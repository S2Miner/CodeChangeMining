[{"original_method":"/**\n     * Creates a new executable that can be used to insert images in the specified rich text area.\n     * \n     * @param rta the execution target\n     */\n    public InsertImageExecutable(RichTextArea rta)\n    {\n        super(rta);\n\n        configHTMLParser = new ImageConfigHTMLParser();\n        configHTMLSerializer = new ImageConfigHTMLSerializer();\n        configJSONParser = new ImageConfigJSONParser();\n        configJSONSerializer = new ImageConfigJSONSerializer();\n    }","id":80000,"modified_method":"/**\n     * Creates a new executable that can be used to insert images in the specified rich text area.\n     * \n     * @param rta the execution target\n     */\n    public InsertImageExecutable(RichTextArea rta)\n    {\n        super(rta);\n\n        configDOMReader = new ImageConfigDOMReader();\n        configDOMWriter = new ImageConfigDOMWriter();\n        configJSONParser = new ImageConfigJSONParser();\n        configJSONSerializer = new ImageConfigJSONSerializer();\n    }","commit_id":"db215cd02e9372542a6640a1a1a4506363fbc0f1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Adds unit tests for the plug-ins to the given test suite.\n     * \n     * @param suite the test suite\n     */\n    private static void addPluginTests(TestSuite suite)\n    {\n        suite.addTestSuite(DefaultPluginFactoryManagerTest.class);\n        suite.addTestSuite(DefaultPluginManagerTest.class);\n        suite.addTestSuite(FocusWidgetUIExtensionTest.class);\n        suite.addTestSuite(HistoryTest.class);\n        suite.addTestSuite(FormatBlockExecutableTest.class);\n        suite.addTestSuite(RemoveFormatExecutableTest.class);\n        suite.addTestSuite(InsertHRExecutableTest.class);\n        suite.addTestSuite(ImageConfigJSONSerializerTest.class);\n        suite.addTestSuite(ImageConfigHTMLSerializerTest.class);\n        suite.addTestSuite(ImageMetaDataExtractorTest.class);\n        suite.addTestSuite(InsertImageExecutableTest.class);\n        suite.addTestSuite(LinkMetaDataExtractorTest.class);\n        suite.addTestSuite(EmptyLinkFilterTest.class);\n        suite.addTestSuite(MacroCallTest.class);\n        suite.addTestSuite(IndentExecutableTest.class);\n        suite.addTestSuite(OutdentExecutableTest.class);\n        suite.addTestSuite(ListBehaviorAdjusterTest.class);\n        suite.addTestSuite(ColorPickerTest.class);\n        suite.addTestSuite(EnableExecutableTest.class);\n        suite.addTestSuite(LinePluginTest.class);\n    }","id":80001,"modified_method":"/**\n     * Adds unit tests for the plug-ins to the given test suite.\n     * \n     * @param suite the test suite\n     */\n    private static void addPluginTests(TestSuite suite)\n    {\n        suite.addTestSuite(DefaultPluginFactoryManagerTest.class);\n        suite.addTestSuite(DefaultPluginManagerTest.class);\n        suite.addTestSuite(FocusWidgetUIExtensionTest.class);\n        suite.addTestSuite(HistoryTest.class);\n        suite.addTestSuite(FormatBlockExecutableTest.class);\n        suite.addTestSuite(RemoveFormatExecutableTest.class);\n        suite.addTestSuite(InsertHRExecutableTest.class);\n        suite.addTestSuite(ImageConfigJSONSerializerTest.class);\n        suite.addTestSuite(ImageConfigDOMWriterTest.class);\n        suite.addTestSuite(ImageMetaDataExtractorTest.class);\n        suite.addTestSuite(InsertImageExecutableTest.class);\n        suite.addTestSuite(LinkMetaDataExtractorTest.class);\n        suite.addTestSuite(EmptyLinkFilterTest.class);\n        suite.addTestSuite(MacroCallTest.class);\n        suite.addTestSuite(IndentExecutableTest.class);\n        suite.addTestSuite(OutdentExecutableTest.class);\n        suite.addTestSuite(ListBehaviorAdjusterTest.class);\n        suite.addTestSuite(ColorPickerTest.class);\n        suite.addTestSuite(EnableExecutableTest.class);\n        suite.addTestSuite(LinePluginTest.class);\n    }","commit_id":"db215cd02e9372542a6640a1a1a4506363fbc0f1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void initNetworkList()\n    {\n        // check for preferred wizard\n        String prefWName = GuiActivator.getResources().\n            getSettingsString(\"preferredAccountWizard\");\n        if(prefWName != null && prefWName.length() > 0)\n            preferredWizardName = prefWName;\n\n        ServiceReference[] accountWizardRefs = null;\n        try\n        {\n            accountWizardRefs = GuiActivator.bundleContext\n                .getServiceReferences(\n                    AccountRegistrationWizard.class.getName(),\n                    null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // this shouldn't happen since we're providing no parameter string\n            // but let's log just in case.\n            logger.error(\n                \"Error while retrieving service refs\", ex);\n            return;\n        }\n\n        // in case we found any, add them in this container.\n        if (accountWizardRefs != null)\n        {\n            logger.debug(\"Found \"\n                         + accountWizardRefs.length\n                         + \" already installed providers.\");\n            for (int i = 0; i < accountWizardRefs.length; i++)\n            {\n                AccountRegistrationWizard wizard\n                    = (AccountRegistrationWizard) GuiActivator.bundleContext\n                        .getService(accountWizardRefs[i]);\n\n                networkComboBox.addItem(wizard);\n\n                // if we have preferred wizard insert it at first position\n                if(preferredWizardName != null\n                    && wizard.getClass().getName().equals(preferredWizardName))\n                    networkComboBox.setSelectedItem(wizard);\n            }\n        }\n    }","id":80002,"modified_method":"private void initNetworkList()\n    {\n        // check for preferred wizard\n        String prefWName = GuiActivator.getResources().\n            getSettingsString(\"preferredAccountWizard\");\n        if(prefWName != null && prefWName.length() > 0)\n            preferredWizardName = prefWName;\n\n        ServiceReference[] accountWizardRefs = null;\n        try\n        {\n            accountWizardRefs = GuiActivator.bundleContext\n                .getServiceReferences(\n                    AccountRegistrationWizard.class.getName(),\n                    null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // this shouldn't happen since we're providing no parameter string\n            // but let's log just in case.\n            logger.error(\n                \"Error while retrieving service refs\", ex);\n            return;\n        }\n\n        // in case we found any, add them in this container.\n        if (accountWizardRefs != null)\n        {\n            logger.debug(\"Found \"\n                         + accountWizardRefs.length\n                         + \" already installed providers.\");\n            \n            // Create a list to sort the wizards\n            ArrayList<AccountRegistrationWizard> list =\n                new ArrayList<AccountRegistrationWizard>();\n            list.ensureCapacity(accountWizardRefs.length);\n            \n            AccountRegistrationWizard prefWiz = null; \n            \n            for (int i = 0; i < accountWizardRefs.length; i++)\n            {\n                AccountRegistrationWizard wizard\n                    = (AccountRegistrationWizard) GuiActivator.bundleContext\n                        .getService(accountWizardRefs[i]);\n\n                list.add(wizard);\n\n                // is it the prefered protocol ?\n                if(preferredWizardName != null\n                    && wizard.getClass().getName().equals(preferredWizardName))\n                {\n                    prefWiz = wizard;\n                }\n            }\n            \n            // Sort the list\n            Collections.sort(list, new Comparator<AccountRegistrationWizard>() {\n                public int compare(AccountRegistrationWizard arg0,\n                        AccountRegistrationWizard arg1)\n                {\n                    return arg0.getProtocolName().compareTo(arg1.getProtocolName());\n                }\n            });\n            \n            // Add the item in the combobox and if\n            // there is a prefered wizard auto select it\n            for (int i=0; i<list.size(); i++)\n            {\n                networkComboBox.addItem(list.get(i));\n            }\n            if (prefWiz != null)\n            {\n                networkComboBox.setSelectedItem(prefWiz);\n            }\n        }\n    }","commit_id":"96449c6619f55a3f36007d4b838b481396a44470","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the byte representation of the image corresponding to the given\n     * identifier.\n     * \n     * @param imageID the identifier of the image\n     * @return the byte representation of the image corresponding to the given\n     * identifier.\n     */\n    public static byte[] getImageInBytes(String imageID) \n    {\n        InputStream in = DictActivator.getResources().\n            getImageInputStream(imageID);\n\n        if (in == null)\n            return null;\n        byte[] image = null;\n        try \n        {\n            image = new byte[in.available()];\n\n            in.read(image);\n        }\n        catch (IOException e) \n        {\n            logger.error(\"Failed to load image:\" + imageID, e);\n        }\n\n        return image;\n    }","id":80003,"modified_method":"/**\n     * Returns the byte representation of the image corresponding to the given\n     * identifier.\n     * \n     * @param imageID the identifier of the image\n     * @return the byte representation of the image corresponding to the given\n     * identifier.\n     */\n    public static byte[] getImageInBytes(String imageID) \n    {\n        InputStream in = IrcActivator.getResources().\n            getImageInputStream(imageID);\n\n        if (in == null)\n            return null;\n        byte[] image = null;\n        try \n        {\n            image = new byte[in.available()];\n\n            in.read(image);\n        }\n        catch (IOException e) \n        {\n            logger.error(\"Failed to load image:\" + imageID, e);\n        }\n\n        return image;\n    }","commit_id":"96449c6619f55a3f36007d4b838b481396a44470","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static boolean isWordStart(CharSequence text, int offset, boolean isCamel) {\n    char prev = offset > 0 ? text.charAt(offset - 1) : 0;\n    char current = text.charAt(offset);\n\n    final boolean firstIsIdentifierPart = Character.isJavaIdentifierPart(prev);\n    final boolean secondIsIdentifierPart = Character.isJavaIdentifierPart(current);\n    if (!firstIsIdentifierPart && secondIsIdentifierPart && !SPECIAL_NON_ID_SYMBOLS.contains(prev)) {\n      return true;\n    }\n\n    if (isCamel && firstIsIdentifierPart && secondIsIdentifierPart && isHumpBound(text, offset, true)) {\n      return true;\n    }\n    \n    if (Character.isWhitespace(current)) {\n      return false;\n    }\n    else if (Character.isWhitespace(prev)) {\n      return true;\n    }\n    else if (SPECIAL_NON_ID_SYMBOLS.contains(current)) {\n      return false;\n    }\n    else {\n      return firstIsIdentifierPart && !secondIsIdentifierPart;\n    }\n  }","id":80004,"modified_method":"public static boolean isWordStart(CharSequence text, int offset, boolean isCamel) {\n    char prev = offset > 0 ? text.charAt(offset - 1) : 0;\n    char current = text.charAt(offset);\n\n    final boolean firstIsIdentifierPart = Character.isJavaIdentifierPart(prev);\n    final boolean secondIsIdentifierPart = Character.isJavaIdentifierPart(current);\n    if (!firstIsIdentifierPart && secondIsIdentifierPart) {\n      return true;\n    }\n\n    if (isCamel && firstIsIdentifierPart && secondIsIdentifierPart && isHumpBound(text, offset, true)) {\n      return true;\n    }\n\n    return (Character.isWhitespace(prev) || firstIsIdentifierPart) &&\n           !Character.isWhitespace(current) && !secondIsIdentifierPart;\n  }","commit_id":"df32f16d402e0d2ca5517c68b939d17d73e57125","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\n\t\t * (typically) moving toward the beginning of the glyphs array. */\n\t\tpublic int getWrapIndex (Array<Glyph> glyphs, int start) {\n\t\t\tchar ch = (char)glyphs.get(start).id;\n\t\t\tif (isWhitespace(ch)) return start;\n\t\t\tfor (int i = start - 1; i >= 1; i--) {\n\t\t\t\tch = (char)glyphs.get(i).id;\n\t\t\t\tif (isWhitespace(ch)) return i;\n\t\t\t\tif (isBreakChar(ch)) return i + 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}","id":80005,"modified_method":"/** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and\n\t\t * (typically) moving toward the beginning of the glyphs array. */\n\t\tpublic int getWrapIndex (Array<Glyph> glyphs, int start) {\n\t\t\tint i = start - 1;\n\t\t\tfor (; i >= 1; i--)\n\t\t\t\tif (!isWhitespace((char)glyphs.get(i).id)) break;\n\t\t\tfor (; i >= 1; i--) {\n\t\t\t\tchar ch = (char)glyphs.get(i).id;\n\t\t\t\tif (isWhitespace(ch) || isBreakChar(ch)) return i + 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}","commit_id":"ee42693da067da7c5ddd747f051c1423d262cb96","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void render () {\n\t\t// red.a = (red.a + Gdx.graphics.getDeltaTime() * 0.1f) % 1;\n\n\t\tint viewHeight = Gdx.graphics.getHeight();\n\n\t\tGdx.gl.glClearColor(0, 0, 0, 1);\n\t\tGdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);\n\n\t\t// Test wrapping or truncation with the font directly.\n\t\tif (true) {\n\t\t\t// BitmapFont font = label.getStyle().font;\n\t\t\tBitmapFont font = this.font;\n\t\t\tfont.getRegion().getTexture().setFilter(TextureFilter.Nearest, TextureFilter.Nearest);\n\n\t\t\tfont.getData().setScale(2f);\n\t\t\trenderer.begin(ShapeRenderer.ShapeType.Line);\n\t\t\trenderer.setColor(0, 1, 0, 1);\n\t\t\tfloat w = Gdx.input.getX();\n\t\t\t// w = 855;\n\t\t\trenderer.rect(10, 10, w, 500);\n\t\t\trenderer.end();\n\n\t\t\tspriteBatch.begin();\n\t\t\tString text = \"your new\";\n\t\t\t// text = \"How quickly [RED]daft jumping zebras vex.\";\n\t\t\t// text = \"Another font wrap is-sue, this time with    multiple whitespace characters.\";\n\t\t\ttext = \"test with AGWlWi AGWlWi issue\";\n\t\t\tif (true) { // Test wrap.\n\t\t\t\tlayout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, true, null);\n\t\t\t} else { // Test truncation.\n\t\t\t\tlayout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, false, \"...\");\n\t\t\t}\n\t\t\tfloat meowy = (500 / 2 + layout.height / 2 + 5);\n\t\t\tfont.draw(spriteBatch, layout, 10, 10 + meowy);\n\t\t\tspriteBatch.end();\n\n\t\t\trenderer.begin(ShapeRenderer.ShapeType.Line);\n\t\t\trenderer.setColor(0, 1, 0, 1);\n\t\t\tfor (int i = 0, n = layout.runs.size; i < n; i++) {\n\t\t\t\tGlyphRun r = layout.runs.get(i);\n\t\t\t\trenderer.rect(10 + r.x, 10 + meowy + r.y, r.width, -font.getLineHeight());\n\t\t\t}\n\t\t\trenderer.end();\n\t\t\tfont.getData().setScale(1f);\n\t\t\treturn;\n\t\t}\n\n\t\t// Test wrapping with label.\n\t\tif (true) {\n\t\t\tlabel.debug();\n\t\t\tlabel.getStyle().font = font;\n\t\t\tlabel.setStyle(label.getStyle());\n\t\t\tlabel.setText(\"How quickly [RED]daft jumping zebras vex.\");\n\t\t\tlabel.setWrap(true);\n\t\t\tlabel.setEllipsis(true);\n\t\t\tlabel.setAlignment(Align.center, Align.right);\n\t\t\tlabel.setWidth(Gdx.input.getX() - label.getX());\n\t\t\tlabel.setHeight(label.getPrefHeight());\n\t\t} else {\n\t\t\t// Test various font features.\n\t\t\tspriteBatch.begin();\n\n\t\t\tString text = \"Sphinx of black quartz, judge my vow.\";\n\t\t\tfont.setColor(Color.RED);\n\n\t\t\tfloat x = 100, y = 20;\n\t\t\tfloat alignmentWidth;\n\n\t\t\tif (false) {\n\t\t\t\talignmentWidth = 0;\n\t\t\t\tfont.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, false);\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\talignmentWidth = 280;\n\t\t\t\tfont.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, true);\n\t\t\t}\n\n\t\t\tfont.draw(spriteBatch, \"[\", 50, 60, 100, Align.left, true);\n\t\t\tfont.getData().markupEnabled = true;\n\t\t\tfont.draw(spriteBatch, \"[\", 100, 60, 100, Align.left, true);\n\t\t\tfont.getData().markupEnabled = false;\n\n\t\t\t// 'R' and 'p' are in different pages\n\t\t\tString txt2 = \"this font uses \" + multiPageFont.getRegions().size + \" texture pages: RpRpRpRpRpNM\";\n\t\t\tspriteBatch.renderCalls = 0;\n\n\t\t\t// regular draw function\n\t\t\tmultiPageFont.setColor(Color.BLUE);\n\t\t\tmultiPageFont.draw(spriteBatch, txt2, 10, 100);\n\n\t\t\t// expert usage.. drawing with bitmap font cache\n\t\t\tBitmapFontCache cache = multiPageFont.getCache();\n\t\t\tcache.clear();\n\t\t\tcache.setColor(Color.BLACK);\n\t\t\tcache.setText(txt2, 10, 50);\n\t\t\tcache.setColors(Color.PINK, 3, 6);\n\t\t\tcache.setColors(Color.ORANGE, 9, 12);\n\t\t\tcache.setColors(Color.GREEN, 16, txt2.length());\n\t\t\tcache.draw(spriteBatch, 5, txt2.length() - 5);\n\n\t\t\tcache.clear();\n\t\t\tcache.setColor(Color.BLACK);\n\t\t\tfloat textX = 10;\n\t\t\ttextX += cache.setText(\"[black] \", textX, 150).width;\n\t\t\tmultiPageFont.getData().markupEnabled = true;\n\t\t\ttextX += cache.addText(\"[[[PINK]pink[]] \", textX, 150).width;\n\t\t\ttextX += cache.addText(\"[PERU][[peru] \", textX, 150).width;\n\t\t\tcache.setColor(Color.GREEN);\n\t\t\ttextX += cache.addText(\"green \", textX, 150).width;\n\t\t\ttextX += cache.addText(\"[#A52A2A]br[#A52A2ADF]ow[#A52A2ABF]n f[#A52A2A9F]ad[#A52A2A7F]in[#A52A2A5F]g o[#A52A2A3F]ut \",\n\t\t\t\ttextX, 150).width;\n\t\t\tmultiPageFont.getData().markupEnabled = false;\n\n\t\t\tcache.draw(spriteBatch);\n\n\t\t\t// tinting\n\t\t\tcache.tint(new Color(1f, 1f, 1f, 0.3f));\n\t\t\tcache.translate(0f, 40f);\n\t\t\tcache.draw(spriteBatch);\n\n\t\t\tspriteBatch.end();\n\t\t\t// System.out.println(spriteBatch.renderCalls);\n\n\t\t\trenderer.begin(ShapeType.Line);\n\t\t\trenderer.setColor(Color.BLACK);\n\t\t\trenderer.rect(x, viewHeight - y - 200, alignmentWidth, 200);\n\t\t\trenderer.end();\n\t\t}\n\n\t\tstage.act(Gdx.graphics.getDeltaTime());\n\t\tstage.draw();\n\t}","id":80006,"modified_method":"@Override\n\tpublic void render () {\n\t\t// red.a = (red.a + Gdx.graphics.getDeltaTime() * 0.1f) % 1;\n\n\t\tint viewHeight = Gdx.graphics.getHeight();\n\n\t\tGdx.gl.glClearColor(0, 0, 0, 1);\n\t\tGdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);\n\n\t\t// Test wrapping or truncation with the font directly.\n\t\tif (true) {\n\t\t\t// BitmapFont font = label.getStyle().font;\n\t\t\tBitmapFont font = this.font;\n\t\t\tfont.getRegion().getTexture().setFilter(TextureFilter.Nearest, TextureFilter.Nearest);\n\n\t\t\tfont.getData().setScale(2f);\n\t\t\trenderer.begin(ShapeRenderer.ShapeType.Line);\n\t\t\trenderer.setColor(0, 1, 0, 1);\n\t\t\tfloat w = Gdx.input.getX();\n\t\t\t// w = 855;\n\t\t\trenderer.rect(10, 10, w, 500);\n\t\t\trenderer.end();\n\n\t\t\tspriteBatch.begin();\n\t\t\tString text = \"your new\";\n\t\t\t// text = \"How quickly [RED]daft jumping zebras vex.\";\n\t\t\t// text = \"Another font wrap is-sue, this time with    multiple whitespace characters.\";\n\t\t\ttext = \"test with AGWlWi      AGWlWi issue\";\n\t\t\tif (true) { // Test wrap.\n\t\t\t\tlayout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, true, null);\n\t\t\t} else { // Test truncation.\n\t\t\t\tlayout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, false, \"...\");\n\t\t\t}\n\t\t\tfloat meowy = (500 / 2 + layout.height / 2 + 5);\n\t\t\tfont.draw(spriteBatch, layout, 10, 10 + meowy);\n\t\t\tspriteBatch.end();\n\n\t\t\trenderer.begin(ShapeRenderer.ShapeType.Line);\n\t\t\trenderer.setColor(0, 1, 0, 1);\n\t\t\tfor (int i = 0, n = layout.runs.size; i < n; i++) {\n\t\t\t\tGlyphRun r = layout.runs.get(i);\n\t\t\t\trenderer.rect(10 + r.x, 10 + meowy + r.y, r.width, -font.getLineHeight());\n\t\t\t}\n\t\t\trenderer.end();\n\t\t\tfont.getData().setScale(1f);\n\t\t\treturn;\n\t\t}\n\n\t\t// Test wrapping with label.\n\t\tif (true) {\n\t\t\tlabel.debug();\n\t\t\tlabel.getStyle().font = font;\n\t\t\tlabel.setStyle(label.getStyle());\n\t\t\tlabel.setText(\"How quickly [RED]daft jumping zebras vex.\");\n\t\t\tlabel.setWrap(true);\n\t\t\tlabel.setEllipsis(true);\n\t\t\tlabel.setAlignment(Align.center, Align.right);\n\t\t\tlabel.setWidth(Gdx.input.getX() - label.getX());\n\t\t\tlabel.setHeight(label.getPrefHeight());\n\t\t} else {\n\t\t\t// Test various font features.\n\t\t\tspriteBatch.begin();\n\n\t\t\tString text = \"Sphinx of black quartz, judge my vow.\";\n\t\t\tfont.setColor(Color.RED);\n\n\t\t\tfloat x = 100, y = 20;\n\t\t\tfloat alignmentWidth;\n\n\t\t\tif (false) {\n\t\t\t\talignmentWidth = 0;\n\t\t\t\tfont.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, false);\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\talignmentWidth = 280;\n\t\t\t\tfont.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, true);\n\t\t\t}\n\n\t\t\tfont.draw(spriteBatch, \"[\", 50, 60, 100, Align.left, true);\n\t\t\tfont.getData().markupEnabled = true;\n\t\t\tfont.draw(spriteBatch, \"[\", 100, 60, 100, Align.left, true);\n\t\t\tfont.getData().markupEnabled = false;\n\n\t\t\t// 'R' and 'p' are in different pages\n\t\t\tString txt2 = \"this font uses \" + multiPageFont.getRegions().size + \" texture pages: RpRpRpRpRpNM\";\n\t\t\tspriteBatch.renderCalls = 0;\n\n\t\t\t// regular draw function\n\t\t\tmultiPageFont.setColor(Color.BLUE);\n\t\t\tmultiPageFont.draw(spriteBatch, txt2, 10, 100);\n\n\t\t\t// expert usage.. drawing with bitmap font cache\n\t\t\tBitmapFontCache cache = multiPageFont.getCache();\n\t\t\tcache.clear();\n\t\t\tcache.setColor(Color.BLACK);\n\t\t\tcache.setText(txt2, 10, 50);\n\t\t\tcache.setColors(Color.PINK, 3, 6);\n\t\t\tcache.setColors(Color.ORANGE, 9, 12);\n\t\t\tcache.setColors(Color.GREEN, 16, txt2.length());\n\t\t\tcache.draw(spriteBatch, 5, txt2.length() - 5);\n\n\t\t\tcache.clear();\n\t\t\tcache.setColor(Color.BLACK);\n\t\t\tfloat textX = 10;\n\t\t\ttextX += cache.setText(\"[black] \", textX, 150).width;\n\t\t\tmultiPageFont.getData().markupEnabled = true;\n\t\t\ttextX += cache.addText(\"[[[PINK]pink[]] \", textX, 150).width;\n\t\t\ttextX += cache.addText(\"[PERU][[peru] \", textX, 150).width;\n\t\t\tcache.setColor(Color.GREEN);\n\t\t\ttextX += cache.addText(\"green \", textX, 150).width;\n\t\t\ttextX += cache.addText(\"[#A52A2A]br[#A52A2ADF]ow[#A52A2ABF]n f[#A52A2A9F]ad[#A52A2A7F]in[#A52A2A5F]g o[#A52A2A3F]ut \",\n\t\t\t\ttextX, 150).width;\n\t\t\tmultiPageFont.getData().markupEnabled = false;\n\n\t\t\tcache.draw(spriteBatch);\n\n\t\t\t// tinting\n\t\t\tcache.tint(new Color(1f, 1f, 1f, 0.3f));\n\t\t\tcache.translate(0f, 40f);\n\t\t\tcache.draw(spriteBatch);\n\n\t\t\tspriteBatch.end();\n\t\t\t// System.out.println(spriteBatch.renderCalls);\n\n\t\t\trenderer.begin(ShapeType.Line);\n\t\t\trenderer.setColor(Color.BLACK);\n\t\t\trenderer.rect(x, viewHeight - y - 200, alignmentWidth, 200);\n\t\t\trenderer.end();\n\t\t}\n\n\t\tstage.act(Gdx.graphics.getDeltaTime());\n\t\tstage.draw();\n\t}","commit_id":"ee42693da067da7c5ddd747f051c1423d262cb96","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param color The default color to use for the text (the BitmapFont {@link BitmapFont#getColor() color} is not used). If\n\t *           {@link BitmapFontData#markupEnabled} is true, color markup tags in the specified string may change the color for\n\t *           portions of the text.\n\t * @param targetWidth The width used for alignment, line wrapping, and truncation. May be zero if those features are not used.\n\t * @param truncate If not null and the width of the glyphs exceed targetWidth, the glyphs are truncated and the glyphs for the\n\t *           specified truncate string are placed at the end. Empty string can be used to truncate without adding glyphs.\n\t *           Truncate should not be used with text that contains multiple lines. Wrap is ignored if truncate is not null. */\n\tpublic void setText (BitmapFont font, CharSequence str, int start, int end, Color color, float targetWidth, int halign,\n\t\tboolean wrap, String truncate) {\n\t\tif (truncate != null)\n\t\t\twrap = true; // Causes truncate code to run, doesn't actually cause wrapping.\n\t\telse if (targetWidth <= font.data.spaceWidth) //\n\t\t\twrap = false; // Avoid one line per character, which is very inefficient.\n\n\t\tBitmapFontData fontData = font.data;\n\t\tboolean markupEnabled = fontData.markupEnabled;\n\n\t\tPool<GlyphRun> glyphRunPool = Pools.get(GlyphRun.class);\n\t\tArray<GlyphRun> runs = this.runs;\n\t\tglyphRunPool.freeAll(runs);\n\t\truns.clear();\n\n\t\tfloat x = 0, y = 0, width = 0;\n\t\tint lines = 0;\n\n\t\tArray<Color> colorStack = GlyphLayout.colorStack;\n\t\tColor nextColor = color;\n\t\tcolorStack.add(color);\n\t\tPool<Color> colorPool = Pools.get(Color.class);\n\n\t\tint runStart = start;\n\t\touter:\n\t\twhile (true) {\n\t\t\t// Each run is delimited by newline or left square bracket.\n\t\t\tint runEnd = -1;\n\t\t\tboolean newline = false;\n\t\t\tif (start == end) {\n\t\t\t\tif (runStart == end) break; // End of string with no run to process, we're done.\n\t\t\t\trunEnd = end; // End of string, process last run.\n\t\t\t} else {\n\t\t\t\tswitch (str.charAt(start++)) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\t// End of line.\n\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\tnewline = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\t// Possible color tag.\n\t\t\t\t\tif (markupEnabled) {\n\t\t\t\t\t\tint length = parseColorMarkup(str, start, end, colorPool);\n\t\t\t\t\t\tif (length >= 0) {\n\t\t\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\t\t\tstart += length + 1;\n\t\t\t\t\t\t\tnextColor = colorStack.peek();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (runEnd != -1) {\n\t\t\t\tif (runEnd != runStart) { // Can happen (eg) when a color tag is at text start.\n\t\t\t\t\t// Store the run that has ended.\n\t\t\t\t\tGlyphRun run = glyphRunPool.obtain();\n\t\t\t\t\truns.add(run);\n\t\t\t\t\trun.color.set(color);\n\t\t\t\t\trun.x = x;\n\t\t\t\t\trun.y = y;\n\t\t\t\t\tfontData.getGlyphs(run, str, runStart, runEnd);\n\n\t\t\t\t\t// Compute the run width, wrap if necessary, and position the run.\n\t\t\t\t\tfloat[] xAdvances = run.xAdvances.items;\n\t\t\t\t\tfor (int i = 0, n = run.xAdvances.size; i < n; i++) {\n\t\t\t\t\t\tfloat xAdvance = xAdvances[i];\n\t\t\t\t\t\tx += xAdvance;\n\n\t\t\t\t\t\t// Don't wrap if the glyph would fit with just its width (no xadvance or kerning).\n\t\t\t\t\t\tif (wrap && x > targetWidth && i > 1 && x - xAdvance //\n\t\t\t\t\t\t\t+ (run.glyphs.get(i - 1).xoffset + run.glyphs.get(i - 1).width) * fontData.scaleX - 0.0001f > targetWidth) {\n\n\t\t\t\t\t\t\tif (truncate != null) {\n\t\t\t\t\t\t\t\ttruncate(fontData, run, targetWidth, truncate, i, glyphRunPool);\n\t\t\t\t\t\t\t\tx = run.x + run.width;\n\t\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint wrapIndex = fontData.getWrapIndex(run.glyphs, i - 1);\n\t\t\t\t\t\t\tif ((run.x == 0 && wrapIndex == 0) // Require at least one glyph per line.\n\t\t\t\t\t\t\t\t|| wrapIndex >= run.glyphs.size) { // Wrap at least the glyph that didn't fit.\n\t\t\t\t\t\t\t\twrapIndex = i - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tGlyphRun next = wrap(fontData, run, glyphRunPool, wrapIndex, i);\n\t\t\t\t\t\t\truns.add(next);\n\n\t\t\t\t\t\t\t// Start the loop over with the new run on the next line.\n\t\t\t\t\t\t\twidth = Math.max(width, run.x + run.width);\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty += fontData.down;\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t\tnext.x = 0;\n\t\t\t\t\t\t\tnext.y = y;\n\t\t\t\t\t\t\ti = -1;\n\t\t\t\t\t\t\tn = next.xAdvances.size;\n\t\t\t\t\t\t\txAdvances = next.xAdvances.items;\n\t\t\t\t\t\t\trun = next;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\trun.width += xAdvance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (newline) {\n\t\t\t\t\t// Next run will be on the next line.\n\t\t\t\t\twidth = Math.max(width, x);\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += fontData.down;\n\t\t\t\t\tlines++;\n\t\t\t\t}\n\n\t\t\t\trunStart = start;\n\t\t\t\tcolor = nextColor;\n\t\t\t}\n\t\t}\n\t\twidth = Math.max(width, x);\n\n\t\tfor (int i = 1, n = colorStack.size; i < n; i++)\n\t\t\tcolorPool.free(colorStack.get(i));\n\t\tcolorStack.clear();\n\n\t\t// Align runs to center or right of targetWidth.\n\t\tif ((halign & Align.left) == 0) { // Not left aligned, so must be center or right aligned.\n\t\t\tboolean center = (halign & Align.center) != 0;\n\t\t\tfloat lineWidth = 0, lineY = Integer.MIN_VALUE;\n\t\t\tint lineStart = 0, n = runs.size;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tGlyphRun run = runs.get(i);\n\t\t\t\tif (run.y != lineY) {\n\t\t\t\t\tlineY = run.y;\n\t\t\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\t\t\tif (center) shift /= 2;\n\t\t\t\t\twhile (lineStart < i)\n\t\t\t\t\t\truns.get(lineStart++).x += shift;\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\t}\n\t\t\t\tlineWidth += run.width;\n\t\t\t}\n\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\tif (center) shift /= 2;\n\t\t\twhile (lineStart < n)\n\t\t\t\truns.get(lineStart++).x += shift;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.height = fontData.capHeight + lines * fontData.lineHeight;\n\t}","id":80007,"modified_method":"/** @param color The default color to use for the text (the BitmapFont {@link BitmapFont#getColor() color} is not used). If\n\t *           {@link BitmapFontData#markupEnabled} is true, color markup tags in the specified string may change the color for\n\t *           portions of the text.\n\t * @param targetWidth The width used for alignment, line wrapping, and truncation. May be zero if those features are not used.\n\t * @param truncate If not null and the width of the glyphs exceed targetWidth, the glyphs are truncated and the glyphs for the\n\t *           specified truncate string are placed at the end. Empty string can be used to truncate without adding glyphs.\n\t *           Truncate should not be used with text that contains multiple lines. Wrap is ignored if truncate is not null. */\n\tpublic void setText (BitmapFont font, CharSequence str, int start, int end, Color color, float targetWidth, int halign,\n\t\tboolean wrap, String truncate) {\n\t\tif (truncate != null)\n\t\t\twrap = true; // Causes truncate code to run, doesn't actually cause wrapping.\n\t\telse if (targetWidth <= font.data.spaceWidth) //\n\t\t\twrap = false; // Avoid one line per character, which is very inefficient.\n\n\t\tBitmapFontData fontData = font.data;\n\t\tboolean markupEnabled = fontData.markupEnabled;\n\n\t\tPool<GlyphRun> glyphRunPool = Pools.get(GlyphRun.class);\n\t\tArray<GlyphRun> runs = this.runs;\n\t\tglyphRunPool.freeAll(runs);\n\t\truns.clear();\n\n\t\tfloat x = 0, y = 0, width = 0;\n\t\tint lines = 0;\n\n\t\tArray<Color> colorStack = GlyphLayout.colorStack;\n\t\tColor nextColor = color;\n\t\tcolorStack.add(color);\n\t\tPool<Color> colorPool = Pools.get(Color.class);\n\n\t\tint runStart = start;\n\t\touter:\n\t\twhile (true) {\n\t\t\t// Each run is delimited by newline or left square bracket.\n\t\t\tint runEnd = -1;\n\t\t\tboolean newline = false;\n\t\t\tif (start == end) {\n\t\t\t\tif (runStart == end) break; // End of string with no run to process, we're done.\n\t\t\t\trunEnd = end; // End of string, process last run.\n\t\t\t} else {\n\t\t\t\tswitch (str.charAt(start++)) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\t// End of line.\n\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\tnewline = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\t// Possible color tag.\n\t\t\t\t\tif (markupEnabled) {\n\t\t\t\t\t\tint length = parseColorMarkup(str, start, end, colorPool);\n\t\t\t\t\t\tif (length >= 0) {\n\t\t\t\t\t\t\trunEnd = start - 1;\n\t\t\t\t\t\t\tstart += length + 1;\n\t\t\t\t\t\t\tnextColor = colorStack.peek();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (runEnd != -1) {\n\t\t\t\tif (runEnd != runStart) { // Can happen (eg) when a color tag is at text start.\n\t\t\t\t\t// Store the run that has ended.\n\t\t\t\t\tGlyphRun run = glyphRunPool.obtain();\n\t\t\t\t\truns.add(run);\n\t\t\t\t\trun.color.set(color);\n\t\t\t\t\trun.x = x;\n\t\t\t\t\trun.y = y;\n\t\t\t\t\tfontData.getGlyphs(run, str, runStart, runEnd);\n\n\t\t\t\t\t// Compute the run width, wrap if necessary, and position the run.\n\t\t\t\t\tfloat[] xAdvances = run.xAdvances.items;\n\t\t\t\t\tfor (int i = 0, n = run.xAdvances.size; i < n; i++) {\n\t\t\t\t\t\tfloat xAdvance = xAdvances[i];\n\t\t\t\t\t\tx += xAdvance;\n\n\t\t\t\t\t\t// Don't wrap if the glyph would fit with just its width (no xadvance or kerning).\n\t\t\t\t\t\tif (wrap && x > targetWidth && i > 1 && x - xAdvance //\n\t\t\t\t\t\t\t+ (run.glyphs.get(i - 1).xoffset + run.glyphs.get(i - 1).width) * fontData.scaleX - 0.0001f > targetWidth) {\n\n\t\t\t\t\t\t\tif (truncate != null) {\n\t\t\t\t\t\t\t\ttruncate(fontData, run, targetWidth, truncate, i, glyphRunPool);\n\t\t\t\t\t\t\t\tx = run.x + run.width;\n\t\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint wrapIndex = fontData.getWrapIndex(run.glyphs, i);\n\t\t\t\t\t\t\tif ((run.x == 0 && wrapIndex == 0) // Require at least one glyph per line.\n\t\t\t\t\t\t\t\t|| wrapIndex >= run.glyphs.size) { // Wrap at least the glyph that didn't fit.\n\t\t\t\t\t\t\t\twrapIndex = i - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tGlyphRun next = wrap(fontData, run, glyphRunPool, wrapIndex, i);\n\t\t\t\t\t\t\truns.add(next);\n\n\t\t\t\t\t\t\t// Start the loop over with the new run on the next line.\n\t\t\t\t\t\t\twidth = Math.max(width, run.x + run.width);\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty += fontData.down;\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t\tnext.x = 0;\n\t\t\t\t\t\t\tnext.y = y;\n\t\t\t\t\t\t\ti = -1;\n\t\t\t\t\t\t\tn = next.xAdvances.size;\n\t\t\t\t\t\t\txAdvances = next.xAdvances.items;\n\t\t\t\t\t\t\trun = next;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\trun.width += xAdvance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (newline) {\n\t\t\t\t\t// Next run will be on the next line.\n\t\t\t\t\twidth = Math.max(width, x);\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += fontData.down;\n\t\t\t\t\tlines++;\n\t\t\t\t}\n\n\t\t\t\trunStart = start;\n\t\t\t\tcolor = nextColor;\n\t\t\t}\n\t\t}\n\t\twidth = Math.max(width, x);\n\n\t\tfor (int i = 1, n = colorStack.size; i < n; i++)\n\t\t\tcolorPool.free(colorStack.get(i));\n\t\tcolorStack.clear();\n\n\t\t// Align runs to center or right of targetWidth.\n\t\tif ((halign & Align.left) == 0) { // Not left aligned, so must be center or right aligned.\n\t\t\tboolean center = (halign & Align.center) != 0;\n\t\t\tfloat lineWidth = 0, lineY = Integer.MIN_VALUE;\n\t\t\tint lineStart = 0, n = runs.size;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tGlyphRun run = runs.get(i);\n\t\t\t\tif (run.y != lineY) {\n\t\t\t\t\tlineY = run.y;\n\t\t\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\t\t\tif (center) shift /= 2;\n\t\t\t\t\twhile (lineStart < i)\n\t\t\t\t\t\truns.get(lineStart++).x += shift;\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\t}\n\t\t\t\tlineWidth += run.width;\n\t\t\t}\n\t\t\tfloat shift = targetWidth - lineWidth;\n\t\t\tif (center) shift /= 2;\n\t\t\twhile (lineStart < n)\n\t\t\t\truns.get(lineStart++).x += shift;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.height = fontData.capHeight + lines * fontData.lineHeight;\n\t}","commit_id":"ee42693da067da7c5ddd747f051c1423d262cb96","url":"https://github.com/libgdx/libgdx"},{"original_method":"private GlyphRun wrap (BitmapFontData fontData, GlyphRun first, Pool<GlyphRun> glyphRunPool, int wrapIndex, int widthIndex) {\n\t\tGlyphRun second = glyphRunPool.obtain();\n\t\tsecond.color.set(first.color);\n\t\tint glyphCount = first.glyphs.size;\n\n\t\t// Determine index where first run ends, ignoring whitespace before the wrap index.\n\t\tint endIndex = wrapIndex;\n\t\tfor (; endIndex > 0; endIndex--)\n\t\t\tif (!fontData.isWhitespace((char)first.glyphs.get(endIndex - 1).id)) break;\n\n\t\t// Determine index where second run starts, ignoring whitespace after the wrap index.\n\t\tint startIndex = wrapIndex;\n\t\tfor (; startIndex < glyphCount; startIndex++)\n\t\t\tif (!fontData.isWhitespace((char)first.glyphs.get(startIndex).id)) break;\n\n\t\t// Copy wrapped glyphs and xAdvances to second run.\n\t\tif (startIndex < glyphCount) {\n\t\t\tsecond.glyphs.addAll(first.glyphs, startIndex, glyphCount - startIndex);\n\t\t\tsecond.xAdvances.add(-second.glyphs.first().xoffset * fontData.scaleX - fontData.padLeft);\n\t\t\tsecond.xAdvances.addAll(first.xAdvances, startIndex + 1, first.xAdvances.size - (startIndex + 1));\n\t\t}\n\n\t\t// Increase first run width up to the end index.\n\t\twhile (widthIndex < endIndex)\n\t\t\tfirst.width += first.xAdvances.get(widthIndex++);\n\n\t\t// Reduce first run width by the wrapped glyphs that have contributed to the width.\n\t\twhile (widthIndex > endIndex + 1)\n\t\t\tfirst.width -= first.xAdvances.get(--widthIndex);\n\n\t\tif (endIndex == 0) {\n\t\t\t// If the first run is now empty, remove it.\n\t\t\tglyphRunPool.free(first);\n\t\t\truns.pop();\n\t\t} else {\n\t\t\t// Truncate wrapped glyphs from first run.\n\t\t\tfirst.glyphs.truncate(endIndex);\n\t\t\tfirst.xAdvances.truncate(endIndex + 1);\n\t\t\tadjustLastGlyph(fontData, first);\n\t\t}\n\t\treturn second;\n\t}","id":80008,"modified_method":"private GlyphRun wrap (BitmapFontData fontData, GlyphRun first, Pool<GlyphRun> glyphRunPool, int wrapIndex, int widthIndex) {\n\t\tGlyphRun second = glyphRunPool.obtain();\n\t\tsecond.color.set(first.color);\n\t\tint glyphCount = first.glyphs.size;\n\n\t\t// Copy wrapped glyphs and xAdvances to second run.\n\t\tif (wrapIndex < glyphCount) {\n\t\t\tsecond.glyphs.addAll(first.glyphs, wrapIndex, glyphCount - wrapIndex);\n\t\t\t// second.xAdvances.add(-second.glyphs.first().xoffset * fontData.scaleX - fontData.padLeft);\n\t\t\tsecond.xAdvances.add(-second.glyphs.first().xoffset * fontData.scaleX - fontData.padLeft);\n\t\t\tsecond.xAdvances.addAll(first.xAdvances, wrapIndex + 1, first.xAdvances.size - (wrapIndex + 1));\n\t\t}\n\n\t\t// Increase first run width up to the end index.\n\t\twhile (widthIndex < wrapIndex)\n\t\t\tfirst.width += first.xAdvances.get(widthIndex++);\n\n\t\t// Reduce first run width by the wrapped glyphs that have contributed to the width.\n\t\twhile (widthIndex > wrapIndex + 1)\n\t\t\tfirst.width -= first.xAdvances.get(--widthIndex);\n\n\t\tif (wrapIndex == 0) {\n\t\t\t// If the first run is now empty, remove it.\n\t\t\tglyphRunPool.free(first);\n\t\t\truns.pop();\n\t\t} else {\n\t\t\t// Truncate wrapped glyphs from first run.\n\t\t\tfirst.glyphs.truncate(wrapIndex);\n\t\t\tfirst.xAdvances.truncate(wrapIndex + 1);\n\t\t\tadjustLastGlyph(fontData, first);\n\t\t}\n\t\treturn second;\n\t}","commit_id":"ee42693da067da7c5ddd747f051c1423d262cb96","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n    public Query toQuery(QueryParseContext parseContext) throws QueryParsingException, IOException {\n        if (filters.isEmpty()) {\n            // no filters provided, this should be ignored upstream\n            return null;\n        }\n\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder f : filters) {\n            query.add(f.toQuery(parseContext), Occur.MUST);\n        }\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n        return query;\n    }","id":80009,"modified_method":"@Override\n    public Query toQuery(QueryParseContext parseContext) throws QueryParsingException, IOException {\n        if (filters.isEmpty()) {\n            // no filters provided, this should be ignored upstream\n            return null;\n        }\n\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder f : filters) {\n            Query innerQuery = f.toQuery(parseContext);\n            // ignore queries that are null\n            if (innerQuery != null) {\n                query.add(innerQuery, Occur.MUST);\n            }\n        }\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n        return query;\n    }","commit_id":"f2573da77b73eaf031f236d5a6af0be4b5f431ee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Query createExpectedQuery(AndQueryBuilder queryBuilder, QueryParseContext context) throws QueryParsingException, IOException {\n        if (queryBuilder.filters().isEmpty()) {\n            return null;\n        }\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder subQuery : queryBuilder.filters()) {\n            query.add(subQuery.toQuery(context), Occur.MUST);\n        }\n        return query;\n    }","id":80010,"modified_method":"@Override\n    protected Query createExpectedQuery(AndQueryBuilder queryBuilder, QueryParseContext context) throws QueryParsingException, IOException {\n        if (queryBuilder.filters().isEmpty()) {\n            return null;\n        }\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder subQuery : queryBuilder.filters()) {\n            Query innerQuery = subQuery.toQuery(context);\n            if (innerQuery != null) {\n                query.add(innerQuery, Occur.MUST);\n            }\n        }\n        return query;\n    }","commit_id":"f2573da77b73eaf031f236d5a6af0be4b5f431ee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query toQuery(QueryParseContext parseContext) throws QueryParsingException, IOException {\n        if (filters.isEmpty()) {\n            // no filters provided, this should be ignored upstream\n            return null;\n        }\n\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder f : filters) {\n            query.add(f.toQuery(parseContext), Occur.SHOULD);\n        }\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n        return query;\n    }","id":80011,"modified_method":"@Override\n    public Query toQuery(QueryParseContext parseContext) throws QueryParsingException, IOException {\n        if (filters.isEmpty()) {\n            // no filters provided, this should be ignored upstream\n            return null;\n        }\n\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder f : filters) {\n            Query innerQuery = f.toQuery(parseContext);\n            // ignore queries that are null\n            if (innerQuery != null) {\n                query.add(innerQuery, Occur.SHOULD);\n            }\n        }\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n        return query;\n    }","commit_id":"f2573da77b73eaf031f236d5a6af0be4b5f431ee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Query createExpectedQuery(OrQueryBuilder queryBuilder, QueryParseContext context) throws QueryParsingException, IOException {\n        if (queryBuilder.filters().isEmpty()) {\n            return null;\n        }\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder subQuery : queryBuilder.filters()) {\n            query.add(subQuery.toQuery(context), Occur.SHOULD);\n        }\n        return query;\n    }","id":80012,"modified_method":"@Override\n    protected Query createExpectedQuery(OrQueryBuilder queryBuilder, QueryParseContext context) throws QueryParsingException, IOException {\n        if (queryBuilder.filters().isEmpty()) {\n            return null;\n        }\n        BooleanQuery query = new BooleanQuery();\n        for (QueryBuilder subQuery : queryBuilder.filters()) {\n            Query innerQuery = subQuery.toQuery(context);\n            // ignore queries that are null\n            if (innerQuery != null) {\n                query.add(innerQuery, Occur.SHOULD);\n            }\n        }\n        return query;\n    }","commit_id":"f2573da77b73eaf031f236d5a6af0be4b5f431ee","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void deleteMissingLayouts(\n\t\t\tlong groupId, boolean privateLayout, Set<Long> newLayoutIds,\n\t\t\tList<Layout> previousLayouts, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\t// Layouts\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (newLayoutIds.size() > 0) {\n\t\t\t\t_log.debug(\"Delete missing layouts\");\n\t\t\t}\n\t\t}\n\n\t\tfor (Layout layout : previousLayouts) {\n\t\t\tif (!newLayoutIds.contains(layout.getLayoutId())) {\n\t\t\t\ttry {\n\t\t\t\t\tLayoutLocalServiceUtil.deleteLayout(\n\t\t\t\t\t\tlayout, false, serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Layout set\n\n\t\tLayoutSetLocalServiceUtil.updatePageCount(groupId, privateLayout);\n\t}","id":80013,"modified_method":"protected void deleteMissingLayouts(\n\t\t\tlong groupId, boolean privateLayout, Set<Long> newLayoutIds,\n\t\t\tList<Layout> previousLayouts, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\t// Layouts\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (newLayoutIds.size() > 0) {\n\t\t\t\t_log.debug(\"Delete missing layouts\");\n\t\t\t}\n\t\t}\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tSet<Long> existLayoutIds = new HashSet<Long>();\n\n\t\tif (group.hasStagingGroup()) {\n\t\t\tGroup stagingGroup = group.getStagingGroup();\n\n\t\t\tif (stagingGroup.hasPrivateLayouts() ||\n\t\t\t\tstagingGroup.hasPublicLayouts()) {\n\n\t\t\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tstagingGroup.getGroupId(), privateLayout);\n\n\t\t\t\tfor (Layout layout : layouts) {\n\t\t\t\t\texistLayoutIds.add(layout.getLayoutId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (Layout layout : previousLayouts) {\n\t\t\tif (!existLayoutIds.contains(layout.getLayoutId())) {\n\t\t\t\ttry {\n\t\t\t\t\tLayoutLocalServiceUtil.deleteLayout(\n\t\t\t\t\t\tlayout, privateLayout, serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Layout set\n\n\t\tLayoutSetLocalServiceUtil.updatePageCount(groupId, privateLayout);\n\t}","commit_id":"bb9d90a4be448e669dfcb753b8a84c8fe554799e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addChildCalendarBookings(\n\t\t\tCalendarBooking calendarBooking, long[] childCalendarIds,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!calendarBooking.isMasterBooking()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\tcalendarBookingPersistence.findByParentCalendarBookingId(\n\t\t\t\tcalendarBooking.getCalendarBookingId());\n\n\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\tif (childCalendarBooking.isMasterBooking() ||\n\t\t\t\tArrayUtil.contains(\n\t\t\t\t\tchildCalendarIds, childCalendarBooking.getCalendarId())) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdeleteCalendarBooking(childCalendarBooking.getCalendarBookingId());\n\t\t}\n\n\t\tfor (long calendarId : childCalendarIds) {\n\t\t\tint count = calendarBookingPersistence.countByC_P(\n\t\t\t\tcalendarId, calendarBooking.getCalendarBookingId());\n\n\t\t\tif (count > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCalendarBooking childCalendarBooking = addCalendarBooking(\n\t\t\t\tcalendarBooking.getUserId(), calendarId, new long[0],\n\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\tcalendarBooking.getTitleMap(),\n\t\t\t\tcalendarBooking.getDescriptionMap(),\n\t\t\t\tcalendarBooking.getLocation(), calendarBooking.getStartTime(),\n\t\t\t\tcalendarBooking.getEndTime(), calendarBooking.getAllDay(),\n\t\t\t\tcalendarBooking.getRecurrence(),\n\t\t\t\tcalendarBooking.getFirstReminder(),\n\t\t\t\tcalendarBooking.getFirstReminderType(),\n\t\t\t\tcalendarBooking.getSecondReminder(),\n\t\t\t\tcalendarBooking.getSecondReminderType(), serviceContext);\n\n\t\t\ttry {\n\t\t\t\tNotificationType notificationType = NotificationType.parse(\n\t\t\t\t\tPortletPropsValues.CALENDAR_NOTIFICATION_DEFAULT_TYPE);\n\n\t\t\t\tNotificationUtil.notifyCalendarBookingRecipients(\n\t\t\t\t\tchildCalendarBooking, notificationType,\n\t\t\t\t\tNotificationTemplateType.INVITE, serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":80014,"modified_method":"protected void addChildCalendarBookings(\n\t\t\tCalendarBooking calendarBooking, long[] childCalendarIds,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!calendarBooking.isMasterBooking()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\tcalendarBookingPersistence.findByParentCalendarBookingId(\n\t\t\t\tcalendarBooking.getCalendarBookingId());\n\t\tSet<Long> existingCalendarBookingIds = new HashSet<Long>(\n\t\t\tchildCalendarIds.length);\n\n\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\tif (!childCalendarBooking.isMasterBooking()) {\n\t\t\t\tdeleteCalendarBooking(\n\t\t\t\t\tchildCalendarBooking.getCalendarBookingId());\n\t\t\t\texistingCalendarBookingIds.add(\n\t\t\t\t\tchildCalendarBooking.getCalendarId());\n\t\t\t}\n\t\t}\n\n\t\tfor (long calendarId : childCalendarIds) {\n\t\t\tint count = calendarBookingPersistence.countByC_P(\n\t\t\t\tcalendarId, calendarBooking.getCalendarBookingId());\n\n\t\t\tif (count > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCalendarBooking childCalendarBooking = addCalendarBooking(\n\t\t\t\tcalendarBooking.getUserId(), calendarId, new long[0],\n\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\tcalendarBooking.getTitleMap(),\n\t\t\t\tcalendarBooking.getDescriptionMap(),\n\t\t\t\tcalendarBooking.getLocation(), calendarBooking.getStartTime(),\n\t\t\t\tcalendarBooking.getEndTime(), calendarBooking.getAllDay(),\n\t\t\t\tcalendarBooking.getRecurrence(),\n\t\t\t\tcalendarBooking.getFirstReminder(),\n\t\t\t\tcalendarBooking.getFirstReminderType(),\n\t\t\t\tcalendarBooking.getSecondReminder(),\n\t\t\t\tcalendarBooking.getSecondReminderType(), serviceContext);\n\n\t\t\ttry {\n\t\t\t\tNotificationType notificationType = NotificationType.parse(\n\t\t\t\t\tPortletPropsValues.CALENDAR_NOTIFICATION_DEFAULT_TYPE);\n\n\t\t\t\tNotificationTemplateType notificationTemplateType =\n\t\t\t\t\t\tNotificationTemplateType.INVITE;\n\n\t\t\t\tif (existingCalendarBookingIds.contains(\n\t\t\t\t\t\tchildCalendarBooking.getCalendarId())) {\n\n\t\t\t\t\tnotificationTemplateType = NotificationTemplateType.UPDATE;\n\t\t\t\t}\n\n\t\t\t\tNotificationUtil.notifyCalendarBookingRecipients(\n\t\t\t\t\tchildCalendarBooking, notificationType,\n\t\t\t\t\tnotificationTemplateType, serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a58097fa74f932df5ad4d34ccd9008945c1b54d3","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\tfreeDecodedData(container);\n\t\tremoveSubSegments(container, context);\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] != null) dataKeys[i].removeFrom(container);\n\t\t\tdataKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] != null) checkKeys[i].removeFrom(container);\n\t\t\tcheckKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = dataBuckets[i];\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Data block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = checkBuckets[i];\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Check block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\terrors.removeFrom(container);\n\t\tcontainer.delete(this);\n\t}","id":80015,"modified_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\tif(decodedData != null)\n\t\t\tfreeDecodedData(container);\n\t\tremoveSubSegments(container, context);\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] != null) dataKeys[i].removeFrom(container);\n\t\t\tdataKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] != null) checkKeys[i].removeFrom(container);\n\t\t\tcheckKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = dataBuckets[i];\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Data block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = checkBuckets[i];\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Check block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\terrors.removeFrom(container);\n\t\tcontainer.delete(this);\n\t}","commit_id":"c6bbd630b14b734319f5c09062e7214da4825f78","url":"https://github.com/freenet/fred"},{"original_method":"public void freeDecodedData(ObjectContainer container) {\n\t\tif(decodedData != null) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(decodedData, 1);\n\t\t\tdecodedData.free();\n\t\t\tif(persistent)\n\t\t\t\tdecodedData.removeFrom(container);\n\t\t}\n\t\tdecodedData = null;\n\t\tif(persistent)\n\t\t\tcontainer.store(this);\n\t}","id":80016,"modified_method":"public void freeDecodedData(ObjectContainer container) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(decodedData, 1);\n\t\tdecodedData.free();\n\t\tif(persistent)\n\t\t\tdecodedData.removeFrom(container);\n\t\tdecodedData = null;\n\t\tif(persistent)\n\t\t\tcontainer.store(this);\n\t}","commit_id":"c6bbd630b14b734319f5c09062e7214da4825f78","url":"https://github.com/freenet/fred"},{"original_method":"private void encoderFinished(ObjectContainer container, ClientContext context) {\n\t\tcontext.cooldownTracker.remove(this, persistent, container);\n\t\tboolean finish = false;\n\t\tboolean half = false;\n\t\tsynchronized(this) {\n\t\t\tencoderFinished = true;\n\t\t\tfinish = fetcherFinished;\n\t\t\thalf = fetcherHalfFinished;\n\t\t}\n\t\tif(finish) {\n\t\t\tif(persistent) removeFrom(container, context);\n\t\t} else if(half) {\n\t\t\tfreeDecodedData(container, false);\n\t\t\tif(persistent) container.store(this);\n\t\t\tif(logMINOR) Logger.minor(this, \"Encoder finished but fetcher not finished on \"+this);\n\t\t} else {\n\t\t\tif(persistent) container.store(this);\n\t\t}\n\t}","id":80017,"modified_method":"private void encoderFinished(ObjectContainer container, ClientContext context) {\n\t\tcontext.cooldownTracker.remove(this, persistent, container);\n\t\tboolean finish = false;\n\t\tboolean half = false;\n\t\tsynchronized(this) {\n\t\t\tencoderFinished = true;\n\t\t\tfinish = fetcherFinished;\n\t\t\thalf = fetcherHalfFinished;\n\t\t}\n\t\tif(finish) {\n\t\t\tif(persistent) removeFrom(container, context);\n\t\t} else if(half) {\n\t\t\tif(crossCheckBlocks == 0)\n\t\t\t\tfreeDecodedData(container, false);\n\t\t\tif(persistent) container.store(this);\n\t\t\tif(logMINOR) Logger.minor(this, \"Encoder finished but fetcher not finished on \"+this);\n\t\t} else {\n\t\t\tif(persistent) container.store(this);\n\t\t}\n\t}","commit_id":"122cf0e0b9d7e050f695ab2e89e6dd6000fa8beb","url":"https://github.com/freenet/fred"},{"original_method":"/** Free the data blocks but only if the encoder has finished with them. */\n\tpublic void fetcherHalfFinished(ObjectContainer container) {\n\t\tboolean finish = false;\n\t\tsynchronized(this) {\n\t\t\tif(fetcherHalfFinished) return;\n\t\t\tfetcherHalfFinished = true;\n\t\t\tfinish = encoderFinished;\n\t\t}\n\t\tif(finish) freeDecodedData(container, false);\n\t\telse {\n\t\t\tif(logMINOR) Logger.minor(this, \"Fetcher half-finished but fetcher not finished on \"+this);\n\t\t}\n\t\tif(persistent) container.store(this);\n\t\t\n\t}","id":80018,"modified_method":"/** Free the data blocks but only if the encoder has finished with them. */\n\tpublic void fetcherHalfFinished(ObjectContainer container) {\n\t\tboolean finish = false;\n\t\tsynchronized(this) {\n\t\t\tif(fetcherHalfFinished) return;\n\t\t\tfetcherHalfFinished = true;\n\t\t\tfinish = encoderFinished;\n\t\t}\n\t\tif(finish) {\n\t\t\tif(crossCheckBlocks == 0) freeDecodedData(container, false);\n\t\t} else {\n\t\t\tif(logMINOR) Logger.minor(this, \"Fetcher half-finished but fetcher not finished on \"+this);\n\t\t}\n\t\tif(persistent) container.store(this);\n\t\t\n\t}","commit_id":"122cf0e0b9d7e050f695ab2e89e6dd6000fa8beb","url":"https://github.com/freenet/fred"},{"original_method":"public S3Service getS3Service(VariableSpace space) throws S3ServiceException {\r\n\t\t\r\n\t\t// Try to connect to S3 first\r\n\t\t//\r\n\t\tString accessKey = space.environmentSubstitute(awsAccessKey);\r\n\t\tString secretKey = space.environmentSubstitute(awsSecretKey);\r\n\t\tAWSCredentials awsCredentials = new AWSCredentials(accessKey, secretKey);\r\n\t\t\r\n\t\tS3Service s3service = new RestS3Service(awsCredentials);\r\n\t\treturn s3service;\r\n\t}","id":80019,"modified_method":"public S3Service getS3Service( VariableSpace space ) throws S3ServiceException {\r\n\r\n    // Try to connect to S3 first\r\n    //\r\n    String accessKey = Encr.decryptPasswordOptionallyEncrypted( space.environmentSubstitute( awsAccessKey ) );\r\n    String secretKey = Encr.decryptPasswordOptionallyEncrypted( space.environmentSubstitute( awsSecretKey ) );\r\n    AWSCredentials awsCredentials = new AWSCredentials( accessKey, secretKey );\r\n\r\n    S3Service s3service = new RestS3Service( awsCredentials );\r\n    return s3service;\r\n  }","commit_id":"0702ebb8a5b26e5976e2d134d58908692745de00","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void addCredentials(HttpClient client)\r\n    {\r\n      if (StringUtils.isEmpty(webAppName)) {\r\n        client.getState().setCredentials\r\n              (\r\n                new AuthScope(environmentSubstitute(hostname), Const.toInt(environmentSubstitute(port), 80), \"Kettle\"), //$NON-NLS-1$\r\n                new UsernamePasswordCredentials(environmentSubstitute(username), environmentSubstitute(password))\r\n              );\r\n      } else {        \r\n        Credentials creds = new UsernamePasswordCredentials(environmentSubstitute(username), environmentSubstitute(password));\r\n        client.getState().setCredentials(AuthScope.ANY, creds);\r\n        client.getParams().setAuthenticationPreemptive(true);      \r\n      }\r\n    }","id":80020,"modified_method":"public void addCredentials(HttpClient client)\r\n    {\r\n      if (StringUtils.isEmpty(webAppName)) {\r\n        client.getState().setCredentials\r\n              (\r\n                new AuthScope(environmentSubstitute(hostname), Const.toInt(environmentSubstitute(port), 80), \"Kettle\"), //$NON-NLS-1$\r\n                new UsernamePasswordCredentials(environmentSubstitute(username), Encr.decryptPasswordOptionallyEncrypted(environmentSubstitute(password)))\r\n              );\r\n      } else {        \r\n        Credentials creds = new UsernamePasswordCredentials(environmentSubstitute(username), Encr.decryptPasswordOptionallyEncrypted(environmentSubstitute(password)));\r\n        client.getState().setCredentials(AuthScope.ANY, creds);\r\n        client.getParams().setAuthenticationPreemptive(true);      \r\n      }\r\n    }","commit_id":"6306ffea19b7782d3897d5fbdc0c73542604bd6d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(SymmetricCryptoTransMeta)smi;\r\n\t\tdata=(SymmetricCryptoTransData)sdi;\r\n\t\t\r\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\t\t\t\t\r\n\t\tif (first) {\r\n\t\t\tfirst=false;\r\n\t\t\t\r\n\t\t    data.outputRowMeta = getInputRowMeta().clone();\r\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\r\n\t\t\t// Let's check that Result Field is given\r\n\t\t\tif (Const.isEmpty(meta.getResultfieldname())) {\r\n\t\t\t\t//\tResult field is missing !\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.ErrorResultFieldMissing\")); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Check if The message field is given\r\n\t\t\tif (Const.isEmpty(meta.getMessageFied())) {\r\n\t\t\t\t// Message Field is missing !\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.MissingMessageField\")); \r\n\t\t\t}\r\n\t\t\t// Try to get Field index\r\n\t\t\tdata.indexOfMessage =getInputRowMeta().indexOfValue(meta.getMessageFied());\t\r\n\t\t\t\r\n\t\t\t// Let's check the Field\r\n\t\t\tif (data.indexOfMessage <0){\r\n\t\t\t\t// The field is unreachable !\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.CouldnotFindField\",meta.getMessageFied())); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(!meta.isSecretKeyInField()) {\r\n\t\t\t\tString realSecretKey=environmentSubstitute(meta.getSecretKey());\r\n\t\t\t\t\r\n\t\t\t\tif(Const.isEmpty(realSecretKey)) {\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyMissing\"));\t\r\n\t\t\t\t}\r\n\t\t\t\t// We have a static secret key\r\n\t\t\t\t// Set secrete key\r\n\t\t\t\tsetSecretKey(realSecretKey);\r\n\t\t\t\t\r\n\t\t\t}else {\r\n\t\t\t\t// dynamic secret key\r\n\t\t\t\tif(Const.isEmpty(meta.getSecretKeyField())) {\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyFieldMissing\"));\t\r\n\t\t\t\t}\r\n\t\t\t\t// Try to get secret key field index\r\n\t\t\t\tdata.indexOfSecretkeyField =getInputRowMeta().indexOfValue(meta.getSecretKeyField());\t\r\n\t\t\t\t\r\n\t\t\t\t// Let's check the Field\r\n\t\t\t\tif (data.indexOfSecretkeyField <0){\r\n\t\t\t\t\t// The field is unreachable !\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.CouldnotFindField\",meta.getSecretKeyField())); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\ttry{\r\n\t\t\t\r\n\t\t\t// handle dynamic secret key\r\n\t\t\tObject realSecretKey;\r\n\t\t\tif(meta.isSecretKeyInField()) {\r\n\t\t\t\tif(meta.isReadKeyAsBinary()) {\r\n\t\t\t\t\trealSecretKey = getInputRowMeta().getBinary(r, data.indexOfSecretkeyField);\r\n\t\t\t\t\tif(realSecretKey==null) {\r\n\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyMissing\"));\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}else {\r\n\t\t\t\t\trealSecretKey = getInputRowMeta().getString(r, data.indexOfSecretkeyField);\r\n\t\t\t\t\tif(Const.isEmpty((String) realSecretKey)) {\r\n\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyMissing\"));\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set secrete key\r\n\t\t\t\tsetSecretKey(realSecretKey);\r\n\t\t\t}\r\n\r\n\t\t\t// Get the field value\r\n\r\n\t\t\tObject result=null;\r\n\t\t\t\r\n\t\t\tif(meta.getOperationType()== SymmetricCryptoTransMeta.OPERATION_TYPE_ENCRYPT) {\r\n\r\n\t\t\t\t// encrypt plain text\r\n\t\t\t\tbyte[] encrBytes = data.Crypt.encrDecryptData(getInputRowMeta().getBinary(r, data.indexOfMessage));\r\n\t\t\t\t \r\n\t\t\t\t// return encrypted value\r\n\t\t\t\tif(meta.isOutputResultAsBinary())\r\n\t\t\t\t\tresult = encrBytes;\t\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = new String(Hex.encodeHex((encrBytes)));\r\n\t\t\t}else {\r\n\t\t\t\t// Get encrypted value\r\n\t\t\t\tString s=getInputRowMeta().getString(r, data.indexOfMessage);    \r\n\t\t\t\r\n\t\t\t\tbyte[] dataBytes = Hex.decodeHex(s.toCharArray());\r\n\t\t\t\t\r\n\t\t\t\t// encrypt or decrypt message and return result\r\n\t\t\t\tbyte[] encrBytes = data.Crypt.encrDecryptData(dataBytes);\r\n\t\t\t\t \r\n\t\t\t\t// we have decrypted value\r\n\t\t\t\tif(meta.isOutputResultAsBinary())\r\n\t\t\t\t  result = encrBytes;\r\n\t\t\t\telse\r\n\t\t\t\t  result = new String(encrBytes);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t Object[] outputRowData =RowDataUtil.addValueData(r, getInputRowMeta().size(),result);\r\n\t\t\t\r\n\t\t\t putRow(data.outputRowMeta, outputRowData);       // copy row to output rowset(s);      \r\n\t\t\t \r\n\t\t} catch(Exception e) {\r\n\t\t\tboolean sendToErrorRow=false;\r\n\t\t\tString errorMessage;\r\n\t\t\tif (getStepMeta().isDoingErrorHandling()) {\r\n\t\t          sendToErrorRow = true;\r\n\t\t          errorMessage = e.toString();\r\n\t\t\t} else {\r\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Log.ErrorInStepRunning\"), e); //$NON-NLS-1$\r\n\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\tsetErrors(1);\r\n\t\t\t\tstopAll();\r\n\t\t\t\tsetOutputDone();  // signal end to receiver(s)\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (sendToErrorRow) {\r\n\t\t\t   // Simply add this row to the error row\r\n\t\t\t   putError(getInputRowMeta(), r, 1, errorMessage, null, \"EncDecr001\");\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t\t\t\r\n\t\treturn true;\r\n\t}","id":80021,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(SymmetricCryptoTransMeta)smi;\r\n\t\tdata=(SymmetricCryptoTransData)sdi;\r\n\t\t\r\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\t\t\t\t\r\n\t\tif (first) {\r\n\t\t\tfirst=false;\r\n\t\t\t\r\n\t\t    data.outputRowMeta = getInputRowMeta().clone();\r\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\r\n\t\t\t// Let's check that Result Field is given\r\n\t\t\tif (Const.isEmpty(meta.getResultfieldname())) {\r\n\t\t\t\t//\tResult field is missing !\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.ErrorResultFieldMissing\")); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Check if The message field is given\r\n\t\t\tif (Const.isEmpty(meta.getMessageFied())) {\r\n\t\t\t\t// Message Field is missing !\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.MissingMessageField\")); \r\n\t\t\t}\r\n\t\t\t// Try to get Field index\r\n\t\t\tdata.indexOfMessage =getInputRowMeta().indexOfValue(meta.getMessageFied());\t\r\n\t\t\t\r\n\t\t\t// Let's check the Field\r\n\t\t\tif (data.indexOfMessage <0){\r\n\t\t\t\t// The field is unreachable !\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.CouldnotFindField\",meta.getMessageFied())); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(!meta.isSecretKeyInField()) {\r\n\t   \t\t\tString realSecretKey=Encr.decryptPasswordOptionallyEncrypted(environmentSubstitute(meta.getSecretKey()));\r\n\t\t\t\tif(Const.isEmpty(realSecretKey)) {\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyMissing\"));\t\r\n\t\t\t\t}\r\n\t\t\t\t// We have a static secret key\r\n\t\t\t\t// Set secrete key\r\n\t\t\t\tsetSecretKey(realSecretKey);\r\n\t\t\t\t\r\n\t\t\t}else {\r\n\t\t\t\t// dynamic secret key\r\n\t\t\t\tif(Const.isEmpty(meta.getSecretKeyField())) {\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyFieldMissing\"));\t\r\n\t\t\t\t}\r\n\t\t\t\t// Try to get secret key field index\r\n\t\t\t\tdata.indexOfSecretkeyField =getInputRowMeta().indexOfValue(meta.getSecretKeyField());\t\r\n\t\t\t\t\r\n\t\t\t\t// Let's check the Field\r\n\t\t\t\tif (data.indexOfSecretkeyField <0){\r\n\t\t\t\t\t// The field is unreachable !\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.CouldnotFindField\",meta.getSecretKeyField())); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\ttry{\r\n\t\t\t\r\n\t\t\t// handle dynamic secret key\r\n\t\t\tObject realSecretKey;\r\n\t\t\tif(meta.isSecretKeyInField()) {\r\n\t\t\t\tif(meta.isReadKeyAsBinary()) {\r\n\t\t\t\t\trealSecretKey = getInputRowMeta().getBinary(r, data.indexOfSecretkeyField);\r\n\t\t\t\t\tif(realSecretKey==null) {\r\n\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyMissing\"));\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}else {\r\n\t\t\t\t\trealSecretKey=Encr.decryptPasswordOptionallyEncrypted(environmentSubstitute((String)getInputRowMeta().getString(r, data.indexOfSecretkeyField)));\r\n\t\t\t\t\tif(Const.isEmpty((String) realSecretKey)) {\r\n\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Exception.SecretKeyMissing\"));\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set secrete key\r\n\t\t\t\tsetSecretKey(realSecretKey);\r\n\t\t\t}\r\n\r\n\t\t\t// Get the field value\r\n\r\n\t\t\tObject result=null;\r\n\t\t\t\r\n\t\t\tif(meta.getOperationType()== SymmetricCryptoTransMeta.OPERATION_TYPE_ENCRYPT) {\r\n\r\n\t\t\t\t// encrypt plain text\r\n\t\t\t\tbyte[] encrBytes = data.Crypt.encrDecryptData(getInputRowMeta().getBinary(r, data.indexOfMessage));\r\n\t\t\t\t \r\n\t\t\t\t// return encrypted value\r\n\t\t\t\tif(meta.isOutputResultAsBinary())\r\n\t\t\t\t\tresult = encrBytes;\t\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = new String(Hex.encodeHex((encrBytes)));\r\n\t\t\t}else {\r\n\t\t\t\t// Get encrypted value\r\n\t\t\t\tString s=getInputRowMeta().getString(r, data.indexOfMessage);    \r\n\t\t\t\r\n\t\t\t\tbyte[] dataBytes = Hex.decodeHex(s.toCharArray());\r\n\t\t\t\t\r\n\t\t\t\t// encrypt or decrypt message and return result\r\n\t\t\t\tbyte[] encrBytes = data.Crypt.encrDecryptData(dataBytes);\r\n\t\t\t\t \r\n\t\t\t\t// we have decrypted value\r\n\t\t\t\tif(meta.isOutputResultAsBinary())\r\n\t\t\t\t  result = encrBytes;\r\n\t\t\t\telse\r\n\t\t\t\t  result = new String(encrBytes);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t Object[] outputRowData =RowDataUtil.addValueData(r, getInputRowMeta().size(),result);\r\n\t\t\t\r\n\t\t\t putRow(data.outputRowMeta, outputRowData);       // copy row to output rowset(s);      \r\n\t\t\t \r\n\t\t} catch(Exception e) {\r\n\t\t\tboolean sendToErrorRow=false;\r\n\t\t\tString errorMessage;\r\n\t\t\tif (getStepMeta().isDoingErrorHandling()) {\r\n\t\t          sendToErrorRow = true;\r\n\t\t          errorMessage = e.toString();\r\n\t\t\t} else {\r\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"SymmetricCryptoTrans.Log.ErrorInStepRunning\"), e); //$NON-NLS-1$\r\n\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\tsetErrors(1);\r\n\t\t\t\tstopAll();\r\n\t\t\t\tsetOutputDone();  // signal end to receiver(s)\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (sendToErrorRow) {\r\n\t\t\t   // Simply add this row to the error row\r\n\t\t\t   putError(getInputRowMeta(), r, 1, errorMessage, null, \"EncDecr001\");\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t\t\t\r\n\t\treturn true;\r\n\t}","commit_id":"2658267ca32cb229de5e192ade0a8a71716710bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\t\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Shell.Title\")); //$NON-NLS-1$\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// SecretKey line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Stepname.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left = new FormAttachment(0, 0);\r\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\r\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, PropsUI.WIDGET_STYLE_TAB);\r\n \t\t\r\n \t\t//////////////////////////\r\n\t\t// START OF GENERAL TAB   ///\r\n\t\t//////////////////////////\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\twGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twGeneralTab.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.GeneralTab.TabTitle\"));\r\n\t\t\r\n\t\twGeneralComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wGeneralComp);\r\n\r\n\t\tFormLayout generalLayout = new FormLayout();\r\n\t\tgeneralLayout.marginWidth  = 3;\r\n\t\tgeneralLayout.marginHeight = 3;\r\n\t\twGeneralComp.setLayout(generalLayout);\r\n\t\t\r\n\r\n    \t\r\n\t\t// ////////////////////////\r\n\t\t// START OF Crypto settings GROUP\r\n\t\t// \r\n\r\n\t\twCryptoSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wCryptoSettings);\r\n\t\twCryptoSettings.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.CryptoSettings.Group.Label\"));\r\n\t\t\r\n\t\tFormLayout CryptoSettingsgroupLayout = new FormLayout();\r\n\t\tCryptoSettingsgroupLayout.marginWidth = 10;\r\n\t\tCryptoSettingsgroupLayout.marginHeight = 10;\r\n\t\twCryptoSettings.setLayout(CryptoSettingsgroupLayout);\r\n\r\n\r\n\r\n\t\t// Operation\r\n\t\twlOperation=new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlOperation.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Operation.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlOperation);\r\n\t\tfdlOperation=new FormData();\r\n\t\tfdlOperation.left = new FormAttachment(0, 0);\r\n\t\tfdlOperation.right= new FormAttachment(middle, -margin);\r\n\t\tfdlOperation.top  = new FormAttachment(wStepname, margin);\r\n\t\twlOperation.setLayoutData(fdlOperation);\r\n\t\t\r\n\t\twOperation=new CCombo(wCryptoSettings, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wOperation);\r\n \t\twOperation.addModifyListener(lsMod);\r\n\t\tfdOperation=new FormData();\r\n\t\tfdOperation.left = new FormAttachment(middle, margin);\r\n\t\tfdOperation.top  = new FormAttachment(wStepname, margin);\r\n\t\tfdOperation.right= new FormAttachment(100, -margin);\r\n\t\twOperation.setLayoutData(fdOperation);\r\n\t\twOperation.setItems(SymmetricCryptoTransMeta.operationTypeDesc);\r\n\t\twOperation.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// Algorithm\r\n\t\twlAlgorithm=new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlAlgorithm.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Algorithm.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlAlgorithm);\r\n\t\tfdlAlgorithm=new FormData();\r\n\t\tfdlAlgorithm.left = new FormAttachment(0, 0);\r\n\t\tfdlAlgorithm.right= new FormAttachment(middle, -margin);\r\n\t\tfdlAlgorithm.top  = new FormAttachment(wOperation, margin);\r\n\t\twlAlgorithm.setLayoutData(fdlAlgorithm);\r\n\t\t\r\n\t\twAlgorithm=new CCombo(wCryptoSettings, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wAlgorithm);\r\n \t\twAlgorithm.addModifyListener(lsMod);\r\n\t\tfdAlgorithm=new FormData();\r\n\t\tfdAlgorithm.left = new FormAttachment(middle, margin);\r\n\t\tfdAlgorithm.top  = new FormAttachment(wOperation, margin);\r\n\t\tfdAlgorithm.right= new FormAttachment(100, -margin);\r\n\t\twAlgorithm.setLayoutData(fdAlgorithm);\r\n\t\twAlgorithm.setItems(SymmetricCryptoMeta.TYPE_ALGORYTHM_CODE);\r\n\t\twAlgorithm.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t    \r\n\t\t// Scheme\r\n\t\twlScheme = new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlScheme.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Scheme.Label\"));\r\n\t\tprops.setLook(wlScheme);\r\n\t\tfdlScheme = new FormData();\r\n\t\tfdlScheme.left = new FormAttachment(0, 0);\r\n\t\tfdlScheme.top = new FormAttachment(wAlgorithm, margin);\r\n\t\tfdlScheme.right = new FormAttachment(middle, -margin);\r\n\t\twlScheme.setLayoutData(fdlScheme);\r\n\r\n\t\twScheme = new TextVar(transMeta, wCryptoSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wScheme);\r\n\t\twScheme.addModifyListener(lsMod);\r\n\t\tfdScheme = new FormData();\r\n\t\tfdScheme.left = new FormAttachment(middle, margin);\r\n\t\tfdScheme.right = new FormAttachment(100, -margin);\r\n\t\tfdScheme.top = new FormAttachment(wAlgorithm, margin);\r\n\t\twScheme.setLayoutData(fdScheme);\r\n\t\t\r\n\t\r\n\t\t// SecretKey\r\n\t\twlSecretKey = new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlSecretKey.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKey.Label\"));\r\n\t\tprops.setLook(wlSecretKey);\r\n\t\tfdlSecretKey = new FormData();\r\n\t\tfdlSecretKey.left = new FormAttachment(0, 0);\r\n\t\tfdlSecretKey.top = new FormAttachment(wScheme, 2*margin);\r\n\t\tfdlSecretKey.right = new FormAttachment(middle, -margin);\r\n\t\twlSecretKey.setLayoutData(fdlSecretKey);\r\n\r\n\t\twSecretKey = new TextVar(transMeta, wCryptoSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wSecretKey);\r\n\t\twSecretKey.addModifyListener(lsMod);\r\n\t\tfdSecretKey = new FormData();\r\n\t\tfdSecretKey.left = new FormAttachment(middle, margin);\r\n\t\tfdSecretKey.right = new FormAttachment(100, -margin);\r\n\t\tfdSecretKey.top = new FormAttachment(wScheme, 2*margin);\r\n\t\twSecretKey.setLayoutData(fdSecretKey);\r\n\t\t\t\t\r\n\t\t// Is secret key extracted from a field?\r\n\t\twlSecretKeyInField = new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlSecretKeyInField.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKeyFileField.Label\"));\r\n\t\tprops.setLook(wlSecretKeyInField);\r\n\t\tfdlSecretKeyInField = new FormData();\r\n\t\tfdlSecretKeyInField.left = new FormAttachment(0, 0);\r\n\t\tfdlSecretKeyInField.top = new FormAttachment(wSecretKey, margin);\r\n\t\tfdlSecretKeyInField.right = new FormAttachment(middle, -margin);\r\n\t\twlSecretKeyInField.setLayoutData(fdlSecretKeyInField);\r\n\t\twSecretKeyInField = new Button(wCryptoSettings, SWT.CHECK);\r\n\t\tprops.setLook(wSecretKeyInField);\r\n\t\twSecretKeyInField.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKeyFileField.Tooltip\"));\r\n\t\tfdSecretKeyInField = new FormData();\r\n\t\tfdSecretKeyInField.left = new FormAttachment(middle, margin);\r\n\t\tfdSecretKeyInField.top = new FormAttachment(wSecretKey, margin);\r\n\t\twSecretKeyInField.setLayoutData(fdSecretKeyInField);\r\n\t\t\r\n\t\tSelectionAdapter lsXslFile = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n            \tActivewlSecretKeyField();\r\n            \tinput.setChanged();\r\n            }\r\n        };\r\n        wSecretKeyInField.addSelectionListener(lsXslFile);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// If secret key defined in a Field\r\n\t\twlSecretKeyField=new Label(wCryptoSettings, SWT.RIGHT);\r\n        wlSecretKeyField.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKeyField.Label\"));\r\n        props.setLook(wlSecretKeyField);\r\n        fdlSecretKeyField=new FormData();\r\n        fdlSecretKeyField.left = new FormAttachment(0, 0);\r\n        fdlSecretKeyField.top  = new FormAttachment(wSecretKeyInField, margin);\r\n        fdlSecretKeyField.right= new FormAttachment(middle, -margin);\r\n        wlSecretKeyField.setLayoutData(fdlSecretKeyField);\r\n        wSecretKeyField=new CCombo(wCryptoSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wSecretKeyField.setEditable(true);\r\n        props.setLook(wSecretKeyField);\r\n        wSecretKeyField.addModifyListener(lsMod);\r\n        fdSecretKeyField=new FormData();\r\n        fdSecretKeyField.left = new FormAttachment(middle, margin);\r\n        fdSecretKeyField.top  = new FormAttachment(wSecretKeyInField, margin);\r\n        fdSecretKeyField.right= new FormAttachment(100, -margin);\r\n        wSecretKeyField.setLayoutData(fdSecretKeyField);\r\n        wSecretKeyField.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    setSecretKeyFieldname();\r\n                }\r\n            }\r\n        );\r\n        \r\n\r\n        wlReadKeyAsBinary=new Label(wCryptoSettings, SWT.RIGHT);\r\n        wlReadKeyAsBinary.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ReadKeyAsBinary.Label\")); //$NON-NLS-1$\r\n        props.setLook(wlReadKeyAsBinary);\r\n        fdlReadKeyAsBinary=new FormData();\r\n        fdlReadKeyAsBinary.left = new FormAttachment(0, 0);\r\n        fdlReadKeyAsBinary.top  = new FormAttachment(wSecretKeyField, margin);\r\n        fdlReadKeyAsBinary.right= new FormAttachment(middle, -margin);\r\n        wlReadKeyAsBinary.setLayoutData(fdlReadKeyAsBinary);\r\n        wReadKeyAsBinary=new Button(wCryptoSettings, SWT.CHECK );\r\n        wReadKeyAsBinary.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ReadKeyAsBinary.Tooltip\"));\r\n        props.setLook(wReadKeyAsBinary);\r\n        fdReadKeyAsBinary=new FormData();\r\n        fdReadKeyAsBinary.left = new FormAttachment(middle, margin);\r\n        fdReadKeyAsBinary.top  = new FormAttachment(wSecretKeyField, margin);\r\n        fdReadKeyAsBinary.right= new FormAttachment(100, -margin);\r\n        wReadKeyAsBinary.setLayoutData(fdReadKeyAsBinary);\r\n        wReadKeyAsBinary.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                    input.setChanged();\r\n                }\r\n            }\r\n        );\r\n        \r\n\t\tfdCryptoSettings = new FormData();\r\n\t\tfdCryptoSettings.left = new FormAttachment(0, margin);\r\n\t\tfdCryptoSettings.top = new FormAttachment(wStepname, margin);\r\n\t\tfdCryptoSettings.right = new FormAttachment(100, -margin);\r\n\t\twCryptoSettings.setLayoutData(fdCryptoSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF  Crypto settings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\t\r\n\r\n\t\t// ////////////////////////\r\n\t\t// START OF Crypto settings GROUP\r\n\t\t// \r\n\r\n\t\twMessageGroup = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wMessageGroup);\r\n\t\twMessageGroup.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Message.Group.Label\"));\r\n\t\t\r\n\t\tFormLayout MessageGroupgroupLayout = new FormLayout();\r\n\t\tMessageGroupgroupLayout.marginWidth = 10;\r\n\t\tMessageGroupgroupLayout.marginHeight = 10;\r\n\t\twMessageGroup.setLayout(MessageGroupgroupLayout);\r\n\r\n\r\n\r\n\t\t\r\n    \t// FieldName to evaluate\r\n\t\twlMessage=new Label(wMessageGroup, SWT.RIGHT);\r\n        wlMessage.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Field.Label\"));\r\n        props.setLook(wlMessage);\r\n        fdlMessage=new FormData();\r\n        fdlMessage.left = new FormAttachment(0, 0);\r\n        fdlMessage.top  = new FormAttachment(wCryptoSettings, margin);\r\n        fdlMessage.right= new FormAttachment(middle, -margin);\r\n        wlMessage.setLayoutData(fdlMessage);\r\n        wMessage=new CCombo(wMessageGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wMessage.setEditable(true);\r\n        props.setLook(wMessage);\r\n        wMessage.addModifyListener(lsMod);\r\n        fdField=new FormData();\r\n        fdField.left = new FormAttachment(middle, margin);\r\n        fdField.top  = new FormAttachment(wCryptoSettings, margin);\r\n        fdField.right= new FormAttachment(100, -margin);\r\n        wMessage.setLayoutData(fdField);\r\n        wMessage.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    setFieldname();\r\n                }\r\n            }\r\n        );\r\n\r\n      \r\n\t\tfdMessageGroup = new FormData();\r\n\t\tfdMessageGroup.left = new FormAttachment(0, margin);\r\n\t\tfdMessageGroup.top = new FormAttachment(wCryptoSettings, margin);\r\n\t\tfdMessageGroup.right = new FormAttachment(100, -margin);\r\n\t\twMessageGroup.setLayoutData(fdMessageGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF  Crypto settings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\t\r\n\r\n    \t// Step Output field grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF Output Field GROUP\r\n\t\t// \r\n\r\n\t\twOutputField = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wOutputField);\r\n\t\twOutputField.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ResultField.Group.Label\"));\r\n\t\t\r\n\t\tFormLayout outputfieldgroupLayout = new FormLayout();\r\n\t\toutputfieldgroupLayout.marginWidth = 10;\r\n\t\toutputfieldgroupLayout.marginHeight = 10;\r\n\t\twOutputField.setLayout(outputfieldgroupLayout);\r\n        \r\n\t      // Output Fieldame\r\n        wResultField = new LabelTextVar(transMeta, wOutputField, \r\n        \t\tBaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ResultField.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ResultField.Tooltip\"));\r\n        props.setLook(wResultField);\r\n        wResultField .addModifyListener(lsMod);\r\n        fdResultField  = new FormData();\r\n        fdResultField .left = new FormAttachment(0, 0);\r\n        fdResultField .top = new FormAttachment(wMessageGroup, margin);\r\n        fdResultField .right = new FormAttachment(100, 0);\r\n        wResultField .setLayoutData(fdResultField );\r\n        \r\n\r\n        wlOutputAsBinary=new Label(wOutputField, SWT.RIGHT);\r\n        wlOutputAsBinary.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.OutputAsBinary.Label\")); //$NON-NLS-1$\r\n        props.setLook(wlOutputAsBinary);\r\n        fdlOutputAsBinary=new FormData();\r\n        fdlOutputAsBinary.left = new FormAttachment(0, 0);\r\n        fdlOutputAsBinary.top  = new FormAttachment(wResultField, margin);\r\n        fdlOutputAsBinary.right= new FormAttachment(middle, -margin);\r\n        wlOutputAsBinary.setLayoutData(fdlOutputAsBinary);\r\n        wOutputAsBinary=new Button(wOutputField, SWT.CHECK );\r\n        wOutputAsBinary.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.OutputAsBinary.Tooltip\"));\r\n        props.setLook(wOutputAsBinary);\r\n        fdOutputAsBinary=new FormData();\r\n        fdOutputAsBinary.left = new FormAttachment(middle, margin);\r\n        fdOutputAsBinary.top  = new FormAttachment(wResultField, margin);\r\n        fdOutputAsBinary.right= new FormAttachment(100, 0);\r\n        wOutputAsBinary.setLayoutData(fdOutputAsBinary);\r\n        wOutputAsBinary.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                    input.setChanged();\r\n                }\r\n            }\r\n        ); \r\n        \r\n        \r\n\t\tfdOutputField = new FormData();\r\n\t\tfdOutputField.left = new FormAttachment(0, margin);\r\n\t\tfdOutputField.top = new FormAttachment(wMessageGroup, margin);\r\n\t\tfdOutputField.right = new FormAttachment(100, -margin);\r\n\t\twOutputField.setLayoutData(fdOutputField);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Output Field GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\t\r\n\t        \r\n\t\tfdGeneralComp=new FormData();\r\n\t\tfdGeneralComp.left  = new FormAttachment(0, 0);\r\n\t\tfdGeneralComp.top   = new FormAttachment(wOutputField, 0);\r\n\t\tfdGeneralComp.right = new FormAttachment(100, 0);\r\n\t\tfdGeneralComp.bottom= new FormAttachment(100, 0);\r\n\t\twGeneralComp.setLayoutData(fdGeneralComp);\r\n\t\t\r\n\t\twGeneralComp.layout();\r\n\t\twGeneralTab.setControl(wGeneralComp);\r\n \t\tprops.setLook(wGeneralComp);\r\n \t\t\r\n \t\t\r\n \t\t\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF GENERAL TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n \t\t\r\n \t\t\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n\r\n\t\t// Add listeners\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();          } };\r\n\t\t\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();              } };\r\n\t\t\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\t\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\t\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// Whenever something changes, set the tooltip to the expanded version\r\n\t\t// of the filename:\r\n\t\twSecretKey.addModifyListener(new ModifyListener() {\r\n\t\t\tpublic void modifyText(ModifyEvent e) {\r\n\t\t\t\twSecretKey.setToolTipText(transMeta.environmentSubstitute(wSecretKey.getText()));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\tActivewlSecretKeyField();\r\n\r\n\t\t\r\n\t\tinput.setChanged(changed);\r\n\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","id":80022,"modified_method":"public String open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\t\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Shell.Title\")); //$NON-NLS-1$\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// SecretKey line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Stepname.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left = new FormAttachment(0, 0);\r\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\r\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, PropsUI.WIDGET_STYLE_TAB);\r\n \t\t\r\n \t\t//////////////////////////\r\n\t\t// START OF GENERAL TAB   ///\r\n\t\t//////////////////////////\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\twGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twGeneralTab.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.GeneralTab.TabTitle\"));\r\n\t\t\r\n\t\twGeneralComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wGeneralComp);\r\n\r\n\t\tFormLayout generalLayout = new FormLayout();\r\n\t\tgeneralLayout.marginWidth  = 3;\r\n\t\tgeneralLayout.marginHeight = 3;\r\n\t\twGeneralComp.setLayout(generalLayout);\r\n\t\t\r\n\r\n    \t\r\n\t\t// ////////////////////////\r\n\t\t// START OF Crypto settings GROUP\r\n\t\t// \r\n\r\n\t\twCryptoSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wCryptoSettings);\r\n\t\twCryptoSettings.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.CryptoSettings.Group.Label\"));\r\n\t\t\r\n\t\tFormLayout CryptoSettingsgroupLayout = new FormLayout();\r\n\t\tCryptoSettingsgroupLayout.marginWidth = 10;\r\n\t\tCryptoSettingsgroupLayout.marginHeight = 10;\r\n\t\twCryptoSettings.setLayout(CryptoSettingsgroupLayout);\r\n\r\n\r\n\r\n\t\t// Operation\r\n\t\twlOperation=new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlOperation.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Operation.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlOperation);\r\n\t\tfdlOperation=new FormData();\r\n\t\tfdlOperation.left = new FormAttachment(0, 0);\r\n\t\tfdlOperation.right= new FormAttachment(middle, -margin);\r\n\t\tfdlOperation.top  = new FormAttachment(wStepname, margin);\r\n\t\twlOperation.setLayoutData(fdlOperation);\r\n\t\t\r\n\t\twOperation=new CCombo(wCryptoSettings, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wOperation);\r\n \t\twOperation.addModifyListener(lsMod);\r\n\t\tfdOperation=new FormData();\r\n\t\tfdOperation.left = new FormAttachment(middle, margin);\r\n\t\tfdOperation.top  = new FormAttachment(wStepname, margin);\r\n\t\tfdOperation.right= new FormAttachment(100, -margin);\r\n\t\twOperation.setLayoutData(fdOperation);\r\n\t\twOperation.setItems(SymmetricCryptoTransMeta.operationTypeDesc);\r\n\t\twOperation.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// Algorithm\r\n\t\twlAlgorithm=new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlAlgorithm.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Algorithm.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlAlgorithm);\r\n\t\tfdlAlgorithm=new FormData();\r\n\t\tfdlAlgorithm.left = new FormAttachment(0, 0);\r\n\t\tfdlAlgorithm.right= new FormAttachment(middle, -margin);\r\n\t\tfdlAlgorithm.top  = new FormAttachment(wOperation, margin);\r\n\t\twlAlgorithm.setLayoutData(fdlAlgorithm);\r\n\t\t\r\n\t\twAlgorithm=new CCombo(wCryptoSettings, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wAlgorithm);\r\n \t\twAlgorithm.addModifyListener(lsMod);\r\n\t\tfdAlgorithm=new FormData();\r\n\t\tfdAlgorithm.left = new FormAttachment(middle, margin);\r\n\t\tfdAlgorithm.top  = new FormAttachment(wOperation, margin);\r\n\t\tfdAlgorithm.right= new FormAttachment(100, -margin);\r\n\t\twAlgorithm.setLayoutData(fdAlgorithm);\r\n\t\twAlgorithm.setItems(SymmetricCryptoMeta.TYPE_ALGORYTHM_CODE);\r\n\t\twAlgorithm.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t    \r\n\t\t// Scheme\r\n\t\twlScheme = new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlScheme.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Scheme.Label\"));\r\n\t\tprops.setLook(wlScheme);\r\n\t\tfdlScheme = new FormData();\r\n\t\tfdlScheme.left = new FormAttachment(0, 0);\r\n\t\tfdlScheme.top = new FormAttachment(wAlgorithm, margin);\r\n\t\tfdlScheme.right = new FormAttachment(middle, -margin);\r\n\t\twlScheme.setLayoutData(fdlScheme);\r\n\r\n\t\twScheme = new TextVar(transMeta, wCryptoSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wScheme);\r\n\t\twScheme.addModifyListener(lsMod);\r\n\t\tfdScheme = new FormData();\r\n\t\tfdScheme.left = new FormAttachment(middle, margin);\r\n\t\tfdScheme.right = new FormAttachment(100, -margin);\r\n\t\tfdScheme.top = new FormAttachment(wAlgorithm, margin);\r\n\t\twScheme.setLayoutData(fdScheme);\r\n\t\t\r\n\t\r\n\t\t// SecretKey\r\n\t\twlSecretKey = new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlSecretKey.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKey.Label\"));\r\n\t\tprops.setLook(wlSecretKey);\r\n\t\tfdlSecretKey = new FormData();\r\n\t\tfdlSecretKey.left = new FormAttachment(0, 0);\r\n\t\tfdlSecretKey.top = new FormAttachment(wScheme, 2*margin);\r\n\t\tfdlSecretKey.right = new FormAttachment(middle, -margin);\r\n\t\twlSecretKey.setLayoutData(fdlSecretKey);\r\n\r\n\t\twSecretKey = new TextVar(transMeta, wCryptoSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wSecretKey);\r\n\t\twSecretKey.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKey.Tooltip\"));\r\n\t\twSecretKey.setEchoChar('*');\r\n\t\twSecretKey.addModifyListener(lsMod);\r\n\t\tfdSecretKey = new FormData();\r\n\t\tfdSecretKey.left = new FormAttachment(middle, margin);\r\n\t\tfdSecretKey.right = new FormAttachment(100, -margin);\r\n\t\tfdSecretKey.top = new FormAttachment(wScheme, 2*margin);\r\n\t\twSecretKey.setLayoutData(fdSecretKey);\r\n\t\t\t\t\r\n\t\t// Is secret key extracted from a field?\r\n\t\twlSecretKeyInField = new Label(wCryptoSettings, SWT.RIGHT);\r\n\t\twlSecretKeyInField.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKeyFileField.Label\"));\r\n\t\tprops.setLook(wlSecretKeyInField);\r\n\t\tfdlSecretKeyInField = new FormData();\r\n\t\tfdlSecretKeyInField.left = new FormAttachment(0, 0);\r\n\t\tfdlSecretKeyInField.top = new FormAttachment(wSecretKey, margin);\r\n\t\tfdlSecretKeyInField.right = new FormAttachment(middle, -margin);\r\n\t\twlSecretKeyInField.setLayoutData(fdlSecretKeyInField);\r\n\t\twSecretKeyInField = new Button(wCryptoSettings, SWT.CHECK);\r\n\t\tprops.setLook(wSecretKeyInField);\r\n\t\twSecretKeyInField.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKeyFileField.Tooltip\"));\r\n\t\tfdSecretKeyInField = new FormData();\r\n\t\tfdSecretKeyInField.left = new FormAttachment(middle, margin);\r\n\t\tfdSecretKeyInField.top = new FormAttachment(wSecretKey, margin);\r\n\t\twSecretKeyInField.setLayoutData(fdSecretKeyInField);\r\n\t\t\r\n\t\tSelectionAdapter lsXslFile = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n            \tActivewlSecretKeyField();\r\n            \tinput.setChanged();\r\n            }\r\n        };\r\n        wSecretKeyInField.addSelectionListener(lsXslFile);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// If secret key defined in a Field\r\n\t\twlSecretKeyField=new Label(wCryptoSettings, SWT.RIGHT);\r\n        wlSecretKeyField.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.SecretKeyField.Label\"));\r\n        props.setLook(wlSecretKeyField);\r\n        fdlSecretKeyField=new FormData();\r\n        fdlSecretKeyField.left = new FormAttachment(0, 0);\r\n        fdlSecretKeyField.top  = new FormAttachment(wSecretKeyInField, margin);\r\n        fdlSecretKeyField.right= new FormAttachment(middle, -margin);\r\n        wlSecretKeyField.setLayoutData(fdlSecretKeyField);\r\n        wSecretKeyField=new CCombo(wCryptoSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wSecretKeyField.setEditable(true);\r\n        props.setLook(wSecretKeyField);\r\n        wSecretKeyField.addModifyListener(lsMod);\r\n        fdSecretKeyField=new FormData();\r\n        fdSecretKeyField.left = new FormAttachment(middle, margin);\r\n        fdSecretKeyField.top  = new FormAttachment(wSecretKeyInField, margin);\r\n        fdSecretKeyField.right= new FormAttachment(100, -margin);\r\n        wSecretKeyField.setLayoutData(fdSecretKeyField);\r\n        wSecretKeyField.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    setSecretKeyFieldname();\r\n                }\r\n            }\r\n        );\r\n        \r\n\r\n        wlReadKeyAsBinary=new Label(wCryptoSettings, SWT.RIGHT);\r\n        wlReadKeyAsBinary.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ReadKeyAsBinary.Label\")); //$NON-NLS-1$\r\n        props.setLook(wlReadKeyAsBinary);\r\n        fdlReadKeyAsBinary=new FormData();\r\n        fdlReadKeyAsBinary.left = new FormAttachment(0, 0);\r\n        fdlReadKeyAsBinary.top  = new FormAttachment(wSecretKeyField, margin);\r\n        fdlReadKeyAsBinary.right= new FormAttachment(middle, -margin);\r\n        wlReadKeyAsBinary.setLayoutData(fdlReadKeyAsBinary);\r\n        wReadKeyAsBinary=new Button(wCryptoSettings, SWT.CHECK );\r\n        wReadKeyAsBinary.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ReadKeyAsBinary.Tooltip\"));\r\n        props.setLook(wReadKeyAsBinary);\r\n        fdReadKeyAsBinary=new FormData();\r\n        fdReadKeyAsBinary.left = new FormAttachment(middle, margin);\r\n        fdReadKeyAsBinary.top  = new FormAttachment(wSecretKeyField, margin);\r\n        fdReadKeyAsBinary.right= new FormAttachment(100, -margin);\r\n        wReadKeyAsBinary.setLayoutData(fdReadKeyAsBinary);\r\n        wReadKeyAsBinary.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                    input.setChanged();\r\n                }\r\n            }\r\n        );\r\n        \r\n\t\tfdCryptoSettings = new FormData();\r\n\t\tfdCryptoSettings.left = new FormAttachment(0, margin);\r\n\t\tfdCryptoSettings.top = new FormAttachment(wStepname, margin);\r\n\t\tfdCryptoSettings.right = new FormAttachment(100, -margin);\r\n\t\twCryptoSettings.setLayoutData(fdCryptoSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF  Crypto settings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\t\r\n\r\n\t\t// ////////////////////////\r\n\t\t// START OF Crypto settings GROUP\r\n\t\t// \r\n\r\n\t\twMessageGroup = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wMessageGroup);\r\n\t\twMessageGroup.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Message.Group.Label\"));\r\n\t\t\r\n\t\tFormLayout MessageGroupgroupLayout = new FormLayout();\r\n\t\tMessageGroupgroupLayout.marginWidth = 10;\r\n\t\tMessageGroupgroupLayout.marginHeight = 10;\r\n\t\twMessageGroup.setLayout(MessageGroupgroupLayout);\r\n\r\n\r\n\r\n\t\t\r\n    \t// FieldName to evaluate\r\n\t\twlMessage=new Label(wMessageGroup, SWT.RIGHT);\r\n        wlMessage.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.Field.Label\"));\r\n        props.setLook(wlMessage);\r\n        fdlMessage=new FormData();\r\n        fdlMessage.left = new FormAttachment(0, 0);\r\n        fdlMessage.top  = new FormAttachment(wCryptoSettings, margin);\r\n        fdlMessage.right= new FormAttachment(middle, -margin);\r\n        wlMessage.setLayoutData(fdlMessage);\r\n        wMessage=new CCombo(wMessageGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wMessage.setEditable(true);\r\n        props.setLook(wMessage);\r\n        wMessage.addModifyListener(lsMod);\r\n        fdField=new FormData();\r\n        fdField.left = new FormAttachment(middle, margin);\r\n        fdField.top  = new FormAttachment(wCryptoSettings, margin);\r\n        fdField.right= new FormAttachment(100, -margin);\r\n        wMessage.setLayoutData(fdField);\r\n        wMessage.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    setFieldname();\r\n                }\r\n            }\r\n        );\r\n\r\n      \r\n\t\tfdMessageGroup = new FormData();\r\n\t\tfdMessageGroup.left = new FormAttachment(0, margin);\r\n\t\tfdMessageGroup.top = new FormAttachment(wCryptoSettings, margin);\r\n\t\tfdMessageGroup.right = new FormAttachment(100, -margin);\r\n\t\twMessageGroup.setLayoutData(fdMessageGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF  Crypto settings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\t\r\n\r\n    \t// Step Output field grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF Output Field GROUP\r\n\t\t// \r\n\r\n\t\twOutputField = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wOutputField);\r\n\t\twOutputField.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ResultField.Group.Label\"));\r\n\t\t\r\n\t\tFormLayout outputfieldgroupLayout = new FormLayout();\r\n\t\toutputfieldgroupLayout.marginWidth = 10;\r\n\t\toutputfieldgroupLayout.marginHeight = 10;\r\n\t\twOutputField.setLayout(outputfieldgroupLayout);\r\n        \r\n\t      // Output Fieldame\r\n        wResultField = new LabelTextVar(transMeta, wOutputField, \r\n        \t\tBaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ResultField.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.ResultField.Tooltip\"));\r\n        props.setLook(wResultField);\r\n        wResultField .addModifyListener(lsMod);\r\n        fdResultField  = new FormData();\r\n        fdResultField .left = new FormAttachment(0, 0);\r\n        fdResultField .top = new FormAttachment(wMessageGroup, margin);\r\n        fdResultField .right = new FormAttachment(100, 0);\r\n        wResultField .setLayoutData(fdResultField );\r\n        \r\n\r\n        wlOutputAsBinary=new Label(wOutputField, SWT.RIGHT);\r\n        wlOutputAsBinary.setText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.OutputAsBinary.Label\")); //$NON-NLS-1$\r\n        props.setLook(wlOutputAsBinary);\r\n        fdlOutputAsBinary=new FormData();\r\n        fdlOutputAsBinary.left = new FormAttachment(0, 0);\r\n        fdlOutputAsBinary.top  = new FormAttachment(wResultField, margin);\r\n        fdlOutputAsBinary.right= new FormAttachment(middle, -margin);\r\n        wlOutputAsBinary.setLayoutData(fdlOutputAsBinary);\r\n        wOutputAsBinary=new Button(wOutputField, SWT.CHECK );\r\n        wOutputAsBinary.setToolTipText(BaseMessages.getString(PKG, \"SymmetricCryptoTransDialog.OutputAsBinary.Tooltip\"));\r\n        props.setLook(wOutputAsBinary);\r\n        fdOutputAsBinary=new FormData();\r\n        fdOutputAsBinary.left = new FormAttachment(middle, margin);\r\n        fdOutputAsBinary.top  = new FormAttachment(wResultField, margin);\r\n        fdOutputAsBinary.right= new FormAttachment(100, 0);\r\n        wOutputAsBinary.setLayoutData(fdOutputAsBinary);\r\n        wOutputAsBinary.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                    input.setChanged();\r\n                }\r\n            }\r\n        ); \r\n        \r\n        \r\n\t\tfdOutputField = new FormData();\r\n\t\tfdOutputField.left = new FormAttachment(0, margin);\r\n\t\tfdOutputField.top = new FormAttachment(wMessageGroup, margin);\r\n\t\tfdOutputField.right = new FormAttachment(100, -margin);\r\n\t\twOutputField.setLayoutData(fdOutputField);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Output Field GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\t\r\n\t        \r\n\t\tfdGeneralComp=new FormData();\r\n\t\tfdGeneralComp.left  = new FormAttachment(0, 0);\r\n\t\tfdGeneralComp.top   = new FormAttachment(wOutputField, 0);\r\n\t\tfdGeneralComp.right = new FormAttachment(100, 0);\r\n\t\tfdGeneralComp.bottom= new FormAttachment(100, 0);\r\n\t\twGeneralComp.setLayoutData(fdGeneralComp);\r\n\t\t\r\n\t\twGeneralComp.layout();\r\n\t\twGeneralTab.setControl(wGeneralComp);\r\n \t\tprops.setLook(wGeneralComp);\r\n \t\t\r\n \t\t\r\n \t\t\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF GENERAL TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n \t\t\r\n \t\t\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n\r\n\t\t// Add listeners\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();          } };\r\n\t\t\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();              } };\r\n\t\t\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\t\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\t\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// Whenever something changes, set the tooltip to the expanded version\r\n\t\t// of the filename:\r\n\t\twSecretKey.addModifyListener(new ModifyListener() {\r\n\t\t\tpublic void modifyText(ModifyEvent e) {\r\n\t\t\t\twSecretKey.setToolTipText(transMeta.environmentSubstitute(wSecretKey.getText()));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\tActivewlSecretKeyField();\r\n\r\n\t\t\r\n\t\tinput.setChanged(changed);\r\n\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","commit_id":"2658267ca32cb229de5e192ade0a8a71716710bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\toperationType = getOperationTypeByCode(Const.NVL(XMLHandler.getTagValue(stepnode,\t\"operation_type\"), \"\"));\r\n\t\t\talgorithm     = XMLHandler.getTagValue(stepnode, \"algorithm\");\r\n\t\t\tschema   = XMLHandler.getTagValue(stepnode, \"schema\");\r\n\t\t\tsecretKeyField     = XMLHandler.getTagValue(stepnode, \"secretKeyField\"); //$NON-NLS-1$\r\n\t\t\tmessageField     = XMLHandler.getTagValue(stepnode, \"messageField\"); //$NON-NLS-1$\r\n\t\t\tresultfieldname     = XMLHandler.getTagValue(stepnode, \"resultfieldname\"); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\tsecretKey     = XMLHandler.getTagValue(stepnode, \"secretKey\");\r\n\t\t\t\r\n\t\t\tsecretKeyInField = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"secretKeyInField\"));\t\r\n\t\t\treadKeyAsBinary = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"readKeyAsBinary\"));\t\r\n\t\t\toutputResultAsBinary = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"outputResultAsBinary\"));\t\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(BaseMessages.getString(PKG, \"SymmetricCryptoTransMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\r\n\t\t}\r\n\t}","id":80023,"modified_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\toperationType = getOperationTypeByCode(Const.NVL(XMLHandler.getTagValue(stepnode,\t\"operation_type\"), \"\"));\r\n\t\t\talgorithm     = XMLHandler.getTagValue(stepnode, \"algorithm\");\r\n\t\t\tschema   = XMLHandler.getTagValue(stepnode, \"schema\");\r\n\t\t\tsecretKeyField     = XMLHandler.getTagValue(stepnode, \"secretKeyField\"); //$NON-NLS-1$\r\n\t\t\tmessageField     = XMLHandler.getTagValue(stepnode, \"messageField\"); //$NON-NLS-1$\r\n\t\t\tresultfieldname     = XMLHandler.getTagValue(stepnode, \"resultfieldname\"); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\tsetSecretKey(Encr.decryptPasswordOptionallyEncrypted(XMLHandler.getTagValue(stepnode, \"secretKey\")));\r\n\t\t\tsecretKeyInField = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"secretKeyInField\"));\t\r\n\t\t\treadKeyAsBinary = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"readKeyAsBinary\"));\t\r\n\t\t\toutputResultAsBinary = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"outputResultAsBinary\"));\t\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(BaseMessages.getString(PKG, \"SymmetricCryptoTransMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\r\n\t\t}\r\n\t}","commit_id":"2658267ca32cb229de5e192ade0a8a71716710bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n            rep.saveStepAttribute(id_transformation, id_step, \"operation_type\", getOperationTypeCode(operationType));\r\n            rep.saveStepAttribute(id_transformation, id_step, \"algorithm\", algorithm);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"schema\", schema);\r\n            \r\n            rep.saveStepAttribute(id_transformation, id_step, \"secretKeyField\", secretKeyField); //$NON-NLS-1$\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"messageField\", messageField); //$NON-NLS-1$\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"resultfieldname\", resultfieldname); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"secretKey\", secretKey);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"secretKeyInField\",  secretKeyInField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"readKeyAsBinary\",  readKeyAsBinary);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"outputResultAsBinary\",  outputResultAsBinary);\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SymmetricCryptoTransMeta.Exception.UnableToSaveStepInfo\")+id_step, e); //$NON-NLS-1$\r\n\t\t}\r\n\t}","id":80024,"modified_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n            rep.saveStepAttribute(id_transformation, id_step, \"operation_type\", getOperationTypeCode(operationType));\r\n            rep.saveStepAttribute(id_transformation, id_step, \"algorithm\", algorithm);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"schema\", schema);\r\n            \r\n            rep.saveStepAttribute(id_transformation, id_step, \"secretKeyField\", secretKeyField); //$NON-NLS-1$\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"messageField\", messageField); //$NON-NLS-1$\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"resultfieldname\", resultfieldname); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"secretKey\", Encr.encryptPasswordIfNotUsingVariables(secretKey));\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"secretKeyInField\",  secretKeyInField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"readKeyAsBinary\",  readKeyAsBinary);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"outputResultAsBinary\",  outputResultAsBinary);\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SymmetricCryptoTransMeta.Exception.UnableToSaveStepInfo\")+id_step, e); //$NON-NLS-1$\r\n\t\t}\r\n\t}","commit_id":"2658267ca32cb229de5e192ade0a8a71716710bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\r\n\t{\r\n        StringBuffer retval = new StringBuffer();\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"operation_type\",getOperationTypeCode(operationType)));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"algorithm\", algorithm));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"schema\", schema));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"secretKeyField\", secretKeyField)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"messageField\", messageField)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"resultfieldname\", resultfieldname)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"secretKey\", secretKey));\r\n\t\t\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"secretKeyInField\",  secretKeyInField));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"readKeyAsBinary\",  readKeyAsBinary));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"outputResultAsBinary\",  outputResultAsBinary));\r\n\t\t\r\n\t\t\r\n\r\n\t\treturn retval.toString();\r\n\t}","id":80025,"modified_method":"public String getXML()\r\n\t{\r\n        StringBuffer retval = new StringBuffer();\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"operation_type\",getOperationTypeCode(operationType)));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"algorithm\", algorithm));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"schema\", schema));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"secretKeyField\", secretKeyField)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"messageField\", messageField)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"resultfieldname\", resultfieldname)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"secretKey\", Encr.encryptPasswordIfNotUsingVariables(secretKey)));\r\n\t\t\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"secretKeyInField\",  secretKeyInField));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"readKeyAsBinary\",  readKeyAsBinary));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"outputResultAsBinary\",  outputResultAsBinary));\r\n\t\t\r\n\t\t\r\n\r\n\t\treturn retval.toString();\r\n\t}","commit_id":"2658267ca32cb229de5e192ade0a8a71716710bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n        \toperationType = getOperationTypeByCode(Const.NVL(rep.getStepAttributeString(id_step, \"operation_type\"), \"\"));\r\n        \talgorithm     = rep.getStepAttributeString(id_step, \"algorithm\");\r\n        \tschema    = rep.getStepAttributeString(id_step, \"schema\");\r\n        \tsecretKeyField     = rep.getStepAttributeString(id_step, \"secretKeyField\"); //$NON-NLS-1$\r\n\t\t\tmessageField     = rep.getStepAttributeString(id_step, \"messageField\"); //$NON-NLS-1$\r\n\t\t\tresultfieldname     = rep.getStepAttributeString(id_step, \"resultfieldname\"); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\tsecretKey     = rep.getStepAttributeString(id_step, \"secretKey\");\r\n\t\t\tsecretKeyInField    =      rep.getStepAttributeBoolean(id_step, \"secretKeyInField\"); \r\n\t\t\treadKeyAsBinary    =      rep.getStepAttributeBoolean(id_step, \"readKeyAsBinary\"); \r\n\t\t\toutputResultAsBinary  =      rep.getStepAttributeBoolean(id_step, \"outputResultAsBinary\"); \r\n\t\t\t\r\n\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SymmetricCryptoTransMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\r\n\t\t}\r\n\t}","id":80026,"modified_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n        \toperationType = getOperationTypeByCode(Const.NVL(rep.getStepAttributeString(id_step, \"operation_type\"), \"\"));\r\n        \talgorithm     = rep.getStepAttributeString(id_step, \"algorithm\");\r\n        \tschema    = rep.getStepAttributeString(id_step, \"schema\");\r\n        \tsecretKeyField     = rep.getStepAttributeString(id_step, \"secretKeyField\"); //$NON-NLS-1$\r\n\t\t\tmessageField     = rep.getStepAttributeString(id_step, \"messageField\"); //$NON-NLS-1$\r\n\t\t\tresultfieldname     = rep.getStepAttributeString(id_step, \"resultfieldname\"); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\tsecretKey              = Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString (id_step, \"secretKey\") );\t\r\n\t\t\tsecretKeyInField    =      rep.getStepAttributeBoolean(id_step, \"secretKeyInField\"); \r\n\t\t\treadKeyAsBinary    =      rep.getStepAttributeBoolean(id_step, \"readKeyAsBinary\"); \r\n\t\t\toutputResultAsBinary  =      rep.getStepAttributeBoolean(id_step, \"outputResultAsBinary\"); \r\n\t\t\t\r\n\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SymmetricCryptoTransMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\r\n\t\t}\r\n\t}","commit_id":"2658267ca32cb229de5e192ade0a8a71716710bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                highestTxId = info.getLastCommittedTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master != null ? master : Machine.NO_MACHINE;\n    }","id":80027,"modified_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                if ( info.getLastCommittedTxId() > highestTxId || info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                    highestTxId = info.getLastCommittedTxId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master != null ? master : Machine.NO_MACHINE;\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized Map<Integer, Machine> getAllMachines( boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        try\n        {\n            Map<Integer, Machine> result = new HashMap<Integer, Machine>();\n            String root = getRoot();\n            List<String> children = getZooKeeper().getChildren( root, false );\n            for ( String child : children )\n            {\n                Pair<Integer, Integer> parsedChild = parseChild( child );\n                if ( parsedChild == null )\n                {\n                    continue;\n                }\n                \n                try\n                {\n                    int id = parsedChild.first();\n                    int seq = parsedChild.other();\n                    long tx = readDataAsLong( root + \"/\" + child );\n                    if ( !result.containsKey( id ) || seq > result.get( id ).getSequenceId() )\n                    {\n                        result.put( id, new Machine( id, seq, tx, getHaServer( id ) ) );\n                    }\n                }\n                catch ( KeeperException inner )\n                {\n                    if ( inner.code() != KeeperException.Code.NONODE )\n                    {\n                        throw new ZooKeeperException( \"Unabe to get master.\", \n                            inner );\n                    }\n                }\n            }\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Unable to get master\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted.\", e );\n        }\n    }","id":80028,"modified_method":"protected synchronized Map<Integer, Machine> getAllMachines( boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        try\n        {\n            Map<Integer, Machine> result = new HashMap<Integer, Machine>();\n            String root = getRoot();\n            List<String> children = getZooKeeper().getChildren( root, false );\n            for ( String child : children )\n            {\n                Pair<Integer, Integer> parsedChild = parseChild( child );\n                if ( parsedChild == null )\n                {\n                    continue;\n                }\n                \n                try\n                {\n                    int id = parsedChild.first();\n                    int seq = parsedChild.other();\n                    long tx = readDataAsLong( root + \"/\" + child );\n                    if ( !result.containsKey( id ) || seq > result.get( id ).getSequenceId() )\n                    {\n                        result.put( id, new Machine( id, seq, tx, getHaServer( id, wait ) ) );\n                    }\n                }\n                catch ( KeeperException inner )\n                {\n                    if ( inner.code() != KeeperException.Code.NONODE )\n                    {\n                        throw new ZooKeeperException( \"Unabe to get master.\", \n                            inner );\n                    }\n                }\n            }\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Unable to get master\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted.\", e );\n        }\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String readHaServer( int machineId )\n    {\n        waitForSyncConnected();\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            System.out.println( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":80029,"modified_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            System.out.println( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String getHaServer( int machineId )\n    {\n        String result = haServersCache.get( machineId );\n        if ( result == null )\n        {\n            result = readHaServer( machineId );\n            haServersCache.put( machineId, result );\n        }\n        return result;\n    }","id":80030,"modified_method":"protected String getHaServer( int machineId, boolean wait )\n    {\n        String result = haServersCache.get( machineId );\n        if ( result == null )\n        {\n            result = readHaServer( machineId, wait );\n            haServersCache.put( machineId, result );\n        }\n        return result;\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n                tryToEnsureIAmNotABrokenMachine( master );\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","id":80031,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself \" + master );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( this.localGraph == null || !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( this.localGraph == null || iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startAsMaster()\n    {\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                CommonFactories.defaultLockManagerFactory(),\n                new MasterIdGeneratorFactory(),\n                CommonFactories.defaultRelationshipTypeCreator(),\n                new MasterTxIdGeneratorFactory( broker ),\n                CommonFactories.defaultTxFinishHook(),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        this.masterServer = (MasterServer) broker.instantiateMasterServer( this );\n        instantiateIndexIfNeeded();\n    }","id":80032,"modified_method":"private void startAsMaster()\n    {\n        System.out.println( \"Starting as master\" );\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                CommonFactories.defaultLockManagerFactory(),\n                new MasterIdGeneratorFactory(),\n                CommonFactories.defaultRelationshipTypeCreator(),\n                new MasterTxIdGeneratorFactory( broker ),\n                CommonFactories.defaultTxFinishHook(),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        this.masterServer = (MasterServer) broker.instantiateMasterServer( this );\n        instantiateIndexIfNeeded();\n        System.out.println( \"Started as master\" );\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startAsSlave()\n    {\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                new SlaveLockManagerFactory( broker, this ),\n                new SlaveIdGeneratorFactory( broker, this ),\n                new SlaveRelationshipTypeCreator( broker, this ),\n                new SlaveTxIdGeneratorFactory( broker, this ),\n                new SlaveTxRollbackHook( broker, this ),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        instantiateIndexIfNeeded();\n        instantiateAutoUpdatePullerIfConfigSaysSo();\n    }","id":80033,"modified_method":"private void startAsSlave()\n    {\n        System.out.println( \"Starting as slave\" );\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                new SlaveLockManagerFactory( broker, this ),\n                new SlaveIdGeneratorFactory( broker, this ),\n                new SlaveRelationshipTypeCreator( broker, this ),\n                new SlaveTxIdGeneratorFactory( broker, this ),\n                new SlaveTxRollbackHook( broker, this ),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        instantiateIndexIfNeeded();\n        instantiateAutoUpdatePullerIfConfigSaysSo();\n        System.out.println( \"Started as slave\" );\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n        new Exception( \"ReevaluateMyself\" ).printStackTrace();\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","id":80034,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw e;\n        }\n    }","id":80035,"modified_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","id":80036,"modified_method":"public void pullUpdates()\n    {\n        System.out.println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        println( \"Job \" + job + \" executed\" );\n        return result;\n    }","id":80037,"modified_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        System.out.println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        System.out.println( \"Job \" + job + \" executed\" );\n        return result;\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void println( String string, Throwable t )\n    {\n        println( string );\n        t.printStackTrace( out );\n    }","id":80038,"modified_method":"private void println( String string, Throwable t )\n    {\n        System.out.println( string );\n        t.printStackTrace();\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, null ),\n                        \"index\", args.get( \"index\", null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                Number masterId = args.getNumber( \"master-id\", null );\n                Master master = new MasterClient( \"localhost\", CommunicationProtocol.PORT );\n                AbstractBroker broker = isMaster ? new FakeMasterBroker( tempMachineId ) :\n                        new FakeSlaveBroker( master, masterId.intValue(), tempMachineId );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        \"index\", args.get( \"index\", null ) ),\n                        AbstractBroker.wrapSingleBroker( broker ) );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","id":80039,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) )\n        {\n            public void println(String x)\n            {\n                super.println( new SimpleDateFormat( \"HH:mm:ss:SS\" ).format( new Date() ) + \": \" + x );\n            }\n        };\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            System.out.println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            System.out.println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, null ),\n                        \"index\", args.get( \"index\", null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                System.out.println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                Number masterId = args.getNumber( \"master-id\", null );\n                Master master = new MasterClient( \"localhost\", CommunicationProtocol.PORT );\n                AbstractBroker broker = isMaster ? new FakeMasterBroker( tempMachineId ) :\n                        new FakeSlaveBroker( master, masterId.intValue(), tempMachineId );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        \"index\", args.get( \"index\", null ) ),\n                        AbstractBroker.wrapSingleBroker( broker ) );\n                System.out.println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            System.out.println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void initiateShutdown() throws RemoteException\n    {\n        println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        println( \"shutdown 1\" );\n        this.db.shutdown();\n        println( \"shutdown 1\" );\n        this.shutdown = true;\n        println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 50 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","id":80040,"modified_method":"public void initiateShutdown() throws RemoteException\n    {\n        System.out.println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        this.db.shutdown();\n        this.shutdown = true;\n        System.out.println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 50 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n            System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n            sequenceNr = setup();\n            System.out.println( \"setup\" );\n            keeperState = KeeperState.SyncConnected;\n            Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n            System.out.println( \"current master \" + currentMaster );\n            \n            // Master has changed since last time I checked and it's not me\n            if ( currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId() &&\n                    currentMaster.other().getMachineId() != machineId )\n            {\n                System.out.println( \"Master changed and it's not me\" );\n                setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n            }\n            else if ( masterBeforeIWrite.other().getMachineId() == -1 &&\n                    currentMaster.other().getMachineId() == machineId )\n            {\n                System.out.println( \"2\" );\n                receiver.newMaster( currentMaster, new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n            if ( path.contains( MASTER_NOTIFY_CHILD ) )\n            {\n                setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                if ( currentMaster.other().getMachineId() == machineId )\n                {\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path.contains( MASTER_REBOUND_CHILD ) )\n            {\n                setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                if ( currentMaster.other().getMachineId() != machineId )\n                {\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else\n            {\n                System.out.println( \"Unrecognized data change \" + path );\n            }\n        }\n    }","id":80041,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> cachedMaster = getCachedMaster();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n                System.out.println( \"current master \" + currentMaster );\n                \n                // Master has changed since last time I checked and it's not me\n                if ( (cachedMaster.other().getMachineId() == -1 || currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId()) &&\n                        currentMaster.other().getMachineId() != machineId )\n                {\n                    System.out.println( \"Master changed and it's not me\" );\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n                else if ( /*masterBeforeIWrite.other().getMachineId() == -1  && */\n                        currentMaster.other().getMachineId() == machineId )\n                {\n                    System.out.println( \"2\" );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String getHaServer( int machineId )\n    {\n        return machineId == this.machineId ? haServer : super.getHaServer( machineId );\n    }","id":80042,"modified_method":"@Override\n    protected String getHaServer( int machineId, boolean wait )\n    {\n        return machineId == this.machineId ? haServer : super.getHaServer( machineId, wait );\n    }","commit_id":"741d82c571ece5cbc33daf13c18ca1c5b9196b5c","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String getHaServer( int machineId )\n    {\n        String result = haServersCache.get( machineId );\n        if ( result == null )\n        {\n            result = readHaServer( machineId );\n            haServersCache.put( machineId, result );\n        }\n        return result;\n    }","id":80043,"modified_method":"protected String getHaServer( int machineId, boolean wait )\n    {\n        String result = haServersCache.get( machineId );\n        if ( result == null )\n        {\n            result = readHaServer( machineId, wait );\n            haServersCache.put( machineId, result );\n        }\n        return result;\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                highestTxId = info.getLastCommittedTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master != null ? master : Machine.NO_MACHINE;\n    }","id":80044,"modified_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                if ( info.getLastCommittedTxId() > highestTxId || info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                    highestTxId = info.getLastCommittedTxId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master != null ? master : Machine.NO_MACHINE;\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String readHaServer( int machineId )\n    {\n        waitForSyncConnected();\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            System.out.println( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":80045,"modified_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            System.out.println( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized Map<Integer, Machine> getAllMachines( boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        try\n        {\n            Map<Integer, Machine> result = new HashMap<Integer, Machine>();\n            String root = getRoot();\n            List<String> children = getZooKeeper().getChildren( root, false );\n            for ( String child : children )\n            {\n                Pair<Integer, Integer> parsedChild = parseChild( child );\n                if ( parsedChild == null )\n                {\n                    continue;\n                }\n                \n                try\n                {\n                    int id = parsedChild.first();\n                    int seq = parsedChild.other();\n                    long tx = readDataAsLong( root + \"/\" + child );\n                    if ( !result.containsKey( id ) || seq > result.get( id ).getSequenceId() )\n                    {\n                        result.put( id, new Machine( id, seq, tx, getHaServer( id ) ) );\n                    }\n                }\n                catch ( KeeperException inner )\n                {\n                    if ( inner.code() != KeeperException.Code.NONODE )\n                    {\n                        throw new ZooKeeperException( \"Unabe to get master.\", \n                            inner );\n                    }\n                }\n            }\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Unable to get master\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted.\", e );\n        }\n    }","id":80046,"modified_method":"protected synchronized Map<Integer, Machine> getAllMachines( boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        try\n        {\n            Map<Integer, Machine> result = new HashMap<Integer, Machine>();\n            String root = getRoot();\n            List<String> children = getZooKeeper().getChildren( root, false );\n            for ( String child : children )\n            {\n                Pair<Integer, Integer> parsedChild = parseChild( child );\n                if ( parsedChild == null )\n                {\n                    continue;\n                }\n                \n                try\n                {\n                    int id = parsedChild.first();\n                    int seq = parsedChild.other();\n                    long tx = readDataAsLong( root + \"/\" + child );\n                    if ( !result.containsKey( id ) || seq > result.get( id ).getSequenceId() )\n                    {\n                        result.put( id, new Machine( id, seq, tx, getHaServer( id, wait ) ) );\n                    }\n                }\n                catch ( KeeperException inner )\n                {\n                    if ( inner.code() != KeeperException.Code.NONODE )\n                    {\n                        throw new ZooKeeperException( \"Unabe to get master.\", \n                            inner );\n                    }\n                }\n            }\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Unable to get master\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted.\", e );\n        }\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n                tryToEnsureIAmNotABrokenMachine( master );\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","id":80047,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself \" + master );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( this.localGraph == null || !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( this.localGraph == null || iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw e;\n        }\n    }","id":80048,"modified_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n        new Exception( \"ReevaluateMyself\" ).printStackTrace();\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","id":80049,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startAsMaster()\n    {\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                CommonFactories.defaultLockManagerFactory(),\n                new MasterIdGeneratorFactory(),\n                CommonFactories.defaultRelationshipTypeCreator(),\n                new MasterTxIdGeneratorFactory( broker ),\n                CommonFactories.defaultTxFinishHook(),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        this.masterServer = (MasterServer) broker.instantiateMasterServer( this );\n        instantiateIndexIfNeeded();\n    }","id":80050,"modified_method":"private void startAsMaster()\n    {\n        System.out.println( \"Starting as master\" );\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                CommonFactories.defaultLockManagerFactory(),\n                new MasterIdGeneratorFactory(),\n                CommonFactories.defaultRelationshipTypeCreator(),\n                new MasterTxIdGeneratorFactory( broker ),\n                CommonFactories.defaultTxFinishHook(),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        this.masterServer = (MasterServer) broker.instantiateMasterServer( this );\n        instantiateIndexIfNeeded();\n        System.out.println( \"Started as master\" );\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startAsSlave()\n    {\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                new SlaveLockManagerFactory( broker, this ),\n                new SlaveIdGeneratorFactory( broker, this ),\n                new SlaveRelationshipTypeCreator( broker, this ),\n                new SlaveTxIdGeneratorFactory( broker, this ),\n                new SlaveTxRollbackHook( broker, this ),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        instantiateIndexIfNeeded();\n        instantiateAutoUpdatePullerIfConfigSaysSo();\n    }","id":80051,"modified_method":"private void startAsSlave()\n    {\n        System.out.println( \"Starting as slave\" );\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                new SlaveLockManagerFactory( broker, this ),\n                new SlaveIdGeneratorFactory( broker, this ),\n                new SlaveRelationshipTypeCreator( broker, this ),\n                new SlaveTxIdGeneratorFactory( broker, this ),\n                new SlaveTxRollbackHook( broker, this ),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        instantiateIndexIfNeeded();\n        instantiateAutoUpdatePullerIfConfigSaysSo();\n        System.out.println( \"Started as slave\" );\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void initiateShutdown() throws RemoteException\n    {\n        println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        println( \"shutdown 1\" );\n        this.db.shutdown();\n        println( \"shutdown 1\" );\n        this.shutdown = true;\n        println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 50 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","id":80052,"modified_method":"public void initiateShutdown() throws RemoteException\n    {\n        System.out.println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        this.db.shutdown();\n        this.shutdown = true;\n        System.out.println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 50 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void println( String string, Throwable t )\n    {\n        println( string );\n        t.printStackTrace( out );\n    }","id":80053,"modified_method":"private void println( String string, Throwable t )\n    {\n        System.out.println( string );\n        t.printStackTrace();\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, null ),\n                        \"index\", args.get( \"index\", null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                Number masterId = args.getNumber( \"master-id\", null );\n                Master master = new MasterClient( \"localhost\", CommunicationProtocol.PORT );\n                AbstractBroker broker = isMaster ? new FakeMasterBroker( tempMachineId ) :\n                        new FakeSlaveBroker( master, masterId.intValue(), tempMachineId );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        \"index\", args.get( \"index\", null ) ),\n                        AbstractBroker.wrapSingleBroker( broker ) );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","id":80054,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) )\n        {\n            public void println(String x)\n            {\n                super.println( new SimpleDateFormat( \"HH:mm:ss:SS\" ).format( new Date() ) + \": \" + x );\n            }\n        };\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            System.out.println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            System.out.println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, null ),\n                        \"index\", args.get( \"index\", null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                System.out.println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                Number masterId = args.getNumber( \"master-id\", null );\n                Master master = new MasterClient( \"localhost\", CommunicationProtocol.PORT );\n                AbstractBroker broker = isMaster ? new FakeMasterBroker( tempMachineId ) :\n                        new FakeSlaveBroker( master, masterId.intValue(), tempMachineId );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        \"index\", args.get( \"index\", null ) ),\n                        AbstractBroker.wrapSingleBroker( broker ) );\n                System.out.println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            System.out.println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        println( \"Job \" + job + \" executed\" );\n        return result;\n    }","id":80055,"modified_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        System.out.println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        System.out.println( \"Job \" + job + \" executed\" );\n        return result;\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","id":80056,"modified_method":"public void pullUpdates()\n    {\n        System.out.println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String getHaServer( int machineId )\n    {\n        return machineId == this.machineId ? haServer : super.getHaServer( machineId );\n    }","id":80057,"modified_method":"@Override\n    protected String getHaServer( int machineId, boolean wait )\n    {\n        return machineId == this.machineId ? haServer : super.getHaServer( machineId, wait );\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n            System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n            sequenceNr = setup();\n            System.out.println( \"setup\" );\n            keeperState = KeeperState.SyncConnected;\n            Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n            System.out.println( \"current master \" + currentMaster );\n            \n            // Master has changed since last time I checked and it's not me\n            if ( currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId() &&\n                    currentMaster.other().getMachineId() != machineId )\n            {\n                System.out.println( \"Master changed and it's not me\" );\n                setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n            }\n            else if ( masterBeforeIWrite.other().getMachineId() == -1 &&\n                    currentMaster.other().getMachineId() == machineId )\n            {\n                System.out.println( \"2\" );\n                receiver.newMaster( currentMaster, new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n            if ( path.contains( MASTER_NOTIFY_CHILD ) )\n            {\n                setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                if ( currentMaster.other().getMachineId() == machineId )\n                {\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path.contains( MASTER_REBOUND_CHILD ) )\n            {\n                setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                if ( currentMaster.other().getMachineId() != machineId )\n                {\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else\n            {\n                System.out.println( \"Unrecognized data change \" + path );\n            }\n        }\n    }","id":80058,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> cachedMaster = getCachedMaster();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n                System.out.println( \"current master \" + currentMaster );\n                \n                // Master has changed since last time I checked and it's not me\n                if ( (cachedMaster.other().getMachineId() == -1 || currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId()) &&\n                        currentMaster.other().getMachineId() != machineId )\n                {\n                    System.out.println( \"Master changed and it's not me\" );\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n                else if ( /*masterBeforeIWrite.other().getMachineId() == -1  && */\n                        currentMaster.other().getMachineId() == machineId )\n                {\n                    System.out.println( \"2\" );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"22bd81c91f3d12151f2dd70ea41093c7ebd4c3e7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String getHaServer( int machineId )\n    {\n        String result = haServersCache.get( machineId );\n        if ( result == null )\n        {\n            result = readHaServer( machineId );\n            haServersCache.put( machineId, result );\n        }\n        return result;\n    }","id":80059,"modified_method":"protected String getHaServer( int machineId, boolean wait )\n    {\n        String result = haServersCache.get( machineId );\n        if ( result == null )\n        {\n            result = readHaServer( machineId, wait );\n            haServersCache.put( machineId, result );\n        }\n        return result;\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String readHaServer( int machineId )\n    {\n        waitForSyncConnected();\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            System.out.println( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":80060,"modified_method":"protected String readHaServer( int machineId, boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        String rootPath = getRoot();\n        try\n        {\n            String haServerPath = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId;\n            byte[] serverData = getZooKeeper().getData( haServerPath, false, null );\n            ByteBuffer buffer = ByteBuffer.wrap( serverData );\n            byte length = buffer.get();\n            char[] chars = new char[length];\n            buffer.asCharBuffer().get( chars );\n            String result = String.valueOf( chars );\n            System.out.println( \"Read HA server:\" + result + \" (for machineID \" + machineId +\n                    \") from zoo keeper\" );\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Couldn't find the HA servers root node\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized Map<Integer, Machine> getAllMachines( boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        try\n        {\n            Map<Integer, Machine> result = new HashMap<Integer, Machine>();\n            String root = getRoot();\n            List<String> children = getZooKeeper().getChildren( root, false );\n            for ( String child : children )\n            {\n                Pair<Integer, Integer> parsedChild = parseChild( child );\n                if ( parsedChild == null )\n                {\n                    continue;\n                }\n                \n                try\n                {\n                    int id = parsedChild.first();\n                    int seq = parsedChild.other();\n                    long tx = readDataAsLong( root + \"/\" + child );\n                    if ( !result.containsKey( id ) || seq > result.get( id ).getSequenceId() )\n                    {\n                        result.put( id, new Machine( id, seq, tx, getHaServer( id ) ) );\n                    }\n                }\n                catch ( KeeperException inner )\n                {\n                    if ( inner.code() != KeeperException.Code.NONODE )\n                    {\n                        throw new ZooKeeperException( \"Unabe to get master.\", \n                            inner );\n                    }\n                }\n            }\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Unable to get master\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted.\", e );\n        }\n    }","id":80061,"modified_method":"protected synchronized Map<Integer, Machine> getAllMachines( boolean wait )\n    {\n        if ( wait )\n        {\n            waitForSyncConnected();\n        }\n        try\n        {\n            Map<Integer, Machine> result = new HashMap<Integer, Machine>();\n            String root = getRoot();\n            List<String> children = getZooKeeper().getChildren( root, false );\n            for ( String child : children )\n            {\n                Pair<Integer, Integer> parsedChild = parseChild( child );\n                if ( parsedChild == null )\n                {\n                    continue;\n                }\n                \n                try\n                {\n                    int id = parsedChild.first();\n                    int seq = parsedChild.other();\n                    long tx = readDataAsLong( root + \"/\" + child );\n                    if ( !result.containsKey( id ) || seq > result.get( id ).getSequenceId() )\n                    {\n                        result.put( id, new Machine( id, seq, tx, getHaServer( id, wait ) ) );\n                    }\n                }\n                catch ( KeeperException inner )\n                {\n                    if ( inner.code() != KeeperException.Code.NONODE )\n                    {\n                        throw new ZooKeeperException( \"Unabe to get master.\", \n                            inner );\n                    }\n                }\n            }\n            return result;\n        }\n        catch ( KeeperException e )\n        {\n            throw new ZooKeeperException( \"Unable to get master\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted.\", e );\n        }\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                highestTxId = info.getLastCommittedTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master != null ? master : Machine.NO_MACHINE;\n    }","id":80062,"modified_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                if ( info.getLastCommittedTxId() > highestTxId || info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                    highestTxId = info.getLastCommittedTxId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master != null ? master : Machine.NO_MACHINE;\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n        new Exception( \"ReevaluateMyself\" ).printStackTrace();\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","id":80063,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n                tryToEnsureIAmNotABrokenMachine( master );\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","id":80064,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself \" + master );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( this.localGraph == null || !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( this.localGraph == null || iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startAsMaster()\n    {\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                CommonFactories.defaultLockManagerFactory(),\n                new MasterIdGeneratorFactory(),\n                CommonFactories.defaultRelationshipTypeCreator(),\n                new MasterTxIdGeneratorFactory( broker ),\n                CommonFactories.defaultTxFinishHook(),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        this.masterServer = (MasterServer) broker.instantiateMasterServer( this );\n        instantiateIndexIfNeeded();\n    }","id":80065,"modified_method":"private void startAsMaster()\n    {\n        System.out.println( \"Starting as master\" );\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                CommonFactories.defaultLockManagerFactory(),\n                new MasterIdGeneratorFactory(),\n                CommonFactories.defaultRelationshipTypeCreator(),\n                new MasterTxIdGeneratorFactory( broker ),\n                CommonFactories.defaultTxFinishHook(),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        this.masterServer = (MasterServer) broker.instantiateMasterServer( this );\n        instantiateIndexIfNeeded();\n        System.out.println( \"Started as master\" );\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw e;\n        }\n    }","id":80066,"modified_method":"public void pullUpdates()\n    {\n        try\n        {\n            receive( broker.getMaster().first().pullUpdates( getSlaveContext( -1 ) ) );\n        }\n        catch ( ZooKeeperException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startAsSlave()\n    {\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                new SlaveLockManagerFactory( broker, this ),\n                new SlaveIdGeneratorFactory( broker, this ),\n                new SlaveRelationshipTypeCreator( broker, this ),\n                new SlaveTxIdGeneratorFactory( broker, this ),\n                new SlaveTxRollbackHook( broker, this ),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        instantiateIndexIfNeeded();\n        instantiateAutoUpdatePullerIfConfigSaysSo();\n    }","id":80067,"modified_method":"private void startAsSlave()\n    {\n        System.out.println( \"Starting as slave\" );\n        this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                new SlaveLockManagerFactory( broker, this ),\n                new SlaveIdGeneratorFactory( broker, this ),\n                new SlaveRelationshipTypeCreator( broker, this ),\n                new SlaveTxIdGeneratorFactory( broker, this ),\n                new SlaveTxRollbackHook( broker, this ),\n                new ZooKeeperLastCommittedTxIdSetter( broker ) );\n        instantiateIndexIfNeeded();\n        instantiateAutoUpdatePullerIfConfigSaysSo();\n        System.out.println( \"Started as slave\" );\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void println( String string, Throwable t )\n    {\n        println( string );\n        t.printStackTrace( out );\n    }","id":80068,"modified_method":"private void println( String string, Throwable t )\n    {\n        System.out.println( string );\n        t.printStackTrace();\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void initiateShutdown() throws RemoteException\n    {\n        println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        println( \"shutdown 1\" );\n        this.db.shutdown();\n        println( \"shutdown 1\" );\n        this.shutdown = true;\n        println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 50 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","id":80069,"modified_method":"public void initiateShutdown() throws RemoteException\n    {\n        System.out.println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        this.db.shutdown();\n        this.shutdown = true;\n        System.out.println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 50 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        println( \"Job \" + job + \" executed\" );\n        return result;\n    }","id":80070,"modified_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        System.out.println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        System.out.println( \"Job \" + job + \" executed\" );\n        return result;\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, null ),\n                        \"index\", args.get( \"index\", null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                Number masterId = args.getNumber( \"master-id\", null );\n                Master master = new MasterClient( \"localhost\", CommunicationProtocol.PORT );\n                AbstractBroker broker = isMaster ? new FakeMasterBroker( tempMachineId ) :\n                        new FakeSlaveBroker( master, masterId.intValue(), tempMachineId );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        \"index\", args.get( \"index\", null ) ),\n                        AbstractBroker.wrapSingleBroker( broker ) );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","id":80071,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) )\n        {\n            public void println(String x)\n            {\n                super.println( new SimpleDateFormat( \"HH:mm:ss:SS\" ).format( new Date() ) + \": \" + x );\n            }\n        };\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            System.out.println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            System.out.println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, null ),\n                        \"index\", args.get( \"index\", null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                System.out.println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                Number masterId = args.getNumber( \"master-id\", null );\n                Master master = new MasterClient( \"localhost\", CommunicationProtocol.PORT );\n                AbstractBroker broker = isMaster ? new FakeMasterBroker( tempMachineId ) :\n                        new FakeSlaveBroker( master, masterId.intValue(), tempMachineId );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        \"index\", args.get( \"index\", null ) ),\n                        AbstractBroker.wrapSingleBroker( broker ) );\n                System.out.println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            System.out.println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","id":80072,"modified_method":"public void pullUpdates()\n    {\n        System.out.println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n            System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n            sequenceNr = setup();\n            System.out.println( \"setup\" );\n            keeperState = KeeperState.SyncConnected;\n            Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n            System.out.println( \"current master \" + currentMaster );\n            \n            // Master has changed since last time I checked and it's not me\n            if ( currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId() &&\n                    currentMaster.other().getMachineId() != machineId )\n            {\n                System.out.println( \"Master changed and it's not me\" );\n                setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n            }\n            else if ( masterBeforeIWrite.other().getMachineId() == -1 &&\n                    currentMaster.other().getMachineId() == machineId )\n            {\n                System.out.println( \"2\" );\n                receiver.newMaster( currentMaster, new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n            if ( path.contains( MASTER_NOTIFY_CHILD ) )\n            {\n                setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                if ( currentMaster.other().getMachineId() == machineId )\n                {\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path.contains( MASTER_REBOUND_CHILD ) )\n            {\n                setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                if ( currentMaster.other().getMachineId() != machineId )\n                {\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else\n            {\n                System.out.println( \"Unrecognized data change \" + path );\n            }\n        }\n    }","id":80073,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> cachedMaster = getCachedMaster();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n                System.out.println( \"current master \" + currentMaster );\n                \n                // Master has changed since last time I checked and it's not me\n                if ( (cachedMaster.other().getMachineId() == -1 || currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId()) &&\n                        currentMaster.other().getMachineId() != machineId )\n                {\n                    System.out.println( \"Master changed and it's not me\" );\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n                else if ( /*masterBeforeIWrite.other().getMachineId() == -1  && */\n                        currentMaster.other().getMachineId() == machineId )\n                {\n                    System.out.println( \"2\" );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String getHaServer( int machineId )\n    {\n        return machineId == this.machineId ? haServer : super.getHaServer( machineId );\n    }","id":80074,"modified_method":"@Override\n    protected String getHaServer( int machineId, boolean wait )\n    {\n        return machineId == this.machineId ? haServer : super.getHaServer( machineId, wait );\n    }","commit_id":"f5936bd08509fd4053f33adbbd84493d3b0b3700","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void execUpdate(Execution exec, List requests, AuWriter out)\n\tthrows IOException {\n\t\tif (requests == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tassert D.OFF || ExecutionsCtrl.getCurrentCtrl() == null:\n\t\t\t\"Impossible to re-activate for update: old=\"+ExecutionsCtrl.getCurrentCtrl()+\", new=\"+exec;\n\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)desktop;\n\t\tfinal Configuration config = desktop.getWebApp().getConfiguration();\n\n\t\tfinal PerformanceMeter pfmeter = config.getPerformanceMeter();\n\t\tlong startTime = 0;\n\t\tif (pfmeter != null) {\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t\t\t//snapshot time since activate might take time\n\t\t\tmeterAuClientComplete(pfmeter, exec);\n\t\t}\n\n\t\tfinal Object[] resultOfRepeat = new Object[1];\n\t\tfinal UiVisualizer uv = doActivate(exec, true, false, resultOfRepeat);\n\t\tif (resultOfRepeat[0] != null) {\n\t\t\tout.resend(resultOfRepeat[0]);\n\t\t\tdoDeactivate(exec);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Monitor monitor = config.getMonitor();\n\t\tif (monitor != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beforeUpdate(desktop, requests);\n\t\t\t} catch (Throwable ex) {\n\t\t\t\tlog.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tfinal String pfReqId =\n\t\t\tpfmeter != null ? meterAuStart(pfmeter, exec, startTime): null;\n\t\tCollection doneReqIds = null; //request IDs that have been processed\n\t\tAbortingReason abrn = null;\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tfinal RequestQueue rque = desktopCtrl.getRequestQueue();\n\t\t\trque.addRequests(requests);\n\n\t\t\tconfig.invokeExecutionInits(exec, null);\n\t\t\tdesktopCtrl.invokeExecutionInits(exec, null);\n\n\t\t\tif (pfReqId != null) rque.addPerfRequestId(pfReqId);\n\n\t\t\tfinal List errs = new LinkedList();\n\t\t\t//Process all; ignore getMaxProcessTime();\n\t\t\t//we cannot handle them partially since UUID might be recycled\n\t\t\tfor (AuRequest request; (request = rque.nextRequest()) != null;) {\n\t\t\t\t//Cycle 1: Process one request\n\t\t\t\t//Don't process more such that requests will be queued\n\t\t\t\t//and we have the chance to optimize them\n\t\t\t\ttry {\n\t\t\t\t\tprocess(exec, request, !errs.isEmpty());\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t//we don't skip request to avoid mis-match between c/s\n\t\t\t\t}\n\n\t\t\t\t//Cycle 2: Process any pending events posted by components\n\t\t\t\tEvent event = nextEvent(uv);\n\t\t\t\tdo {\n\t\t\t\t\tfor (; event != null; event = nextEvent(uv)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\t\tif (!handleError(ex, uv, errs))\n\t\t\t\t\t\t\t\tbreak; //skip the rest of events! \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tresumeAll(desktop, uv, errs);\n\t\t\t\t} while ((event = nextEvent(uv)) != null);\n\t\t\t}\n\n\t\t\t//Cycle 2a: Handle aborting reason\n\t\t\tabrn = uv.getAbortingReason();\n\t\t\tif (abrn != null)\n\t\t\t\tabrn.execute(); //always execute even if !isAborting\n\n\t\t\t//Cycle 3: Generate output\n\t\t\tfinal List responses = getResponses(exec, uv, errs);\n\n\t\t\tdoneReqIds = rque.clearPerfRequestIds();\n\n\t\t\tfinal List prs = desktopCtrl.piggyResponse(null, true);\n\t\t\tif (prs != null) responses.addAll(0, prs);\n\n\t\t\tout.writeResponseId(desktopCtrl.getResponseId(true));\n\t\t\tout.write(responses);\n\n//\t\t\tif (log.debugable())\n//\t\t\t\tif (responses.size() < 5 || log.finerable()) log.finer(\"Responses: \"+responses);\n//\t\t\t\telse log.debug(\"Responses: \"+responses.subList(0, 5)+\"...\");\n\n\t\t\tcleaned = true;\n\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, null, errs);\n\t\t\tconfig.invokeExecutionCleanups(exec, null, errs);\n\n\t\t\tfinal String seqId = ((ExecutionCtrl)exec).getRequestId();\n\t\t\tif (seqId != null)\n\t\t\t\tdesktopCtrl.responseSent(seqId, out.complete());\n\t\t} catch (Throwable ex) {\n\t\t\tif (!cleaned) {\n\t\t\t\tcleaned = true;\n\t\t\t\tfinal List errs = new LinkedList();\n\t\t\t\terrs.add(ex);\n\t\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, null, errs);\n\t\t\t\tconfig.invokeExecutionCleanups(exec, null, errs);\n\t\t\t\tex = errs.isEmpty() ? null: (Throwable)errs.get(0);\n\t\t\t}\n\n\t\t\tif (ex != null) {\n\t\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!cleaned) {\n\t\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, null, null);\n\t\t\t\tconfig.invokeExecutionCleanups(exec, null, null);\n\t\t\t}\n\n\t\t\tif (abrn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tabrn.finish();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warning(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (monitor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.afterUpdate(desktop);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tlog.error(ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoDeactivate(exec);\n\n\t\t\tif (pfmeter != null && doneReqIds != null)\n\t\t\t\tmeterAuServerComplete(pfmeter, doneReqIds, exec);\n\t\t}\n\t}","id":80075,"modified_method":"public void execUpdate(Execution exec, List requests, AuWriter out)\n\tthrows IOException {\n\t\tif (requests == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tassert D.OFF || ExecutionsCtrl.getCurrentCtrl() == null:\n\t\t\t\"Impossible to re-activate for update: old=\"+ExecutionsCtrl.getCurrentCtrl()+\", new=\"+exec;\n\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)desktop;\n\t\tfinal Configuration config = desktop.getWebApp().getConfiguration();\n\n\t\tfinal PerformanceMeter pfmeter = config.getPerformanceMeter();\n\t\tlong startTime = 0;\n\t\tif (pfmeter != null) {\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t\t\t//snapshot time since activate might take time\n\t\t\tmeterAuClientComplete(pfmeter, exec);\n\t\t}\n\n\t\tfinal Object[] resultOfRepeat = new Object[1];\n\t\tfinal UiVisualizer uv = doActivate(exec, true, false, resultOfRepeat);\n\t\tif (resultOfRepeat[0] != null) {\n\t\t\tout.resend(resultOfRepeat[0]);\n\t\t\tdoDeactivate(exec);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Monitor monitor = config.getMonitor();\n\t\tif (monitor != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beforeUpdate(desktop, requests);\n\t\t\t} catch (Throwable ex) {\n\t\t\t\tlog.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tfinal String pfReqId =\n\t\t\tpfmeter != null ? meterAuStart(pfmeter, exec, startTime): null;\n\t\tCollection doneReqIds = null; //request IDs that have been processed\n\t\tAbortingReason abrn = null;\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tfinal RequestQueue rque = desktopCtrl.getRequestQueue();\n\t\t\trque.addRequests(requests);\n\n\t\t\tconfig.invokeExecutionInits(exec, null);\n\t\t\tdesktopCtrl.invokeExecutionInits(exec, null);\n\n\t\t\tif (pfReqId != null) rque.addPerfRequestId(pfReqId);\n\n\t\t\tfinal List errs = new LinkedList();\n\t\t\t//Process all; ignore getMaxProcessTime();\n\t\t\t//we cannot handle them partially since UUID might be recycled\n\t\t\tfor (AuRequest request; (request = rque.nextRequest()) != null;) {\n\t\t\t\t//Cycle 1: Process one request\n\t\t\t\t//Don't process more such that requests will be queued\n\t\t\t\t//and we have the chance to optimize them\n\t\t\t\ttry {\n\t\t\t\t\tprocess(exec, request, !errs.isEmpty());\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t//we don't skip request to avoid mis-match between c/s\n\t\t\t\t}\n\n\t\t\t\t//Cycle 2: Process any pending events posted by components\n\t\t\t\tEvent event = nextEvent(uv);\n\t\t\t\tdo {\n\t\t\t\t\tfor (; event != null; event = nextEvent(uv)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tresumeAll(desktop, uv, errs);\n\t\t\t\t} while ((event = nextEvent(uv)) != null);\n\t\t\t}\n\n\t\t\t//Cycle 2a: Handle aborting reason\n\t\t\tabrn = uv.getAbortingReason();\n\t\t\tif (abrn != null)\n\t\t\t\tabrn.execute(); //always execute even if !isAborting\n\n\t\t\t//Cycle 3: Generate output\n\t\t\tfinal List responses = getResponses(exec, uv, errs);\n\n\t\t\tdoneReqIds = rque.clearPerfRequestIds();\n\n\t\t\tfinal List prs = desktopCtrl.piggyResponse(null, true);\n\t\t\tif (prs != null) responses.addAll(0, prs);\n\n\t\t\tout.writeResponseId(desktopCtrl.getResponseId(true));\n\t\t\tout.write(responses);\n\n//\t\t\tif (log.debugable())\n//\t\t\t\tif (responses.size() < 5 || log.finerable()) log.finer(\"Responses: \"+responses);\n//\t\t\t\telse log.debug(\"Responses: \"+responses.subList(0, 5)+\"...\");\n\n\t\t\tcleaned = true;\n\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, null, errs);\n\t\t\tconfig.invokeExecutionCleanups(exec, null, errs);\n\n\t\t\tfinal String seqId = ((ExecutionCtrl)exec).getRequestId();\n\t\t\tif (seqId != null)\n\t\t\t\tdesktopCtrl.responseSent(seqId, out.complete());\n\t\t} catch (Throwable ex) {\n\t\t\tif (!cleaned) {\n\t\t\t\tcleaned = true;\n\t\t\t\tfinal List errs = new LinkedList();\n\t\t\t\terrs.add(ex);\n\t\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, null, errs);\n\t\t\t\tconfig.invokeExecutionCleanups(exec, null, errs);\n\t\t\t\tex = errs.isEmpty() ? null: (Throwable)errs.get(0);\n\t\t\t}\n\n\t\t\tif (ex != null) {\n\t\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!cleaned) {\n\t\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, null, null);\n\t\t\t\tconfig.invokeExecutionCleanups(exec, null, null);\n\t\t\t}\n\n\t\t\tif (abrn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tabrn.finish();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warning(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (monitor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.afterUpdate(desktop);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tlog.error(ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoDeactivate(exec);\n\n\t\t\tif (pfmeter != null && doneReqIds != null)\n\t\t\t\tmeterAuServerComplete(pfmeter, doneReqIds, exec);\n\t\t}\n\t}","commit_id":"3781224578519637824ab26b9123bac478eaaf81","url":"https://github.com/zkoss/zk"},{"original_method":"/** It assumes exactly one of pagedef and richlet is not null. */\n\tprivate void execNewPage0(final Execution exec, final PageDefinition pagedef,\n\tfinal Richlet richlet, final Page page, final Writer out) throws IOException {\n\t\t//Update the device type first. If this is the second page and not\n\t\t//belonging to the same device type, an exception is thrown\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)desktop;\n\t\tfinal LanguageDefinition langdef = //default page\n\t\t\tpagedef != null ? pagedef.getLanguageDefinition():\n\t\t\trichlet != null ? richlet.getLanguageDefinition(): null;\n\t\tif (langdef != null)\n\t\t\tdesktop.setDeviceType(langdef.getDeviceType()); //set and check!\n\n\t\tfinal WebApp wapp = desktop.getWebApp();\n\t\tfinal Configuration config = wapp.getConfiguration();\n\t\tPerformanceMeter pfmeter = config.getPerformanceMeter();\n\t\tfinal long startTime = pfmeter != null ? System.currentTimeMillis(): 0;\n\t\t\t\t//snapshot time since activate might take time\n\n\t\t//It is possible this method is invoked when processing other exec\n\t\tfinal Execution oldexec = Executions.getCurrent();\n\t\tfinal ExecutionCtrl oldexecCtrl = (ExecutionCtrl)oldexec;\n\t\tfinal UiVisualizer olduv =\n\t\t\toldexecCtrl != null ? (UiVisualizer)oldexecCtrl.getVisualizer(): null;\n\n\t\tfinal UiVisualizer uv;\n\t\tif (olduv != null) {\n\t\t\tuv = doReactivate(exec, olduv);\n\t\t\tpfmeter = null; //don't count included pages\n\t\t} else {\n\t\t\tuv = doActivate(exec, false, false, null);\n\t\t}\n\n\t\tfinal ExecutionCtrl execCtrl = (ExecutionCtrl)exec;\n\t\tfinal Page old = execCtrl.getCurrentPage();\n\t\tfinal PageDefinition olddef = execCtrl.getCurrentPageDefinition();\n\t\texecCtrl.setCurrentPage(page);\n\t\texecCtrl.setCurrentPageDefinition(pagedef);\n\n\t\tfinal String pfReqId =\n\t\t\tpfmeter != null ? meterLoadStart(pfmeter, exec, startTime): null;\n\t\tAbortingReason abrn = null;\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tconfig.invokeExecutionInits(exec, oldexec);\n\t\t\tdesktopCtrl.invokeExecutionInits(exec, oldexec);\n\n\t\t\tif (olduv != null) {\n\t\t\t\tfinal Component owner = olduv.getOwner();\n\t\t\t\tif (owner != null) {\n\t\t\t\t\t((PageCtrl)page).setOwner(owner);\n//\t\t\t\t\tif (D.ON && log.finerable()) log.finer(\"Set owner of \"+page+\" to \"+owner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Cycle 1: Creates all components\n\n\t\t\t//Note:\n\t\t\t//1) stylesheet, tablib are inited in Page's contructor\n\t\t\t//2) we add variable resolvers before init because\n\t\t\t//init's zscirpt might depend on it.\n\t\t\tif (pagedef != null) {\n\t\t\t\t((PageCtrl)page).preInit();\n\t\t\t\tpagedef.initXelContext(page);\n\n\t\t\t\tfinal Initiators inits = Initiators.doInit(pagedef, page);\n\t\t\t\t\t//Request 1472813: sendRedirect in init; test: sendRedirectNow.zul\n\t\t\t\ttry {\n\t\t\t\t\tpagedef.init(page, !uv.isEverAsyncUpdate() && !uv.isAborting());\n\n\t\t\t\t\tfinal Component[] comps;\n\t\t\t\t\tfinal String uri = pagedef.getForwardURI(page);\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\tcomps = new Component[0];\n\t\t\t\t\t\texec.forward(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomps = uv.isAborting() || exec.isVoided() ?\n\t\t\t\t\t\t\tnew Component[0]:\n\t\t\t\t\t\t\texecCreate(new CreateInfo(\n\t\t\t\t\t\t\t\t((WebAppCtrl)wapp).getUiFactory(), exec, page,\n\t\t\t\t\t\t\t\tconfig.getComposer(page)),\n\t\t\t\t\t\t\tpagedef, null);\n\t\t\t\t\t}\n\n\t\t\t\t\tinits.doAfterCompose(page, comps);\n\t\t\t\t\tafterCreate(comps);\n\t\t\t\t} catch(Throwable ex) {\n\t\t\t\t\tif (!inits.doCatch(ex))\n\t\t\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t\t} finally {\n\t\t\t\t\tinits.doFinally();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//FUTURE: a way to allow richlet to set page ID\n\t\t\t\t((PageCtrl)page).preInit();\n\t\t\t\t((PageCtrl)page).init(new PageConfig() {\n\t\t\t\t\tpublic String getId() {return null;}\n\t\t\t\t\tpublic String getUuid() {return null;}\n\t\t\t\t\tpublic String getTitle() {return null;}\n\t\t\t\t\tpublic String getStyle() {return null;}\n\t\t\t\t\tpublic String getBeforeHeadTags() {return \"\";}\n\t\t\t\t\tpublic String getAfterHeadTags() {return \"\";}\n\t\t\t\t\t/** @deprecated */\n\t\t\t\t\tpublic String getHeaders(boolean before) {return \"\";}\n\t\t\t\t\t/** @deprecated */\n\t\t\t\t\tpublic String getHeaders() {return \"\";}\n\t\t\t\t\tpublic Collection getResponseHeaders() {return Collections.EMPTY_LIST;}\n\t\t\t\t});\n\t\t\t\tfinal Composer composer = config.getComposer(page);\n\t\t\t\ttry {\n\t\t\t\t\trichlet.service(page);\n\n\t\t\t\t\tfor (Component root = page.getFirstRoot(); root != null;\n\t\t\t\t\troot = root.getNextSibling()) {\n\t\t\t\t\t\tif (composer != null)\n\t\t\t\t\t\t\tcomposer.doAfterCompose(root);\n\t\t\t\t\t\tafterCreate(new Component[] {root});\n\t\t\t\t\t\t\t//root's next sibling might be changed\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tif (composer instanceof ComposerExt)\n\t\t\t\t\t\tif (((ComposerExt)composer).doCatch(t))\n\t\t\t\t\t\t\tt = null; //ignored\n\t\t\t\t\tif (t != null)\n\t\t\t\t\t\tthrow t;\n\t\t\t\t} finally {\n\t\t\t\t\tif (composer instanceof ComposerExt)\n\t\t\t\t\t\t((ComposerExt)composer).doFinally();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exec.isVoided())\n\t\t\t\treturn; //don't generate any output\n\n\t\t\t//Cycle 2: process pending events\n\t\t\t//Unlike execUpdate, execution is aborted here if any exception\n\t\t\tfinal List errs = new LinkedList();\n\t\t\tEvent event = nextEvent(uv);\n\t\t\tdo {\n\t\t\t\tfor (; event != null; event = nextEvent(uv)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\tif (!handleError(ex, uv, errs))\n\t\t\t\t\t\t\tbreak; //skip the rest of events! \n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresumeAll(desktop, uv, null);\n\t\t\t} while ((event = nextEvent(uv)) != null);\n\n\t\t\t//Cycle 2a: Handle aborting reason\n\t\t\tabrn = uv.getAbortingReason();\n\t\t\tif (abrn != null)\n\t\t\t\tabrn.execute(); //always execute even if !isAborting\n\n\t\t\t//Cycle 3: Redraw the page (and responses)\n\t\t\tList responses = getResponses(exec, uv, errs);\n\n\t\t\tif (olduv != null && olduv.addToFirstAsyncUpdate(responses))\n\t\t\t\tresponses = null;\n\t\t\t\t//A new ZK page might be included by an async update\n\t\t\t\t//(example: ZUL's include).\n\t\t\t\t//If so, we cannot generate the responses in the page.\n\t\t\t\t//Rather, we shall add them to the async update.\n\t\t\telse\n\t\t\t\texecCtrl.setResponses(responses);\n\n\t\t\tredrawNewPage(page, out);\n\t\t} catch (Throwable ex) {\n\t\t\tcleaned = true;\n\t\t\tfinal List errs = new LinkedList();\n\t\t\terrs.add(ex);\n\n\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, oldexec, errs);\n\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, errs);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\n\t\t\tif (!errs.isEmpty()) {\n\t\t\t\tex = (Throwable)errs.get(0);\n\t\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!cleaned) {\n\t\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, oldexec, null);\n\t\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, null);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\t\t\t}\n\t\t\tif (abrn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tabrn.finish();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warning(t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texecCtrl.setCurrentPage(old); //restore it\n\t\t\texecCtrl.setCurrentPageDefinition(olddef); //restore it\n\n\t\t\tif (olduv != null) doDereactivate(exec, olduv);\n\t\t\telse doDeactivate(exec);\n\n\t\t\tif (pfmeter != null)\n\t\t\t\tmeterLoadServerComplete(pfmeter, pfReqId, exec);\n\t\t}\n\t}","id":80076,"modified_method":"/** It assumes exactly one of pagedef and richlet is not null. */\n\tprivate void execNewPage0(final Execution exec, final PageDefinition pagedef,\n\tfinal Richlet richlet, final Page page, final Writer out) throws IOException {\n\t\t//Update the device type first. If this is the second page and not\n\t\t//belonging to the same device type, an exception is thrown\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)desktop;\n\t\tfinal LanguageDefinition langdef = //default page\n\t\t\tpagedef != null ? pagedef.getLanguageDefinition():\n\t\t\trichlet != null ? richlet.getLanguageDefinition(): null;\n\t\tif (langdef != null)\n\t\t\tdesktop.setDeviceType(langdef.getDeviceType()); //set and check!\n\n\t\tfinal WebApp wapp = desktop.getWebApp();\n\t\tfinal Configuration config = wapp.getConfiguration();\n\t\tPerformanceMeter pfmeter = config.getPerformanceMeter();\n\t\tfinal long startTime = pfmeter != null ? System.currentTimeMillis(): 0;\n\t\t\t\t//snapshot time since activate might take time\n\n\t\t//It is possible this method is invoked when processing other exec\n\t\tfinal Execution oldexec = Executions.getCurrent();\n\t\tfinal ExecutionCtrl oldexecCtrl = (ExecutionCtrl)oldexec;\n\t\tfinal UiVisualizer olduv =\n\t\t\toldexecCtrl != null ? (UiVisualizer)oldexecCtrl.getVisualizer(): null;\n\n\t\tfinal UiVisualizer uv;\n\t\tif (olduv != null) {\n\t\t\tuv = doReactivate(exec, olduv);\n\t\t\tpfmeter = null; //don't count included pages\n\t\t} else {\n\t\t\tuv = doActivate(exec, false, false, null);\n\t\t}\n\n\t\tfinal ExecutionCtrl execCtrl = (ExecutionCtrl)exec;\n\t\tfinal Page old = execCtrl.getCurrentPage();\n\t\tfinal PageDefinition olddef = execCtrl.getCurrentPageDefinition();\n\t\texecCtrl.setCurrentPage(page);\n\t\texecCtrl.setCurrentPageDefinition(pagedef);\n\n\t\tfinal String pfReqId =\n\t\t\tpfmeter != null ? meterLoadStart(pfmeter, exec, startTime): null;\n\t\tAbortingReason abrn = null;\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tconfig.invokeExecutionInits(exec, oldexec);\n\t\t\tdesktopCtrl.invokeExecutionInits(exec, oldexec);\n\n\t\t\tif (olduv != null) {\n\t\t\t\tfinal Component owner = olduv.getOwner();\n\t\t\t\tif (owner != null) {\n\t\t\t\t\t((PageCtrl)page).setOwner(owner);\n//\t\t\t\t\tif (D.ON && log.finerable()) log.finer(\"Set owner of \"+page+\" to \"+owner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Cycle 1: Creates all components\n\n\t\t\t//Note:\n\t\t\t//1) stylesheet, tablib are inited in Page's contructor\n\t\t\t//2) we add variable resolvers before init because\n\t\t\t//init's zscirpt might depend on it.\n\t\t\tif (pagedef != null) {\n\t\t\t\t((PageCtrl)page).preInit();\n\t\t\t\tpagedef.initXelContext(page);\n\n\t\t\t\tfinal Initiators inits = Initiators.doInit(pagedef, page);\n\t\t\t\t\t//Request 1472813: sendRedirect in init; test: sendRedirectNow.zul\n\t\t\t\ttry {\n\t\t\t\t\tpagedef.init(page, !uv.isEverAsyncUpdate() && !uv.isAborting());\n\n\t\t\t\t\tfinal Component[] comps;\n\t\t\t\t\tfinal String uri = pagedef.getForwardURI(page);\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\tcomps = new Component[0];\n\t\t\t\t\t\texec.forward(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomps = uv.isAborting() || exec.isVoided() ?\n\t\t\t\t\t\t\tnew Component[0]:\n\t\t\t\t\t\t\texecCreate(new CreateInfo(\n\t\t\t\t\t\t\t\t((WebAppCtrl)wapp).getUiFactory(), exec, page,\n\t\t\t\t\t\t\t\tconfig.getComposer(page)),\n\t\t\t\t\t\t\tpagedef, null);\n\t\t\t\t\t}\n\n\t\t\t\t\tinits.doAfterCompose(page, comps);\n\t\t\t\t\tafterCreate(comps);\n\t\t\t\t} catch(Throwable ex) {\n\t\t\t\t\tif (!inits.doCatch(ex))\n\t\t\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t\t} finally {\n\t\t\t\t\tinits.doFinally();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//FUTURE: a way to allow richlet to set page ID\n\t\t\t\t((PageCtrl)page).preInit();\n\t\t\t\t((PageCtrl)page).init(new PageConfig() {\n\t\t\t\t\tpublic String getId() {return null;}\n\t\t\t\t\tpublic String getUuid() {return null;}\n\t\t\t\t\tpublic String getTitle() {return null;}\n\t\t\t\t\tpublic String getStyle() {return null;}\n\t\t\t\t\tpublic String getBeforeHeadTags() {return \"\";}\n\t\t\t\t\tpublic String getAfterHeadTags() {return \"\";}\n\t\t\t\t\t/** @deprecated */\n\t\t\t\t\tpublic String getHeaders(boolean before) {return \"\";}\n\t\t\t\t\t/** @deprecated */\n\t\t\t\t\tpublic String getHeaders() {return \"\";}\n\t\t\t\t\tpublic Collection getResponseHeaders() {return Collections.EMPTY_LIST;}\n\t\t\t\t});\n\t\t\t\tfinal Composer composer = config.getComposer(page);\n\t\t\t\ttry {\n\t\t\t\t\trichlet.service(page);\n\n\t\t\t\t\tfor (Component root = page.getFirstRoot(); root != null;\n\t\t\t\t\troot = root.getNextSibling()) {\n\t\t\t\t\t\tif (composer != null)\n\t\t\t\t\t\t\tcomposer.doAfterCompose(root);\n\t\t\t\t\t\tafterCreate(new Component[] {root});\n\t\t\t\t\t\t\t//root's next sibling might be changed\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tif (composer instanceof ComposerExt)\n\t\t\t\t\t\tif (((ComposerExt)composer).doCatch(t))\n\t\t\t\t\t\t\tt = null; //ignored\n\t\t\t\t\tif (t != null)\n\t\t\t\t\t\tthrow t;\n\t\t\t\t} finally {\n\t\t\t\t\tif (composer instanceof ComposerExt)\n\t\t\t\t\t\t((ComposerExt)composer).doFinally();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exec.isVoided())\n\t\t\t\treturn; //don't generate any output\n\n\t\t\t//Cycle 2: process pending events\n\t\t\t//Unlike execUpdate, execution is aborted here if any exception\n\t\t\tfinal List errs = new LinkedList();\n\t\t\tEvent event = nextEvent(uv);\n\t\t\tdo {\n\t\t\t\tfor (; event != null; event = nextEvent(uv)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresumeAll(desktop, uv, null);\n\t\t\t} while ((event = nextEvent(uv)) != null);\n\n\t\t\t//Cycle 2a: Handle aborting reason\n\t\t\tabrn = uv.getAbortingReason();\n\t\t\tif (abrn != null)\n\t\t\t\tabrn.execute(); //always execute even if !isAborting\n\n\t\t\t//Cycle 3: Redraw the page (and responses)\n\t\t\tList responses = getResponses(exec, uv, errs);\n\n\t\t\tif (olduv != null && olduv.addToFirstAsyncUpdate(responses))\n\t\t\t\tresponses = null;\n\t\t\t\t//A new ZK page might be included by an async update\n\t\t\t\t//(example: ZUL's include).\n\t\t\t\t//If so, we cannot generate the responses in the page.\n\t\t\t\t//Rather, we shall add them to the async update.\n\t\t\telse\n\t\t\t\texecCtrl.setResponses(responses);\n\n\t\t\tredrawNewPage(page, out);\n\t\t} catch (Throwable ex) {\n\t\t\tcleaned = true;\n\t\t\tfinal List errs = new LinkedList();\n\t\t\terrs.add(ex);\n\n\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, oldexec, errs);\n\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, errs);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\n\t\t\tif (!errs.isEmpty()) {\n\t\t\t\tex = (Throwable)errs.get(0);\n\t\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!cleaned) {\n\t\t\t\tdesktopCtrl.invokeExecutionCleanups(exec, oldexec, null);\n\t\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, null);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\t\t\t}\n\t\t\tif (abrn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tabrn.finish();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.warning(t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texecCtrl.setCurrentPage(old); //restore it\n\t\t\texecCtrl.setCurrentPageDefinition(olddef); //restore it\n\n\t\t\tif (olduv != null) doDereactivate(exec, olduv);\n\t\t\telse doDeactivate(exec);\n\n\t\t\tif (pfmeter != null)\n\t\t\t\tmeterLoadServerComplete(pfmeter, pfReqId, exec);\n\t\t}\n\t}","commit_id":"3781224578519637824ab26b9123bac478eaaf81","url":"https://github.com/zkoss/zk"},{"original_method":"/** Handles each error. The erros will be queued to the errs list\n\t * and processed later by {@link #visualizeErrors}.\n\t * @return whether it is handled (i.e., become an AuResponse)\n\t * (and won't be added to errs).\n\t */\n\tprivate static final\n\tboolean handleError(Throwable ex, UiVisualizer uv, List errs) {\n\t\tfinal Throwable t = Exceptions.findCause(ex, Expectable.class);\n\t\tif (t == null) {\n\t\t\tif (ex instanceof org.xml.sax.SAXException\n\t\t\t|| ex instanceof org.zkoss.zk.ui.metainfo.PropertyNotFoundException)\n\t\t\t\tlog.error(Exceptions.getMessage(ex));\n\t\t\telse\n\t\t\t\tlog.realCauseBriefly(ex);\n\t\t} else {\n\t\t\tex = t;\n\t\t\tif (log.debugable()) log.debug(Exceptions.getRealCause(ex));\n\t\t}\n\n\t\tif (ex instanceof WrongValueException) {\n\t\t\tWrongValueException wve = (WrongValueException)ex;\n\t\t\tfinal Component comp = wve.getComponent();\n\t\t\tif (comp != null) {\n\t\t\t\twve = ((ComponentCtrl)comp).onWrongValue(wve);\n\t\t\t\tif (wve != null) {\n\t\t\t\t\tComponent c = wve.getComponent();\n\t\t\t\t\tif (c == null) c = comp;\n\t\t\t\t\tuv.addResponse(\n\t\t\t\t\t\tnew AuWrongValue(c, Exceptions.getMessage(wve)));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (ex instanceof WrongValuesException) {\n\t\t\tfinal WrongValueException[] wves =\n\t\t\t\t((WrongValuesException)ex).getWrongValueExceptions();\n\t\t\tfinal LinkedList infs = new LinkedList();\n\t\t\tfor (int i = 0; i < wves.length; i++) {\n\t\t\t\tfinal Component comp = wves[i].getComponent();\n\t\t\t\tif (comp != null) {\n\t\t\t\t\tWrongValueException wve = ((ComponentCtrl)comp).onWrongValue(wves[i]);\n\t\t\t\t\tif (wve != null) {\n\t\t\t\t\t\tComponent c = wve.getComponent();\n\t\t\t\t\t\tif (c == null) c = comp;\n\t\t\t\t\t\tinfs.add(c.getUuid());\n\t\t\t\t\t\tinfs.add(Exceptions.getMessage(wve));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tuv.addResponse(\n\t\t\t\tnew AuWrongValue((String[])infs.toArray(new String[infs.size()])));\n\t\t\treturn true;\n\t\t}\n\n\t\terrs.add(ex);\n\t\treturn false;\n\t}","id":80077,"modified_method":"/** Handles each error. The erros will be queued to the errs list\n\t * and processed later by {@link #visualizeErrors}.\n\t * @return whether it is handled (i.e., become an AuResponse)\n\t * (and won't be added to errs).\n\t */\n\tprivate static final\n\tvoid handleError(Throwable ex, UiVisualizer uv, List errs) {\n\t\tfinal Throwable t = Exceptions.findCause(ex, Expectable.class);\n\t\tif (t == null) {\n\t\t\tif (ex instanceof org.xml.sax.SAXException\n\t\t\t|| ex instanceof org.zkoss.zk.ui.metainfo.PropertyNotFoundException)\n\t\t\t\tlog.error(Exceptions.getMessage(ex));\n\t\t\telse\n\t\t\t\tlog.realCauseBriefly(ex);\n\t\t} else {\n\t\t\tex = t;\n\t\t\tif (log.debugable()) log.debug(Exceptions.getRealCause(ex));\n\t\t}\n\n\t\tif (ex instanceof WrongValueException) {\n\t\t\tWrongValueException wve = (WrongValueException)ex;\n\t\t\tfinal Component comp = wve.getComponent();\n\t\t\tif (comp != null) {\n\t\t\t\twve = ((ComponentCtrl)comp).onWrongValue(wve);\n\t\t\t\tif (wve != null) {\n\t\t\t\t\tComponent c = wve.getComponent();\n\t\t\t\t\tif (c == null) c = comp;\n\t\t\t\t\tuv.addResponse(\n\t\t\t\t\t\tnew AuWrongValue(c, Exceptions.getMessage(wve)));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (ex instanceof WrongValuesException) {\n\t\t\tfinal WrongValueException[] wves =\n\t\t\t\t((WrongValuesException)ex).getWrongValueExceptions();\n\t\t\tfinal LinkedList infs = new LinkedList();\n\t\t\tfor (int i = 0; i < wves.length; i++) {\n\t\t\t\tfinal Component comp = wves[i].getComponent();\n\t\t\t\tif (comp != null) {\n\t\t\t\t\tWrongValueException wve = ((ComponentCtrl)comp).onWrongValue(wves[i]);\n\t\t\t\t\tif (wve != null) {\n\t\t\t\t\t\tComponent c = wve.getComponent();\n\t\t\t\t\t\tif (c == null) c = comp;\n\t\t\t\t\t\tinfs.add(c.getUuid());\n\t\t\t\t\t\tinfs.add(Exceptions.getMessage(wve));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tuv.addResponse(\n\t\t\t\tnew AuWrongValue((String[])infs.toArray(new String[infs.size()])));\n\t\t\treturn;\n\t\t}\n\n\t\terrs.add(ex);\n\t}","commit_id":"3781224578519637824ab26b9123bac478eaaf81","url":"https://github.com/zkoss/zk"},{"original_method":"public JSONArray finishUpdate(Object ctx) throws IOException {\n\t\tfinal UpdateInfo ui = (UpdateInfo)ctx;\n\t\tfinal Execution exec = ui.uv.getExecution();\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal List errs = new LinkedList();\n\n\t\t//1. process events\n\t\tEvent event = nextEvent(ui.uv);\n\t\tdo {\n\t\t\tfor (; event != null; event = nextEvent(ui.uv)) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tif (!handleError(ex, ui.uv, errs))\n\t\t\t\t\t\tbreak; //skip the rest of events! \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresumeAll(desktop, ui.uv, errs);\n\t\t} while ((event = nextEvent(ui.uv)) != null);\n\n\t\t//2. Handle aborting reason\n\t\tui.abrn = ui.uv.getAbortingReason();\n\t\tif (ui.abrn != null)\n\t\t\tui.abrn.execute(); //always execute even if !isAborting\n\n\t\t//3. Retrieve responses\n\t\tfinal List responses = getResponses(exec, ui.uv, errs);\n\n\t\tfinal JSONArray rs = new JSONArray();\n\t\tfor (Iterator it = responses.iterator(); it.hasNext();)\n\t\t\trs.add(AuWriters.toJSON((AuResponse)it.next()));\n\t\treturn rs;\n\t}","id":80078,"modified_method":"public JSONArray finishUpdate(Object ctx) throws IOException {\n\t\tfinal UpdateInfo ui = (UpdateInfo)ctx;\n\t\tfinal Execution exec = ui.uv.getExecution();\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal List errs = new LinkedList();\n\n\t\t//1. process events\n\t\tEvent event = nextEvent(ui.uv);\n\t\tdo {\n\t\t\tfor (; event != null; event = nextEvent(ui.uv)) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\thandleError(ex, ui.uv, errs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresumeAll(desktop, ui.uv, errs);\n\t\t} while ((event = nextEvent(ui.uv)) != null);\n\n\t\t//2. Handle aborting reason\n\t\tui.abrn = ui.uv.getAbortingReason();\n\t\tif (ui.abrn != null)\n\t\t\tui.abrn.execute(); //always execute even if !isAborting\n\n\t\t//3. Retrieve responses\n\t\tfinal List responses = getResponses(exec, ui.uv, errs);\n\n\t\tfinal JSONArray rs = new JSONArray();\n\t\tfor (Iterator it = responses.iterator(); it.hasNext();)\n\t\t\trs.add(AuWriters.toJSON((AuResponse)it.next()));\n\t\treturn rs;\n\t}","commit_id":"3781224578519637824ab26b9123bac478eaaf81","url":"https://github.com/zkoss/zk"},{"original_method":"public static RuleInputAccess getAccess() {\n        final Map<String, Object> inputs = INPUT.get();\n        return new RuleInputAccess() {\n\n            @Override\n            public boolean has(String modelPath) {\n                return inputs.containsKey(modelPath);\n            }\n\n            public Object input(String modelPath) {\n                return inputs.get(modelPath);\n            }\n\n            @Override\n            public PropertyWrapper property(final String modelPath) {\n                return new PropertyWrapper() {\n                    @Override\n                    public Object getProperty(String name) {\n                        return input(modelPath);\n                    }\n\n                    @Override\n                    public Object invokeMethod(String name, Object args) {\n                        return null;\n                    }\n\n                    @Override\n                    public void setProperty(String propertyName, Object newValue) {\n\n                    }\n\n                    @Override\n                    public MetaClass getMetaClass() {\n                        return null;\n                    }\n\n                    @Override\n                    public void setMetaClass(MetaClass metaClass) {\n\n                    }\n                };\n            }\n        };\n    }","id":80079,"modified_method":"public static RuleInputAccess getAccess() {\n        final Map<String, Object> inputs = INPUT.get();\n        return new RuleInputAccess() {\n\n            @Override\n            public boolean has(String modelPath) {\n                return inputs.containsKey(modelPath);\n            }\n\n            public Object input(String modelPath) {\n                return inputs.get(modelPath);\n            }\n        };\n    }","commit_id":"ce0ade715c63ceb339f24dd367442d80fbd453b5","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n    }","id":80080,"modified_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        if (expression.getLeftExpression() instanceof VariableExpression) {\n            expression.setRightExpression(replaceExpr(expression.getRightExpression()));\n        } else {\n            super.visitBinaryExpression(expression);\n        }\n    }","commit_id":"ce0ade715c63ceb339f24dd367442d80fbd453b5","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean extractPropertyPath(Expression expression, List<String> names) {\n        if (expression instanceof PropertyExpression) {\n            PropertyExpression propertyExpression = (PropertyExpression) expression;\n            return extractPropertyPath(propertyExpression.getObjectExpression(), names)\n                && extractPropertyPath(propertyExpression.getProperty(), names);\n        } else if (expression instanceof VariableExpression) {\n            names.add(((VariableExpression) expression).getName());\n        } else if (expression instanceof ConstantExpression) {\n            ConstantExpression constantExpression = (ConstantExpression) expression;\n            if (constantExpression.getType().equals(ClassHelper.STRING_TYPE)) {\n                names.add(constantExpression.getText());\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n\n        return true;\n    }","id":80081,"modified_method":"private boolean extractPropertyPath(Expression expression, List<String> names) {\n        if (expression instanceof PropertyExpression) {\n            PropertyExpression propertyExpression = (PropertyExpression) expression;\n            if (extractPropertyPath(propertyExpression.getObjectExpression(), names)) {\n                return extractPropertyPath(propertyExpression.getProperty(), names);\n            } else {\n                super.visitPropertyExpression(propertyExpression);\n            }\n        } else if (expression instanceof VariableExpression) {\n            names.add(((VariableExpression) expression).getName());\n        } else if (expression instanceof ConstantExpression) {\n            ConstantExpression constantExpression = (ConstantExpression) expression;\n            if (constantExpression.getType().equals(ClassHelper.STRING_TYPE)) {\n                names.add(constantExpression.getText());\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n\n        return true;\n    }","commit_id":"ce0ade715c63ceb339f24dd367442d80fbd453b5","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitPropertyExpression(PropertyExpression expression) {\n        ArrayList<String> names = Lists.newArrayList();\n        boolean propertyIsLiteral = extractPropertyPath(expression, names);\n        if (names.isEmpty() || !names.get(0).equals(\"thing\")) {\n            super.visitPropertyExpression(expression);\n        } else {\n            String modelPath = ModelPath.pathString(names);\n            ConstantExpression modelPathConstantExpression = new ConstantExpression(modelPath);\n            inputs.relativePath(modelPath, expression.getLineNumber());\n            VariableExpression inputsVariable = new VariableExpression(accessVariable);\n            Expression originalObjectExpression = expression.getObjectExpression();\n            ArgumentListExpression modelPathArgumentExpression = new ArgumentListExpression(modelPathConstantExpression);\n            expression.setObjectExpression(new TernaryExpression(\n                new BooleanExpression(new MethodCallExpression(inputsVariable, HAS, modelPathArgumentExpression)),\n                new MethodCallExpression(inputsVariable, propertyIsLiteral ? PROPERTY : INPUT, modelPathArgumentExpression),\n                originalObjectExpression\n            ));\n        }\n    }","id":80082,"modified_method":"@Override\n    public void visitPropertyExpression(PropertyExpression expression) {\n        ArrayList<String> names = Lists.newArrayList();\n        boolean propertyNameIsPart = extractPropertyPath(expression, names);\n        if (!names.isEmpty()) {\n            if (names.get(0).equals(\"thing\")) {\n                String modelPath = ModelPath.pathString(names);\n                inputs.relativePath(modelPath, expression.getLineNumber());\n                if (propertyNameIsPart) {\n                    replaceVisitedExpressionWith(conditionalInputGet(modelPath, expression));\n                } else {\n                    expression.setObjectExpression(conditionalInputGet(modelPath, expression.getObjectExpression()));\n                }\n            } else {\n                expression.setObjectExpression(new TernaryExpression(\n                    new BooleanExpression(ConstantExpression.TRUE),\n                    expression.getObjectExpression(),\n                    ConstantExpression.FALSE\n                ));\n            }\n        }\n    }","commit_id":"ce0ade715c63ceb339f24dd367442d80fbd453b5","url":"https://github.com/gradle/gradle"},{"original_method":"private static void _localizeUsers(long companyId) throws Exception {\n\t\tUser user = UserLocalServiceUtil.getDefaultUser(companyId);\n\n\t\tExpandoBridge expandoBridge = user.getExpandoBridge();\n\n\t\tString attributeName =\n\t\t\t\"localizationUpdated_\" + PortletPropsValues.COMPANY_DEFAULT_LOCALE;\n\n\t\tboolean localizationUpdated = GetterUtil.getBoolean(\n\t\t\texpandoBridge.getAttribute(attributeName, false));\n\n\t\tif (localizationUpdated) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\texpandoBridge.addAttribute(\n\t\t\t\tattributeName, ExpandoColumnConstants.BOOLEAN, Boolean.FALSE,\n\t\t\t\tfalse);\n\t\t}\n\t\tcatch (DuplicateColumnNameException dcne) {\n\t\t}\n\n\t\texpandoBridge.setAttribute(attributeName, Boolean.TRUE, false);\n\n\t\tuser.setLanguageId(PortletPropsValues.COMPANY_DEFAULT_LOCALE);\n\t\tuser.setTimeZoneId(PortletPropsValues.COMPANY_DEFAULT_TIME_ZONE);\n\n\t\tUserLocalServiceUtil.updateUser(user);\n\t}","id":80083,"modified_method":"private static void _localizeUsers(long companyId) throws Exception {\n\t\tCompany company = CompanyLocalServiceUtil.getCompany(companyId);\n\n\t\tExpandoBridge expandoBridge = company.getExpandoBridge();\n\n\t\tString attributeName =\n\t\t\t\"localizationUpdated_\" + PortletPropsValues.COMPANY_DEFAULT_LOCALE;\n\n\t\tboolean localizationUpdated = GetterUtil.getBoolean(\n\t\t\texpandoBridge.getAttribute(attributeName, false));\n\n\t\tif (localizationUpdated) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\texpandoBridge.addAttribute(\n\t\t\t\tattributeName, ExpandoColumnConstants.BOOLEAN, Boolean.FALSE,\n\t\t\t\tfalse);\n\t\t}\n\t\tcatch (DuplicateColumnNameException dcne) {\n\t\t}\n\n\t\texpandoBridge.setAttribute(attributeName, Boolean.TRUE, false);\n\n\t\tCompanyLocalServiceUtil.updateCompany(company);\n\n\t\tint count = UserLocalServiceUtil.getCompanyUsersCount(companyId);\n\n\t\tint pages = count / Indexer.DEFAULT_INTERVAL;\n\n\t\tfor (int i = 0; i <= pages; i++) {\n\t\t\tint start = (i * Indexer.DEFAULT_INTERVAL);\n\t\t\tint end = start + Indexer.DEFAULT_INTERVAL;\n\n\t\t\tList<User> users = UserLocalServiceUtil.getCompanyUsers(\n\t\t\t\tcompanyId, start, end);\n\n\t\t\tfor (User user : users) {\n\t\t\t\tuser.setLanguageId(PortletPropsValues.COMPANY_DEFAULT_LOCALE);\n\t\t\t\tuser.setTimeZoneId(\n\t\t\t\t\tPortletPropsValues.COMPANY_DEFAULT_TIME_ZONE);\n\n\t\t\t\tUserLocalServiceUtil.updateUser(user);\n\t\t\t}\n\t\t}\n\t}","commit_id":"dd7476a64f5011049884cdf002c726867193585a","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private Configuration getDetachedConfiguration(String notation) {\n        Dependency dependency = getProject().getDependencies().create(notation);\n        Configuration configuration = getProject().getConfigurations().detachedConfiguration(dependency);\n        return configuration;\n    }","id":80084,"modified_method":"private Configuration getDetachedConfiguration(String notation) {\n        Dependency dependency = getProject().getDependencies().create(notation);\n        return getProject().getConfigurations().detachedConfiguration(dependency);\n    }","commit_id":"27ddb0cfe26aedac9a1d03c686a0c0ed520a0d47","url":"https://github.com/gradle/gradle"},{"original_method":"@Mutate\n        void createCoffeeScriptSources(ComponentSpecContainer components, final ServiceRegistry serviceRegistry) {\n            for (PlayApplicationSpec playComponent : components.withType(PlayApplicationSpec.class)) {\n                CoffeeScriptSourceSet coffeeScriptSourceSet =\n                        new DefaultCoffeeScriptSourceSet(\"coffeeScriptSources\", playComponent.getName(), serviceRegistry.get(FileResolver.class));\n                coffeeScriptSourceSet.getSource().srcDir(\"app/assets\");\n                coffeeScriptSourceSet.getSource().include(\"**/*.coffee\");\n\n                // Add a JavaScriptSourceSet to process the compiled coffee script sources\n                JavaScriptSourceSet javaScriptSourceSet = new DefaultJavaScriptSourceSet(COFFEE_SCRIPT_GENERATED, playComponent.getName(), serviceRegistry.get(FileResolver.class));\n                // This is so we force the SourceSetTransformTask to be created even though the source\n                // is still empty at this point\n                javaScriptSourceSet.builtBy(coffeeScriptSourceSet);\n                javaScriptSourceSet.getSource().include(\"**/*.js\");\n\n                ((ComponentSpecInternal) playComponent).getSources().add(coffeeScriptSourceSet);\n                ((ComponentSpecInternal) playComponent).getSources().add(javaScriptSourceSet);\n            }\n        }","id":80085,"modified_method":"@Mutate\n        void createCoffeeScriptSourceSets(ComponentSpecContainer components, final ServiceRegistry serviceRegistry) {\n            for (PlayApplicationSpec playComponent : components.withType(PlayApplicationSpec.class)) {\n                registerSourceSetFactory((ComponentSpecInternal) playComponent, serviceRegistry.get(Instantiator.class), serviceRegistry.get(FileResolver.class));\n\n                CoffeeScriptSourceSet coffeeScriptSourceSet = ((ComponentSpecInternal) playComponent).getSources().create(\"coffeeScriptSources\", CoffeeScriptSourceSet.class);\n                coffeeScriptSourceSet.getSource().srcDir(\"app/assets\");\n                coffeeScriptSourceSet.getSource().include(\"**/*.coffee\");\n            }\n        }","commit_id":"27ddb0cfe26aedac9a1d03c686a0c0ed520a0d47","url":"https://github.com/gradle/gradle"},{"original_method":"@Mutate\n        void createJavaScriptSources(ComponentSpecContainer components, final ServiceRegistry serviceRegistry) {\n            for (PlayApplicationSpec playComponent : components.withType(PlayApplicationSpec.class)) {\n                JavaScriptSourceSet javaScriptSourceSet = new DefaultJavaScriptSourceSet(\"javaScriptSources\", playComponent.getName(), serviceRegistry.get(FileResolver.class));\n                javaScriptSourceSet.getSource().srcDir(\"app/assets\");\n                javaScriptSourceSet.getSource().include(\"**/*.js\");\n                ((ComponentSpecInternal) playComponent).getSources().add(javaScriptSourceSet);\n            }\n        }","id":80086,"modified_method":"@Mutate\n        void createJavascriptSourceSets(ComponentSpecContainer components, final ServiceRegistry serviceRegistry) {\n            for (PlayApplicationSpec playComponent : components.withType(PlayApplicationSpec.class)) {\n                registerSourceSetFactory((ComponentSpecInternal) playComponent, serviceRegistry.get(Instantiator.class), serviceRegistry.get(FileResolver.class));\n                JavaScriptSourceSet javaScriptSourceSet = ((ComponentSpecInternal) playComponent).getSources().create(\"javaScriptSources\", JavaScriptSourceSet.class);\n                javaScriptSourceSet.getSource().srcDir(\"app/assets\");\n                javaScriptSourceSet.getSource().include(\"**/*.js\");\n            }\n        }","commit_id":"27ddb0cfe26aedac9a1d03c686a0c0ed520a0d47","url":"https://github.com/gradle/gradle"},{"original_method":"private FileCollection getGroovyClasspath(FileCollection classpath) {\n        Configuration groovyClasspath = project.getConfigurations().getByName(GROOVY_CONFIGURATION_NAME);\n        if (groovyClasspath.getDependencies().isEmpty() && !project.getRepositories().isEmpty()) {\n            Matcher groovyJar = findGroovyJar(classpath);\n            if (groovyJar != null) {\n                // project.getDependencies().create(String) seems to be the only feasible way to create a Dependency with a classifier\n                String notation = \"org.codehaus.groovy:\" + groovyJar.group(1) + \":\" + groovyJar.group(2);\n                if (groovyJar.group(3) != null) {\n                    notation += \":indy\";\n                }\n                List<Dependency> dependencies = Lists.newArrayList();\n                dependencies.add(project.getDependencies().create(notation));\n                if (groovyJar.group(1).equals(\"groovy\") && VersionNumber.parse(groovyJar.group(2)).getMajor() >= 2) {\n                    // for when AntGroovyCompiler is used\n                    dependencies.add(project.getDependencies().create(notation.replace(\":groovy:\", \":groovy-ant:\")));\n                }\n                groovyClasspath = project.getConfigurations().detachedConfiguration(dependencies.toArray(new Dependency[dependencies.size()]));\n            }\n        }\n        return groovyClasspath;\n    }","id":80087,"modified_method":"private FileCollection getGroovyClasspath(FileCollection classpath) {\n        Configuration groovyConfiguration = project.getConfigurations().getByName(GROOVY_CONFIGURATION_NAME);\n        if (!groovyConfiguration.getDependencies().isEmpty()) { return groovyConfiguration; }\n\n        Matcher groovyJar = findGroovyJar(classpath);\n        if (groovyJar == null) { return groovyConfiguration; }\n\n        if (project.getRepositories().isEmpty()) {\n            return project.files(groovyJar.group(0));\n        }\n\n        // project.getDependencies().create(String) seems to be the only feasible way to create a Dependency with a classifier\n        String notation = \"org.codehaus.groovy:\" + groovyJar.group(1) + \":\" + groovyJar.group(2);\n        if (groovyJar.group(3) != null) {\n            notation += \":indy\";\n        }\n        List<Dependency> dependencies = Lists.newArrayList();\n        dependencies.add(project.getDependencies().create(notation));\n        if (groovyJar.group(1).equals(\"groovy\") && VersionNumber.parse(groovyJar.group(2)).getMajor() >= 2) {\n            // for when AntGroovyCompiler is used\n            dependencies.add(project.getDependencies().create(notation.replace(\":groovy:\", \":groovy-ant:\")));\n        }\n        return project.getConfigurations().detachedConfiguration(dependencies.toArray(new Dependency[dependencies.size()]));\n    }","commit_id":"285f08052ad553ecb12b40d53e8c9e11923a94d6","url":"https://github.com/gradle/gradle"},{"original_method":"public PlayApplicationRunner newApplicationRunner(Factory<WorkerProcessBuilder> workerProcessBuilderFactory, PlayRunSpec spec) {\n        PlayRunVersion version = PlayRunVersion.parse(targetPlatform.getPlayVersion());\n\n        List<File> playRunClasspath = new ArrayList<File>();\n        Set<File> applicationFiles = fileResolver.resolveFiles(spec.getClasspath()).getFiles();\n        FileCollection playDependencyFiles = getDependencies(getPlayDependencyNotation(), getDocsDependencyNotation());\n        playRunClasspath.addAll(applicationFiles);\n        playRunClasspath.addAll(playDependencyFiles.getFiles());\n\n        VersionedPlayRunSpec versionedSpec = create(version, spec, playRunClasspath);\n        return new PlayApplicationRunner(fileResolver.resolve(\".\"), workerProcessBuilderFactory, versionedSpec);\n    }","id":80088,"modified_method":"public PlayApplicationRunner newApplicationRunner(Factory<WorkerProcessBuilder> workerProcessBuilderFactory, PlayRunSpec spec) {\n        List<File> playRunClasspath = new ArrayList<File>();\n\n        Set<File> applicationFiles = fileResolver.resolveFiles(spec.getClasspath()).getFiles();\n        FileCollection playDependencyFiles = getPlatformDependencies(\"play\", \"play-docs\");\n        playRunClasspath.addAll(applicationFiles);\n        playRunClasspath.addAll(playDependencyFiles.getFiles());\n\n        VersionedPlayRunSpec versionedSpec = createPlayRunner(spec, playRunClasspath);\n        return new PlayApplicationRunner(fileResolver.resolve(\".\"), workerProcessBuilderFactory, versionedSpec);\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public Object getDocsDependencyNotation() {\n        return String.format(\"com.typesafe.play:play-docs_%s:%s\", targetPlatform.getScalaPlatform().getScalaCompatibilityVersion(), targetPlatform.getPlayVersion(), targetPlatform.getPlayVersion());\n    }","id":80089,"modified_method":"private String getDependencyNotation(String module) {\n        return String.format(\"com.typesafe.play:%s_%s:%s\", module, targetPlatform.getScalaPlatform().getScalaCompatibilityVersion(), targetPlatform.getPlayVersion());\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"private Configuration resolveClasspath(Object... dependencyNotations) {\n        List<Dependency> dependencies = CollectionUtils.collect(dependencyNotations, new Transformer<Dependency, Object>() {\n            public Dependency transform(Object dependencyNotation) {\n                return dependencyHandler.create(dependencyNotation);\n            }\n        });\n        Dependency[] dependenciesArray = dependencies.toArray(new Dependency[dependencies.size()]);\n        Configuration detachedConfiguration = configurationContainer.detachedConfiguration(dependenciesArray);\n        return detachedConfiguration;\n    }","id":80090,"modified_method":"private Configuration resolveClasspath(Object... dependencyNotations) {\n        List<Dependency> dependencies = CollectionUtils.collect(dependencyNotations, new Transformer<Dependency, Object>() {\n            public Dependency transform(Object dependencyNotation) {\n                return dependencyHandler.create(dependencyNotation);\n            }\n        });\n        Dependency[] dependenciesArray = dependencies.toArray(new Dependency[dependencies.size()]);\n        return configurationContainer.detachedConfiguration(dependenciesArray);\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public VersionedPlayRunSpec create(PlayRunVersion version, PlayRunSpec spec, Iterable<File> classpath) {\n        switch (version) {\n            case V_22X:\n                return new PlayRunSpecV22X(classpath, spec.getProjectPath(), spec.getForkOptions(), spec.getHttpPort());\n            case V_23X:\n                return new PlayRunSpecV23X(classpath, spec.getProjectPath(), spec.getForkOptions(), spec.getHttpPort());\n            default:\n                throw new RuntimeException(\"Could not create play run spec for version: \" + version);\n        }\n    }","id":80091,"modified_method":"public VersionedPlayRunSpec createPlayRunner(PlayRunSpec spec, Iterable<File> classpath) {\n        switch (playVersion) {\n            case PLAY_2_2_X:\n                return new PlayRunSpecV22X(classpath, spec.getProjectPath(), spec.getForkOptions(), spec.getHttpPort());\n            case PLAY_2_3_X:\n            default:\n                return new PlayRunSpecV23X(classpath, spec.getProjectPath(), spec.getForkOptions(), spec.getHttpPort());\n        }\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollection getPlayDependencies() {\n        return getDependencies(getPlayDependencyNotation());\n    }","id":80092,"modified_method":"public FileCollection getPlayDependencies() {\n        return getPlatformDependencies(\"play\");\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultPlayToolProvider(FileResolver fileResolver, CompilerDaemonManager compilerDaemonManager, ConfigurationContainer configurationContainer, DependencyHandler dependencyHandler, PlayPlatform targetPlatform) {\n        this.fileResolver = fileResolver;\n        this.compilerDaemonManager = compilerDaemonManager;\n        this.configurationContainer = configurationContainer;\n        this.dependencyHandler = dependencyHandler;\n        this.targetPlatform = targetPlatform;\n    }","id":80093,"modified_method":"public DefaultPlayToolProvider(FileResolver fileResolver, CompilerDaemonManager compilerDaemonManager, ConfigurationContainer configurationContainer, DependencyHandler dependencyHandler, PlayPlatform targetPlatform) {\n        this.fileResolver = fileResolver;\n        this.compilerDaemonManager = compilerDaemonManager;\n        this.configurationContainer = configurationContainer;\n        this.dependencyHandler = dependencyHandler;\n        this.targetPlatform = targetPlatform;\n        this.playVersion = parsePlayVersion(targetPlatform);\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollection getPlayTestDependencies() {\n        return getDependencies(String.format(\"com.typesafe.play:play-test_%s:%s\", targetPlatform.getScalaPlatform().getScalaCompatibilityVersion(), targetPlatform.getPlayVersion(), targetPlatform.getPlayVersion()));\n    }","id":80094,"modified_method":"public FileCollection getPlayTestDependencies() {\n        return getPlatformDependencies(\"play-test\");\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public Object getBuildDocHandler(ClassLoader docsClassLoader, JarFile docJar) throws NoSuchMethodException, ClassNotFoundException, IOException, InvocationTargetException, IllegalAccessException {\n        return getDocHandlerFactoryMethod(docsClassLoader).invoke(null, docJar, \"play/docs/content\");\n    }","id":80095,"modified_method":"public Object getBuildDocHandler(ClassLoader docsClassLoader) throws NoSuchMethodException, ClassNotFoundException, IOException, IllegalAccessException {\n        try {\n            return getDocHandlerFactoryMethod(docsClassLoader).invoke(null, getDocJar(), \"play/docs/content\");\n        } catch (InvocationTargetException e) {\n            throw UncheckedException.unwrapAndRethrow(e);\n        }\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public PlayAppLifecycleUpdate(Exception exception) {\n        this.status = PlayAppStatus.FAILED;\n        this.exception = exception;\n    }","id":80096,"modified_method":"private PlayAppLifecycleUpdate(Exception exception) {\n        this.running = false;\n        this.exception = exception;\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public PlayAppLifecycleUpdate(PlayAppStatus status) {\n        this.status = status;\n        this.exception = null;\n    }","id":80097,"modified_method":"private PlayAppLifecycleUpdate(boolean isRunning) {\n        this.running = isRunning;\n        this.exception = null;\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public PlayApplicationRunnerToken start() {\n        WorkerProcess process = createWorkerProcess(workingDir, workerFactory, spec);\n        process.start();\n\n        PlayWorkerClient clientCallBack = new PlayWorkerClient();\n        process.getConnection().addIncoming(PlayRunWorkerClientProtocol.class, clientCallBack);\n        PlayRunWorkerServerProtocol workerServer = process.getConnection().addOutgoing(PlayRunWorkerServerProtocol.class);\n        process.getConnection().connect();\n        PlayAppLifecycleUpdate result = clientCallBack.waitForRunning();\n        if (result.getStatus() == PlayAppStatus.RUNNING) {\n            return new PlayApplicationRunnerToken(workerServer, clientCallBack);\n        } else {\n            throw new GradleException(\"Unable to start Play application.\", result.getException());\n        }\n    }","id":80098,"modified_method":"public PlayApplicationRunnerToken start() {\n        WorkerProcess process = createWorkerProcess(workingDir, workerFactory, spec);\n        process.start();\n\n        PlayWorkerClient clientCallBack = new PlayWorkerClient();\n        process.getConnection().addIncoming(PlayRunWorkerClientProtocol.class, clientCallBack);\n        PlayRunWorkerServerProtocol workerServer = process.getConnection().addOutgoing(PlayRunWorkerServerProtocol.class);\n        process.getConnection().connect();\n        PlayAppLifecycleUpdate result = clientCallBack.waitForRunning();\n        if (result.isRunning()) {\n            return new PlayApplicationRunnerToken(workerServer, clientCallBack);\n        } else {\n            throw new GradleException(\"Unable to start Play application.\", result.getException());\n        }\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public void update(PlayAppLifecycleUpdate update) {\n        try {\n            PlayAppStatus status = update.getStatus();\n            if (status == PlayAppStatus.RUNNING || status == PlayAppStatus.FAILED) {\n                startEvent.put(update);\n            } else {\n                stopEvent.put(update);\n            }\n        } catch (InterruptedException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","id":80099,"modified_method":"public void update(PlayAppLifecycleUpdate update) {\n        try {\n            if (update.isStopped()) {\n                stopEvent.put(update);\n            } else {\n                startEvent.put(update);\n            }\n        } catch (InterruptedException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(WorkerProcessContext context) {\n        stop = new CountDownLatch(1);\n        final PlayRunWorkerClientProtocol clientProtocol = context.getServerConnection().addOutgoing(PlayRunWorkerClientProtocol.class);\n        context.getServerConnection().addIncoming(PlayRunWorkerServerProtocol.class, this);\n        context.getServerConnection().connect();\n        final PlayAppLifecycleUpdate result = startServer();\n        try {\n            clientProtocol.update(result);\n            stop.await();\n        } catch (InterruptedException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            clientProtocol.update(new PlayAppLifecycleUpdate(PlayAppStatus.STOPPED));\n        }\n    }","id":80100,"modified_method":"public void execute(WorkerProcessContext context) {\n        stop = new CountDownLatch(1);\n        final PlayRunWorkerClientProtocol clientProtocol = context.getServerConnection().addOutgoing(PlayRunWorkerClientProtocol.class);\n        context.getServerConnection().addIncoming(PlayRunWorkerServerProtocol.class, this);\n        context.getServerConnection().connect();\n        final PlayAppLifecycleUpdate result = startServer();\n        try {\n            clientProtocol.update(result);\n            stop.await();\n        } catch (InterruptedException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            clientProtocol.update(PlayAppLifecycleUpdate.stopped());\n        }\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"public PlayAppLifecycleUpdate startServer() {\n        try {\n            PlayExecuter playExcutor = new PlayExecuter();\n            playExcutor.run(spec);\n            return new PlayAppLifecycleUpdate(PlayAppStatus.RUNNING);\n        } catch (Exception e) {\n            Logging.getLogger(this.getClass()).error(\"Failed to run Play\", e);\n            return new PlayAppLifecycleUpdate(e);\n        }\n    }","id":80101,"modified_method":"private PlayAppLifecycleUpdate startServer() {\n        try {\n            run(spec);\n            return PlayAppLifecycleUpdate.running();\n        } catch (Exception e) {\n            Logging.getLogger(this.getClass()).error(\"Failed to run Play\", e);\n            return PlayAppLifecycleUpdate.failed(e);\n        }\n    }","commit_id":"a059ce4cba2cded84a62170b2fbfcb24ddcd368b","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n   * Read the view archives.\n   *\n   * @param configuration  Ambari configuration\n   *\n   * @return the set of view instance definitions read from the archives\n   *\n   * @throws SystemException if the view archives can not be successfully read\n   */\n  public Set<ViewInstanceEntity> readViewArchives(Configuration configuration)\n      throws SystemException {\n\n    try {\n      File viewDir = configuration.getViewsDir();\n\n      Set<ViewInstanceEntity> allInstanceDefinitions = new HashSet<ViewInstanceEntity>();\n\n      String extractedArchivesPath = viewDir.getAbsolutePath() +\n          File.separator + EXTRACTED_ARCHIVES_DIR;\n\n      if (ensureExtractedArchiveDirectory(extractedArchivesPath)) {\n        File[] files = viewDir.listFiles();\n\n        if (files != null) {\n          for (File archiveFile : files) {\n            if (!archiveFile.isDirectory()) {\n              try {\n                ViewConfig viewConfig = helper.getViewConfigFromArchive(archiveFile);\n\n                String viewName    = ViewEntity.getViewName(viewConfig.getName(), viewConfig.getVersion());\n                String archivePath = extractedArchivesPath + File.separator + viewName;\n\n                // extract the archive and get the class loader\n                ClassLoader cl = extractViewArchive(archiveFile, helper.getFile(archivePath));\n\n                ViewEntity viewDefinition = createViewDefinition(viewConfig, configuration, cl, archivePath);\n\n                Set<ViewInstanceEntity> instanceDefinitions = new HashSet<ViewInstanceEntity>();\n\n                for (InstanceConfig instanceConfig : viewConfig.getInstances()) {\n                  try {\n                    instanceDefinitions.add(createViewInstanceDefinition(viewDefinition, instanceConfig));\n                  } catch (Exception e) {\n                    LOG.error(\"Caught exception adding view instance for view \" +\n                        viewDefinition.getViewName(), e);\n                  }\n                }\n                // ensure that the view entity matches the db\n                instanceDefinitions.addAll(persistView(viewDefinition));\n\n                // update the registry with the view\n                addDefinition(viewDefinition);\n\n                // update the registry with the view instances\n                for (ViewInstanceEntity instanceEntity : instanceDefinitions) {\n                  addInstanceDefinition(viewDefinition, instanceEntity);\n                }\n\n                allInstanceDefinitions.addAll(instanceDefinitions);\n              } catch (Exception e) {\n                LOG.error(\"Caught exception loading view from \" + archiveFile.getAbsolutePath(), e);\n              }\n            }\n          }\n          removeUndeployedViews();\n        }\n      }\n      return allInstanceDefinitions;\n    } catch (Exception e) {\n      throw new SystemException(\"Caught exception reading view archives.\", e);\n    }\n  }","id":80102,"modified_method":"/**\n   * Read the view archives.\n   *\n   * @param configuration  Ambari configuration\n   *\n   * @return the set of view instance definitions read from the archives\n   *\n   * @throws SystemException if the view archives can not be successfully read\n   */\n  public Set<ViewInstanceEntity> readViewArchives(Configuration configuration)\n      throws SystemException {\n\n    try {\n      File viewDir = configuration.getViewsDir();\n\n      Set<ViewInstanceEntity> allInstanceDefinitions = new HashSet<ViewInstanceEntity>();\n\n      String extractedArchivesPath = viewDir.getAbsolutePath() +\n          File.separator + EXTRACTED_ARCHIVES_DIR;\n\n      if (ensureExtractedArchiveDirectory(extractedArchivesPath)) {\n        File[] files = viewDir.listFiles();\n\n        if (files != null) {\n          for (File archiveFile : files) {\n            if (!archiveFile.isDirectory()) {\n              try {\n                ViewConfig viewConfig = helper.getViewConfigFromArchive(archiveFile);\n\n                String viewName    = ViewEntity.getViewName(viewConfig.getName(), viewConfig.getVersion());\n                String archivePath = extractedArchivesPath + File.separator + viewName;\n\n                // extract the archive and get the class loader\n                ClassLoader cl = extractViewArchive(archiveFile, helper.getFile(archivePath));\n\n                ViewEntity viewDefinition = createViewDefinition(viewConfig, configuration, cl, archivePath);\n\n                Set<ViewInstanceEntity> instanceDefinitions = new HashSet<ViewInstanceEntity>();\n\n                for (InstanceConfig instanceConfig : viewConfig.getInstances()) {\n                  try {\n                    instanceDefinitions.add(createViewInstanceDefinition(viewDefinition, instanceConfig));\n                  } catch (Exception e) {\n                    LOG.error(\"Caught exception adding view instance for view \" +\n                        viewDefinition.getViewName(), e);\n                  }\n                }\n                // ensure that the view entity matches the db\n                syncView(viewDefinition, instanceDefinitions);\n\n                // update the registry with the view\n                addDefinition(viewDefinition);\n\n                // update the registry with the view instances\n                for (ViewInstanceEntity instanceEntity : instanceDefinitions) {\n                  addInstanceDefinition(viewDefinition, instanceEntity);\n                }\n\n                allInstanceDefinitions.addAll(instanceDefinitions);\n              } catch (Exception e) {\n                LOG.error(\"Caught exception loading view from \" + archiveFile.getAbsolutePath(), e);\n              }\n            }\n          }\n          removeUndeployedViews();\n        }\n      }\n      return allInstanceDefinitions;\n    } catch (Exception e) {\n      throw new SystemException(\"Caught exception reading view archives.\", e);\n    }\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Install the given view instance with its associated view.\n   *\n   * @param instanceEntity  the view instance entity\n   *\n   * @throws IllegalStateException     if the given instance is not in a valid state\n   * @throws IllegalArgumentException  if the view associated with the given instance\n   *                                   does not exist\n   */\n  public void installViewInstance(ViewInstanceEntity instanceEntity)\n      throws IllegalStateException, IllegalArgumentException {\n    ViewEntity viewEntity = getDefinition(instanceEntity.getViewName());\n\n    if (viewEntity != null) {\n      String instanceName = instanceEntity.getName();\n      String viewName     = viewEntity.getCommonName();\n      String version      = viewEntity.getVersion();\n\n      if (getInstanceDefinition(viewName, version, instanceName) == null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Creating view instance \" + viewName + \"/\" +\n              version + \"/\" + instanceName);\n        }\n        instanceEntity.validate(viewEntity);\n        instanceDAO.create(instanceEntity);\n        try {\n          // bind the view instance to a view\n          bindViewInstance(viewEntity, instanceEntity);\n        } catch (Exception e) {\n          String message = \"Caught exception installing view instance.\";\n          LOG.error(message, e);\n          throw new IllegalStateException(message, e);\n        }\n        // update the registry\n        addInstanceDefinition(viewEntity, instanceEntity);\n      }\n    } else {\n      String message = \"Attempt to install an instance for an unknown view \" +\n          instanceEntity.getViewName() + \".\";\n\n      LOG.error(message);\n      throw new IllegalArgumentException(message);\n    }\n  }","id":80103,"modified_method":"/**\n   * Install the given view instance with its associated view.\n   *\n   * @param instanceEntity  the view instance entity\n   *\n   * @throws IllegalStateException     if the given instance is not in a valid state\n   * @throws IllegalArgumentException  if the view associated with the given instance\n   *                                   does not exist\n   */\n  public void installViewInstance(ViewInstanceEntity instanceEntity)\n      throws IllegalStateException, IllegalArgumentException {\n    ViewEntity viewEntity = getDefinition(instanceEntity.getViewName());\n\n    if (viewEntity != null) {\n      String instanceName = instanceEntity.getName();\n      String viewName     = viewEntity.getCommonName();\n      String version      = viewEntity.getVersion();\n\n      if (getInstanceDefinition(viewName, version, instanceName) == null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Creating view instance \" + viewName + \"/\" +\n              version + \"/\" + instanceName);\n        }\n        instanceEntity.validate(viewEntity);\n        instanceDAO.merge(instanceEntity);\n        try {\n          // bind the view instance to a view\n          bindViewInstance(viewEntity, instanceEntity);\n        } catch (Exception e) {\n          String message = \"Caught exception installing view instance.\";\n          LOG.error(message, e);\n          throw new IllegalStateException(message, e);\n        }\n        // update the registry\n        addInstanceDefinition(viewEntity, instanceEntity);\n      }\n    } else {\n      String message = \"Attempt to install an instance for an unknown view \" +\n          instanceEntity.getViewName() + \".\";\n\n      LOG.error(message);\n      throw new IllegalArgumentException(message);\n    }\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testReadViewArchives_exception() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    File viewDir = createNiceMock(File.class);\n    File extractedArchiveDir = createNiceMock(File.class);\n    File viewArchive = createNiceMock(File.class);\n    File archiveDir = createNiceMock(File.class);\n    File entryFile  = createNiceMock(File.class);\n    File classesDir = createNiceMock(File.class);\n    File libDir = createNiceMock(File.class);\n    File fileEntry = createNiceMock(File.class);\n\n    JarFile viewJarFile = createNiceMock(JarFile.class);\n    Enumeration<JarEntry> enumeration = createMock(Enumeration.class);\n    JarEntry jarEntry = createNiceMock(JarEntry.class);\n    InputStream is = createMock(InputStream.class);\n    FileOutputStream fos = createMock(FileOutputStream.class);\n\n    ViewDAO vDAO = createMock(ViewDAO.class);\n\n    ViewRegistry.setViewDAO(vDAO);\n\n    ViewEntity viewDefinition = ViewEntityTest.getViewEntity();\n\n    Map<File, ViewConfig> viewConfigs =\n        Collections.singletonMap(viewArchive, viewDefinition.getConfiguration());\n\n    Map<String, File> files = new HashMap<String, File>();\n\n    files.put(\"/var/lib/ambari-server/resources/views/work\", extractedArchiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\", archiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/view.xml\", entryFile);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/classes\", classesDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/lib\", libDir);\n\n    Map<File, FileOutputStream> outputStreams = new HashMap<File, FileOutputStream>();\n    outputStreams.put(entryFile, fos);\n\n    Map<File, JarFile> jarFiles = new HashMap<File, JarFile>();\n    jarFiles.put(viewArchive, viewJarFile);\n\n    // set expectations\n    expect(configuration.getViewsDir()).andReturn(viewDir);\n    expect(viewDir.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views\");\n\n    expect(viewDir.listFiles()).andReturn(new File[]{viewArchive});\n\n    expect(viewArchive.isDirectory()).andReturn(false);\n\n    expect(archiveDir.exists()).andReturn(false);\n    expect(archiveDir.getAbsolutePath()).andReturn(\n        \"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n    expect(archiveDir.mkdir()).andReturn(true);\n    expect(archiveDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewJarFile.entries()).andReturn(enumeration);\n    expect(viewJarFile.getInputStream(jarEntry)).andReturn(is);\n\n    expect(enumeration.hasMoreElements()).andReturn(true);\n    expect(enumeration.hasMoreElements()).andReturn(false);\n    expect(enumeration.nextElement()).andReturn(jarEntry);\n\n    expect(jarEntry.getName()).andReturn(\"view.xml\");\n    expect(jarEntry.isDirectory()).andReturn(false);\n\n    expect(is.available()).andReturn(1);\n    expect(is.available()).andReturn(0);\n\n    expect(is.read()).andReturn(10);\n    fos.write(10);\n\n    fos.close();\n    is.close();\n\n    expect(extractedArchiveDir.exists()).andReturn(false);\n    expect(extractedArchiveDir.mkdir()).andReturn(true);\n\n    expect(classesDir.exists()).andReturn(true);\n    expect(classesDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(libDir.exists()).andReturn(true);\n\n    expect(libDir.listFiles()).andReturn(new File[]{fileEntry});\n    expect(fileEntry.toURI()).andReturn(new URI(\"file:./\"));\n\n    Capture<ViewEntity> captureViewEntity = new Capture<ViewEntity>();\n\n    expect(vDAO.findByName(\"MY_VIEW{1.0.0}\")).andReturn(null);\n    vDAO.create(capture(captureViewEntity));\n    expectLastCall().andThrow(new IllegalArgumentException(\"Expected exception.\"));\n\n    expect(vDAO.findAll()).andReturn(Collections.<ViewEntity>emptyList());\n\n    // replay mocks\n    replay(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n    registry.setHelper(new TestViewRegistryHelper(viewConfigs, files, outputStreams, jarFiles));\n\n    Set<ViewInstanceEntity> instanceEntities = registry.readViewArchives(configuration);\n\n    Assert.assertEquals(0, instanceEntities.size());\n\n    // verify mocks\n    verify(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n  }","id":80104,"modified_method":"@Test\n  public void testReadViewArchives_exception() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    File viewDir = createNiceMock(File.class);\n    File extractedArchiveDir = createNiceMock(File.class);\n    File viewArchive = createNiceMock(File.class);\n    File archiveDir = createNiceMock(File.class);\n    File entryFile  = createNiceMock(File.class);\n    File classesDir = createNiceMock(File.class);\n    File libDir = createNiceMock(File.class);\n    File fileEntry = createNiceMock(File.class);\n\n    JarFile viewJarFile = createNiceMock(JarFile.class);\n    Enumeration<JarEntry> enumeration = createMock(Enumeration.class);\n    JarEntry jarEntry = createNiceMock(JarEntry.class);\n    InputStream is = createMock(InputStream.class);\n    FileOutputStream fos = createMock(FileOutputStream.class);\n\n    ViewDAO vDAO = createMock(ViewDAO.class);\n\n    ViewRegistry.setViewDAO(vDAO);\n\n    ViewEntity viewDefinition = ViewEntityTest.getViewEntity();\n\n    Map<File, ViewConfig> viewConfigs =\n        Collections.singletonMap(viewArchive, viewDefinition.getConfiguration());\n\n    Map<String, File> files = new HashMap<String, File>();\n\n    files.put(\"/var/lib/ambari-server/resources/views/work\", extractedArchiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\", archiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/view.xml\", entryFile);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/classes\", classesDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/lib\", libDir);\n\n    Map<File, FileOutputStream> outputStreams = new HashMap<File, FileOutputStream>();\n    outputStreams.put(entryFile, fos);\n\n    Map<File, JarFile> jarFiles = new HashMap<File, JarFile>();\n    jarFiles.put(viewArchive, viewJarFile);\n\n    // set expectations\n    expect(configuration.getViewsDir()).andReturn(viewDir);\n    expect(viewDir.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views\");\n\n    expect(viewDir.listFiles()).andReturn(new File[]{viewArchive});\n\n    expect(viewArchive.isDirectory()).andReturn(false);\n\n    expect(archiveDir.exists()).andReturn(false);\n    expect(archiveDir.getAbsolutePath()).andReturn(\n        \"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n    expect(archiveDir.mkdir()).andReturn(true);\n    expect(archiveDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewJarFile.entries()).andReturn(enumeration);\n    expect(viewJarFile.getInputStream(jarEntry)).andReturn(is);\n\n    expect(enumeration.hasMoreElements()).andReturn(true);\n    expect(enumeration.hasMoreElements()).andReturn(false);\n    expect(enumeration.nextElement()).andReturn(jarEntry);\n\n    expect(jarEntry.getName()).andReturn(\"view.xml\");\n    expect(jarEntry.isDirectory()).andReturn(false);\n\n    expect(is.available()).andReturn(1);\n    expect(is.available()).andReturn(0);\n\n    expect(is.read()).andReturn(10);\n    fos.write(10);\n\n    fos.close();\n    is.close();\n\n    expect(extractedArchiveDir.exists()).andReturn(false);\n    expect(extractedArchiveDir.mkdir()).andReturn(true);\n\n    expect(classesDir.exists()).andReturn(true);\n    expect(classesDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(libDir.exists()).andReturn(true);\n\n    expect(libDir.listFiles()).andReturn(new File[]{fileEntry});\n    expect(fileEntry.toURI()).andReturn(new URI(\"file:./\"));\n\n    Capture<ViewEntity> captureViewEntity = new Capture<ViewEntity>();\n\n    expect(vDAO.findByName(\"MY_VIEW{1.0.0}\")).andReturn(null);\n    expect(vDAO.merge(capture(captureViewEntity))).andThrow(new IllegalArgumentException(\"Expected exception.\"));\n\n    expect(vDAO.findAll()).andReturn(Collections.<ViewEntity>emptyList());\n\n    // replay mocks\n    replay(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n    registry.setHelper(new TestViewRegistryHelper(viewConfigs, files, outputStreams, jarFiles));\n\n    Set<ViewInstanceEntity> instanceEntities = registry.readViewArchives(configuration);\n\n    Assert.assertEquals(0, instanceEntities.size());\n\n    // verify mocks\n    verify(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testReadViewArchives() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    File viewDir = createNiceMock(File.class);\n    File extractedArchiveDir = createNiceMock(File.class);\n    File viewArchive = createNiceMock(File.class);\n    File archiveDir = createNiceMock(File.class);\n    File entryFile  = createNiceMock(File.class);\n    File classesDir = createNiceMock(File.class);\n    File libDir = createNiceMock(File.class);\n    File fileEntry = createNiceMock(File.class);\n\n    JarFile viewJarFile = createNiceMock(JarFile.class);\n    Enumeration<JarEntry> enumeration = createMock(Enumeration.class);\n    JarEntry jarEntry = createNiceMock(JarEntry.class);\n    InputStream is = createMock(InputStream.class);\n    FileOutputStream fos = createMock(FileOutputStream.class);\n\n    ViewDAO vDAO = createMock(ViewDAO.class);\n\n    ViewRegistry.setViewDAO(vDAO);\n\n    ViewEntity viewDefinition = ViewEntityTest.getViewEntity();\n\n    Map<File, ViewConfig> viewConfigs =\n        Collections.singletonMap(viewArchive, viewDefinition.getConfiguration());\n\n    Map<String, File> files = new HashMap<String, File>();\n\n    files.put(\"/var/lib/ambari-server/resources/views/work\", extractedArchiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\", archiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/view.xml\", entryFile);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/classes\", classesDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/lib\", libDir);\n\n    Map<File, FileOutputStream> outputStreams = new HashMap<File, FileOutputStream>();\n    outputStreams.put(entryFile, fos);\n\n    Map<File, JarFile> jarFiles = new HashMap<File, JarFile>();\n    jarFiles.put(viewArchive, viewJarFile);\n\n    // set expectations\n    expect(configuration.getViewsDir()).andReturn(viewDir);\n    expect(viewDir.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views\");\n\n    expect(viewDir.listFiles()).andReturn(new File[]{viewArchive});\n\n    expect(viewArchive.isDirectory()).andReturn(false);\n\n    expect(archiveDir.exists()).andReturn(false);\n    expect(archiveDir.getAbsolutePath()).andReturn(\n        \"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n    expect(archiveDir.mkdir()).andReturn(true);\n    expect(archiveDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewJarFile.entries()).andReturn(enumeration);\n    expect(viewJarFile.getInputStream(jarEntry)).andReturn(is);\n\n    expect(enumeration.hasMoreElements()).andReturn(true);\n    expect(enumeration.hasMoreElements()).andReturn(false);\n    expect(enumeration.nextElement()).andReturn(jarEntry);\n\n    expect(jarEntry.getName()).andReturn(\"view.xml\");\n    expect(jarEntry.isDirectory()).andReturn(false);\n\n    expect(is.available()).andReturn(1);\n    expect(is.available()).andReturn(0);\n\n    expect(is.read()).andReturn(10);\n    fos.write(10);\n\n    fos.close();\n    is.close();\n\n    expect(extractedArchiveDir.exists()).andReturn(false);\n    expect(extractedArchiveDir.mkdir()).andReturn(true);\n\n    expect(classesDir.exists()).andReturn(true);\n    expect(classesDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(libDir.exists()).andReturn(true);\n\n    expect(libDir.listFiles()).andReturn(new File[]{fileEntry});\n    expect(fileEntry.toURI()).andReturn(new URI(\"file:./\"));\n\n    Capture<ViewEntity> captureViewEntity = new Capture<ViewEntity>();\n\n    expect(vDAO.findByName(\"MY_VIEW{1.0.0}\")).andReturn(null);\n    vDAO.create(capture(captureViewEntity));\n\n    expect(vDAO.findAll()).andReturn(Collections.<ViewEntity>emptyList());\n\n    // replay mocks\n    replay(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n    registry.setHelper(new TestViewRegistryHelper(viewConfigs, files, outputStreams, jarFiles));\n\n    Set<ViewInstanceEntity> instanceEntities = registry.readViewArchives(configuration);\n\n    Assert.assertEquals(2, instanceEntities.size());\n    Assert.assertEquals(\"MY_VIEW\", captureViewEntity.getValue().getCommonName());\n\n    // verify mocks\n    verify(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n  }","id":80105,"modified_method":"@Test\n  public void testReadViewArchives() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    File viewDir = createNiceMock(File.class);\n    File extractedArchiveDir = createNiceMock(File.class);\n    File viewArchive = createNiceMock(File.class);\n    File archiveDir = createNiceMock(File.class);\n    File entryFile  = createNiceMock(File.class);\n    File classesDir = createNiceMock(File.class);\n    File libDir = createNiceMock(File.class);\n    File fileEntry = createNiceMock(File.class);\n\n    JarFile viewJarFile = createNiceMock(JarFile.class);\n    Enumeration<JarEntry> enumeration = createMock(Enumeration.class);\n    JarEntry jarEntry = createNiceMock(JarEntry.class);\n    InputStream is = createMock(InputStream.class);\n    FileOutputStream fos = createMock(FileOutputStream.class);\n\n    ViewDAO vDAO = createMock(ViewDAO.class);\n\n    ViewRegistry.setViewDAO(vDAO);\n\n    ViewEntity viewDefinition = ViewEntityTest.getViewEntity();\n\n    Map<File, ViewConfig> viewConfigs =\n        Collections.singletonMap(viewArchive, viewDefinition.getConfiguration());\n\n    Map<String, File> files = new HashMap<String, File>();\n\n    files.put(\"/var/lib/ambari-server/resources/views/work\", extractedArchiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\", archiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/view.xml\", entryFile);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/classes\", classesDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/lib\", libDir);\n\n    Map<File, FileOutputStream> outputStreams = new HashMap<File, FileOutputStream>();\n    outputStreams.put(entryFile, fos);\n\n    Map<File, JarFile> jarFiles = new HashMap<File, JarFile>();\n    jarFiles.put(viewArchive, viewJarFile);\n\n    // set expectations\n    expect(configuration.getViewsDir()).andReturn(viewDir);\n    expect(viewDir.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views\");\n\n    expect(viewDir.listFiles()).andReturn(new File[]{viewArchive});\n\n    expect(viewArchive.isDirectory()).andReturn(false);\n\n    expect(archiveDir.exists()).andReturn(false);\n    expect(archiveDir.getAbsolutePath()).andReturn(\n        \"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n    expect(archiveDir.mkdir()).andReturn(true);\n    expect(archiveDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewJarFile.entries()).andReturn(enumeration);\n    expect(viewJarFile.getInputStream(jarEntry)).andReturn(is);\n\n    expect(enumeration.hasMoreElements()).andReturn(true);\n    expect(enumeration.hasMoreElements()).andReturn(false);\n    expect(enumeration.nextElement()).andReturn(jarEntry);\n\n    expect(jarEntry.getName()).andReturn(\"view.xml\");\n    expect(jarEntry.isDirectory()).andReturn(false);\n\n    expect(is.available()).andReturn(1);\n    expect(is.available()).andReturn(0);\n\n    expect(is.read()).andReturn(10);\n    fos.write(10);\n\n    fos.close();\n    is.close();\n\n    expect(extractedArchiveDir.exists()).andReturn(false);\n    expect(extractedArchiveDir.mkdir()).andReturn(true);\n\n    expect(classesDir.exists()).andReturn(true);\n    expect(classesDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(libDir.exists()).andReturn(true);\n\n    expect(libDir.listFiles()).andReturn(new File[]{fileEntry});\n    expect(fileEntry.toURI()).andReturn(new URI(\"file:./\"));\n\n    Capture<ViewEntity> captureViewEntity = new Capture<ViewEntity>();\n\n    expect(vDAO.findByName(\"MY_VIEW{1.0.0}\")).andReturn(null);\n    expect(vDAO.merge(capture(captureViewEntity))).andReturn(null);\n\n    expect(vDAO.findAll()).andReturn(Collections.<ViewEntity>emptyList());\n\n    // replay mocks\n    replay(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n    registry.setHelper(new TestViewRegistryHelper(viewConfigs, files, outputStreams, jarFiles));\n\n    Set<ViewInstanceEntity> instanceEntities = registry.readViewArchives(configuration);\n\n    Assert.assertEquals(2, instanceEntities.size());\n    Assert.assertEquals(\"MY_VIEW\", captureViewEntity.getValue().getCommonName());\n\n    // verify mocks\n    verify(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, vDAO);\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateViewInstance_invalid() throws Exception {\n\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n\n    ViewRegistry.init(viewDAO, viewInstanceDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n\n    Properties properties = new Properties();\n    properties.put(\"p1\", \"v1\");\n\n    Configuration ambariConfig = new Configuration(properties);\n\n    ViewConfig config = ViewConfigTest.getConfig(xml_valid_instance);\n    ViewConfig invalidConfig = ViewConfigTest.getConfig(xml_invalid_instance);\n    ViewEntity viewEntity = getViewEntity(config, ambariConfig, getClass().getClassLoader(), \"\");\n    ViewInstanceEntity viewInstanceEntity = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n    ViewInstanceEntity updateInstance = getViewInstanceEntity(viewEntity, invalidConfig.getInstances().get(0));\n\n    viewInstanceDAO.create(viewInstanceEntity);\n\n    replay(viewDAO, viewInstanceDAO);\n\n    registry.addDefinition(viewEntity);\n    registry.installViewInstance(viewInstanceEntity);\n\n    try {\n      registry.updateViewInstance(updateInstance);\n      Assert.fail(\"expected an IllegalStateException\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n    verify(viewDAO, viewInstanceDAO);\n  }","id":80106,"modified_method":"@Test\n  public void testUpdateViewInstance_invalid() throws Exception {\n\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n\n    ViewRegistry.init(viewDAO, viewInstanceDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n\n    Properties properties = new Properties();\n    properties.put(\"p1\", \"v1\");\n\n    Configuration ambariConfig = new Configuration(properties);\n\n    ViewConfig config = ViewConfigTest.getConfig(xml_valid_instance);\n    ViewConfig invalidConfig = ViewConfigTest.getConfig(xml_invalid_instance);\n    ViewEntity viewEntity = getViewEntity(config, ambariConfig, getClass().getClassLoader(), \"\");\n    ViewInstanceEntity viewInstanceEntity = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n    ViewInstanceEntity updateInstance = getViewInstanceEntity(viewEntity, invalidConfig.getInstances().get(0));\n\n    expect(viewInstanceDAO.merge(viewInstanceEntity)).andReturn(null);\n\n    replay(viewDAO, viewInstanceDAO);\n\n    registry.addDefinition(viewEntity);\n    registry.installViewInstance(viewInstanceEntity);\n\n    try {\n      registry.updateViewInstance(updateInstance);\n      Assert.fail(\"expected an IllegalStateException\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n    verify(viewDAO, viewInstanceDAO);\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testInstallViewInstance() throws Exception {\n\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n\n    ViewRegistry.init(viewDAO, viewInstanceDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n\n    Properties properties = new Properties();\n    properties.put(\"p1\", \"v1\");\n\n    Configuration ambariConfig = new Configuration(properties);\n\n    ViewConfig config = ViewConfigTest.getConfig(xml_valid_instance);\n    ViewEntity viewEntity = getViewEntity(config, ambariConfig, getClass().getClassLoader(), \"\");\n    ViewInstanceEntity viewInstanceEntity = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n\n    viewInstanceDAO.create(viewInstanceEntity);\n\n    replay(viewDAO, viewInstanceDAO);\n\n    registry.addDefinition(viewEntity);\n    registry.installViewInstance(viewInstanceEntity);\n\n    Collection<ViewInstanceEntity> viewInstanceDefinitions = registry.getInstanceDefinitions(viewEntity);\n\n    Assert.assertEquals(1, viewInstanceDefinitions.size());\n\n    Assert.assertEquals(viewInstanceEntity, viewInstanceDefinitions.iterator().next());\n\n    verify(viewDAO, viewInstanceDAO);\n  }","id":80107,"modified_method":"@Test\n  public void testInstallViewInstance() throws Exception {\n\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n\n    ViewRegistry.init(viewDAO, viewInstanceDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n\n    Properties properties = new Properties();\n    properties.put(\"p1\", \"v1\");\n\n    Configuration ambariConfig = new Configuration(properties);\n\n    ViewConfig config = ViewConfigTest.getConfig(xml_valid_instance);\n    ViewEntity viewEntity = getViewEntity(config, ambariConfig, getClass().getClassLoader(), \"\");\n    ViewInstanceEntity viewInstanceEntity = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n\n    expect(viewInstanceDAO.merge(viewInstanceEntity)).andReturn(null);\n\n    replay(viewDAO, viewInstanceDAO);\n\n    registry.addDefinition(viewEntity);\n    registry.installViewInstance(viewInstanceEntity);\n\n    Collection<ViewInstanceEntity> viewInstanceDefinitions = registry.getInstanceDefinitions(viewEntity);\n\n    Assert.assertEquals(1, viewInstanceDefinitions.size());\n\n    Assert.assertEquals(viewInstanceEntity, viewInstanceDefinitions.iterator().next());\n\n    verify(viewDAO, viewInstanceDAO);\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateViewInstance() throws Exception {\n\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n\n    ViewRegistry.init(viewDAO, viewInstanceDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n\n    Properties properties = new Properties();\n    properties.put(\"p1\", \"v1\");\n\n    Configuration ambariConfig = new Configuration(properties);\n\n    ViewConfig config = ViewConfigTest.getConfig(xml_valid_instance);\n    ViewEntity viewEntity = getViewEntity(config, ambariConfig, getClass().getClassLoader(), \"\");\n    ViewInstanceEntity viewInstanceEntity = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n    ViewInstanceEntity updateInstance = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n\n    viewInstanceDAO.create(viewInstanceEntity);\n    expect(viewInstanceDAO.merge(viewInstanceEntity)).andReturn(viewInstanceEntity);\n\n    replay(viewDAO, viewInstanceDAO);\n\n    registry.addDefinition(viewEntity);\n    registry.installViewInstance(viewInstanceEntity);\n\n    registry.updateViewInstance(updateInstance);\n\n    Collection<ViewInstanceEntity> viewInstanceDefinitions = registry.getInstanceDefinitions(viewEntity);\n\n    Assert.assertEquals(1, viewInstanceDefinitions.size());\n\n    Assert.assertEquals(viewInstanceEntity, viewInstanceDefinitions.iterator().next());\n\n    verify(viewDAO, viewInstanceDAO);\n  }","id":80108,"modified_method":"@Test\n  public void testUpdateViewInstance() throws Exception {\n\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n\n    ViewRegistry.init(viewDAO, viewInstanceDAO);\n\n    ViewRegistry registry = ViewRegistry.getInstance();\n\n    Properties properties = new Properties();\n    properties.put(\"p1\", \"v1\");\n\n    Configuration ambariConfig = new Configuration(properties);\n\n    ViewConfig config = ViewConfigTest.getConfig(xml_valid_instance);\n    ViewEntity viewEntity = getViewEntity(config, ambariConfig, getClass().getClassLoader(), \"\");\n    ViewInstanceEntity viewInstanceEntity = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n    ViewInstanceEntity updateInstance = getViewInstanceEntity(viewEntity, config.getInstances().get(0));\n\n    expect(viewInstanceDAO.merge(viewInstanceEntity)).andReturn(null);\n    expect(viewInstanceDAO.merge(viewInstanceEntity)).andReturn(viewInstanceEntity);\n\n    replay(viewDAO, viewInstanceDAO);\n\n    registry.addDefinition(viewEntity);\n    registry.installViewInstance(viewInstanceEntity);\n\n    registry.updateViewInstance(updateInstance);\n\n    Collection<ViewInstanceEntity> viewInstanceDefinitions = registry.getInstanceDefinitions(viewEntity);\n\n    Assert.assertEquals(1, viewInstanceDefinitions.size());\n\n    Assert.assertEquals(viewInstanceEntity, viewInstanceDefinitions.iterator().next());\n\n    verify(viewDAO, viewInstanceDAO);\n  }","commit_id":"8b60e7a11d9d51222448c61bbfc1b4d45e579e75","url":"https://github.com/apache/ambari"},{"original_method":"@Override\r\n        public AbstractAction visit(FileSearchFilterNode fsfn) {\r\n            return openChild(fsfn);\r\n        }","id":80109,"modified_method":"@Override\n        public AbstractAction visit(FileTypeNode fsfn) {\n            return openChild(fsfn);\n        }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Resets the back and forward list, and also disable the back and forward\n     * buttons.\n     */\n    private void resetHistoryListAndButtons() {\n        // clear the back and forward list\n        backList.clear();\n        forwardList.clear();\n        backButton.setEnabled(false);\n        forwardButton.setEnabled(false);\n    }","id":80110,"modified_method":"/**\n     * Resets the back and forward list, and also disable the back and forward\n     * buttons.\n     */\n    private void resetHistory() {\n        // clear the back and forward list\n        backList.clear();\n        forwardList.clear();\n        backButton.setEnabled(false);\n        forwardButton.setEnabled(false);\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void backButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        // update the back and forward List\n        String[] currentNodePath = backList.pollLast();\n        String[] newCurrentNodePath = backList.peekLast();\n        forwardList.addLast(currentNodePath);\n\n        // enable / disable the back and forward button\n        if (backList.size() > 1) {\n            backButton.setEnabled(true);\n        } else {\n            backButton.setEnabled(false);\n        }\n        this.forwardButton.setEnabled(true);\n\n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n\n        this.setCursor(null);\n\n    }","id":80111,"modified_method":"private void backButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        \n        // the end is the current place,\n        String[] currentNodePath = backList.pollLast();\n        forwardList.addLast(currentNodePath);\n        forwardButton.setEnabled(true);\n        \n        /* We peek instead of poll because we use its existence\n         * in the list later on so that we do not reset the forward list\n         * after the selection occurs. */\n        String[] newCurrentNodePath = backList.peekLast();\n\n        // enable / disable the back and forward button\n        if (backList.size() > 1) {\n            backButton.setEnabled(true);\n        } else {\n            backButton.setEnabled(false);\n        }\n        \n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n        this.setCursor(null);\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void forwardButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forwardButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n//        try {\n        // update the back and forward List\n        //int newCurrentIndex = forwardList.size() - 1;\n        String[] newCurrentNodePath = forwardList.pollLast();\n        //forwardList.remove(newCurrentIndex);\n        backList.addLast(newCurrentNodePath);\n\n        // enable / disable the back and forward button\n        if (!forwardList.isEmpty()) {\n            forwardButton.setEnabled(true);\n        } else {\n            forwardButton.setEnabled(false);\n        }\n        this.backButton.setEnabled(true);\n\n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n        this.setCursor(null);\n\n    }","id":80112,"modified_method":"private void forwardButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forwardButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\n        String[] newCurrentNodePath = forwardList.pollLast();\n        if (!forwardList.isEmpty()) {\n            forwardButton.setEnabled(true);\n        } else {\n            forwardButton.setEnabled(false);\n        }\n        \n        backList.addLast(newCurrentNodePath);\n        backButton.setEnabled(true);\n \n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n        this.setCursor(null);\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Called only when top component was closed on all workspaces before and\n     * now is opened for the first time on some workspace. The intent is to\n     * provide subclasses information about TopComponent's life cycle across all\n     * existing workspaces. Subclasses will usually perform initializing tasks\n     * here.\n     */\n    @Override\n    public void componentOpened() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (Case.existsCurrentCase()) {\n                Case currentCase = Case.getCurrentCase();\n\n                // close the top component if there's no image in this case\n                if (currentCase.getRootObjectsCount() == 0) {\n                    //this.close();\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n                } else {\n                    // if there's at least one image, load the image and open the top component\n                    List<Object> items = new ArrayList<Object>();\n                    final SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n                    items.add(new DataSources(tskCase));\n                    items.add(new Views(tskCase));\n                    items.add(new Results(tskCase));\n                    contentChildren = new RootContentChildren(items);\n                    Node root = new AbstractNode(contentChildren) {\n                        /**\n                         * to override the right click action in the white blank\n                         * space area on the directory tree window\n                         */\n                        @Override\n                        public Action[] getActions(boolean popup) {\n                            return new Action[]{};\n                        }\n\n                        // Overide the AbstractNode use of DefaultHandle to return\n                        // a handle which can be serialized without a parent\n                        @Override\n                        public Node.Handle getHandle() {\n                            return new Node.Handle() {\n                                @Override\n                                public Node getNode() throws IOException {\n                                    return em.getRootContext();\n                                }\n                            };\n                        }\n                    };\n\n                    root = new DirectoryTreeFilterNode(root, true);\n\n\n                    em.setRootContext(root);\n                    em.getRootContext().setName(currentCase.getName());\n                    em.getRootContext().setDisplayName(currentCase.getName());\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n\n                    // Reset the forward and back lists because we're resetting the root context\n                    resetHistoryListAndButtons();\n\n                    Children childNodes = em.getRootContext().getChildren();\n                    TreeView tree = getTree();\n\n                    Node results = childNodes.findChild(ResultsNode.NAME);\n                    tree.expandNode(results);\n\n                    Children resultsChilds = results.getChildren();\n                    tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n                    tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n\n\n                    Node views = childNodes.findChild(ViewsNode.NAME);\n                    Children viewsChilds = views.getChildren();\n                    for (Node n : viewsChilds.getNodes()) {\n                        tree.expandNode(n);\n                    }\n\n                    tree.collapseNode(views);\n\n                    // if the dataResult is not opened\n                    if (!dataResult.isOpened()) {\n                        dataResult.open(); // open the data result top component as well when the directory tree is opened\n                    }\n\n\n                    // select the first image node, if there is one\n                    // (this has to happen after dataResult is opened, because the event\n                    // of changing the selected node fires a handler that tries to make\n                    // dataResult active)\n                    if (childNodes.getNodesCount() > 0) {\n                        try {\n                            em.setSelectedNodes(new Node[]{childNodes.getNodeAt(0)});\n                        } catch (Exception ex) {\n                            logger.log(Level.SEVERE, \"Error setting default selected node.\", ex);\n                        }\n                    }\n\n                }\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","id":80113,"modified_method":"/**\n     * Called only when top component was closed on all workspaces before and\n     * now is opened for the first time on some workspace. The intent is to\n     * provide subclasses information about TopComponent's life cycle across all\n     * existing workspaces. Subclasses will usually perform initializing tasks\n     * here.\n     */\n    @Override\n    public void componentOpened() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (Case.existsCurrentCase()) {\n                Case currentCase = Case.getCurrentCase();\n\n                // close the top component if there's no image in this case\n                if (currentCase.getRootObjectsCount() == 0) {\n                    //this.close();\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n                } else {\n                    // if there's at least one image, load the image and open the top component\n                    List<Object> items = new ArrayList<>();\n                    final SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n                    items.add(new DataSources(tskCase));\n                    items.add(new Views(tskCase));\n                    items.add(new Results(tskCase));\n                    contentChildren = new RootContentChildren(items);\n                    Node root = new AbstractNode(contentChildren) {\n                        /**\n                         * to override the right click action in the white blank\n                         * space area on the directory tree window\n                         */\n                        @Override\n                        public Action[] getActions(boolean popup) {\n                            return new Action[]{};\n                        }\n\n                        // Overide the AbstractNode use of DefaultHandle to return\n                        // a handle which can be serialized without a parent\n                        @Override\n                        public Node.Handle getHandle() {\n                            return new Node.Handle() {\n                                @Override\n                                public Node getNode() throws IOException {\n                                    return em.getRootContext();\n                                }\n                            };\n                        }\n                    };\n\n                    root = new DirectoryTreeFilterNode(root, true);\n\n\n                    em.setRootContext(root);\n                    em.getRootContext().setName(currentCase.getName());\n                    em.getRootContext().setDisplayName(currentCase.getName());\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n\n                    // Reset the forward and back lists because we're resetting the root context\n                    resetHistory();\n\n                    Children childNodes = em.getRootContext().getChildren();\n                    TreeView tree = getTree();\n\n                    Node results = childNodes.findChild(ResultsNode.NAME);\n                    tree.expandNode(results);\n\n                    Children resultsChilds = results.getChildren();\n                    tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n                    tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n\n\n                    Node views = childNodes.findChild(ViewsNode.NAME);\n                    Children viewsChilds = views.getChildren();\n                    for (Node n : viewsChilds.getNodes()) {\n                        tree.expandNode(n);\n                    }\n\n                    tree.collapseNode(views);\n\n                    // if the dataResult is not opened\n                    if (!dataResult.isOpened()) {\n                        dataResult.open(); // open the data result top component as well when the directory tree is opened\n                    }\n\n\n                    // select the first image node, if there is one\n                    // (this has to happen after dataResult is opened, because the event\n                    // of changing the selected node fires a handler that tries to make\n                    // dataResult active)\n                    if (childNodes.getNodesCount() > 0) {\n                        try {\n                            em.setSelectedNodes(new Node[]{childNodes.getNodeAt(0)});\n                        } catch (Exception ex) {\n                            logger.log(Level.SEVERE, \"Error setting default selected node.\", ex);\n                        }\n                    }\n\n                }\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Event handler to run when selection changed\n     *\n     * TODO this needs to be revised\n     *\n     * @param oldNodes\n     * @param newNodes\n     */\n    private void respondSelection(final Node[] oldNodes, final Node[] newNodes) {\n        if (!Case.isCaseOpen()) {\n            //handle in-between condition when case is being closed\n            //and legacy selection events are pumped\n            return;\n        }\n\n\n        // Some lock that prevents certain Node operations is set during the\n        // ExplorerManager selection-change, so we must handle changes after the\n        // selection-change event is processed.\n        //TODO find a different way to refresh data result viewer, scheduling this\n        //to EDT breaks loading of nodes in the background\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // change the cursor to \"waiting cursor\" for this operation\n                DirectoryTreeTopComponent.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n\n                    // make sure dataResult is open, redundant?\n                    //dataResult.open();\n\n                    Node treeNode = DirectoryTreeTopComponent.this.getSelectedNode();\n                    if (treeNode != null) {\n                        OriginalNode origin = treeNode.getLookup().lookup(OriginalNode.class);\n                        if (origin == null) {\n                            return;\n                        }\n                        Node originNode = origin.getNode();\n                        \n                        //set node, wrap in filter node first to filter out children\n                        Node drfn = new DataResultFilterNode(originNode, DirectoryTreeTopComponent.this.em);\n                        dataResult.setNode(new TableFilterNode(drfn, true));\n\n                        String displayName = \"\";\n                        Content content = originNode.getLookup().lookup(Content.class);\n                        if (content != null) {\n                            try {\n                                displayName = content.getUniquePath();\n                            } catch (TskCoreException ex) {\n                                logger.log(Level.SEVERE, \"Exception while calling Content.getUniquePath() for node: \" + originNode);\n                            }    \n                        } \n                        else if (originNode.getLookup().lookup(String.class) != null) {\n                            displayName = originNode.getLookup().lookup(String.class);\n                        }\n                        dataResult.setPath(displayName);\n                    }\n\n                    // set the directory listing to be active\n                    if (oldNodes != null && newNodes != null\n                            && (oldNodes.length == newNodes.length)) {\n                        boolean sameNodes = true;\n                        for (int i = 0; i < oldNodes.length; i++) {\n                            sameNodes = sameNodes && oldNodes[i].getName().equals(newNodes[i].getName());\n                        }\n                        if (!sameNodes) {\n                            dataResult.requestActive();\n                        }\n                    }\n                } finally {\n                    setCursor(null);\n                }\n            }\n        });\n\n        // update the back and forward list\n        Node[] selectedNode = em.getSelectedNodes();\n        if (selectedNode.length > 0) {\n            Node selectedContext = selectedNode[0];\n\n            final String[] selectedPath = NodeOp.createPath(selectedContext, em.getRootContext());\n            String[] currentLast = backList.peekLast();\n            String lastNodeName = null;\n            if (currentLast != null) {\n                lastNodeName = currentLast[currentLast.length - 1];\n            }\n            String selectedNodeName = selectedContext.getName();\n            if (currentLast == null || !selectedNodeName.equals(lastNodeName)) {\n                //add to the list if the last if not the same as current\n\n                backList.addLast(selectedPath); // add the node to the \"backList\"\n                if (backList.size() > 1) {\n                    backButton.setEnabled(true);\n                } else {\n                    backButton.setEnabled(false);\n                }\n\n                forwardList.clear(); // clear the \"forwardList\"\n                forwardButton.setEnabled(false); // disable the forward Button\n            }\n        }\n    }","id":80114,"modified_method":"/**\n     * Event handler to run when selection changed\n     *\n     * TODO this needs to be revised\n     *\n     * @param oldNodes\n     * @param newNodes\n     */\n    private void respondSelection(final Node[] oldNodes, final Node[] newNodes) {\n        if (!Case.isCaseOpen()) {\n            //handle in-between condition when case is being closed\n            //and legacy selection events are pumped\n            return;\n        }\n\n\n        // Some lock that prevents certain Node operations is set during the\n        // ExplorerManager selection-change, so we must handle changes after the\n        // selection-change event is processed.\n        //TODO find a different way to refresh data result viewer, scheduling this\n        //to EDT breaks loading of nodes in the background\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // change the cursor to \"waiting cursor\" for this operation\n                DirectoryTreeTopComponent.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n\n                    // make sure dataResult is open, redundant?\n                    //dataResult.open();\n\n                    Node treeNode = DirectoryTreeTopComponent.this.getSelectedNode();\n                    if (treeNode != null) {\n                        OriginalNode origin = treeNode.getLookup().lookup(OriginalNode.class);\n                        if (origin == null) {\n                            return;\n                        }\n                        Node originNode = origin.getNode();\n                        \n                        //set node, wrap in filter node first to filter out children\n                        Node drfn = new DataResultFilterNode(originNode, DirectoryTreeTopComponent.this.em);\n                        dataResult.setNode(new TableFilterNode(drfn, true));\n\n                        String displayName = \"\";\n                        Content content = originNode.getLookup().lookup(Content.class);\n                        if (content != null) {\n                            try {\n                                displayName = content.getUniquePath();\n                            } catch (TskCoreException ex) {\n                                logger.log(Level.SEVERE, \"Exception while calling Content.getUniquePath() for node: \" + originNode);\n                            }    \n                        } \n                        else if (originNode.getLookup().lookup(String.class) != null) {\n                            displayName = originNode.getLookup().lookup(String.class);\n                        }\n                        dataResult.setPath(displayName);\n                    }\n\n                    // set the directory listing to be active\n                    if (oldNodes != null && newNodes != null\n                            && (oldNodes.length == newNodes.length)) {\n                        boolean sameNodes = true;\n                        for (int i = 0; i < oldNodes.length; i++) {\n                            sameNodes = sameNodes && oldNodes[i].getName().equals(newNodes[i].getName());\n                        }\n                        if (!sameNodes) {\n                            dataResult.requestActive();\n                        }\n                    }\n                } finally {\n                    setCursor(null);\n                }\n            }\n        });\n\n        // update the back and forward list\n        updateHistory(em.getSelectedNodes());\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * The \"listener\" that listens to any changes made in the Case.java class.\n     * It will do something based on the changes in the Case.java class.\n     *\n     * @param evt the property change event\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n        String changed = evt.getPropertyName();\n        Object oldValue = evt.getOldValue();\n        Object newValue = evt.getNewValue();\n\n        // change in the case name\n        if (changed.equals(Case.CASE_NAME)) {\n            // set the main title of the window\n            String oldCaseName = oldValue.toString();\n            String newCaseName = newValue.toString();\n\n\n            // update the case name\n            if ((!oldCaseName.equals(\"\")) && (!newCaseName.equals(\"\"))) {\n                // change the root name and display name\n                em.getRootContext().setName(newCaseName);\n                em.getRootContext().setDisplayName(newCaseName);\n            }\n        } // changed current case\n        else if (changed.equals(Case.CASE_CURRENT_CASE)) {\n\n            // case opened\n            if (newValue != null) {\n                resetHistoryListAndButtons();\n            }\n        } // if the image is added to the case\n        else if (changed.equals(Case.CASE_ADD_DATA_SOURCE)) {\n            componentOpened();\n//            Image img = (Image)newValue;\n//\n//            int[] imageIDs = Case.getCurrentCase().getImageIDs();\n//\n//            // add the first image\n//            if(imageIDs.length == 1){\n//                \n//            }\n//            else{\n//                // add the additional images\n//                ImageNode newNode = new ImageNode(img);\n//                ((ImageChildren)getOriginalRootContent().getChildren()).addNode(newNode);\n//\n//                // expand the new added node\n//                int count = em.getRootContext().getChildren().getNodesCount();\n//                em.setExploredContext(em.getRootContext().getChildren().getNodeAt(count - 1));\n//            }\n        } // not supporting deleting images for now\n        //        // if the image is removed from the case\n        //        if(changed.equals(Case.CASE_DEL_IMAGE)){\n        //            if(Case.getCurrentCase().getImageIDs().length > 0){\n        //                // just remove the given image from the directory tree\n        //                Image img = (Image)newValue;\n        //                int ID = Integer.parseInt(oldValue.toString());\n        //                ImageNode tempNode = new ImageNode(img);\n        //                ((ImageChildren)getOriginalRootContent().getChildren()).removeNode(tempNode);\n        //            }\n        //        }\n        // change in node selection\n        else if (changed.equals(ExplorerManager.PROP_SELECTED_NODES)) {\n            respondSelection((Node[]) oldValue, (Node[]) newValue);\n        } else if (changed.equals(IngestModuleEvent.DATA.toString())) {\n            final ModuleDataEvent event = (ModuleDataEvent) oldValue;\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshTree(event.getArtifactType());\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.COMPLETED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                    refreshTree();\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.CONTENT_CHANGED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                }\n            });\n        }\n    }","id":80115,"modified_method":"/**\n     * The \"listener\" that listens to any changes made in the Case.java class.\n     * It will do something based on the changes in the Case.java class.\n     *\n     * @param evt the property change event\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n        String changed = evt.getPropertyName();\n        Object oldValue = evt.getOldValue();\n        Object newValue = evt.getNewValue();\n\n        // change in the case name\n        if (changed.equals(Case.CASE_NAME)) {\n            // set the main title of the window\n            String oldCaseName = oldValue.toString();\n            String newCaseName = newValue.toString();\n\n\n            // update the case name\n            if ((!oldCaseName.equals(\"\")) && (!newCaseName.equals(\"\"))) {\n                // change the root name and display name\n                em.getRootContext().setName(newCaseName);\n                em.getRootContext().setDisplayName(newCaseName);\n            }\n        } // changed current case\n        else if (changed.equals(Case.CASE_CURRENT_CASE)) {\n\n            // case opened\n            if (newValue != null) {\n                resetHistory();\n            }\n        } // if the image is added to the case\n        else if (changed.equals(Case.CASE_ADD_DATA_SOURCE)) {\n            componentOpened();\n//            Image img = (Image)newValue;\n//\n//            int[] imageIDs = Case.getCurrentCase().getImageIDs();\n//\n//            // add the first image\n//            if(imageIDs.length == 1){\n//                \n//            }\n//            else{\n//                // add the additional images\n//                ImageNode newNode = new ImageNode(img);\n//                ((ImageChildren)getOriginalRootContent().getChildren()).addNode(newNode);\n//\n//                // expand the new added node\n//                int count = em.getRootContext().getChildren().getNodesCount();\n//                em.setExploredContext(em.getRootContext().getChildren().getNodeAt(count - 1));\n//            }\n        } // not supporting deleting images for now\n        //        // if the image is removed from the case\n        //        if(changed.equals(Case.CASE_DEL_IMAGE)){\n        //            if(Case.getCurrentCase().getImageIDs().length > 0){\n        //                // just remove the given image from the directory tree\n        //                Image img = (Image)newValue;\n        //                int ID = Integer.parseInt(oldValue.toString());\n        //                ImageNode tempNode = new ImageNode(img);\n        //                ((ImageChildren)getOriginalRootContent().getChildren()).removeNode(tempNode);\n        //            }\n        //        }\n        // change in node selection\n        else if (changed.equals(ExplorerManager.PROP_SELECTED_NODES)) {\n            respondSelection((Node[]) oldValue, (Node[]) newValue);\n        } else if (changed.equals(IngestModuleEvent.DATA.toString())) {\n            final ModuleDataEvent event = (ModuleDataEvent) oldValue;\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshTree(event.getArtifactType());\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.COMPLETED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                    refreshTree();\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.CONTENT_CHANGED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                }\n            });\n        }\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Set selected node using the previously saved selection path to the\n     * selected node\n     *\n     * @param path node path with node names\n     * @param rootNodeName name of the root node to match or null if any\n     */\n    private void setSelectedNode(final String[] path, final String rootNodeName) {\n        if (path == null) {\n            return;\n        }\n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n\n                if (path.length > 0 && (rootNodeName == null || path[0].equals(rootNodeName))) {\n                    try {\n                        final TreeView tree = getTree();\n                        Node newSelection = NodeOp.findPath(em.getRootContext(), path);\n                        //resetHistoryListAndButtons();\n                        if (newSelection != null) {\n                            if (rootNodeName != null) {\n                                //called from tree auto refresh context\n                                //remove last from backlist, because auto select will result in duplication\n                                backList.pollLast();\n                            }\n                            //select\n                            //tree.expandNode(newSelection);\n                            em.setExploredContextAndSelection(newSelection, new Node[]{newSelection});\n                        }\n                        // We need to set the selection, which will refresh dataresult and get rid of the oob exception\n                    } catch (NodeNotFoundException ex) {\n                        logger.log(Level.WARNING, \"Node not found\", ex);\n                    } catch (PropertyVetoException ex) {\n                        logger.log(Level.WARNING, \"Property Veto\", ex);\n                    }\n                }\n            }\n        });\n    }","id":80116,"modified_method":"/**\n     * Set selected node using the previously saved selection path to the\n     * selected node\n     *\n     * @param path node path with node names\n     * @param rootNodeName name of the root node to match or null if any\n     */\n    private void setSelectedNode(final String[] path, final String rootNodeName) {\n        if (path == null) {\n            return;\n        }\n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n\n                if (path.length > 0 && (rootNodeName == null || path[0].equals(rootNodeName))) {\n                    try {\n                        Node newSelection = NodeOp.findPath(em.getRootContext(), path);\n                        \n                        if (newSelection != null) {\n                            if (rootNodeName != null) {\n                                //called from tree auto refresh context\n                                //remove last from backlist, because auto select will result in duplication\n                                backList.pollLast();\n                            }\n                            em.setExploredContextAndSelection(newSelection, new Node[]{newSelection});\n                        }\n                        \n                        // We need to set the selection, which will refresh dataresult and get rid of the oob exception\n                    } catch (NodeNotFoundException ex) {\n                        logger.log(Level.WARNING, \"Node not found\", ex);\n                    } catch (PropertyVetoException ex) {\n                        logger.log(Level.WARNING, \"Property Veto\", ex);\n                    }\n                }\n            }\n        });\n    }","commit_id":"69ea984602ecfce93f7cb1d1fa5e87f20206ef99","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@BaseDialog.Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOk() {\n    if (this.myTree.getSelectedNodes(SNodeTreeNode.class, new Tree.NodeFilter() {\n      public boolean accept(Object p0) {\n        return true;\n      }\n    }).length != 1) {\n      JOptionPane.showMessageDialog(this, \"Error!\");\n    }\n  }","id":80117,"modified_method":"@BaseDialog.Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOk() {\n    SNodeTreeNode[] selectedNode = this.myTree.getSelectedNodes(SNodeTreeNode.class, new Tree.NodeFilter() {\n      public boolean accept(Object p0) {\n        return true;\n      }\n    });\n    if (selectedNode.length != 1) {\n      JOptionPane.showMessageDialog(this, \"Mapping Configuration node is not selected!\");\n    } else {\n      this.myResult = (SNode) selectedNode[0].getSNode();\n      this.myTree.dispose();\n      this.dispose();\n    }\n  }","commit_id":"7953b4769137355746140167adf974023b53a823","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MappingDialog(Language language, IOperationContext operationContext) {\n    super(operationContext.getMainFrame(), \"Choose Mapping Configuration\");\n    this.myLanguage = language;\n    this.myContext = operationContext;\n    this.myMainComponent.add(this.myTree, BorderLayout.CENTER);\n    this.myTree.setBorder(BorderFactory.createLineBorder(Color.BLACK));\n    this.myTree.rebuildNow();\n  }","id":80118,"modified_method":"public MappingDialog(Language language, IOperationContext operationContext) {\n    super(operationContext.getMainFrame(), \"Choose Mapping Configuration\");\n    this.myLanguage = language;\n    this.myContext = operationContext;\n    JScrollPane scrollPane = new JScrollPane(this.myTree);\n    this.myMainComponent.add(scrollPane, BorderLayout.CENTER);\n    this.myTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n    this.myTree.rebuildNow();\n    this.myTree.expandAll();\n  }","commit_id":"7953b4769137355746140167adf974023b53a823","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\r\n        public AbstractAction visit(FileSearchFilterNode fsfn) {\r\n            return openChild(fsfn);\r\n        }","id":80119,"modified_method":"@Override\n        public AbstractAction visit(FileTypeNode fsfn) {\n            return openChild(fsfn);\n        }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Event handler to run when selection changed\n     *\n     * TODO this needs to be revised\n     *\n     * @param oldNodes\n     * @param newNodes\n     */\n    private void respondSelection(final Node[] oldNodes, final Node[] newNodes) {\n        if (!Case.isCaseOpen()) {\n            //handle in-between condition when case is being closed\n            //and legacy selection events are pumped\n            return;\n        }\n\n\n        // Some lock that prevents certain Node operations is set during the\n        // ExplorerManager selection-change, so we must handle changes after the\n        // selection-change event is processed.\n        //TODO find a different way to refresh data result viewer, scheduling this\n        //to EDT breaks loading of nodes in the background\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // change the cursor to \"waiting cursor\" for this operation\n                DirectoryTreeTopComponent.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n\n                    // make sure dataResult is open, redundant?\n                    //dataResult.open();\n\n                    Node treeNode = DirectoryTreeTopComponent.this.getSelectedNode();\n                    if (treeNode != null) {\n                        OriginalNode origin = treeNode.getLookup().lookup(OriginalNode.class);\n                        if (origin == null) {\n                            return;\n                        }\n                        Node originNode = origin.getNode();\n                        \n                        //set node, wrap in filter node first to filter out children\n                        Node drfn = new DataResultFilterNode(originNode, DirectoryTreeTopComponent.this.em);\n                        dataResult.setNode(new TableFilterNode(drfn, true));\n\n                        String displayName = \"\";\n                        Content content = originNode.getLookup().lookup(Content.class);\n                        if (content != null) {\n                            try {\n                                displayName = content.getUniquePath();\n                            } catch (TskCoreException ex) {\n                                logger.log(Level.SEVERE, \"Exception while calling Content.getUniquePath() for node: \" + originNode);\n                            }    \n                        } \n                        else if (originNode.getLookup().lookup(String.class) != null) {\n                            displayName = originNode.getLookup().lookup(String.class);\n                        }\n                        dataResult.setPath(displayName);\n                    }\n\n                    // set the directory listing to be active\n                    if (oldNodes != null && newNodes != null\n                            && (oldNodes.length == newNodes.length)) {\n                        boolean sameNodes = true;\n                        for (int i = 0; i < oldNodes.length; i++) {\n                            sameNodes = sameNodes && oldNodes[i].getName().equals(newNodes[i].getName());\n                        }\n                        if (!sameNodes) {\n                            dataResult.requestActive();\n                        }\n                    }\n                } finally {\n                    setCursor(null);\n                }\n            }\n        });\n\n        // update the back and forward list\n        Node[] selectedNode = em.getSelectedNodes();\n        if (selectedNode.length > 0) {\n            Node selectedContext = selectedNode[0];\n\n            final String[] selectedPath = NodeOp.createPath(selectedContext, em.getRootContext());\n            String[] currentLast = backList.peekLast();\n            String lastNodeName = null;\n            if (currentLast != null) {\n                lastNodeName = currentLast[currentLast.length - 1];\n            }\n            String selectedNodeName = selectedContext.getName();\n            if (currentLast == null || !selectedNodeName.equals(lastNodeName)) {\n                //add to the list if the last if not the same as current\n\n                backList.addLast(selectedPath); // add the node to the \"backList\"\n                if (backList.size() > 1) {\n                    backButton.setEnabled(true);\n                } else {\n                    backButton.setEnabled(false);\n                }\n\n                forwardList.clear(); // clear the \"forwardList\"\n                forwardButton.setEnabled(false); // disable the forward Button\n            }\n        }\n    }","id":80120,"modified_method":"/**\n     * Event handler to run when selection changed\n     *\n     * TODO this needs to be revised\n     *\n     * @param oldNodes\n     * @param newNodes\n     */\n    private void respondSelection(final Node[] oldNodes, final Node[] newNodes) {\n        if (!Case.isCaseOpen()) {\n            //handle in-between condition when case is being closed\n            //and legacy selection events are pumped\n            return;\n        }\n\n\n        // Some lock that prevents certain Node operations is set during the\n        // ExplorerManager selection-change, so we must handle changes after the\n        // selection-change event is processed.\n        //TODO find a different way to refresh data result viewer, scheduling this\n        //to EDT breaks loading of nodes in the background\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // change the cursor to \"waiting cursor\" for this operation\n                DirectoryTreeTopComponent.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n\n                    // make sure dataResult is open, redundant?\n                    //dataResult.open();\n\n                    Node treeNode = DirectoryTreeTopComponent.this.getSelectedNode();\n                    if (treeNode != null) {\n                        OriginalNode origin = treeNode.getLookup().lookup(OriginalNode.class);\n                        if (origin == null) {\n                            return;\n                        }\n                        Node originNode = origin.getNode();\n                        \n                        //set node, wrap in filter node first to filter out children\n                        Node drfn = new DataResultFilterNode(originNode, DirectoryTreeTopComponent.this.em);\n                        dataResult.setNode(new TableFilterNode(drfn, true));\n\n                        String displayName = \"\";\n                        Content content = originNode.getLookup().lookup(Content.class);\n                        if (content != null) {\n                            try {\n                                displayName = content.getUniquePath();\n                            } catch (TskCoreException ex) {\n                                logger.log(Level.SEVERE, \"Exception while calling Content.getUniquePath() for node: \" + originNode);\n                            }    \n                        } \n                        else if (originNode.getLookup().lookup(String.class) != null) {\n                            displayName = originNode.getLookup().lookup(String.class);\n                        }\n                        dataResult.setPath(displayName);\n                    }\n\n                    // set the directory listing to be active\n                    if (oldNodes != null && newNodes != null\n                            && (oldNodes.length == newNodes.length)) {\n                        boolean sameNodes = true;\n                        for (int i = 0; i < oldNodes.length; i++) {\n                            sameNodes = sameNodes && oldNodes[i].getName().equals(newNodes[i].getName());\n                        }\n                        if (!sameNodes) {\n                            dataResult.requestActive();\n                        }\n                    }\n                } finally {\n                    setCursor(null);\n                }\n            }\n        });\n\n        // update the back and forward list\n        updateHistory(em.getSelectedNodes());\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * The \"listener\" that listens to any changes made in the Case.java class.\n     * It will do something based on the changes in the Case.java class.\n     *\n     * @param evt the property change event\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n        String changed = evt.getPropertyName();\n        Object oldValue = evt.getOldValue();\n        Object newValue = evt.getNewValue();\n\n        // change in the case name\n        if (changed.equals(Case.CASE_NAME)) {\n            // set the main title of the window\n            String oldCaseName = oldValue.toString();\n            String newCaseName = newValue.toString();\n\n\n            // update the case name\n            if ((!oldCaseName.equals(\"\")) && (!newCaseName.equals(\"\"))) {\n                // change the root name and display name\n                em.getRootContext().setName(newCaseName);\n                em.getRootContext().setDisplayName(newCaseName);\n            }\n        } // changed current case\n        else if (changed.equals(Case.CASE_CURRENT_CASE)) {\n\n            // case opened\n            if (newValue != null) {\n                resetHistoryListAndButtons();\n            }\n        } // if the image is added to the case\n        else if (changed.equals(Case.CASE_ADD_DATA_SOURCE)) {\n            componentOpened();\n//            Image img = (Image)newValue;\n//\n//            int[] imageIDs = Case.getCurrentCase().getImageIDs();\n//\n//            // add the first image\n//            if(imageIDs.length == 1){\n//                \n//            }\n//            else{\n//                // add the additional images\n//                ImageNode newNode = new ImageNode(img);\n//                ((ImageChildren)getOriginalRootContent().getChildren()).addNode(newNode);\n//\n//                // expand the new added node\n//                int count = em.getRootContext().getChildren().getNodesCount();\n//                em.setExploredContext(em.getRootContext().getChildren().getNodeAt(count - 1));\n//            }\n        } // not supporting deleting images for now\n        //        // if the image is removed from the case\n        //        if(changed.equals(Case.CASE_DEL_IMAGE)){\n        //            if(Case.getCurrentCase().getImageIDs().length > 0){\n        //                // just remove the given image from the directory tree\n        //                Image img = (Image)newValue;\n        //                int ID = Integer.parseInt(oldValue.toString());\n        //                ImageNode tempNode = new ImageNode(img);\n        //                ((ImageChildren)getOriginalRootContent().getChildren()).removeNode(tempNode);\n        //            }\n        //        }\n        // change in node selection\n        else if (changed.equals(ExplorerManager.PROP_SELECTED_NODES)) {\n            respondSelection((Node[]) oldValue, (Node[]) newValue);\n        } else if (changed.equals(IngestModuleEvent.DATA.toString())) {\n            final ModuleDataEvent event = (ModuleDataEvent) oldValue;\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshTree(event.getArtifactType());\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.COMPLETED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                    refreshTree();\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.CONTENT_CHANGED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                }\n            });\n        }\n    }","id":80121,"modified_method":"/**\n     * The \"listener\" that listens to any changes made in the Case.java class.\n     * It will do something based on the changes in the Case.java class.\n     *\n     * @param evt the property change event\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n        String changed = evt.getPropertyName();\n        Object oldValue = evt.getOldValue();\n        Object newValue = evt.getNewValue();\n\n        // change in the case name\n        if (changed.equals(Case.CASE_NAME)) {\n            // set the main title of the window\n            String oldCaseName = oldValue.toString();\n            String newCaseName = newValue.toString();\n\n\n            // update the case name\n            if ((!oldCaseName.equals(\"\")) && (!newCaseName.equals(\"\"))) {\n                // change the root name and display name\n                em.getRootContext().setName(newCaseName);\n                em.getRootContext().setDisplayName(newCaseName);\n            }\n        } // changed current case\n        else if (changed.equals(Case.CASE_CURRENT_CASE)) {\n\n            // case opened\n            if (newValue != null) {\n                resetHistory();\n            }\n        } // if the image is added to the case\n        else if (changed.equals(Case.CASE_ADD_DATA_SOURCE)) {\n            componentOpened();\n//            Image img = (Image)newValue;\n//\n//            int[] imageIDs = Case.getCurrentCase().getImageIDs();\n//\n//            // add the first image\n//            if(imageIDs.length == 1){\n//                \n//            }\n//            else{\n//                // add the additional images\n//                ImageNode newNode = new ImageNode(img);\n//                ((ImageChildren)getOriginalRootContent().getChildren()).addNode(newNode);\n//\n//                // expand the new added node\n//                int count = em.getRootContext().getChildren().getNodesCount();\n//                em.setExploredContext(em.getRootContext().getChildren().getNodeAt(count - 1));\n//            }\n        } // not supporting deleting images for now\n        //        // if the image is removed from the case\n        //        if(changed.equals(Case.CASE_DEL_IMAGE)){\n        //            if(Case.getCurrentCase().getImageIDs().length > 0){\n        //                // just remove the given image from the directory tree\n        //                Image img = (Image)newValue;\n        //                int ID = Integer.parseInt(oldValue.toString());\n        //                ImageNode tempNode = new ImageNode(img);\n        //                ((ImageChildren)getOriginalRootContent().getChildren()).removeNode(tempNode);\n        //            }\n        //        }\n        // change in node selection\n        else if (changed.equals(ExplorerManager.PROP_SELECTED_NODES)) {\n            respondSelection((Node[]) oldValue, (Node[]) newValue);\n        } else if (changed.equals(IngestModuleEvent.DATA.toString())) {\n            final ModuleDataEvent event = (ModuleDataEvent) oldValue;\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshTree(event.getArtifactType());\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.COMPLETED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                    refreshTree();\n                }\n            });\n        } else if (changed.equals(IngestModuleEvent.CONTENT_CHANGED.toString())) {\n            SwingUtilities.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    refreshContentTree();\n                }\n            });\n        }\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Resets the back and forward list, and also disable the back and forward\n     * buttons.\n     */\n    private void resetHistoryListAndButtons() {\n        // clear the back and forward list\n        backList.clear();\n        forwardList.clear();\n        backButton.setEnabled(false);\n        forwardButton.setEnabled(false);\n    }","id":80122,"modified_method":"/**\n     * Resets the back and forward list, and also disable the back and forward\n     * buttons.\n     */\n    private void resetHistory() {\n        // clear the back and forward list\n        backList.clear();\n        forwardList.clear();\n        backButton.setEnabled(false);\n        forwardButton.setEnabled(false);\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void forwardButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forwardButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n//        try {\n        // update the back and forward List\n        //int newCurrentIndex = forwardList.size() - 1;\n        String[] newCurrentNodePath = forwardList.pollLast();\n        //forwardList.remove(newCurrentIndex);\n        backList.addLast(newCurrentNodePath);\n\n        // enable / disable the back and forward button\n        if (!forwardList.isEmpty()) {\n            forwardButton.setEnabled(true);\n        } else {\n            forwardButton.setEnabled(false);\n        }\n        this.backButton.setEnabled(true);\n\n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n        this.setCursor(null);\n\n    }","id":80123,"modified_method":"private void forwardButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forwardButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\n        String[] newCurrentNodePath = forwardList.pollLast();\n        if (!forwardList.isEmpty()) {\n            forwardButton.setEnabled(true);\n        } else {\n            forwardButton.setEnabled(false);\n        }\n        \n        backList.addLast(newCurrentNodePath);\n        backButton.setEnabled(true);\n \n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n        this.setCursor(null);\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void backButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        // update the back and forward List\n        String[] currentNodePath = backList.pollLast();\n        String[] newCurrentNodePath = backList.peekLast();\n        forwardList.addLast(currentNodePath);\n\n        // enable / disable the back and forward button\n        if (backList.size() > 1) {\n            backButton.setEnabled(true);\n        } else {\n            backButton.setEnabled(false);\n        }\n        this.forwardButton.setEnabled(true);\n\n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n\n        this.setCursor(null);\n\n    }","id":80124,"modified_method":"private void backButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backButtonActionPerformed\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        \n        // the end is the current place,\n        String[] currentNodePath = backList.pollLast();\n        forwardList.addLast(currentNodePath);\n        forwardButton.setEnabled(true);\n        \n        /* We peek instead of poll because we use its existence\n         * in the list later on so that we do not reset the forward list\n         * after the selection occurs. */\n        String[] newCurrentNodePath = backList.peekLast();\n\n        // enable / disable the back and forward button\n        if (backList.size() > 1) {\n            backButton.setEnabled(true);\n        } else {\n            backButton.setEnabled(false);\n        }\n        \n        // update the selection on directory tree\n        setSelectedNode(newCurrentNodePath, null);\n\n        this.setCursor(null);\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Set selected node using the previously saved selection path to the\n     * selected node\n     *\n     * @param path node path with node names\n     * @param rootNodeName name of the root node to match or null if any\n     */\n    private void setSelectedNode(final String[] path, final String rootNodeName) {\n        if (path == null) {\n            return;\n        }\n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n\n                if (path.length > 0 && (rootNodeName == null || path[0].equals(rootNodeName))) {\n                    try {\n                        final TreeView tree = getTree();\n                        Node newSelection = NodeOp.findPath(em.getRootContext(), path);\n                        //resetHistoryListAndButtons();\n                        if (newSelection != null) {\n                            if (rootNodeName != null) {\n                                //called from tree auto refresh context\n                                //remove last from backlist, because auto select will result in duplication\n                                backList.pollLast();\n                            }\n                            //select\n                            //tree.expandNode(newSelection);\n                            em.setExploredContextAndSelection(newSelection, new Node[]{newSelection});\n                        }\n                        // We need to set the selection, which will refresh dataresult and get rid of the oob exception\n                    } catch (NodeNotFoundException ex) {\n                        logger.log(Level.WARNING, \"Node not found\", ex);\n                    } catch (PropertyVetoException ex) {\n                        logger.log(Level.WARNING, \"Property Veto\", ex);\n                    }\n                }\n            }\n        });\n    }","id":80125,"modified_method":"/**\n     * Set selected node using the previously saved selection path to the\n     * selected node\n     *\n     * @param path node path with node names\n     * @param rootNodeName name of the root node to match or null if any\n     */\n    private void setSelectedNode(final String[] path, final String rootNodeName) {\n        if (path == null) {\n            return;\n        }\n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n\n                if (path.length > 0 && (rootNodeName == null || path[0].equals(rootNodeName))) {\n                    try {\n                        Node newSelection = NodeOp.findPath(em.getRootContext(), path);\n                        \n                        if (newSelection != null) {\n                            if (rootNodeName != null) {\n                                //called from tree auto refresh context\n                                //remove last from backlist, because auto select will result in duplication\n                                backList.pollLast();\n                            }\n                            em.setExploredContextAndSelection(newSelection, new Node[]{newSelection});\n                        }\n                        \n                        // We need to set the selection, which will refresh dataresult and get rid of the oob exception\n                    } catch (NodeNotFoundException ex) {\n                        logger.log(Level.WARNING, \"Node not found\", ex);\n                    } catch (PropertyVetoException ex) {\n                        logger.log(Level.WARNING, \"Property Veto\", ex);\n                    }\n                }\n            }\n        });\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Called only when top component was closed on all workspaces before and\n     * now is opened for the first time on some workspace. The intent is to\n     * provide subclasses information about TopComponent's life cycle across all\n     * existing workspaces. Subclasses will usually perform initializing tasks\n     * here.\n     */\n    @Override\n    public void componentOpened() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (Case.existsCurrentCase()) {\n                Case currentCase = Case.getCurrentCase();\n\n                // close the top component if there's no image in this case\n                if (currentCase.getRootObjectsCount() == 0) {\n                    //this.close();\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n                } else {\n                    // if there's at least one image, load the image and open the top component\n                    List<Object> items = new ArrayList<Object>();\n                    final SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n                    items.add(new DataSources(tskCase));\n                    items.add(new Views(tskCase));\n                    items.add(new Results(tskCase));\n                    contentChildren = new RootContentChildren(items);\n                    Node root = new AbstractNode(contentChildren) {\n                        /**\n                         * to override the right click action in the white blank\n                         * space area on the directory tree window\n                         */\n                        @Override\n                        public Action[] getActions(boolean popup) {\n                            return new Action[]{};\n                        }\n\n                        // Overide the AbstractNode use of DefaultHandle to return\n                        // a handle which can be serialized without a parent\n                        @Override\n                        public Node.Handle getHandle() {\n                            return new Node.Handle() {\n                                @Override\n                                public Node getNode() throws IOException {\n                                    return em.getRootContext();\n                                }\n                            };\n                        }\n                    };\n\n                    root = new DirectoryTreeFilterNode(root, true);\n\n\n                    em.setRootContext(root);\n                    em.getRootContext().setName(currentCase.getName());\n                    em.getRootContext().setDisplayName(currentCase.getName());\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n\n                    // Reset the forward and back lists because we're resetting the root context\n                    resetHistoryListAndButtons();\n\n                    Children childNodes = em.getRootContext().getChildren();\n                    TreeView tree = getTree();\n\n                    Node results = childNodes.findChild(ResultsNode.NAME);\n                    tree.expandNode(results);\n\n                    Children resultsChilds = results.getChildren();\n                    tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n                    tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n\n\n                    Node views = childNodes.findChild(ViewsNode.NAME);\n                    Children viewsChilds = views.getChildren();\n                    for (Node n : viewsChilds.getNodes()) {\n                        tree.expandNode(n);\n                    }\n\n                    tree.collapseNode(views);\n\n                    // if the dataResult is not opened\n                    if (!dataResult.isOpened()) {\n                        dataResult.open(); // open the data result top component as well when the directory tree is opened\n                    }\n\n\n                    // select the first image node, if there is one\n                    // (this has to happen after dataResult is opened, because the event\n                    // of changing the selected node fires a handler that tries to make\n                    // dataResult active)\n                    if (childNodes.getNodesCount() > 0) {\n                        try {\n                            em.setSelectedNodes(new Node[]{childNodes.getNodeAt(0)});\n                        } catch (Exception ex) {\n                            logger.log(Level.SEVERE, \"Error setting default selected node.\", ex);\n                        }\n                    }\n\n                }\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","id":80126,"modified_method":"/**\n     * Called only when top component was closed on all workspaces before and\n     * now is opened for the first time on some workspace. The intent is to\n     * provide subclasses information about TopComponent's life cycle across all\n     * existing workspaces. Subclasses will usually perform initializing tasks\n     * here.\n     */\n    @Override\n    public void componentOpened() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (Case.existsCurrentCase()) {\n                Case currentCase = Case.getCurrentCase();\n\n                // close the top component if there's no image in this case\n                if (currentCase.getRootObjectsCount() == 0) {\n                    //this.close();\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n                } else {\n                    // if there's at least one image, load the image and open the top component\n                    List<Object> items = new ArrayList<>();\n                    final SleuthkitCase tskCase = currentCase.getSleuthkitCase();\n                    items.add(new DataSources(tskCase));\n                    items.add(new Views(tskCase));\n                    items.add(new Results(tskCase));\n                    contentChildren = new RootContentChildren(items);\n                    Node root = new AbstractNode(contentChildren) {\n                        /**\n                         * to override the right click action in the white blank\n                         * space area on the directory tree window\n                         */\n                        @Override\n                        public Action[] getActions(boolean popup) {\n                            return new Action[]{};\n                        }\n\n                        // Overide the AbstractNode use of DefaultHandle to return\n                        // a handle which can be serialized without a parent\n                        @Override\n                        public Node.Handle getHandle() {\n                            return new Node.Handle() {\n                                @Override\n                                public Node getNode() throws IOException {\n                                    return em.getRootContext();\n                                }\n                            };\n                        }\n                    };\n\n                    root = new DirectoryTreeFilterNode(root, true);\n\n\n                    em.setRootContext(root);\n                    em.getRootContext().setName(currentCase.getName());\n                    em.getRootContext().setDisplayName(currentCase.getName());\n                    ((BeanTreeView) this.jScrollPane1).setRootVisible(false); // hide the root\n\n                    // Reset the forward and back lists because we're resetting the root context\n                    resetHistory();\n\n                    Children childNodes = em.getRootContext().getChildren();\n                    TreeView tree = getTree();\n\n                    Node results = childNodes.findChild(ResultsNode.NAME);\n                    tree.expandNode(results);\n\n                    Children resultsChilds = results.getChildren();\n                    tree.expandNode(resultsChilds.findChild(KeywordHits.NAME));\n                    tree.expandNode(resultsChilds.findChild(ExtractedContentNode.NAME));\n\n\n                    Node views = childNodes.findChild(ViewsNode.NAME);\n                    Children viewsChilds = views.getChildren();\n                    for (Node n : viewsChilds.getNodes()) {\n                        tree.expandNode(n);\n                    }\n\n                    tree.collapseNode(views);\n\n                    // if the dataResult is not opened\n                    if (!dataResult.isOpened()) {\n                        dataResult.open(); // open the data result top component as well when the directory tree is opened\n                    }\n\n\n                    // select the first image node, if there is one\n                    // (this has to happen after dataResult is opened, because the event\n                    // of changing the selected node fires a handler that tries to make\n                    // dataResult active)\n                    if (childNodes.getNodesCount() > 0) {\n                        try {\n                            em.setSelectedNodes(new Node[]{childNodes.getNodeAt(0)});\n                        } catch (Exception ex) {\n                            logger.log(Level.SEVERE, \"Error setting default selected node.\", ex);\n                        }\n                    }\n\n                }\n            }\n        } finally {\n            this.setCursor(null);\n        }\n    }","commit_id":"09f57cd48cccc133ad9fe71ed295fb829c9d8f0c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n\tpublic String getMachineID() {\n\t\tfinal String envVar = System\n\t\t\t\t.getenv(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID);\n\t\t\n\t\treturn envVar;\n\t}","id":80127,"modified_method":"@Override\n\tpublic String getMachineID() {\n\t\treturn System.getenv(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID);\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic String getCloudTemplateName() {\n\t\tfinal String envVar = System\n\t\t\t\t.getenv(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME);\n\n\t\treturn envVar;\n\t}","id":80128,"modified_method":"@Override\n\tpublic String getCloudTemplateName() {\n\t\treturn System.getenv(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME);\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private StorageFacade getRemoteStorage() {\n\t\tElasticServiceManager elasticServiceManager = null;\n\t\tif (admin != null) {\n\t\t\telasticServiceManager = admin.getElasticServiceManagers().waitForAtLeastOne();\n\t\t\tRemoteStorageProvisioningDriver storageApi = \n\t\t\t\t\t(RemoteStorageProvisioningDriver) ((InternalElasticServiceManager) elasticServiceManager)\n\t\t\t\t\t.getStorageApi(ServiceUtils.getAbsolutePUName(applicationName, serviceName));\n\t\t\t\n\t\t\tStorageFacadeImpl storageFacadeImpl = new StorageFacadeImpl(this, storageApi);\n\t\t\treturn storageFacadeImpl;\n\t\t}\n\t\treturn null;\n\t}","id":80129,"modified_method":"private StorageFacade getRemoteStorage() {\n\t\tElasticServiceManager elasticServiceManager;\n\t\tif (admin != null) {\n\t\t\telasticServiceManager = admin.getElasticServiceManagers().waitForAtLeastOne();\n\t\t\tRemoteStorageProvisioningDriver storageApi = \n\t\t\t\t\t(RemoteStorageProvisioningDriver) ((InternalElasticServiceManager) elasticServiceManager)\n\t\t\t\t\t.getStorageApi(ServiceUtils.getAbsolutePUName(applicationName, serviceName));\n\t\t\t\n\t\t\treturn new StorageFacadeImpl(this, storageApi);\n\n\t\t}\n\t\treturn null;\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic String getLocationId() {\n\t\tfinal String envVar = System\n\t\t\t\t.getenv(CloudifyConstants.CLOUDIFY_CLOUD_LOCATION_ID);\n\t\t\n\t\treturn envVar;\n\t}","id":80130,"modified_method":"@Override\n\tpublic String getLocationId() {\n\t\treturn System.getenv(CloudifyConstants.CLOUDIFY_CLOUD_LOCATION_ID);\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic String getImageID() {\n\t\tfinal String envVar = System\n\t\t\t\t.getenv(CloudifyConstants.CLOUDIFY_CLOUD_IMAGE_ID);\n\n\t\treturn envVar;\n\t}","id":80131,"modified_method":"@Override\n\tpublic String getImageID() {\n\t\treturn System.getenv(CloudifyConstants.CLOUDIFY_CLOUD_IMAGE_ID);\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic String getBindAddress() {\n\t\tfinal String envVar = System\n\t\t\t\t.getenv(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_IP_ADDRESS_ENV);\n\t\t\n\t\treturn envVar;\n\t}","id":80132,"modified_method":"@Override\n\tpublic String getBindAddress() {\n\t\treturn System.getenv(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_IP_ADDRESS_ENV);\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic String getHardwareID() {\n\t\tfinal String envVar = System\n\t\t\t\t.getenv(CloudifyConstants.CLOUDIFY_CLOUD_HARDWARE_ID);\n\n\t\treturn envVar;\n\t}","id":80133,"modified_method":"@Override\n\tpublic String getHardwareID() {\n        return System.getenv(CloudifyConstants.CLOUDIFY_CLOUD_HARDWARE_ID);\n\t}","commit_id":"2d5e4f48658cba5648b971229bd6bdf9e498590a","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void declareIntrinsicFunction(Name className, Name functionName, int arity, IntrinsicMethod implementation, boolean original) {\n        JetScope memberScope = getClassMemberScope(className);\n        final Collection<FunctionDescriptor> group = memberScope.getFunctions(functionName);\n        for (FunctionDescriptor descriptor : group) {\n            if (className.equals(descriptor.getContainingDeclaration().getName()) && descriptor.getValueParameters().size() == arity) {\n                myMethods.put(original ? descriptor.getOriginal() : descriptor, implementation);\n            }\n        }\n    }","id":80134,"modified_method":"private void declareIntrinsicFunction(Name className, Name functionName, int arity, IntrinsicMethod implementation) {\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME.child(className), functionName, arity, implementation);\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void declareArrayMethods() {\n\n        for (JvmPrimitiveType jvmPrimitiveType : JvmPrimitiveType.values()) {\n            declareArrayMethodsForPrimitive(jvmPrimitiveType);\n        }\n\n        declareIntrinsicProperty(Name.identifier(\"Array\"), Name.identifier(\"size\"), ARRAY_SIZE);\n        declareIntrinsicProperty(Name.identifier(\"Array\"), Name.identifier(\"indices\"), ARRAY_INDICES);\n        declareIntrinsicFunction(Name.identifier(\"Array\"), Name.identifier(\"set\"), 2, ARRAY_SET, true);\n        declareIntrinsicFunction(Name.identifier(\"Array\"), Name.identifier(\"get\"), 1, ARRAY_GET, true);\n        declareIterator(myStdLib.getArray());\n    }","id":80135,"modified_method":"private void declareArrayMethods() {\n\n        for (JvmPrimitiveType jvmPrimitiveType : JvmPrimitiveType.values()) {\n            declareArrayMethodsForPrimitive(jvmPrimitiveType);\n        }\n\n        declareIntrinsicProperty(Name.identifier(\"Array\"), Name.identifier(\"size\"), ARRAY_SIZE);\n        declareIntrinsicProperty(Name.identifier(\"Array\"), Name.identifier(\"indices\"), ARRAY_INDICES);\n        declareIntrinsicFunction(Name.identifier(\"Array\"), Name.identifier(\"set\"), 2, ARRAY_SET);\n        declareIntrinsicFunction(Name.identifier(\"Array\"), Name.identifier(\"get\"), 1, ARRAY_GET);\n        declareIterator(Name.identifier(\"Array\"));\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@PostConstruct\n    public void init() {\n        namedMethods.put(KOTLIN_JAVA_CLASS_FUNCTION, new JavaClassFunction());\n        namedMethods.put(KOTLIN_JAVA_CLASS_PROPERTY, new JavaClassProperty());\n        namedMethods.put(KOTLIN_ARRAYS_ARRAY, new JavaClassArray());\n\n        ImmutableList<Name> primitiveCastMethods = OperatorConventions.NUMBER_CONVERSIONS.asList();\n        for (Name method : primitiveCastMethods) {\n            declareIntrinsicFunction(Name.identifier(\"Number\"), method, 0, NUMBER_CAST, true);\n            for (Name type : PRIMITIVE_NUMBER_TYPES) {\n                declareIntrinsicFunction(type, method, 0, NUMBER_CAST, true);\n            }\n        }\n\n        for (Name type : PRIMITIVE_NUMBER_TYPES) {\n            declareIntrinsicFunction(type, Name.identifier(\"plus\"), 0, UNARY_PLUS, false);\n            declareIntrinsicFunction(type, Name.identifier(\"minus\"), 0, UNARY_MINUS, false);\n            declareIntrinsicFunction(type, Name.identifier(\"inv\"), 0, INV, false);\n            declareIntrinsicFunction(type, Name.identifier(\"rangeTo\"), 1, UP_TO, false);\n            declareIntrinsicFunction(type, Name.identifier(\"upto\"), 1, UP_TO, false);\n            declareIntrinsicFunction(type, Name.identifier(\"downto\"), 1, DOWN_TO, false);\n            declareIntrinsicFunction(type, Name.identifier(\"inc\"), 0, INC, false);\n            declareIntrinsicFunction(type, Name.identifier(\"dec\"), 0, DEC, false);\n        }\n\n        declareBinaryOp(Name.identifier(\"plus\"), Opcodes.IADD);\n        declareBinaryOp(Name.identifier(\"minus\"), Opcodes.ISUB);\n        declareBinaryOp(Name.identifier(\"times\"), Opcodes.IMUL);\n        declareBinaryOp(Name.identifier(\"div\"), Opcodes.IDIV);\n        declareBinaryOp(Name.identifier(\"mod\"), Opcodes.IREM);\n        declareBinaryOp(Name.identifier(\"shl\"), Opcodes.ISHL);\n        declareBinaryOp(Name.identifier(\"shr\"), Opcodes.ISHR);\n        declareBinaryOp(Name.identifier(\"ushr\"), Opcodes.IUSHR);\n        declareBinaryOp(Name.identifier(\"and\"), Opcodes.IAND);\n        declareBinaryOp(Name.identifier(\"or\"), Opcodes.IOR);\n        declareBinaryOp(Name.identifier(\"xor\"), Opcodes.IXOR);\n\n        declareIntrinsicFunction(Name.identifier(\"Boolean\"), Name.identifier(\"not\"), 0, new Not(), true);\n\n        declareIntrinsicFunction(Name.identifier(\"String\"), Name.identifier(\"plus\"), 1, new Concat(), true);\n        declareIntrinsicFunction(Name.identifier(\"CharSequence\"), Name.identifier(\"get\"), 1, new StringGetChar(), true);\n        declareIntrinsicFunction(Name.identifier(\"String\"), Name.identifier(\"get\"), 1, new StringGetChar(), true);\n\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"toString\")), 0, new ToString());\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"equals\")), 1, EQUALS);\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"identityEquals\")), 1, IDENTITY_EQUALS);\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"plus\")), 1, STRING_PLUS);\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"arrayOfNulls\")), 1, new NewArray());\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"sure\")), 0, new Sure());\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"synchronized\")), 2, new StupidSync());\n        declareOverload(myStdLib.getLibraryScope().getFunctions(Name.identifier(\"iterator\")), 0, new IteratorIterator());\n\n        declareIntrinsicFunction(Name.identifier(\"ByteIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"ShortIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"IntIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"LongIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"CharIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"BooleanIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"FloatIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n        declareIntrinsicFunction(Name.identifier(\"DoubleIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT, false);\n\n        for (Name type : PRIMITIVE_TYPES) {\n            declareIntrinsicFunction(type, Name.identifier(\"compareTo\"), 1, new CompareTo(), false);\n        }\n//        declareIntrinsicFunction(\"Any\", \"equals\", 1, new Equals());\n//\n        declareIntrinsicStringMethods();\n        declareIntrinsicProperty(Name.identifier(\"CharSequence\"), Name.identifier(\"length\"), new StringLength());\n        declareIntrinsicProperty(Name.identifier(\"String\"), Name.identifier(\"length\"), new StringLength());\n\n        declareArrayMethods();\n    }","id":80136,"modified_method":"@PostConstruct\n    public void init() {\n        namedMethods.put(KOTLIN_JAVA_CLASS_FUNCTION, new JavaClassFunction());\n        namedMethods.put(KOTLIN_JAVA_CLASS_PROPERTY, new JavaClassProperty());\n        namedMethods.put(KOTLIN_ARRAYS_ARRAY, new JavaClassArray());\n\n        ImmutableList<Name> primitiveCastMethods = OperatorConventions.NUMBER_CONVERSIONS.asList();\n        for (Name method : primitiveCastMethods) {\n            declareIntrinsicFunction(Name.identifier(\"Number\"), method, 0, NUMBER_CAST);\n            for (Name type : PRIMITIVE_NUMBER_TYPES) {\n                declareIntrinsicFunction(type, method, 0, NUMBER_CAST);\n            }\n        }\n\n        for (Name type : PRIMITIVE_NUMBER_TYPES) {\n            declareIntrinsicFunction(type, Name.identifier(\"plus\"), 0, UNARY_PLUS);\n            declareIntrinsicFunction(type, Name.identifier(\"minus\"), 0, UNARY_MINUS);\n            declareIntrinsicFunction(type, Name.identifier(\"inv\"), 0, INV);\n            declareIntrinsicFunction(type, Name.identifier(\"rangeTo\"), 1, UP_TO);\n            declareIntrinsicFunction(type, Name.identifier(\"upto\"), 1, UP_TO);\n            declareIntrinsicFunction(type, Name.identifier(\"downto\"), 1, DOWN_TO);\n            declareIntrinsicFunction(type, Name.identifier(\"inc\"), 0, INC);\n            declareIntrinsicFunction(type, Name.identifier(\"dec\"), 0, DEC);\n        }\n\n        declareBinaryOp(Name.identifier(\"plus\"), Opcodes.IADD);\n        declareBinaryOp(Name.identifier(\"minus\"), Opcodes.ISUB);\n        declareBinaryOp(Name.identifier(\"times\"), Opcodes.IMUL);\n        declareBinaryOp(Name.identifier(\"div\"), Opcodes.IDIV);\n        declareBinaryOp(Name.identifier(\"mod\"), Opcodes.IREM);\n        declareBinaryOp(Name.identifier(\"shl\"), Opcodes.ISHL);\n        declareBinaryOp(Name.identifier(\"shr\"), Opcodes.ISHR);\n        declareBinaryOp(Name.identifier(\"ushr\"), Opcodes.IUSHR);\n        declareBinaryOp(Name.identifier(\"and\"), Opcodes.IAND);\n        declareBinaryOp(Name.identifier(\"or\"), Opcodes.IOR);\n        declareBinaryOp(Name.identifier(\"xor\"), Opcodes.IXOR);\n\n        declareIntrinsicFunction(Name.identifier(\"Boolean\"), Name.identifier(\"not\"), 0, new Not());\n\n        declareIntrinsicFunction(Name.identifier(\"String\"), Name.identifier(\"plus\"), 1, new Concat());\n        declareIntrinsicFunction(Name.identifier(\"CharSequence\"), Name.identifier(\"get\"), 1, new StringGetChar());\n        declareIntrinsicFunction(Name.identifier(\"String\"), Name.identifier(\"get\"), 1, new StringGetChar());\n\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"toString\"), 0, new ToString());\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"equals\"), 1, EQUALS);\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"identityEquals\"), 1, IDENTITY_EQUALS);\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"plus\"), 1, STRING_PLUS);\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"arrayOfNulls\"), 1, new NewArray());\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"sure\"), 0, new Sure());\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"synchronized\"), 2, new StupidSync());\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME, Name.identifier(\"iterator\"), 0, new IteratorIterator());\n\n\n        declareIntrinsicFunction(Name.identifier(\"ByteIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"ShortIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"IntIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"LongIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"CharIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"BooleanIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"FloatIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n        declareIntrinsicFunction(Name.identifier(\"DoubleIterator\"), Name.identifier(\"next\"), 0, ITERATOR_NEXT);\n\n        for (Name type : PRIMITIVE_TYPES) {\n            declareIntrinsicFunction(type, Name.identifier(\"compareTo\"), 1, new CompareTo());\n        }\n//        declareIntrinsicFunction(\"Any\", \"equals\", 1, new Equals());\n//\n        declareIntrinsicStringMethods();\n        declareIntrinsicProperty(Name.identifier(\"CharSequence\"), Name.identifier(\"length\"), new StringLength());\n        declareIntrinsicProperty(Name.identifier(\"String\"), Name.identifier(\"length\"), new StringLength());\n\n        declareArrayMethods();\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void declareIntrinsicProperty(Name className, Name methodName, IntrinsicMethod implementation) {\n        final JetScope numberScope = getClassMemberScope(className);\n        Collection<VariableDescriptor> properties = numberScope.getProperties(methodName);\n        assert properties.size() == 1;\n        final PropertyDescriptor property = (PropertyDescriptor) properties.iterator().next();\n        myMethods.put(property.getOriginal(), implementation);\n    }","id":80137,"modified_method":"private void declareIntrinsicProperty(Name className, Name methodName, IntrinsicMethod implementation) {\n        intrinsicsMap.registerIntrinsic(JetStandardClasses.STANDARD_CLASSES_FQNAME.child(className), methodName, -1, implementation);\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void declareBinaryOp(Name methodName, int opcode) {\n        BinaryOp op = new BinaryOp(opcode);\n        for (Name type : PRIMITIVE_TYPES) {\n            declareIntrinsicFunction(type, methodName, 1, op, false);\n        }\n    }","id":80138,"modified_method":"private void declareBinaryOp(Name methodName, int opcode) {\n        BinaryOp op = new BinaryOp(opcode);\n        for (Name type : PRIMITIVE_TYPES) {\n            declareIntrinsicFunction(type, methodName, 1, op);\n        }\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void declareArrayMethodsForPrimitive(JvmPrimitiveType jvmPrimitiveType) {\n        PrimitiveType primitiveType = jvmPrimitiveType.getPrimitiveType();\n        declareIntrinsicProperty(primitiveType.getArrayTypeName(), Name.identifier(\"size\"), ARRAY_SIZE);\n        declareIntrinsicProperty(primitiveType.getArrayTypeName(), Name.identifier(\"indices\"), ARRAY_INDICES);\n        declareIntrinsicFunction(primitiveType.getArrayTypeName(), Name.identifier(\"set\"), 2, ARRAY_SET, true);\n        declareIntrinsicFunction(primitiveType.getArrayTypeName(), Name.identifier(\"get\"), 1, ARRAY_GET, true);\n        declareIterator(myStdLib.getPrimitiveArrayClassDescriptor(primitiveType));\n    }","id":80139,"modified_method":"private void declareArrayMethodsForPrimitive(JvmPrimitiveType jvmPrimitiveType) {\n        PrimitiveType primitiveType = jvmPrimitiveType.getPrimitiveType();\n        declareIntrinsicProperty(primitiveType.getArrayTypeName(), Name.identifier(\"size\"), ARRAY_SIZE);\n        declareIntrinsicProperty(primitiveType.getArrayTypeName(), Name.identifier(\"indices\"), ARRAY_INDICES);\n        declareIntrinsicFunction(primitiveType.getArrayTypeName(), Name.identifier(\"set\"), 2, ARRAY_SET);\n        declareIntrinsicFunction(primitiveType.getArrayTypeName(), Name.identifier(\"get\"), 1, ARRAY_GET);\n        declareIterator(primitiveType.getArrayTypeName());\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public IntrinsicMethod getIntrinsic(@NotNull CallableMemberDescriptor descriptor) {\n        IntrinsicMethod intrinsicMethod = myMethods.get(descriptor.getOriginal());\n        if (intrinsicMethod == null) {\n            List<AnnotationDescriptor> annotations = descriptor.getAnnotations();\n            if (annotations != null) {\n                for (AnnotationDescriptor annotation : annotations) {\n                    if(\"Intrinsic\".equals(annotation.getType().getConstructor().getDeclarationDescriptor().getName().getName())) {\n                        String value = (String) annotation.getValueArguments().get(0).getValue();\n                        intrinsicMethod = namedMethods.get(value);\n                        if (intrinsicMethod != null) { break; }\n                    }\n                }\n            }\n        }\n        return intrinsicMethod;\n    }","id":80140,"modified_method":"@Nullable\n    public IntrinsicMethod getIntrinsic(@NotNull CallableMemberDescriptor descriptor) {\n        IntrinsicMethod intrinsicMethod = myMethods.get(descriptor.getOriginal());\n        if (intrinsicMethod != null) {\n            return intrinsicMethod;\n        }\n\n        intrinsicMethod = intrinsicsMap.getIntrinsic(descriptor);\n        if (intrinsicMethod != null) {\n            return intrinsicMethod;\n        }\n\n        List<AnnotationDescriptor> annotations = descriptor.getAnnotations();\n        if (annotations != null) {\n            for (AnnotationDescriptor annotation : annotations) {\n                if(\"Intrinsic\".equals(annotation.getType().getConstructor().getDeclarationDescriptor().getName().getName())) {\n                    String value = (String) annotation.getValueArguments().get(0).getValue();\n                    intrinsicMethod = namedMethods.get(value);\n                    if (intrinsicMethod != null) { break; }\n                }\n            }\n        }\n        return intrinsicMethod;\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void declareIterator(ClassDescriptor classDescriptor) {\n        declareOverload(classDescriptor.getDefaultType().getMemberScope().getFunctions(Name.identifier(\"iterator\")), 0, ARRAY_ITERATOR);\n    }","id":80141,"modified_method":"private void declareIterator(@NotNull Name arrayClassName) {\n        declareIntrinsicFunction(arrayClassName, Name.identifier(\"iterator\"), 0, ARRAY_ITERATOR);\n    }","commit_id":"f73f5b50749d28242a1e372b6da099800bc813bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected Trigger getQuartzTrigger(\n\t\t\tcom.liferay.portal.kernel.scheduler.Trigger trigger,\n\t\t\tStorageType storageType)\n\t\tthrows SchedulerException {\n\n\t\tif (trigger == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDate endDate = trigger.getEndDate();\n\t\tString jobName = fixMaxLength(\n\t\t\ttrigger.getJobName(), _jobNameMaxLength, storageType);\n\t\tString groupName = fixMaxLength(\n\t\t\ttrigger.getGroupName(), _groupNameMaxLength, storageType);\n\n\t\tDate startDate = trigger.getStartDate();\n\n\t\tif (startDate == null) {\n\t\t\tstartDate = new Date(System.currentTimeMillis());\n\t\t}\n\n\t\tTrigger quartzTrigger = null;\n\n\t\tTriggerType triggerType = trigger.getTriggerType();\n\n\t\tif (triggerType.equals(TriggerType.CRON)) {\n\t\t\tTriggerBuilder<Trigger>triggerBuilder = TriggerBuilder.newTrigger();\n\n\t\t\ttriggerBuilder.endAt(endDate);\n\t\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\t\ttriggerBuilder.startAt(startDate);\n\t\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\t\tCronScheduleBuilder cronScheduleBuilder =\n\t\t\t\tCronScheduleBuilder.cronSchedule(\n\t\t\t\t\t(String)trigger.getTriggerContent());\n\n\t\t\ttriggerBuilder.withSchedule(cronScheduleBuilder);\n\n\t\t\tquartzTrigger = triggerBuilder.build();\n\t\t}\n\t\telse if (triggerType.equals(TriggerType.SIMPLE)) {\n\t\t\tObjectValuePair<Integer, TimeUnit> triggerContent =\n\t\t\t\t(ObjectValuePair<Integer, TimeUnit>)trigger.getTriggerContent();\n\n\t\t\tint interval = triggerContent.getKey();\n\t\t\tTimeUnit timeUnit = triggerContent.getValue();\n\n\t\t\tif (interval < 0) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Not scheduling \" + trigger.getJobName() +\n\t\t\t\t\t\t\t\" because interval is less than 0\");\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tTriggerBuilder<Trigger> triggerBuilder =\n\t\t\t\tTriggerBuilder.newTrigger();\n\n\t\t\ttriggerBuilder.endAt(endDate);\n\t\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\t\ttriggerBuilder.startAt(startDate);\n\t\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\t\tif (interval > 0) {\n\t\t\t\tCalendarIntervalScheduleBuilder\n\t\t\t\t\tcalendarIntervalScheduleBuilder =\n\t\t\t\t\t\tCalendarIntervalScheduleBuilder.\n\t\t\t\t\t\t\tcalendarIntervalSchedule();\n\n\t\t\t\tswitch (timeUnit) {\n\t\t\t\t\tcase SECOND:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInSeconds(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MINUTE:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMinutes(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HOUR:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInHours(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DAY:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInDays(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WEEK:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInWeeks(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMonths(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase YEAR:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInYears(\n\t\t\t\t\t\t\tinterval);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttriggerBuilder.withSchedule(calendarIntervalScheduleBuilder);\n\t\t\t}\n\n\t\t\tquartzTrigger = triggerBuilder.build();\n\t\t}\n\t\telse {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unknown trigger type \" + trigger.getTriggerType());\n\t\t}\n\n\t\treturn quartzTrigger;\n\t}","id":80142,"modified_method":"protected Trigger getQuartzTrigger(\n\t\t\tcom.liferay.portal.kernel.scheduler.Trigger trigger,\n\t\t\tStorageType storageType)\n\t\tthrows SchedulerException {\n\n\t\tif (trigger == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDate endDate = trigger.getEndDate();\n\t\tString jobName = fixMaxLength(\n\t\t\ttrigger.getJobName(), _jobNameMaxLength, storageType);\n\t\tString groupName = fixMaxLength(\n\t\t\ttrigger.getGroupName(), _groupNameMaxLength, storageType);\n\n\t\tDate startDate = trigger.getStartDate();\n\n\t\tif (startDate == null) {\n\t\t\tstartDate = new Date(System.currentTimeMillis());\n\t\t}\n\n\t\tTriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger();\n\n\t\ttriggerBuilder.endAt(endDate);\n\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\ttriggerBuilder.startAt(startDate);\n\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\tTriggerType triggerType = trigger.getTriggerType();\n\n\t\tif (triggerType == TriggerType.CRON) {\n\t\t\ttriggerBuilder.withSchedule(\n\t\t\t\tCronScheduleBuilder.cronSchedule(\n\t\t\t\t\t(String)trigger.getTriggerContent()));\n\n\t\t\treturn triggerBuilder.build();\n\t\t}\n\n\t\tObjectValuePair<Integer, TimeUnit> triggerContent =\n\t\t\t(ObjectValuePair<Integer, TimeUnit>)trigger.getTriggerContent();\n\n\t\tint interval = triggerContent.getKey();\n\t\tTimeUnit timeUnit = triggerContent.getValue();\n\n\t\tif (interval < 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Not scheduling \" + trigger.getJobName() +\n\t\t\t\t\t\t\" because interval is less than 0\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\telse if (interval == 0) {\n\t\t\treturn triggerBuilder.build();\n\t\t}\n\n\t\tCalendarIntervalScheduleBuilder calendarIntervalScheduleBuilder =\n\t\t\tCalendarIntervalScheduleBuilder.calendarIntervalSchedule();\n\n\t\tswitch (timeUnit) {\n\t\t\tcase SECOND:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInSeconds(interval);\n\n\t\t\t\tbreak;\n\n\t\t\tcase MINUTE:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMinutes(interval);\n\n\t\t\t\tbreak;\n\n\t\t\tcase HOUR:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInHours(interval);\n\n\t\t\t\tbreak;\n\n\t\t\tcase DAY:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInDays(interval);\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEEK:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInWeeks(interval);\n\n\t\t\t\tbreak;\n\n\t\t\tcase MONTH:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMonths(interval);\n\n\t\t\t\tbreak;\n\n\t\t\tcase YEAR:\n\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInYears(interval);\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttriggerBuilder.withSchedule(calendarIntervalScheduleBuilder);\n\n\t\treturn triggerBuilder.build();\n\t}","commit_id":"0235c464e1e5bd40148bb8a06424a063c058d980","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Trigger getQuartzTrigger(\n\t\t\tcom.liferay.portal.kernel.scheduler.Trigger trigger,\n\t\t\tStorageType storageType)\n\t\tthrows SchedulerException {\n\n\t\tif (trigger == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDate endDate = trigger.getEndDate();\n\t\tString jobName = fixMaxLength(\n\t\t\ttrigger.getJobName(), _jobNameMaxLength, storageType);\n\t\tString groupName = fixMaxLength(\n\t\t\ttrigger.getGroupName(), _groupNameMaxLength, storageType);\n\n\t\tDate startDate = trigger.getStartDate();\n\n\t\tif (startDate == null) {\n\t\t\tstartDate = new Date(System.currentTimeMillis());\n\t\t}\n\n\t\tTrigger quartzTrigger = null;\n\n\t\tTriggerType triggerType = trigger.getTriggerType();\n\n\t\tif (triggerType.equals(TriggerType.CRON)) {\n\t\t\tTriggerBuilder<Trigger>triggerBuilder = TriggerBuilder.newTrigger();\n\n\t\t\ttriggerBuilder.endAt(endDate);\n\t\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\t\ttriggerBuilder.startAt(startDate);\n\t\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\t\tCronScheduleBuilder cronScheduleBuilder =\n\t\t\t\tCronScheduleBuilder.cronSchedule(\n\t\t\t\t\t(String)trigger.getTriggerContent());\n\n\t\t\ttriggerBuilder.withSchedule(cronScheduleBuilder);\n\n\t\t\tquartzTrigger = triggerBuilder.build();\n\t\t}\n\t\telse if (triggerType.equals(TriggerType.SIMPLE)) {\n\t\t\tObjectValuePair<Long, TimeUnit> triggerContent =\n\t\t\t\t(ObjectValuePair<Long, TimeUnit>)trigger.getTriggerContent();\n\n\t\t\tlong interval = triggerContent.getKey();\n\t\t\tTimeUnit timeUnit = triggerContent.getValue();\n\n\t\t\tif (interval <= 0) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Not scheduling \" + trigger.getJobName() +\n\t\t\t\t\t\t\t\" because interval is less than or equal to 0\");\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tTriggerBuilder<Trigger> triggerBuilder =\n\t\t\t\tTriggerBuilder.newTrigger();\n\n\t\t\ttriggerBuilder.endAt(endDate);\n\t\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\t\ttriggerBuilder.startAt(startDate);\n\t\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\t\tCalendarIntervalScheduleBuilder calendarIntervalScheduleBuilder =\n\t\t\t\tCalendarIntervalScheduleBuilder.calendarIntervalSchedule();\n\n\t\t\tswitch (timeUnit) {\n\t\t\t\tcase SECOND:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInSeconds(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MINUTE:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMinutes(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HOUR:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInHours(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DAY:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInDays(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WEEK:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInWeeks(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MONTH:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMonths(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase YEAR:\n\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInYears(\n\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttriggerBuilder.withSchedule(calendarIntervalScheduleBuilder);\n\n\t\t\tquartzTrigger = triggerBuilder.build();\n\t\t}\n\t\telse {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unknown trigger type \" + trigger.getTriggerType());\n\t\t}\n\n\t\treturn quartzTrigger;\n\t}","id":80143,"modified_method":"protected Trigger getQuartzTrigger(\n\t\t\tcom.liferay.portal.kernel.scheduler.Trigger trigger,\n\t\t\tStorageType storageType)\n\t\tthrows SchedulerException {\n\n\t\tif (trigger == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDate endDate = trigger.getEndDate();\n\t\tString jobName = fixMaxLength(\n\t\t\ttrigger.getJobName(), _jobNameMaxLength, storageType);\n\t\tString groupName = fixMaxLength(\n\t\t\ttrigger.getGroupName(), _groupNameMaxLength, storageType);\n\n\t\tDate startDate = trigger.getStartDate();\n\n\t\tif (startDate == null) {\n\t\t\tstartDate = new Date(System.currentTimeMillis());\n\t\t}\n\n\t\tTrigger quartzTrigger = null;\n\n\t\tTriggerType triggerType = trigger.getTriggerType();\n\n\t\tif (triggerType.equals(TriggerType.CRON)) {\n\t\t\tTriggerBuilder<Trigger>triggerBuilder = TriggerBuilder.newTrigger();\n\n\t\t\ttriggerBuilder.endAt(endDate);\n\t\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\t\ttriggerBuilder.startAt(startDate);\n\t\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\t\tCronScheduleBuilder cronScheduleBuilder =\n\t\t\t\tCronScheduleBuilder.cronSchedule(\n\t\t\t\t\t(String)trigger.getTriggerContent());\n\n\t\t\ttriggerBuilder.withSchedule(cronScheduleBuilder);\n\n\t\t\tquartzTrigger = triggerBuilder.build();\n\t\t}\n\t\telse if (triggerType.equals(TriggerType.SIMPLE)) {\n\t\t\tObjectValuePair<Long, TimeUnit> triggerContent =\n\t\t\t\t(ObjectValuePair<Long, TimeUnit>)trigger.getTriggerContent();\n\n\t\t\tlong interval = triggerContent.getKey();\n\t\t\tTimeUnit timeUnit = triggerContent.getValue();\n\n\t\t\tif (interval < 0) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Not scheduling \" + trigger.getJobName() +\n\t\t\t\t\t\t\t\" because interval is less than 0\");\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tTriggerBuilder<Trigger> triggerBuilder =\n\t\t\t\tTriggerBuilder.newTrigger();\n\n\t\t\ttriggerBuilder.endAt(endDate);\n\t\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\t\ttriggerBuilder.startAt(startDate);\n\t\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\t\tif (interval > 0) {\n\t\t\t\tCalendarIntervalScheduleBuilder\n\t\t\t\t\tcalendarIntervalScheduleBuilder =\n\t\t\t\t\t\tCalendarIntervalScheduleBuilder.\n\t\t\t\t\t\t\tcalendarIntervalSchedule();\n\n\t\t\t\tswitch (timeUnit) {\n\t\t\t\t\tcase SECOND:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInSeconds(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MINUTE:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMinutes(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HOUR:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInHours(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DAY:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInDays(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WEEK:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInWeeks(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInMonths(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase YEAR:\n\t\t\t\t\t\tcalendarIntervalScheduleBuilder.withIntervalInYears(\n\t\t\t\t\t\t\t(int)interval);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttriggerBuilder.withSchedule(calendarIntervalScheduleBuilder);\n\t\t\t}\n\n\t\t\tquartzTrigger = triggerBuilder.build();\n\t\t}\n\t\telse {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unknown trigger type \" + trigger.getTriggerType());\n\t\t}\n\n\t\treturn quartzTrigger;\n\t}","commit_id":"e493791d0091c6676a3dcf2c3e9f6630fc127272","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SchedulerResponse getScheduledJob(\n\t\t\tScheduler scheduler, JobKey jobKey)\n\t\tthrows Exception {\n\n\t\tJobDetail jobDetail = scheduler.getJobDetail(jobKey);\n\n\t\tif (jobDetail == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJobDataMap jobDataMap = jobDetail.getJobDataMap();\n\n\t\tString description = jobDataMap.getString(SchedulerEngine.DESCRIPTION);\n\t\tString destinationName = jobDataMap.getString(\n\t\t\tSchedulerEngine.DESTINATION_NAME);\n\t\tMessage message = getMessage(jobDataMap);\n\t\tJobState jobState = getJobState(jobDataMap);\n\t\tStorageType storageType = StorageType.valueOf(\n\t\t\tjobDataMap.getString(SchedulerEngine.STORAGE_TYPE));\n\n\t\tmessage.put(SchedulerEngine.JOB_STATE, jobState);\n\n\t\tSchedulerResponse schedulerResponse = new SchedulerResponse();\n\n\t\tschedulerResponse.setDescription(description);\n\t\tschedulerResponse.setDestinationName(destinationName);\n\t\tschedulerResponse.setMessage(message);\n\t\tschedulerResponse.setStorageType(storageType);\n\n\t\tString jobName = jobKey.getName();\n\t\tString groupName = jobKey.getGroup();\n\n\t\tTriggerKey triggerKey = new TriggerKey(jobName, groupName);\n\n\t\tTrigger trigger = scheduler.getTrigger(triggerKey);\n\n\t\tif (trigger == null) {\n\t\t\tschedulerResponse.setGroupName(groupName);\n\t\t\tschedulerResponse.setJobName(jobName);\n\n\t\t\treturn schedulerResponse;\n\t\t}\n\n\t\tmessage.put(SchedulerEngine.END_TIME, trigger.getEndTime());\n\t\tmessage.put(\n\t\t\tSchedulerEngine.FINAL_FIRE_TIME, trigger.getFinalFireTime());\n\t\tmessage.put(SchedulerEngine.NEXT_FIRE_TIME, trigger.getNextFireTime());\n\t\tmessage.put(\n\t\t\tSchedulerEngine.PREVIOUS_FIRE_TIME, trigger.getPreviousFireTime());\n\t\tmessage.put(SchedulerEngine.START_TIME, trigger.getStartTime());\n\n\t\tif (trigger instanceof CalendarIntervalTrigger) {\n\t\t\tCalendarIntervalTrigger calendarIntervalTrigger =\n\t\t\t\tCalendarIntervalTrigger.class.cast(trigger);\n\n\t\t\tIntervalUnit intervalUnit =\n\t\t\t\tcalendarIntervalTrigger.getRepeatIntervalUnit();\n\n\t\t\tschedulerResponse.setTrigger(\n\t\t\t\tnew IntervalTrigger(\n\t\t\t\t\tjobName, groupName, calendarIntervalTrigger.getStartTime(),\n\t\t\t\t\tcalendarIntervalTrigger.getEndTime(),\n\t\t\t\t\tcalendarIntervalTrigger.getRepeatInterval(),\n\t\t\t\t\tTimeUnit.valueOf(intervalUnit.name())));\n\t\t}\n\t\telse if (trigger instanceof CronTrigger) {\n\t\t\tCronTrigger cronTrigger = CronTrigger.class.cast(trigger);\n\n\t\t\tschedulerResponse.setTrigger(\n\t\t\t\tnew com.liferay.portal.kernel.scheduler.CronTrigger(\n\t\t\t\t\tjobName, groupName, cronTrigger.getStartTime(),\n\t\t\t\t\tcronTrigger.getEndTime(), cronTrigger.getCronExpression()));\n\t\t}\n\n\t\treturn schedulerResponse;\n\t}","id":80144,"modified_method":"protected SchedulerResponse getScheduledJob(\n\t\t\tScheduler scheduler, JobKey jobKey)\n\t\tthrows Exception {\n\n\t\tJobDetail jobDetail = scheduler.getJobDetail(jobKey);\n\n\t\tif (jobDetail == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJobDataMap jobDataMap = jobDetail.getJobDataMap();\n\n\t\tString description = jobDataMap.getString(SchedulerEngine.DESCRIPTION);\n\t\tString destinationName = jobDataMap.getString(\n\t\t\tSchedulerEngine.DESTINATION_NAME);\n\t\tMessage message = getMessage(jobDataMap);\n\t\tJobState jobState = getJobState(jobDataMap);\n\t\tStorageType storageType = StorageType.valueOf(\n\t\t\tjobDataMap.getString(SchedulerEngine.STORAGE_TYPE));\n\n\t\tmessage.put(SchedulerEngine.JOB_STATE, jobState);\n\n\t\tSchedulerResponse schedulerResponse = new SchedulerResponse();\n\n\t\tschedulerResponse.setDescription(description);\n\t\tschedulerResponse.setDestinationName(destinationName);\n\t\tschedulerResponse.setMessage(message);\n\t\tschedulerResponse.setStorageType(storageType);\n\n\t\tString jobName = jobKey.getName();\n\t\tString groupName = jobKey.getGroup();\n\n\t\tTriggerKey triggerKey = new TriggerKey(jobName, groupName);\n\n\t\tTrigger trigger = scheduler.getTrigger(triggerKey);\n\n\t\tif (trigger == null) {\n\t\t\tschedulerResponse.setGroupName(groupName);\n\t\t\tschedulerResponse.setJobName(jobName);\n\n\t\t\treturn schedulerResponse;\n\t\t}\n\n\t\tmessage.put(SchedulerEngine.END_TIME, trigger.getEndTime());\n\t\tmessage.put(\n\t\t\tSchedulerEngine.FINAL_FIRE_TIME, trigger.getFinalFireTime());\n\t\tmessage.put(SchedulerEngine.NEXT_FIRE_TIME, trigger.getNextFireTime());\n\t\tmessage.put(\n\t\t\tSchedulerEngine.PREVIOUS_FIRE_TIME, trigger.getPreviousFireTime());\n\t\tmessage.put(SchedulerEngine.START_TIME, trigger.getStartTime());\n\n\t\tif (trigger instanceof CalendarIntervalTrigger) {\n\t\t\tCalendarIntervalTrigger calendarIntervalTrigger =\n\t\t\t\tCalendarIntervalTrigger.class.cast(trigger);\n\n\t\t\tIntervalUnit intervalUnit =\n\t\t\t\tcalendarIntervalTrigger.getRepeatIntervalUnit();\n\n\t\t\tschedulerResponse.setTrigger(\n\t\t\t\tnew IntervalTrigger(\n\t\t\t\t\tjobName, groupName, calendarIntervalTrigger.getStartTime(),\n\t\t\t\t\tcalendarIntervalTrigger.getEndTime(),\n\t\t\t\t\tcalendarIntervalTrigger.getRepeatInterval(),\n\t\t\t\t\tTimeUnit.valueOf(intervalUnit.name())));\n\t\t}\n\t\telse if (trigger instanceof CronTrigger) {\n\t\t\tCronTrigger cronTrigger = CronTrigger.class.cast(trigger);\n\n\t\t\tschedulerResponse.setTrigger(\n\t\t\t\tnew com.liferay.portal.kernel.scheduler.CronTrigger(\n\t\t\t\t\tjobName, groupName, cronTrigger.getStartTime(),\n\t\t\t\t\tcronTrigger.getEndTime(), cronTrigger.getCronExpression()));\n\t\t}\n\t\telse if (trigger instanceof SimpleTrigger) {\n\t\t\tSimpleTrigger simpleTrigger = SimpleTrigger.class.cast(trigger);\n\n\t\t\tschedulerResponse.setTrigger(\n\t\t\t\tnew IntervalTrigger(\n\t\t\t\t\tjobName, groupName, simpleTrigger.getStartTime(),\n\t\t\t\t\tsimpleTrigger.getEndTime(),\n\t\t\t\t\t(int)simpleTrigger.getRepeatInterval(),\n\t\t\t\t\tTimeUnit.MILLISECOND));\n\t\t}\n\n\t\treturn schedulerResponse;\n\t}","commit_id":"248220f6f361b0df7cfe7fd84a9c096ced03c1d0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Trigger getQuartzTrigger(\n\t\t\tcom.liferay.portal.kernel.scheduler.Trigger trigger,\n\t\t\tStorageType storageType)\n\t\tthrows SchedulerException {\n\n\t\tif (trigger == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDate endDate = trigger.getEndDate();\n\t\tString jobName = fixMaxLength(\n\t\t\ttrigger.getJobName(), _jobNameMaxLength, storageType);\n\t\tString groupName = fixMaxLength(\n\t\t\ttrigger.getGroupName(), _groupNameMaxLength, storageType);\n\n\t\tDate startDate = trigger.getStartDate();\n\n\t\tif (startDate == null) {\n\t\t\tstartDate = new Date(System.currentTimeMillis());\n\t\t}\n\n\t\tTriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger();\n\n\t\ttriggerBuilder.endAt(endDate);\n\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\ttriggerBuilder.startAt(startDate);\n\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\tTriggerType triggerType = trigger.getTriggerType();\n\n\t\tif (triggerType == TriggerType.CRON) {\n\t\t\ttriggerBuilder.withSchedule(\n\t\t\t\tCronScheduleBuilder.cronSchedule(\n\t\t\t\t\t(String)trigger.getTriggerContent()));\n\n\t\t\treturn triggerBuilder.build();\n\t\t}\n\n\t\tObjectValuePair<Integer, TimeUnit> objectValuePair =\n\t\t\t(ObjectValuePair<Integer, TimeUnit>)trigger.getTriggerContent();\n\n\t\tint interval = objectValuePair.getKey();\n\n\t\tif (interval < 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Not scheduling \" + trigger.getJobName() +\n\t\t\t\t\t\t\" because interval is less than 0\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\telse if (interval == 0) {\n\t\t\treturn triggerBuilder.build();\n\t\t}\n\n\t\tCalendarIntervalScheduleBuilder calendarIntervalScheduleBuilder =\n\t\t\tCalendarIntervalScheduleBuilder.calendarIntervalSchedule();\n\n\t\tTimeUnit timeUnit = objectValuePair.getValue();\n\n\t\tcalendarIntervalScheduleBuilder.withInterval(\n\t\t\tinterval, IntervalUnit.valueOf(timeUnit.name()));\n\n\t\ttriggerBuilder.withSchedule(calendarIntervalScheduleBuilder);\n\n\t\treturn triggerBuilder.build();\n\t}","id":80145,"modified_method":"protected Trigger getQuartzTrigger(\n\t\t\tcom.liferay.portal.kernel.scheduler.Trigger trigger,\n\t\t\tStorageType storageType)\n\t\tthrows SchedulerException {\n\n\t\tif (trigger == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDate endDate = trigger.getEndDate();\n\t\tString jobName = fixMaxLength(\n\t\t\ttrigger.getJobName(), _jobNameMaxLength, storageType);\n\t\tString groupName = fixMaxLength(\n\t\t\ttrigger.getGroupName(), _groupNameMaxLength, storageType);\n\n\t\tDate startDate = trigger.getStartDate();\n\n\t\tif (startDate == null) {\n\t\t\tstartDate = new Date(System.currentTimeMillis());\n\t\t}\n\n\t\tTriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger();\n\n\t\ttriggerBuilder.endAt(endDate);\n\t\ttriggerBuilder.forJob(jobName, groupName);\n\t\ttriggerBuilder.startAt(startDate);\n\t\ttriggerBuilder.withIdentity(jobName, groupName);\n\n\t\tTriggerType triggerType = trigger.getTriggerType();\n\n\t\tif (triggerType == TriggerType.CRON) {\n\t\t\ttriggerBuilder.withSchedule(\n\t\t\t\tCronScheduleBuilder.cronSchedule(\n\t\t\t\t\t(String)trigger.getTriggerContent()));\n\n\t\t\treturn triggerBuilder.build();\n\t\t}\n\n\t\tObjectValuePair<Integer, TimeUnit> objectValuePair =\n\t\t\t(ObjectValuePair<Integer, TimeUnit>)trigger.getTriggerContent();\n\n\t\tint interval = objectValuePair.getKey();\n\n\t\tif (interval < 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Not scheduling \" + trigger.getJobName() +\n\t\t\t\t\t\t\" because interval is less than 0\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\telse if (interval == 0) {\n\t\t\treturn triggerBuilder.build();\n\t\t}\n\n\t\tTimeUnit timeUnit = objectValuePair.getValue();\n\n\t\tif (timeUnit == TimeUnit.MILLISECOND) {\n\t\t\tSimpleScheduleBuilder simpleScheduleBuilder =\n\t\t\t\tSimpleScheduleBuilder.simpleSchedule();\n\n\t\t\tsimpleScheduleBuilder.withIntervalInMilliseconds(interval);\n\t\t\tsimpleScheduleBuilder.withRepeatCount(\n\t\t\t\tSimpleTrigger.REPEAT_INDEFINITELY);\n\n\t\t\ttriggerBuilder.withSchedule(simpleScheduleBuilder);\n\t\t}\n\t\telse {\n\t\t\tCalendarIntervalScheduleBuilder calendarIntervalScheduleBuilder =\n\t\t\t\tCalendarIntervalScheduleBuilder.calendarIntervalSchedule();\n\n\t\t\tcalendarIntervalScheduleBuilder.withInterval(\n\t\t\t\tinterval, IntervalUnit.valueOf(timeUnit.name()));\n\n\t\t\ttriggerBuilder.withSchedule(calendarIntervalScheduleBuilder);\n\t\t}\n\n\t\treturn triggerBuilder.build();\n\t}","commit_id":"248220f6f361b0df7cfe7fd84a9c096ced03c1d0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Document[] parse() throws Parser.Failure {\n        String supportError = TextParser.supports(url(), this.responseHeader == null ? null : this.responseHeader.mime());\n        if (supportError != null) throw new Parser.Failure(\"no parser support:\" + supportError, url());\n        try {\n            return TextParser.parseSource(url(), this.responseHeader == null ? null : this.responseHeader.mime(), this.responseHeader == null ? \"UTF-8\" : this.responseHeader.getCharacterEncoding(), this.content.length, new ByteArrayInputStream(this.content));\n        } catch (Exception e) {\n            return null;\n        }\n\n    }","id":80146,"modified_method":"public Document[] parse() throws Parser.Failure {\n        String supportError = TextParser.supports(url(), this.responseHeader == null ? null : this.responseHeader.mime());\n        if (supportError != null) throw new Parser.Failure(\"no parser support:\" + supportError, url());\n        try {\n            return TextParser.parseSource(url(), this.responseHeader == null ? null : this.responseHeader.mime(), this.responseHeader == null ? \"UTF-8\" : this.responseHeader.getCharacterEncoding(), this.content);\n        } catch (Exception e) {\n            return null;\n        }\n\n    }","commit_id":"ce248cc8dd554009f8604f9a8e4188a5444fa7e2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static Document[] parseSource(\n            final MultiProtocolURI location,\n            final String mimeType,\n            final String charset,\n            final byte[] content\n        ) throws Parser.Failure {\n        return parseSource(location, mimeType, charset, content.length, new ByteArrayInputStream(content));\n    }","id":80147,"modified_method":"public static Document[] parseSource(\n            final MultiProtocolURI location,\n            String mimeType,\n            final String charset,\n            final byte[] content\n        ) throws Parser.Failure {\n        if (log.isFine()) log.logFine(\"Parsing '\" + location + \"' from byte-array\");\n        mimeType = normalizeMimeType(mimeType);\n        List<Parser> idioms = null;\n        try {\n            idioms = parsers(location, mimeType);\n        } catch (final Parser.Failure e) {\n            final String errorMsg = \"Parser Failure for extension '\" + location.getFileExtension() + \"' or mimetype '\" + mimeType + \"': \" + e.getMessage();\n            log.logWarning(errorMsg);\n            throw new Parser.Failure(errorMsg, location);\n        }\n        assert !idioms.isEmpty() : \"no parsers applied for url \" + location.toNormalform(true, false);\n\n        return parseSource(location, mimeType, idioms, charset, content);\n    }","commit_id":"ce248cc8dd554009f8604f9a8e4188a5444fa7e2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static Document[] parseSource(\n            final MultiProtocolURI location,\n            String mimeType,\n            final String charset,\n            final long contentLength,\n            final InputStream sourceStream\n        ) throws Parser.Failure {\n        if (log.isFine()) log.logFine(\"Parsing '\" + location + \"' from stream\");\n        mimeType = normalizeMimeType(mimeType);\n        List<Parser> idioms = null;\n        try {\n            idioms = parsers(location, mimeType);\n        } catch (final Parser.Failure e) {\n            final String errorMsg = \"Parser Failure for extension '\" + location.getFileExtension() + \"' or mimetype '\" + mimeType + \"': \" + e.getMessage();\n            log.logWarning(errorMsg);\n            throw new Parser.Failure(errorMsg, location);\n        }\n        assert !idioms.isEmpty() : \"no parsers applied for url \" + location.toNormalform(true, false);\n\n        // if we do not have more than one parser or the content size is over MaxInt\n        // then we use only one stream-oriented parser.\n        if (idioms.size() == 1 || contentLength > Integer.MAX_VALUE) {\n            // use a specific stream-oriented parser\n            final Document[] docs = parseSource(location, mimeType, idioms.get(0), charset, contentLength, sourceStream);\n            for (final Document d: docs) { assert d.getText() != null; } // verify docs\n            return docs;\n        }\n\n        // in case that we know more parsers we first transform the content into a byte[] and use that as base\n        // for a number of different parse attempts.\n        byte[] b = null;\n        try {\n            b = FileUtils.read(sourceStream, (int) contentLength);\n        } catch (final IOException e) {\n            throw new Parser.Failure(e.getMessage(), location);\n        }\n        final Document[] docs = parseSource(location, mimeType, idioms, charset, b);\n        for (final Document d: docs) { assert d.getText() != null; } // verify docs\n        return docs;\n    }","id":80148,"modified_method":"public static Document[] parseSource(\n            final MultiProtocolURI location,\n            String mimeType,\n            final String charset,\n            final long contentLength,\n            final InputStream sourceStream\n        ) throws Parser.Failure {\n        if (log.isFine()) log.logFine(\"Parsing '\" + location + \"' from stream\");\n        mimeType = normalizeMimeType(mimeType);\n        List<Parser> idioms = null;\n        try {\n            idioms = parsers(location, mimeType);\n        } catch (final Parser.Failure e) {\n            final String errorMsg = \"Parser Failure for extension '\" + location.getFileExtension() + \"' or mimetype '\" + mimeType + \"': \" + e.getMessage();\n            log.logWarning(errorMsg);\n            throw new Parser.Failure(errorMsg, location);\n        }\n        assert !idioms.isEmpty() : \"no parsers applied for url \" + location.toNormalform(true, false);\n\n        // if we do not have more than one parser or the content size is over MaxInt\n        // then we use only one stream-oriented parser.\n        if (idioms.size() == 1 || contentLength > Integer.MAX_VALUE) {\n            // use a specific stream-oriented parser\n            return parseSource(location, mimeType, idioms.get(0), charset, contentLength, sourceStream);\n        }\n\n        // in case that we know more parsers we first transform the content into a byte[] and use that as base\n        // for a number of different parse attempts.\n        byte[] b = null;\n        try {\n            b = FileUtils.read(sourceStream, (int) contentLength);\n        } catch (final IOException e) {\n            throw new Parser.Failure(e.getMessage(), location);\n        }\n        return parseSource(location, mimeType, idioms, charset, b);\n    }","commit_id":"ce248cc8dd554009f8604f9a8e4188a5444fa7e2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static Document[] parseSource(\n            final MultiProtocolURI location,\n            final String mimeType,\n            final List<Parser> parsers,\n            final String charset,\n            final byte[] sourceArray\n        ) throws Parser.Failure {\n        final String fileExt = location.getFileExtension();\n        if (log.isFine()) log.logInfo(\"Parsing \" + location + \" with mimeType '\" + mimeType + \"' and file extension '\" + fileExt + \"' from byte[]\");\n        final String documentCharset = htmlParser.patchCharsetEncoding(charset);\n        assert !parsers.isEmpty();\n\n        Document[] docs = null;\n        final HashMap<Parser, Parser.Failure> failedParser = new HashMap<Parser, Parser.Failure>();\n        if (MemoryControl.request(sourceArray.length * 2, false)) {\n            for (final Parser parser: parsers) {\n                try {\n                    docs = parser.parse(location, mimeType, documentCharset, new ByteArrayInputStream(sourceArray));\n                } catch (final Parser.Failure e) {\n                    failedParser.put(parser, e);\n                    //log.logWarning(\"tried parser '\" + parser.getName() + \"' to parse \" + location.toNormalform(true, false) + \" but failed: \" + e.getMessage(), e);\n                } catch (final Exception e) {\n                    failedParser.put(parser, new Parser.Failure(e.getMessage(), location));\n                    //log.logWarning(\"tried parser '\" + parser.getName() + \"' to parse \" + location.toNormalform(true, false) + \" but failed: \" + e.getMessage(), e);\n                }\n                if (docs != null) break;\n            }\n        }\n\n        if (docs == null) {\n            if (failedParser.isEmpty()) {\n                final String errorMsg = \"Parsing content with file extension '\" + location.getFileExtension() + \"' and mimetype '\" + mimeType + \"' failed.\";\n                //log.logWarning(\"Unable to parse '\" + location + \"'. \" + errorMsg);\n                throw new Parser.Failure(errorMsg, location);\n            } else {\n                String failedParsers = \"\";\n                for (final Map.Entry<Parser, Parser.Failure> error: failedParser.entrySet()) {\n                    log.logWarning(\"tried parser '\" + error.getKey().getName() + \"' to parse \" + location.toNormalform(true, false) + \" but failed: \" + error.getValue().getMessage(), error.getValue());\n                    failedParsers += error.getKey().getName() + \" \";\n                }\n                throw new Parser.Failure(\"All parser failed: \" + failedParsers, location);\n            }\n        }\n        for (final Document d: docs) { assert d.getText() != null : \"mimeType = \" + mimeType; } // verify docs\n        return docs;\n    }","id":80149,"modified_method":"private static Document[] parseSource(\n            final MultiProtocolURI location,\n            final String mimeType,\n            final List<Parser> parsers,\n            final String charset,\n            final byte[] sourceArray\n        ) throws Parser.Failure {\n        final String fileExt = location.getFileExtension();\n        if (log.isFine()) log.logInfo(\"Parsing \" + location + \" with mimeType '\" + mimeType + \"' and file extension '\" + fileExt + \"' from byte[]\");\n        final String documentCharset = htmlParser.patchCharsetEncoding(charset);\n        assert !parsers.isEmpty();\n\n        Document[] docs = null;\n        final HashMap<Parser, Parser.Failure> failedParser = new HashMap<Parser, Parser.Failure>();\n        if (MemoryControl.request(sourceArray.length * 6, false)) {\n            for (final Parser parser: parsers) {\n                try {\n                    docs = parser.parse(location, mimeType, documentCharset, new ByteArrayInputStream(sourceArray));\n                } catch (final Parser.Failure e) {\n                    failedParser.put(parser, e);\n                    //log.logWarning(\"tried parser '\" + parser.getName() + \"' to parse \" + location.toNormalform(true, false) + \" but failed: \" + e.getMessage(), e);\n                } catch (final Exception e) {\n                    failedParser.put(parser, new Parser.Failure(e.getMessage(), location));\n                    //log.logWarning(\"tried parser '\" + parser.getName() + \"' to parse \" + location.toNormalform(true, false) + \" but failed: \" + e.getMessage(), e);\n                }\n                if (docs != null) break;\n            }\n        }\n\n        if (docs == null) {\n            if (failedParser.isEmpty()) {\n                final String errorMsg = \"Parsing content with file extension '\" + location.getFileExtension() + \"' and mimetype '\" + mimeType + \"' failed.\";\n                //log.logWarning(\"Unable to parse '\" + location + \"'. \" + errorMsg);\n                throw new Parser.Failure(errorMsg, location);\n            } else {\n                String failedParsers = \"\";\n                for (final Map.Entry<Parser, Parser.Failure> error: failedParser.entrySet()) {\n                    log.logWarning(\"tried parser '\" + error.getKey().getName() + \"' to parse \" + location.toNormalform(true, false) + \" but failed: \" + error.getValue().getMessage(), error.getValue());\n                    failedParsers += error.getKey().getName() + \" \";\n                }\n                throw new Parser.Failure(\"All parser failed: \" + failedParsers, location);\n            }\n        }\n        for (final Document d: docs) { assert d.getText() != null : \"mimeType = \" + mimeType; } // verify docs\n        return docs;\n    }","commit_id":"ce248cc8dd554009f8604f9a8e4188a5444fa7e2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public TextSnippet(\r\n            final LoaderDispatcher loader,\r\n            final URIMetadataRow.Components comp,\r\n            final HandleSet queryhashes,\r\n            final CacheStrategy cacheStrategy,\r\n            final boolean pre,\r\n            final int snippetMaxLength,\r\n            final int maxDocLen,\r\n            final boolean reindexing) {\r\n        // heise = \"0OQUNU3JSs05\"\r\n        final DigestURI url = comp.url();\r\n        if (queryhashes.isEmpty()) {\r\n            //System.out.println(\"found no queryhashes for URL retrieve \" + url);\r\n            init(url.hash(), null, ResultClass.ERROR_NO_HASH_GIVEN, \"no query hashes given\");\r\n            return;\r\n        }\r\n\r\n        // try to get snippet from snippetCache\r\n        ResultClass source = ResultClass.SOURCE_CACHE;\r\n        final String wordhashes = yacySearch.set2string(queryhashes);\r\n        final String urls = ASCII.String(url.hash());\r\n        String snippetLine = snippetsCache.get(wordhashes, urls);\r\n        if (snippetLine != null) {\r\n            // found the snippet\r\n            init(url.hash(), snippetLine, source, null);\r\n            return;\r\n        }\r\n\r\n\r\n        /* ===========================================================================\r\n         * LOAD RESOURCE DATA\r\n         * =========================================================================== */\r\n        // if the snippet is not in the cache, we can try to get it from the htcache\r\n        final Response response;\r\n        try {\r\n            // first try to get the snippet from metadata\r\n            String loc;\r\n            final boolean noCacheUsage = url.isFile() || url.isSMB() || cacheStrategy == null;\r\n            if (containsAllHashes(loc = comp.dc_title(), queryhashes)) {\r\n                // try to create the snippet from information given in the url itself\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return;\r\n            } else if (containsAllHashes(loc = comp.dc_creator(), queryhashes)) {\r\n                // try to create the snippet from information given in the creator metadata\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return;\r\n            } else if (containsAllHashes(loc = comp.dc_subject(), queryhashes)) {\r\n                // try to create the snippet from information given in the subject metadata\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return;\r\n            } else if (containsAllHashes(loc = comp.url().toNormalform(true, true).replace('-', ' '), queryhashes)) {\r\n                // try to create the snippet from information given in the url\r\n                init(url.hash(), loc, ResultClass.SOURCE_METADATA, null);\r\n                return;\r\n            } else {\r\n                // try to load the resource from the cache\r\n                response = loader == null ? null : loader.load(loader.request(url, true, reindexing), noCacheUsage ? CacheStrategy.NOCACHE : cacheStrategy, Long.MAX_VALUE, true);\r\n                if (response == null) {\r\n                    // in case that we did not get any result we can still return a success when we are not allowed to go online\r\n                    if (cacheStrategy == null || cacheStrategy.mustBeOffline()) {\r\n                        init(url.hash(), null, ResultClass.ERROR_SOURCE_LOADING, \"omitted network load (not allowed), no cache entry\");\r\n                        return;\r\n                    }\r\n\r\n                    // if it is still not available, report an error\r\n                    init(url.hash(), null, ResultClass.ERROR_RESOURCE_LOADING, \"error loading resource from net, no cache entry\");\r\n                    return;\r\n                } else {\r\n                    // place entry on indexing queue\r\n                    Switchboard.getSwitchboard().toIndexer(response);\r\n                    source = ResultClass.SOURCE_WEB;\r\n                }\r\n            }\r\n        } catch (final Exception e) {\r\n            //Log.logException(e);\r\n            init(url.hash(), null, ResultClass.ERROR_SOURCE_LOADING, \"error loading resource: \" + e.getMessage());\r\n            return;\r\n        }\r\n\r\n        /* ===========================================================================\r\n         * PARSE RESOURCE\r\n         * =========================================================================== */\r\n        Document document = null;\r\n        try {\r\n            document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n        } catch (final Parser.Failure e) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, e.getMessage()); // cannot be parsed\r\n            return;\r\n        }\r\n        if (document == null) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, \"parser error/failed\"); // cannot be parsed\r\n            return;\r\n        }\r\n\r\n        /* ===========================================================================\r\n         * COMPUTE SNIPPET\r\n         * =========================================================================== */\r\n        // we have found a parseable non-empty file: use the lines\r\n\r\n        // compute snippet from text\r\n        final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n        if (sentences == null) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_NO_LINES, \"parser returned no sentences\");\r\n            return;\r\n        }\r\n        final SnippetExtractor tsr;\r\n        String textline = null;\r\n        HandleSet remainingHashes = queryhashes;\r\n        try {\r\n            tsr = new SnippetExtractor(sentences, queryhashes, snippetMaxLength);\r\n            textline = tsr.getSnippet();\r\n            remainingHashes =  tsr.getRemainingWords();\r\n        } catch (final UnsupportedOperationException e) {\r\n            init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n            return;\r\n        }\r\n\r\n        // compute snippet from media\r\n        //String audioline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n        //String videoline = computeMediaSnippet(document.getVideolinks(), queryhashes);\r\n        //String appline = computeMediaSnippet(document.getApplinks(), queryhashes);\r\n        //String hrefline = computeMediaSnippet(document.getAnchors(), queryhashes);\r\n        //String imageline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n\r\n        snippetLine = \"\";\r\n        //if (audioline != null) line += (line.length() == 0) ? audioline : \"<br />\" + audioline;\r\n        //if (videoline != null) line += (line.length() == 0) ? videoline : \"<br />\" + videoline;\r\n        //if (appline   != null) line += (line.length() == 0) ? appline   : \"<br />\" + appline;\r\n        //if (hrefline  != null) line += (line.length() == 0) ? hrefline  : \"<br />\" + hrefline;\r\n        if (textline  != null) snippetLine += (snippetLine.length() == 0) ? textline  : \"<br />\" + textline;\r\n\r\n        if (snippetLine == null || !remainingHashes.isEmpty()) {\r\n            init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n            return;\r\n        }\r\n        if (snippetLine.length() > snippetMaxLength) snippetLine = snippetLine.substring(0, snippetMaxLength);\r\n\r\n        // finally store this snippet in our own cache\r\n        snippetsCache.put(wordhashes, urls, snippetLine);\r\n\r\n        document.close();\r\n        init(url.hash(), snippetLine, source, null);\r\n    }","id":80150,"modified_method":"public TextSnippet(\r\n            final LoaderDispatcher loader,\r\n            final URIMetadataRow.Components comp,\r\n            final HandleSet queryhashes,\r\n            final CacheStrategy cacheStrategy,\r\n            final boolean pre,\r\n            final int snippetMaxLength,\r\n            final int maxDocLen,\r\n            final boolean reindexing) {\r\n        // heise = \"0OQUNU3JSs05\"\r\n        final DigestURI url = comp.url();\r\n        if (queryhashes.isEmpty()) {\r\n            //System.out.println(\"found no queryhashes for URL retrieve \" + url);\r\n            init(url.hash(), null, ResultClass.ERROR_NO_HASH_GIVEN, \"no query hashes given\");\r\n            return;\r\n        }\r\n\r\n        // try to get snippet from snippetCache\r\n        ResultClass source = ResultClass.SOURCE_CACHE;\r\n        final String wordhashes = yacySearch.set2string(queryhashes);\r\n        final String urls = ASCII.String(url.hash());\r\n        String snippetLine = snippetsCache.get(wordhashes, urls);\r\n        if (snippetLine != null) {\r\n            // found the snippet\r\n            init(url.hash(), snippetLine, source, null);\r\n            return;\r\n        }\r\n\r\n        Document document = loadDocument(loader, comp, queryhashes, cacheStrategy, url, reindexing, source);\r\n        if (document == null) {\r\n            if (this.error == null) {\r\n            \tinit(url.hash(), null, ResultClass.ERROR_PARSER_FAILED, \"parser error/failed\"); // cannot be parsed\r\n            }\r\n            return;\r\n        }\r\n\r\n        /* ===========================================================================\r\n         * COMPUTE SNIPPET\r\n         * =========================================================================== */\r\n        // we have found a parseable non-empty file: use the lines\r\n\r\n        // compute snippet from text\r\n        final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n        if (sentences == null) {\r\n            init(url.hash(), null, ResultClass.ERROR_PARSER_NO_LINES, \"parser returned no sentences\");\r\n            return;\r\n        }\r\n        final SnippetExtractor tsr;\r\n        String textline = null;\r\n        HandleSet remainingHashes = queryhashes;\r\n        try {\r\n            tsr = new SnippetExtractor(sentences, queryhashes, snippetMaxLength);\r\n            textline = tsr.getSnippet();\r\n            remainingHashes =  tsr.getRemainingWords();\r\n        } catch (final UnsupportedOperationException e) {\r\n            init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n            return;\r\n        }\r\n\r\n        // compute snippet from media\r\n        //String audioline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n        //String videoline = computeMediaSnippet(document.getVideolinks(), queryhashes);\r\n        //String appline = computeMediaSnippet(document.getApplinks(), queryhashes);\r\n        //String hrefline = computeMediaSnippet(document.getAnchors(), queryhashes);\r\n        //String imageline = computeMediaSnippet(document.getAudiolinks(), queryhashes);\r\n\r\n        snippetLine = \"\";\r\n        //if (audioline != null) line += (line.length() == 0) ? audioline : \"<br />\" + audioline;\r\n        //if (videoline != null) line += (line.length() == 0) ? videoline : \"<br />\" + videoline;\r\n        //if (appline   != null) line += (line.length() == 0) ? appline   : \"<br />\" + appline;\r\n        //if (hrefline  != null) line += (line.length() == 0) ? hrefline  : \"<br />\" + hrefline;\r\n        if (textline  != null) snippetLine += (snippetLine.length() == 0) ? textline  : \"<br />\" + textline;\r\n\r\n        if (snippetLine == null || !remainingHashes.isEmpty()) {\r\n            init(url.hash(), null, ResultClass.ERROR_NO_MATCH, \"no matching snippet found\");\r\n            return;\r\n        }\r\n        if (snippetLine.length() > snippetMaxLength) snippetLine = snippetLine.substring(0, snippetMaxLength);\r\n\r\n        // finally store this snippet in our own cache\r\n        snippetsCache.put(wordhashes, urls, snippetLine);\r\n\r\n        document.close();\r\n        init(url.hash(), snippetLine, source, null);\r\n    }","commit_id":"ce248cc8dd554009f8604f9a8e4188a5444fa7e2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void addSubDocuments(final Document[] docs) throws IOException {\n        for (final Document doc: docs) {\n            this.sections.addAll(doc.sections);\n            this.titles.addAll(doc.titles());\n            this.keywords.addAll(doc.getKeywords());\n            for (String d: doc.dc_description()) this.descriptions.add(d);\n\n            if (!(this.text instanceof ByteArrayOutputStream)) {\n                this.text = new ByteArrayOutputStream();\n            }\n            FileUtils.copy(doc.getTextStream(), (ByteArrayOutputStream) this.text);\n\n            this.anchors.addAll(doc.getAnchors());\n            this.rss.putAll(doc.getRSS());\n            this.images.putAll(doc.getImages());\n        }\n    }","id":80151,"modified_method":"/**\n     * Adds the main content of subdocuments to this document.\n     * This is useful if the document is a container for other documents (like zip or other archives)\n     * to make the content of the subdocuments searcheable,\n     * but has only one url (unlike container-urls as rss).\n     *\n     * This is similar to mergeDocuments but directly joins internal content variables,\n     * uses less parsed details and keeps this documents crawl data (like crawldepth, lastmodified)\n     *\n     * @see mergeDocuments()\n     * @param docs to be included\n     * @throws IOException\n     */\n    public void addSubDocuments(final Document[] docs) throws IOException {\n        for (final Document doc: docs) {\n            this.sections.addAll(doc.sections);\n            this.titles.addAll(doc.titles());\n            this.keywords.addAll(doc.getKeywords());\n            for (String d: doc.dc_description()) this.descriptions.add(d);\n\n            if (!(this.text instanceof ByteArrayOutputStream)) {\n                this.text = new ByteArrayOutputStream();\n            }\n            FileUtils.copy(doc.getTextStream(), (ByteArrayOutputStream) this.text);\n\n            this.anchors.addAll(doc.getAnchors());\n            this.rss.putAll(doc.getRSS());\n            this.images.putAll(doc.getImages());\n        }\n    }","commit_id":"e76a90837be0eacef61730886a7dd5d92e1d8d71","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\r\n    public Document[] parse(\r\n            final AnchorURL location,\r\n            final String mimeType,\r\n            final String charset,\r\n            final VocabularyScraper scraper, \r\n            final int timezoneOffset,\r\n            InputStream source) throws Parser.Failure, InterruptedException {\r\n\r\n        final List<Document> docacc = new ArrayList<Document>();\r\n        Document[] subDocs = null;\r\n        final String ext = MultiProtocolURL.getFileExtension(location.getFileName());\r\n        if (ext.equals(\"gz\") || ext.equals(\"tgz\")) {\r\n            try {\r\n                source = new GZIPInputStream(source);\r\n            } catch (final IOException e) {\r\n                throw new Parser.Failure(\"tar parser: \" + e.getMessage(), location);\r\n            }\r\n        }\r\n        TarArchiveEntry entry;\r\n        final TarArchiveInputStream tis = new TarArchiveInputStream(source);\r\n        File tmp = null;\r\n\r\n        // loop through the elements in the tar file and parse every single file inside\r\n        while (true) {\r\n            try {\r\n                entry = tis.getNextTarEntry();\r\n                if (entry == null) break;\r\n                if (entry.isDirectory() || entry.getSize() <= 0) continue;\r\n                final String name = entry.getName();\r\n                final int idx = name.lastIndexOf('.');\r\n                final String mime = TextParser.mimeOf((idx > -1) ? name.substring(idx+1) : \"\");\r\n                try {\r\n                    tmp = FileUtils.createTempFile(this.getClass(), name);\r\n                    FileUtils.copy(tis, tmp, entry.getSize());\r\n                    subDocs = TextParser.parseSource(AnchorURL.newAnchor(location, \"#\" + name), mime, null, scraper, timezoneOffset, 999, tmp);\r\n                    if (subDocs == null) continue;\r\n                    for (final Document d: subDocs) docacc.add(d);\r\n                } catch (final Parser.Failure e) {\r\n                    AbstractParser.log.warn(\"tar parser entry \" + name + \": \" + e.getMessage());\r\n                } finally {\r\n                    if (tmp != null) FileUtils.deletedelete(tmp);\r\n                }\r\n            } catch (final IOException e) {\r\n                AbstractParser.log.warn(\"tar parser:\" + e.getMessage());\r\n                break;\r\n            }\r\n        }\r\n        if (docacc.isEmpty()) return null;\r\n        return docacc.toArray(new Document[docacc.size()]);\r\n    }","id":80152,"modified_method":"@Override\r\n    public Document[] parse(\r\n            final AnchorURL location,\r\n            final String mimeType,\r\n            final String charset,\r\n            final VocabularyScraper scraper, \r\n            final int timezoneOffset,\r\n            InputStream source) throws Parser.Failure, InterruptedException {\r\n\r\n        final String ext = MultiProtocolURL.getFileExtension(location.getFileName());\r\n        if (ext.equals(\"gz\") || ext.equals(\"tgz\")) {\r\n            try {\r\n                source = new GZIPInputStream(source);\r\n            } catch (final IOException e) {\r\n                throw new Parser.Failure(\"tar parser: \" + e.getMessage(), location);\r\n            }\r\n        }\r\n        TarArchiveEntry entry;\r\n        final TarArchiveInputStream tis = new TarArchiveInputStream(source);\r\n        \r\n        // create maindoc for this bzip container\r\n        Document maindoc = new Document(\r\n                    location,\r\n                    mimeType,\r\n                    charset,\r\n                    this,\r\n                    null,\r\n                    null,\r\n                    null,\r\n                    null,\r\n                    null,\r\n                    null,\r\n                    null,\r\n                    0.0d, 0.0d,\r\n                    (Object) null,\r\n                    null,\r\n                    null,\r\n                    null,\r\n                    false,\r\n                    new Date());\r\n        // loop through the elements in the tar file and parse every single file inside\r\n        while (true) {\r\n            try {\r\n                File tmp = null;\r\n                entry = tis.getNextTarEntry();\r\n                if (entry == null) break;\r\n                if (entry.isDirectory() || entry.getSize() <= 0) continue;\r\n                final String name = entry.getName();\r\n                final int idx = name.lastIndexOf('.');\r\n                final String mime = TextParser.mimeOf((idx > -1) ? name.substring(idx+1) : \"\");\r\n                try {\r\n                    tmp = FileUtils.createTempFile(this.getClass(), name);\r\n                    FileUtils.copy(tis, tmp, entry.getSize());\r\n                    final Document[] subDocs = TextParser.parseSource(AnchorURL.newAnchor(location, \"#\" + name), mime, null, scraper, timezoneOffset, 999, tmp);\r\n                    if (subDocs == null) continue;\r\n                    maindoc.addSubDocuments(subDocs);\r\n                } catch (final Parser.Failure e) {\r\n                    AbstractParser.log.warn(\"tar parser entry \" + name + \": \" + e.getMessage());\r\n                } finally {\r\n                    if (tmp != null) FileUtils.deletedelete(tmp);\r\n                }\r\n            } catch (final IOException e) {\r\n                AbstractParser.log.warn(\"tar parser:\" + e.getMessage());\r\n                break;\r\n            }\r\n        }\r\n        return new Document[]{maindoc};\r\n    }","commit_id":"e76a90837be0eacef61730886a7dd5d92e1d8d71","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\r\n    public Document[] parse(\r\n            final AnchorURL location,\r\n            final String mimeType,\r\n            final String charset,\r\n            final VocabularyScraper scraper, \r\n            final int timezoneOffset,\r\n            final InputStream source)\r\n            throws Parser.Failure, InterruptedException {\r\n        // check memory for parser\r\n        if (!MemoryControl.request(200 * 1024 * 1024, false))\r\n            throw new Parser.Failure(\"Not enough Memory available for zip parser: \" + MemoryControl.available(), location);\r\n\r\n         Document[] docs = null;\r\n        final List<Document> docacc = new ArrayList<Document>();\r\n        ZipEntry entry;\r\n        final ZipInputStream zis = new ZipInputStream(source);\r\n        File tmp = null;\r\n\r\n        // loop through the elements in the zip file and parse every single file inside\r\n        while (true) {\r\n            try {\r\n                if (zis.available() <= 0) break;\r\n                entry = zis.getNextEntry();\r\n                if (entry == null) break;\r\n                if (entry.isDirectory() || entry.getSize() <= 0) continue;\r\n                final String name = entry.getName();\r\n                final int idx = name.lastIndexOf('.');\r\n                final String mime = TextParser.mimeOf((idx >= 0) ? name.substring(idx + 1) : \"\");\r\n                try {\r\n                    tmp = FileUtils.createTempFile(this.getClass(), name);\r\n                    FileUtils.copy(zis, tmp, entry.getSize());\r\n                    final DigestURL virtualURL = DigestURL.newURL(location, \"#\" + name);\r\n                    //this.log.logInfo(\"ZIP file parser: \" + virtualURL.toNormalform(false, false));\r\n                    docs = TextParser.parseSource(new AnchorURL(virtualURL), mime, null, scraper, timezoneOffset, 999, tmp);\r\n                    if (docs == null) continue;\r\n                    for (final Document d: docs) docacc.add(d);\r\n                } catch (final Parser.Failure e) {\r\n                    AbstractParser.log.warn(\"ZIP parser entry \" + name + \": \" + e.getMessage());\r\n                } finally {\r\n                    if (tmp != null) FileUtils.deletedelete(tmp);\r\n                }\r\n            } catch (final IOException e) {\r\n                AbstractParser.log.warn(\"ZIP parser:\" + e.getMessage());\r\n                break;\r\n            }\r\n        }\r\n        if (docacc.isEmpty()) return null;\r\n        return docacc.toArray(new Document[docacc.size()]);\r\n    }","id":80153,"modified_method":"@Override\r\n    public Document[] parse(\r\n            final AnchorURL location,\r\n            final String mimeType,\r\n            final String charset,\r\n            final VocabularyScraper scraper, \r\n            final int timezoneOffset,\r\n            final InputStream source)\r\n            throws Parser.Failure, InterruptedException {\r\n        // check memory for parser\r\n        if (!MemoryControl.request(200 * 1024 * 1024, false))\r\n            throw new Parser.Failure(\"Not enough Memory available for zip parser: \" + MemoryControl.available(), location);\r\n\r\n        ZipEntry entry;\r\n        final ZipInputStream zis = new ZipInputStream(source);\r\n        // create maindoc for this zip container with supplied url and mime\r\n        Document maindoc = new Document(\r\n                location,\r\n                mimeType,\r\n                charset,\r\n                this,\r\n                null,\r\n                null,\r\n                null,\r\n                null,\r\n                null,\r\n                null,\r\n                null,\r\n                0.0d, 0.0d,\r\n                (Object)null,\r\n                null,\r\n                null,\r\n                null,\r\n                false,\r\n                new Date());\r\n\r\n        // loop through the elements in the zip file and parse every single file inside\r\n        while (true) {\r\n            try {\r\n                File tmp = null;\r\n                if (zis.available() <= 0) break;\r\n                entry = zis.getNextEntry();\r\n                if (entry == null) break;\r\n                if (entry.isDirectory() || entry.getSize() <= 0) continue;\r\n                final String name = entry.getName();\r\n                final int idx = name.lastIndexOf('.');\r\n                final String mime = TextParser.mimeOf((idx >= 0) ? name.substring(idx + 1) : \"\");\r\n                try {\r\n                    tmp = FileUtils.createTempFile(this.getClass(), name);\r\n                    FileUtils.copy(zis, tmp, entry.getSize());\r\n                    final DigestURL virtualURL = DigestURL.newURL(location, \"#\" + name);\r\n                    //this.log.logInfo(\"ZIP file parser: \" + virtualURL.toNormalform(false, false));\r\n                    final Document[] docs = TextParser.parseSource(new AnchorURL(virtualURL), mime, null, scraper, timezoneOffset, 999, tmp);\r\n                    if (docs == null) continue;\r\n                    maindoc.addSubDocuments(docs);\r\n                } catch (final Parser.Failure e) {\r\n                    AbstractParser.log.warn(\"ZIP parser entry \" + name + \": \" + e.getMessage());\r\n                } finally {\r\n                    if (tmp != null) FileUtils.deletedelete(tmp);\r\n                }\r\n            } catch (final IOException e) {\r\n                AbstractParser.log.warn(\"ZIP parser:\" + e.getMessage());\r\n                break;\r\n            }\r\n        }\r\n        return new Document[]{maindoc};\r\n    }","commit_id":"e76a90837be0eacef61730886a7dd5d92e1d8d71","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void checkNameSpace(String contentName, boolean expected) throws Exception {\n\t\tContentName name = ContentName.fromNative(contentName);\n\t\tRepositoryOutputStream ros = putLibrary.repoOpen(name, null, putLibrary.getDefaultPublisher());\n\t\tbyte [] data = \"Testing 1 2 3\".getBytes();\n\t\tros.write(data, 0, data.length);\n\t\ttry {\n\t\t\tros.close();\n\t\t} catch (IOException ex) {}\t// File not put causes an I/O exception\n\t}","id":80154,"modified_method":"protected void checkNameSpace(String contentName, boolean expected) throws Exception {\n\t\tContentName name = ContentName.fromNative(contentName);\n\t\tRepositoryOutputStream ros = new RepositoryOutputStream(name, putLibrary); \n\t\tbyte [] data = \"Testing 1 2 3\".getBytes();\n\t\tros.write(data, 0, data.length);\n\t\ttry {\n\t\t\tros.close();\n\t\t} catch (IOException ex) {}\t// File not put causes an I/O exception\n\t}","commit_id":"ca7da7ab08e4ed5533df37bf6560a973e32f9807","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@BeforeClass\n\tpublic static void setUpBeforeClass() throws Exception {\n\t\t//Library.logger().setLevel(Level.FINEST);\n\t\tRepoTestBase.setUpBeforeClass();\n\t\tbyte value = 1;\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tdata[i] = value++;\n\t\tRepositoryOutputStream ros = putLibrary.repoOpen(ContentName.fromNative(\"/testNameSpace/stream\"), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull, putLibrary.getDefaultPublisher());\n\t\tros.setBlockSize(100);\n\t\tros.setTimeout(4000);\n\t\tros.write(data, 0, data.length);\n\t\tros.close();\n\t}","id":80155,"modified_method":"@BeforeClass\n\tpublic static void setUpBeforeClass() throws Exception {\n\t\t//Library.logger().setLevel(Level.FINEST);\n\t\tRepoTestBase.setUpBeforeClass();\n\t\tbyte value = 1;\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tdata[i] = value++;\n\t\tRepositoryOutputStream ros = new RepositoryOutputStream(ContentName.fromNative(\"/testNameSpace/stream\"), putLibrary); \n\t\tros.setBlockSize(100);\n\t\tros.setTimeout(4000);\n\t\tros.write(data, 0, data.length);\n\t\tros.close();\n\t}","commit_id":"ca7da7ab08e4ed5533df37bf6560a973e32f9807","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void addContentToRepo(ContentName name){\n\t\ttry{\n\t\t\tRepositoryOutputStream ros = putLibrary.repoOpen(name, null, putLibrary.getDefaultPublisher());\n\t\t\tros.setTimeout(5000);\n\t\t\tbyte [] data = \"Testing 1 2 3\".getBytes();\n\t\t\tros.write(data, 0, data.length);\n\t\t\tros.close();\n\t\t} catch (IOException ex) {\n\t\t\tex.printStackTrace();\n\t\t\tAssert.fail(\"could not put the content into the repo (\"+name+\"); \" + ex.getMessage());\n\t\t} catch (XMLStreamException e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(\"Could not open repo output stream for test.\");\n\t\t}\n\t}","id":80156,"modified_method":"private void addContentToRepo(ContentName name){\n\t\ttry{\n\t\t\tRepositoryOutputStream ros = new RepositoryOutputStream(name, putLibrary);\n\t\t\tros.setTimeout(5000);\n\t\t\tbyte [] data = \"Testing 1 2 3\".getBytes();\n\t\t\tros.write(data, 0, data.length);\n\t\t\tros.close();\n\t\t} catch (IOException ex) {\n\t\t\tex.printStackTrace();\n\t\t\tAssert.fail(\"could not put the content into the repo (\"+name+\"); \" + ex.getMessage());\n\t\t} \n\t}","commit_id":"ca7da7ab08e4ed5533df37bf6560a973e32f9807","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Publish a piece of named content signed by our default identity in \n\t * response to an already-received Interest. The first block of Data\n\t * will be written immediately, if name matches this Interest; otherwise\n\t * both Data and Interest will be held pending later matches.\n\t * @param name name for content.\n\t * @param content content to publish; will be fragmented if necessary.\n\t * @param outstandingInterest an Interest, usually recieved by the handleInterests\n\t * \tmethod of a CCNFilterListener. Only one responder should write data\n\t * \tin response to a given Interest. The Interest should ideally have been\n\t * \treceived on the same CCNHandle used by this CCNWriter to write data.\n\t * @throws SignatureException if there is a problem signing.\n\t * @throws IOException if there is a problem writing data.\n\t */\t\n\tpublic ContentName put(ContentName name, byte[] content, Interest outstandingInterest) throws SignatureException, IOException {\n\t\treturn put(name, content, null, null, null, outstandingInterest);\n\t}","id":80157,"modified_method":"/**\n\t * Publish a piece of named content signed by our default identity in \n\t * response to an already-received Interest. The first block of Data\n\t * will be written immediately, if name matches this Interest; otherwise\n\t * both Data and Interest will be held pending later matches.\n\t * @param name name for content.\n\t * @param content content to publish; will be fragmented if necessary.\n\t * @param outstandingInterest an Interest, usually recieved by the handleInterests\n\t * \tmethod of a CCNFilterListener. Only one responder should write data\n\t * \tin response to a given Interest. The Interest should ideally have been\n\t * \treceived on the same CCNHandle used by this CCNWriter to write data.\n\t * @throws SignatureException if there is a problem signing.\n\t * @throws IOException if there is a problem writing data.\n\t */\t\n\tpublic ContentName put(ContentName name, byte[] content, Interest outstandingInterest) throws SignatureException, IOException {\n\t\treturn put(name, content, null, null, null, null, outstandingInterest);\n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Publish a piece of named content signed by a particular identity.\n\t * @param name name for content.\n\t * @param content content to publish; will be fragmented if necessary\n\t * @param type type to specify for content. If null, DATA will be used. (see ContentType).\n\t * @param publisher selects one of our identities to publish under\n\t * @param freshnessSeconds how long the content should be considered valid in the cache.\n\t * @throws SignatureException if there is a problem signing.\n\t * @throws IOException if there is a problem writing data.\n\t */\n\tpublic ContentName put(ContentName name, byte[] content, \n\t\t\tSignedInfo.ContentType type,\n\t\t\tPublisherPublicKeyDigest publisher,\n\t\t\tInteger freshnessSeconds) throws SignatureException, IOException {\n\t\treturn put(name, content, type, publisher, freshnessSeconds, null);\n\t}","id":80158,"modified_method":"/**\n\t * Publish a piece of named content signed by a particular identity.\n\t * @param name name for content.\n\t * @param content content to publish; will be fragmented if necessary\n\t * @param type type to specify for content. If null, DATA will be used. (see ContentType).\n\t * @param publisher selects one of our identities to publish under\n\t * @param freshnessSeconds how long the content should be considered valid in the cache.\n\t * @throws SignatureException if there is a problem signing.\n\t * @throws IOException if there is a problem writing data.\n\t */\n\tpublic ContentName put(ContentName name, byte[] content, \n\t\t\tSignedInfo.ContentType type,\n\t\t\tPublisherPublicKeyDigest publisher,\n\t\t\tInteger freshnessSeconds) throws SignatureException, IOException {\n\t\treturn put(name, content, type, publisher, null, freshnessSeconds, null);\n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Publish a piece of named content signed by a particular identity.\n\t * @param name name for content.\n\t * @param content content to publish; will be fragmented if necessary\n\t * @param type type to specify for content. If null, DATA will be used. (see ContentType).\n\t * @param publisher selects one of our identities to publish under\n\t * @param freshnessSeconds how long the content should be considered valid in the cache.\n\t * @param outstandingInterest an interest this data is being written in response to. If the\n\t * \tname matches the Interest, the first Data segment of the content will be written immediately.\n\t *   Otherwise both Interest and Data will be cached.\n\t * @throws SignatureException if there is a problem signing.\n\t * @throws IOException if there is a problem writing data.\n\t */\n\tpublic ContentName put(ContentName name, byte[] content, \n\t\t\tSignedInfo.ContentType type,\n\t\t\tPublisherPublicKeyDigest publisher,\n\t\t\tInteger freshnessSeconds,\n\t\t\tInterest outstandingInterest) throws SignatureException, IOException {\n\t\ttry {\n\t\t\taddOutstandingInterest(outstandingInterest);\n\t\t\t_segmenter.put(name, content, 0, ((null == content) ? 0 : content.length),\n\t\t\t\t\t\t\t\t  true, type, freshnessSeconds, null, publisher);\n\t\t\treturn name;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tLog.info(\"InvalidKeyException using key for publisher \" + publisher + \".\");\n\t\t\tthrow new SignatureException(e);\n\t\t} catch (SignatureException e) {\n\t\t\tLog.info(\"SignatureException using key for publisher \" + publisher + \".\");\n\t\t\tthrow e;\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tLog.info(\"NoSuchAlgorithmException using key for publisher \" + publisher + \".\");\n\t\t\tthrow new SignatureException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Cannot encrypt content -- bad algorithm parameter!: \" + e.getMessage());\n\t\t} \n\t}","id":80159,"modified_method":"/**\n\t * Publish a piece of named content signed by a particular identity.\n\t * @param name name for content.\n\t * @param content content to publish; will be fragmented if necessary\n\t * @param type type to specify for content. If null, DATA will be used. (see ContentType).\n\t * @param publisher selects one of our identities to publish under\n\t * @param freshnessSeconds how long the content should be considered valid in the cache.\n\t * @param outstandingInterest an interest this data is being written in response to. If the\n\t * \tname matches the Interest, the first Data segment of the content will be written immediately.\n\t *   Otherwise both Interest and Data will be cached.\n\t * @throws SignatureException if there is a problem signing.\n\t * @throws IOException if there is a problem writing data.\n\t */\n\tpublic ContentName put(ContentName name, byte[] content, \n\t\t\tSignedInfo.ContentType type,\n\t\t\tPublisherPublicKeyDigest publisher,\n\t\t\tKeyLocator locator, \n\t\t\tInteger freshnessSeconds,\n\t\t\tInterest outstandingInterest) throws SignatureException, IOException {\n\t\ttry {\n\t\t\taddOutstandingInterest(outstandingInterest);\n\t\t\t_segmenter.getFlowControl().addNameSpace(name);\n\t\t\t_segmenter.getFlowControl().startWrite(name, Shape.STREAM); // Streams take care of this for the non-gone case.\n\t\t\t_segmenter.put(name, content, 0, ((null == content) ? 0 : content.length),\n\t\t\t\t\t\t\t\t  true, type, freshnessSeconds, locator, publisher);\n\t\t\t_segmenter.getFlowControl().beforeClose();\n\t\t\t_segmenter.getFlowControl().afterClose();\n\t\t\treturn name;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tLog.info(\"InvalidKeyException using key for publisher \" + publisher + \".\");\n\t\t\tthrow new SignatureException(e);\n\t\t} catch (SignatureException e) {\n\t\t\tLog.info(\"SignatureException using key for publisher \" + publisher + \".\");\n\t\t\tthrow e;\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tLog.info(\"NoSuchAlgorithmException using key for publisher \" + publisher + \".\");\n\t\t\tthrow new SignatureException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Cannot encrypt content -- bad algorithm parameter!: \" + e.getMessage());\n\t\t} \n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Construct a writer that will decide later what namespace is should write into\n\t * @param handle The ccn context it will use to write, if null one will be created with CCNHandle#open().\n\t * @throws IOException If network initialization fails.\n\t */\n\tpublic CCNWriter(CCNHandle handle) throws IOException {\n\t\tthis(new CCNFlowControl(handle));\n\t}","id":80160,"modified_method":"/**\n\t * Construct a writer that will decide later what namespace is should write into\n\t * @param handle The ccn context it will use to write, if null one will be created with CCNHandle#open().\n\t * @throws IOException If network initialization fails.\n\t */\n\tpublic CCNWriter(CCNHandle handle) throws IOException {\n\t\tthis((ContentName)null, handle);\n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Construct a writer that will write content into a certain namespace. Names specified\n\t * in calls to put should be descendants of this namespace.\n\t * @param namespace The parent namespace this writer will write to as a file path-style string version\n\t * \t\tof a name (for example /org/ccnx/test).\n\t * @param handle The ccn context it will use to write, if null one will be created with CCNHandle#open().\n\t * @throws MalformedContentNameStringException If namespace cannot be parsed. \n\t * @throws IOException If network initialization fails.\n\t */\n\tpublic CCNWriter(String namespace, CCNHandle handle) throws MalformedContentNameStringException, IOException {\n\t\tthis(new CCNFlowControl(ContentName.fromNative(namespace), handle));\n\t}","id":80161,"modified_method":"/**\n\t * Construct a writer that will write content into a certain namespace. Names specified\n\t * in calls to put should be descendants of this namespace.\n\t * @param namespace The parent namespace this writer will write to as a file path-style string version\n\t * \t\tof a name (for example /org/ccnx/test).\n\t * @param handle The ccn context it will use to write, if null one will be created with CCNHandle#open().\n\t * @throws MalformedContentNameStringException If namespace cannot be parsed. \n\t * @throws IOException If network initialization fails.\n\t */\n\tpublic CCNWriter(String namespace, CCNHandle handle) throws MalformedContentNameStringException, IOException {\n\t\tthis(ContentName.fromNative(namespace), handle);\n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Publishes a piece of content as a new version of a given name.\n\t * @param name The (unversioned) name to publish under.\n\t * @param content The content to publish, which will be segmented if necessary.\n\t * @param type The type to publish the content as.\n\t * @param locator The key locator to used to help consumers find the key used to sign.\n\t * @param publisher Specifies what key the content should be signed by.\n\t * @throws SignatureException if cannot sign\n\t * @throws InvalidKeyException if cannot sign with specified key.\n\t * @throws NoSuchAlgorithmException if algorithm specified does not exist.\n\t * @throws IOException if cannot write data successfully.\n\t * @throws InvalidAlgorithmParameterException if there is a problem with the cryptographic parameters.\n\t */\n\tpublic ContentName newVersion(\n\t\t\tContentName name, byte [] content,\n\t\t\tContentType type,\n\t\t\tKeyLocator locator, PublisherPublicKeyDigest publisher) throws SignatureException, \n\t\t\tInvalidKeyException, NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException {\n\t\t\n\t\t// Construct new name\n\t\t// <name>/<VERSION_MARKER><version_number>\n\t\tContentName versionedName = VersioningProfile.addVersion(name);\n\n\t\t// put result; segmenter will fill in defaults\n\t\t_segmenter.put(versionedName, content, 0, ((null == content) ? 0 : content.length),\n\t\t\t\t\t\t\t  true,\n\t\t\t\t \t\t\t  type, null, locator, publisher);\n\t\treturn versionedName;\n\t}","id":80162,"modified_method":"/**\n\t * Publishes a piece of content as a new version of a given name.\n\t * @param name The (unversioned) name to publish under.\n\t * @param content The content to publish, which will be segmented if necessary.\n\t * @param type The type to publish the content as.\n\t * @param locator The key locator to used to help consumers find the key used to sign.\n\t * @param publisher Specifies what key the content should be signed by.\n\t * @throws SignatureException if cannot sign\n\t * @throws InvalidKeyException if cannot sign with specified key.\n\t * @throws NoSuchAlgorithmException if algorithm specified does not exist.\n\t * @throws IOException if cannot write data successfully.\n\t * @throws InvalidAlgorithmParameterException if there is a problem with the cryptographic parameters.\n\t */\n\tpublic ContentName newVersion(\n\t\t\tContentName name, byte [] content,\n\t\t\tContentType type,\n\t\t\tKeyLocator locator, PublisherPublicKeyDigest publisher) throws SignatureException, \n\t\t\tInvalidKeyException, NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException {\n\t\t\n\t\t// Construct new name\n\t\t// <name>/<VERSION_MARKER><version_number>\n\t\tContentName versionedName = VersioningProfile.addVersion(name);\n\n\t\t// put result; segmenter will fill in defaults\n\t\treturn put(versionedName, content, type, publisher, locator, null, null);\n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Construct a writer that will write content into a certain namespace. Names specified\n\t * in calls to put should be descendants of this namespace.\n\t * @param namespace The parent namespace this writer will write to.\n\t * @param handle The ccn context it will use to write, if null one will be created with CCNHandle#open().\n\t * @throws MalformedContentNameStringException If namespace cannot be parsed. \n\t * @throws IOException If network initialization fails.\n\t */\n\tpublic CCNWriter(ContentName namespace, CCNHandle handle) throws IOException {\n\t\tthis(new CCNFlowControl(namespace, handle));\n\t}","id":80163,"modified_method":"/**\n\t * Construct a writer that will write content into a certain namespace. Names specified\n\t * in calls to put should be descendants of this namespace.\n\t * @param namespace The parent namespace this writer will write to.\n\t * @param handle The ccn context it will use to write, if null one will be created with CCNHandle#open().\n\t * @throws MalformedContentNameStringException If namespace cannot be parsed. \n\t * @throws IOException If network initialization fails.\n\t */\n\tpublic CCNWriter(ContentName namespace, CCNHandle handle) throws IOException {\n\t\t_segmenter = new CCNSegmenter(getFlowController(namespace, handle));\n\t}","commit_id":"9468349611cf3f7d7cdf70426bc685c90067c6af","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static boolean baseMappingRule_Condition_3668957831723418687(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:308041c6-80bc-4e26-b4b1-473fd45c9339(jetbrains.mps.make.script.structure)\", \"Feedback\"), \"error\")) == SPropertyOperations.getString_def(_context.getNode(), \"feedback\", \"INFO\");\n  }","id":80164,"modified_method":"public static boolean baseMappingRule_Condition_3668957831723418687(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:308041c6-80bc-4e26-b4b1-473fd45c9339(jetbrains.mps.make.script.structure)\", \"Feedback\"), \"error\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"feedback\", \"INFO\"));\n  }","commit_id":"ee8c11c60ee6e1df6c5028bb36dd47a222c32662","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_3668957831723397506(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:308041c6-80bc-4e26-b4b1-473fd45c9339(jetbrains.mps.make.script.structure)\", \"Feedback\"), \"info\")) == SPropertyOperations.getString_def(_context.getNode(), \"feedback\", \"INFO\");\n  }","id":80165,"modified_method":"public static boolean baseMappingRule_Condition_3668957831723397506(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:308041c6-80bc-4e26-b4b1-473fd45c9339(jetbrains.mps.make.script.structure)\", \"Feedback\"), \"info\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"feedback\", \"INFO\"));\n  }","commit_id":"ee8c11c60ee6e1df6c5028bb36dd47a222c32662","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_3668957831723418661(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:308041c6-80bc-4e26-b4b1-473fd45c9339(jetbrains.mps.make.script.structure)\", \"Feedback\"), \"warning\")) == SPropertyOperations.getString_def(_context.getNode(), \"feedback\", \"INFO\");\n  }","id":80166,"modified_method":"public static boolean baseMappingRule_Condition_3668957831723418661(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:308041c6-80bc-4e26-b4b1-473fd45c9339(jetbrains.mps.make.script.structure)\", \"Feedback\"), \"warning\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"feedback\", \"INFO\"));\n  }","commit_id":"ee8c11c60ee6e1df6c5028bb36dd47a222c32662","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void onWindowUpdate(ISession session, IStream stream, WindowUpdateFrame frame)\n    {\n        if (frame.getStreamId() > 0)\n        {\n            if (stream != null)\n                stream.updateWindowSize(frame.getWindowDelta());\n        }\n        else\n        {\n            session.updateWindowSize(frame.getWindowDelta());\n        }\n    }","id":80167,"modified_method":"@Override\n    public void onWindowUpdate(ISession session, IStream stream, WindowUpdateFrame frame)\n    {\n        int delta = frame.getWindowDelta();\n        if (frame.getStreamId() > 0)\n        {\n            if (stream != null)\n            {\n                int oldSize = stream.updateWindowSize(delta);\n                LOG.debug(\"Updated stream window {} -> {} for {}\", oldSize, oldSize + delta, stream);\n            }\n        }\n        else\n        {\n            int oldSize = session.updateWindowSize(frame.getWindowDelta());\n            LOG.debug(\"Updated session window {} -> {} for {}\", oldSize, oldSize + delta, session);\n        }\n    }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onDataConsumed(ISession session, IStream stream, int length)\n    {\n        // This is the algorithm for flow control.\n        // This method is called when a whole flow controlled frame has been consumed.\n        // We currently send a WindowUpdate every time, even if the frame was very small.\n        // Other policies may send the WindowUpdate only upon reaching a threshold.\n\n        LOG.debug(\"Consumed {} on {}\", length, stream);\n        // Negative streamId allow for generation of bytes for both stream and session\n        int streamId = stream != null ? -stream.getId() : 0;\n        WindowUpdateFrame frame = new WindowUpdateFrame(streamId, length);\n        session.frame(stream, frame, Callback.Adapter.INSTANCE);\n    }","id":80168,"modified_method":"@Override\n    public void onDataConsumed(ISession session, IStream stream, int length)\n    {\n        // This is the algorithm for flow control.\n        // This method is called when a whole flow controlled frame has been consumed.\n        // We currently send a WindowUpdate every time, even if the frame was very small.\n        // Other policies may send the WindowUpdate only upon reaching a threshold.\n\n        LOG.debug(\"Data consumed, increasing window by {} for {}\", length, stream);\n        // Negative streamId allow for generation of bytes for both stream and session\n        int streamId = stream != null ? -stream.getId() : 0;\n        WindowUpdateFrame frame = new WindowUpdateFrame(streamId, length);\n        session.frame(stream, frame, Callback.Adapter.INSTANCE);\n    }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void updateInitialWindowSize(ISession session, int initialWindowSize)\n    {\n        int windowSize = this.initialWindowSize;\n        this.initialWindowSize = initialWindowSize;\n\n        int delta = initialWindowSize - windowSize;\n\n        // Update the sessions's window size.\n        session.updateWindowSize(delta);\n\n        // Update the streams' window size.\n        for (Stream stream : session.getStreams())\n            ((IStream)stream).updateWindowSize(delta);\n    }","id":80169,"modified_method":"@Override\n    public void updateInitialWindowSize(ISession session, int initialWindowSize)\n    {\n        int windowSize = this.initialWindowSize;\n        this.initialWindowSize = initialWindowSize;\n\n        int delta = initialWindowSize - windowSize;\n\n        // Update the sessions's window size.\n        int oldSize = session.updateWindowSize(delta);\n        LOG.debug(\"Updated session initial window {} -> {} for {}\", oldSize, oldSize + delta, session);\n\n        // Update the streams' window size.\n        for (Stream stream : session.getStreams())\n        {\n            oldSize = ((IStream)stream).updateWindowSize(delta);\n            LOG.debug(\"Updated stream initial window {} -> {} for {}\", oldSize, oldSize + delta, stream);\n        }\n    }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onDataSent(ISession session, IStream stream, int length)\n    {\n        session.updateWindowSize(length);\n        if (stream != null)\n            stream.updateWindowSize(length);\n    }","id":80170,"modified_method":"@Override\n    public void onDataSent(ISession session, IStream stream, int length)\n    {\n        if (length == 0)\n            return;\n\n        LOG.debug(\"Data sent, decreasing window by {}\", length);\n        int oldSize = session.updateWindowSize(-length);\n        LOG.debug(\"Updated session window {} -> {} for {}\", oldSize, oldSize - length, session);\n        if (stream != null)\n        {\n            oldSize = stream.updateWindowSize(-length);\n            LOG.debug(\"Updated stream window {} -> {} for {}\", oldSize, oldSize - length, stream);\n        }\n    }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            flowControl.onDataSent(HTTP2Session.this, stream, -length);\n            // Do we have more to send ?\n            if (frame.getFlowControlledLength() > 0)\n            {\n                // We have written part of the frame, but there is more to write.\n                // We need to keep the correct ordering of frames, to avoid that other\n                // frames for the same stream are written before this one is finished.\n                flusher.prepend(this);\n            }\n            else\n            {\n                callback.succeeded();\n                // TODO: what below is needed ? YES IT IS.\n//                stream.updateCloseState(dataInfo.isClose(), true);\n//                if (stream.isClosed())\n//                    removeStream(stream);\n            }\n        }","id":80171,"modified_method":"@Override\n        public void succeeded()\n        {\n            flowControl.onDataSent(HTTP2Session.this, stream, length);\n            // Do we have more to send ?\n            if (frame.getFlowControlledLength() > 0)\n            {\n                // We have written part of the frame, but there is more to write.\n                // We need to keep the correct ordering of frames, to avoid that other\n                // frames for the same stream are written before this one is finished.\n                flusher.prepend(this);\n            }\n            else\n            {\n                callback.succeeded();\n                // TODO: what below is needed ? YES IT IS.\n//                stream.updateCloseState(dataInfo.isClose(), true);\n//                if (stream.isClosed())\n//                    removeStream(stream);\n            }\n        }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        protected Action process() throws Exception\n        {\n            synchronized (queue)\n            {\n                if (closed)\n                    return Action.IDLE;\n\n                int sessionWindow = getWindowSize();\n                int nonStalledIndex = 0;\n                int size = queue.size();\n                while (nonStalledIndex < size)\n                {\n                    FlusherEntry entry = queue.get(nonStalledIndex);\n                    IStream stream = entry.stream;\n                    int frameWindow = entry.frame.getFlowControlledLength();\n                    if (frameWindow > 0)\n                    {\n                        // Is the session stalled ?\n                        if (sessionWindow <= 0)\n                        {\n                            HTTP2FlowControl.LOG.debug(\"Session stalled {}\", HTTP2Session.this);\n                            ++nonStalledIndex;\n                            // There may be *non* flow controlled frames to send.\n                            continue;\n                        }\n\n                        if (stream != null)\n                        {\n                            Integer streamWindow = streams.get(stream);\n                            if (streamWindow == null)\n                            {\n                                streamWindow = stream.getWindowSize();\n                                streams.put(stream, streamWindow);\n                            }\n\n                            // Is it a frame belonging to an already stalled stream ?\n                            if (streamWindow <= 0)\n                            {\n                                HTTP2FlowControl.LOG.debug(\"Stream stalled {}\", stream);\n                                ++nonStalledIndex;\n                                continue;\n                            }\n                        }\n                    }\n\n                    // We will be possibly writing this frame.\n                    queue.remove(nonStalledIndex);\n                    --size;\n\n                    // If the stream has been reset, don't send flow controlled frames.\n                    if (stream != null && stream.isReset() && frameWindow > 0)\n                    {\n                        reset.add(entry);\n                        continue;\n                    }\n\n                    // Reduce the flow control windows.\n                    sessionWindow -= frameWindow;\n                    if (stream != null && frameWindow > 0)\n                        streams.put(stream, streams.get(stream) - frameWindow);\n\n                    active.add(entry);\n                    if (active.size() == maxGather)\n                        break;\n                }\n                streams.clear();\n            }\n\n            for (int i = 0; i < reset.size(); ++i)\n            {\n                FlusherEntry entry = reset.get(i);\n                // TODO: introduce a StreamResetException ?\n                entry.failed(new IllegalStateException());\n            }\n            reset.clear();\n\n            if (active.isEmpty())\n                return Action.IDLE;\n\n            for (int i = 0; i < active.size(); ++i)\n            {\n                FlusherEntry entry = active.get(i);\n                entry.generate(lease);\n            }\n\n            List<ByteBuffer> byteBuffers = lease.getByteBuffers();\n            endPoint.write(this, byteBuffers.toArray(new ByteBuffer[byteBuffers.size()]));\n            return Action.SCHEDULED;\n        }","id":80172,"modified_method":"@Override\n        protected Action process() throws Exception\n        {\n            synchronized (queue)\n            {\n                if (closed)\n                    return Action.IDLE;\n\n                int sessionWindow = getWindowSize();\n                int nonStalledIndex = 0;\n                int size = queue.size();\n                while (nonStalledIndex < size)\n                {\n                    FlusherEntry entry = queue.get(nonStalledIndex);\n                    IStream stream = entry.stream;\n                    int frameWindow = entry.frame.getFlowControlledLength();\n                    if (frameWindow > 0)\n                    {\n                        // Is the session stalled ?\n                        if (sessionWindow <= 0)\n                        {\n                            flowControl.onSessionStalled(HTTP2Session.this);\n                            ++nonStalledIndex;\n                            // There may be *non* flow controlled frames to send.\n                            continue;\n                        }\n\n                        if (stream != null)\n                        {\n                            Integer streamWindow = streams.get(stream);\n                            if (streamWindow == null)\n                            {\n                                streamWindow = stream.getWindowSize();\n                                streams.put(stream, streamWindow);\n                            }\n\n                            // Is it a frame belonging to an already stalled stream ?\n                            if (streamWindow <= 0)\n                            {\n                                flowControl.onStreamStalled(stream);\n                                ++nonStalledIndex;\n                                continue;\n                            }\n                        }\n                    }\n\n                    // We will be possibly writing this frame.\n                    queue.remove(nonStalledIndex);\n                    --size;\n\n                    // If the stream has been reset, don't send flow controlled frames.\n                    if (stream != null && stream.isReset() && frameWindow > 0)\n                    {\n                        reset.add(entry);\n                        continue;\n                    }\n\n                    // Reduce the flow control windows.\n                    sessionWindow -= frameWindow;\n                    if (stream != null && frameWindow > 0)\n                        streams.put(stream, streams.get(stream) - frameWindow);\n\n                    active.add(entry);\n                    if (active.size() == maxGather)\n                        break;\n                }\n                streams.clear();\n            }\n\n            for (int i = 0; i < reset.size(); ++i)\n            {\n                FlusherEntry entry = reset.get(i);\n                // TODO: introduce a StreamResetException ?\n                entry.failed(new IllegalStateException());\n            }\n            reset.clear();\n\n            if (active.isEmpty())\n                return Action.IDLE;\n\n            for (int i = 0; i < active.size(); ++i)\n            {\n                FlusherEntry entry = active.get(i);\n                entry.generate(lease);\n            }\n\n            List<ByteBuffer> byteBuffers = lease.getByteBuffers();\n            endPoint.write(this, byteBuffers.toArray(new ByteBuffer[byteBuffers.size()]));\n            return Action.SCHEDULED;\n        }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void updateWindowSize(int delta)\n    {\n        if (delta != 0)\n        {\n            int oldSize = windowSize.getAndAdd(delta);\n            HTTP2FlowControl.LOG.debug(\"Updated session window {} -> {} for {}\", oldSize, oldSize + delta, this);\n        }\n    }","id":80173,"modified_method":"@Override\n    public int updateWindowSize(int delta)\n    {\n        return windowSize.getAndAdd(delta);\n    }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void updateWindowSize(int delta)\n    {\n        if (delta != 0)\n        {\n            int oldSize = windowSize.getAndAdd(delta);\n            HTTP2FlowControl.LOG.debug(\"Updated stream window {} -> {} for {}\", oldSize, oldSize + delta, this);\n        }\n    }","id":80174,"modified_method":"@Override\n    public int updateWindowSize(int delta)\n    {\n        return windowSize.getAndAdd(delta);\n    }","commit_id":"fb93973c9d799829b2ecb9d792fe3f8594c906db","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static BBContainer allocateDirect(final int capacity) {\n        synchronized (m_availableBufferStock) {\n            ArrayDeque<ByteBuffer> buffers = m_availableBufferStock.get(capacity);\n            ByteBuffer retval = null;\n            if (buffers != null) {\n                retval = buffers.poll();\n            }\n            if (retval != null) {\n                retval.clear();\n            } else {\n                bytesAllocatedGlobally.getAndAdd(capacity);\n                retval = ByteBuffer.allocateDirect(capacity);\n            }\n            return new BBContainer(retval, 0) {\n\n                @Override\n                public void discard() {\n                    synchronized (m_availableBufferStock) {\n                        ArrayDeque<ByteBuffer> buffers = m_availableBufferStock.get(b.capacity());\n                        if (buffers == null) {\n                            buffers = new ArrayDeque<ByteBuffer>();\n                            m_availableBufferStock.put(b.capacity(), buffers);\n                        }\n                        buffers.offer(b);\n                    }\n                }\n\n            };\n        }\n    }","id":80175,"modified_method":"public static BBContainer allocateDirect(final int capacity) {\n        final ByteBuffer retval = ByteBuffer.allocateDirect(capacity);\n        bytesAllocatedGlobally.getAndAdd(capacity);\n\n        return new BBContainer(retval, 0) {\n\n            @Override\n            public void discard() {\n                try {\n                    DirectMemoryUtils.destroyDirectByteBuffer(retval);\n                } catch (Throwable e) {\n                    VoltDB.crashLocalVoltDB(\"Failed to deallocate direct byte buffer\", false, e);\n                }\n            }\n\n        };\n    }","commit_id":"ed1a9bbc48ed53c84cf5fa7f7e8b682517118be6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void generatePrimaryConstructorProperties(PropertyCodegen propertyCodegen, JetClassOrObject origin) {\n        boolean isAnnotation = origin instanceof JetClass && ((JetClass) origin).isAnnotation();\n        for (JetParameter p : getPrimaryConstructorParameters()) {\n            if (p.getValOrVarNode() != null) {\n                PropertyDescriptor propertyDescriptor = state.getBindingContext().get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, p);\n                if (propertyDescriptor != null) {\n                    if (!isAnnotation) {\n                        propertyCodegen.generateBackingField(p, propertyDescriptor);\n                        propertyCodegen\n                                .generateDefaultGetter(propertyDescriptor, getVisibilityAccessFlag(propertyDescriptor), p);\n                        if (propertyDescriptor.isVar()) {\n                            propertyCodegen\n                                    .generateDefaultSetter(propertyDescriptor, getVisibilityAccessFlag(propertyDescriptor), p);\n                        }\n                    }\n                    else {\n                        Type type = state.getTypeMapper().mapType(propertyDescriptor);\n                        v.newMethod(p, ACC_PUBLIC | ACC_ABSTRACT, p.getName(), \"()\" + type.getDescriptor(), null, null);\n                    }\n                }\n            }\n        }\n    }","id":80176,"modified_method":"private void generatePrimaryConstructorProperties(PropertyCodegen propertyCodegen, JetClassOrObject origin) {\n        boolean isAnnotation = origin instanceof JetClass && ((JetClass) origin).isAnnotation();\n        for (JetParameter p : getPrimaryConstructorParameters()) {\n            if (p.getValOrVarNode() != null) {\n                PropertyDescriptor propertyDescriptor = state.getBindingContext().get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, p);\n                if (propertyDescriptor != null) {\n                    if (!isAnnotation) {\n                        propertyCodegen.generateBackingField(p, propertyDescriptor);\n                        int accessFlags = getVisibilityAccessFlag(propertyDescriptor) | getModalityAccessFlag(propertyDescriptor);\n                        propertyCodegen.generateDefaultGetter(propertyDescriptor, accessFlags, p);\n                        if (propertyDescriptor.isVar()) {\n                            propertyCodegen.generateDefaultSetter(propertyDescriptor, accessFlags, p);\n                        }\n                    }\n                    else {\n                        Type type = state.getTypeMapper().mapType(propertyDescriptor);\n                        v.newMethod(p, ACC_PUBLIC | ACC_ABSTRACT, p.getName(), \"()\" + type.getDescriptor(), null, null);\n                    }\n                }\n            }\n        }\n    }","commit_id":"5bc9291d617d9322dc7400f24136d14e18a4e643","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateGetter(JetProperty p, PropertyDescriptor propertyDescriptor) {\n        JetPropertyAccessor getter = p.getGetter();\n        if (getter != null && getter.getBodyExpression() != null) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n            functionCodegen.generateMethod(getter, signature.getJvmMethodSignature(), true, signature.getPropertyTypeKotlinSignature(),\n                                           propertyDescriptor.getGetter());\n        }\n        else if (isExternallyAccessible(propertyDescriptor)) {\n            generateDefaultGetter(p);\n            JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n            FunctionCodegen.generateBridgeIfNeeded(context, state, v, signature.getJvmMethodSignature().getAsmMethod(),\n                                                   propertyDescriptor.getGetter(), kind);\n        }\n    }","id":80177,"modified_method":"private void generateGetter(JetProperty p, PropertyDescriptor propertyDescriptor) {\n        JetPropertyAccessor getter = p.getGetter();\n        if (getter != null && getter.getBodyExpression() != null) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n            functionCodegen.generateMethod(getter, signature.getJvmMethodSignature(), true, signature.getPropertyTypeKotlinSignature(),\n                                           propertyDescriptor.getGetter());\n        }\n        else if (isExternallyAccessible(propertyDescriptor)) {\n            int flags = getVisibilityAccessFlag(propertyDescriptor);\n            flags |= getModalityAccessFlag(propertyDescriptor);\n            generateDefaultGetter(propertyDescriptor, flags, p);\n\n            JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n            FunctionCodegen.generateBridgeIfNeeded(context, state, v, signature.getJvmMethodSignature().getAsmMethod(),\n                                                   propertyDescriptor.getGetter(), kind);\n        }\n    }","commit_id":"5bc9291d617d9322dc7400f24136d14e18a4e643","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generateDefaultGetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        checkMustGenerateCode(propertyDescriptor);\n\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= ACC_STATIC;\n        }\n\n        PsiElement psiElement = descriptorToDeclaration(bindingContext, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if (isTrait && !(kind instanceof OwnerKind.DelegateKind)) {\n            flags |= ACC_ABSTRACT;\n        }\n\n        if (propertyDescriptor.getModality() == Modality.FINAL) {\n            flags |= ACC_FINAL;\n        }\n\n        JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n        final JvmMethodSignature jvmMethodSignature = signature.getJvmMethodSignature();\n        final String descriptor = jvmMethodSignature.getAsmMethod().getDescriptor();\n        String getterName = getterName(propertyDescriptor.getName());\n        MethodVisitor mv = v.newMethod(origin, flags, getterName, descriptor, jvmMethodSignature.getGenericsSignature(), null);\n        PropertyGetterDescriptor getter = propertyDescriptor.getGetter();\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(),\n                                      jvmMethodSignature.getKotlinTypeParameter(), propertyDescriptor,\n                                      getter == null\n                                      ? propertyDescriptor.getVisibility()\n                                      : getter.getVisibility());\n\n        if (getter != null) {\n            //noinspection ConstantConditions\n            assert !getter.hasBody();\n            AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(getter);\n        }\n\n        if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            if (propertyDescriptor.getModality() != Modality.ABSTRACT) {\n                mv.visitCode();\n                if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                    genStubThrow(mv);\n                }\n                else {\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    if (kind != OwnerKind.NAMESPACE) {\n                        iv.load(0, OBJECT_TYPE);\n                    }\n                    final Type type = typeMapper.mapType(propertyDescriptor);\n\n                    if ((kind instanceof OwnerKind.DelegateKind) != (propertyDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                        throw new IllegalStateException(\"mismatching kind in \" + propertyDescriptor);\n                    }\n\n                    if (kind instanceof OwnerKind.DelegateKind) {\n                        OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                        dk.getDelegate().put(OBJECT_TYPE, iv);\n                        iv.invokeinterface(dk.getOwnerClass(), getterName, descriptor);\n                    }\n                    else {\n                        iv.visitFieldInsn(\n                                kind == OwnerKind.NAMESPACE ? GETSTATIC : GETFIELD,\n                                typeMapper.getOwner(propertyDescriptor, kind).getInternalName(),\n                                propertyDescriptor.getName().getName(),\n                                type.getDescriptor());\n                    }\n                    iv.areturn(type);\n                }\n            }\n        }\n        FunctionCodegen.endVisit(mv, \"getter\", origin);\n    }","id":80178,"modified_method":"public void generateDefaultGetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        checkMustGenerateCode(propertyDescriptor);\n\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= ACC_STATIC;\n        }\n\n        PsiElement psiElement = descriptorToDeclaration(bindingContext, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if (isTrait && !(kind instanceof OwnerKind.DelegateKind)) {\n            flags |= ACC_ABSTRACT;\n        }\n\n        JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n        final JvmMethodSignature jvmMethodSignature = signature.getJvmMethodSignature();\n        final String descriptor = jvmMethodSignature.getAsmMethod().getDescriptor();\n        String getterName = getterName(propertyDescriptor.getName());\n        MethodVisitor mv = v.newMethod(origin, flags, getterName, descriptor, jvmMethodSignature.getGenericsSignature(), null);\n        PropertyGetterDescriptor getter = propertyDescriptor.getGetter();\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(),\n                                      jvmMethodSignature.getKotlinTypeParameter(), propertyDescriptor,\n                                      getter == null\n                                      ? propertyDescriptor.getVisibility()\n                                      : getter.getVisibility());\n\n        if (getter != null) {\n            //noinspection ConstantConditions\n            assert !getter.hasBody();\n            AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(getter);\n        }\n\n        if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            if (propertyDescriptor.getModality() != Modality.ABSTRACT) {\n                mv.visitCode();\n                if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                    genStubThrow(mv);\n                }\n                else {\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    if (kind != OwnerKind.NAMESPACE) {\n                        iv.load(0, OBJECT_TYPE);\n                    }\n                    final Type type = typeMapper.mapType(propertyDescriptor);\n\n                    if ((kind instanceof OwnerKind.DelegateKind) != (propertyDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                        throw new IllegalStateException(\"mismatching kind in \" + propertyDescriptor);\n                    }\n\n                    if (kind instanceof OwnerKind.DelegateKind) {\n                        OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                        dk.getDelegate().put(OBJECT_TYPE, iv);\n                        iv.invokeinterface(dk.getOwnerClass(), getterName, descriptor);\n                    }\n                    else {\n                        iv.visitFieldInsn(\n                                kind == OwnerKind.NAMESPACE ? GETSTATIC : GETFIELD,\n                                typeMapper.getOwner(propertyDescriptor, kind).getInternalName(),\n                                propertyDescriptor.getName().getName(),\n                                type.getDescriptor());\n                    }\n                    iv.areturn(type);\n                }\n            }\n        }\n        FunctionCodegen.endVisit(mv, \"getter\", origin);\n    }","commit_id":"5bc9291d617d9322dc7400f24136d14e18a4e643","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateSetter(JetProperty p, PropertyDescriptor propertyDescriptor) {\n        JetPropertyAccessor setter = p.getSetter();\n        if (setter != null && setter.getBodyExpression() != null) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n            functionCodegen.generateMethod(setter, signature.getJvmMethodSignature(), true, signature.getPropertyTypeKotlinSignature(),\n                                           propertyDescriptor.getSetter());\n        }\n        else if (isExternallyAccessible(propertyDescriptor) && propertyDescriptor.isVar()) {\n            generateDefaultSetter(p);\n            JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n            FunctionCodegen.generateBridgeIfNeeded(context, state, v, signature.getJvmMethodSignature().getAsmMethod(),\n                                                   propertyDescriptor.getSetter(), kind);\n        }\n    }","id":80179,"modified_method":"private void generateSetter(JetProperty p, PropertyDescriptor propertyDescriptor) {\n        JetPropertyAccessor setter = p.getSetter();\n        if (setter != null && setter.getBodyExpression() != null) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n            functionCodegen.generateMethod(setter, signature.getJvmMethodSignature(), true, signature.getPropertyTypeKotlinSignature(),\n                                           propertyDescriptor.getSetter());\n        }\n        else if (isExternallyAccessible(propertyDescriptor) && propertyDescriptor.isVar()) {\n            PropertySetterDescriptor setterDescriptor = propertyDescriptor.getSetter();\n            int flags = setterDescriptor == null ? getVisibilityAccessFlag(propertyDescriptor) : getVisibilityAccessFlag(setterDescriptor);\n            flags |= getModalityAccessFlag(propertyDescriptor);\n            generateDefaultSetter(propertyDescriptor, flags, p);\n\n            JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n            FunctionCodegen.generateBridgeIfNeeded(context, state, v, signature.getJvmMethodSignature().getAsmMethod(),\n                                                   setterDescriptor, kind);\n        }\n    }","commit_id":"5bc9291d617d9322dc7400f24136d14e18a4e643","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void gen(JetProperty p) {\n        final VariableDescriptor descriptor = bindingContext.get(BindingContext.VARIABLE, p);\n        if (!(descriptor instanceof PropertyDescriptor)) {\n            throw new UnsupportedOperationException(\"expect a property to have a property descriptor\");\n        }\n        final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) descriptor;\n        if (kind == OwnerKind.NAMESPACE || kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.TRAIT_IMPL) {\n            if (kind != OwnerKind.TRAIT_IMPL) {\n                generateBackingField(p, propertyDescriptor);\n            }\n            generateGetter(p, propertyDescriptor);\n            generateSetter(p, propertyDescriptor);\n        }\n        else if (kind instanceof OwnerKind.DelegateKind) {\n            generateDefaultGetter(propertyDescriptor, ACC_PUBLIC, p);\n            if (propertyDescriptor.isVar()) {\n                generateDefaultSetter(propertyDescriptor, ACC_PUBLIC, p);\n            }\n        }\n    }","id":80180,"modified_method":"public void gen(JetProperty p) {\n        VariableDescriptor descriptor = bindingContext.get(BindingContext.VARIABLE, p);\n        if (!(descriptor instanceof PropertyDescriptor)) {\n            throw new UnsupportedOperationException(\"expect a property to have a property descriptor\");\n        }\n        PropertyDescriptor propertyDescriptor = (PropertyDescriptor) descriptor;\n        assert kind == OwnerKind.NAMESPACE || kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.TRAIT_IMPL\n                : \"Generating property with a wrong kind (\" + kind + \"): \" + descriptor;\n\n        if (kind != OwnerKind.TRAIT_IMPL) {\n            generateBackingField(p, propertyDescriptor);\n        }\n        generateGetter(p, propertyDescriptor);\n        generateSetter(p, propertyDescriptor);\n    }","commit_id":"5bc9291d617d9322dc7400f24136d14e18a4e643","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generateDefaultSetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        checkMustGenerateCode(propertyDescriptor);\n\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= ACC_STATIC;\n        }\n\n        PsiElement psiElement = descriptorToDeclaration(bindingContext, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if (isTrait && !(kind instanceof OwnerKind.DelegateKind)) {\n            flags |= ACC_ABSTRACT;\n        }\n\n        if (propertyDescriptor.getModality() == Modality.FINAL) {\n            flags |= ACC_FINAL;\n        }\n\n        JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n        assert true;\n        final JvmMethodSignature jvmMethodSignature = signature.getJvmMethodSignature();\n        final String descriptor = jvmMethodSignature.getAsmMethod().getDescriptor();\n        MethodVisitor mv = v.newMethod(origin, flags, setterName(propertyDescriptor.getName()), descriptor, jvmMethodSignature.getGenericsSignature(), null);\n        PropertySetterDescriptor setter = propertyDescriptor.getSetter();\n        assert setter != null;\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(),\n                                      jvmMethodSignature.getKotlinTypeParameter(), propertyDescriptor,\n                                      setter.getVisibility());\n\n        assert !setter.hasBody();\n        AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(setter);\n\n        if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            if (propertyDescriptor.getModality() != Modality.ABSTRACT) {\n                mv.visitCode();\n                if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                    genStubThrow(mv);\n                }\n                else {\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    final Type type = typeMapper.mapType(propertyDescriptor);\n                    int paramCode = 0;\n                    if (kind != OwnerKind.NAMESPACE) {\n                        iv.load(0, OBJECT_TYPE);\n                        paramCode = 1;\n                    }\n\n                    if ((kind instanceof OwnerKind.DelegateKind) != (propertyDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                        throw new IllegalStateException(\"mismatching kind in \" + propertyDescriptor);\n                    }\n\n                    if (kind instanceof OwnerKind.DelegateKind) {\n                        OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                        iv.load(0, OBJECT_TYPE);\n                        dk.getDelegate().put(OBJECT_TYPE, iv);\n\n                        iv.load(paramCode, type);\n                        iv.invokeinterface(dk.getOwnerClass(), setterName(propertyDescriptor.getName()), descriptor);\n                    }\n                    else {\n                        iv.load(paramCode, type);\n                        iv.visitFieldInsn(kind == OwnerKind.NAMESPACE ? PUTSTATIC : PUTFIELD,\n                                          typeMapper.getOwner(propertyDescriptor, kind).getInternalName(),\n                                          propertyDescriptor.getName().getName(),\n                                          type.getDescriptor());\n                    }\n\n                    iv.visitInsn(RETURN);\n                }\n            }\n            FunctionCodegen.endVisit(mv, \"setter\", origin);\n        }\n    }","id":80181,"modified_method":"public void generateDefaultSetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        checkMustGenerateCode(propertyDescriptor);\n\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= ACC_STATIC;\n        }\n\n        PsiElement psiElement = descriptorToDeclaration(bindingContext, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if (isTrait && !(kind instanceof OwnerKind.DelegateKind)) {\n            flags |= ACC_ABSTRACT;\n        }\n\n        JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n        assert true;\n        final JvmMethodSignature jvmMethodSignature = signature.getJvmMethodSignature();\n        final String descriptor = jvmMethodSignature.getAsmMethod().getDescriptor();\n        MethodVisitor mv = v.newMethod(origin, flags, setterName(propertyDescriptor.getName()), descriptor, jvmMethodSignature.getGenericsSignature(), null);\n        PropertySetterDescriptor setter = propertyDescriptor.getSetter();\n        assert setter != null;\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(),\n                                      jvmMethodSignature.getKotlinTypeParameter(), propertyDescriptor,\n                                      setter.getVisibility());\n\n        assert !setter.hasBody();\n        AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(setter);\n\n        if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            if (propertyDescriptor.getModality() != Modality.ABSTRACT) {\n                mv.visitCode();\n                if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                    genStubThrow(mv);\n                }\n                else {\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    final Type type = typeMapper.mapType(propertyDescriptor);\n                    int paramCode = 0;\n                    if (kind != OwnerKind.NAMESPACE) {\n                        iv.load(0, OBJECT_TYPE);\n                        paramCode = 1;\n                    }\n\n                    if ((kind instanceof OwnerKind.DelegateKind) != (propertyDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                        throw new IllegalStateException(\"mismatching kind in \" + propertyDescriptor);\n                    }\n\n                    if (kind instanceof OwnerKind.DelegateKind) {\n                        OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                        iv.load(0, OBJECT_TYPE);\n                        dk.getDelegate().put(OBJECT_TYPE, iv);\n\n                        iv.load(paramCode, type);\n                        iv.invokeinterface(dk.getOwnerClass(), setterName(propertyDescriptor.getName()), descriptor);\n                    }\n                    else {\n                        iv.load(paramCode, type);\n                        iv.visitFieldInsn(kind == OwnerKind.NAMESPACE ? PUTSTATIC : PUTFIELD,\n                                          typeMapper.getOwner(propertyDescriptor, kind).getInternalName(),\n                                          propertyDescriptor.getName().getName(),\n                                          type.getDescriptor());\n                    }\n\n                    iv.visitInsn(RETURN);\n                }\n            }\n            FunctionCodegen.endVisit(mv, \"setter\", origin);\n        }\n    }","commit_id":"5bc9291d617d9322dc7400f24136d14e18a4e643","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public String toString() {\n        return \"[\" + getClass().getSimpleName() + \"# rp: \" + this.provider + \"]\";\n    }","id":80182,"modified_method":"@Override\n    public String toString() {\n        return \"[\" + getClass().getSimpleName() + \"# rp: \" + this.providerHandler.getResourceProvider() + \"]\";\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#getAttribute(ResolveContext, String)}\n     */\n    public Object getAttribute(final String name) {\n        return this.provider.getAttribute(this.resolveContext, name);\n    }","id":80183,"modified_method":"/**\n     * #see {@link ResourceProvider#getAttribute(ResolveContext, String)}\n     */\n    public Object getAttribute(final String name) {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.getAttribute(this.resolveContext, name);\n        }\n        return null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#hasChanges(ResolveContext)}\n     */\n    public boolean hasChanges() {\n        return this.provider.hasChanges(this.resolveContext);\n    }","id":80184,"modified_method":"/**\n     * #see {@link ResourceProvider#hasChanges(ResolveContext)}\n     */\n    public boolean hasChanges() {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.hasChanges(this.resolveContext);\n        }\n        return false;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#isLive(ResolveContext)}\n     */\n    public boolean isLive() {\n        return this.provider.isLive(this.resolveContext);\n    }","id":80185,"modified_method":"/**\n     * #see {@link ResourceProvider#isLive(ResolveContext)}\n     */\n    public boolean isLive() {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.isLive(this.resolveContext);\n        }\n        return false;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#refresh(ResolveContext)}\n     */\n    public void refresh() {\n        this.provider.refresh(this.resolveContext);\n    }","id":80186,"modified_method":"/**\n     * #see {@link ResourceProvider#refresh(ResolveContext)}\n     */\n    public void refresh() {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            rp.refresh(this.resolveContext);\n        }\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#getResource(ResolveContext, String, ResourceContext, Resource)}\n     */\n    public Resource getResource(final String path, final Resource parent, final Map<String, String> parameters) {\n        final ResourceContext resourceContext;\n        if ( parameters != null ) {\n            resourceContext = new ResourceContext() {\n\n                @Override\n                public Map<String, String> getResolveParameters() {\n                    return parameters;\n                }\n            };\n        } else {\n            resourceContext = ResourceContext.EMPTY_CONTEXT;\n        }\n        return wrapResource(this.provider.getResource(this.resolveContext, path, resourceContext, parent));\n    }","id":80187,"modified_method":"/**\n     * #see {@link ResourceProvider#getResource(ResolveContext, String, ResourceContext, Resource)}\n     */\n    public Resource getResource(final String path, final Resource parent, final Map<String, String> parameters) {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp == null ) {\n            return null;\n        }\n        final ResourceContext resourceContext;\n        if ( parameters != null ) {\n            resourceContext = new ResourceContext() {\n\n                @Override\n                public Map<String, String> getResolveParameters() {\n                    return parameters;\n                }\n            };\n        } else {\n            resourceContext = ResourceContext.EMPTY_CONTEXT;\n        }\n        return wrapResource(rp.getResource(this.resolveContext, path, resourceContext, parent));\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"public AuthenticatedResourceProvider(@Nonnull final ResourceProvider<Object> provider,\n            final boolean useRAS,\n            @Nonnull final ResolveContext<Object> resolveContext,\n            @Nonnull final ResourceAccessSecurityTracker tracker) {\n        this.provider = provider;\n        this.resolveContext = resolveContext;\n        this.tracker = tracker;\n        this.useRAS = useRAS;\n    }","id":80188,"modified_method":"public AuthenticatedResourceProvider(@Nonnull final ResourceProviderHandler providerHandler,\n            final boolean useRAS,\n            @Nonnull final ResolveContext<Object> resolveContext,\n            @Nonnull final ResourceAccessSecurityTracker tracker) {\n        this.providerHandler = providerHandler;\n        this.resolveContext = resolveContext;\n        this.tracker = tracker;\n        this.useRAS = useRAS;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#getParent(ResolveContext, Resource)}\n     */\n    public Resource getParent(final Resource child) {\n        return wrapResource(this.provider.getParent(this.resolveContext, child));\n    }","id":80189,"modified_method":"/**\n     * #see {@link ResourceProvider#getParent(ResolveContext, Resource)}\n     */\n    public Resource getParent(final Resource child) {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return wrapResource(rp.getParent(this.resolveContext, child));\n        }\n        return null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#create(ResolveContext, String, Map)}\n     */\n    public Resource create(final ResourceResolver resolver,\n            final String path,\n            final Map<String, Object> properties)\n    throws PersistenceException {\n        if ( this.canCreate(resolver, path) ) {\n            return this.provider.create(this.resolveContext, path, properties);\n        } else {\n            return null;\n        }\n    }","id":80190,"modified_method":"/**\n     * #see {@link ResourceProvider#create(ResolveContext, String, Map)}\n     */\n    public Resource create(final ResourceResolver resolver,\n            final String path,\n            final Map<String, Object> properties)\n    throws PersistenceException {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null && this.canCreate(resolver, path) ) {\n            return rp.create(this.resolveContext, path, properties);\n        }\n        return null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#adaptTo(ResolveContext, Class)}\n     */\n    public <AdapterType> AdapterType adaptTo(final Class<AdapterType> type) {\n        return this.provider.adaptTo(this.resolveContext, type);\n    }","id":80191,"modified_method":"/**\n     * #see {@link ResourceProvider#adaptTo(ResolveContext, Class)}\n     */\n    public <AdapterType> AdapterType adaptTo(final Class<AdapterType> type) {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.adaptTo(this.resolveContext, type);\n        }\n        return null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#delete(ResolveContext, Resource)}\n     */\n    public void delete(final Resource resource) throws PersistenceException {\n        if ( this.canDelete(resource) ) {\n            this.provider.delete(this.resolveContext, resource);\n        } else {\n            throw new PersistenceException(\"Unable to delete resource \" + resource.getPath());\n        }\n    }","id":80192,"modified_method":"/**\n     * #see {@link ResourceProvider#delete(ResolveContext, Resource)}\n     */\n    public void delete(final Resource resource) throws PersistenceException {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null && this.canDelete(resource) ) {\n            rp.delete(this.resolveContext, resource);\n        } else {\n            throw new PersistenceException(\"Unable to delete resource \" + resource.getPath());\n        }\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#move(ResolveContext, String, String)}\n     */\n    public boolean move(final String srcAbsPath, final String destAbsPath) throws PersistenceException {\n        return this.provider.move(this.resolveContext, srcAbsPath, destAbsPath);\n    }","id":80193,"modified_method":"/**\n     * #see {@link ResourceProvider#move(ResolveContext, String, String)}\n     */\n    public boolean move(final String srcAbsPath, final String destAbsPath) throws PersistenceException {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.move(this.resolveContext, srcAbsPath, destAbsPath);\n        }\n        return false;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#getQueryLanguageProvider()}\n     */\n    private QueryLanguageProvider<Object> getQueryLanguageProvider() {\n        return this.provider.getQueryLanguageProvider();\n    }","id":80194,"modified_method":"/**\n     * #see {@link ResourceProvider#getQueryLanguageProvider()}\n     */\n    private QueryLanguageProvider<Object> getQueryLanguageProvider() {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.getQueryLanguageProvider();\n        }\n        return null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#revert(ResolveContext)}\n     */\n    public void revert() {\n        this.provider.revert(this.resolveContext);\n    }","id":80195,"modified_method":"/**\n     * #see {@link ResourceProvider#revert(ResolveContext)}\n     */\n    public void revert() {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            rp.revert(this.resolveContext);\n        }\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#listChildren(ResolveContext, Resource)}\n     */\n    public Iterator<Resource> listChildren(final Resource parent) {\n        return wrapIterator(this.provider.listChildren(this.resolveContext, parent));\n    }","id":80196,"modified_method":"/**\n     * #see {@link ResourceProvider#listChildren(ResolveContext, Resource)}\n     */\n    public Iterator<Resource> listChildren(final Resource parent) {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return wrapIterator(rp.listChildren(this.resolveContext, parent));\n        }\n        return null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#getAttributeNames(ResolveContext)}\n     */\n    public Collection<String> getAttributeNames(final Set<String> attributeNames) {\n        Collection<String> rpAttributeNames = this.provider.getAttributeNames(this.resolveContext);\n        if (rpAttributeNames != null) {\n            attributeNames.addAll(rpAttributeNames);\n        }\n        return attributeNames;\n    }","id":80197,"modified_method":"/**\n     * #see {@link ResourceProvider#getAttributeNames(ResolveContext)}\n     */\n    public void getAttributeNames(final Set<String> attributeNames) {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            Collection<String> rpAttributeNames = rp.getAttributeNames(this.resolveContext);\n            if (rpAttributeNames != null) {\n                attributeNames.addAll(rpAttributeNames);\n            }\n        }\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#copy(ResolveContext, String, String)}\n     */\n    public boolean copy(final String srcAbsPath, final String destAbsPath) throws PersistenceException {\n        return this.provider.copy(this.resolveContext, srcAbsPath, destAbsPath);\n    }","id":80198,"modified_method":"/**\n     * #see {@link ResourceProvider#copy(ResolveContext, String, String)}\n     */\n    public boolean copy(final String srcAbsPath, final String destAbsPath) throws PersistenceException {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            return rp.copy(this.resolveContext, srcAbsPath, destAbsPath);\n        }\n        return false;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * #see {@link ResourceProvider#commit(ResolveContext)}\n     */\n    public void commit() throws PersistenceException {\n        this.provider.commit(this.resolveContext);\n    }","id":80199,"modified_method":"/**\n     * #see {@link ResourceProvider#commit(ResolveContext)}\n     */\n    public void commit() throws PersistenceException {\n        final ResourceProvider<Object> rp = this.providerHandler.getResourceProvider();\n        if ( rp != null ) {\n            rp.commit(this.resolveContext);\n        }\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void prepare() throws PersistenceException, AccessSecurityException {\n        this.resourceResolver = mock(ResourceResolver.class);\n        this.resolveContext = mock(ResolveContext.class);\n        when(this.resolveContext.getResourceResolver()).thenReturn(this.resourceResolver);\n\n        this.security = mock(ResourceAccessSecurity.class);\n\n        this.queryLanguageProvider = mock(QueryLanguageProvider.class);\n\n        this.resourceProvider = mock(ResourceProvider.class);\n        when(resourceProvider.getQueryLanguageProvider()).thenReturn(this.queryLanguageProvider);\n\n        useRAS = false;\n\n        final ResourceAccessSecurityTracker securityTracker = new ResourceAccessSecurityTracker() {\n            @Override\n            public ResourceAccessSecurity getApplicationResourceAccessSecurity() {\n                if ( useRAS) {\n                    return security;\n                }\n                return null;\n            }\n        };\n\n        this.src = new AuthenticatedResourceProvider(this.resourceProvider, false, this.resolveContext, securityTracker);\n\n    }","id":80200,"modified_method":"@Before\n    public void prepare() throws PersistenceException, AccessSecurityException {\n        this.resourceResolver = mock(ResourceResolver.class);\n        this.resolveContext = mock(ResolveContext.class);\n        when(this.resolveContext.getResourceResolver()).thenReturn(this.resourceResolver);\n\n        this.security = mock(ResourceAccessSecurity.class);\n\n        this.queryLanguageProvider = mock(QueryLanguageProvider.class);\n\n        this.resourceProvider = mock(ResourceProvider.class);\n        when(resourceProvider.getQueryLanguageProvider()).thenReturn(this.queryLanguageProvider);\n\n        final ResourceProviderHandler handler = mock(ResourceProviderHandler.class);\n        when(handler.getResourceProvider()).thenReturn(this.resourceProvider);\n\n        useRAS = false;\n\n        final ResourceAccessSecurityTracker securityTracker = new ResourceAccessSecurityTracker() {\n            @Override\n            public ResourceAccessSecurity getApplicationResourceAccessSecurity() {\n                if ( useRAS) {\n                    return security;\n                }\n                return null;\n            }\n        };\n\n        this.src = new AuthenticatedResourceProvider(handler, false, this.resolveContext, securityTracker);\n\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public ResourceProvider<?> getParentResourceProvider() {\n        if ( ! parentLookupDone ) {\n            synchronized ( this ) {\n                if ( this.parentPath != null ) {\n                    String path = this.parentPath;\n                    while ( path != null && this.parentProvider != null ) {\n                        final Node<ResourceProviderHandler> node = this.control.getResourceProviderStorage().getTree().getBestMatchingNode(this.parentPath);\n                        if ( node != null ) {\n                            final ResourceProviderHandler handler = node.getValue();\n                            try {\n                                this.parentResolveContext = this.resolveContextManager.getOrCreateResolveContext(handler, this.control);\n                                if ( this.parentResolveContext != null ) {\n                                    this.parentProvider = handler.getResourceProvider();\n                                }\n                            } catch ( final LoginException se) {\n                                // skip this, try next\n                            }\n                            if ( this.parentProvider == null ) {\n                                path = ResourceUtil.getParent(path);\n                            }\n                        } else {\n                            path = null;\n                        }\n                    }\n                }\n                parentLookupDone = true;\n            }\n        }\n        return this.parentProvider;\n    }","id":80201,"modified_method":"@Override\n    public ResourceProvider<?> getParentResourceProvider() {\n        if ( ! parentLookupDone ) {\n            synchronized ( this ) {\n                if ( this.parentPath != null ) {\n                    String path = this.parentPath;\n                    while ( path != null && this.parentProviderHandler != null ) {\n                        final Node<ResourceProviderHandler> node = this.control.getResourceProviderStorage().getTree().getBestMatchingNode(this.parentPath);\n                        if ( node != null ) {\n                            final ResourceProviderHandler handler = node.getValue();\n                            try {\n                                this.parentResolveContext = this.resolveContextManager.getOrCreateResolveContext(handler, this.control);\n                                if ( this.parentResolveContext != null ) {\n                                    this.parentProviderHandler = handler;\n                                }\n                            } catch ( final LoginException se) {\n                                // skip this, try next\n                            }\n                            if ( this.parentProviderHandler == null ) {\n                                path = ResourceUtil.getParent(path);\n                            }\n                        } else {\n                            path = null;\n                        }\n                    }\n                }\n                parentLookupDone = true;\n            }\n        }\n        return this.parentProviderHandler != null ? this.parentProviderHandler.getResourceProvider() : null;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Authenticate all handlers\n     * @param handlers List of handlers\n     * @param control the resource resolver control\n     * @throws LoginException If authentication fails to one provider\n     */\n    public void authenticateAll(@Nonnull final List<ResourceProviderHandler> handlers,\n            @Nonnull final ResourceResolverControl control)\n    throws LoginException {\n        for (final ResourceProviderHandler h : handlers) {\n            try {\n                this.getOrCreateProvider(h, control);\n            } catch ( final LoginException le ) {\n                // authentication failed, logout from all successful handlers\n                for(final Map.Entry<ResourceProviderHandler, AuthenticatedResourceProvider> entry : this.contextMap.entrySet()) {\n                    if ( entry.getValue() != AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER ) {\n                        entry.getKey().getResourceProvider().logout(entry.getValue().getResolveContext().getProviderState());\n                    }\n                }\n                this.contextMap.clear();\n                control.clearAuthenticatedProviders();\n                throw le;\n            }\n        }\n    }","id":80202,"modified_method":"/**\n     * Authenticate all handlers\n     * @param handlers List of handlers\n     * @param control the resource resolver control\n     * @throws LoginException If authentication fails to one provider\n     */\n    public void authenticateAll(@Nonnull final List<ResourceProviderHandler> handlers,\n            @Nonnull final ResourceResolverControl control)\n    throws LoginException {\n        for (final ResourceProviderHandler h : handlers) {\n            try {\n                this.getOrCreateProvider(h, control);\n            } catch ( final LoginException le ) {\n                // authentication failed, logout from all successful handlers\n                for(final Map.Entry<ResourceProviderHandler, AuthenticatedResourceProvider> entry : this.contextMap.entrySet()) {\n                    if ( entry.getValue() != AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER ) {\n                        final ResourceProvider<Object> provider = entry.getKey().getResourceProvider();\n                        if ( provider != null ) {\n                            provider.logout(entry.getValue().getResolveContext().getProviderState());\n                        }\n                    }\n                }\n                this.contextMap.clear();\n                control.clearAuthenticatedProviders();\n                throw le;\n            }\n        }\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Authenticate a single resource provider (handler)\n     * @param handler The resource provider handler\n     * @param control The resource control\n     * @return The resolve context\n     * @throws LoginException If authentication fails\n     */\n    private @Nonnull AuthenticatedResourceProvider authenticate(@Nonnull final ResourceProviderHandler handler,\n            @Nonnull final ResourceResolverControl control) throws LoginException {\n        final ResourceProvider<Object> provider = handler.getResourceProvider();\n        boolean isAuthenticated = false;\n        Object contextData = null;\n        if ( (handler.getInfo().getAuthType() == AuthType.required || handler.getInfo().getAuthType() == AuthType.lazy) ) {\n            try {\n                contextData = provider.authenticate(control.getAuthenticationInfo());\n                isAuthenticated = true;\n            } catch ( final LoginException le ) {\n                logger.debug(\"Unable to login into resource provider \" + provider, le);\n                throw le;\n            }\n        }\n\n        final ResolveContext<Object> context = new BasicResolveContext<Object>(this.resolver,\n                this,\n                control,\n                contextData,\n                ResourceUtil.getParent(handler.getInfo().getPath()));\n        final AuthenticatedResourceProvider rp = new AuthenticatedResourceProvider(provider,\n                handler.getInfo().getUseResourceAccessSecurity(),\n                context,\n                this.tracker);\n        if ( isAuthenticated ) {\n            this.authenticated.add(rp);\n        }\n        if ( handler.getInfo().isModifiable() ) {\n            this.modifiable.add(rp);\n        }\n        if ( handler.getInfo().isRefreshable() ) {\n            this.refreshable.add(rp);\n        }\n\n        return rp;\n    }","id":80203,"modified_method":"/**\n     * Authenticate a single resource provider (handler)\n     * @param handler The resource provider handler\n     * @param control The resource control\n     * @return The resolve context\n     * @throws LoginException If authentication fails\n     */\n    private @Nonnull AuthenticatedResourceProvider authenticate(@Nonnull final ResourceProviderHandler handler,\n            @Nonnull final ResourceResolverControl control) throws LoginException {\n        final ResourceProvider<Object> provider = handler.getResourceProvider();\n        boolean isAuthenticated = false;\n        Object contextData = null;\n        if ( (handler.getInfo().getAuthType() == AuthType.required || handler.getInfo().getAuthType() == AuthType.lazy) ) {\n            try {\n                contextData = provider.authenticate(control.getAuthenticationInfo());\n                isAuthenticated = true;\n            } catch ( final LoginException le ) {\n                logger.debug(\"Unable to login into resource provider \" + provider, le);\n                throw le;\n            }\n        }\n\n        final ResolveContext<Object> context = new BasicResolveContext<Object>(this.resolver,\n                this,\n                control,\n                contextData,\n                ResourceUtil.getParent(handler.getInfo().getPath()));\n        final AuthenticatedResourceProvider rp = new AuthenticatedResourceProvider(handler,\n                handler.getInfo().getUseResourceAccessSecurity(),\n                context,\n                this.tracker);\n        if ( isAuthenticated ) {\n            this.authenticated.add(rp);\n        }\n        if ( handler.getInfo().isModifiable() ) {\n            this.modifiable.add(rp);\n        }\n        if ( handler.getInfo().isRefreshable() ) {\n            this.refreshable.add(rp);\n        }\n\n        return rp;\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Logs out from all providers.\n     */\n    private void logout() {\n        for(final Map.Entry<ResourceProviderHandler, Object> entry : this.authenticatedProviders.entrySet()) {\n            entry.getKey().getResourceProvider().logout(entry.getValue());\n        }\n        this.authenticatedProviders.clear();\n    }","id":80204,"modified_method":"/**\n     * Logs out from all providers.\n     */\n    private void logout() {\n        for(final Map.Entry<ResourceProviderHandler, Object> entry : this.authenticatedProviders.entrySet()) {\n            final ResourceProvider<Object> rp = entry.getKey().getResourceProvider();\n            if ( rp != null ) {\n                rp.logout(entry.getValue());\n            }\n        }\n        this.authenticatedProviders.clear();\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void prepare() throws PersistenceException, AccessSecurityException {\n\n        rr = mock(ResourceResolver.class);\n        resolveContext = mock(ResolveContext.class);\n        when(resolveContext.getResourceResolver()).thenReturn(rr);\n\n        security = mock(ResourceAccessSecurity.class);\n        first = mock(Resource.class);\n        second = mock(Resource.class);\n\n        when(security.getReadableResource(first)).thenReturn(first);\n        when(security.getReadableResource(second)).thenReturn(null);\n        when(security.transformQuery(\"FIND ALL\", \"MockQueryLanguage\", rr)).thenReturn(\"FIND ALL\");\n\n        QueryLanguageProvider qlp = mock(QueryLanguageProvider.class);\n\n        rp = mock(ResourceProvider.class);\n        when(rp.getQueryLanguageProvider()).thenReturn(qlp);\n\n        when(rp.create(resolveContext, \"/some/path\", Collections.<String, Object> emptyMap())).thenReturn(mock(Resource.class));\n        when(qlp.findResources(resolveContext, \"FIND ALL\", \"MockQueryLanguage\")).thenReturn(Arrays.asList(first, second).iterator());\n\n        ResourceAccessSecurityTracker securityTracker = new ResourceAccessSecurityTracker() {\n            @Override\n            public ResourceAccessSecurity getApplicationResourceAccessSecurity() {\n                return security;\n            }\n        };\n\n        src = new AuthenticatedResourceProvider(rp, false, resolveContext, securityTracker);\n\n    }","id":80205,"modified_method":"@Before\n    public void prepare() throws PersistenceException, AccessSecurityException {\n\n        rr = mock(ResourceResolver.class);\n        resolveContext = mock(ResolveContext.class);\n        when(resolveContext.getResourceResolver()).thenReturn(rr);\n\n        security = mock(ResourceAccessSecurity.class);\n        first = mock(Resource.class);\n        second = mock(Resource.class);\n\n        when(security.getReadableResource(first)).thenReturn(first);\n        when(security.getReadableResource(second)).thenReturn(null);\n        when(security.transformQuery(\"FIND ALL\", \"MockQueryLanguage\", rr)).thenReturn(\"FIND ALL\");\n\n        QueryLanguageProvider qlp = mock(QueryLanguageProvider.class);\n\n        rp = mock(ResourceProvider.class);\n        when(rp.getQueryLanguageProvider()).thenReturn(qlp);\n\n        when(rp.create(resolveContext, \"/some/path\", Collections.<String, Object> emptyMap())).thenReturn(mock(Resource.class));\n        when(qlp.findResources(resolveContext, \"FIND ALL\", \"MockQueryLanguage\")).thenReturn(Arrays.asList(first, second).iterator());\n\n        ResourceAccessSecurityTracker securityTracker = new ResourceAccessSecurityTracker() {\n            @Override\n            public ResourceAccessSecurity getApplicationResourceAccessSecurity() {\n                return security;\n            }\n        };\n\n        final ResourceProviderHandler handler = mock(ResourceProviderHandler.class);\n        when(handler.getResourceProvider()).thenReturn(this.rp);\n\n        src = new AuthenticatedResourceProvider(handler, false, resolveContext, securityTracker);\n\n    }","commit_id":"370ae7225c3f52a42bc89d91b493aa3edbca4688","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Authenticate a single resource provider (handler)\n     * @param handler The resource provider handler\n     * @param control The resource control\n     * @return The resolve context\n     * @throws LoginException If authentication fails\n     */\n    private @Nonnull AuthenticatedResourceProvider authenticate(@Nonnull final ResourceProviderHandler handler,\n            @Nonnull final ResourceResolverControl control) throws LoginException {\n        final ResourceProvider<Object> provider = handler.getResourceProvider();\n        boolean isAuthenticated = false;\n        Object contextData = null;\n        if ( (handler.getInfo().getAuthType() == AuthType.required || handler.getInfo().getAuthType() == AuthType.lazy) ) {\n            try {\n                contextData = provider.authenticate(control.getAuthenticationInfo());\n                isAuthenticated = true;\n            } catch ( final LoginException le ) {\n                logger.debug(\"Unable to login into resource provider \" + provider, le);\n                throw le;\n            }\n        }\n\n        final ResolveContext<Object> context = new BasicResolveContext<Object>(this.resolver,\n                this,\n                control,\n                contextData,\n                ResourceUtil.getParent(handler.getInfo().getPath()));\n        final AuthenticatedResourceProvider rp = new AuthenticatedResourceProvider(handler,\n                handler.getInfo().getUseResourceAccessSecurity(),\n                context,\n                this.tracker);\n        if ( isAuthenticated ) {\n            this.authenticated.add(rp);\n        }\n        if ( handler.getInfo().isModifiable() ) {\n            this.modifiable.add(rp);\n        }\n        if ( handler.getInfo().isRefreshable() ) {\n            this.refreshable.add(rp);\n        }\n\n        return rp;\n    }","id":80206,"modified_method":"/**\n     * Authenticate a single resource provider (handler)\n     * @param handler The resource provider handler\n     * @param control The resource control\n     * @return The resolve context\n     * @throws LoginException If authentication fails\n     */\n    private @Nonnull AuthenticatedResourceProvider authenticate(@Nonnull final ResourceProviderHandler handler,\n            @Nonnull final ResourceProvider<Object> provider,\n            @Nonnull final ResourceResolverControl control) throws LoginException {\n        boolean isAuthenticated = false;\n        Object contextData = null;\n        if ( (handler.getInfo().getAuthType() == AuthType.required || handler.getInfo().getAuthType() == AuthType.lazy) ) {\n            try {\n                contextData = provider.authenticate(control.getAuthenticationInfo());\n                isAuthenticated = true;\n            } catch ( final LoginException le ) {\n                logger.debug(\"Unable to login into resource provider \" + provider, le);\n                throw le;\n            }\n        }\n\n        final ResolveContext<Object> context = new BasicResolveContext<Object>(this.resolver,\n                this,\n                control,\n                contextData,\n                ResourceUtil.getParent(handler.getInfo().getPath()));\n        final AuthenticatedResourceProvider rp = new AuthenticatedResourceProvider(handler,\n                handler.getInfo().getUseResourceAccessSecurity(),\n                context,\n                this.tracker);\n        if ( isAuthenticated ) {\n            this.authenticated.add(rp);\n        }\n        if ( handler.getInfo().isModifiable() ) {\n            this.modifiable.add(rp);\n        }\n        if ( handler.getInfo().isRefreshable() ) {\n            this.refreshable.add(rp);\n        }\n\n        return rp;\n    }","commit_id":"1aa7b7b70103dfcea67c634dd652512eb26bdb24","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Get the context\n     * @param handler The resource handler\n     * @return The resource context or {@code null} if authentication failed previously.\n     */\n    public @CheckForNull AuthenticatedResourceProvider getOrCreateProvider(@Nonnull final ResourceProviderHandler handler,\n            @Nonnull final ResourceResolverControl control)\n    throws LoginException {\n        AuthenticatedResourceProvider provider = this.contextMap.get(handler);\n        if (provider == null) {\n            try {\n                provider = authenticate(handler, control);\n                this.contextMap.put(handler, provider);\n                if ( handler.getInfo().getAuthType() == AuthType.lazy || handler.getInfo().getAuthType() == AuthType.required ) {\n                    control.registerAuthenticatedProvider(handler, provider.getResolveContext().getProviderState());\n                }\n            } catch ( final LoginException le) {\n                logger.debug(\"Authentication to resource provider \" + handler.getResourceProvider() + \" failed: \" + le.getMessage(), le);\n                this.contextMap.put(handler, AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER);\n\n                throw le;\n            }\n        }\n\n        return provider == AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER ? null : provider;\n    }","id":80207,"modified_method":"/**\n     * Get the context\n     * @param handler The resource handler\n     * @return The resource context or {@code null} if authentication failed previously.\n     */\n    public @CheckForNull AuthenticatedResourceProvider getOrCreateProvider(@Nonnull final ResourceProviderHandler handler,\n            @Nonnull final ResourceResolverControl control)\n    throws LoginException {\n        AuthenticatedResourceProvider provider = this.contextMap.get(handler);\n        if (provider == null) {\n            final ResourceProvider<Object> resourceProvider = handler.getResourceProvider();\n            if ( resourceProvider != null ) {\n                try {\n                    provider = authenticate(handler, resourceProvider, control);\n                    this.contextMap.put(handler, provider);\n                    if ( handler.getInfo().getAuthType() == AuthType.lazy || handler.getInfo().getAuthType() == AuthType.required ) {\n                        control.registerAuthenticatedProvider(handler, provider.getResolveContext().getProviderState());\n                    }\n                } catch ( final LoginException le) {\n                    logger.debug(\"Authentication to resource provider \" + resourceProvider + \" failed: \" + le.getMessage(), le);\n                    this.contextMap.put(handler, AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER);\n\n                    throw le;\n                }\n            } else {\n                this.contextMap.put(handler, AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER);\n            }\n        }\n\n        return provider == AuthenticatedResourceProvider.UNAUTHENTICATED_PROVIDER ? null : provider;\n    }","commit_id":"1aa7b7b70103dfcea67c634dd652512eb26bdb24","url":"https://github.com/apache/sling"},{"original_method":"public ResourceProviderStorage(List<ResourceProviderHandler> handlers) {\n        this.allHandlers = handlers;\n        this.authRequiredHandlers = new ArrayList<ResourceProviderHandler>();\n        this.adaptableHandlers = new ArrayList<ResourceProviderHandler>();\n        this.attributableHandlers = new ArrayList<ResourceProviderHandler>();\n        this.languageQueryableHandlers = new ArrayList<ResourceProviderHandler>();\n        for (ResourceProviderHandler h : allHandlers) {\n            ResourceProviderInfo info = h.getInfo();\n            if (info.getAuthType() == AuthType.required) {\n                this.authRequiredHandlers.add(h);\n            }\n            if (info.isAdaptable()) {\n                this.adaptableHandlers.add(h);\n            }\n            if (info.isAttributable()) {\n                this.attributableHandlers.add(h);\n            }\n            if (h.getResourceProvider().getQueryLanguageProvider() != null) {\n                this.languageQueryableHandlers.add(h);\n            }\n        }\n        this.handlersTree = new PathTree<ResourceProviderHandler>(handlers);\n    }","id":80208,"modified_method":"public ResourceProviderStorage(List<ResourceProviderHandler> handlers) {\n        this.allHandlers = handlers;\n        this.authRequiredHandlers = new ArrayList<ResourceProviderHandler>();\n        this.adaptableHandlers = new ArrayList<ResourceProviderHandler>();\n        this.attributableHandlers = new ArrayList<ResourceProviderHandler>();\n        this.languageQueryableHandlers = new ArrayList<ResourceProviderHandler>();\n        for (ResourceProviderHandler h : allHandlers) {\n            ResourceProviderInfo info = h.getInfo();\n            if (info.getAuthType() == AuthType.required) {\n                this.authRequiredHandlers.add(h);\n            }\n            if (info.isAdaptable()) {\n                this.adaptableHandlers.add(h);\n            }\n            if (info.isAttributable()) {\n                this.attributableHandlers.add(h);\n            }\n            final ResourceProvider<Object> rp = h.getResourceProvider();\n            if (rp != null && rp.getQueryLanguageProvider() != null) {\n                this.languageQueryableHandlers.add(h);\n            }\n        }\n        this.handlersTree = new PathTree<ResourceProviderHandler>(handlers);\n    }","commit_id":"1aa7b7b70103dfcea67c634dd652512eb26bdb24","url":"https://github.com/apache/sling"},{"original_method":"public CandidateInfo resolveConflict(List<CandidateInfo> conflicts){\n    final int size = conflicts.size();\n    if(size == 1){\n      return conflicts.get(0);\n    }\n    if(size > 0){\n      final CandidateInfo[] uncheckedResult = conflicts.toArray(new CandidateInfo[size]);\n      CandidateInfo currentResult = uncheckedResult[0];\n\n      final PsiElement currentElement = currentResult.getElement();\n      if(currentElement instanceof PsiField){\n        for (int i = 1; i < uncheckedResult.length; i++) {\n          final CandidateInfo candidate = uncheckedResult[i];\n          final PsiElement otherElement = candidate.getElement();\n          if (otherElement == null) continue;\n\n          if (!(otherElement instanceof PsiField)) {\n            if (otherElement instanceof PsiLocalVariable) {\n              return candidate;\n            }\n            else {\n              if (!currentResult.isAccessible()) return candidate;\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n\n          final PsiClass newClass = ((PsiField)otherElement).getContainingClass();\n          final PsiClass oldClass = ((PsiField)currentElement).getContainingClass();\n\n          final PsiElement scope = currentResult.getCurrentFileResolveScope();\n          if (newClass.isInheritor(oldClass, true)) {\n            if (!(scope instanceof PsiClass) || !((PsiClass)scope).isInheritorDeep(oldClass, newClass)) {\n              // candidate is better\n              conflicts.remove(currentResult);\n              currentResult = candidate;\n              continue;\n            }\n          }\n          else if (oldClass.isInheritor(newClass, true)) {\n            if (!(scope instanceof PsiClass) || !((PsiClass)scope).isInheritorDeep(newClass, oldClass)) {\n              // candidate is worse\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n\n          if (!candidate.isAccessible()) {\n            conflicts.remove(candidate);\n            continue;\n          }\n          if (!currentResult.isAccessible()) {\n            conflicts.remove(currentResult);\n            currentResult = candidate;\n            continue;\n          }\n\n          //This test should go last\n          if (otherElement == currentElement && candidate.getSubstitutor().equals(currentResult.getSubstitutor())) {\n            conflicts.remove(candidate);\n            continue;\n          }\n\n          return null;\n        }\n      }\n      return currentResult;\n    }\n    return null;\n  }","id":80209,"modified_method":"public CandidateInfo resolveConflict(List<CandidateInfo> conflicts){\n    final int size = conflicts.size();\n    if(size == 1){\n      return conflicts.get(0);\n    }\n    if(size > 0){\n      final CandidateInfo[] uncheckedResult = conflicts.toArray(new CandidateInfo[size]);\n      CandidateInfo currentResult = uncheckedResult[0];\n\n      final PsiElement currentElement = currentResult.getElement();\n      if(currentElement instanceof PsiField){\n        for (int i = 1; i < uncheckedResult.length; i++) {\n          final CandidateInfo candidate = uncheckedResult[i];\n          final PsiElement otherElement = candidate.getElement();\n          if (otherElement == null) continue;\n\n          if (!(otherElement instanceof PsiField)) {\n            if (otherElement instanceof PsiLocalVariable) {\n              return candidate;\n            }\n            else {\n              if (!currentResult.isAccessible()) return candidate;\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n\n          final PsiClass newClass = ((PsiField)otherElement).getContainingClass();\n          final PsiClass oldClass = ((PsiField)currentElement).getContainingClass();\n\n          final PsiElement scope = currentResult.getCurrentFileResolveScope();\n          if (newClass.isInheritor(oldClass, true)) {\n            if (!(scope instanceof PsiClass) ||\n                scope.equals(oldClass) ||\n                scope.equals(newClass) ||\n                !((PsiClass)scope).isInheritorDeep(oldClass, newClass)) {\n              // candidate is better\n              conflicts.remove(currentResult);\n              currentResult = candidate;\n              continue;\n            }\n          }\n          else if (oldClass.isInheritor(newClass, true)) {\n            if (!(scope instanceof PsiClass) ||\n                scope.equals(oldClass) ||\n                scope.equals(newClass) ||\n                !((PsiClass)scope).isInheritorDeep(newClass, oldClass)) {\n              // candidate is worse\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n\n          if (!candidate.isAccessible()) {\n            conflicts.remove(candidate);\n            continue;\n          }\n          if (!currentResult.isAccessible()) {\n            conflicts.remove(currentResult);\n            currentResult = candidate;\n            continue;\n          }\n\n          //This test should go last\n          if (otherElement == currentElement && candidate.getSubstitutor().equals(currentResult.getSubstitutor())) {\n            conflicts.remove(candidate);\n            continue;\n          }\n\n          return null;\n        }\n      }\n      return currentResult;\n    }\n    return null;\n  }","commit_id":"1433b26ec844b980e9e3aaf18746fd194bb87afb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processDeclarationsInClass(PsiClass aClass, PsiScopeProcessor processor,\n                                                   PsiSubstitutor substitutor, Set<PsiClass> visited, PsiElement last,\n                                                   PsiElement place, boolean isRaw) {\n    if (visited.contains(aClass)) return true;\n    isRaw = isRaw || PsiUtil.isRawSubstitutor(aClass, substitutor);\n    if (last instanceof PsiTypeParameterList || last instanceof PsiModifierList) return true; //TypeParameterList and ModifierList do not see our declarations\n    final Object data;\n    synchronized (PsiLock.LOCK) {\n      data = aClass.getUserData(NAME_MAPS_BUILT_FLAG);\n    }\n    if (last instanceof PsiReferenceList && data == null || aClass instanceof PsiTypeParameter) {\n      return processDeclarationsInClassNotCached(aClass, processor, substitutor, visited, last, place, isRaw);\n    }\n\n    final NameHint nameHint = processor.getHint(NameHint.class);\n    final ElementClassHint classHint = processor.getHint(ElementClassHint.class);\n\n    if (nameHint != null) {\n      if (classHint == null || classHint.shouldProcess(PsiField.class)) {\n        final PsiField fieldByName = aClass.findFieldByName(nameHint.getName(), false);\n        if (fieldByName != null) {\n          processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, aClass);\n          if (!processor.execute(fieldByName, substitutor)) return false;\n        }\n        else {\n          final Map<String, List<Pair<PsiField, PsiSubstitutor>>> allFieldsMap = getMap(aClass, PsiField.class);\n\n          final List<Pair<PsiField, PsiSubstitutor>> list = allFieldsMap.get(nameHint.getName());\n          if (list != null) {\n            for (final Pair<PsiField, PsiSubstitutor> candidate : list) {\n              PsiField candidateField = candidate.getFirst();\n              PsiSubstitutor finalSubstitutor = obtainFinalSubstitutor(candidateField.getContainingClass(), candidate.getSecond(), aClass,\n                                                                       substitutor, place);\n\n              processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, candidateField.getContainingClass());\n              if (!processor.execute(candidateField, finalSubstitutor)) return false;\n            }\n          }\n        }\n      }\n      if (classHint == null || classHint.shouldProcess(PsiClass.class)) {\n        if (last != null && last.getParent() == aClass) {\n          if (last instanceof PsiClass) {\n            if (!processor.execute(last, substitutor)) return false;\n          }\n          // Parameters\n          final PsiTypeParameterList list = aClass.getTypeParameterList();\n          if (list != null && !PsiScopesUtil.processScope(list, processor, substitutor, last, place)) return false;\n        }\n        if (!(last instanceof PsiReferenceList) && !(last instanceof PsiModifierList)) {\n          final PsiClass classByName = aClass.findInnerClassByName(nameHint.getName(), false);\n          if (classByName != null) {\n            processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, aClass);\n            if (!processor.execute(classByName, substitutor)) return false;\n          }\n          else {\n            final Map<String, List<Pair<PsiClass, PsiSubstitutor>>> allClassesMap = getMap(aClass, PsiClass.class);\n\n            final List<Pair<PsiClass, PsiSubstitutor>> list = allClassesMap.get(nameHint.getName());\n            if (list != null) {\n              for (final Pair<PsiClass, PsiSubstitutor> candidate : list) {\n                final PsiClass inner = candidate.getFirst();\n                final PsiClass containingClass = inner.getContainingClass();\n                if (containingClass != null) {\n                  PsiSubstitutor finalSubstitutor = obtainFinalSubstitutor(containingClass, candidate.getSecond(), aClass,\n                                                                           substitutor, place);\n                  processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, containingClass);\n                  if (!processor.execute(inner, finalSubstitutor)) return false;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (classHint == null || classHint.shouldProcess(PsiMethod.class)) {\n        if (processor instanceof MethodResolverProcessor) {\n          final MethodResolverProcessor methodResolverProcessor = (MethodResolverProcessor)processor;\n          if (methodResolverProcessor.isConstructor()) {\n            final PsiMethod[] constructors = aClass.getConstructors();\n            methodResolverProcessor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, aClass);\n            for (PsiMethod constructor : constructors) {\n              if (!methodResolverProcessor.execute(constructor, substitutor)) return false;\n            }\n            return true;\n          }\n        }\n        final Map<String, List<Pair<PsiMethod, PsiSubstitutor>>> allMethodsMap = getMap(aClass, PsiMethod.class);\n        final List<Pair<PsiMethod, PsiSubstitutor>> list = allMethodsMap.get(nameHint.getName());\n        if (list != null) {\n          for (final Pair<PsiMethod, PsiSubstitutor> candidate : list) {\n            PsiMethod candidateMethod = candidate.getFirst();\n            if (processor instanceof MethodResolverProcessor) {\n              if (candidateMethod.isConstructor() != ((MethodResolverProcessor)processor).isConstructor()) continue;\n            }\n            final PsiClass containingClass = candidateMethod.getContainingClass();\n            PsiSubstitutor finalSubstitutor = obtainFinalSubstitutor(containingClass, candidate.getSecond(), aClass,\n                                                                     substitutor, place);\n            if (isRaw && !candidateMethod.hasModifierProperty(PsiModifier.STATIC)) { //static methods are not erased due to raw overriding\n              PsiTypeParameter[] methodTypeParameters = candidateMethod.getTypeParameters();\n              for (PsiTypeParameter methodTypeParameter : methodTypeParameters) {\n                finalSubstitutor = ((PsiSubstitutorEx)finalSubstitutor).inplacePut(methodTypeParameter, null);\n              }\n            }\n            processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, containingClass);\n            if (!processor.execute(candidateMethod, finalSubstitutor)) return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    return processDeclarationsInClassNotCached(aClass, processor, substitutor, visited, last, place, isRaw);\n  }","id":80210,"modified_method":"public static boolean processDeclarationsInClass(PsiClass aClass, PsiScopeProcessor processor,\n                                                   PsiSubstitutor substitutor, Set<PsiClass> visited, PsiElement last,\n                                                   PsiElement place, boolean isRaw) {\n    if (visited.contains(aClass)) return true;\n    isRaw = isRaw || PsiUtil.isRawSubstitutor(aClass, substitutor);\n    if (last instanceof PsiTypeParameterList || last instanceof PsiModifierList) return true; //TypeParameterList and ModifierList do not see our declarations\n    final Object data;\n    synchronized (PsiLock.LOCK) {\n      data = aClass.getUserData(NAME_MAPS_BUILT_FLAG);\n    }\n    if (data == null) {\n      return processDeclarationsInClassNotCached(aClass, processor, substitutor, visited, last, place, isRaw);\n    }\n\n    final NameHint nameHint = processor.getHint(NameHint.class);\n    final ElementClassHint classHint = processor.getHint(ElementClassHint.class);\n\n    if (nameHint != null) {\n      if (classHint == null || classHint.shouldProcess(PsiField.class)) {\n        final PsiField fieldByName = aClass.findFieldByName(nameHint.getName(), false);\n        if (fieldByName != null) {\n          processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, aClass);\n          if (!processor.execute(fieldByName, substitutor)) return false;\n        }\n        else {\n          final Map<String, List<Pair<PsiField, PsiSubstitutor>>> allFieldsMap = getMap(aClass, PsiField.class);\n\n          final List<Pair<PsiField, PsiSubstitutor>> list = allFieldsMap.get(nameHint.getName());\n          if (list != null) {\n            for (final Pair<PsiField, PsiSubstitutor> candidate : list) {\n              PsiField candidateField = candidate.getFirst();\n              PsiSubstitutor finalSubstitutor = obtainFinalSubstitutor(candidateField.getContainingClass(), candidate.getSecond(), aClass,\n                                                                       substitutor, place);\n\n              processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, candidateField.getContainingClass());\n              if (!processor.execute(candidateField, finalSubstitutor)) return false;\n            }\n          }\n        }\n      }\n      if (classHint == null || classHint.shouldProcess(PsiClass.class)) {\n        if (last != null && last.getParent() == aClass) {\n          if (last instanceof PsiClass) {\n            if (!processor.execute(last, substitutor)) return false;\n          }\n          // Parameters\n          final PsiTypeParameterList list = aClass.getTypeParameterList();\n          if (list != null && !PsiScopesUtil.processScope(list, processor, substitutor, last, place)) return false;\n        }\n        if (!(last instanceof PsiReferenceList) && !(last instanceof PsiModifierList)) {\n          final PsiClass classByName = aClass.findInnerClassByName(nameHint.getName(), false);\n          if (classByName != null) {\n            processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, aClass);\n            if (!processor.execute(classByName, substitutor)) return false;\n          }\n          else {\n            final Map<String, List<Pair<PsiClass, PsiSubstitutor>>> allClassesMap = getMap(aClass, PsiClass.class);\n\n            final List<Pair<PsiClass, PsiSubstitutor>> list = allClassesMap.get(nameHint.getName());\n            if (list != null) {\n              for (final Pair<PsiClass, PsiSubstitutor> candidate : list) {\n                final PsiClass inner = candidate.getFirst();\n                final PsiClass containingClass = inner.getContainingClass();\n                if (containingClass != null) {\n                  PsiSubstitutor finalSubstitutor = obtainFinalSubstitutor(containingClass, candidate.getSecond(), aClass,\n                                                                           substitutor, place);\n                  processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, containingClass);\n                  if (!processor.execute(inner, finalSubstitutor)) return false;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (classHint == null || classHint.shouldProcess(PsiMethod.class)) {\n        if (processor instanceof MethodResolverProcessor) {\n          final MethodResolverProcessor methodResolverProcessor = (MethodResolverProcessor)processor;\n          if (methodResolverProcessor.isConstructor()) {\n            final PsiMethod[] constructors = aClass.getConstructors();\n            methodResolverProcessor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, aClass);\n            for (PsiMethod constructor : constructors) {\n              if (!methodResolverProcessor.execute(constructor, substitutor)) return false;\n            }\n            return true;\n          }\n        }\n        final Map<String, List<Pair<PsiMethod, PsiSubstitutor>>> allMethodsMap = getMap(aClass, PsiMethod.class);\n        final List<Pair<PsiMethod, PsiSubstitutor>> list = allMethodsMap.get(nameHint.getName());\n        if (list != null) {\n          for (final Pair<PsiMethod, PsiSubstitutor> candidate : list) {\n            PsiMethod candidateMethod = candidate.getFirst();\n            if (processor instanceof MethodResolverProcessor) {\n              if (candidateMethod.isConstructor() != ((MethodResolverProcessor)processor).isConstructor()) continue;\n            }\n            final PsiClass containingClass = candidateMethod.getContainingClass();\n            PsiSubstitutor finalSubstitutor = obtainFinalSubstitutor(containingClass, candidate.getSecond(), aClass,\n                                                                     substitutor, place);\n            if (isRaw && !candidateMethod.hasModifierProperty(PsiModifier.STATIC)) { //static methods are not erased due to raw overriding\n              PsiTypeParameter[] methodTypeParameters = candidateMethod.getTypeParameters();\n              for (PsiTypeParameter methodTypeParameter : methodTypeParameters) {\n                finalSubstitutor = ((PsiSubstitutorEx)finalSubstitutor).inplacePut(methodTypeParameter, null);\n              }\n            }\n            processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, containingClass);\n            if (!processor.execute(candidateMethod, finalSubstitutor)) return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    return processDeclarationsInClassNotCached(aClass, processor, substitutor, visited, last, place, isRaw);\n  }","commit_id":"1433b26ec844b980e9e3aaf18746fd194bb87afb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JavaResolveResult[] multiResolveConstructor(PsiClassType type, PsiExpressionList argumentList, PsiElement place) {\n    final MethodResolverProcessor processor;\n    PsiClassType.ClassResolveResult classResolveResult = type.resolveGenerics();\n    final PsiClass aClass = classResolveResult.getElement();\n    final JavaResolveResult[] result;\n    if (aClass == null) {\n      result = JavaResolveResult.EMPTY_ARRAY;\n    }\n    else {\n      if (argumentList.getParent() instanceof PsiAnonymousClass) {\n        final PsiClass anonymous = (PsiClass)argumentList.getParent();\n        processor = new MethodResolverProcessor(anonymous, argumentList, place);\n        final PsiClass superClass = anonymous.getSuperClass();\n        if (superClass != null) {\n          processor.setName(superClass.getName());\n        }\n      }\n      else {\n        processor = new MethodResolverProcessor(aClass, argumentList, place);\n        processor.setName(aClass.getName());\n      }\n      PsiScopesUtil.processScope(aClass, processor, classResolveResult.getSubstitutor(), aClass, place);\n\n      // getting the most suitable myResult\n      result = processor.getResult();\n    }\n    return result;\n  }","id":80211,"modified_method":"@NotNull\n  public JavaResolveResult[] multiResolveConstructor(PsiClassType type, PsiExpressionList argumentList, PsiElement place) {\n    PsiClassType.ClassResolveResult classResolveResult = type.resolveGenerics();\n    PsiClass aClass = classResolveResult.getElement();\n    if (aClass == null) {\n      return JavaResolveResult.EMPTY_ARRAY;\n    }\n    else {\n      final MethodResolverProcessor processor;\n      PsiSubstitutor substitutor;\n      if (argumentList.getParent() instanceof PsiAnonymousClass) {\n        final PsiClass anonymous = (PsiClass)argumentList.getParent();\n        processor = new MethodResolverProcessor(anonymous, argumentList, place);\n        aClass = anonymous.getSuperClass();\n        if (aClass == null) return JavaResolveResult.EMPTY_ARRAY;\n        substitutor = TypeConversionUtil.getSuperClassSubstitutor(aClass, anonymous, classResolveResult.getSubstitutor());\n      }\n      else {\n        processor = new MethodResolverProcessor(aClass, argumentList, place);\n        substitutor = classResolveResult.getSubstitutor();\n      }\n\n      for (PsiMethod constructor : aClass.getConstructors()) {\n        if (!processor.execute(constructor, substitutor)) break;\n      }\n\n      return processor.getResult();\n    }\n  }","commit_id":"1433b26ec844b980e9e3aaf18746fd194bb87afb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n\tpublic OGraphElement newInstance(final String iClassName) {\r\n\t\tif (iClassName.equals(OGraphVertex.class.getSimpleName()))\r\n\t\t\treturn new OGraphVertex(this);\r\n\t\telse if (iClassName.equals(OGraphEdge.class.getSimpleName()))\r\n\t\t\treturn new OGraphEdge(this);\r\n\r\n\t\tfinal OClass cls = getMetadata().getSchema().getClass(iClassName);\r\n\t\tif (cls != null && cls.getSuperClass() != null) {\r\n\t\t\tif (cls.getSuperClass().getName().equals(OGraphVertex.class.getSimpleName()))\r\n\t\t\t\treturn new OGraphVertex(this, iClassName);\r\n\t\t\telse if (cls.getSuperClass().getName().equals(OGraphEdge.class.getSimpleName()))\r\n\t\t\t\treturn new OGraphEdge(this, iClassName);\r\n\t\t}\r\n\r\n\t\tthrow new OGraphException(\"Unrecognized class: \" + iClassName);\r\n\t}","id":80212,"modified_method":"@Override\r\n\tpublic OGraphElement newInstance(final String iClassName) {\r\n\t\tif (iClassName.equals(OGraphVertex.class.getSimpleName()))\r\n\t\t\treturn new OGraphVertex(this);\r\n\t\telse if (iClassName.equals(OGraphEdge.class.getSimpleName()))\r\n\t\t\treturn new OGraphEdge(this);\r\n\r\n\t\tOClass cls = getMetadata().getSchema().getClass(iClassName);\r\n\t\tif (cls != null) {\r\n\t\t\tcls = cls.getSuperClass();\r\n\t\t\twhile (cls != null) {\r\n\t\t\t\tif (cls.getName().equals(OGraphVertex.class.getSimpleName()))\r\n\t\t\t\t\treturn new OGraphVertex(this, iClassName);\r\n\t\t\t\telse if (cls.getName().equals(OGraphEdge.class.getSimpleName()))\r\n\t\t\t\t\treturn new OGraphEdge(this, iClassName);\r\n\r\n\t\t\t\tcls = cls.getSuperClass();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow new OGraphException(\"Unrecognized class: \" + iClassName);\r\n\t}","commit_id":"5122c892b23298f9faa681aa76d0401f7f5ee236","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static boolean isAccessible(@NotNull PsiMember member,\n                                     @Nullable final PsiClass memberClass,\n                                     @Nullable PsiModifierList modifierList,\n                                     @NotNull  PsiElement place,\n                                     @Nullable PsiClass accessObjectClass,\n                                     @Nullable final PsiElement fileResolveScope) {\n    if (modifierList == null) return true;\n    final PsiFile placeContainingFile = place.getContainingFile();\n    final PsiManager manager = placeContainingFile.getManager();\n    if (placeContainingFile instanceof JavaCodeFragment) {\n      JavaCodeFragment fragment = (JavaCodeFragment)placeContainingFile;\n      JavaCodeFragment.VisibilityChecker visibilityChecker = fragment.getVisibilityChecker();\n      if (visibilityChecker != null) {\n        JavaCodeFragment.VisibilityChecker.Visibility visibility = visibilityChecker.isDeclarationVisible(member, place);\n        if (visibility == JavaCodeFragment.VisibilityChecker.Visibility.VISIBLE) return true;\n        if (visibility == JavaCodeFragment.VisibilityChecker.Visibility.NOT_VISIBLE) return false;\n      }\n    }\n    else if (placeContainingFile instanceof XmlFile && !PsiUtil.isInJspFile(placeContainingFile)) return true;\n    // We don't care about access rights in javadoc\n    if (isInJavaDoc(place)) return true;\n\n    if (accessObjectClass != null) {\n      if (!isAccessible(accessObjectClass, accessObjectClass.getContainingClass(), accessObjectClass.getModifierList(), place, null,\n                        null)) return false;\n    }\n\n    int effectiveAccessLevel = PsiUtil.getAccessLevel(modifierList);\n    PsiFile file = FileContextUtil.getContextFile(place); //TODO: implementation method!!!!\n    if (PsiUtil.isInJspFile(file) && PsiUtil.isInJspFile(member.getContainingFile())) return true;\n    if (file instanceof XmlFile && !PsiUtil.isInJspFile(file)) return true;\n    if (effectiveAccessLevel == PsiUtil.ACCESS_LEVEL_PUBLIC) {\n      return true;\n    }\n    if (effectiveAccessLevel == PsiUtil.ACCESS_LEVEL_PROTECTED) {\n      if (JavaPsiFacade.getInstance(manager.getProject()).arePackagesTheSame(member, place)) return true;\n      if (memberClass == null) return false;\n\n      for (PsiElement placeParent = place; placeParent != null; placeParent = placeParent.getContext()) {\n        if (placeParent instanceof PsiClass && InheritanceUtil.isInheritorOrSelf((PsiClass)placeParent, memberClass, true)) {\n          if (member instanceof PsiClass || modifierList.hasModifierProperty(PsiModifier.STATIC)) return true;\n          if (accessObjectClass == null || InheritanceUtil.isInheritorOrSelf(accessObjectClass, (PsiClass)placeParent, true)) return true;\n        }\n      }\n      return false;\n    }\n    if (effectiveAccessLevel == PsiUtil.ACCESS_LEVEL_PRIVATE) {\n      if (memberClass == null) return true;\n      if (accessObjectClass != null) {\n        PsiClass topMemberClass = getTopLevelClass(memberClass, accessObjectClass);\n        PsiClass topAccessClass = getTopLevelClass(accessObjectClass, memberClass);\n        if (!manager.areElementsEquivalent(topMemberClass, topAccessClass)) return false;\n      }\n\n      if (fileResolveScope == null) {\n        PsiClass placeTopLevelClass = getTopLevelClass(place, null);\n        PsiClass memberTopLevelClass = getTopLevelClass(memberClass, null);\n        return manager.areElementsEquivalent(placeTopLevelClass, memberTopLevelClass);\n      }\n      else {\n        return fileResolveScope instanceof PsiClass &&\n               !((PsiClass)fileResolveScope).isInheritor(memberClass, true);\n      }\n    }\n    if (!JavaPsiFacade.getInstance(manager.getProject()).arePackagesTheSame(member, place)) return false;\n    if (modifierList.hasModifierProperty(PsiModifier.STATIC)) return true;\n    // maybe inheritance lead through package local class in other package ?\n    final PsiClass placeClass = getContextClass(place);\n    if (memberClass == null || placeClass == null) return true;\n    // check only classes since interface members are public,  and if placeClass is interface,\n    // then its members are static, and cannot refer to nonstatic members of memberClass\n    if (memberClass.isInterface() || placeClass.isInterface()) return true;\n    if (placeClass.isInheritor(memberClass, true)) {\n      PsiClass superClass = placeClass.getSuperClass();\n      while (!manager.areElementsEquivalent(superClass, memberClass)) {\n        if (superClass == null || !JavaPsiFacade.getInstance(manager.getProject()).arePackagesTheSame(superClass, memberClass)) return false;\n        superClass = superClass.getSuperClass();\n      }\n    }\n\n    return true;\n  }","id":80213,"modified_method":"public static boolean isAccessible(@NotNull PsiMember member,\n                                     @Nullable final PsiClass memberClass,\n                                     @Nullable PsiModifierList modifierList,\n                                     @NotNull  PsiElement place,\n                                     @Nullable PsiClass accessObjectClass,\n                                     @Nullable final PsiElement fileResolveScope) {\n    if (modifierList == null) return true;\n    final PsiFile placeContainingFile = place.getContainingFile();\n    final PsiManager manager = placeContainingFile.getManager();\n    if (placeContainingFile instanceof JavaCodeFragment) {\n      JavaCodeFragment fragment = (JavaCodeFragment)placeContainingFile;\n      JavaCodeFragment.VisibilityChecker visibilityChecker = fragment.getVisibilityChecker();\n      if (visibilityChecker != null) {\n        JavaCodeFragment.VisibilityChecker.Visibility visibility = visibilityChecker.isDeclarationVisible(member, place);\n        if (visibility == JavaCodeFragment.VisibilityChecker.Visibility.VISIBLE) return true;\n        if (visibility == JavaCodeFragment.VisibilityChecker.Visibility.NOT_VISIBLE) return false;\n      }\n    }\n    else if (placeContainingFile instanceof XmlFile && !PsiUtil.isInJspFile(placeContainingFile)) return true;\n    // We don't care about access rights in javadoc\n    if (isInJavaDoc(place)) return true;\n\n    if (accessObjectClass != null) {\n      if (!isAccessible(accessObjectClass, accessObjectClass.getContainingClass(), accessObjectClass.getModifierList(), place, null,\n                        null)) return false;\n    }\n\n    int effectiveAccessLevel = PsiUtil.getAccessLevel(modifierList);\n    PsiFile file = FileContextUtil.getContextFile(place); //TODO: implementation method!!!!\n    if (PsiUtil.isInJspFile(file) && PsiUtil.isInJspFile(member.getContainingFile())) return true;\n    if (file instanceof XmlFile && !PsiUtil.isInJspFile(file)) return true;\n    if (effectiveAccessLevel == PsiUtil.ACCESS_LEVEL_PUBLIC) {\n      return true;\n    }\n    if (effectiveAccessLevel == PsiUtil.ACCESS_LEVEL_PROTECTED) {\n      if (JavaPsiFacade.getInstance(manager.getProject()).arePackagesTheSame(member, place)) return true;\n      if (memberClass == null) return false;\n\n      for (PsiElement placeParent = place; placeParent != null; placeParent = placeParent.getContext()) {\n        if (placeParent instanceof PsiClass && InheritanceUtil.isInheritorOrSelf((PsiClass)placeParent, memberClass, true)) {\n          if (member instanceof PsiClass || modifierList.hasModifierProperty(PsiModifier.STATIC)) return true;\n          if (accessObjectClass == null || InheritanceUtil.isInheritorOrSelf(accessObjectClass, (PsiClass)placeParent, true)) return true;\n        }\n      }\n      return false;\n    }\n    if (effectiveAccessLevel == PsiUtil.ACCESS_LEVEL_PRIVATE) {\n      if (memberClass == null) return true;\n      if (accessObjectClass != null) {\n        PsiClass topMemberClass = getTopLevelClass(memberClass, accessObjectClass);\n        PsiClass topAccessClass = getTopLevelClass(accessObjectClass, memberClass);\n        if (!manager.areElementsEquivalent(topMemberClass, topAccessClass)) return false;\n      }\n\n      if (fileResolveScope == null) {\n        PsiClass placeTopLevelClass = getTopLevelClass(place, null);\n        PsiClass memberTopLevelClass = getTopLevelClass(memberClass, null);\n        return manager.areElementsEquivalent(placeTopLevelClass, memberTopLevelClass);\n      }\n      else {\n        return fileResolveScope instanceof PsiClass &&\n               !((PsiClass)fileResolveScope).isInheritor(memberClass, true);\n      }\n    }\n    if (!JavaPsiFacade.getInstance(manager.getProject()).arePackagesTheSame(member, place)) return false;\n    if (modifierList.hasModifierProperty(PsiModifier.STATIC)) return true;\n    // maybe inheritance lead through package local class in other package ?\n    final PsiClass placeClass = getContextClass(place);\n    if (memberClass == null || placeClass == null) return true;\n    // check only classes since interface members are public,  and if placeClass is interface,\n    // then its members are static, and cannot refer to nonstatic members of memberClass\n    if (memberClass.isInterface() || placeClass.isInterface()) return true;\n    PsiClass clazz = accessObjectClass != null ?\n                     accessObjectClass :\n                     placeClass.getSuperClass(); //may start from super class\n    if (clazz != null && clazz.isInheritor(memberClass, true)) {\n      PsiClass superClass = clazz;\n      while (!manager.areElementsEquivalent(superClass, memberClass)) {\n        if (superClass == null || !JavaPsiFacade.getInstance(manager.getProject()).arePackagesTheSame(superClass, memberClass)) return false;\n        superClass = superClass.getSuperClass();\n      }\n    }\n\n    return true;\n  }","commit_id":"8c88de80a73aac588d2cd74b2a2eb66db58747b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Map<String, PsiType> getAllSuperTypes(PsiType base, final Project project) {\n    final Map<String, Map<String, PsiType>> cache =\n      CachedValuesManager.getManager(project).getCachedValue(project, new CachedValueProvider<Map<String, Map<String, PsiType>>>() {\n        @Override\n        public Result<Map<String, Map<String, PsiType>>> compute() {\n          final Map<String, Map<String, PsiType>> result = new ConcurrentHashMap<String, Map<String, PsiType>>();\n          return Result.create(result, PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT, ProjectRootManager.getInstance(project));\n        }\n      });\n\n    final PsiClass cls = PsiUtil.resolveClassInType(base);\n    //noinspection ConstantConditions\n    String key = cls instanceof PsiTypeParameter\n                 ? cls.getName() + cls.getSuperClass().getName()\n                 : TypeConversionUtil.erasure(base).getCanonicalText();\n    if (key == null) key = \"\";\n    Map<String, PsiType> result = cache.get(key);\n    if (result == null) {\n      result = new HashMap<String, PsiType>();\n      collectSuperTypes(base, result, project);\n      cache.put(key, result);\n    }\n    return result;\n  }","id":80214,"modified_method":"public static Map<String, PsiType> getAllSuperTypes(@NotNull PsiType base, final Project project) {\n    final Map<String, Map<String, PsiType>> cache =\n      CachedValuesManager.getManager(project).getCachedValue(project, new CachedValueProvider<Map<String, Map<String, PsiType>>>() {\n        @Override\n        public Result<Map<String, Map<String, PsiType>>> compute() {\n          final Map<String, Map<String, PsiType>> result = new ConcurrentHashMap<String, Map<String, PsiType>>();\n          return Result.create(result, PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT, ProjectRootManager.getInstance(project));\n        }\n      });\n\n    final PsiClass cls = PsiUtil.resolveClassInType(base);\n    //noinspection ConstantConditions\n    String key;\n    if (cls instanceof PsiTypeParameter) {\n      final PsiClass superClass = cls.getSuperClass();\n      key = cls.getName() + (superClass == null ? CommonClassNames.JAVA_LANG_OBJECT : superClass.getName());\n    }\n    else {\n      key = TypeConversionUtil.erasure(base).getCanonicalText();\n    }\n    if (key == null) key = \"\";\n    Map<String, PsiType> result = cache.get(key);\n    if (result == null) {\n      result = new HashMap<String, PsiType>();\n      collectSuperTypes(base, result, project);\n      cache.put(key, result);\n    }\n    return result;\n  }","commit_id":"65ad79ba84a6f76c3713ed40b40cd5d9017c79eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAction() {\n    if (!myCallback.checkConflicts(this)) return;\n    JavaRefactoringSettings.getInstance().PULL_UP_MEMBERS_JAVADOC = myJavaDocPanel.getPolicy();\n    StatisticsManager\n            .getInstance().incUseCount(new StatisticsInfo(PULL_UP_STATISTICS_KEY + myClass.getQualifiedName(), getSuperClass().getQualifiedName()));\n    \n    invokeRefactoring(new PullUpHelper(myClass, getSuperClass(), getSelectedMemberInfos(),\n                                               new DocCommentPolicy(getJavaDocPolicy())));\n    close(OK_EXIT_CODE);\n  }","id":80215,"modified_method":"protected void doAction() {\n    if (!myCallback.checkConflicts(this)) return;\n    JavaRefactoringSettings.getInstance().PULL_UP_MEMBERS_JAVADOC = myJavaDocPanel.getPolicy();\n    final PsiClass superClass = getSuperClass();\n    String name = superClass.getQualifiedName();\n    if (name != null) {\n      StatisticsManager\n        .getInstance().incUseCount(new StatisticsInfo(PULL_UP_STATISTICS_KEY + myClass.getQualifiedName(), name));\n    }\n    \n    invokeRefactoring(new PullUpHelper(myClass, superClass, getSelectedMemberInfos(),\n                                               new DocCommentPolicy(getJavaDocPolicy())));\n    close(OK_EXIT_CODE);\n  }","commit_id":"b4c42eb07698204c05f71ecd5954a78b4fe4774f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   *\n   * @param subClass\n   * @param includeNonProject\n   * @param sortAlphabetically if false, sorted in DFS order\n   * @return\n   */\n  public static ArrayList<PsiClass> createBasesList(PsiClass subClass, boolean includeNonProject, boolean sortAlphabetically) {\n    LinkedHashSet<PsiClass> bases = new LinkedHashSet<PsiClass>();\n    InheritanceUtil.getSuperClasses(subClass, bases, includeNonProject);\n\n    if (!subClass.isInterface()) {\n      final PsiManager manager = subClass.getManager();\n      PsiClass javaLangObject = JavaPsiFacade.getInstance(manager.getProject()).findClass(\"java.lang.Object\", subClass.getResolveScope());\n      if (includeNonProject && javaLangObject != null && !manager.areElementsEquivalent(javaLangObject, subClass)) {\n        bases.add(javaLangObject);\n      }\n    }\n\n    ArrayList<PsiClass> basesList = new ArrayList<PsiClass>(bases);\n\n    if (sortAlphabetically) {\n      Collections.sort(\n          basesList, new Comparator<PsiClass>() {\n            public int compare(PsiClass c1, PsiClass c2) {\n              return c1.getQualifiedName().compareTo(c2.getQualifiedName());\n            }\n          }\n      );\n    }\n\n    return basesList;\n  }","id":80216,"modified_method":"/**\n   *\n   * @param subClass\n   * @param includeNonProject\n   * @param sortAlphabetically if false, sorted in DFS order\n   * @return\n   */\n  public static ArrayList<PsiClass> createBasesList(PsiClass subClass, boolean includeNonProject, boolean sortAlphabetically) {\n    LinkedHashSet<PsiClass> bases = new LinkedHashSet<PsiClass>();\n    InheritanceUtil.getSuperClasses(subClass, bases, includeNonProject);\n\n    if (!subClass.isInterface()) {\n      final PsiManager manager = subClass.getManager();\n      PsiClass javaLangObject = JavaPsiFacade.getInstance(manager.getProject()).findClass(\"java.lang.Object\", subClass.getResolveScope());\n      if (includeNonProject && javaLangObject != null && !manager.areElementsEquivalent(javaLangObject, subClass)) {\n        bases.add(javaLangObject);\n      }\n    }\n\n    ArrayList<PsiClass> basesList = new ArrayList<PsiClass>(bases);\n\n    if (sortAlphabetically) {\n      Collections.sort(\n          basesList, new Comparator<PsiClass>() {\n            public int compare(PsiClass c1, PsiClass c2) {\n              final String fqn1 = c1.getQualifiedName();\n              final String fqn2 = c2.getQualifiedName();\n              if (fqn1 != null && fqn2 != null) return fqn1.compareTo(fqn2);\n              if (fqn1 == null && fqn2 == null) {\n                return Comparing.compare(c1.getName(), c2.getName());\n              }\n              return fqn1 == null ? 1 : -1;\n            }\n          }\n      );\n    }\n\n    return basesList;\n  }","commit_id":"b4c42eb07698204c05f71ecd5954a78b4fe4774f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    return getSuperClass().getName();\n  }","id":80217,"modified_method":"public String toString() {\n    final PsiClass superClass = getSuperClass();\n    return superClass != null ? superClass.getName() : \"<invalid>\";\n  }","commit_id":"f430242bb82fd992a5d04d5f9213d52a92895c71","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getAccessLevel() {\n    return PsiUtil.getAccessLevel(getSuperClass() .getModifierList());\n  }","id":80218,"modified_method":"public int getAccessLevel() {\n    final PsiClass superClass = getSuperClass();\n    return superClass != null ? PsiUtil.getAccessLevel(superClass.getModifierList()) : PsiUtil.ACCESS_LEVEL_PUBLIC;\n  }","commit_id":"f430242bb82fd992a5d04d5f9213d52a92895c71","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof SuperTypeGroup)) return false;\n\n    final SuperTypeGroup superTypeGroup = (SuperTypeGroup)o;\n\n    if (myOverrides != superTypeGroup.myOverrides) return false;\n    if (getSuperClass() != null ? !getSuperClass() .equals(superTypeGroup.getSuperClass() ) : superTypeGroup.getSuperClass()  != null) return false;\n\n    return true;\n  }","id":80219,"modified_method":"public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof SuperTypeGroup)) return false;\n\n    final SuperTypeGroup superTypeGroup = (SuperTypeGroup)o;\n\n    if (myOverrides != superTypeGroup.myOverrides) return false;\n    final PsiClass superClass = getSuperClass();\n    if (superClass != null ? !superClass .equals(superTypeGroup.getSuperClass() ) : superTypeGroup.getSuperClass()  != null) return false;\n\n    return true;\n  }","commit_id":"f430242bb82fd992a5d04d5f9213d52a92895c71","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n    int result;\n    result = (getSuperClass()  != null ? getSuperClass() .hashCode() : 0);\n    result = 29 * result + (myOverrides ? 1 : 0);\n    return result;\n  }","id":80220,"modified_method":"public int hashCode() {\n    int result;\n    final PsiClass superClass = getSuperClass();\n    result = (superClass  != null ? superClass .hashCode() : 0);\n    result = 29 * result + (myOverrides ? 1 : 0);\n    return result;\n  }","commit_id":"f430242bb82fd992a5d04d5f9213d52a92895c71","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doClose(final boolean ok) {\n    if (myDisposedFlag) return;\n\n    if (posponeCloseWhenListReady(ok)) return;\n\n    cancelListUpdater();\n    close(ok);\n\n    clearPosponedOkAction(ok);\n  }","id":80221,"modified_method":"protected void doClose(final boolean ok) {\n    if (myDisposedFlag) return;\n\n    if (posponeCloseWhenListReady(ok)) return;\n\n    cancelListUpdater();\n    close(ok);\n\n    clearPosponedOkAction(ok);\n  }","commit_id":"1f0e4f1ddb81c6210ab0e9f448de1a28486d020e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void fillInCommonPrefix(final String pattern) {\n      final ArrayList<String> list = new ArrayList<String>();\n      String[] names = myCheckBox.isSelected() ? myNames[1] : myNames[0];\n      myMatcher.getNamesByPattern(list, pattern, names, new Computable<Boolean>() {\n        public Boolean compute() {\n          return false;\n        }\n      });\n\n      if (isComplexPattern(pattern)) return; //TODO: support '*'\n      final String oldText = myTextField.getText();\n      final int oldPos = myList.getSelectedIndex();\n\n      String commonPrefix = null;\n      if (!list.isEmpty()) {\n        for (String name : list) {\n          final String string = name.toLowerCase();\n          if (commonPrefix == null) {\n            commonPrefix = string;\n          } else {\n            while (commonPrefix.length() > 0) {\n              if (string.startsWith(commonPrefix)) {\n                break;\n              }\n              commonPrefix = commonPrefix.substring(0, commonPrefix.length() - 1);\n            }\n            if (commonPrefix.length() == 0) break;\n          }\n        }\n        commonPrefix = list.get(0).substring(0, commonPrefix.length());\n        for (int i = 1; i < list.size(); i++) {\n          final String string = list.get(i).substring(0, commonPrefix.length());\n          if (!string.equals(commonPrefix)) {\n            commonPrefix = commonPrefix.toLowerCase();\n            break;\n          }\n        }\n      }\n      if (commonPrefix == null) commonPrefix = \"\";\n      final String newPattern = commonPrefix;\n\n      myHistory.add(Pair.create(oldText, oldPos));\n      myTextField.setText(newPattern);\n      myTextField.setCaretPosition(newPattern.length());\n\n      rebuildList();\n    }","id":80222,"modified_method":"private void fillInCommonPrefix(final String pattern) {\n      final List<String> list = getNamesByPattern(myMatcher, pattern, getNames(), new Computable<Boolean>() {\n        public Boolean compute() {\n          return false;\n        }\n      });\n\n      if (isComplexPattern(pattern)) return; //TODO: support '*'\n      final String oldText = myTextField.getText();\n      final int oldPos = myList.getSelectedIndex();\n\n      String commonPrefix = null;\n      if (!list.isEmpty()) {\n        for (String name : list) {\n          final String string = name.toLowerCase();\n          if (commonPrefix == null) {\n            commonPrefix = string;\n          } else {\n            while (commonPrefix.length() > 0) {\n              if (string.startsWith(commonPrefix)) {\n                break;\n              }\n              commonPrefix = commonPrefix.substring(0, commonPrefix.length() - 1);\n            }\n            if (commonPrefix.length() == 0) break;\n          }\n        }\n        commonPrefix = list.get(0).substring(0, commonPrefix.length());\n        for (int i = 1; i < list.size(); i++) {\n          final String string = list.get(i).substring(0, commonPrefix.length());\n          if (!string.equals(commonPrefix)) {\n            commonPrefix = commonPrefix.toLowerCase();\n            break;\n          }\n        }\n      }\n      if (commonPrefix == null) commonPrefix = \"\";\n      final String newPattern = commonPrefix;\n\n      myHistory.add(Pair.create(oldText, oldPos));\n      myTextField.setText(newPattern);\n      myTextField.setCaretPosition(newPattern.length());\n\n      rebuildList();\n    }","commit_id":"1f0e4f1ddb81c6210ab0e9f448de1a28486d020e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean posponeCloseWhenListReady(boolean ok) {\n    if (!Registry.is(\"actionSystem.fixLostTyping\")) return false;\n\n    final String text = myTextField.getText();\n    if (ok && !myListIsUpToDate && text != null && text.trim().length() > 0) {\n      myPosponedOkAction = new ActionCallback();\n      IdeFocusManager.getInstance(myProject).suspendKeyProcessingUntil(myPosponedOkAction);\n      return true;\n    }\n\n    return false;\n  }","id":80223,"modified_method":"private boolean posponeCloseWhenListReady(boolean ok) {\n    if (!isToFixLostTyping()) return false;\n\n    final String text = myTextField.getText();\n    if (ok && !myListIsUpToDate && text != null && text.trim().length() > 0) {\n      myPosponedOkAction = new ActionCallback();\n      IdeFocusManager.getInstance(myProject).suspendKeyProcessingUntil(myPosponedOkAction);\n      return true;\n    }\n\n    return false;\n  }","commit_id":"1f0e4f1ddb81c6210ab0e9f448de1a28486d020e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void appendToModel(final List<Cmd> commands, final int selectionPos) {\n      myAlarm.cancelAllRequests();\n      myCommands.addAll(commands);\n\n      if (myCommands.isEmpty() || myDisposedFlag) return;\n      myAlarm.addRequest(new Runnable() {\n        public void run() {\n          if (myDisposedFlag) return;\n          final long startTime = System.currentTimeMillis();\n          while (!myCommands.isEmpty() && System.currentTimeMillis() - startTime < MAX_BLOCKING_TIME) {\n            final Cmd cmd = myCommands.remove(0);\n            cmd.apply();\n          }\n\n          myList.setVisibleRowCount(Math.min(VISIBLE_LIST_SIZE_LIMIT, myList.getModel().getSize()));\n          if (!myListModel.isEmpty()) {\n            int pos = selectionPos == 0 ? detectBestStatisticalPosition() : selectionPos;\n            ListScrollingUtil.selectItem(myList, Math.min(pos, myListModel.size() - 1));\n          }\n\n          if (!myCommands.isEmpty()) {\n            myAlarm.addRequest(this, DELAY);\n          } else {\n            doPostponedOkIfNeeded();\n          }\n          if (!myDisposedFlag) {\n            showList();\n          }\n        }\n      }, DELAY);\n    }","id":80224,"modified_method":"public void appendToModel(final List<Cmd> commands, final int selectionPos) {\n      myAlarm.cancelAllRequests();\n      myCommands.addAll(commands);\n\n      if (myCommands.isEmpty() || myDisposedFlag) return;\n      myAlarm.addRequest(new Runnable() {\n        public void run() {\n          if (myDisposedFlag) {\n            return;\n          }\n          final long startTime = System.currentTimeMillis();\n          while (!myCommands.isEmpty() && System.currentTimeMillis() - startTime < MAX_BLOCKING_TIME) {\n            final Cmd cmd = myCommands.remove(0);\n            cmd.apply();\n          }\n\n          myList.setVisibleRowCount(Math.min(VISIBLE_LIST_SIZE_LIMIT, myList.getModel().getSize()));\n          if (!myListModel.isEmpty()) {\n            int pos = selectionPos == 0 ? detectBestStatisticalPosition() : selectionPos;\n            ListScrollingUtil.selectItem(myList, Math.min(pos, myListModel.size() - 1));\n          }\n\n          if (!myCommands.isEmpty()) {\n            myAlarm.addRequest(this, DELAY);\n          } else {\n            doPostponedOkIfNeeded();\n          }\n          if (!myDisposedFlag) {\n            showList();\n          }\n        }\n      }, DELAY);\n    }","commit_id":"1f0e4f1ddb81c6210ab0e9f448de1a28486d020e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean addElementsByPattern(Set<Object> result, String pattern, String[] names, boolean checkboxState, int maxCount, Computable<Boolean> isCancelled) {\n    String namePattern = getNamePattern(pattern);\n    String qualifierPattern = getQualifierPattern(pattern);\n\n    boolean empty = namePattern.length() == 0 || namePattern.equals(\"@\");    // TODO[yole]: remove implicit dependency\n    if (empty && !canShowListForEmptyPattern()) return false;\n\n    List<String> namesList = new ArrayList<String>();\n    getNamesByPattern(namesList, namePattern, names, isCancelled);\n    if (isCancelled.compute()) {\n      throw new ProcessCanceledException();\n    }\n    // Here we sort using namePattern to have similar logic with empty qualified patten case\n    Collections.sort(namesList, new MatchesComparator(namePattern));\n\n    boolean overflow = false;\n    List<Object> sameNameElements = new SmartList<Object>();\n    All:\n    for (String name : namesList) {\n      if (isCancelled.compute()) {\n        throw new ProcessCanceledException();\n      }\n      final Object[] elements = myModel.getElementsByName(name, checkboxState, namePattern);\n      if (elements.length > 1) {\n        sameNameElements.clear();\n        for (final Object element : elements) {\n          if (matchesQualifier(element, qualifierPattern)) {\n            sameNameElements.add(element);\n          }\n        }\n        sortByProximity(sameNameElements);\n        for (Object element : sameNameElements) {\n          result.add(element);\n          if (result.size() >= maxCount) {\n            overflow = true;\n            break All;\n          }\n        }\n      } else if (elements.length == 1 && matchesQualifier(elements[0], qualifierPattern)) {\n        result.add(elements[0]);\n        if (result.size() >= maxCount) {\n          overflow = true;\n          break;\n        }\n      }\n    }\n\n    return overflow;\n  }","id":80225,"modified_method":"public boolean addElementsByPattern(Set<Object> result,\n                                      String pattern,\n                                      String[] names,\n                                      boolean checkboxState,\n                                      int maxCount,\n                                      Computable<Boolean> isCancelled) {\n    String namePattern = getNamePattern(pattern);\n    String qualifierPattern = getQualifierPattern(pattern);\n\n    boolean empty = namePattern.length() == 0 || namePattern.equals(\"@\");    // TODO[yole]: remove implicit dependency\n    if (empty && !canShowListForEmptyPattern()) return false;\n\n    List<String> namesList = ChooseByNameBase.getNamesByPattern(this, namePattern, names, isCancelled);\n    if (isCancelled.compute()) {\n      throw new ProcessCanceledException();\n    }\n    // Here we sort using namePattern to have similar logic with empty qualified patten case\n    Collections.sort(namesList, new MatchesComparator(namePattern));\n\n    boolean overflow = false;\n    List<Object> sameNameElements = new SmartList<Object>();\n    All:\n    for (String name : namesList) {\n      if (isCancelled.compute()) {\n        throw new ProcessCanceledException();\n      }\n      final Object[] elements = myModel.getElementsByName(name, checkboxState, namePattern);\n      if (elements.length > 1) {\n        sameNameElements.clear();\n        for (final Object element : elements) {\n          if (matchesQualifier(element, qualifierPattern)) {\n            sameNameElements.add(element);\n          }\n        }\n        sortByProximity(sameNameElements);\n        for (Object element : sameNameElements) {\n          result.add(element);\n          if (result.size() >= maxCount) {\n            overflow = true;\n            break All;\n          }\n        }\n      }\n      else if (elements.length == 1 && matchesQualifier(elements[0], qualifierPattern)) {\n        result.add(elements[0]);\n        if (result.size() >= maxCount) {\n          overflow = true;\n          break;\n        }\n      }\n    }\n\n    return overflow;\n  }","commit_id":"1f0e4f1ddb81c6210ab0e9f448de1a28486d020e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public List<String> filterNames(@NotNull ChooseByNameBase base, @NotNull String[] names, @NotNull String pattern) {\n    List<String> res = new ArrayList<String>();\n    getNamesByPattern(base, Arrays.asList(names), null, res, pattern, MatchingMode.CASE_INSENSITIVE);\n    return res;\n  }","id":80226,"modified_method":"@NotNull\n  @Override\n  public List<String> filterNames(@NotNull ChooseByNameBase base, @NotNull String[] names, @NotNull String pattern) {\n    return getNamesByPattern(base, Arrays.asList(names), null, convertToMatchingPattern(base, pattern));\n  }","commit_id":"d85c578bd1be42162e4e8469430617a83522a378","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void sortNamesList(@NotNull String namePattern, @NotNull List<String> namesList) {\n    // Here we sort using namePattern to have similar logic with empty qualified patten case\n    Collections.sort(namesList, new MatchesComparator(namePattern));\n  }","id":80227,"modified_method":"protected void sortNamesList(@NotNull String namePattern, @NotNull List<String> namesList) {\n    final MinusculeMatcher matcher = buildPatternMatcher(namePattern, NameUtil.MatchingCaseSensitivity.NONE);\n    // Here we sort using namePattern to have similar logic with empty qualified patten case\n    Collections.sort(namesList, new Comparator<String>() {\n      @Override\n      public int compare(String o1, String o2) {\n        boolean start1 = matcher.isStartMatch(o1);\n        boolean start2 = matcher.isStartMatch(o2);\n        if (start1 != start2) return start1 ? -1 : 1;\n\n        int degree1 = matcher.matchingDegree(o2);\n        int degree2 = matcher.matchingDegree(o1);\n        if (degree1 < degree2) return -1;\n        if (degree1 > degree2) return 1;\n\n        return o1.compareToIgnoreCase(o2);\n      }\n    });\n  }","commit_id":"d85c578bd1be42162e4e8469430617a83522a378","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void getNamesByPattern(@NotNull final ChooseByNameBase base,\n                                        @NotNull List<String> names,\n                                        @Nullable ProgressIndicator indicator,\n                                        @NotNull final List<String> outListFiltered, // matched items\n                                        @NotNull String pattern,\n                                        @NotNull MatchingMode matchingMode) throws ProcessCanceledException {\n    if (!base.canShowListForEmptyPattern()) {\n      LOG.assertTrue(!pattern.isEmpty(), base);\n    }\n\n    if (StringUtil.startsWithChar(pattern, '@') && base.getModel() instanceof GotoClassModel2) {\n      pattern = pattern.substring(1);\n    }\n\n    final String finalPattern = pattern;\n    final Matcher matcher;\n\n    switch (matchingMode) {\n      case CASE_SENSITIVE:\n        matcher = buildPatternMatcher(pattern, NameUtil.MatchingCaseSensitivity.ALL);\n        break;\n      case CASE_INSENSITIVE:\n        matcher = buildPatternMatcher(pattern, NameUtil.MatchingCaseSensitivity.NONE);\n        break;\n      case STRICT_CASE_INSENSITIVE:\n        matcher = new Matcher() {\n          @Override\n          public boolean matches(@NotNull String name) {\n            return StringUtil.startsWithIgnoreCase(name, finalPattern);\n          }\n        };\n        break;\n      default:\n        return;\n    }\n\n    JobLauncher.getInstance().invokeConcurrentlyUnderProgress(names, indicator, false, new Processor<String>() {\n      @Override\n      public boolean process(String name) {\n        if (matches(base, finalPattern, matcher, name)) {\n          synchronized (outListFiltered) {\n            outListFiltered.add(name);\n          }\n        }\n        return true;\n      }\n    });\n  }","id":80228,"modified_method":"private static List<String> getNamesByPattern(@NotNull final ChooseByNameBase base,\n                                                @NotNull List<String> names,\n                                                @Nullable ProgressIndicator indicator,\n                                                final String pattern) \n    throws ProcessCanceledException {\n    final Matcher matcher = buildPatternMatcher(pattern, NameUtil.MatchingCaseSensitivity.NONE);\n\n    @NotNull final List<String> outListFiltered = new ArrayList<String>();\n    JobLauncher.getInstance().invokeConcurrentlyUnderProgress(names, indicator, false, new Processor<String>() {\n      @Override\n      public boolean process(String name) {\n        if (matches(base, pattern, matcher, name)) {\n          synchronized (outListFiltered) {\n            outListFiltered.add(name);\n          }\n        }\n        return true;\n      }\n    });\n    return outListFiltered;\n  }","commit_id":"d85c578bd1be42162e4e8469430617a83522a378","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return null if consumer returned false, number of consumed elements otherwise.\n   */\n  @Nullable\n  private Integer consumeElements(@NotNull ChooseByNameBase base,\n                                  boolean everywhere,\n                                  @NotNull ProgressIndicator indicator,\n                                  @NotNull Processor<Object> consumer,\n                                  @NotNull String namePattern,\n                                  @NotNull String qualifierPattern,\n                                  @NotNull Set<String> allNames,\n                                  @NotNull MatchingMode matchingMode,\n                                  boolean needSeparator) {\n    ChooseByNameModel model = base.getModel();\n    List<String> namesList = new ArrayList<String>();\n    getNamesByPattern(base, new ArrayList<String>(allNames), indicator, namesList, namePattern, matchingMode);\n    allNames.removeAll(namesList);\n    sortNamesList(namePattern, namesList);\n\n    indicator.checkCanceled();\n\n    List<Object> sameNameElements = new SmartList<Object>();\n    List<Pair<String, MinusculeMatcher>> patternsAndMatchers = getPatternsAndMatchers(qualifierPattern, base);\n    int elementsConsumed = 0;\n\n    for (String name : namesList) {\n      indicator.checkCanceled();\n\n      // use interruptible call if possible\n      Object[] elements = model instanceof ContributorsBasedGotoByModel ?\n                                ((ContributorsBasedGotoByModel)model).getElementsByName(name, everywhere, namePattern, indicator)\n                                : model.getElementsByName(name, everywhere, namePattern);\n      if (elements.length > 1) {\n        sameNameElements.clear();\n        for (final Object element : elements) {\n          indicator.checkCanceled();\n          if (matchesQualifier(element, base, patternsAndMatchers)) {\n            sameNameElements.add(element);\n          }\n        }\n        sortByProximity(base, sameNameElements);\n        for (Object element : sameNameElements) {\n          if (needSeparator && !consumer.process(ChooseByNameBase.NON_PREFIX_SEPARATOR)) return null;\n          if (!consumer.process(element)) return null;\n          needSeparator = false;\n          elementsConsumed++;\n        }\n      }\n      else if (elements.length == 1 && matchesQualifier(elements[0], base, patternsAndMatchers)) {\n        if (needSeparator && !consumer.process(ChooseByNameBase.NON_PREFIX_SEPARATOR)) return null;\n        if (!consumer.process(elements[0])) return null;\n        needSeparator = false;\n        elementsConsumed++;\n      }\n    }\n    return elementsConsumed;\n  }","id":80229,"modified_method":"private boolean consumeElements(@NotNull ChooseByNameBase base,\n                                  boolean everywhere,\n                                  @NotNull ProgressIndicator indicator,\n                                  @NotNull Processor<Object> consumer,\n                                  @NotNull String namePattern,\n                                  @NotNull String qualifierPattern,\n                                  @NotNull Set<String> allNames) {\n    ChooseByNameModel model = base.getModel();\n    String matchingPattern = convertToMatchingPattern(base, namePattern);\n    List<String> namesList = getNamesByPattern(base, new ArrayList<String>(allNames), indicator, matchingPattern);\n    allNames.removeAll(namesList);\n    sortNamesList(matchingPattern, namesList);\n\n    indicator.checkCanceled();\n\n    List<Object> sameNameElements = new SmartList<Object>();\n    List<Pair<String, MinusculeMatcher>> patternsAndMatchers = getPatternsAndMatchers(qualifierPattern, base);\n\n    MinusculeMatcher matcher = buildPatternMatcher(matchingPattern, NameUtil.MatchingCaseSensitivity.NONE);\n    boolean sortedByMatchingDegree = !(base.getModel() instanceof CustomMatcherModel);\n    boolean afterStartMatch = false;\n\n    for (String name : namesList) {\n      indicator.checkCanceled();\n      \n      boolean isStartMatch = matcher.isStartMatch(name);\n      boolean needSeparator = sortedByMatchingDegree && !isStartMatch && afterStartMatch;\n\n      // use interruptible call if possible\n      Object[] elements = model instanceof ContributorsBasedGotoByModel ?\n                                ((ContributorsBasedGotoByModel)model).getElementsByName(name, everywhere, namePattern, indicator)\n                                : model.getElementsByName(name, everywhere, namePattern);\n      if (elements.length > 1) {\n        sameNameElements.clear();\n        for (final Object element : elements) {\n          indicator.checkCanceled();\n          if (matchesQualifier(element, base, patternsAndMatchers)) {\n            sameNameElements.add(element);\n          }\n        }\n        sortByProximity(base, sameNameElements);\n        for (Object element : sameNameElements) {\n          if (needSeparator && !consumer.process(ChooseByNameBase.NON_PREFIX_SEPARATOR)) return false;\n          if (!consumer.process(element)) return false;\n          needSeparator = false;\n          afterStartMatch = isStartMatch;\n        }\n      }\n      else if (elements.length == 1 && matchesQualifier(elements[0], base, patternsAndMatchers)) {\n        if (needSeparator && !consumer.process(ChooseByNameBase.NON_PREFIX_SEPARATOR)) return false;\n        if (!consumer.process(elements[0])) return false;\n        afterStartMatch = isStartMatch;\n      }\n    }\n    return true;\n  }","commit_id":"d85c578bd1be42162e4e8469430617a83522a378","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean filterElements(@NotNull ChooseByNameBase base,\n                                @NotNull String pattern,\n                                boolean everywhere,\n                                @NotNull ProgressIndicator indicator,\n                                @NotNull Processor<Object> consumer) {\n    String namePattern = getNamePattern(base, pattern);\n    String qualifierPattern = getQualifierPattern(base, pattern);\n\n    ChooseByNameModel model = base.getModel();\n    boolean empty = namePattern.isEmpty() ||\n                    namePattern.equals(\"@\") && model instanceof GotoClassModel2;    // TODO[yole]: remove implicit dependency\n    if (empty && !base.canShowListForEmptyPattern()) return true;\n\n    Set<String> names = new THashSet<String>(Arrays.asList(base.getNames(everywhere)));\n\n    if (base.isSearchInAnyPlace() && !namePattern.trim().isEmpty()) {\n      String middleMatchPattern = \"*\" + namePattern;\n\n      // consume elements matching by prefix case-sensitively\n      Integer elementsConsumed = consumeElements(base, everywhere, indicator, consumer, namePattern, qualifierPattern, names,\n                                                 MatchingMode.CASE_SENSITIVE, false);\n      if (elementsConsumed == null) return false;\n\n      if (elementsConsumed == 0) {\n        // search for strict prefixes case-insensitively\n        elementsConsumed = consumeElements(base, everywhere, indicator, consumer, namePattern,\n                                           qualifierPattern, names, MatchingMode.STRICT_CASE_INSENSITIVE, false);\n        if (elementsConsumed == null) return false;\n\n        // search with original pattern without case sensitivity, don't add separator before found items\n        // result: items matched by prefix will always be above middle-matched items\n        Integer elementsConsumed2 = consumeElements(base, everywhere, indicator, consumer, namePattern,\n                                                    qualifierPattern, names, MatchingMode.CASE_INSENSITIVE, false);\n        if (elementsConsumed2 == null) return false;\n\n        elementsConsumed += elementsConsumed2;\n      }\n\n      // search with broadest criteria - middle match pattern, without case sensitivity\n      elementsConsumed = consumeElements(base, everywhere, indicator, consumer, middleMatchPattern,\n                                         qualifierPattern, names, MatchingMode.CASE_INSENSITIVE, elementsConsumed > 0);\n      return elementsConsumed != null;\n    }\n    else {\n      Integer elementsConsumed = consumeElements(base, everywhere, indicator, consumer, namePattern, qualifierPattern, names,\n                                                 MatchingMode.CASE_INSENSITIVE, false);\n      return elementsConsumed != null;\n    }\n  }","id":80230,"modified_method":"@Override\n  public boolean filterElements(@NotNull ChooseByNameBase base,\n                                @NotNull String pattern,\n                                boolean everywhere,\n                                @NotNull ProgressIndicator indicator,\n                                @NotNull Processor<Object> consumer) {\n    String namePattern = getNamePattern(base, pattern);\n    String qualifierPattern = getQualifierPattern(base, pattern);\n\n    ChooseByNameModel model = base.getModel();\n    boolean empty = namePattern.isEmpty() ||\n                    namePattern.equals(\"@\") && model instanceof GotoClassModel2;    // TODO[yole]: remove implicit dependency\n    if (empty && !base.canShowListForEmptyPattern()) return true;\n\n    Set<String> names = new THashSet<String>(Arrays.asList(base.getNames(everywhere)));\n\n    return consumeElements(base, everywhere, indicator, consumer, namePattern, qualifierPattern, names);\n  }","commit_id":"d85c578bd1be42162e4e8469430617a83522a378","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleMessage(Message message) {\n        try {\n            NSStack nsStack = new NSStack();\n            nsStack.push();\n\n            BindingOperationInfo operation = (BindingOperationInfo) message.getExchange().get(\n                            BindingOperationInfo.class.getName());\n\n            assert operation.getName() != null;\n\n            XMLStreamWriter xmlWriter = getXMLStreamWriter(message);\n\n\n            List<MessagePartInfo> parts = null;\n\n            if (!isRequestor(message)) {\n                parts = operation.getOutput().getMessageParts();\n                addOperationNode(nsStack, message, xmlWriter, true, operation);\n            } else {\n                parts = operation.getInput().getMessageParts();\n                addOperationNode(nsStack, message, xmlWriter, false, operation);\n            }\n            \n            MessageContentsList objs = MessageContentsList.getContentsList(message);\n            if (objs == null) {\n                return;\n            }\n            \n            \n            for (MessagePartInfo part : parts) {\n                if (objs.hasValue(part)) {\n                    Object o = objs.get(part);\n                    if (o == null) {\n                        //WSI-BP R2211 - RPC/Lit parts are not allowed to be xsi:nil\n                        throw new Fault(\n                            new org.apache.cxf.common.i18n.Message(\"BP_2211_RPCLIT_CANNOT_BE_NULL\",\n                                                                   LOG, part.getConcreteName()));\n                    }\n                   //WSI-BP R2737  -RPC/LIG part name space is empty\n                   // part.setConcreteName(new QName(\"\", part.getConcreteName().getLocalPart()));\n                }\n            }\n            writeParts(message, message.getExchange(), operation, objs, parts);\n            \n            // Finishing the writing.\n            xmlWriter.writeEndElement();            \n        } catch (XMLStreamException e) {\n            throw new Fault(e);\n        }\n    }","id":80231,"modified_method":"public void handleMessage(Message message) {\n        try {\n            NSStack nsStack = new NSStack();\n            nsStack.push();\n\n            BindingOperationInfo operation = (BindingOperationInfo) message.getExchange().get(\n                            BindingOperationInfo.class.getName());\n\n            assert operation.getName() != null;\n\n            XMLStreamWriter xmlWriter = getXMLStreamWriter(message);\n\n\n            List<MessagePartInfo> parts = null;\n\n            boolean output = false;\n            if (!isRequestor(message)) {\n                parts = operation.getOutput().getMessageParts();\n                output = true;\n            } else {\n                parts = operation.getInput().getMessageParts();\n                output = false;\n            }\n\n            MessageContentsList objs = MessageContentsList.getContentsList(message);\n            if (objs == null) {\n                addOperationNode(nsStack, message, xmlWriter, output, operation);\n                xmlWriter.writeEndElement();\n                return;\n            }\n\n            for (MessagePartInfo part : parts) {\n                if (objs.hasValue(part)) {\n                    Object o = objs.get(part);\n                    if (o == null) {\n                        //WSI-BP R2211 - RPC/Lit parts are not allowed to be xsi:nil\n                        throw new Fault(\n                            new org.apache.cxf.common.i18n.Message(\"BP_2211_RPCLIT_CANNOT_BE_NULL\",\n                                                                   LOG, part.getConcreteName()));\n                    }\n                   //WSI-BP R2737  -RPC/LIG part name space is empty\n                   // part.setConcreteName(new QName(\"\", part.getConcreteName().getLocalPart()));\n                }\n            }\n\n            addOperationNode(nsStack, message, xmlWriter, output, operation);\n            writeParts(message, message.getExchange(), operation, objs, parts);\n\n            // Finishing the writing.\n            xmlWriter.writeEndElement();            \n        } catch (XMLStreamException e) {\n            throw new Fault(e);\n        }\n    }","commit_id":"0b18aed8bf54f1b1bebe2448f5f3dd6d592fd8b6","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * A filter to filter based on several types.\n     */\n    public Filter typesFilter(String... types) {\n        if (types.length == 1) {\n            return documentMapper(types[0]).typeFilter();\n        }\n        PublicTermsFilter termsFilter = new PublicTermsFilter();\n        for (String type : types) {\n            termsFilter.addTerm(new Term(TypeFieldMapper.NAME, type));\n        }\n        return termsFilter;\n    }","id":80232,"modified_method":"/**\n     * A filter to filter based on several types.\n     */\n    public Filter typesFilter(String... types) {\n        if (types.length == 1) {\n            DocumentMapper docMapper = documentMapper(types[0]);\n            if (docMapper == null) {\n                throw new TypeMissingException(index, types[0]);\n            }\n            return docMapper.typeFilter();\n        }\n        PublicTermsFilter termsFilter = new PublicTermsFilter();\n        for (String type : types) {\n            if (!hasMapping(type)) {\n                throw new TypeMissingException(index, type);\n            }\n            termsFilter.addTerm(new Term(TypeFieldMapper.NAME, type));\n        }\n        return termsFilter;\n    }","commit_id":"f8b1d1eebdd144d07bf83c1bbcc034a83890ff68","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override protected GetResponse shardOperation(GetRequest request, int shardId) throws ElasticSearchException {\n        IndexService indexService = indicesService.indexServiceSafe(request.index());\n        IndexShard indexShard = indexService.shardSafe(shardId);\n\n        DocumentMapper docMapper = indexService.mapperService().documentMapper(request.type());\n        if (docMapper == null) {\n            throw new DocumentMapperNotFoundException(\"No mapper found for type [\" + request.type() + \"]\");\n        }\n\n        if (request.refresh()) {\n            indexShard.refresh(new Engine.Refresh(false));\n        }\n\n        Engine.Searcher searcher = indexShard.searcher();\n        boolean exists = false;\n        byte[] source = null;\n        Map<String, GetField> fields = null;\n        long version = -1;\n        try {\n            UidField.DocIdAndVersion docIdAndVersion = UidField.loadDocIdAndVersion(searcher.reader(), docMapper.uidMapper().term(request.type(), request.id()));\n            if (docIdAndVersion.docId != Lucene.NO_DOC) {\n                if (docIdAndVersion.version > 0) {\n                    version = docIdAndVersion.version;\n                }\n                exists = true;\n                FieldSelector fieldSelector = buildFieldSelectors(docMapper, request.fields());\n                if (fieldSelector != null) {\n                    Document doc = searcher.reader().document(docIdAndVersion.docId, fieldSelector);\n                    source = extractSource(doc, docMapper);\n\n                    for (Object oField : doc.getFields()) {\n                        Fieldable field = (Fieldable) oField;\n                        String name = field.name();\n                        Object value = null;\n                        FieldMappers fieldMappers = docMapper.mappers().indexName(field.name());\n                        if (fieldMappers != null) {\n                            FieldMapper mapper = fieldMappers.mapper();\n                            if (mapper != null) {\n                                name = mapper.names().fullName();\n                                value = mapper.valueForSearch(field);\n                            }\n                        }\n                        if (value == null) {\n                            if (field.isBinary()) {\n                                value = field.getBinaryValue();\n                            } else {\n                                value = field.stringValue();\n                            }\n                        }\n\n                        if (fields == null) {\n                            fields = newHashMapWithExpectedSize(2);\n                        }\n\n                        GetField getField = fields.get(name);\n                        if (getField == null) {\n                            getField = new GetField(name, new ArrayList<Object>(2));\n                            fields.put(name, getField);\n                        }\n                        getField.values().add(value);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            throw new ElasticSearchException(\"Failed to get type [\" + request.type() + \"] and id [\" + request.id() + \"]\", e);\n        } finally {\n            searcher.release();\n        }\n        return new GetResponse(request.index(), request.type(), request.id(), version, exists, source, fields);\n    }","id":80233,"modified_method":"@Override protected GetResponse shardOperation(GetRequest request, int shardId) throws ElasticSearchException {\n        IndexService indexService = indicesService.indexServiceSafe(request.index());\n        IndexShard indexShard = indexService.shardSafe(shardId);\n\n        DocumentMapper docMapper = indexService.mapperService().documentMapper(request.type());\n        if (docMapper == null) {\n            throw new TypeMissingException(new Index(request.index()), request.type());\n        }\n\n        if (request.refresh()) {\n            indexShard.refresh(new Engine.Refresh(false));\n        }\n\n        Engine.Searcher searcher = indexShard.searcher();\n        boolean exists = false;\n        byte[] source = null;\n        Map<String, GetField> fields = null;\n        long version = -1;\n        try {\n            UidField.DocIdAndVersion docIdAndVersion = UidField.loadDocIdAndVersion(searcher.reader(), docMapper.uidMapper().term(request.type(), request.id()));\n            if (docIdAndVersion.docId != Lucene.NO_DOC) {\n                if (docIdAndVersion.version > 0) {\n                    version = docIdAndVersion.version;\n                }\n                exists = true;\n                FieldSelector fieldSelector = buildFieldSelectors(docMapper, request.fields());\n                if (fieldSelector != null) {\n                    Document doc = searcher.reader().document(docIdAndVersion.docId, fieldSelector);\n                    source = extractSource(doc, docMapper);\n\n                    for (Object oField : doc.getFields()) {\n                        Fieldable field = (Fieldable) oField;\n                        String name = field.name();\n                        Object value = null;\n                        FieldMappers fieldMappers = docMapper.mappers().indexName(field.name());\n                        if (fieldMappers != null) {\n                            FieldMapper mapper = fieldMappers.mapper();\n                            if (mapper != null) {\n                                name = mapper.names().fullName();\n                                value = mapper.valueForSearch(field);\n                            }\n                        }\n                        if (value == null) {\n                            if (field.isBinary()) {\n                                value = field.getBinaryValue();\n                            } else {\n                                value = field.stringValue();\n                            }\n                        }\n\n                        if (fields == null) {\n                            fields = newHashMapWithExpectedSize(2);\n                        }\n\n                        GetField getField = fields.get(name);\n                        if (getField == null) {\n                            getField = new GetField(name, new ArrayList<Object>(2));\n                            fields.put(name, getField);\n                        }\n                        getField.values().add(value);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            throw new ElasticSearchException(\"Failed to get type [\" + request.type() + \"] and id [\" + request.id() + \"]\", e);\n        } finally {\n            searcher.release();\n        }\n        return new GetResponse(request.index(), request.type(), request.id(), version, exists, source, fields);\n    }","commit_id":"f8b1d1eebdd144d07bf83c1bbcc034a83890ff68","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void prepare(PercolateContext context, ParsedDocument parsedDocument) {\n        IndexReader[] memoryIndices = new IndexReader[parsedDocument.docs().size()];\n        List<ParseContext.Document> docs = parsedDocument.docs();\n        int rootDocIndex = docs.size() - 1;\n        assert rootDocIndex > 0;\n        MemoryIndex rootDocMemoryIndex = null;\n        for (int i = 0; i < docs.size(); i++) {\n            ParseContext.Document d = docs.get(i);\n            MemoryIndex memoryIndex;\n            if (rootDocIndex == i) {\n                // the last doc is always the rootDoc, since that is usually the biggest document it make sense\n                // to reuse the MemoryIndex it uses\n                memoryIndex = rootDocMemoryIndex = cache.get();\n            } else {\n                memoryIndex = new MemoryIndex(true);\n            }\n            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();\n            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();\n        }\n        try {\n            MultiReader mReader = new MultiReader(memoryIndices, true);\n            LeafReader slowReader = SlowCompositeReaderWrapper.wrap(mReader);\n            final IndexSearcher slowSearcher = new IndexSearcher(slowReader) {\n\n                @Override\n                public Weight createNormalizedWeight(Query query, boolean needsScores) throws IOException {\n                    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n                    bq.add(query, BooleanClause.Occur.MUST);\n                    bq.add(Queries.newNestedFilter(), BooleanClause.Occur.MUST_NOT);\n                    return super.createNormalizedWeight(bq.build(), needsScores);\n                }\n\n            };\n            slowSearcher.setQueryCache(null);\n            DocSearcher docSearcher = new DocSearcher(slowSearcher, rootDocMemoryIndex);\n            context.initialize(docSearcher, parsedDocument);\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"Failed to create index for percolator with nested document \", e);\n        }\n    }","id":80234,"modified_method":"@Override\n    public void prepare(PercolateContext context, ParsedDocument parsedDocument) {\n        IndexReader[] memoryIndices = new IndexReader[parsedDocument.docs().size()];\n        List<ParseContext.Document> docs = parsedDocument.docs();\n        int rootDocIndex = docs.size() - 1;\n        assert rootDocIndex > 0;\n        MemoryIndex rootDocMemoryIndex = null;\n        for (int i = 0; i < docs.size(); i++) {\n            ParseContext.Document d = docs.get(i);\n            MemoryIndex memoryIndex;\n            if (rootDocIndex == i) {\n                // the last doc is always the rootDoc, since that is usually the biggest document it make sense\n                // to reuse the MemoryIndex it uses\n                memoryIndex = rootDocMemoryIndex = cache.get();\n            } else {\n                memoryIndex = new MemoryIndex(true);\n            }\n            memoryIndices[i] = indexDoc(d, memoryIndex, context, parsedDocument).createSearcher().getIndexReader();\n        }\n        try {\n            MultiReader mReader = new MultiReader(memoryIndices, true);\n            LeafReader slowReader = SlowCompositeReaderWrapper.wrap(mReader);\n            final IndexSearcher slowSearcher = new IndexSearcher(slowReader) {\n\n                @Override\n                public Weight createNormalizedWeight(Query query, boolean needsScores) throws IOException {\n                    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n                    bq.add(query, BooleanClause.Occur.MUST);\n                    bq.add(Queries.newNestedFilter(), BooleanClause.Occur.MUST_NOT);\n                    return super.createNormalizedWeight(bq.build(), needsScores);\n                }\n\n            };\n            slowSearcher.setQueryCache(null);\n            DocSearcher docSearcher = new DocSearcher(slowSearcher, rootDocMemoryIndex);\n            context.initialize(docSearcher, parsedDocument);\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"Failed to create index for percolator with nested document \", e);\n        }\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {\n        for (IndexableField field : d.getFields()) {\n            if (field.fieldType().indexOptions() == IndexOptions.NONE && field.name().equals(UidFieldMapper.NAME)) {\n                continue;\n            }\n            try {\n                // TODO: instead of passing null here, we can have a CTL<Map<String,TokenStream>> and pass previous,\n                // like the indexer does\n                try (TokenStream tokenStream = field.tokenStream(analyzer, null)) {\n                    if (tokenStream != null) {\n                        memoryIndex.addField(field.name(), tokenStream, field.boost());\n                    }\n                 }\n            } catch (IOException e) {\n                throw new ElasticsearchException(\"Failed to create token stream\", e);\n            }\n        }\n        return memoryIndex;\n    }","id":80235,"modified_method":"MemoryIndex indexDoc(ParseContext.Document d, MemoryIndex memoryIndex, PercolateContext context, ParsedDocument parsedDocument) {\n        for (IndexableField field : d.getFields()) {\n            Analyzer analyzer = context.analysisService().defaultIndexAnalyzer();\n            DocumentMapper documentMapper = context.mapperService().documentMapper(parsedDocument.type());\n            if (documentMapper != null && documentMapper.mappers().getMapper(field.name()) != null) {\n                analyzer =  documentMapper.mappers().indexAnalyzer();\n            }\n            if (field.fieldType().indexOptions() == IndexOptions.NONE && field.name().equals(UidFieldMapper.NAME)) {\n                continue;\n            }\n            try {\n                // TODO: instead of passing null here, we can have a CTL<Map<String,TokenStream>> and pass previous,\n                // like the indexer does\n                try (TokenStream tokenStream = field.tokenStream(analyzer, null)) {\n                    if (tokenStream != null) {\n                        memoryIndex.addField(field.name(), tokenStream, field.boost());\n                    }\n                 }\n            } catch (IOException e) {\n                throw new ElasticsearchException(\"Failed to create token stream\", e);\n            }\n        }\n        return memoryIndex;\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ParsedDocument parse(PercolateShardRequest request, PercolateContext context, MapperService mapperService, QueryShardContext queryShardContext) {\n        BytesReference source = request.source();\n        if (source == null || source.length() == 0) {\n            if (request.docSource() != null && request.docSource().length() != 0) {\n                return parseFetchedDoc(context, request.docSource(), mapperService, request.shardId().getIndex(), request.documentType());\n            } else {\n                return null;\n            }\n        }\n\n        // TODO: combine all feature parse elements into one map\n        Map<String, ? extends SearchParseElement> hlElements = highlightPhase.parseElements();\n        Map<String, ? extends SearchParseElement> aggregationElements = aggregationPhase.parseElements();\n\n        ParsedDocument doc = null;\n        // Some queries (function_score query when for decay functions) rely on a SearchContext being set:\n        // We switch types because this context needs to be in the context of the percolate queries in the shard and\n        // not the in memory percolate doc\n        String[] previousTypes = context.types();\n        context.types(new String[]{PercolatorService.TYPE_NAME});\n        try (XContentParser parser = XContentFactory.xContent(source).createParser(source);) {\n            String currentFieldName = null;\n            XContentParser.Token token;\n            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                if (token == XContentParser.Token.FIELD_NAME) {\n                    currentFieldName = parser.currentName();\n                    // we need to check the \"doc\" here, so the next token will be START_OBJECT which is\n                    // the actual document starting\n                    if (\"doc\".equals(currentFieldName)) {\n                        if (doc != null) {\n                            throw new ElasticsearchParseException(\"Either specify doc or get, not both\");\n                        }\n\n                        DocumentMapperForType docMapper = mapperService.documentMapperWithAutoCreate(request.documentType());\n                        String index = context.shardTarget().index();\n                        doc = docMapper.getDocumentMapper().parse(source(parser).index(index).type(request.documentType()).flyweight(true));\n                        if (docMapper.getMapping() != null) {\n                            doc.addDynamicMappingsUpdate(docMapper.getMapping());\n                        }\n                        if (doc.dynamicMappingsUpdate() != null) {\n                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());\n                        }\n                        // the document parsing exists the \"doc\" object, so we need to set the new current field.\n                        currentFieldName = parser.currentName();\n                    }\n                } else if (token == XContentParser.Token.START_OBJECT) {\n                    SearchParseElement element = hlElements.get(currentFieldName);\n                    if (element == null) {\n                        element = aggregationElements.get(currentFieldName);\n                    }\n\n                    if (\"query\".equals(currentFieldName)) {\n                        if (context.percolateQuery() != null) {\n                            throw new ElasticsearchParseException(\"Either specify query or filter, not both\");\n                        }\n                        context.percolateQuery(queryShardContext.parse(parser).query());\n                    } else if (\"filter\".equals(currentFieldName)) {\n                        if (context.percolateQuery() != null) {\n                            throw new ElasticsearchParseException(\"Either specify query or filter, not both\");\n                        }\n                        Query filter = queryShardContext.parseInnerFilter(parser).query();\n                        context.percolateQuery(new ConstantScoreQuery(filter));\n                    } else if (\"sort\".equals(currentFieldName)) {\n                        parseSort(parser, context);\n                    } else if (element != null) {\n                        element.parse(parser, context);\n                    }\n                } else if (token == XContentParser.Token.START_ARRAY) {\n                    if (\"sort\".equals(currentFieldName)) {\n                        parseSort(parser, context);\n                    }\n                } else if (token == null) {\n                    break;\n                } else if (token.isValue()) {\n                    if (\"size\".equals(currentFieldName)) {\n                        context.size(parser.intValue());\n                        if (context.size() < 0) {\n                            throw new ElasticsearchParseException(\"size is set to [{}] and is expected to be higher or equal to 0\", context.size());\n                        }\n                    } else if (\"sort\".equals(currentFieldName)) {\n                        parseSort(parser, context);\n                    } else if (\"track_scores\".equals(currentFieldName) || \"trackScores\".equals(currentFieldName)) {\n                        context.trackScores(parser.booleanValue());\n                    }\n                }\n            }\n\n            // We need to get the actual source from the request body for highlighting, so parse the request body again\n            // and only get the doc source.\n            if (context.highlight() != null) {\n                parser.close();\n                currentFieldName = null;\n                try (XContentParser parserForHighlighter = XContentFactory.xContent(source).createParser(source)) {\n                    token = parserForHighlighter.nextToken();\n                    assert token == XContentParser.Token.START_OBJECT;\n                    while ((token = parserForHighlighter.nextToken()) != XContentParser.Token.END_OBJECT) {\n                        if (token == XContentParser.Token.FIELD_NAME) {\n                            currentFieldName = parserForHighlighter.currentName();\n                        } else if (token == XContentParser.Token.START_OBJECT) {\n                            if (\"doc\".equals(currentFieldName)) {\n                                BytesStreamOutput bStream = new BytesStreamOutput();\n                                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.SMILE, bStream);\n                                builder.copyCurrentStructure(parserForHighlighter);\n                                builder.close();\n                                doc.setSource(bStream.bytes());\n                                break;\n                            } else {\n                                parserForHighlighter.skipChildren();\n                            }\n                        } else if (token == null) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n        } catch (Throwable e) {\n            throw new ElasticsearchParseException(\"failed to parse request\", e);\n        } finally {\n            context.types(previousTypes);\n        }\n\n        if (request.docSource() != null && request.docSource().length() != 0) {\n            if (doc != null) {\n                throw new IllegalArgumentException(\"Can't specify the document to percolate in the source of the request and as document id\");\n            }\n\n            doc = parseFetchedDoc(context, request.docSource(), mapperService, request.shardId().getIndex(), request.documentType());\n        }\n\n        if (doc == null) {\n            throw new IllegalArgumentException(\"Nothing to percolate\");\n        }\n\n        return doc;\n    }","id":80236,"modified_method":"public ParsedDocument parse(PercolateShardRequest request, PercolateContext context, MapperService mapperService, QueryShardContext queryShardContext) {\n        BytesReference source = request.source();\n        if (source == null || source.length() == 0) {\n            if (request.docSource() != null && request.docSource().length() != 0) {\n                return parseFetchedDoc(context, request.docSource(), mapperService, request.shardId().getIndex(), request.documentType());\n            } else {\n                return null;\n            }\n        }\n\n        // TODO: combine all feature parse elements into one map\n        Map<String, ? extends SearchParseElement> hlElements = highlightPhase.parseElements();\n        Map<String, ? extends SearchParseElement> aggregationElements = aggregationPhase.parseElements();\n\n        ParsedDocument doc = null;\n        // Some queries (function_score query when for decay functions) rely on a SearchContext being set:\n        // We switch types because this context needs to be in the context of the percolate queries in the shard and\n        // not the in memory percolate doc\n        String[] previousTypes = context.types();\n        context.types(new String[]{PercolatorService.TYPE_NAME});\n        try (XContentParser parser = XContentFactory.xContent(source).createParser(source);) {\n            String currentFieldName = null;\n            XContentParser.Token token;\n            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                if (token == XContentParser.Token.FIELD_NAME) {\n                    currentFieldName = parser.currentName();\n                    // we need to check the \"doc\" here, so the next token will be START_OBJECT which is\n                    // the actual document starting\n                    if (\"doc\".equals(currentFieldName)) {\n                        if (doc != null) {\n                            throw new ElasticsearchParseException(\"Either specify doc or get, not both\");\n                        }\n\n                        DocumentMapperForType docMapper = mapperService.documentMapperWithAutoCreate(request.documentType());\n                        String index = context.shardTarget().index();\n                        doc = docMapper.getDocumentMapper().parse(source(parser).index(index).type(request.documentType()).flyweight(true));\n                        if (docMapper.getMapping() != null) {\n                            doc.addDynamicMappingsUpdate(docMapper.getMapping());\n                        }\n                        // the document parsing exists the \"doc\" object, so we need to set the new current field.\n                        currentFieldName = parser.currentName();\n                    }\n                } else if (token == XContentParser.Token.START_OBJECT) {\n                    SearchParseElement element = hlElements.get(currentFieldName);\n                    if (element == null) {\n                        element = aggregationElements.get(currentFieldName);\n                    }\n\n                    if (\"query\".equals(currentFieldName)) {\n                        if (context.percolateQuery() != null) {\n                            throw new ElasticsearchParseException(\"Either specify query or filter, not both\");\n                        }\n                        context.percolateQuery(queryShardContext.parse(parser).query());\n                    } else if (\"filter\".equals(currentFieldName)) {\n                        if (context.percolateQuery() != null) {\n                            throw new ElasticsearchParseException(\"Either specify query or filter, not both\");\n                        }\n                        Query filter = queryShardContext.parseInnerFilter(parser).query();\n                        context.percolateQuery(new ConstantScoreQuery(filter));\n                    } else if (\"sort\".equals(currentFieldName)) {\n                        parseSort(parser, context);\n                    } else if (element != null) {\n                        element.parse(parser, context);\n                    }\n                } else if (token == XContentParser.Token.START_ARRAY) {\n                    if (\"sort\".equals(currentFieldName)) {\n                        parseSort(parser, context);\n                    }\n                } else if (token == null) {\n                    break;\n                } else if (token.isValue()) {\n                    if (\"size\".equals(currentFieldName)) {\n                        context.size(parser.intValue());\n                        if (context.size() < 0) {\n                            throw new ElasticsearchParseException(\"size is set to [{}] and is expected to be higher or equal to 0\", context.size());\n                        }\n                    } else if (\"sort\".equals(currentFieldName)) {\n                        parseSort(parser, context);\n                    } else if (\"track_scores\".equals(currentFieldName) || \"trackScores\".equals(currentFieldName)) {\n                        context.trackScores(parser.booleanValue());\n                    }\n                }\n            }\n\n            // We need to get the actual source from the request body for highlighting, so parse the request body again\n            // and only get the doc source.\n            if (context.highlight() != null) {\n                parser.close();\n                currentFieldName = null;\n                try (XContentParser parserForHighlighter = XContentFactory.xContent(source).createParser(source)) {\n                    token = parserForHighlighter.nextToken();\n                    assert token == XContentParser.Token.START_OBJECT;\n                    while ((token = parserForHighlighter.nextToken()) != XContentParser.Token.END_OBJECT) {\n                        if (token == XContentParser.Token.FIELD_NAME) {\n                            currentFieldName = parserForHighlighter.currentName();\n                        } else if (token == XContentParser.Token.START_OBJECT) {\n                            if (\"doc\".equals(currentFieldName)) {\n                                BytesStreamOutput bStream = new BytesStreamOutput();\n                                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.SMILE, bStream);\n                                builder.copyCurrentStructure(parserForHighlighter);\n                                builder.close();\n                                doc.setSource(bStream.bytes());\n                                break;\n                            } else {\n                                parserForHighlighter.skipChildren();\n                            }\n                        } else if (token == null) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n        } catch (Throwable e) {\n            throw new ElasticsearchParseException(\"failed to parse request\", e);\n        } finally {\n            context.types(previousTypes);\n        }\n\n        if (request.docSource() != null && request.docSource().length() != 0) {\n            if (doc != null) {\n                throw new IllegalArgumentException(\"Can't specify the document to percolate in the source of the request and as document id\");\n            }\n\n            doc = parseFetchedDoc(context, request.docSource(), mapperService, request.shardId().getIndex(), request.documentType());\n        }\n\n        if (doc == null) {\n            throw new IllegalArgumentException(\"Nothing to percolate\");\n        }\n\n        return doc;\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {\n        this.highlightPhase = highlightPhase;\n        this.sortParseElement = sortParseElement;\n        this.aggregationPhase = aggregationPhase;\n        this.mappingUpdatedAction = mappingUpdatedAction;\n    }","id":80237,"modified_method":"@Inject\n    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement,\n                                   AggregationPhase aggregationPhase) {\n        this.highlightPhase = highlightPhase;\n        this.sortParseElement = sortParseElement;\n        this.aggregationPhase = aggregationPhase;\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void init() {\n        IndexSettings indexSettings = new IndexSettings(new IndexMetaData.Builder(\"_index\").settings(\n                Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)\n                        .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n                        .build(), Settings.EMPTY);\n        AnalysisService analysisService = new AnalysisService(indexSettings, Collections.<String, AnalyzerProvider>emptyMap(), Collections.<String, TokenizerFactory>emptyMap(), Collections.<String, CharFilterFactory>emptyMap(), Collections.<String, TokenFilterFactory>emptyMap());\n        IndicesModule indicesModule = new IndicesModule();\n        mapperService = new MapperService(indexSettings, analysisService, new SimilarityService(indexSettings, Collections.emptyMap()), indicesModule.getMapperRegistry(), () -> null);\n\n        Map<String, QueryParser<?>> parsers = singletonMap(\"term\", new TermQueryParser());\n        IndicesQueriesRegistry indicesQueriesRegistry = new IndicesQueriesRegistry(indexSettings.getSettings(), parsers);\n\n        queryShardContext = new QueryShardContext(indexSettings, null, null, null, mapperService, null, null, indicesQueriesRegistry);\n\n        HighlightPhase highlightPhase = new HighlightPhase(Settings.EMPTY, new Highlighters());\n        AggregatorParsers aggregatorParsers = new AggregatorParsers(Collections.emptySet(), Collections.emptySet());\n        AggregationPhase aggregationPhase = new AggregationPhase(new AggregationParseElement(aggregatorParsers), new AggregationBinaryParseElement(aggregatorParsers));\n        MappingUpdatedAction mappingUpdatedAction = Mockito.mock(MappingUpdatedAction.class);\n        parser = new PercolateDocumentParser(\n                highlightPhase, new SortParseElement(), aggregationPhase, mappingUpdatedAction\n        );\n\n        request = Mockito.mock(PercolateShardRequest.class);\n        Mockito.when(request.shardId()).thenReturn(new ShardId(new Index(\"_index\"), 0));\n        Mockito.when(request.documentType()).thenReturn(\"type\");\n    }","id":80238,"modified_method":"@Before\n    public void init() {\n        IndexSettings indexSettings = new IndexSettings(new IndexMetaData.Builder(\"_index\").settings(\n                Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)\n                        .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n                        .build(), Settings.EMPTY);\n        AnalysisService analysisService = new AnalysisService(indexSettings, Collections.<String, AnalyzerProvider>emptyMap(), Collections.<String, TokenizerFactory>emptyMap(), Collections.<String, CharFilterFactory>emptyMap(), Collections.<String, TokenFilterFactory>emptyMap());\n        IndicesModule indicesModule = new IndicesModule();\n        mapperService = new MapperService(indexSettings, analysisService, new SimilarityService(indexSettings, Collections.emptyMap()), indicesModule.getMapperRegistry(), () -> null);\n\n        Map<String, QueryParser<?>> parsers = singletonMap(\"term\", new TermQueryParser());\n        IndicesQueriesRegistry indicesQueriesRegistry = new IndicesQueriesRegistry(indexSettings.getSettings(), parsers);\n\n        queryShardContext = new QueryShardContext(indexSettings, null, null, null, mapperService, null, null, indicesQueriesRegistry);\n\n        HighlightPhase highlightPhase = new HighlightPhase(Settings.EMPTY, new Highlighters());\n        AggregatorParsers aggregatorParsers = new AggregatorParsers(Collections.emptySet(), Collections.emptySet());\n        AggregationPhase aggregationPhase = new AggregationPhase(new AggregationParseElement(aggregatorParsers), new AggregationBinaryParseElement(aggregatorParsers));\n        parser = new PercolateDocumentParser(highlightPhase, new SortParseElement(), aggregationPhase);\n\n        request = Mockito.mock(PercolateShardRequest.class);\n        Mockito.when(request.shardId()).thenReturn(new ShardId(new Index(\"_index\"), 0));\n        Mockito.when(request.documentType()).thenReturn(\"type\");\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimple2() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", \"field1\", \"type=long,doc_values=true\"));\n        ensureGreen();\n\n        // introduce the doc\n        XContentBuilder doc = XContentFactory.jsonBuilder().startObject().startObject(\"doc\")\n                .field(\"field1\", 1)\n                .field(\"field2\", \"value\")\n                .endObject().endObject();\n\n        PercolateResponse response = client().preparePercolate().setSource(doc)\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .execute().actionGet();\n        assertMatchCount(response, 0l);\n        assertThat(response.getMatches(), emptyArray());\n\n        // add first query...\n        client().prepareIndex(\"test\", PercolatorService.TYPE_NAME, \"test1\")\n                .setSource(XContentFactory.jsonBuilder().startObject().field(\"query\", termQuery(\"field2\", \"value\")).endObject())\n                .execute().actionGet();\n        refresh();\n\n        response = client().preparePercolate()\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .setSource(doc).execute().actionGet();\n        assertMatchCount(response, 1l);\n        assertThat(response.getMatches(), arrayWithSize(1));\n        assertThat(convertFromTextArray(response.getMatches(), \"test\"), arrayContaining(\"test1\"));\n\n        // add second query...\n        client().prepareIndex(\"test\", PercolatorService.TYPE_NAME, \"test2\")\n                .setSource(XContentFactory.jsonBuilder().startObject().field(\"query\", termQuery(\"field1\", 1)).endObject())\n                .execute().actionGet();\n        refresh();\n\n        response = client().preparePercolate()\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .setSource(doc)\n                .execute().actionGet();\n        assertMatchCount(response, 2l);\n        assertThat(response.getMatches(), arrayWithSize(2));\n        assertThat(convertFromTextArray(response.getMatches(), \"test\"), arrayContainingInAnyOrder(\"test1\", \"test2\"));\n\n\n        client().prepareDelete(\"test\", PercolatorService.TYPE_NAME, \"test2\").execute().actionGet();\n        refresh();\n        response = client().preparePercolate()\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .setSource(doc).execute().actionGet();\n        assertMatchCount(response, 1l);\n        assertThat(response.getMatches(), arrayWithSize(1));\n        assertThat(convertFromTextArray(response.getMatches(), \"test\"), arrayContaining(\"test1\"));\n    }","id":80239,"modified_method":"public void testSimple2() throws Exception {\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", \"field1\", \"type=long,doc_values=true\", \"field2\", \"type=string\"));\n        ensureGreen();\n\n        // introduce the doc\n        XContentBuilder doc = XContentFactory.jsonBuilder().startObject().startObject(\"doc\")\n                .field(\"field1\", 1)\n                .field(\"field2\", \"value\")\n                .endObject().endObject();\n\n        PercolateResponse response = client().preparePercolate().setSource(doc)\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .execute().actionGet();\n        assertMatchCount(response, 0l);\n        assertThat(response.getMatches(), emptyArray());\n\n        // add first query...\n        client().prepareIndex(\"test\", PercolatorService.TYPE_NAME, \"test1\")\n                .setSource(XContentFactory.jsonBuilder().startObject().field(\"query\", termQuery(\"field2\", \"value\")).endObject())\n                .execute().actionGet();\n        refresh();\n\n        response = client().preparePercolate()\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .setSource(doc).execute().actionGet();\n        assertMatchCount(response, 1l);\n        assertThat(response.getMatches(), arrayWithSize(1));\n        assertThat(convertFromTextArray(response.getMatches(), \"test\"), arrayContaining(\"test1\"));\n\n        // add second query...\n        client().prepareIndex(\"test\", PercolatorService.TYPE_NAME, \"test2\")\n                .setSource(XContentFactory.jsonBuilder().startObject().field(\"query\", termQuery(\"field1\", 1)).endObject())\n                .execute().actionGet();\n        refresh();\n\n        response = client().preparePercolate()\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .setSource(doc)\n                .execute().actionGet();\n        assertMatchCount(response, 2l);\n        assertThat(response.getMatches(), arrayWithSize(2));\n        assertThat(convertFromTextArray(response.getMatches(), \"test\"), arrayContainingInAnyOrder(\"test1\", \"test2\"));\n\n\n        client().prepareDelete(\"test\", PercolatorService.TYPE_NAME, \"test2\").execute().actionGet();\n        refresh();\n        response = client().preparePercolate()\n                .setIndices(\"test\").setDocumentType(\"type1\")\n                .setSource(doc).execute().actionGet();\n        assertMatchCount(response, 1l);\n        assertThat(response.getMatches(), arrayWithSize(1));\n        assertThat(convertFromTextArray(response.getMatches(), \"test\"), arrayContaining(\"test1\"));\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public PercolateShardResponse percolate(PercolateShardRequest request) throws IOException {\n        IndexService percolateIndexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n        IndexShard indexShard = percolateIndexService.getShard(request.shardId().id());\n        indexShard.readAllowed(); // check if we can read the shard...\n        PercolatorQueriesRegistry percolateQueryRegistry = indexShard.percolateRegistry();\n        percolateQueryRegistry.prePercolate();\n        long startTime = System.nanoTime();\n\n        // TODO: The filteringAliases should be looked up at the coordinating node and serialized with all shard request,\n        // just like is done in other apis.\n        String[] filteringAliases = indexNameExpressionResolver.filteringAliases(\n                clusterService.state(),\n                indexShard.shardId().index().name(),\n                request.indices()\n        );\n        Query aliasFilter = percolateIndexService.aliasFilter(indexShard.getQueryShardContext(), filteringAliases);\n\n        SearchShardTarget searchShardTarget = new SearchShardTarget(clusterService.localNode().id(), request.shardId().getIndex(), request.shardId().id());\n        final PercolateContext context = new PercolateContext(\n                request, searchShardTarget, indexShard, percolateIndexService, pageCacheRecycler, bigArrays, scriptService, aliasFilter, parseFieldMatcher\n        );\n        SearchContext.setCurrent(context);\n        try {\n            ParsedDocument parsedDocument = percolateDocumentParser.parse(request, context, percolateIndexService.mapperService(), percolateIndexService.getQueryShardContext());\n\n            if (context.searcher().getIndexReader().maxDoc() == 0) {\n                return new PercolateShardResponse(Lucene.EMPTY_TOP_DOCS, Collections.emptyMap(), Collections.emptyMap(), context);\n            }\n            if (context.size() < 0) {\n                context.size(0);\n            }\n\n            // parse the source either into one MemoryIndex, if it is a single document or index multiple docs if nested\n            PercolatorIndex percolatorIndex;\n            boolean isNested = indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();\n            if (parsedDocument.docs().size() > 1) {\n                assert isNested;\n                percolatorIndex = multi;\n            } else {\n                percolatorIndex = single;\n            }\n            percolatorIndex.prepare(context, parsedDocument);\n\n            BucketCollector aggregatorCollector = null;\n            if (context.aggregations() != null) {\n                AggregationContext aggregationContext = new AggregationContext(context);\n                context.aggregations().aggregationContext(aggregationContext);\n\n                Aggregator[] aggregators = context.aggregations().factories().createTopLevelAggregators(aggregationContext);\n                List<Aggregator> aggregatorCollectors = new ArrayList<>(aggregators.length);\n                for (int i = 0; i < aggregators.length; i++) {\n                    if (!(aggregators[i] instanceof GlobalAggregator)) {\n                        Aggregator aggregator = aggregators[i];\n                        aggregatorCollectors.add(aggregator);\n                    }\n                }\n                context.aggregations().aggregators(aggregators);\n                aggregatorCollector = BucketCollector.wrap(aggregatorCollectors);\n                aggregatorCollector.preCollection();\n            }\n            PercolatorQueriesRegistry queriesRegistry = indexShard.percolateRegistry();\n            return doPercolate(context, queriesRegistry, aggregationPhase, aggregatorCollector, highlightPhase);\n        } finally {\n            SearchContext.removeCurrent();\n            context.close();\n            percolateQueryRegistry.postPercolate(System.nanoTime() - startTime);\n        }\n    }","id":80240,"modified_method":"public PercolateShardResponse percolate(PercolateShardRequest request) throws IOException {\n        IndexService percolateIndexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n        IndexShard indexShard = percolateIndexService.getShard(request.shardId().id());\n        indexShard.readAllowed(); // check if we can read the shard...\n        PercolatorQueriesRegistry percolateQueryRegistry = indexShard.percolateRegistry();\n        percolateQueryRegistry.prePercolate();\n        long startTime = System.nanoTime();\n\n        // TODO: The filteringAliases should be looked up at the coordinating node and serialized with all shard request,\n        // just like is done in other apis.\n        String[] filteringAliases = indexNameExpressionResolver.filteringAliases(\n                clusterService.state(),\n                indexShard.shardId().index().name(),\n                request.indices()\n        );\n        Query aliasFilter = percolateIndexService.aliasFilter(indexShard.getQueryShardContext(), filteringAliases);\n\n        SearchShardTarget searchShardTarget = new SearchShardTarget(clusterService.localNode().id(), request.shardId().getIndex(), request.shardId().id());\n        final PercolateContext context = new PercolateContext(\n                request, searchShardTarget, indexShard, percolateIndexService, pageCacheRecycler, bigArrays, scriptService, aliasFilter, parseFieldMatcher\n        );\n        SearchContext.setCurrent(context);\n        try {\n            ParsedDocument parsedDocument = percolateDocumentParser.parse(request, context, percolateIndexService.mapperService(), percolateIndexService.getQueryShardContext());\n\n            if (context.searcher().getIndexReader().maxDoc() == 0) {\n                return new PercolateShardResponse(Lucene.EMPTY_TOP_DOCS, Collections.emptyMap(), Collections.emptyMap(), context);\n            }\n            if (context.size() < 0) {\n                context.size(0);\n            }\n\n            // parse the source either into one MemoryIndex, if it is a single document or index multiple docs if nested\n            PercolatorIndex percolatorIndex;\n            DocumentMapper documentMapper = indexShard.mapperService().documentMapper(request.documentType());\n            boolean isNested = documentMapper != null && documentMapper.hasNestedObjects();\n            if (parsedDocument.docs().size() > 1) {\n                assert isNested;\n                percolatorIndex = multi;\n            } else {\n                percolatorIndex = single;\n            }\n            percolatorIndex.prepare(context, parsedDocument);\n\n            BucketCollector aggregatorCollector = null;\n            if (context.aggregations() != null) {\n                AggregationContext aggregationContext = new AggregationContext(context);\n                context.aggregations().aggregationContext(aggregationContext);\n\n                Aggregator[] aggregators = context.aggregations().factories().createTopLevelAggregators(aggregationContext);\n                List<Aggregator> aggregatorCollectors = new ArrayList<>(aggregators.length);\n                for (int i = 0; i < aggregators.length; i++) {\n                    if (!(aggregators[i] instanceof GlobalAggregator)) {\n                        Aggregator aggregator = aggregators[i];\n                        aggregatorCollectors.add(aggregator);\n                    }\n                }\n                context.aggregations().aggregators(aggregators);\n                aggregatorCollector = BucketCollector.wrap(aggregatorCollectors);\n                aggregatorCollector.preCollection();\n            }\n            PercolatorQueriesRegistry queriesRegistry = indexShard.percolateRegistry();\n            return doPercolate(context, queriesRegistry, aggregationPhase, aggregatorCollector, highlightPhase);\n        } finally {\n            SearchContext.removeCurrent();\n            context.close();\n            percolateQueryRegistry.postPercolate(System.nanoTime() - startTime);\n        }\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void prepare(PercolateContext context, ParsedDocument parsedDocument) {\n        MemoryIndex memoryIndex = cache.get();\n        for (IndexableField field : parsedDocument.rootDoc().getFields()) {\n            if (field.fieldType().indexOptions() == IndexOptions.NONE && field.name().equals(UidFieldMapper.NAME)) {\n                continue;\n            }\n            try {\n                Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();\n                // TODO: instead of passing null here, we can have a CTL<Map<String,TokenStream>> and pass previous,\n                // like the indexer does\n                try (TokenStream tokenStream = field.tokenStream(analyzer, null)) {\n                    if (tokenStream != null) {\n                        memoryIndex.addField(field.name(), tokenStream, field.boost());\n                    }\n                 }\n            } catch (Exception e) {\n                throw new ElasticsearchException(\"Failed to create token stream for [\" + field.name() + \"]\", e);\n            }\n        }\n        context.initialize(new DocEngineSearcher(memoryIndex), parsedDocument);\n    }","id":80241,"modified_method":"@Override\n    public void prepare(PercolateContext context, ParsedDocument parsedDocument) {\n        MemoryIndex memoryIndex = cache.get();\n        for (IndexableField field : parsedDocument.rootDoc().getFields()) {\n            Analyzer analyzer = context.analysisService().defaultIndexAnalyzer();\n            DocumentMapper documentMapper = context.mapperService().documentMapper(parsedDocument.type());\n            if (documentMapper != null && documentMapper.mappers().getMapper(field.name()) != null) {\n                analyzer =  documentMapper.mappers().indexAnalyzer();\n            }\n            if (field.fieldType().indexOptions() == IndexOptions.NONE && field.name().equals(UidFieldMapper.NAME)) {\n                continue;\n            }\n            try {\n                // TODO: instead of passing null here, we can have a CTL<Map<String,TokenStream>> and pass previous,\n                // like the indexer does\n                try (TokenStream tokenStream = field.tokenStream(analyzer, null)) {\n                    if (tokenStream != null) {\n                        memoryIndex.addField(field.name(), tokenStream, field.boost());\n                    }\n                 }\n            } catch (Exception e) {\n                throw new ElasticsearchException(\"Failed to create token stream for [\" + field.name() + \"]\", e);\n            }\n        }\n        context.initialize(new DocEngineSearcher(memoryIndex), parsedDocument);\n    }","commit_id":"8b02f214c43673d917e835fdbf127cb94b06a28b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected RelatedPages buildRelatedPages() throws Exception {\n\t\tWikiPage parentPage = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\tRandomTestUtil.randomString(), true);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\tWikiPage page = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), \"InitialPageName\",\n\t\t\tRandomTestUtil.randomString(), parentPage.getTitle(), true,\n\t\t\tserviceContext);\n\n\t\tWikiPage childPage = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(),\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\tpage.getTitle(), true, serviceContext);\n\n\t\tWikiPage grandChildPage = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(),\n\t\t\tRandomTestUtil.randomString(), RandomTestUtil.randomString(),\n\t\t\tchildPage.getTitle(), true, serviceContext);\n\n\t\tWikiPageLocalServiceUtil.renamePage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), \"InitialPageName\",\n\t\t\t\"RenamedPage\", serviceContext);\n\n\t\tpage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_node.getNodeId(), \"RenamedPage\");\n\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t_node.getNodeId(), \"InitialPageName\");\n\n\t\treturn new RelatedPages(\n\t\t\tparentPage, page, childPage, grandChildPage, redirectorPage);\n\t}","id":80242,"modified_method":"protected RelatedPages buildRelatedPages() throws Exception {\n\n\n\t\t/*\n\t\t*\n\t\t* hierarchy:\n\t\t*\n\t\t* \tparentPage\n\t\t* \t\t|\n\t\t* \t  page - redirectorPage\n\t\t* \t\t|\n\t\t* \t  child - redirectorChild\n\t\t* \t\t|\n\t\t* \tgrandchild*\n\t\t* */\n\n\t\t// Create parent page\n\t\tWikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\t_PARENT_PAGE, true);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\t// Create further redirector page (will be renamed)\n\n\t\tWikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), _REDIRECTOR_PAGE,\n\t\t\tRandomTestUtil.randomString(), _PARENT_PAGE, true, serviceContext);\n\n\t\t// Rename redirector page (and create page)\n\n\t\tWikiPageLocalServiceUtil.renamePage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), _REDIRECTOR_PAGE,\n\t\t\t_PAGE, serviceContext);\n\n\t\t// Create a redirector child page (will be renamed)\n\n\t\tWikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(),\n\t\t\t_CHILD_REDIRECTOR_PAGE, RandomTestUtil.randomString(), _PAGE, true,\n\t\t\tserviceContext);\n\n\t\t// Rename redirector child page (and create child page)\n\n\t\tWikiPageLocalServiceUtil.renamePage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(),\n\t\t\t_CHILD_REDIRECTOR_PAGE, _CHILD_PAGE, serviceContext);\n\n\t\t// Create a grand child page\n\n\t\tWikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), _GRANDCHILD_PAGE,\n\t\t\tRandomTestUtil.randomString(), _CHILD_PAGE, true, serviceContext);\n\n\t\treturn new RelatedPages(\n\t\t\tWikiPageLocalServiceUtil.getPage(_node.getNodeId(), _PARENT_PAGE),\n\t\t\tWikiPageLocalServiceUtil.getPage(_node.getNodeId(), _PAGE),\n\t\t\tWikiPageLocalServiceUtil.getPage(_node.getNodeId(), _CHILD_PAGE),\n\t\t\tWikiPageLocalServiceUtil.getPage(\n\t\t\t\t_node.getNodeId(), _GRANDCHILD_PAGE),\n\t\t\tWikiPageLocalServiceUtil.getPage(\n\t\t\t\t_node.getNodeId(), _REDIRECTOR_PAGE),\n\t\t\tWikiPageLocalServiceUtil.getPage(\n\t\t\t\t_node.getNodeId(), _CHILD_REDIRECTOR_PAGE));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public RelatedPages(\n\t\t\tWikiPage parentPage, WikiPage page, WikiPage childPage,\n\t\t\tWikiPage grandchildPage, WikiPage redirectorPage) {\n\n\t\t\t_parentPage = parentPage;\n\t\t\t_page = page;\n\t\t\t_grandchildPage = grandchildPage;\n\t\t\t_childPage = childPage;\n\t\t\t_redirectorPage = redirectorPage;\n\t\t}","id":80243,"modified_method":"public RelatedPages(\n\t\t\tWikiPage parentPage, WikiPage page, WikiPage childPage,\n\t\t\tWikiPage grandchildPage, WikiPage redirectorPage,\n\t\t\tWikiPage childRedirectPage) {\n\n\t\t\t_parentPage = parentPage;\n\t\t\t_page = page;\n\t\t\t_grandchildPage = grandchildPage;\n\t\t\t_childPage = childPage;\n\t\t\t_redirectorPage = redirectorPage;\n\t\t\t_childRedirectorPage = childRedirectPage;\n\t\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testTrashVersionCreationWhenMovingToTrash() throws Exception {\n\t\tint initialTrashVersionsCount =\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount();\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashVersionsCount + 4,\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount());\n\t}","id":80244,"modified_method":"@Test\n\tpublic void testTrashVersionCreationWhenMovingToTrash() throws Exception {\n\t\tint initialTrashVersionsCount =\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount();\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashVersionsCount + 5,\n\t\t\tTrashVersionLocalServiceUtil.getTrashVersionsCount());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreRedirectorPageWithParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertFalse(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 5,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","id":80245,"modified_method":"@Test\n\tpublic void testRestoreRedirectPageWithParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(_GRANDCHILD_PAGE, grandchildPage.getTitle());\n\t\tAssert.assertFalse(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 6,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWitExplicitlyTrashedChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","id":80246,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWitExplicitlyTrashedChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageWithRedirectorPageToTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80247,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageWithRedirectorPageToTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestMoveParentPageWithRedirectorAndChildPageAndGrandchildPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 4,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","id":80248,"modified_method":"@Test\n\tpublic void\n\t\t\ttestMoveParentPageWithRedirectorAndChildPageAndGrandchildPageToTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 5,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithChildPageAndgrandchildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 5,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","id":80249,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithChildPageAndgrandchildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(_GRANDCHILD_PAGE, grandchildPage.getTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 6,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tredirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80250,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageWithRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tredirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(_REDIRECTOR_PAGE, redirectorPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMoveInitialParentPageToTrash() throws Exception {\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tWikiPage parentPage = relatedPages.getParentPage();\n\t\tWikiPage page = relatedPages.getPage();\n\n\t\tWikiPage newParentPage = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\tRandomTestUtil.randomString(), true);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\tWikiPageLocalServiceUtil.changeParent(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), page.getTitle(),\n\t\t\tnewParentPage.getTitle(), serviceContext);\n\n\t\tmovePageToTrash(parentPage);\n\n\t\tnewParentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tnewParentPage.getResourcePrimKey());\n\t\tpage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tparentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tparentPage.getResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(newParentPage.isInTrash());\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getParentTitle(), newParentPage.getTitle());\n\t\tAssert.assertEquals(newParentPage.getTitle(), page.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 4,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":80251,"modified_method":"@Test\n\tpublic void testMoveInitialParentPageToTrash() throws Exception {\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tWikiPage parentPage = relatedPages.getParentPage();\n\t\tWikiPage page = relatedPages.getPage();\n\n\t\tWikiPage newParentPage = WikiTestUtil.addPage(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(), _node.getNodeId(),\n\t\t\tRandomTestUtil.randomString(), true);\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(_group.getGroupId());\n\n\t\tWikiPageLocalServiceUtil.changeParent(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), page.getTitle(),\n\t\t\tnewParentPage.getTitle(), serviceContext);\n\n\t\tmovePageToTrash(parentPage);\n\n\t\tnewParentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tnewParentPage.getResourcePrimKey());\n\t\tpage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tparentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tparentPage.getResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(newParentPage.isInTrash());\n\t\tAssert.assertTrue(parentPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getParentTitle(), newParentPage.getTitle());\n\t\tAssert.assertEquals(newParentPage.getTitle(), page.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 5,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","id":80252,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreParentPageWithExplicitlyTrashedRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80253,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreParentPageWithExplicitlyTrashedRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertTrue(childPage.isInTrashExplicitly());\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(_REDIRECTOR_PAGE, redirectorPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndRedirectorFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80254,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndRedirectorFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(_REDIRECTOR_PAGE, redirectorPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageAndChildPageAndRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80255,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedParentPageAndChildPageAndRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(_REDIRECTOR_PAGE, redirectorPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedRedirectorPageWithRestoredPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80256,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedRedirectorPageWithRestoredPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getRedirectorPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(redirectorPage.isInTrash());\n\t\tAssert.assertEquals(_REDIRECTOR_PAGE, redirectorPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestorePageToADifferentNode() throws Exception {\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tWikiPageTrashHandlerTestUtil.moveParentBaseModelToTrash(\n\t\t\t_node.getNodeId());\n\n\t\tWikiNode newNode = WikiTestUtil.addNode(_group.getGroupId());\n\n\t\tmoveTrashEntry(\n\t\t\trelatedPages.getChildPageResourcePrimKey(), newNode.getNodeId());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), page.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPage.getNodeId());\n\t\tAssert.assertEquals(_node.getNodeId(), redirectorPage.getNodeId());\n\t\tAssert.assertNull(childPage.getParentPage());\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tpage.getResourcePrimKey());\n\t\tWikiPageResource childPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tchildPage.getResourcePrimKey());\n\t\tWikiPageResource RedirectorPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tredirectorPage.getResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), pageResource.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPageResource.getNodeId());\n\t\tAssert.assertEquals(\n\t\t\t_node.getNodeId(), RedirectorPageResource.getNodeId());\n\t}","id":80257,"modified_method":"@Test\n\tpublic void testRestorePageToADifferentNode() throws Exception {\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tWikiPageTrashHandlerTestUtil.moveParentBaseModelToTrash(\n\t\t\t_node.getNodeId());\n\n\t\tWikiNode newNode = WikiTestUtil.addNode(_group.getGroupId());\n\n\t\tmoveTrashEntry(\n\t\t\trelatedPages.getChildPageResourcePrimKey(), newNode.getNodeId());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), page.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPage.getNodeId());\n\t\tAssert.assertEquals(_node.getNodeId(), redirectorPage.getNodeId());\n\t\tAssert.assertNull(childPage.getParentPage());\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tpage.getResourcePrimKey());\n\t\tWikiPageResource childPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tchildPage.getResourcePrimKey());\n\t\tWikiPageResource redirectorPageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getWikiPageResource(\n\t\t\t\tredirectorPage.getResourcePrimKey());\n\n\t\tAssert.assertEquals(_node.getNodeId(), pageResource.getNodeId());\n\t\tAssert.assertEquals(newNode.getNodeId(), childPageResource.getNodeId());\n\t\tAssert.assertEquals(\n\t\t\t_node.getNodeId(), redirectorPageResource.getNodeId());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedChildPageWithChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 5,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","id":80258,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedChildPageWithChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(_GRANDCHILD_PAGE, grandchildPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 6,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageAndParentPageWithRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","id":80259,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageAndParentPageWithRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageWithTrashedParentFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(StringPool.BLANK, childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 3,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","id":80260,"modified_method":"@Test\n\tpublic void\n\t\t\ttestRestoreExplicitlyTrashedChildPageWithTrashedParentFromTrash()\n\t\tthrows Exception {\n\n\t\tint initialBaseModelsCount =\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node);\n\t\tint initialTrashEntriesCount =\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId());\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\t\tWikiPage grandchildPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getGrandchildPageResourcePrimKey());\n\n\t\tAssert.assertTrue(page.isInTrashExplicitly());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertFalse(grandchildPage.isInTrash());\n\t\tAssert.assertEquals(StringPool.BLANK, childPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tchildPage.getTitle(), grandchildPage.getParentTitle());\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 4,\n\t\t\tWikiPageTrashHandlerTestUtil.getNotInTrashBaseModelsCount(_node));\n\t\tAssert.assertEquals(\n\t\t\tinitialTrashEntriesCount + 1,\n\t\t\tTrashEntryLocalServiceUtil.getEntriesCount(_group.getGroupId()));\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","id":80261,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedParentPageAndChildPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getChildPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\t\trestoreFromTrash(relatedPages.getChildPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage childPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getChildPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertFalse(childPage.isInTrash());\n\t\tAssert.assertEquals(_CHILD_PAGE, childPage.getTitle());\n\t\tAssert.assertEquals(page.getTitle(), childPage.getParentTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedPageWithRedirectorPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","id":80262,"modified_method":"@Test\n\tpublic void testRestoreExplicitlyTrashedPageWithRedirectPageFromTrash()\n\t\tthrows Exception {\n\n\t\tRelatedPages relatedPages = buildRelatedPages();\n\n\t\tmovePageToTrash(relatedPages.getRedirectorPage());\n\t\tmovePageToTrash(relatedPages.getPage());\n\n\t\trestoreFromTrash(relatedPages.getPage());\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getPageResourcePrimKey());\n\t\tWikiPage redirectorPage = WikiPageLocalServiceUtil.getPage(\n\t\t\trelatedPages.getRedirectorPageResourcePrimKey());\n\n\t\tAssert.assertFalse(page.isInTrash());\n\t\tAssert.assertEquals(_PAGE, page.getTitle());\n\t\tAssert.assertTrue(redirectorPage.isInTrashExplicitly());\n\t\tAssert.assertEquals(page.getTitle(), redirectorPage.getRedirectTitle());\n\t}","commit_id":"6afdf64894eeb8ec0fade21a9fc62bba72fc495a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportPortlet(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tLayout layout, Element parentElement, boolean exportPermissions,\n\t\t\tboolean exportPortletArchivedSetups, boolean exportPortletData,\n\t\t\tboolean exportPortletSetup, boolean exportPortletUserPreferences)\n\t\tthrows Exception {\n\n\t\tlong plid = PortletKeys.PREFS_OWNER_ID_DEFAULT;\n\t\tlong layoutId = LayoutConstants.DEFAULT_PARENT_LAYOUT_ID;\n\n\t\tif (layout != null) {\n\t\t\tplid = layout.getPlid();\n\t\t\tlayoutId = layout.getLayoutId();\n\t\t}\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tportletDataContext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not export portlet \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!portlet.isInstanceable() &&\n\t\t\t!portlet.isPreferencesUniquePerLayout() &&\n\t\t\tportletDataContext.hasNotUniquePerLayout(portletId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (BackgroundTaskThreadLocal.hasBackgroundTask()) {\n\t\t\tPortletDataContext clonedPortletDataContext =\n\t\t\t\tPortletDataContextFactoryUtil.clonePortletDataContext(\n\t\t\t\t\tportletDataContext);\n\n\t\t\tManifestSummary manifestSummary =\n\t\t\t\tclonedPortletDataContext.getManifestSummary();\n\n\t\t\tmanifestSummary.resetCounters();\n\n\t\t\tPortletDataHandler portletDataHandler =\n\t\t\t\tportlet.getPortletDataHandlerInstance();\n\n\t\t\tportletDataHandler.prepareManifestSummary(clonedPortletDataContext);\n\n\t\t\tPortletDataHandlerStatusMessageSenderUtil.sendStatusMessage(\n\t\t\t\t\"portlet\", portletId, manifestSummary);\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement portletElement = document.addElement(\"portlet\");\n\n\t\tportletElement.addAttribute(\"portlet-id\", portletId);\n\t\tportletElement.addAttribute(\n\t\t\t\"root-portlet-id\", PortletConstants.getRootPortletId(portletId));\n\t\tportletElement.addAttribute(\"old-plid\", String.valueOf(plid));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-group-id\",\n\t\t\tString.valueOf(portletDataContext.getScopeGroupId()));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-type\", portletDataContext.getScopeType());\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-uuid\", portletDataContext.getScopeLayoutUuid());\n\t\tportletElement.addAttribute(\n\t\t\t\"private-layout\", String.valueOf(layout.isPrivateLayout()));\n\n\t\t// Data\n\n\t\tif (exportPortletData) {\n\t\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getStrictPortletSetup(\n\t\t\t\t\tlayout, portletId);\n\n\t\t\tif (!portlet.isPreferencesUniquePerLayout()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(portletId);\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeType());\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeLayoutUuid());\n\n\t\t\t\tString dataKey = sb.toString();\n\n\t\t\t\tif (!portletDataContext.hasNotUniquePerLayout(dataKey)) {\n\t\t\t\t\tportletDataContext.putNotUniquePerLayout(dataKey);\n\n\t\t\t\t\texportPortletData(\n\t\t\t\t\t\tportletDataContext, portlet, layout,\n\t\t\t\t\t\tjxPortletPreferences, portletElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texportPortletData(\n\t\t\t\t\tportletDataContext, portlet, layout, jxPortletPreferences,\n\t\t\t\t\tportletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Portlet preferences\n\n\t\tif (exportPortletSetup) {\n\n\t\t\t// Company\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getCompanyId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_COMPANY, false, layout, plid,\n\t\t\t\tportlet.getRootPortletId(), portletElement);\n\n\t\t\t// Group\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false, layout,\n\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portlet.getRootPortletId(),\n\t\t\t\tportletElement);\n\n\t\t\t// Layout\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, PortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, false, layout, plid,\n\t\t\t\tportletId, portletElement);\n\t\t}\n\n\t\t// Portlet user preferences\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tList<PortletPreferences> portletPreferencesList =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, plid, portletId);\n\n\t\t\tfor (PortletPreferences portletPreferences :\n\t\t\t\t\tportletPreferencesList) {\n\n\t\t\t\tboolean defaultUser = false;\n\n\t\t\t\tif (portletPreferences.getOwnerId() ==\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT) {\n\n\t\t\t\t\tdefaultUser = true;\n\t\t\t\t}\n\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletPreferences.getOwnerId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, defaultUser, layout,\n\t\t\t\t\tplid, portletId, portletElement);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletPreferences groupPortletPreferences =\n\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP,\n\t\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED,\n\t\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\texportPortletPreference(\n\t\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false,\n\t\t\t\t\tgroupPortletPreferences, portlet.getRootPortletId(),\n\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portletElement);\n\t\t\t}\n\t\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t\t}\n\t\t}\n\n\t\t// Archived setups\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\t\tList<PortletItem> portletItems =\n\t\t\t\tPortletItemLocalServiceUtil.getPortletItems(\n\t\t\t\t\tportletDataContext.getGroupId(), rootPortletId,\n\t\t\t\t\tPortletPreferences.class.getName());\n\n\t\t\tfor (PortletItem portletItem : portletItems) {\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletItem.getPortletItemId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_ARCHIVED, false, null, plid,\n\t\t\t\t\tportletItem.getPortletId(), portletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Permissions\n\n\t\tif (exportPermissions) {\n\t\t\t_permissionExporter.exportPortletPermissions(\n\t\t\t\tportletDataContext, portletId, layout, portletElement);\n\t\t}\n\n\t\t// Zip\n\n\t\tStringBundler pathSB = new StringBundler(4);\n\n\t\tpathSB.append(\n\t\t\tExportImportPathUtil.getPortletPath(portletDataContext, portletId));\n\t\tpathSB.append(StringPool.SLASH);\n\t\tpathSB.append(plid);\n\t\tpathSB.append(\"/portlet.xml\");\n\n\t\tString path = pathSB.toString();\n\n\t\tElement element = parentElement.addElement(\"portlet\");\n\n\t\telement.addAttribute(\"portlet-id\", portletId);\n\t\telement.addAttribute(\"layout-id\", String.valueOf(layoutId));\n\t\telement.addAttribute(\"path\", path);\n\t\telement.addAttribute(\"portlet-data\", String.valueOf(exportPortletData));\n\n\t\tStringBundler configurationOptionsSB = new StringBundler(6);\n\n\t\tif (exportPortletSetup) {\n\t\t\tconfigurationOptionsSB.append(\"setup\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tconfigurationOptionsSB.append(\"archived-setups\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tconfigurationOptionsSB.append(\"user-preferences\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (configurationOptionsSB.index() > 0) {\n\t\t\tconfigurationOptionsSB.setIndex(configurationOptionsSB.index() -1);\n\t\t}\n\n\t\telement.addAttribute(\n\t\t\t\"portlet-configuration\", configurationOptionsSB.toString());\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\ttry {\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tpath, document.formattedString());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ioe.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addPrimaryKey(String.class, path);\n\t\t}\n\t}","id":80263,"modified_method":"protected void exportPortlet(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tLayout layout, Element parentElement, boolean exportPermissions,\n\t\t\tboolean exportPortletArchivedSetups, boolean exportPortletData,\n\t\t\tboolean exportPortletSetup, boolean exportPortletUserPreferences)\n\t\tthrows Exception {\n\n\t\tlong plid = PortletKeys.PREFS_OWNER_ID_DEFAULT;\n\t\tlong layoutId = LayoutConstants.DEFAULT_PARENT_LAYOUT_ID;\n\n\t\tif (layout != null) {\n\t\t\tplid = layout.getPlid();\n\t\t\tlayoutId = layout.getLayoutId();\n\t\t}\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tportletDataContext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not export portlet \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!portlet.isInstanceable() &&\n\t\t\t!portlet.isPreferencesUniquePerLayout() &&\n\t\t\tportletDataContext.hasNotUniquePerLayout(portletId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (BackgroundTaskThreadLocal.hasBackgroundTask()) {\n\t\t\tPortletDataContext clonedPortletDataContext =\n\t\t\t\tPortletDataContextFactoryUtil.clonePortletDataContext(\n\t\t\t\t\tportletDataContext);\n\n\t\t\tManifestSummary manifestSummary =\n\t\t\t\tclonedPortletDataContext.getManifestSummary();\n\n\t\t\tmanifestSummary.resetCounters();\n\n\t\t\tPortletDataHandler portletDataHandler =\n\t\t\t\tportlet.getPortletDataHandlerInstance();\n\n\t\t\tportletDataHandler.prepareManifestSummary(clonedPortletDataContext);\n\n\t\t\tPortletDataHandlerStatusMessageSenderUtil.sendStatusMessage(\n\t\t\t\t\"portlet\", portletId, manifestSummary);\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement portletElement = document.addElement(\"portlet\");\n\n\t\tportletElement.addAttribute(\"portlet-id\", portletId);\n\t\tportletElement.addAttribute(\n\t\t\t\"root-portlet-id\", PortletConstants.getRootPortletId(portletId));\n\t\tportletElement.addAttribute(\"old-plid\", String.valueOf(plid));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-group-id\",\n\t\t\tString.valueOf(portletDataContext.getScopeGroupId()));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-type\", portletDataContext.getScopeType());\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-uuid\", portletDataContext.getScopeLayoutUuid());\n\t\tportletElement.addAttribute(\n\t\t\t\"private-layout\", String.valueOf(layout.isPrivateLayout()));\n\n\t\t// Data\n\n\t\tif (exportPortletData) {\n\t\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getStrictPortletSetup(\n\t\t\t\t\tlayout, portletId);\n\n\t\t\tif (!portlet.isPreferencesUniquePerLayout()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(portletId);\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeType());\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeLayoutUuid());\n\n\t\t\t\tString dataKey = sb.toString();\n\n\t\t\t\tif (!portletDataContext.hasNotUniquePerLayout(dataKey)) {\n\t\t\t\t\tportletDataContext.putNotUniquePerLayout(dataKey);\n\n\t\t\t\t\texportPortletData(\n\t\t\t\t\t\tportletDataContext, portlet, layout,\n\t\t\t\t\t\tjxPortletPreferences, portletElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texportPortletData(\n\t\t\t\t\tportletDataContext, portlet, layout, jxPortletPreferences,\n\t\t\t\t\tportletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Portlet preferences\n\n\t\tif (exportPortletSetup) {\n\n\t\t\t// Company\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getCompanyId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_COMPANY, false, layout, plid,\n\t\t\t\tportlet.getRootPortletId(), portletElement);\n\n\t\t\t// Group\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false, layout,\n\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portlet.getRootPortletId(),\n\t\t\t\tportletElement);\n\n\t\t\t// Layout\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, PortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, false, layout, plid,\n\t\t\t\tportletId, portletElement);\n\t\t}\n\n\t\t// Portlet user preferences\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tList<PortletPreferences> portletPreferencesList =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, plid, portletId);\n\n\t\t\tfor (PortletPreferences portletPreferences :\n\t\t\t\t\tportletPreferencesList) {\n\n\t\t\t\tboolean defaultUser = false;\n\n\t\t\t\tif (portletPreferences.getOwnerId() ==\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT) {\n\n\t\t\t\t\tdefaultUser = true;\n\t\t\t\t}\n\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletPreferences.getOwnerId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, defaultUser, layout,\n\t\t\t\t\tplid, portletId, portletElement);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletPreferences groupPortletPreferences =\n\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP,\n\t\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED,\n\t\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\texportPortletPreference(\n\t\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false,\n\t\t\t\t\tgroupPortletPreferences, portlet.getRootPortletId(),\n\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portletElement);\n\t\t\t}\n\t\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t\t}\n\t\t}\n\n\t\t// Archived setups\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\t\tList<PortletItem> portletItems =\n\t\t\t\tPortletItemLocalServiceUtil.getPortletItems(\n\t\t\t\t\tportletDataContext.getGroupId(), rootPortletId,\n\t\t\t\t\tPortletPreferences.class.getName());\n\n\t\t\tfor (PortletItem portletItem : portletItems) {\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletItem.getPortletItemId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_ARCHIVED, false, null, plid,\n\t\t\t\t\tportletItem.getPortletId(), portletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Permissions\n\n\t\tif (exportPermissions) {\n\t\t\t_permissionExporter.exportPortletPermissions(\n\t\t\t\tportletDataContext, portletId, layout, portletElement);\n\t\t}\n\n\t\t// Zip\n\n\t\tStringBundler pathSB = new StringBundler(4);\n\n\t\tpathSB.append(\n\t\t\tExportImportPathUtil.getPortletPath(portletDataContext, portletId));\n\t\tpathSB.append(StringPool.SLASH);\n\t\tpathSB.append(plid);\n\t\tpathSB.append(\"/portlet.xml\");\n\n\t\tString path = pathSB.toString();\n\n\t\tElement element = parentElement.addElement(\"portlet\");\n\n\t\telement.addAttribute(\"portlet-id\", portletId);\n\t\telement.addAttribute(\"layout-id\", String.valueOf(layoutId));\n\t\telement.addAttribute(\"path\", path);\n\t\telement.addAttribute(\"portlet-data\", String.valueOf(exportPortletData));\n\n\t\tStringBundler configurationOptionsSB = new StringBundler(6);\n\n\t\tif (exportPortletSetup) {\n\t\t\tconfigurationOptionsSB.append(\"setup\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tconfigurationOptionsSB.append(\"archived-setups\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tconfigurationOptionsSB.append(\"user-preferences\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (configurationOptionsSB.index() > 0) {\n\t\t\tconfigurationOptionsSB.setIndex(configurationOptionsSB.index() -1);\n\t\t}\n\n\t\telement.addAttribute(\n\t\t\t\"portlet-configuration\", configurationOptionsSB.toString());\n\n\t\ttry {\n\t\t\tportletDataContext.addZipEntry(path, document.formattedString());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(ioe.getMessage());\n\t\t\t}\n\t\t}\n\t}","commit_id":"a667ebd543506c9368aca84c56c1b0a92625578d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportLocks(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"locks\");\n\n\t\tMap<String, Lock> locksMap = portletDataContext.getLocks();\n\n\t\tfor (Map.Entry<String, Lock> entry : locksMap.entrySet()) {\n\t\t\tLock lock = entry.getValue();\n\n\t\t\tString entryKey = entry.getKey();\n\n\t\t\tint pos = entryKey.indexOf(CharPool.POUND);\n\n\t\t\tString className = entryKey.substring(0, pos);\n\t\t\tString key = entryKey.substring(pos + 1);\n\n\t\t\tString path = getLockPath(portletDataContext, className, key, lock);\n\n\t\t\tElement assetElement = rootElement.addElement(\"asset\");\n\n\t\t\tassetElement.addAttribute(\"path\", path);\n\t\t\tassetElement.addAttribute(\"class-name\", className);\n\t\t\tassetElement.addAttribute(\"key\", key);\n\n\t\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tportletDataContext.addZipEntry(path, lock);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addZipEntry(\n\t\t\tExportImportPathUtil.getRootPath(portletDataContext) + \"/locks.xml\",\n\t\t\tdocument.formattedString());\n\t}","id":80264,"modified_method":"protected void exportLocks(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"locks\");\n\n\t\tMap<String, Lock> locksMap = portletDataContext.getLocks();\n\n\t\tfor (Map.Entry<String, Lock> entry : locksMap.entrySet()) {\n\t\t\tLock lock = entry.getValue();\n\n\t\t\tString entryKey = entry.getKey();\n\n\t\t\tint pos = entryKey.indexOf(CharPool.POUND);\n\n\t\t\tString className = entryKey.substring(0, pos);\n\t\t\tString key = entryKey.substring(pos + 1);\n\n\t\t\tString path = getLockPath(portletDataContext, className, key, lock);\n\n\t\t\tElement assetElement = rootElement.addElement(\"asset\");\n\n\t\t\tassetElement.addAttribute(\"path\", path);\n\t\t\tassetElement.addAttribute(\"class-name\", className);\n\t\t\tassetElement.addAttribute(\"key\", key);\n\n\t\t\tportletDataContext.addZipEntry(path, lock);\n\t\t}\n\n\t\tportletDataContext.addZipEntry(\n\t\t\tExportImportPathUtil.getRootPath(portletDataContext) + \"/locks.xml\",\n\t\t\tdocument.formattedString());\n\t}","commit_id":"a667ebd543506c9368aca84c56c1b0a92625578d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportPortletPreference(\n\t\t\tPortletDataContext portletDataContext, long ownerId, int ownerType,\n\t\t\tboolean defaultUser, PortletPreferences portletPreferences,\n\t\t\tString portletId, long plid, Element parentElement)\n\t\tthrows Exception {\n\n\t\tString preferencesXML = portletPreferences.getPreferences();\n\n\t\tif (Validator.isNull(preferencesXML)) {\n\t\t\tpreferencesXML = PortletConstants.DEFAULT_PREFERENCES;\n\t\t}\n\n\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.fromDefaultXML(preferencesXML);\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tportletDataContext.getCompanyId(), portletId);\n\n\t\tElement portletPreferencesElement = parentElement.addElement(\n\t\t\t\"portlet-preferences\");\n\n\t\tif ((portlet != null) &&\n\t\t\t(portlet.getPortletDataHandlerInstance() != null)) {\n\n\t\t\tElement exportDataRootElement =\n\t\t\t\tportletDataContext.getExportDataRootElement();\n\n\t\t\ttry {\n\t\t\t\tportletDataContext.clearScopedPrimaryKeys();\n\n\t\t\t\tElement preferenceDataElement =\n\t\t\t\t\tportletPreferencesElement.addElement(\"preference-data\");\n\n\t\t\t\tportletDataContext.setExportDataRootElement(\n\t\t\t\t\tpreferenceDataElement);\n\n\t\t\t\tPortletDataHandler portletDataHandler =\n\t\t\t\t\tportlet.getPortletDataHandlerInstance();\n\n\t\t\t\tjxPortletPreferences =\n\t\t\t\t\tportletDataHandler.processExportPortletPreferences(\n\t\t\t\t\t\tportletDataContext, portletId, jxPortletPreferences);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tportletDataContext.setExportDataRootElement(\n\t\t\t\t\texportDataRootElement);\n\t\t\t}\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(\n\t\t\tPortletPreferencesFactoryUtil.toXML(jxPortletPreferences));\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\trootElement.addAttribute(\"owner-id\", String.valueOf(ownerId));\n\t\trootElement.addAttribute(\"owner-type\", String.valueOf(ownerType));\n\t\trootElement.addAttribute(\"default-user\", String.valueOf(defaultUser));\n\t\trootElement.addAttribute(\"plid\", String.valueOf(plid));\n\t\trootElement.addAttribute(\"portlet-id\", portletId);\n\n\t\tif (ownerType == PortletKeys.PREFS_OWNER_TYPE_ARCHIVED) {\n\t\t\tPortletItem portletItem =\n\t\t\t\tPortletItemLocalServiceUtil.getPortletItem(ownerId);\n\n\t\t\trootElement.addAttribute(\n\t\t\t\t\"archive-user-uuid\", portletItem.getUserUuid());\n\t\t\trootElement.addAttribute(\"archive-name\", portletItem.getName());\n\t\t}\n\t\telse if (ownerType == PortletKeys.PREFS_OWNER_TYPE_USER) {\n\t\t\tUser user = UserLocalServiceUtil.fetchUserById(ownerId);\n\n\t\t\tif (user == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trootElement.addAttribute(\"user-uuid\", user.getUserUuid());\n\t\t}\n\n\t\tList<Node> nodes = document.selectNodes(\n\t\t\t\"/portlet-preferences/preference[name/text() = \" +\n\t\t\t\t\"'last-publish-date']\");\n\n\t\tfor (Node node : nodes) {\n\t\t\tdocument.remove(node);\n\t\t}\n\n\t\tString path = ExportImportPathUtil.getPortletPreferencesPath(\n\t\t\tportletDataContext, portletId, ownerId, ownerType, plid);\n\n\t\tportletPreferencesElement.addAttribute(\"path\", path);\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\tportletDataContext.addZipEntry(\n\t\t\t\tpath, document.formattedString(StringPool.TAB, false, false));\n\t\t}\n\t}","id":80265,"modified_method":"protected void exportPortletPreference(\n\t\t\tPortletDataContext portletDataContext, long ownerId, int ownerType,\n\t\t\tboolean defaultUser, PortletPreferences portletPreferences,\n\t\t\tString portletId, long plid, Element parentElement)\n\t\tthrows Exception {\n\n\t\tString preferencesXML = portletPreferences.getPreferences();\n\n\t\tif (Validator.isNull(preferencesXML)) {\n\t\t\tpreferencesXML = PortletConstants.DEFAULT_PREFERENCES;\n\t\t}\n\n\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.fromDefaultXML(preferencesXML);\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tportletDataContext.getCompanyId(), portletId);\n\n\t\tElement portletPreferencesElement = parentElement.addElement(\n\t\t\t\"portlet-preferences\");\n\n\t\tif ((portlet != null) &&\n\t\t\t(portlet.getPortletDataHandlerInstance() != null)) {\n\n\t\t\tElement exportDataRootElement =\n\t\t\t\tportletDataContext.getExportDataRootElement();\n\n\t\t\ttry {\n\t\t\t\tportletDataContext.clearScopedPrimaryKeys();\n\n\t\t\t\tElement preferenceDataElement =\n\t\t\t\t\tportletPreferencesElement.addElement(\"preference-data\");\n\n\t\t\t\tportletDataContext.setExportDataRootElement(\n\t\t\t\t\tpreferenceDataElement);\n\n\t\t\t\tPortletDataHandler portletDataHandler =\n\t\t\t\t\tportlet.getPortletDataHandlerInstance();\n\n\t\t\t\tjxPortletPreferences =\n\t\t\t\t\tportletDataHandler.processExportPortletPreferences(\n\t\t\t\t\t\tportletDataContext, portletId, jxPortletPreferences);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tportletDataContext.setExportDataRootElement(\n\t\t\t\t\texportDataRootElement);\n\t\t\t}\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(\n\t\t\tPortletPreferencesFactoryUtil.toXML(jxPortletPreferences));\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\trootElement.addAttribute(\"owner-id\", String.valueOf(ownerId));\n\t\trootElement.addAttribute(\"owner-type\", String.valueOf(ownerType));\n\t\trootElement.addAttribute(\"default-user\", String.valueOf(defaultUser));\n\t\trootElement.addAttribute(\"plid\", String.valueOf(plid));\n\t\trootElement.addAttribute(\"portlet-id\", portletId);\n\n\t\tif (ownerType == PortletKeys.PREFS_OWNER_TYPE_ARCHIVED) {\n\t\t\tPortletItem portletItem =\n\t\t\t\tPortletItemLocalServiceUtil.getPortletItem(ownerId);\n\n\t\t\trootElement.addAttribute(\n\t\t\t\t\"archive-user-uuid\", portletItem.getUserUuid());\n\t\t\trootElement.addAttribute(\"archive-name\", portletItem.getName());\n\t\t}\n\t\telse if (ownerType == PortletKeys.PREFS_OWNER_TYPE_USER) {\n\t\t\tUser user = UserLocalServiceUtil.fetchUserById(ownerId);\n\n\t\t\tif (user == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trootElement.addAttribute(\"user-uuid\", user.getUserUuid());\n\t\t}\n\n\t\tList<Node> nodes = document.selectNodes(\n\t\t\t\"/portlet-preferences/preference[name/text() = \" +\n\t\t\t\t\"'last-publish-date']\");\n\n\t\tfor (Node node : nodes) {\n\t\t\tdocument.remove(node);\n\t\t}\n\n\t\tString path = ExportImportPathUtil.getPortletPreferencesPath(\n\t\t\tportletDataContext, portletId, ownerId, ownerType, plid);\n\n\t\tportletPreferencesElement.addAttribute(\"path\", path);\n\n\t\tportletDataContext.addZipEntry(\n\t\t\tpath, document.formattedString(StringPool.TAB, false, false));\n\t}","commit_id":"a667ebd543506c9368aca84c56c1b0a92625578d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetCategory category)\n\t\tthrows Exception {\n\n\t\tif (category.getParentCategoryId() !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, category, AssetCategory.class,\n\t\t\t\tcategory.getParentCategoryId());\n\t\t}\n\t\telse {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, category, AssetVocabulary.class,\n\t\t\t\tcategory.getVocabularyId());\n\t\t}\n\n\t\tlong userId = portletDataContext.getUserId(assetCategory.getUserUuid());\n\t\tlong groupId = portletDataContext.getGroupId();\n\t\tlong assetVocabularyId = MapUtil.getLong(\n\t\t\tassetVocabularyPKs, assetCategory.getVocabularyId(),\n\t\t\tassetCategory.getVocabularyId());\n\t\tlong parentAssetCategoryId = MapUtil.getLong(\n\t\t\tassetCategoryPKs, assetCategory.getParentCategoryId(),\n\t\t\tassetCategory.getParentCategoryId());\n\n\t\tif ((parentAssetCategoryId !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(parentAssetCategoryId == assetCategory.getParentCategoryId())) {\n\n\t\t\tString path = getAssetCategoryPath(\n\t\t\t\tportletDataContext, parentAssetCategoryId);\n\n\t\t\tAssetCategory parentAssetCategory =\n\t\t\t\t(AssetCategory)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\tNode parentCategoryNode =\n\t\t\t\tassetCategoryElement.getParent().selectSingleNode(\n\t\t\t\t\t\"./category[@path='\" + path + \"']\");\n\n\t\t\tif (parentCategoryNode != null) {\n\t\t\t\timportAssetCategory(\n\t\t\t\t\tportletDataContext, assetVocabularyPKs, assetCategoryPKs,\n\t\t\t\t\tassetCategoryUuids, (Element)parentCategoryNode,\n\t\t\t\t\tparentAssetCategory);\n\n\t\t\t\tparentAssetCategoryId = MapUtil.getLong(\n\t\t\t\t\tassetCategoryPKs, assetCategory.getParentCategoryId(),\n\t\t\t\t\tassetCategory.getParentCategoryId());\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(assetCategory.getCreateDate());\n\t\tserviceContext.setModifiedDate(assetCategory.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(portletDataContext.getScopeGroupId());\n\n\t\tAssetCategory importedAssetCategory = null;\n\n\t\tif ((parentAssetCategoryId !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(AssetCategoryUtil.fetchByPrimaryKey(parentAssetCategoryId) ==\n\t\t\t\tnull)) {\n\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent category for category \" +\n\t\t\t\t\tassetCategory.getCategoryId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tList<Element> propertyElements = assetCategoryElement.elements(\n\t\t\t\"property\");\n\n\t\tString[] properties = new String[propertyElements.size()];\n\n\t\tfor (int i = 0; i < propertyElements.size(); i++) {\n\t\t\tElement propertyElement = propertyElements.get(i);\n\n\t\t\tString key = propertyElement.attributeValue(\"key\");\n\t\t\tString value = propertyElement.attributeValue(\"value\");\n\n\t\t\tproperties[i] = key.concat(\n\t\t\t\tAssetCategoryConstants.PROPERTY_KEY_VALUE_SEPARATOR).concat(\n\t\t\t\t\tvalue);\n\t\t}\n\n\t\tAssetCategory existingAssetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\tassetCategory.getUuid(), groupId);\n\n\t\tif (existingAssetCategory == null) {\n\t\t\texistingAssetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\t\tassetCategory.getUuid(),\n\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t}\n\n\t\tif (existingAssetCategory == null) {\n\t\t\tString name = getAssetCategoryName(\n\t\t\t\tnull, groupId, parentAssetCategoryId, assetCategory.getName(),\n\t\t\t\tassetCategory.getVocabularyId(), 2);\n\n\t\t\tserviceContext.setUuid(assetCategory.getUuid());\n\n\t\t\timportedAssetCategory =\n\t\t\t\tAssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\t\tuserId, parentAssetCategoryId,\n\t\t\t\t\tgetAssetCategoryTitleMap(groupId, assetCategory, name),\n\t\t\t\t\tassetCategory.getDescriptionMap(), assetVocabularyId,\n\t\t\t\t\tproperties, serviceContext);\n\t\t}\n\t\telse if (portletDataContext.isCompanyStagedGroupedModel(\n\t\t\t\t\texistingAssetCategory)) {\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tString name = getAssetCategoryName(\n\t\t\t\tassetCategory.getUuid(), groupId, parentAssetCategoryId,\n\t\t\t\tassetCategory.getName(), assetCategory.getVocabularyId(), 2);\n\n\t\t\timportedAssetCategory =\n\t\t\t\tAssetCategoryLocalServiceUtil.updateCategory(\n\t\t\t\t\tuserId, existingAssetCategory.getCategoryId(),\n\t\t\t\t\tparentAssetCategoryId,\n\t\t\t\t\tgetAssetCategoryTitleMap(groupId, assetCategory, name),\n\t\t\t\t\tassetCategory.getDescriptionMap(), assetVocabularyId,\n\t\t\t\t\tproperties, serviceContext);\n\t\t}\n\n\t\tassetCategoryPKs.put(\n\t\t\tassetCategory.getCategoryId(),\n\t\t\timportedAssetCategory.getCategoryId());\n\n\t\tassetCategoryUuids.put(\n\t\t\tassetCategory.getUuid(), importedAssetCategory.getUuid());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tAssetCategory.class, assetCategory.getCategoryId(),\n\t\t\timportedAssetCategory.getCategoryId());\n\t}","id":80266,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetCategory category)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(category.getUserUuid());\n\n\t\tif (category.getParentCategoryId() !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, category, AssetCategory.class,\n\t\t\t\tcategory.getParentCategoryId());\n\t\t}\n\t\telse {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, category, AssetVocabulary.class,\n\t\t\t\tcategory.getVocabularyId());\n\t\t}\n\n\t\tMap<Long, Long> vocabularyIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetVocabulary.class);\n\n\t\tlong vocabularyId = MapUtil.getLong(\n\t\t\tvocabularyIds, category.getVocabularyId(),\n\t\t\tcategory.getVocabularyId());\n\n\t\tMap<Long, Long> categoryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetCategory.class);\n\n\t\tlong parentCategoryId = MapUtil.getLong(\n\t\t\tcategoryIds, category.getParentCategoryId(),\n\t\t\tcategory.getParentCategoryId());\n\n\t\tElement categoryElement = portletDataContext.getImportDataElement(\n\t\t\tcategory);\n\n\t\tList<Element> propertyElements = categoryElement.elements(\"property\");\n\n\t\tString[] properties = new String[propertyElements.size()];\n\n\t\tfor (int i = 0; i < propertyElements.size(); i++) {\n\t\t\tElement propertyElement = propertyElements.get(i);\n\n\t\t\tString key = propertyElement.attributeValue(\"key\");\n\t\t\tString value = propertyElement.attributeValue(\"value\");\n\n\t\t\tproperties[i] = key.concat(\n\t\t\t\tAssetCategoryConstants.PROPERTY_KEY_VALUE_SEPARATOR).concat(\n\t\t\t\t\tvalue);\n\t\t}\n\n\t\tServiceContext serviceContext = createServiceContext(\n\t\t\tportletDataContext, category);\n\n\t\tAssetCategory importedCategory = null;\n\n\t\tAssetCategory existingAssetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\tcategory.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\tif (existingAssetCategory == null) {\n\t\t\texistingAssetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\t\tcategory.getUuid(), portletDataContext.getCompanyGroupId());\n\t\t}\n\n\t\tif (existingAssetCategory == null) {\n\t\t\tString name = getAssetCategoryName(\n\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentCategoryId,\n\t\t\t\tcategory.getName(), category.getVocabularyId(), 2);\n\n\t\t\tserviceContext.setUuid(category.getUuid());\n\n\t\t\timportedCategory = AssetCategoryLocalServiceUtil.addCategory(\n\t\t\t\tuserId, parentCategoryId,\n\t\t\t\tgetAssetCategoryTitleMap(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), category, name),\n\t\t\t\tcategory.getDescriptionMap(), vocabularyId, properties,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tString name = getAssetCategoryName(\n\t\t\t\tcategory.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\t\tparentCategoryId, category.getName(),\n\t\t\t\tcategory.getVocabularyId(), 2);\n\n\t\t\timportedCategory = AssetCategoryLocalServiceUtil.updateCategory(\n\t\t\t\tuserId, existingAssetCategory.getCategoryId(), parentCategoryId,\n\t\t\t\tgetAssetCategoryTitleMap(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), category, name),\n\t\t\t\tcategory.getDescriptionMap(), vocabularyId, properties,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\tcategoryIds.put(\n\t\t\tcategory.getCategoryId(), importedCategory.getCategoryId());\n\n\t\tMap<String, String> categoryUuids =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetCategory.class + \".uuid\");\n\n\t\tcategoryUuids.put(category.getUuid(), importedCategory.getUuid());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tAssetCategory.class, category.getCategoryId(),\n\t\t\timportedCategory.getCategoryId());\n\t}","commit_id":"aa486cb59cffe0a1e2e4810ffd60236f3c5a72b3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetCategory category)\n\t\tthrows Exception {\n\n\t\tif (category.getParentCategoryId() !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tAssetCategory parentCategory =\n\t\t\t\tAssetCategoryLocalServiceUtil.fetchAssetCategory(\n\t\t\t\t\tcategory.getParentCategoryId());\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, category, parentCategory,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\t\telse {\n\t\t\tAssetVocabulary assetVocabulary =\n\t\t\t\tAssetVocabularyLocalServiceUtil.fetchAssetVocabulary(\n\t\t\t\t\tcategory.getVocabularyId());\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, category, assetVocabulary,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\texportAssetVocabulary(\n\t\t\tportletDataContext, assetVocabulariesElement,\n\t\t\tassetCategory.getVocabularyId());\n\n\t\tif (assetCategory.getParentCategoryId() !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\texportAssetCategory(\n\t\t\t\tportletDataContext, assetVocabulariesElement,\n\t\t\t\tassetCategoriesElement, assetCategory.getParentCategoryId());\n\t\t}\n\n\t\tString path = getAssetCategoryPath(\n\t\t\tportletDataContext, assetCategory.getCategoryId());\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement assetCategoryElement = assetCategoriesElement.addElement(\n\t\t\t\"category\");\n\n\t\tassetCategoryElement.addAttribute(\"path\", path);\n\n\t\tassetCategory.setUserUuid(assetCategory.getUserUuid());\n\n\t\tportletDataContext.addZipEntry(path, assetCategory);\n\n\t\tList<AssetCategoryProperty> assetCategoryProperties =\n\t\t\tAssetCategoryPropertyLocalServiceUtil.getCategoryProperties(\n\t\t\t\tassetCategory.getCategoryId());\n\n\t\tfor (AssetCategoryProperty assetCategoryProperty :\n\t\t\t\tassetCategoryProperties) {\n\n\t\t\tElement propertyElement = assetCategoryElement.addElement(\n\t\t\t\t\"property\");\n\n\t\t\tpropertyElement.addAttribute(\n\t\t\t\t\"userUuid\", assetCategoryProperty.getUserUuid());\n\t\t\tpropertyElement.addAttribute(\"key\", assetCategoryProperty.getKey());\n\t\t\tpropertyElement.addAttribute(\n\t\t\t\t\"value\", assetCategoryProperty.getValue());\n\t\t}\n\n\t\tportletDataContext.addPermissions(\n\t\t\tAssetCategory.class, assetCategory.getCategoryId());\n\t}","id":80267,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetCategory category)\n\t\tthrows Exception {\n\n\t\tif (category.getParentCategoryId() !=\n\t\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tAssetCategory parentCategory =\n\t\t\t\tAssetCategoryLocalServiceUtil.fetchAssetCategory(\n\t\t\t\t\tcategory.getParentCategoryId());\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, category, parentCategory,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\t\telse {\n\t\t\tAssetVocabulary assetVocabulary =\n\t\t\t\tAssetVocabularyLocalServiceUtil.fetchAssetVocabulary(\n\t\t\t\t\tcategory.getVocabularyId());\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, category, assetVocabulary,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tElement categoryElement = portletDataContext.getExportDataElement(\n\t\t\tcategory);\n\n\t\tcategory.setUserUuid(category.getUserUuid());\n\n\t\tList<AssetCategoryProperty> categoryProperties =\n\t\t\tAssetCategoryPropertyLocalServiceUtil.getCategoryProperties(\n\t\t\t\tcategory.getCategoryId());\n\n\t\tfor (AssetCategoryProperty categoryProperty : categoryProperties) {\n\t\t\tElement propertyElement = categoryElement.addElement(\"property\");\n\n\t\t\tpropertyElement.addAttribute(\n\t\t\t\t\"userUuid\", categoryProperty.getUserUuid());\n\t\t\tpropertyElement.addAttribute(\"key\", categoryProperty.getKey());\n\t\t\tpropertyElement.addAttribute(\"value\", categoryProperty.getValue());\n\t\t}\n\n\t\tString categoryPath = ExportImportPathUtil.getModelPath(category);\n\n\t\tcategoryElement.addAttribute(\"path\", categoryPath);\n\n\t\tportletDataContext.addPermissions(\n\t\t\tAssetCategory.class, category.getCategoryId());\n\n\t\tportletDataContext.addZipEntry(categoryPath, category);\n\t}","commit_id":"aa486cb59cffe0a1e2e4810ffd60236f3c5a72b3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetVocabulary vocabulary)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tassetVocabulary.getUserUuid());\n\t\tlong groupId = portletDataContext.getScopeGroupId();\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(assetVocabulary.getCreateDate());\n\t\tserviceContext.setModifiedDate(assetVocabulary.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(portletDataContext.getScopeGroupId());\n\n\t\tAssetVocabulary importedAssetVocabulary = null;\n\n\t\tAssetVocabulary existingAssetVocabulary =\n\t\t\tAssetVocabularyUtil.fetchByUUID_G(\n\t\t\t\tassetVocabulary.getUuid(), groupId);\n\n\t\tif (existingAssetVocabulary == null) {\n\t\t\texistingAssetVocabulary = AssetVocabularyUtil.fetchByUUID_G(\n\t\t\t\tassetVocabulary.getUuid(),\n\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t}\n\n\t\tif (existingAssetVocabulary == null) {\n\t\t\tString name = getAssetVocabularyName(\n\t\t\t\tnull, groupId, assetVocabulary.getName(), 2);\n\n\t\t\tserviceContext.setUuid(assetVocabulary.getUuid());\n\n\t\t\timportedAssetVocabulary =\n\t\t\t\tAssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\t\t\tuserId, StringPool.BLANK,\n\t\t\t\t\tgetAssetVocabularyTitleMap(groupId, assetVocabulary, name),\n\t\t\t\t\tassetVocabulary.getDescriptionMap(),\n\t\t\t\t\tassetVocabulary.getSettings(), serviceContext);\n\t\t}\n\t\telse if (portletDataContext.isCompanyStagedGroupedModel(\n\t\t\t\t\texistingAssetVocabulary)) {\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tString name = getAssetVocabularyName(\n\t\t\t\tassetVocabulary.getUuid(), groupId, assetVocabulary.getName(),\n\t\t\t\t2);\n\n\t\t\timportedAssetVocabulary =\n\t\t\t\tAssetVocabularyLocalServiceUtil.updateVocabulary(\n\t\t\t\t\texistingAssetVocabulary.getVocabularyId(), StringPool.BLANK,\n\t\t\t\t\tgetAssetVocabularyTitleMap(groupId, assetVocabulary, name),\n\t\t\t\t\tassetVocabulary.getDescriptionMap(),\n\t\t\t\t\tassetVocabulary.getSettings(), serviceContext);\n\t\t}\n\n\t\tassetVocabularyPKs.put(\n\t\t\tassetVocabulary.getVocabularyId(),\n\t\t\timportedAssetVocabulary.getVocabularyId());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tAssetVocabulary.class, assetVocabulary.getVocabularyId(),\n\t\t\timportedAssetVocabulary.getVocabularyId());\n\t}","id":80268,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetVocabulary vocabulary)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(vocabulary.getUserUuid());\n\n\t\tServiceContext serviceContext = createServiceContext(\n\t\t\tportletDataContext, vocabulary);\n\n\t\tAssetVocabulary importedVocabulary = null;\n\n\t\tAssetVocabulary existingAssetVocabulary =\n\t\t\tAssetVocabularyUtil.fetchByUUID_G(\n\t\t\t\tvocabulary.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\tif (existingAssetVocabulary == null) {\n\t\t\texistingAssetVocabulary = AssetVocabularyUtil.fetchByUUID_G(\n\t\t\t\tvocabulary.getUuid(), portletDataContext.getCompanyGroupId());\n\t\t}\n\n\t\tif (existingAssetVocabulary == null) {\n\t\t\tString name = getAssetVocabularyName(\n\t\t\t\tnull, portletDataContext.getScopeGroupId(),\n\t\t\t\tvocabulary.getName(), 2);\n\n\t\t\tserviceContext.setUuid(vocabulary.getUuid());\n\n\t\t\timportedVocabulary =\n\t\t\t\tAssetVocabularyLocalServiceUtil.addVocabulary(\n\t\t\t\t\tuserId, StringPool.BLANK,\n\t\t\t\t\tgetAssetVocabularyTitleMap(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), vocabulary, name),\n\t\t\t\t\tvocabulary.getDescriptionMap(), vocabulary.getSettings(),\n\t\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tString name = getAssetVocabularyName(\n\t\t\t\tvocabulary.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\t\tvocabulary.getName(), 2);\n\n\t\t\timportedVocabulary =\n\t\t\t\tAssetVocabularyLocalServiceUtil.updateVocabulary(\n\t\t\t\t\texistingAssetVocabulary.getVocabularyId(), StringPool.BLANK,\n\t\t\t\t\tgetAssetVocabularyTitleMap(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), vocabulary, name),\n\t\t\t\t\tvocabulary.getDescriptionMap(), vocabulary.getSettings(),\n\t\t\t\t\tserviceContext);\n\t\t}\n\n\t\tMap<Long, Long> vocabularyIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetVocabulary.class);\n\n\t\tvocabularyIds.put(\n\t\t\tvocabulary.getVocabularyId(), importedVocabulary.getVocabularyId());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tAssetVocabulary.class, vocabulary.getVocabularyId(),\n\t\t\timportedVocabulary.getVocabularyId());\n\t}","commit_id":"aa486cb59cffe0a1e2e4810ffd60236f3c5a72b3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetVocabulary vocabulary)\n\t\tthrows Exception {\n\n\t\tString path = getAssetVocabulariesPath(\n\t\t\tportletDataContext, assetVocabulary.getVocabularyId());\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement assetVocabularyElement = assetVocabulariesElement.addElement(\n\t\t\t\"vocabulary\");\n\n\t\tassetVocabularyElement.addAttribute(\"path\", path);\n\n\t\tassetVocabulary.setUserUuid(assetVocabulary.getUserUuid());\n\n\t\tportletDataContext.addZipEntry(path, assetVocabulary);\n\n\t\tportletDataContext.addPermissions(\n\t\t\tAssetVocabulary.class, assetVocabulary.getVocabularyId());\n\t}","id":80269,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, AssetVocabulary vocabulary)\n\t\tthrows Exception {\n\n\t\tElement vocabularyElement = portletDataContext.getExportDataElement(\n\t\t\tvocabulary);\n\n\t\tString vocabularyPath = ExportImportPathUtil.getModelPath(vocabulary);\n\n\t\tvocabularyElement.addAttribute(\"path\", vocabularyPath);\n\n\t\tvocabulary.setUserUuid(vocabulary.getUserUuid());\n\n\t\tportletDataContext.addPermissions(\n\t\t\tAssetVocabulary.class, vocabulary.getVocabularyId());\n\n\t\tportletDataContext.addZipEntry(vocabularyPath, vocabulary);\n\t}","commit_id":"aa486cb59cffe0a1e2e4810ffd60236f3c5a72b3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * @param user\n     * @param pool\n     * @return the User object corresponding to the username in <code>user<\/code>\n     * @throws XMLDBException\n     */\n    private User getUser(String user, String password, BrokerPool pool) throws XMLDBException {\n        if (user == null) {\n            user = \"guest\";\n            password = \"guest\";\n        }\n    \tUser u = pool.getSecurityManager().getUser(user);\n        if (u == null) {\n        \tthrow new XMLDBException( ErrorCodes.PERMISSION_DENIED, \"User '\" + user + \"' does not exist\");\n        }\n        if (!u.validate(password) ) {\n        \tthrow new XMLDBException( ErrorCodes.PERMISSION_DENIED, \"Invalid password for user '\" + user + \"'\");\n        }\n        return u;\n    }","id":80270,"modified_method":"/**\n   * @param user\n   * @param pool\n   * @return the User object corresponding to the username in <code>user<\/code>\n   * @throws XMLDBException\n   */\n  private User getUser(String user, String password, BrokerPool pool) throws XMLDBException {\n    if (user == null) {\n      user = \"guest\";\n      password = \"guest\";\n    }\n    SecurityManager securityManager = pool.getSecurityManager();\n    User u = securityManager.getUser(user);\n    if (u == null) {\n      throw new XMLDBException(ErrorCodes.PERMISSION_DENIED, \"User '\" + user + \"' does not exist\");\n    }\n    if (!u.validate(password, securityManager)) {\n      throw new XMLDBException(ErrorCodes.PERMISSION_DENIED, \"Invalid password for user '\" + user + \"'\");\n    }\n    return u;\n  }","commit_id":"828f7d21badc000309cc7bd8bf96a0aeb928a992","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Attempt to create the lock file and thus acquire a lock.\n     * \n     * @return false if another process holds the lock\n     * @throws ReadOnlyException if the lock file could not be created or saved\n     * due to IO errors. The caller may want to switch to read-only mode.\n     */\n    public boolean tryLock() throws ReadOnlyException {\n        int attempt = 0;\n        while (lockFile.exists()) {\n            try {\n                read();\n            } catch (IOException e) {\n                message(\"Failed to read lock file\", null);\n                e.printStackTrace();\n            }\n            if (checkHeartbeat()) {\n                if (++attempt == 1) {\n                    // sometimes Java does not properly delete files, so we may have an old\n                    // lock file from a previous db run, which has not timed out yet. We thus\n                    // give the db a second chance and wait for HEARTBEAT + 100 milliseconds\n                    // before we check the heartbeat a second time.\n                    synchronized (this) {\n                        try {\n                            message(\"Waiting a short time for the lock to be released...\", null);\n                            wait(HEARTBEAT + 100);\n                        } catch (InterruptedException e) {\n                        }\n                    }\n                    try {\n                        // close the open channel, so it can be read again\n                        if (channel.isOpen())\n                            channel.close();\n                        channel = null;\n                    } catch (IOException e) {\n                    }\n                } else\n                    // we found a valid heartbeat\n                    return false;\n            }\n        }\n        try {\n            if (!lockFile.createNewFile())\n                return false;\n        } catch (IOException e) {\n            throw new ReadOnlyException(message(\"Could not create lock file\", e));\n        }\n        \n        try {\n            save();\n        } catch (IOException e) {\n            throw new ReadOnlyException(message(\"Caught exception while trying to write lock file\", e));\n        }\n        \n        //Schedule the heartbeat for the file lock\n        Properties params = new Properties();\n        params.put(FileLock.class.getName(), this);\n        pool.getScheduler().createPeriodicJob(HEARTBEAT, new FileLockHeartBeat(lockFile.getName()), -1, params);\n        \n        return true;\n    }","id":80271,"modified_method":"/**\n     * Attempt to create the lock file and thus acquire a lock.\n     * \n     * @return false if another process holds the lock\n     * @throws ReadOnlyException if the lock file could not be created or saved\n     * due to IO errors. The caller may want to switch to read-only mode.\n     */\n    public boolean tryLock() throws ReadOnlyException {\n\tint attempt = 0;\n\twhile (lockFile.exists()) {\n\t    try {\n\t\tread();\n\t    } catch (IOException e) {\n\t\tmessage(\"Failed to read lock file\", null);\n\t\te.printStackTrace();\n\t    }\n\t    if (checkHeartbeat()) {\n\t\tif (++attempt == 1) {\n                    // sometimes Java does not properly delete files, so we may have an old\n                    // lock file from a previous db run, which has not timed out yet. We thus\n                    // give the db a second chance and wait for HEARTBEAT + 100 milliseconds\n\t\t    // before we check the heartbeat a second time.\n\t\t    synchronized (this) {\n\t\t\ttry {\n                            message(\"Waiting a short time for the lock to be released...\", null);\n\t\t\t    wait(HEARTBEAT + 100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t    }\n\t\t    try {\n\t\t\t// close the open channel, so it can be read again\n\t\t\tif (channel.isOpen())\n\t\t\t    channel.close();\n\t\t\tchannel = null;\n\t\t    } catch (IOException e) {\n\t\t    }\n\t\t} else\n\t\t    // we found a valid heartbeat\n\t\t    return false;\n\t    }\n\t}\n\ttry {\n\t    if (!lockFile.createNewFile())\n\t\treturn false;\n\t} catch (IOException e) {\n            throw new ReadOnlyException(message(\"Could not create lock file\", e));\n\t}\n\n\ttry {\n\t    save();\n\t} catch (IOException e) {\n            throw new ReadOnlyException(message(\"Caught exception while trying to write lock file\", e));\n\t}\n\n        //Schedule the heartbeat for the file lock\n\tProperties params = new Properties();\n\tparams.put(FileLock.class.getName(), this);\n\tpool.getScheduler().createPeriodicJob(HEARTBEAT,\n\t\tnew FileLockHeartBeat(lockFile.getAbsolutePath()), -1, params);\n\n\treturn true;\n    }","commit_id":"828f7d21badc000309cc7bd8bf96a0aeb928a992","url":"https://github.com/eXist-db/exist"},{"original_method":"private void configure(String controllerConfig) throws ServletException {\n        LOG.debug(\"Loading XQueryURLRewrite configuration from \" + controllerConfig);\n        if (controllerConfig.startsWith(XmldbURI.XMLDB_URI_PREFIX)) {\n            DBBroker broker = null;\n            DocumentImpl doc = null;\n            try {\n                broker = urlRewrite.pool.get(urlRewrite.user);\n\n                doc = broker.getXMLResource(XmldbURI.create(controllerConfig), Lock.READ_LOCK);\n                if (doc != null)\n                    parse(doc);\n            } catch (EXistException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } catch (PermissionDeniedException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } finally {\n                if (doc != null)\n                    doc.getUpdateLock().release(Lock.READ_LOCK);\n                urlRewrite.pool.release(broker);\n            }\n        } else {\n            try {\n                File d = new File(urlRewrite.getConfig().getServletContext().getRealPath(\".\"));\n                File configFile = new File(d, controllerConfig);\n                if (configFile.canRead()) {\n                    Document doc = parseConfig(configFile);\n                    parse(doc);\n                }\n            } catch (ParserConfigurationException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } catch (SAXException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } catch (IOException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            }\n        }\n        urlRewrite.clearCaches();\n    }","id":80272,"modified_method":"private void configure(String controllerConfig) throws ServletException {\n        LOG.debug(\"Loading XQueryURLRewrite configuration from \" + controllerConfig);\n        if (controllerConfig.startsWith(XmldbURI.XMLDB_URI_PREFIX)) {\n            DBBroker broker = null;\n            DocumentImpl doc = null;\n            try {\n                broker = urlRewrite.pool.get(urlRewrite.defaultUser);\n\n                doc = broker.getXMLResource(XmldbURI.create(controllerConfig), Lock.READ_LOCK);\n                if (doc != null)\n                    parse(doc);\n            } catch (EXistException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } catch (PermissionDeniedException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } finally {\n                if (doc != null)\n                    doc.getUpdateLock().release(Lock.READ_LOCK);\n                urlRewrite.pool.release(broker);\n            }\n        } else {\n            try {\n                File d = new File(urlRewrite.getConfig().getServletContext().getRealPath(\".\"));\n                File configFile = new File(d, controllerConfig);\n                if (configFile.canRead()) {\n                    Document doc = parseConfig(configFile);\n                    parse(doc);\n                }\n            } catch (ParserConfigurationException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } catch (SAXException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            } catch (IOException e) {\n                throw new ServletException(\"Failed to parse controller.xml: \" + e.getMessage(), e);\n            }\n        }\n        urlRewrite.clearCaches();\n    }","commit_id":"c776e0158038c4a58dad98980c2c96c8fafb8d05","url":"https://github.com/eXist-db/exist"},{"original_method":"private void checkCache() throws EXistException {\n        if (checkModified) {\n            // check if any of the currently used sources has been updated\n            // if yes, clear the cache\n            synchronized (urlCache) {\n                for (Source source : sources.values()) {\n                    if (source instanceof DBSource) {\n                        // Check if the XQuery source changed. If yes, clear all caches.\n                        DBBroker broker = null;\n                        try {\n                            broker = pool.get(user);\n                            if (source.isValid(broker) != Source.VALID) {\n                                clearCaches();\n                                break;\n                            }\n                        } finally {\n                            pool.release(broker);\n                        }\n                    } else {\n                        if (source.isValid((DBBroker)null) != Source.VALID) {\n                            clearCaches();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }","id":80273,"modified_method":"private void checkCache(User user) throws EXistException {\n        if (checkModified) {\n            // check if any of the currently used sources has been updated\n            // if yes, clear the cache\n            synchronized (urlCache) {\n                for (Source source : sources.values()) {\n                    if (source instanceof DBSource) {\n                        // Check if the XQuery source changed. If yes, clear all caches.\n                        DBBroker broker = null;\n                        try {\n                            broker = pool.get(user);\n                            if (source.isValid(broker) != Source.VALID) {\n                                clearCaches();\n                                break;\n                            }\n                        } finally {\n                            pool.release(broker);\n                        }\n                    } else {\n                        if (source.isValid((DBBroker)null) != Source.VALID) {\n                            clearCaches();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"c776e0158038c4a58dad98980c2c96c8fafb8d05","url":"https://github.com/eXist-db/exist"},{"original_method":"public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        if (rewriteConfig == null) {\n            configure();\n            rewriteConfig = new RewriteConfig(this);\n        }\n        \n        long start = System.currentTimeMillis();\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n        if (request.getCharacterEncoding() == null) {\n            try {\n                request.setCharacterEncoding(\"UTF-8\");\n            } catch (IllegalStateException e) {\n            }\n        }\n\n        if (LOG.isTraceEnabled())\n            LOG.trace(request.getRequestURI());\n        \n        Descriptor descriptor = Descriptor.getDescriptorSingleton();\n        if(descriptor != null && descriptor.requestsFiltered())\n        {\n            String attr = (String) request.getAttribute(\"XQueryURLRewrite.forwarded\");\n            if (attr == null) {\n//                request = new HttpServletRequestWrapper(request, /*formEncoding*/ \"utf-8\" );\n                //logs the request if specified in the descriptor\n                descriptor.doLogRequestInReplayLog(request);\n\n                request.setAttribute(\"XQueryURLRewrite.forwarded\", \"true\");\n            }\n        }\n\n        try {\n            configure();\n            checkCache();\n\n            RequestWrapper modifiedRequest = new RequestWrapper(request);\n            URLRewrite staticRewrite = rewriteConfig.lookup(modifiedRequest);\n            if (staticRewrite != null && !staticRewrite.isControllerForward()) {\n                modifiedRequest.setPaths(staticRewrite.resolve(modifiedRequest), staticRewrite.getPrefix());\n                if (LOG.isTraceEnabled())\n                    LOG.trace(\"Forwarding to target: \" + staticRewrite.getTarget());\n                staticRewrite.doRewrite(modifiedRequest, response, filterChain);\n            } else {\n                if (LOG.isTraceEnabled())\n                    LOG.trace(\"Processing request URI: \" + request.getRequestURI());\n\n                if (staticRewrite != null) {\n                    // fix the request URI\n                    staticRewrite.updateRequest(modifiedRequest);\n                }\n\n                // check if the request URI is already in the url cache\n                ModelAndView modelView;\n                synchronized (urlCache) {\n                    modelView = urlCache.get(modifiedRequest.getRequestURI());\n                }\n                // no: create a new model and view configuration\n                if (modelView == null) {\n                    modelView = new ModelAndView();\n                    // Execute the query\n                    Sequence result = Sequence.EMPTY_SEQUENCE;\n                    DBBroker broker = null;\n                    try {\n                        broker = pool.get(user);\n                        modifiedRequest.setAttribute(RQ_ATTR_REQUEST_URI, request.getRequestURI());\n                        result = runQuery(broker, modifiedRequest, response, staticRewrite);\n\n                        logResult(broker, result);\n                    } finally {\n                        pool.release(broker);\n                    }\n\n                    // process the query result\n                    if (result.getItemCount() == 1) {\n                        Item resource = result.itemAt(0);\n                        if (!Type.subTypeOf(resource.getType(), Type.NODE))\n                            throw new ServletException(\"XQueryURLRewrite: urlrewrite query should return an element!\");\n                        Node node = ((NodeValue) resource).getNode();\n                        if (node.getNodeType() == Node.DOCUMENT_NODE)\n                            node = ((Document) node).getDocumentElement();\n                        if (node.getNodeType() != Node.ELEMENT_NODE) {\n                            throw new ServletException(\"Redirect XQuery should return an XML element!\");\n                        }\n                        Element elem = (Element) node;\n                        if (!(Namespaces.EXIST_NS.equals(elem.getNamespaceURI()))) {\n                            throw new ServletException(\"Redirect XQuery should return an element in namespace \" + Namespaces.EXIST_NS);\n                        }\n\n                        if (\"dispatch\".equals(elem.getLocalName())) {\n                            node = elem.getFirstChild();\n                            while (node != null) {\n                                if (node.getNodeType() == Node.ELEMENT_NODE && Namespaces.EXIST_NS.equals(node.getNamespaceURI())) {\n                                    Element action = (Element) node;\n                                    if (\"view\".equals(action.getLocalName())) {\n                                        parseViews(modifiedRequest, action, modelView);\n                                    } else if (\"cache-control\".equals(action.getLocalName())) {\n                                        String option = action.getAttribute(\"cache\");\n                                        modelView.setUseCache(\"yes\".equals(option));\n                                    } else {\n                                        URLRewrite urw = parseAction(modifiedRequest, action);\n                                        if (urw != null)\n                                            modelView.setModel(urw);\n                                    }\n                                }\n                                node = node.getNextSibling();\n                            }\n                            if (modelView.getModel() == null)\n                                modelView.setModel(new PassThrough(elem, modifiedRequest));\n                        } else if (\"ignore\".equals(elem.getLocalName())) {\n                            modelView.setModel(new PassThrough(elem, modifiedRequest));\n                            NodeList nl = elem.getElementsByTagNameNS(Namespaces.EXIST_NS, \"cache-control\");\n                            if (nl.getLength() > 0) {\n                                elem = (Element) nl.item(0);\n                                String option = elem.getAttribute(\"cache\");\n                                modelView.setUseCache(\"yes\".equals(option));\n                            }\n                        }\n                    }\n\n                    // store the original request URI to org.exist.forward.request-uri\n                    modifiedRequest.setAttribute(RQ_ATTR_REQUEST_URI, request.getRequestURI());\n                    modifiedRequest.setAttribute(RQ_ATTR_SERVLET_PATH, request.getServletPath());\n\n                    if (modelView.useCache()) {\n                        synchronized (urlCache) {\n                            urlCache.put(request.getRequestURI(), modelView);\n                        }\n                    }\n                }\n                if (LOG.isTraceEnabled())\n                    LOG.trace(\"URLRewrite took \" + (System.currentTimeMillis() - start) + \"ms.\");\n\n                HttpServletResponse wrappedResponse = response;\n                if (modelView.hasViews())\n                    wrappedResponse = new CachingResponseWrapper(response, true);\n                if (modelView.getModel() == null)\n                    modelView.setModel(new PassThrough(modifiedRequest));\n\n                if (staticRewrite != null) {\n                    staticRewrite.rewriteRequest(modifiedRequest);\n                }\n                doRewrite(modelView.getModel(), modifiedRequest, wrappedResponse, filterChain);\n\n                if (modelView.hasViews()) {\n                    int status = ((CachingResponseWrapper) wrappedResponse).getStatus();\n                    if (status == HttpServletResponse.SC_NOT_MODIFIED) {\n                        response.flushBuffer();\n                    } else if (status < 400) {\n                        List<URLRewrite> views = modelView.views;\n                        for (int i = 0; i < views.size(); i++) {\n                            URLRewrite view = (URLRewrite) views.get(i);\n                            RequestWrapper wrappedReq = new RequestWrapper(modifiedRequest);\n                            wrappedReq.setMethod(\"POST\");\n                            wrappedReq.setCharacterEncoding(wrappedResponse.getCharacterEncoding());\n                            wrappedReq.setContentType(wrappedResponse.getContentType());\n                            byte[] data = ((CachingResponseWrapper) wrappedResponse).getData();\n                            if (data != null)\n                                wrappedReq.setData(data);\n\n                            if (i < views.size() - 1)\n                                wrappedResponse = new CachingResponseWrapper(response, true);\n                            else\n                                wrappedResponse = new CachingResponseWrapper(response, false);\n                            doRewrite(view, wrappedReq, wrappedResponse, null);\n                            wrappedResponse.flushBuffer();\n\n                            // catch errors in the view\n                            status = ((CachingResponseWrapper) wrappedResponse).getStatus();\n                            if (status >= 400) {\n                                flushError(response, wrappedResponse);\n                                break;\n                            }\n                        }\n                    } else {\n                        // HTTP response code indicates an error\n                        flushError(response, wrappedResponse);\n                    }\n                }\n//            Sequence result;\n//            if ((result = (Sequence) request.getAttribute(RQ_ATTR_RESULT)) != null) {\n//                writeResults(response, broker, result);\n//            }\n            }\n        } catch (EXistException e) {\n            LOG.error(e.getMessage(), e);\n            throw new ServletException(\"An error occurred while retrieving query results: \" \n                    + e.getMessage(), e);\n\n        } catch (XPathException e) {\n            LOG.error(e.getMessage(), e);\n            throw new ServletException(\"An error occurred while executing the urlrewrite query: \" \n                    + e.getMessage(), e);\n\n//        } catch (SAXException e) {\n//            throw new ServletException(\"Error while serializing results: \" + e.getMessage(), e);\n            \n        } catch (Throwable e){\n            LOG.error(e.getMessage(), e);\n            throw new ServletException(\"An error occurred: \"\n                    + e.getMessage(), e);\n        }\n    }","id":80274,"modified_method":"public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        if (rewriteConfig == null) {\n            configure();\n            rewriteConfig = new RewriteConfig(this);\n        }\n        \n        long start = System.currentTimeMillis();\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n        if (request.getCharacterEncoding() == null) {\n            try {\n                request.setCharacterEncoding(\"UTF-8\");\n            } catch (IllegalStateException e) {\n            }\n        }\n\n        if (LOG.isTraceEnabled())\n            LOG.trace(request.getRequestURI());\n        \n        Descriptor descriptor = Descriptor.getDescriptorSingleton();\n        if(descriptor != null && descriptor.requestsFiltered())\n        {\n            String attr = (String) request.getAttribute(\"XQueryURLRewrite.forwarded\");\n            if (attr == null) {\n//                request = new HttpServletRequestWrapper(request, /*formEncoding*/ \"utf-8\" );\n                //logs the request if specified in the descriptor\n                descriptor.doLogRequestInReplayLog(request);\n\n                request.setAttribute(\"XQueryURLRewrite.forwarded\", \"true\");\n            }\n        }\n\n    \tUser user = defaultUser;\n        Principal principal = request.getUserPrincipal();\n        if (principal instanceof User)\n\t\t\tuser = (User) principal;\n\n        try {\n            configure();\n            checkCache(user);\n\n            RequestWrapper modifiedRequest = new RequestWrapper(request);\n            URLRewrite staticRewrite = rewriteConfig.lookup(modifiedRequest);\n            if (staticRewrite != null && !staticRewrite.isControllerForward()) {\n                modifiedRequest.setPaths(staticRewrite.resolve(modifiedRequest), staticRewrite.getPrefix());\n                if (LOG.isTraceEnabled())\n                    LOG.trace(\"Forwarding to target: \" + staticRewrite.getTarget());\n                staticRewrite.doRewrite(modifiedRequest, response, filterChain);\n            } else {\n                if (LOG.isTraceEnabled())\n                    LOG.trace(\"Processing request URI: \" + request.getRequestURI());\n\n                if (staticRewrite != null) {\n                    // fix the request URI\n                    staticRewrite.updateRequest(modifiedRequest);\n                }\n\n                // check if the request URI is already in the url cache\n                ModelAndView modelView;\n                synchronized (urlCache) {\n                    modelView = urlCache.get(modifiedRequest.getRequestURI());\n                }\n                // no: create a new model and view configuration\n                if (modelView == null) {\n                    modelView = new ModelAndView();\n                    // Execute the query\n                    Sequence result = Sequence.EMPTY_SEQUENCE;\n                    DBBroker broker = null;\n                    try {\n                        broker = pool.get(user);\n                        modifiedRequest.setAttribute(RQ_ATTR_REQUEST_URI, request.getRequestURI());\n                        result = runQuery(broker, modifiedRequest, response, staticRewrite);\n\n                        logResult(broker, result);\n                    } finally {\n                        pool.release(broker);\n                    }\n\n                    // process the query result\n                    if (result.getItemCount() == 1) {\n                        Item resource = result.itemAt(0);\n                        if (!Type.subTypeOf(resource.getType(), Type.NODE))\n                            throw new ServletException(\"XQueryURLRewrite: urlrewrite query should return an element!\");\n                        Node node = ((NodeValue) resource).getNode();\n                        if (node.getNodeType() == Node.DOCUMENT_NODE)\n                            node = ((Document) node).getDocumentElement();\n                        if (node.getNodeType() != Node.ELEMENT_NODE) {\n                            throw new ServletException(\"Redirect XQuery should return an XML element!\");\n                        }\n                        Element elem = (Element) node;\n                        if (!(Namespaces.EXIST_NS.equals(elem.getNamespaceURI()))) {\n                            throw new ServletException(\"Redirect XQuery should return an element in namespace \" + Namespaces.EXIST_NS);\n                        }\n\n                        if (\"dispatch\".equals(elem.getLocalName())) {\n                            node = elem.getFirstChild();\n                            while (node != null) {\n                                if (node.getNodeType() == Node.ELEMENT_NODE && Namespaces.EXIST_NS.equals(node.getNamespaceURI())) {\n                                    Element action = (Element) node;\n                                    if (\"view\".equals(action.getLocalName())) {\n                                        parseViews(modifiedRequest, action, modelView);\n                                    } else if (\"cache-control\".equals(action.getLocalName())) {\n                                        String option = action.getAttribute(\"cache\");\n                                        modelView.setUseCache(\"yes\".equals(option));\n                                    } else {\n                                        URLRewrite urw = parseAction(modifiedRequest, action);\n                                        if (urw != null)\n                                            modelView.setModel(urw);\n                                    }\n                                }\n                                node = node.getNextSibling();\n                            }\n                            if (modelView.getModel() == null)\n                                modelView.setModel(new PassThrough(elem, modifiedRequest));\n                        } else if (\"ignore\".equals(elem.getLocalName())) {\n                            modelView.setModel(new PassThrough(elem, modifiedRequest));\n                            NodeList nl = elem.getElementsByTagNameNS(Namespaces.EXIST_NS, \"cache-control\");\n                            if (nl.getLength() > 0) {\n                                elem = (Element) nl.item(0);\n                                String option = elem.getAttribute(\"cache\");\n                                modelView.setUseCache(\"yes\".equals(option));\n                            }\n                        }\n                    }\n\n                    // store the original request URI to org.exist.forward.request-uri\n                    modifiedRequest.setAttribute(RQ_ATTR_REQUEST_URI, request.getRequestURI());\n                    modifiedRequest.setAttribute(RQ_ATTR_SERVLET_PATH, request.getServletPath());\n\n                    if (modelView.useCache()) {\n                        synchronized (urlCache) {\n                            urlCache.put(request.getRequestURI(), modelView);\n                        }\n                    }\n                }\n                if (LOG.isTraceEnabled())\n                    LOG.trace(\"URLRewrite took \" + (System.currentTimeMillis() - start) + \"ms.\");\n\n                HttpServletResponse wrappedResponse = response;\n                if (modelView.hasViews())\n                    wrappedResponse = new CachingResponseWrapper(response, true);\n                if (modelView.getModel() == null)\n                    modelView.setModel(new PassThrough(modifiedRequest));\n\n                if (staticRewrite != null) {\n                    staticRewrite.rewriteRequest(modifiedRequest);\n                }\n                doRewrite(modelView.getModel(), modifiedRequest, wrappedResponse, filterChain);\n\n                if (modelView.hasViews()) {\n                    int status = ((CachingResponseWrapper) wrappedResponse).getStatus();\n                    if (status == HttpServletResponse.SC_NOT_MODIFIED) {\n                        response.flushBuffer();\n                    } else if (status < 400) {\n                        List<URLRewrite> views = modelView.views;\n                        for (int i = 0; i < views.size(); i++) {\n                            URLRewrite view = (URLRewrite) views.get(i);\n                            RequestWrapper wrappedReq = new RequestWrapper(modifiedRequest);\n                            wrappedReq.setMethod(\"POST\");\n                            wrappedReq.setCharacterEncoding(wrappedResponse.getCharacterEncoding());\n                            wrappedReq.setContentType(wrappedResponse.getContentType());\n                            byte[] data = ((CachingResponseWrapper) wrappedResponse).getData();\n                            if (data != null)\n                                wrappedReq.setData(data);\n\n                            if (i < views.size() - 1)\n                                wrappedResponse = new CachingResponseWrapper(response, true);\n                            else\n                                wrappedResponse = new CachingResponseWrapper(response, false);\n                            doRewrite(view, wrappedReq, wrappedResponse, null);\n                            wrappedResponse.flushBuffer();\n\n                            // catch errors in the view\n                            status = ((CachingResponseWrapper) wrappedResponse).getStatus();\n                            if (status >= 400) {\n                                flushError(response, wrappedResponse);\n                                break;\n                            }\n                        }\n                    } else {\n                        // HTTP response code indicates an error\n                        flushError(response, wrappedResponse);\n                    }\n                }\n//            Sequence result;\n//            if ((result = (Sequence) request.getAttribute(RQ_ATTR_RESULT)) != null) {\n//                writeResults(response, broker, result);\n//            }\n            }\n        } catch (EXistException e) {\n            LOG.error(e.getMessage(), e);\n            throw new ServletException(\"An error occurred while retrieving query results: \" \n                    + e.getMessage(), e);\n\n        } catch (XPathException e) {\n            LOG.error(e.getMessage(), e);\n            throw new ServletException(\"An error occurred while executing the urlrewrite query: \" \n                    + e.getMessage(), e);\n\n//        } catch (SAXException e) {\n//            throw new ServletException(\"Error while serializing results: \" + e.getMessage(), e);\n            \n        } catch (Throwable e){\n            LOG.error(e.getMessage(), e);\n            throw new ServletException(\"An error occurred: \"\n                    + e.getMessage(), e);\n        }\n    }","commit_id":"c776e0158038c4a58dad98980c2c96c8fafb8d05","url":"https://github.com/eXist-db/exist"},{"original_method":"private void configure() throws ServletException {\n        try {\n            Class<?> driver = Class.forName(DRIVER);\n            Database database = (Database) driver.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n            LOG.debug(\"Initialized database\");\n        } catch(Exception e) {\n            String errorMessage=\"Failed to initialize database driver\";\n            LOG.error(errorMessage,e);\n            throw new ServletException(errorMessage+\": \" + e.getMessage(), e);\n        }\n\n        String username = config.getInitParameter(\"user\");\n        if(username == null)\n            username = DEFAULT_USER;\n        String password = config.getInitParameter(\"password\");\n        if(password == null)\n            password = DEFAULT_PASS;\n        try {\n            pool = BrokerPool.getInstance();\n            org.exist.security.SecurityManager secman = pool.getSecurityManager();\n            user = secman.getUser(username);\n            if (!user.validate(password)) {\n                throw new ServletException(\"Invalid password specified for XQueryURLRewrite user\");\n            }\n        } catch (EXistException e) {\n            throw new ServletException(\"Could not intialize db: \" + e.getMessage(), e);\n        }\n    }","id":80275,"modified_method":"private void configure() throws ServletException {\n        try {\n            Class<?> driver = Class.forName(DRIVER);\n            Database database = (Database) driver.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n            LOG.debug(\"Initialized database\");\n        } catch(Exception e) {\n            String errorMessage=\"Failed to initialize database driver\";\n            LOG.error(errorMessage,e);\n            throw new ServletException(errorMessage+\": \" + e.getMessage(), e);\n        }\n\n\t\ttry {\n\t\t\tpool = BrokerPool.getInstance();\n\t\t} catch (EXistException e) {\n            throw new ServletException(\"Could not intialize db: \" + e.getMessage(), e);\n\t\t}\n        \n\t\tString username = config.getInitParameter(\"user\");\n\t\tif(username != null) {\n\t\t\tString password = config.getInitParameter(\"password\");\n\t\t\ttry {\n\t\t\t\tUser user = pool.getSecurityManager().authenticate(username, password);\n\t        \tif (user != null && user.isAuthenticated())\n\t        \t\tdefaultUser = user;\n\t\t\t} catch (AuthenticationException e) {\n\t\t\t\tLOG.error(\"User can not be authenticated (\"+username+\"), using default user.\");\n\t\t\t}\n\t\t}\n    }","commit_id":"c776e0158038c4a58dad98980c2c96c8fafb8d05","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @param user\n     * @param pool\n     * @return the User object corresponding to the username in <code>user<\/code>\n     * @throws XMLDBException\n     */\n    private User getUser(String user, String password, BrokerPool pool) throws XMLDBException {\n        if (user == null) {\n            user = \"guest\";\n            password = \"guest\";\n        }\n    \tUser u = pool.getSecurityManager().getUser(user);\n        if (u == null) {\n        \tthrow new XMLDBException( ErrorCodes.PERMISSION_DENIED, \"User '\" + user + \"' does not exist\");\n        }\n        if (!u.validate(password) ) {\n        \tthrow new XMLDBException( ErrorCodes.PERMISSION_DENIED, \"Invalid password for user '\" + user + \"'\");\n        }\n        return u;\n    }","id":80276,"modified_method":"/**\n   * @param user\n   * @param pool\n   * @return the User object corresponding to the username in <code>user<\/code>\n   * @throws XMLDBException\n   */\n  private User getUser(String user, String password, BrokerPool pool) throws XMLDBException {\n    if (user == null) {\n      user = \"guest\";\n      password = \"guest\";\n    }\n    SecurityManager securityManager = pool.getSecurityManager();\n    User u = securityManager.getUser(user);\n    if (u == null) {\n      throw new XMLDBException(ErrorCodes.PERMISSION_DENIED, \"User '\" + user + \"' does not exist\");\n    }\n    if (!u.validate(password, securityManager)) {\n      throw new XMLDBException(ErrorCodes.PERMISSION_DENIED, \"Invalid password for user '\" + user + \"'\");\n    }\n    return u;\n  }","commit_id":"5a2ee0675c7d7de9757db5c73ef34c0cf2359d5e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Attempt to create the lock file and thus acquire a lock.\n     * \n     * @return false if another process holds the lock\n     * @throws ReadOnlyException if the lock file could not be created or saved\n     * due to IO errors. The caller may want to switch to read-only mode.\n     */\n    public boolean tryLock() throws ReadOnlyException {\n        int attempt = 0;\n        while (lockFile.exists()) {\n            try {\n                read();\n            } catch (IOException e) {\n                message(\"Failed to read lock file\", null);\n                e.printStackTrace();\n            }\n            if (checkHeartbeat()) {\n                if (++attempt == 1) {\n                    // sometimes Java does not properly delete files, so we may have an old\n                    // lock file from a previous db run, which has not timed out yet. We thus\n                    // give the db a second chance and wait for HEARTBEAT + 100 milliseconds\n                    // before we check the heartbeat a second time.\n                    synchronized (this) {\n                        try {\n                            message(\"Waiting a short time for the lock to be released...\", null);\n                            wait(HEARTBEAT + 100);\n                        } catch (InterruptedException e) {\n                        }\n                    }\n                    try {\n                        // close the open channel, so it can be read again\n                        if (channel.isOpen())\n                            channel.close();\n                        channel = null;\n                    } catch (IOException e) {\n                    }\n                } else\n                    // we found a valid heartbeat\n                    return false;\n            }\n        }\n        try {\n            if (!lockFile.createNewFile())\n                return false;\n        } catch (IOException e) {\n            throw new ReadOnlyException(message(\"Could not create lock file\", e));\n        }\n        \n        try {\n            save();\n        } catch (IOException e) {\n            throw new ReadOnlyException(message(\"Caught exception while trying to write lock file\", e));\n        }\n        \n        //Schedule the heartbeat for the file lock\n        Properties params = new Properties();\n        params.put(FileLock.class.getName(), this);\n        pool.getScheduler().createPeriodicJob(HEARTBEAT, new FileLockHeartBeat(lockFile.getName()), -1, params);\n        \n        return true;\n    }","id":80277,"modified_method":"/**\n     * Attempt to create the lock file and thus acquire a lock.\n     * \n     * @return false if another process holds the lock\n     * @throws ReadOnlyException if the lock file could not be created or saved\n     * due to IO errors. The caller may want to switch to read-only mode.\n     */\n    public boolean tryLock() throws ReadOnlyException {\n\tint attempt = 0;\n\twhile (lockFile.exists()) {\n\t    try {\n\t\tread();\n\t    } catch (IOException e) {\n\t\tmessage(\"Failed to read lock file\", null);\n\t\te.printStackTrace();\n\t    }\n\t    if (checkHeartbeat()) {\n\t\tif (++attempt == 1) {\n                    // sometimes Java does not properly delete files, so we may have an old\n                    // lock file from a previous db run, which has not timed out yet. We thus\n                    // give the db a second chance and wait for HEARTBEAT + 100 milliseconds\n\t\t    // before we check the heartbeat a second time.\n\t\t    synchronized (this) {\n\t\t\ttry {\n                            message(\"Waiting a short time for the lock to be released...\", null);\n\t\t\t    wait(HEARTBEAT + 100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t    }\n\t\t    try {\n\t\t\t// close the open channel, so it can be read again\n\t\t\tif (channel.isOpen())\n\t\t\t    channel.close();\n\t\t\tchannel = null;\n\t\t    } catch (IOException e) {\n\t\t    }\n\t\t} else\n\t\t    // we found a valid heartbeat\n\t\t    return false;\n\t    }\n\t}\n\ttry {\n\t    if (!lockFile.createNewFile())\n\t\treturn false;\n\t} catch (IOException e) {\n            throw new ReadOnlyException(message(\"Could not create lock file\", e));\n\t}\n\n\ttry {\n\t    save();\n\t} catch (IOException e) {\n            throw new ReadOnlyException(message(\"Caught exception while trying to write lock file\", e));\n\t}\n\n        //Schedule the heartbeat for the file lock\n\tProperties params = new Properties();\n\tparams.put(FileLock.class.getName(), this);\n\tpool.getScheduler().createPeriodicJob(HEARTBEAT,\n\t\tnew FileLockHeartBeat(lockFile.getAbsolutePath()), -1, params);\n\n\treturn true;\n    }","commit_id":"5a2ee0675c7d7de9757db5c73ef34c0cf2359d5e","url":"https://github.com/eXist-db/exist"},{"original_method":"private static void doQuery(Collection collection, String query) {\n    \ttry {\n\t        XQueryService service = (XQueryService)\n\t            collection.getService(\"XQueryService\", \"1.0\");\n\t        ResourceSet result = service.query(query);\n\t        System.out.println(\"Found \" + result.getSize() + \" results.\");\n\t        for(ResourceIterator i = result.getIterator(); i.hasMoreResources(); ) {\n\t            String content = i.nextResource().getContent().toString();\n\t        }\n        } catch (Exception e) {            \n            fail(e.getMessage()); \n        }\n    }","id":80278,"modified_method":"private static void doQuery(Collection collection, String query) {\n    \ttry {\n\t        XQueryService service = (XQueryService)\n\t            collection.getService(\"XQueryService\", \"1.0\");\n\t        ResourceSet result = service.query(query);\n\t        System.out.println(\"Found \" + result.getSize() + \" results.\");\n\t        for(ResourceIterator i = result.getIterator(); i.hasMoreResources(); ) {\n\t            String content = i.nextResource().getContent().toString();\n\t        }\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage()); \n        }\n    }","commit_id":"5a2ee0675c7d7de9757db5c73ef34c0cf2359d5e","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() {\n    \ttry {\n\t        for (int i = 0; i < INSTANCE_COUNT; i++) {\n\t            Collection root = DatabaseManager.getCollection(\"xmldb:test\" + i + \"://\" + DBBroker.ROOT_COLLECTION);\n\t            Collection test = root.getChildCollection(\"test\");\n\t            if (test == null) {\n\t                CollectionManagementService service = (CollectionManagementService)\n\t                    root.getService(\"CollectionManagementService\", \"1.0\");\n\t                test = service.createCollection(\"test\");\n\t            }\n\t            \n                    String existHome = System.getProperty(\"exist.home\");\n                    File existDir = existHome==null ? new File(\".\") : new File(existHome);\n\t            File samples = new File(existDir,\"samples/shakespeare\");\n\t            File[] files = samples.listFiles();\n\t            MimeTable mimeTab = MimeTable.getInstance();\n\t            for (int j = 0; j < files.length; j++) {\n\t                MimeType mime = mimeTab.getContentTypeFor(files[j].getName());\n\t                if(mime != null && mime.isXMLType())\n\t                    loadFile(test, files[j].getAbsolutePath());\n\t            }\n\t            \n\t            doQuery(test, \"//SPEECH[SPEAKER='HAMLET']\");\n\t        }\n        } catch (Exception e) {            \n            fail(e.getMessage()); \n        }\n    }","id":80279,"modified_method":"public void testStore() {\n    \ttry {\n\t        for (int i = 0; i < INSTANCE_COUNT; i++) {\n\t            Collection root = DatabaseManager.getCollection(\"xmldb:test\" + i + \"://\" + DBBroker.ROOT_COLLECTION);\n\t            Collection test = root.getChildCollection(\"test\");\n\t            if (test == null) {\n\t                CollectionManagementService service = (CollectionManagementService)\n\t                    root.getService(\"CollectionManagementService\", \"1.0\");\n\t                test = service.createCollection(\"test\");\n\t            }\n\t            \n                    String existHome = System.getProperty(\"exist.home\");\n                    File existDir = existHome==null ? new File(\".\") : new File(existHome);\n\t            File samples = new File(existDir,\"samples/shakespeare\");\n\t            File[] files = samples.listFiles();\n\t            MimeTable mimeTab = MimeTable.getInstance();\n\t            for (int j = 0; j < files.length; j++) {\n\t                MimeType mime = mimeTab.getContentTypeFor(files[j].getName());\n\t                if(mime != null && mime.isXMLType())\n\t                    loadFile(test, files[j].getAbsolutePath());\n\t            }\n\t            \n\t            doQuery(test, \"//SPEECH[SPEAKER='HAMLET']\");\n\t        }\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage()); \n        }\n    }","commit_id":"5a2ee0675c7d7de9757db5c73ef34c0cf2359d5e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Create and Start a new Scheduler\n\t * \n\t * @param brokerpool\tThe brokerpool for which this scheduler is intended\n\t */\n\tpublic Scheduler(BrokerPool brokerpool, Configuration config) throws EXistException\n\t{\n\t\tthis.brokerpool = brokerpool;\n\t\tthis.config = config;\n\t\t\n\t\ttry\n\t\t{\n\t\t\t//load the properties for quartz\n            InputStream is = Scheduler.class.getResourceAsStream(\"quartz.properties\");\n            Properties properties = new Properties();\n            try\n            {\n                properties.load(is);\n            }\n            catch (IOException e)\n            {\n                throw new EXistException(\"Failed to load scheduler settings from org/exist/scheduler/quartz.properties\");\n            }\n\n            SchedulerFactory schedulerFactory = new StdSchedulerFactory(properties);\n\t\t\tscheduler = schedulerFactory.getScheduler();\n\t\t}\n\t\tcatch(SchedulerException se)\n\t\t{\n\t\t\tthrow new EXistException(\"Unable to create Scheduler\", se);\n\t\t}\n\t}","id":80280,"modified_method":"/**\n\t * Create and Start a new Scheduler\n\t * \n\t * @param brokerpool\tThe brokerpool for which this scheduler is intended\n\t */\n\tpublic Scheduler(BrokerPool brokerpool, Configuration config) throws EXistException\n\t{\n\t\tthis.brokerpool = brokerpool;\n\t\tthis.config = config;\n\t\t\n\t\ttry\n\t\t{\n\t\t\t//load the properties for quartz\n            InputStream is = Scheduler.class.getResourceAsStream(\"quartz.properties\");\n            Properties properties = new Properties();\n            try\n            {\n                properties.load(is);\n            }\n            catch (IOException e)\n            {\n                throw new EXistException(\"Failed to load scheduler settings from org/exist/scheduler/quartz.properties\");\n            }\n            properties.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, brokerpool.getId() + \"_QuartzScheduler\");\n            SchedulerFactory schedulerFactory = new StdSchedulerFactory(properties);\n\t\t\tscheduler = schedulerFactory.getScheduler();\n\t\t}\n\t\tcatch(SchedulerException se)\n\t\t{\n\t\t\tthrow new EXistException(\"Unable to create Scheduler\", se);\n\t\t}\n\t}","commit_id":"5a2ee0675c7d7de9757db5c73ef34c0cf2359d5e","url":"https://github.com/eXist-db/exist"},{"original_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test suite for org.exist.xmldb\");\n\t\t//$JUnit-BEGIN$\n\t\tsuite.addTest(new TestSuite(CreateCollectionsTest.class));\n\t\tsuite.addTest(new TestSuite(ResourceTest.class));\n        suite.addTest(new TestSuite(BinaryResourceUpdateTest.class));\n//\t\tsuite.addTest(new TestSuite(ResourceSetTest.class));\n\t\tsuite.addTest(new TestSuite(TestEXistXMLSerialize.class));\n\t\tsuite.addTest(new TestSuite(CopyMoveTest.class));\n        suite.addTest(new TestSuite(ContentAsDOMTest.class));\n//        suite.addTest(new TestSuite(MultiDBTest.class));\n        suite.addTestSuite(XmldbURITest.class);\n        suite.addTestSuite(CollectionConfigurationTest.class);\n        suite.addTestSuite(CollectionTest.class);\n\t\t//$JUnit-END$\n\t\treturn suite;\n\t}","id":80281,"modified_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test suite for org.exist.xmldb\");\n\t\t//$JUnit-BEGIN$\n\t\tsuite.addTest(new TestSuite(CreateCollectionsTest.class));\n\t\tsuite.addTest(new TestSuite(ResourceTest.class));\n        suite.addTest(new TestSuite(BinaryResourceUpdateTest.class));\n//\t\tsuite.addTest(new TestSuite(ResourceSetTest.class));\n\t\tsuite.addTest(new TestSuite(TestEXistXMLSerialize.class));\n\t\tsuite.addTest(new TestSuite(CopyMoveTest.class));\n        suite.addTest(new TestSuite(ContentAsDOMTest.class));\n        suite.addTestSuite(XmldbURITest.class);\n        suite.addTestSuite(CollectionConfigurationTest.class);\n        suite.addTestSuite(CollectionTest.class);\n        suite.addTest(new TestSuite(MultiDBTest.class));\n        //$JUnit-END$\n\t\treturn suite;\n\t}","commit_id":"5a2ee0675c7d7de9757db5c73ef34c0cf2359d5e","url":"https://github.com/eXist-db/exist"},{"original_method":"public GenericDomValueReference(final PsiReferenceProvider provider, GenericDomValue<T> xmlValue) {\n    super(provider);\n    myGenericValue = xmlValue;\n    final XmlTag tag = xmlValue.getXmlTag();\n    assert tag != null;\n    myValueElement = DomUtil.getValueElement(xmlValue);\n    myContextElement = xmlValue instanceof GenericAttributeValue ? myValueElement : tag;\n    final String text = myValueElement.getText();\n    TextRange range = getTextRange(text);\n    if (xmlValue instanceof GenericAttributeValue) {\n      range = new TextRange(range.getStartOffset() + (text.startsWith(\"\\\"\") ? 1 : 0),\n                            range.getEndOffset() - (text.endsWith(\"\\\"\") ? 1 : 0));\n    }\n    myTextRange = range.shiftRight(myValueElement.getTextRange().getStartOffset() - myContextElement.getTextRange().getStartOffset());\n  }","id":80282,"modified_method":"public GenericDomValueReference(final PsiReferenceProvider provider, GenericDomValue<T> xmlValue) {\n    super(provider);\n    myGenericValue = xmlValue;\n    final XmlTag tag = xmlValue.getXmlTag();\n    assert tag != null;\n    myValueElement = xmlValue instanceof GenericAttributeValue ? ((GenericAttributeValue)xmlValue).getXmlAttributeValue() : tag; //DomUtil.getValueElement(xmlValue);\n    myContextElement = xmlValue instanceof GenericAttributeValue ? myValueElement : tag;\n    final String text = myValueElement.getText();\n    TextRange range = getTextRange(text);\n    if (xmlValue instanceof GenericAttributeValue) {\n      range = new TextRange(range.getStartOffset() + (text.startsWith(\"\\\"\") ? 1 : 0),\n                            range.getEndOffset() - (text.endsWith(\"\\\"\") ? 1 : 0));\n    }\n    myTextRange = range.shiftRight(myValueElement.getTextRange().getStartOffset() - myContextElement.getTextRange().getStartOffset());\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiReference[] createReference(DomElement element) {\n    if (!(element instanceof GenericDomValue)) return null;\n\n    PsiElement psiElement;\n    if (element instanceof GenericAttributeValue) {\n      psiElement = ((GenericAttributeValue)element).getXmlAttributeValue();\n      if (psiElement == null) return null;\n    }\n    else {\n      if (element.getXmlTag().getValue().getTextElements().length == 0) return null;\n      psiElement = element.getXmlElement();\n    }\n\n    Converter converter = ((GenericDomValue)element).getConverter();\n    if (converter instanceof PsiReferenceConverter) {\n      return ((PsiReferenceConverter)converter).createReferences(psiElement, false);\n    }\n\n    GenericDomValue domElement = (GenericDomValue)element;\n    final Class clazz = DomUtil.getGenericValueParameter(domElement.getDomElementType());\n    if (PsiType.class.isAssignableFrom(clazz)) {\n      return new PsiReference[]{new PsiTypeReference(this, (GenericDomValue<PsiType>)domElement)};\n    }\n    if (PsiClass.class.isAssignableFrom(clazz)) {\n      JavaClassReferenceProvider provider = new JavaClassReferenceProvider();\n      return provider.getReferencesByElement(psiElement);\n//      return new PsiReference[] {new PsiClassReference(this, (GenericDomValue<PsiClass>)domElement)};\n    }\n    if (Integer.class.isAssignableFrom(clazz)) {\n      return new PsiReference[]{new GenericDomValueReference(this, domElement) {\n        public Object[] getVariants() {\n          return new Object[]{\"239\", \"42\"};\n        }\n      }};\n    }\n    if (String.class.isAssignableFrom(clazz)) {\n      return null;\n    }\n    PsiReferenceFactory provider = myProviders.get(clazz);\n    if (provider != null) {\n      return provider.getReferencesByElement(psiElement);\n    }\n\n    return new PsiReference[]{new GenericDomValueReference(this, domElement)};\n  }","id":80283,"modified_method":"@NotNull\n  private PsiReference[] createReference(DomElement element) {\n    if (!(element instanceof GenericDomValue)) return PsiReference.EMPTY_ARRAY;\n\n    PsiElement psiElement;\n    if (element instanceof GenericAttributeValue) {\n      psiElement = ((GenericAttributeValue)element).getXmlAttributeValue();\n      if (psiElement == null) return PsiReference.EMPTY_ARRAY;\n    }\n    else {\n      if (element.getXmlTag().getValue().getTextElements().length == 0) return PsiReference.EMPTY_ARRAY;\n      psiElement = element.getXmlElement();\n    }\n\n    Converter converter = ((GenericDomValue)element).getConverter();\n    if (converter instanceof PsiReferenceConverter) {\n      return ((PsiReferenceConverter)converter).createReferences(psiElement, false);\n    }\n\n    GenericDomValue domElement = (GenericDomValue)element;\n    final Class clazz = DomUtil.getGenericValueParameter(domElement.getDomElementType());\n    if (PsiType.class.isAssignableFrom(clazz)) {\n      return new PsiReference[]{new PsiTypeReference(this, (GenericDomValue<PsiType>)domElement)};\n    }\n    if (PsiClass.class.isAssignableFrom(clazz)) {\n      JavaClassReferenceProvider provider = new JavaClassReferenceProvider();\n      return provider.getReferencesByElement(psiElement);\n//      return new PsiReference[] {new PsiClassReference(this, (GenericDomValue<PsiClass>)domElement)};\n    }\n    if (Integer.class.isAssignableFrom(clazz)) {\n      return new PsiReference[]{new GenericDomValueReference(this, domElement) {\n        public Object[] getVariants() {\n          return new Object[]{\"239\", \"42\"};\n        }\n      }};\n    }\n    if (String.class.isAssignableFrom(clazz)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    PsiReferenceFactory provider = myProviders.get(clazz);\n    if (provider != null) {\n      return provider.getReferencesByElement(psiElement);\n    }\n\n    return new PsiReference[]{new GenericDomValueReference(this, domElement)};\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement psiElement) {\n    if (!(psiElement instanceof XmlTag || psiElement instanceof XmlAttributeValue)) return GenericReference.EMPTY_ARRAY;\n    PsiElement originalElement = psiElement.getUserData(PsiUtil.ORIGINAL_KEY);\n    if (originalElement != null) {\n      psiElement = originalElement;\n    }\n\n    final XmlTag tag = PsiTreeUtil.getParentOfType(psiElement, XmlTag.class, false);\n\n    final DomElement domElement = DomManager.getDomManager(psiElement.getManager().getProject()).getDomElement(tag);\n    if (domElement == null) return GenericReference.EMPTY_ARRAY;\n\n    GenericDomValue nameElement = domElement.getGenericInfo().getNameDomElement(domElement);\n    if (nameElement != null && nameElement.getValue() instanceof String && DomUtil.getValueElement(nameElement) == psiElement) {\n      return new PsiReference[]{XmlReference.createSelfReference((XmlElement)psiElement)};\n    }\n\n    if (psiElement instanceof XmlAttributeValue) {\n      final XmlAttributeValue value = (XmlAttributeValue)psiElement;\n      final PsiElement parent = value.getParent();\n      if (parent instanceof XmlAttribute) {\n        final String name = ((XmlAttribute)parent).getLocalName();\n        final DomAttributeChildDescription childDescription = domElement.getGenericInfo().getAttributeChildDescription(name);\n        if (childDescription != null) {\n          final PsiReference[] reference = createReference(childDescription.getValues(domElement).get(0));\n          if (reference != null) {\n            return reference;\n          }\n        }\n      }\n    }\n    else {\n      final PsiReference[] reference = createReference(domElement);\n      if (reference != null) {\n        return reference;\n      }\n    }\n\n    return GenericReference.EMPTY_ARRAY;\n  }","id":80284,"modified_method":"@NotNull\n  public PsiReference[] getReferencesByElement(PsiElement psiElement) {\n    if (!(psiElement instanceof XmlTag || psiElement instanceof XmlAttributeValue)) return GenericReference.EMPTY_ARRAY;\n    PsiElement originalElement = psiElement.getUserData(PsiUtil.ORIGINAL_KEY);\n    if (originalElement != null) {\n      psiElement = originalElement;\n    }\n\n    final XmlTag tag = PsiTreeUtil.getParentOfType(psiElement, XmlTag.class, false);\n\n    final DomElement domElement = DomManager.getDomManager(psiElement.getManager().getProject()).getDomElement(tag);\n    if (domElement == null) return GenericReference.EMPTY_ARRAY;\n\n    PsiReference[] reference = PsiReference.EMPTY_ARRAY;\n\n\n    if (psiElement instanceof XmlAttributeValue) {\n      final XmlAttributeValue value = (XmlAttributeValue)psiElement;\n      final PsiElement parent = value.getParent();\n      if (parent instanceof XmlAttribute) {\n        final String name = ((XmlAttribute)parent).getLocalName();\n        final DomAttributeChildDescription childDescription = domElement.getGenericInfo().getAttributeChildDescription(name);\n        if (childDescription != null) {\n          reference = createReference(childDescription.getValues(domElement).get(0));\n        }\n      }\n    }\n    else {\n      reference = createReference(domElement);\n    }\n\n    DomElement parent = (domElement instanceof GenericDomValue) ? domElement.getParent() : domElement;\n    GenericDomValue nameElement = parent.getGenericInfo().getNameDomElement(parent);\n    if (nameElement != null && nameElement.getValue() instanceof String) {\n      final XmlElement valueElement = DomUtil.getValueElement(nameElement);\n      if (valueElement == psiElement || nameElement.getXmlTag() == psiElement) {\n        PsiReference selfReference = XmlReference.createSelfReference((XmlElement)psiElement, valueElement);\n//      return new PsiReference[] {selfReference};\n        reference = ArrayUtil.append(reference, selfReference);\n      }\n    }\n\n    return reference;\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canFindUsagesFor(PsiElement element) {\n    return element instanceof XmlElementDecl || element instanceof XmlAttributeDecl || element instanceof XmlEntityDecl ||\n           element instanceof XmlTag || element instanceof XmlAttributeValue || (PsiUtil.isInJspFile(element) && element instanceof PsiFile);\n  }","id":80285,"modified_method":"public boolean canFindUsagesFor(PsiElement element) {\n    return element instanceof XmlElementDecl ||\n           element instanceof XmlAttributeDecl ||\n           element instanceof XmlEntityDecl ||\n           element instanceof XmlTag ||\n           element instanceof XmlAttributeValue ||\n           element instanceof XmlText ||\n           (PsiUtil.isInJspFile(element) && element instanceof PsiFile);\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getDescriptiveName(PsiElement element) {\n    return ((PsiNamedElement)element).getName();\n  }","id":80286,"modified_method":"@NotNull\n  public String getDescriptiveName(PsiElement element) {\n    if (element instanceof PsiNamedElement) {\n      return ((PsiNamedElement)element).getName();\n    } else {\n      return element.getText();\n    }\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getNodeText(PsiElement element, boolean useFullName) {\n    return ((PsiNamedElement)element).getName();\n  }","id":80287,"modified_method":"@NotNull\n  public String getNodeText(PsiElement element, boolean useFullName) {\n    if (element instanceof PsiNamedElement) {\n      return ((PsiNamedElement)element).getName();\n    } else {\n      return element.getText();\n    }\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getType(PsiElement element) {\n    if (element instanceof XmlElementDecl || element instanceof XmlTag) {\n      return LangBundle.message(\"xml.terms.tag\");\n    } else if (element instanceof XmlAttributeDecl) {\n      return LangBundle.message(\"xml.terms.attribute\");\n    } else if (element instanceof XmlAttributeValue) {\n      return LangBundle.message(\"xml.terms.attribute.value\");\n    } else if (element instanceof XmlEntityDecl) {\n      return LangBundle.message(\"xml.terms.entity\");\n    }\n\n    return null;\n  }","id":80288,"modified_method":"@NotNull\n  public String getType(PsiElement element) {\n    if (element instanceof XmlElementDecl || element instanceof XmlTag) {\n      return LangBundle.message(\"xml.terms.tag\");\n    } else if (element instanceof XmlAttributeDecl) {\n      return LangBundle.message(\"xml.terms.attribute\");\n    } else if (element instanceof XmlAttributeValue) {\n      return LangBundle.message(\"xml.terms.attribute.value\");\n    } else if (element instanceof XmlEntityDecl) {\n      return LangBundle.message(\"xml.terms.entity\");\n    } else if (element instanceof XmlText) {\n      return \"\";\n    }\n\n    return null;\n  }","commit_id":"c970789a08b83a100f675952c6f7585b54ae9ad4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Iterable<StripedLockIntObjectConcurrentHashMap.IntEntry<V>> entries() {\n    final Iterator<StripedLockIntObjectConcurrentHashMap.IntEntry<IntReference<V>>> entryIterator = myMap.entries().iterator();\n    return new Iterable<StripedLockIntObjectConcurrentHashMap.IntEntry<V>>() {\n      @Override\n      public Iterator<StripedLockIntObjectConcurrentHashMap.IntEntry<V>> iterator() {\n        return new Iterator<StripedLockIntObjectConcurrentHashMap.IntEntry<V>>() {\n          StripedLockIntObjectConcurrentHashMap.IntEntry<V> next = nextAliveEntry();\n          @Override\n          public boolean hasNext() {\n            return next != null;\n          }\n\n          @Override\n          public StripedLockIntObjectConcurrentHashMap.IntEntry<V> next() {\n            StripedLockIntObjectConcurrentHashMap.IntEntry<V> result = next;\n            next = nextAliveEntry();\n            return result;\n          }\n\n          private StripedLockIntObjectConcurrentHashMap.IntEntry<V> nextAliveEntry() {\n            while (entryIterator.hasNext()) {\n              StripedLockIntObjectConcurrentHashMap.IntEntry<IntReference<V>> entry = entryIterator.next();\n              final V v = entry.getValue().get();\n              if (v == null) {\n                continue;\n              }\n              final int key = entry.getKey();\n              return new StripedLockIntObjectConcurrentHashMap.IntEntry<V>() {\n                @Override\n                public int getKey() {\n                  return key;\n                }\n\n                @NotNull\n                @Override\n                public V getValue() {\n                  return v;\n                }\n              };\n            }\n            return null;\n          }\n\n          @Override\n          public void remove() {\n            throw new IncorrectOperationException(\"not implemented\");\n          }\n        };\n      }\n    };\n  }","id":80289,"modified_method":"@NotNull\n  @Override\n  public Iterable<StripedLockIntObjectConcurrentHashMap.IntEntry<V>> entries() {\n    final Iterator<StripedLockIntObjectConcurrentHashMap.IntEntry<IntReference<V>>> entryIterator = myMap.entries().iterator();\n    return new Iterable<StripedLockIntObjectConcurrentHashMap.IntEntry<V>>() {\n      @Override\n      public Iterator<StripedLockIntObjectConcurrentHashMap.IntEntry<V>> iterator() {\n        return new Iterator<StripedLockIntObjectConcurrentHashMap.IntEntry<V>>() {\n          StripedLockIntObjectConcurrentHashMap.IntEntry<V> next = nextAliveEntry();\n          @Override\n          public boolean hasNext() {\n            return next != null;\n          }\n\n          @Override\n          public StripedLockIntObjectConcurrentHashMap.IntEntry<V> next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StripedLockIntObjectConcurrentHashMap.IntEntry<V> result = next;\n            next = nextAliveEntry();\n            return result;\n          }\n\n          private StripedLockIntObjectConcurrentHashMap.IntEntry<V> nextAliveEntry() {\n            while (entryIterator.hasNext()) {\n              StripedLockIntObjectConcurrentHashMap.IntEntry<IntReference<V>> entry = entryIterator.next();\n              final V v = entry.getValue().get();\n              if (v == null) {\n                continue;\n              }\n              final int key = entry.getKey();\n              return new StripedLockIntObjectConcurrentHashMap.IntEntry<V>() {\n                @Override\n                public int getKey() {\n                  return key;\n                }\n\n                @NotNull\n                @Override\n                public V getValue() {\n                  return v;\n                }\n              };\n            }\n            return null;\n          }\n\n          @Override\n          public void remove() {\n            throw new IncorrectOperationException(\"not implemented\");\n          }\n        };\n      }\n    };\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public V cacheOrGet(int key, @NotNull V value) {\n    processQueue();\n    IntReference<V> ref = myMap.putIfAbsent(key, createReference(key, value, myQueue));\n    V v = ref == null ? null : ref.get();\n    return v == null ? value : v;\n  }","id":80290,"modified_method":"@NotNull\n  @Override\n  public V cacheOrGet(int key, @NotNull V value) {\n    processQueue();\n    IntReference<V> newRef = createReference(key, value, myQueue);\n    while (true) {\n      IntReference<V> ref = myMap.putIfAbsent(key, newRef);\n      if (ref == null) return value; // there were no previous value\n      V old = ref.get();\n      if (old != null) return old;\n\n      // old value has been gced; need to overwrite\n      boolean replaced = myMap.replace(key, ref, newRef);\n      if (replaced) {\n        return value;\n      }\n    }\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void processQueue() {\n    while(true){\n      IntReference ref = (IntReference)myQueue.poll();\n      if (ref == null) {\n        return;\n      }\n      int key = ref.getKey();\n      myMap.remove(key);\n    }\n  }","id":80291,"modified_method":"private void processQueue() {\n    while (true) {\n      @SuppressWarnings(\"unchecked\")\n      IntReference<V> ref = (IntReference)myQueue.poll();\n      if (ref == null) {\n        return;\n      }\n      int key = ref.getKey();\n      myMap.remove(key, ref);\n    }\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object o) {\n      if (this == o) return true;\n      if (!(o instanceof Key)) return false;\n      Object t = get();\n      Object u = ((Key)o).get();\n      if (t == null || u == null) return false;\n      return t == u || t.equals(u);\n    }","id":80292,"modified_method":"public boolean equals(Object o) {\n      if (this == o) return true;\n      if (!(o instanceof ConcurrentRefHashMap.Key)) return false;\n      Object t = get();\n      Object u = ((ConcurrentRefHashMap.Key)o).get();\n      if (t == null || u == null) return false;\n      if (t == u) return true;\n      return t.equals(u);\n    }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentSoftHashMap(final TObjectHashingStrategy<K> hashingStrategy) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(new TObjectHashingStrategy<Key<K>>() {\n      @Override\n      public int computeHashCode(final Key<K> object) {\n        return hashingStrategy.computeHashCode(object.get());\n      }\n\n      @Override\n      public boolean equals(final Key<K> o1, final Key<K> o2) {\n        return hashingStrategy.equals(o1.get(), o2.get());\n      }\n    } );\n  }","id":80293,"modified_method":"public ConcurrentSoftHashMap(TObjectHashingStrategy<K> hashingStrategy) {\n    super(hashingStrategy);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentSoftHashMap(int initialCapacity, float loadFactor) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(initialCapacity, loadFactor, 4);\n  }","id":80294,"modified_method":"public ConcurrentSoftHashMap(int initialCapacity, float loadFactor) {\n    super(initialCapacity, loadFactor);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentSoftHashMap(int initialCapacity) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(initialCapacity);\n  }","id":80295,"modified_method":"public ConcurrentSoftHashMap(int initialCapacity) {\n    super(initialCapacity);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentSoftHashMap(@NotNull Map<? extends K, ? extends V> t) {\n    this(Math.max(2 * t.size(), 11), 0.75f);\n    putAll(t);\n  }","id":80296,"modified_method":"public ConcurrentSoftHashMap(Map<? extends K, ? extends V> t) {\n    super(t);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentSoftHashMap() {\n    myMap = new ConcurrentHashMap<Key<K>, V>();\n  }","id":80297,"modified_method":"public ConcurrentSoftHashMap() {\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SoftKey(K k, ReferenceQueue<? super K> q) {\n      super(k, q);\n      myHash = k.hashCode();\n    }","id":80298,"modified_method":"private SoftKey(@NotNull K k, V v, ReferenceQueue<K> q) {\n      super(k, q);\n      value = v;\n      myHash = k.hashCode();\n    }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n      V v = get();\n      return obj instanceof MyRef && ((MyRef)obj).hash == hash && v != null && v.equals(((MyRef)obj).get());\n    }","id":80299,"modified_method":"@Override\n    public boolean equals(Object obj) {\n      V v = get();\n      if (!(obj instanceof MyRef)) {\n        return false;\n      }\n      MyRef other = (MyRef)obj;\n      return other.hash == hash && key == other.getKey() && Comparing.equal(v, other.get());\n    }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private WeakKey(K k, ReferenceQueue<K> q) {\n      super(k, q);\n      myHash = k.hashCode();\n    }","id":80300,"modified_method":"private WeakKey(@NotNull K k, V v, ReferenceQueue<K> q) {\n      super(k, q);\n      value = v;\n      myHash = k.hashCode();\n    }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakHashMap(Map<? extends K, ? extends V> t) {\n    this(Math.max(2 * t.size(), 11), 0.75f);\n    putAll(t);\n  }","id":80301,"modified_method":"public ConcurrentWeakHashMap(Map<? extends K, ? extends V> t) {\n    super(t);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakHashMap() {\n    myMap = new ConcurrentHashMap<Key<K>, V>();\n  }","id":80302,"modified_method":"public ConcurrentWeakHashMap() {\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakHashMap(final TObjectHashingStrategy<K> hashingStrategy) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(new TObjectHashingStrategy<Key<K>>() {\n      @Override\n      public int computeHashCode(final Key<K> object) {\n        return hashingStrategy.computeHashCode(object.get());\n      }\n\n      @Override\n      public boolean equals(final Key<K> o1, final Key<K> o2) {\n        return hashingStrategy.equals(o1.get(), o2.get());\n      }\n    } );\n  }","id":80303,"modified_method":"public ConcurrentWeakHashMap(TObjectHashingStrategy<K> hashingStrategy) {\n    super(hashingStrategy);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, TObjectHashingStrategy<Key<K>> hashingStrategy) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(initialCapacity, loadFactor, concurrencyLevel, hashingStrategy);\n  }","id":80304,"modified_method":"public ConcurrentWeakHashMap(int initialCapacity,\n                               float loadFactor,\n                               int concurrencyLevel,\n                               TObjectHashingStrategy<Key<K, V>> hashingStrategy) {\n    super(initialCapacity, loadFactor, concurrencyLevel, hashingStrategy);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakHashMap(int initialCapacity, float loadFactor) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(initialCapacity, loadFactor, 4);\n  }","id":80305,"modified_method":"public ConcurrentWeakHashMap(int initialCapacity, float loadFactor) {\n    super(initialCapacity, loadFactor);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakHashMap(int initialCapacity) {\n    myMap = new ConcurrentHashMap<Key<K>, V>(initialCapacity);\n  }","id":80306,"modified_method":"public ConcurrentWeakHashMap(int initialCapacity) {\n    super(initialCapacity);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MyReference<K, V> createRef(K key, V value) {\n    return new MyReference<K,V>(key, value, myQueue);\n  }","id":80307,"modified_method":"@Override\n  protected MyReference<K, V> createRef(K key, V value) {\n    return new MyWeakReference<K,V>(key, value, myQueue);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakValueHashMap() {\n    myMap = new ConcurrentHashMap<K, MyReference<K,V>>();\n  }","id":80308,"modified_method":"public ConcurrentWeakValueHashMap() {\n    super();\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakValueHashMap(final Map<K, V> map) {\n    this();\n    putAll(map);\n  }","id":80309,"modified_method":"public ConcurrentWeakValueHashMap(Map<K, V> map) {\n    super(map);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConcurrentWeakValueHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {\n    myMap = new ConcurrentHashMap<K, MyReference<K,V>>(initialCapacity, loadFactor, concurrencyLevel);\n  }","id":80310,"modified_method":"public ConcurrentWeakValueHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {\n    super(initialCapacity, loadFactor, concurrencyLevel);\n  }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n      V v = get();\n      return obj instanceof MyRef && ((MyRef)obj).hash == hash && v != null && v.equals(((MyRef)obj).get());\n    }","id":80311,"modified_method":"@Override\n    public boolean equals(Object obj) {\n      V v = get();\n      if (!(obj instanceof MyRef)) {\n        return false;\n      }\n      MyRef other = (MyRef)obj;\n      return other.hash == hash && key == other.getKey() && Comparing.equal(v, other.get());\n    }","commit_id":"b78c7d414f0151881ab21e201b364dccf540858d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getArtifactDaysToKeepStr() {\n        if(artifactDaysToKeep==-1)  return \"\";\n        else                        return String.valueOf(artifactDaysToKeep);\n    }","id":80312,"modified_method":"public String getArtifactDaysToKeepStr() {\n        return toString(artifactDaysToKeep);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"public String getArtifactNumToKeepStr() {\n        if(artifactNumToKeep==-1)   return \"\";\n        else                        return String.valueOf(artifactNumToKeep);\n    }","id":80313,"modified_method":"public String getArtifactNumToKeepStr() {\n        return toString(artifactNumToKeep);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"public int getArtifactDaysToKeep() {\n        return artifactDaysToKeep;\n    }","id":80314,"modified_method":"public int getArtifactDaysToKeep() {\n        return unbox(artifactDaysToKeep);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"public int getArtifactNumToKeep() {\n        return artifactNumToKeep;\n    }","id":80315,"modified_method":"public int getArtifactNumToKeep() {\n        return unbox(artifactNumToKeep);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void perform(Job<?,?> job) throws IOException, InterruptedException {\n        LOGGER.log(FINE,\"Running the log rotation for \"+job.getFullDisplayName());\n\n        // keep the last successful build regardless of the status\n        Run lsb = job.getLastSuccessfulBuild();\n        Run lstb = job.getLastStableBuild();\n\n        if(numToKeep!=-1) {\n            Run[] builds = job.getBuilds().toArray(new Run[0]);\n            for( int i=numToKeep; i<builds.length; i++ ) {\n                Run r = builds[i];\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last stable build\");\n                    continue;\n                }\n                r.delete();\n            }\n        }\n\n        if(daysToKeep!=-1) {\n            Calendar cal = new GregorianCalendar();\n            cal.add(Calendar.DAY_OF_YEAR,-daysToKeep);\n            // copy it to the array because we'll be deleting builds as we go.\n            for( Run r : job.getBuilds().toArray(new Run[0]) ) {\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last stable build\");\n                    continue;\n                }\n                if (!r.getTimestamp().before(cal)) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's still new\");\n                    continue;\n                }\n                r.delete();\n            }\n        }\n\n        if(artifactNumToKeep!=-1) {\n            Run[] builds = job.getBuilds().toArray(new Run[0]);\n            for( int i=artifactNumToKeep; i<builds.length; i++ ) {\n                Run r = builds[i];\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last stable build\");\n                    continue;\n                }\n                r.deleteArtifacts();\n            }\n        }\n\n        if(artifactDaysToKeep!=-1) {\n            Calendar cal = new GregorianCalendar();\n            cal.add(Calendar.DAY_OF_YEAR,-artifactDaysToKeep);\n            // copy it to the array because we'll be deleting builds as we go.\n            for( Run r : job.getBuilds().toArray(new Run[0]) ) {\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last stable build\");\n                    continue;\n                }\n                if (!r.getTimestamp().before(cal)) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's still new\");\n                    continue;\n                }\n                r.deleteArtifacts();\n            }\n        }\n\n    }","id":80316,"modified_method":"public void perform(Job<?,?> job) throws IOException, InterruptedException {\n        LOGGER.log(FINE,\"Running the log rotation for \"+job.getFullDisplayName());\n        \n        // keep the last successful build regardless of the status\n        Run lsb = job.getLastSuccessfulBuild();\n        Run lstb = job.getLastStableBuild();\n\n        if(numToKeep!=-1) {\n            List<? extends Run<?,?>> builds = job.getBuilds();\n            for (Run r : builds.subList(Math.min(builds.size(),numToKeep),builds.size())) {\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last stable build\");\n                    continue;\n                }\n                r.delete();\n            }\n        }\n\n        if(daysToKeep!=-1) {\n            Calendar cal = new GregorianCalendar();\n            cal.add(Calendar.DAY_OF_YEAR,-daysToKeep);\n            // copy it to the array because we'll be deleting builds as we go.\n            for( Run r : job.getBuilds() ) {\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's the last stable build\");\n                    continue;\n                }\n                if (!r.getTimestamp().before(cal)) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not GC-ed because it's still new\");\n                    continue;\n                }\n                r.delete();\n            }\n        }\n\n        if(artifactNumToKeep!=null && artifactNumToKeep!=-1) {\n            List<? extends Run<?,?>> builds = job.getBuilds();\n            for (Run r : builds.subList(Math.min(builds.size(),artifactNumToKeep),builds.size())) {\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last stable build\");\n                    continue;\n                }\n                r.deleteArtifacts();\n            }\n        }\n\n        if(artifactDaysToKeep!=null && artifactDaysToKeep!=-1) {\n            Calendar cal = new GregorianCalendar();\n            cal.add(Calendar.DAY_OF_YEAR,-artifactDaysToKeep);\n            // copy it to the array because we'll be deleting builds as we go.\n            for( Run r : job.getBuilds() ) {\n                if (r.isKeepLog()) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's marked as a keeper\");\n                    continue;\n                }\n                if (r==lsb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last successful build\");\n                    continue;\n                }\n                if (r==lstb) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's the last stable build\");\n                    continue;\n                }\n                if (!r.getTimestamp().before(cal)) {\n                    LOGGER.log(FINER,r.getFullDisplayName()+\" is not purged of artifacts because it's still new\");\n                    continue;\n                }\n                r.deleteArtifacts();\n            }\n        }\n\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * @deprecated since 1.350\n     */\n    public LogRotator(int daysToKeep, int numToKeep) {\n        this(daysToKeep, numToKeep, -1, -1);\n    }","id":80317,"modified_method":"/**\n     * @deprecated since 1.350.\n     *      Use {@link #LogRotator(int, int, int, int)}\n     */\n    public LogRotator(int daysToKeep, int numToKeep) {\n        this(daysToKeep, numToKeep, -1, -1);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"public String getDaysToKeepStr() {\n        if(daysToKeep==-1)  return \"\";\n        else                return String.valueOf(daysToKeep);\n    }","id":80318,"modified_method":"public String getDaysToKeepStr() {\n        return toString(daysToKeep);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"public String getNumToKeepStr() {\n        if(numToKeep==-1)   return \"\";\n        else                return String.valueOf(numToKeep);\n    }","id":80319,"modified_method":"public String getNumToKeepStr() {\n        return toString(numToKeep);\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    protected void tearDown() throws Exception {\n        super.tearDown();\n        LoadStatistics.CLOCK = original;\n    }","id":80320,"modified_method":"@Override\n    protected void tearDown() throws Exception {\n        super.tearDown();\n        LoadStatistics.CLOCK = original;\n        NodeProvisionerInvoker.INITIALDELAY = original*10;\n        NodeProvisionerInvoker.RECURRENCEPERIOD = original;\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        original = LoadStatistics.CLOCK;\n        LoadStatistics.CLOCK = 10; // run x1000 the regular speed to speed up the test\n        super.setUp();\n    }","id":80321,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        original = LoadStatistics.CLOCK;\n        LoadStatistics.CLOCK = 10; // run x1000 the regular speed to speed up the test\n        NodeProvisionerInvoker.INITIALDELAY = 100;\n        NodeProvisionerInvoker.RECURRENCEPERIOD = 10;\n        super.setUp();\n    }","commit_id":"f7edbbab3b80092a177844b0f102e5ef7ea30393","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected InetSocketAddress startServer(ServerSessionFrameListener listener) throws Exception\n    {\n        server = new Server();\n        connector = newSPDYServerConnector(listener);\n        connector.setPort(0);\n        server.addConnector(connector);\n        server.start();\n        return new InetSocketAddress(\"localhost\", connector.getLocalPort());\n    }","id":80322,"modified_method":"protected InetSocketAddress startSPDYServer(ServerSessionFrameListener listener) throws Exception\n    {\n        server = new Server();\n        connector = newSPDYServerConnector(listener);\n        connector.setPort(0);\n        server.addConnector(connector);\n        server.start();\n        return new InetSocketAddress(\"localhost\", connector.getLocalPort());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testConcurrentSynDataReplyData() throws Exception\n    {\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(synInfo.getHeaders(), false));\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteBuffer buffer = ByteBuffer.allocateDirect(dataInfo.getBytesCount());\n                        dataInfo.getBytes(buffer);\n                        Assert.assertTrue(dataInfo.isConsumed());\n                        buffer.flip();\n                        stream.data(new ByteBufferDataInfo(buffer, true));\n                    }\n                };\n            }\n        };\n        final Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        final int iterations = 50;\n        final int count = 50;\n\n        final Headers headers = new Headers();\n        headers.put(\"method\", \"get\");\n        headers.put(\"path\", \"/\");\n        headers.put(\"version\", \"http/1.1\");\n        headers.put(\"host\", \"localhost:8080\");\n        headers.put(\"content-type\", \"application/octet-stream\");\n\n        final CountDownLatch latch = new CountDownLatch(count * iterations);\n        session.addListener(new Session.StreamListener.Adapter()\n        {\n            @Override\n            public void onStreamClosed(Stream stream)\n            {\n                latch.countDown();\n            }\n        });\n\n        List<Callable<Object>> tasks = new ArrayList<>();\n        for (int i = 0; i < count; ++i)\n        {\n            tasks.add(new Callable<Object>()\n            {\n                @Override\n                public Object call() throws Exception\n                {\n                    process(session, SPDY.V2, headers, iterations);\n                    return null;\n                }\n            });\n        }\n\n        ExecutorService threadPool = Executors.newFixedThreadPool(count);\n        List<Future<Object>> futures = threadPool.invokeAll(tasks);\n        for (Future<Object> future : futures)\n            future.get();\n        Assert.assertTrue(latch.await(count * iterations * 100, TimeUnit.MILLISECONDS));\n        threadPool.shutdown();\n    }","id":80323,"modified_method":"@Test\n    public void testConcurrentSynDataReplyData() throws Exception\n    {\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(synInfo.getHeaders(), false));\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteBuffer buffer = ByteBuffer.allocateDirect(dataInfo.getBytesCount());\n                        dataInfo.getBytes(buffer);\n                        Assert.assertTrue(dataInfo.isConsumed());\n                        buffer.flip();\n                        stream.data(new ByteBufferDataInfo(buffer, true));\n                    }\n                };\n            }\n        };\n        final Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        final int iterations = 50;\n        final int count = 50;\n\n        final Headers headers = new Headers();\n        headers.put(\"method\", \"get\");\n        headers.put(\"path\", \"/\");\n        headers.put(\"version\", \"http/1.1\");\n        headers.put(\"host\", \"localhost:8080\");\n        headers.put(\"content-type\", \"application/octet-stream\");\n\n        final CountDownLatch latch = new CountDownLatch(count * iterations);\n        session.addListener(new Session.StreamListener.Adapter()\n        {\n            @Override\n            public void onStreamClosed(Stream stream)\n            {\n                latch.countDown();\n            }\n        });\n\n        List<Callable<Object>> tasks = new ArrayList<>();\n        for (int i = 0; i < count; ++i)\n        {\n            tasks.add(new Callable<Object>()\n            {\n                @Override\n                public Object call() throws Exception\n                {\n                    process(session, SPDY.V2, headers, iterations);\n                    return null;\n                }\n            });\n        }\n\n        ExecutorService threadPool = Executors.newFixedThreadPool(count);\n        List<Future<Object>> futures = threadPool.invokeAll(tasks);\n        for (Future<Object> future : futures)\n            future.get();\n        Assert.assertTrue(latch.await(count * iterations * 100, TimeUnit.MILLISECONDS));\n        threadPool.shutdown();\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSynStreamIgnoredAfterGoAway() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            private final AtomicInteger syns = new AtomicInteger();\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                int synCount = syns.incrementAndGet();\n                if (synCount == 1)\n                {\n                    stream.reply(new ReplyInfo(true));\n                    stream.getSession().goAway(SPDY.V2);\n                }\n                else\n                {\n                    latch.countDown();\n                }\n                return null;\n            }\n        };\n        final AtomicReference<Session> ref = new AtomicReference<>();\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                ref.get().syn(SPDY.V2, new SynInfo(true), null);\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n        ref.set(session);\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertFalse(latch.await(1, TimeUnit.SECONDS));\n    }","id":80324,"modified_method":"@Test\n    public void testSynStreamIgnoredAfterGoAway() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            private final AtomicInteger syns = new AtomicInteger();\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                int synCount = syns.incrementAndGet();\n                if (synCount == 1)\n                {\n                    stream.reply(new ReplyInfo(true));\n                    stream.getSession().goAway(SPDY.V2);\n                }\n                else\n                {\n                    latch.countDown();\n                }\n                return null;\n            }\n        };\n        final AtomicReference<Session> ref = new AtomicReference<>();\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                ref.get().syn(SPDY.V2, new SynInfo(true), null);\n            }\n        };\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), clientSessionFrameListener);\n        ref.set(session);\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertFalse(latch.await(1, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testServerReceivesGoAwayOnClientGoAway() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                return null;\n            }\n\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                Assert.assertEquals(0, goAwayInfo.getLastStreamId());\n                Assert.assertSame(SessionStatus.OK, goAwayInfo.getSessionStatus());\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        session.goAway(SPDY.V2);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":80325,"modified_method":"@Test\n    public void testServerReceivesGoAwayOnClientGoAway() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                return null;\n            }\n\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                Assert.assertEquals(0, goAwayInfo.getLastStreamId());\n                Assert.assertSame(SessionStatus.OK, goAwayInfo.getSessionStatus());\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        session.goAway(SPDY.V2);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testDataNotProcessedAfterGoAway() throws Exception\n    {\n        final CountDownLatch closeLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            private AtomicInteger syns = new AtomicInteger();\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                int synCount = syns.incrementAndGet();\n                if (synCount == 1)\n                {\n                    return null;\n                }\n                else\n                {\n                    stream.getSession().goAway(SPDY.V2);\n                    closeLatch.countDown();\n                    return new Stream.FrameListener.Adapter()\n                    {\n                        @Override\n                        public void onData(Stream stream, DataInfo dataInfo)\n                        {\n                            dataLatch.countDown();\n                        }\n                    };\n                }\n            }\n        };\n        final AtomicReference<GoAwayInfo> goAwayRef = new AtomicReference<>();\n        final CountDownLatch goAwayLatch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                goAwayRef.set(goAwayInfo);\n                goAwayLatch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        // First stream is processed ok\n        final CountDownLatch reply1Latch = new CountDownLatch(1);\n        Stream stream1 = session.syn(SPDY.V2, new SynInfo(true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                reply1Latch.countDown();\n            }\n        });\n        Assert.assertTrue(reply1Latch.await(5, TimeUnit.SECONDS));\n\n        // Second stream is closed in the middle\n        Stream stream2 = session.syn(SPDY.V2, new SynInfo(false), null);\n        Assert.assertTrue(closeLatch.await(5, TimeUnit.SECONDS));\n\n        // There is a race between the data we want to send, and the client\n        // closing the connection because the server closed it after the\n        // go_away, so we guard with a try/catch to have the test pass cleanly\n        try\n        {\n            stream2.data(new StringDataInfo(\"foo\", true));\n            Assert.assertFalse(dataLatch.await(1, TimeUnit.SECONDS));\n        }\n        catch (SPDYException x)\n        {\n            Assert.assertThat(x.getCause(), instanceOf(ClosedChannelException.class));\n        }\n\n        // Be sure the last good stream is the first\n        Assert.assertTrue(goAwayLatch.await(5, TimeUnit.SECONDS));\n        GoAwayInfo goAway = goAwayRef.get();\n        Assert.assertNotNull(goAway);\n        Assert.assertEquals(stream1.getId(), goAway.getLastStreamId());\n    }","id":80326,"modified_method":"@Test\n    public void testDataNotProcessedAfterGoAway() throws Exception\n    {\n        final CountDownLatch closeLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            private AtomicInteger syns = new AtomicInteger();\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                int synCount = syns.incrementAndGet();\n                if (synCount == 1)\n                {\n                    return null;\n                }\n                else\n                {\n                    stream.getSession().goAway(SPDY.V2);\n                    closeLatch.countDown();\n                    return new Stream.FrameListener.Adapter()\n                    {\n                        @Override\n                        public void onData(Stream stream, DataInfo dataInfo)\n                        {\n                            dataLatch.countDown();\n                        }\n                    };\n                }\n            }\n        };\n        final AtomicReference<GoAwayInfo> goAwayRef = new AtomicReference<>();\n        final CountDownLatch goAwayLatch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                goAwayRef.set(goAwayInfo);\n                goAwayLatch.countDown();\n            }\n        };\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        // First stream is processed ok\n        final CountDownLatch reply1Latch = new CountDownLatch(1);\n        Stream stream1 = session.syn(SPDY.V2, new SynInfo(true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                reply1Latch.countDown();\n            }\n        });\n        Assert.assertTrue(reply1Latch.await(5, TimeUnit.SECONDS));\n\n        // Second stream is closed in the middle\n        Stream stream2 = session.syn(SPDY.V2, new SynInfo(false), null);\n        Assert.assertTrue(closeLatch.await(5, TimeUnit.SECONDS));\n\n        // There is a race between the data we want to send, and the client\n        // closing the connection because the server closed it after the\n        // go_away, so we guard with a try/catch to have the test pass cleanly\n        try\n        {\n            stream2.data(new StringDataInfo(\"foo\", true));\n            Assert.assertFalse(dataLatch.await(1, TimeUnit.SECONDS));\n        }\n        catch (SPDYException x)\n        {\n            Assert.assertThat(x.getCause(), instanceOf(ClosedChannelException.class));\n        }\n\n        // Be sure the last good stream is the first\n        Assert.assertTrue(goAwayLatch.await(5, TimeUnit.SECONDS));\n        GoAwayInfo goAway = goAwayRef.get();\n        Assert.assertNotNull(goAway);\n        Assert.assertEquals(stream1.getId(), goAway.getLastStreamId());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testClientReceivesGoAwayOnServerGoAway() throws Exception\n    {\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                stream.getSession().goAway(SPDY.V2);\n                return null;\n            }\n        };\n        final AtomicReference<GoAwayInfo> ref = new AtomicReference<>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                ref.set(goAwayInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Stream stream1 = session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n        GoAwayInfo goAwayInfo = ref.get();\n        Assert.assertNotNull(goAwayInfo);\n        Assert.assertEquals(stream1.getId(), goAwayInfo.getLastStreamId());\n        Assert.assertSame(SessionStatus.OK, goAwayInfo.getSessionStatus());\n    }","id":80327,"modified_method":"@Test\n    public void testClientReceivesGoAwayOnServerGoAway() throws Exception\n    {\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                stream.getSession().goAway(SPDY.V2);\n                return null;\n            }\n        };\n        final AtomicReference<GoAwayInfo> ref = new AtomicReference<>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                ref.set(goAwayInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Stream stream1 = session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n        GoAwayInfo goAwayInfo = ref.get();\n        Assert.assertNotNull(goAwayInfo);\n        Assert.assertEquals(stream1.getId(), goAwayInfo.getLastStreamId());\n        Assert.assertSame(SessionStatus.OK, goAwayInfo.getSessionStatus());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testPOSTWithParametersInTwoFramesOneRead() throws Exception\n    {\n        final String path = \"/foo\";\n        final String data1 = \"a=1&\";\n        final String data2 = \"b=2\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"POST\", httpRequest.getMethod());\n                Assert.assertEquals(\"1\", httpRequest.getParameter(\"a\"));\n                Assert.assertEquals(\"2\", httpRequest.getParameter(\"b\"));\n                handlerLatch.countDown();\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"content-type\", \"application/x-www-form-urlencoded\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        // Send the data frames consecutively, so the server reads both frames in one read\n        stream.data(new StringDataInfo(data1, false));\n        stream.data(new StringDataInfo(data2, true));\n\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","id":80328,"modified_method":"@Test\n    public void testPOSTWithParametersInTwoFramesOneRead() throws Exception\n    {\n        final String path = \"/foo\";\n        final String data1 = \"a=1&\";\n        final String data2 = \"b=2\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"POST\", httpRequest.getMethod());\n                Assert.assertEquals(\"1\", httpRequest.getParameter(\"a\"));\n                Assert.assertEquals(\"2\", httpRequest.getParameter(\"b\"));\n                handlerLatch.countDown();\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"content-type\", \"application/x-www-form-urlencoded\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        // Send the data frames consecutively, so the server reads both frames in one read\n        stream.data(new StringDataInfo(data1, false));\n        stream.data(new StringDataInfo(data2, true));\n\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Ignore\n    @Test\n    public void test100Continue() throws Exception\n    {\n        final String data = \"data\";\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException\n            {\n                request.setHandled(true);\n                httpResponse.sendError(100);\n\n                BufferedReader reader = httpRequest.getReader();\n                String read = reader.readLine();\n                Assert.assertEquals(data, read);\n                Assert.assertNull(reader.readLine());\n\n                httpResponse.setStatus(200);\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + \"/100\");\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"expect\", \"100-continue\");\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.getHeaders().get(\"status\").value().contains(\"100\"));\n                replyLatch.countDown();\n\n                // Now send the data\n                stream.data(new StringDataInfo(data, true));\n            }\n        });\n\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n\n        Thread.sleep(500_000);\n    }","id":80329,"modified_method":"@Ignore\n    @Test\n    public void test100Continue() throws Exception\n    {\n        final String data = \"data\";\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException\n            {\n                request.setHandled(true);\n                httpResponse.sendError(100);\n\n                BufferedReader reader = httpRequest.getReader();\n                String read = reader.readLine();\n                Assert.assertEquals(data, read);\n                Assert.assertNull(reader.readLine());\n\n                httpResponse.setStatus(200);\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + \"/100\");\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"expect\", \"100-continue\");\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.getHeaders().get(\"status\").value().contains(\"100\"));\n                replyLatch.countDown();\n\n                // Now send the data\n                stream.data(new StringDataInfo(data, true));\n            }\n        });\n\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n\n        Thread.sleep(500_000);\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testPOSTWithParameters() throws Exception\n    {\n        final String path = \"/foo\";\n        final String data = \"a=1&b=2\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"POST\", httpRequest.getMethod());\n                Assert.assertEquals(\"1\", httpRequest.getParameter(\"a\"));\n                Assert.assertEquals(\"2\", httpRequest.getParameter(\"b\"));\n                handlerLatch.countDown();\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"content-type\", \"application/x-www-form-urlencoded\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        stream.data(new StringDataInfo(data, true));\n\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","id":80330,"modified_method":"@Test\n    public void testPOSTWithParameters() throws Exception\n    {\n        final String path = \"/foo\";\n        final String data = \"a=1&b=2\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"POST\", httpRequest.getMethod());\n                Assert.assertEquals(\"1\", httpRequest.getParameter(\"a\"));\n                Assert.assertEquals(\"2\", httpRequest.getParameter(\"b\"));\n                handlerLatch.countDown();\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"content-type\", \"application/x-www-form-urlencoded\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        stream.data(new StringDataInfo(data, true));\n\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSimpleGET() throws Exception\n    {\n        final String path = \"/foo\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"GET\", httpRequest.getMethod());\n                Assert.assertEquals(path, target);\n                Assert.assertEquals(path, httpRequest.getRequestURI());\n                Assert.assertEquals(\"localhost:\" + connector.getLocalPort(), httpRequest.getHeader(\"host\"));\n                handlerLatch.countDown();\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","id":80331,"modified_method":"@Test\n    public void testSimpleGET() throws Exception\n    {\n        final String path = \"/foo\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"GET\", httpRequest.getMethod());\n                Assert.assertEquals(path, target);\n                Assert.assertEquals(path, httpRequest.getRequestURI());\n                Assert.assertEquals(\"localhost:\" + connector.getLocalPort(), httpRequest.getHeader(\"host\"));\n                handlerLatch.countDown();\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testHEAD() throws Exception\n    {\n        final String path = \"/foo\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"HEAD\", httpRequest.getMethod());\n                Assert.assertEquals(path, target);\n                Assert.assertEquals(path, httpRequest.getRequestURI());\n                handlerLatch.countDown();\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"HEAD\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","id":80332,"modified_method":"@Test\n    public void testHEAD() throws Exception\n    {\n        final String path = \"/foo\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"HEAD\", httpRequest.getMethod());\n                Assert.assertEquals(path, target);\n                Assert.assertEquals(path, httpRequest.getRequestURI());\n                handlerLatch.countDown();\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"HEAD\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testPOSTWithParametersInTwoFramesTwoReads() throws Exception\n    {\n        final String path = \"/foo\";\n        final String data1 = \"a=1&\";\n        final String data2 = \"b=2\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"POST\", httpRequest.getMethod());\n                Assert.assertEquals(\"1\", httpRequest.getParameter(\"a\"));\n                Assert.assertEquals(\"2\", httpRequest.getParameter(\"b\"));\n                handlerLatch.countDown();\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"content-type\", \"application/x-www-form-urlencoded\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        // Sleep between the data frames so that they will be read in 2 reads\n        stream.data(new StringDataInfo(data1, false));\n        Thread.sleep(1000);\n        stream.data(new StringDataInfo(data2, true));\n\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","id":80333,"modified_method":"@Test\n    public void testPOSTWithParametersInTwoFramesTwoReads() throws Exception\n    {\n        final String path = \"/foo\";\n        final String data1 = \"a=1&\";\n        final String data2 = \"b=2\";\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"POST\", httpRequest.getMethod());\n                Assert.assertEquals(\"1\", httpRequest.getParameter(\"a\"));\n                Assert.assertEquals(\"2\", httpRequest.getParameter(\"b\"));\n                handlerLatch.countDown();\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"POST\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + path);\n        headers.put(\"version\", \"HTTP/1.1\");\n        headers.put(\"content-type\", \"application/x-www-form-urlencoded\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(headers, false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        // Sleep between the data frames so that they will be read in 2 reads\n        stream.data(new StringDataInfo(data1, false));\n        Thread.sleep(1000);\n        stream.data(new StringDataInfo(data2, true));\n\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGETWithQueryString() throws Exception\n    {\n        final String path = \"/foo\";\n        final String query = \"p=1\";\n        final String uri = path + \"?\" + query;\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"GET\", httpRequest.getMethod());\n                Assert.assertEquals(path, target);\n                Assert.assertEquals(path, httpRequest.getRequestURI());\n                Assert.assertEquals(query, httpRequest.getQueryString());\n                handlerLatch.countDown();\n            }\n        }, null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + uri);\n        headers.put(\"version\", \"HTTP/1.1\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","id":80334,"modified_method":"@Test\n    public void testGETWithQueryString() throws Exception\n    {\n        final String path = \"/foo\";\n        final String query = \"p=1\";\n        final String uri = path + \"?\" + query;\n        final CountDownLatch handlerLatch = new CountDownLatch(1);\n        Session session = startClient(startHTTPServer(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse)\n                    throws IOException, ServletException\n            {\n                request.setHandled(true);\n                Assert.assertEquals(\"GET\", httpRequest.getMethod());\n                Assert.assertEquals(path, target);\n                Assert.assertEquals(path, httpRequest.getRequestURI());\n                Assert.assertEquals(query, httpRequest.getQueryString());\n                handlerLatch.countDown();\n            }\n        }), null);\n\n        Headers headers = new Headers();\n        headers.put(\"method\", \"GET\");\n        headers.put(\"url\", \"http://localhost:\" + connector.getLocalPort() + uri);\n        headers.put(\"version\", \"HTTP/1.1\");\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(headers, true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(replyInfo.isClose());\n                Headers replyHeaders = replyInfo.getHeaders();\n                Assert.assertTrue(replyHeaders.get(\"status\").value().contains(\"200\"));\n                replyLatch.countDown();\n            }\n        });\n        Assert.assertTrue(handlerLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testHeaders() throws Exception\n    {\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(false));\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onHeaders(Stream stream, HeadersInfo headersInfo)\n                    {\n                        Assert.assertTrue(stream.isHalfClosed());\n                        stream.headers(new HeadersInfo(new Headers(), true));\n                        Assert.assertTrue(stream.isClosed());\n                    }\n                };\n            }\n        };\n\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Headers headers = new Headers();\n                headers.put(\"foo\", \"bar\");\n                headers.put(\"baz\", \"woo\");\n                stream.headers(new HeadersInfo(headers, true));\n                Assert.assertTrue(stream.isHalfClosed());\n            }\n\n            @Override\n            public void onHeaders(Stream stream, HeadersInfo headersInfo)\n            {\n                Assert.assertTrue(stream.isClosed());\n                latch.countDown();\n            }\n        });\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":80335,"modified_method":"@Test\n    public void testHeaders() throws Exception\n    {\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(false));\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onHeaders(Stream stream, HeadersInfo headersInfo)\n                    {\n                        Assert.assertTrue(stream.isHalfClosed());\n                        stream.headers(new HeadersInfo(new Headers(), true));\n                        Assert.assertTrue(stream.isClosed());\n                    }\n                };\n            }\n        };\n\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Headers headers = new Headers();\n                headers.put(\"foo\", \"bar\");\n                headers.put(\"baz\", \"woo\");\n                stream.headers(new HeadersInfo(headers, true));\n                Assert.assertTrue(stream.isHalfClosed());\n            }\n\n            @Override\n            public void onHeaders(Stream stream, HeadersInfo headersInfo)\n            {\n                Assert.assertTrue(stream.isClosed());\n                latch.countDown();\n            }\n        });\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testClientEnforcingIdleTimeout() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        InetSocketAddress address = startServer(new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                return null;\n            }\n\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                latch.countDown();\n            }\n        });\n\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setName(threadPool.getName() + \"-client\");\n        clientFactory = newSPDYClientFactory(threadPool);\n        clientFactory.start();\n        SPDYClient client = clientFactory.newSPDYClient();\n        long maxIdleTime = 1000;\n        client.setMaxIdleTime(maxIdleTime);\n        Session session = client.connect(address, null).get();\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(2 * maxIdleTime, TimeUnit.MILLISECONDS));\n    }","id":80336,"modified_method":"@Test\n    public void testClientEnforcingIdleTimeout() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        InetSocketAddress address = startSPDYServer(new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                return null;\n            }\n\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                latch.countDown();\n            }\n        });\n\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setName(threadPool.getName() + \"-client\");\n        clientFactory = newSPDYClientFactory(threadPool);\n        clientFactory.start();\n        SPDYClient client = clientFactory.newSPDYClient();\n        long maxIdleTime = 1000;\n        client.setMaxIdleTime(maxIdleTime);\n        Session session = client.connect(address, null).get();\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(2 * maxIdleTime, TimeUnit.MILLISECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testClientNotEnforcingIdleTimeoutWithPendingStream() throws Exception\n    {\n        final long maxIdleTime = 1000;\n        final CountDownLatch latch = new CountDownLatch(1);\n        InetSocketAddress address = startServer(new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                return null;\n            }\n\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                latch.countDown();\n            }\n        });\n\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setName(threadPool.getName() + \"-client\");\n        clientFactory = newSPDYClientFactory(threadPool);\n        clientFactory.start();\n        SPDYClient client = clientFactory.newSPDYClient();\n        client.setMaxIdleTime(maxIdleTime);\n        Session session = client.connect(address, null).get();\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                try\n                {\n                    Thread.sleep(2 * maxIdleTime);\n                    replyLatch.countDown();\n                }\n                catch (InterruptedException e)\n                {\n                    Assert.fail();\n                }\n            }\n        });\n\n        Assert.assertFalse(latch.await(2 * maxIdleTime, TimeUnit.MILLISECONDS));\n        Assert.assertTrue(replyLatch.await(3 * maxIdleTime, TimeUnit.MILLISECONDS));\n    }","id":80337,"modified_method":"@Test\n    public void testClientNotEnforcingIdleTimeoutWithPendingStream() throws Exception\n    {\n        final long maxIdleTime = 1000;\n        final CountDownLatch latch = new CountDownLatch(1);\n        InetSocketAddress address = startSPDYServer(new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                stream.reply(new ReplyInfo(true));\n                return null;\n            }\n\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                latch.countDown();\n            }\n        });\n\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setName(threadPool.getName() + \"-client\");\n        clientFactory = newSPDYClientFactory(threadPool);\n        clientFactory.start();\n        SPDYClient client = clientFactory.newSPDYClient();\n        client.setMaxIdleTime(maxIdleTime);\n        Session session = client.connect(address, null).get();\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                try\n                {\n                    Thread.sleep(2 * maxIdleTime);\n                    replyLatch.countDown();\n                }\n                catch (InterruptedException e)\n                {\n                    Assert.fail();\n                }\n            }\n        });\n\n        Assert.assertFalse(latch.await(2 * maxIdleTime, TimeUnit.MILLISECONDS));\n        Assert.assertTrue(replyLatch.await(3 * maxIdleTime, TimeUnit.MILLISECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testClientEnforcingIdleTimeoutWithUnrespondedStream() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        InetSocketAddress address = startServer(new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                latch.countDown();\n            }\n        });\n\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setName(threadPool.getName() + \"-client\");\n        clientFactory = newSPDYClientFactory(threadPool);\n        clientFactory.start();\n        SPDYClient client = clientFactory.newSPDYClient();\n        long maxIdleTime = 1000;\n        client.setMaxIdleTime(maxIdleTime);\n        Session session = client.connect(address, null).get();\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(2 * maxIdleTime, TimeUnit.MILLISECONDS));\n    }","id":80338,"modified_method":"@Test\n    public void testClientEnforcingIdleTimeoutWithUnrespondedStream() throws Exception\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        InetSocketAddress address = startSPDYServer(new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onGoAway(Session session, GoAwayInfo goAwayInfo)\n            {\n                latch.countDown();\n            }\n        });\n\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setName(threadPool.getName() + \"-client\");\n        clientFactory = newSPDYClientFactory(threadPool);\n        clientFactory.start();\n        SPDYClient client = clientFactory.newSPDYClient();\n        long maxIdleTime = 1000;\n        client.setMaxIdleTime(maxIdleTime);\n        Session session = client.connect(address, null).get();\n\n        session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(2 * maxIdleTime, TimeUnit.MILLISECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testServerPingPong() throws Exception\n    {\n        final CountDownLatch pingLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            public volatile int pingId;\n\n            @Override\n            public void onConnect(Session session)\n            {\n                PingInfo pingInfo = session.ping(SPDY.V2);\n                this.pingId = pingInfo.getPingId();\n            }\n\n            @Override\n            public void onPing(Session session, PingInfo pingInfo)\n            {\n                Assert.assertEquals(0, pingInfo.getPingId() % 2);\n                Assert.assertEquals(pingId, pingInfo.getPingId());\n                pingLatch.countDown();\n            }\n        };\n        startClient(startServer(serverSessionFrameListener), null);\n\n        Assert.assertTrue(pingLatch.await(5, TimeUnit.SECONDS));\n    }","id":80339,"modified_method":"@Test\n    public void testServerPingPong() throws Exception\n    {\n        final CountDownLatch pingLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            public volatile int pingId;\n\n            @Override\n            public void onConnect(Session session)\n            {\n                PingInfo pingInfo = session.ping(SPDY.V2);\n                this.pingId = pingInfo.getPingId();\n            }\n\n            @Override\n            public void onPing(Session session, PingInfo pingInfo)\n            {\n                Assert.assertEquals(0, pingInfo.getPingId() % 2);\n                Assert.assertEquals(pingId, pingInfo.getPingId());\n                pingLatch.countDown();\n            }\n        };\n        startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        Assert.assertTrue(pingLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testPingPong() throws Exception\n    {\n        final AtomicReference<PingInfo> ref = new AtomicReference<>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onPing(Session session, PingInfo pingInfo)\n            {\n                ref.set(pingInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(null), clientSessionFrameListener);\n        PingInfo pingInfo = session.ping(SPDY.V2);\n        Assert.assertEquals(1, pingInfo.getPingId() % 2);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n        PingInfo pongInfo = ref.get();\n        Assert.assertNotNull(pongInfo);\n        Assert.assertEquals(pingInfo.getPingId(), pongInfo.getPingId());\n    }","id":80340,"modified_method":"@Test\n    public void testPingPong() throws Exception\n    {\n        final AtomicReference<PingInfo> ref = new AtomicReference<>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onPing(Session session, PingInfo pingInfo)\n            {\n                ref.set(pingInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startSPDYServer(null), clientSessionFrameListener);\n        PingInfo pingInfo = session.ping(SPDY.V2);\n        Assert.assertEquals(1, pingInfo.getPingId() % 2);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n        PingInfo pongInfo = ref.get();\n        Assert.assertNotNull(pongInfo);\n        Assert.assertEquals(pingInfo.getPingId(), pongInfo.getPingId());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSettings() throws Exception\n    {\n        Map<SettingsInfo.Key,Integer> settings = new HashMap<>();\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.UPLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.DOWNLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSISTED | SettingsInfo.Key.CONGESTION_WINDOW), 1024);\n        final SettingsInfo clientSettingsInfo = new SettingsInfo(settings);\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo serverSettingsInfo)\n            {\n                Assert.assertEquals(clientSettingsInfo, serverSettingsInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        session.settings(SPDY.V2, clientSettingsInfo);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":80341,"modified_method":"@Test\n    public void testSettings() throws Exception\n    {\n        Map<SettingsInfo.Key,Integer> settings = new HashMap<>();\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.UPLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.DOWNLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSISTED | SettingsInfo.Key.CONGESTION_WINDOW), 1024);\n        final SettingsInfo clientSettingsInfo = new SettingsInfo(settings);\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo serverSettingsInfo)\n            {\n                Assert.assertEquals(clientSettingsInfo, serverSettingsInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        session.settings(SPDY.V2, clientSettingsInfo);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testServerSettings() throws Exception\n    {\n        Map<SettingsInfo.Key,Integer> settings = new HashMap<>();\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.UPLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.DOWNLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSIST | SettingsInfo.Key.CONGESTION_WINDOW), 1024);\n        final SettingsInfo serverSettingsInfo = new SettingsInfo(settings);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                session.settings(SPDY.V2, serverSettingsInfo);\n            }\n        };\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo clientSettingsInfo)\n            {\n                Assert.assertEquals(serverSettingsInfo, clientSettingsInfo);\n                latch.countDown();\n            }\n        };\n\n        startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":80342,"modified_method":"@Test\n    public void testServerSettings() throws Exception\n    {\n        Map<SettingsInfo.Key,Integer> settings = new HashMap<>();\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.UPLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.DOWNLOAD_BANDWIDTH), 1024 * 1024);\n        settings.put(new SettingsInfo.Key(SettingsInfo.Key.FLAG_PERSIST | SettingsInfo.Key.CONGESTION_WINDOW), 1024);\n        final SettingsInfo serverSettingsInfo = new SettingsInfo(settings);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                session.settings(SPDY.V2, serverSettingsInfo);\n            }\n        };\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public void onSettings(Session session, SettingsInfo clientSettingsInfo)\n            {\n                Assert.assertEquals(serverSettingsInfo, clientSettingsInfo);\n                latch.countDown();\n            }\n        };\n\n        startClient(startSPDYServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSynReplyDataFlushData() throws Exception\n    {\n        final String data1 = \"foo\";\n        final String data2 = \"bar\";\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertTrue(stream.isHalfClosed());\n\n                stream.reply(new ReplyInfo(false));\n                stream.data(new StringDataInfo(data1, false));\n                stream.getSession().flush();\n                stream.data(new StringDataInfo(data2, true));\n\n                return null;\n            }\n        };\n\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch1 = new CountDownLatch(1);\n        final CountDownLatch dataLatch2 = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(true), new Stream.FrameListener.Adapter()\n        {\n            private AtomicInteger dataCount = new AtomicInteger();\n\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertFalse(replyInfo.isClose());\n                replyLatch.countDown();\n            }\n\n            @Override\n            public void onData(Stream stream, DataInfo dataInfo)\n            {\n                final ByteBuffer buffer = ByteBuffer.allocate(dataInfo.getBytesCount());\n                dataInfo.getBytes(buffer);\n                buffer.flip();\n                int dataCount = this.dataCount.incrementAndGet();\n                if (dataCount == 1)\n                {\n                    String chunk1 = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                    Assert.assertEquals(data1, chunk1);\n                    dataLatch1.countDown();\n                }\n                else if (dataCount == 2)\n                {\n                    String chunk2 = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                    Assert.assertEquals(data2, chunk2);\n                    dataLatch2.countDown();\n                }\n            }\n        });\n\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(dataLatch1.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(dataLatch2.await(5, TimeUnit.SECONDS));\n    }","id":80343,"modified_method":"@Test\n    public void testSynReplyDataFlushData() throws Exception\n    {\n        final String data1 = \"foo\";\n        final String data2 = \"bar\";\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertTrue(stream.isHalfClosed());\n\n                stream.reply(new ReplyInfo(false));\n                stream.data(new StringDataInfo(data1, false));\n                stream.getSession().flush();\n                stream.data(new StringDataInfo(data2, true));\n\n                return null;\n            }\n        };\n\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch1 = new CountDownLatch(1);\n        final CountDownLatch dataLatch2 = new CountDownLatch(1);\n        session.syn(SPDY.V2, new SynInfo(true), new Stream.FrameListener.Adapter()\n        {\n            private AtomicInteger dataCount = new AtomicInteger();\n\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertFalse(replyInfo.isClose());\n                replyLatch.countDown();\n            }\n\n            @Override\n            public void onData(Stream stream, DataInfo dataInfo)\n            {\n                final ByteBuffer buffer = ByteBuffer.allocate(dataInfo.getBytesCount());\n                dataInfo.getBytes(buffer);\n                buffer.flip();\n                int dataCount = this.dataCount.incrementAndGet();\n                if (dataCount == 1)\n                {\n                    String chunk1 = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                    Assert.assertEquals(data1, chunk1);\n                    dataLatch1.countDown();\n                }\n                else if (dataCount == 2)\n                {\n                    String chunk2 = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                    Assert.assertEquals(data2, chunk2);\n                    dataLatch2.countDown();\n                }\n            }\n        });\n\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(dataLatch1.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(dataLatch2.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testServerSynDataReplyData() throws Exception\n    {\n        final String serverData = \"server\";\n        final String clientData = \"client\";\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        final CountDownLatch clientDataLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                Stream stream = session.syn(SPDY.V2, new SynInfo(false), new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onReply(Stream stream, ReplyInfo replyInfo)\n                    {\n                        replyLatch.countDown();\n                    }\n\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteBuffer buffer = ByteBuffer.allocate(dataInfo.getBytesCount());\n                        dataInfo.getBytes(buffer);\n                        buffer.flip();\n                        String data = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                        Assert.assertEquals(clientData, data);\n                        clientDataLatch.countDown();\n                    }\n                });\n                stream.data(new StringDataInfo(serverData, true));\n            }\n        };\n\n        final CountDownLatch synLatch = new CountDownLatch(1);\n        final CountDownLatch serverDataLatch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertEquals(0, stream.getId() % 2);\n\n                stream.reply(new ReplyInfo(false));\n                stream.data(new StringDataInfo(clientData, true));\n                synLatch.countDown();\n\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteBuffer buffer = ByteBuffer.allocate(dataInfo.getBytesCount());\n                        dataInfo.getBytes(buffer);\n                        buffer.flip();\n                        String data = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                        Assert.assertEquals(serverData, data);\n                        serverDataLatch.countDown();\n                    }\n                };\n            }\n        };\n\n        startClient(startServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Assert.assertTrue(synLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(serverDataLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(clientDataLatch.await(5, TimeUnit.SECONDS));\n    }","id":80344,"modified_method":"@Test\n    public void testServerSynDataReplyData() throws Exception\n    {\n        final String serverData = \"server\";\n        final String clientData = \"client\";\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        final CountDownLatch clientDataLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                Stream stream = session.syn(SPDY.V2, new SynInfo(false), new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onReply(Stream stream, ReplyInfo replyInfo)\n                    {\n                        replyLatch.countDown();\n                    }\n\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteBuffer buffer = ByteBuffer.allocate(dataInfo.getBytesCount());\n                        dataInfo.getBytes(buffer);\n                        buffer.flip();\n                        String data = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                        Assert.assertEquals(clientData, data);\n                        clientDataLatch.countDown();\n                    }\n                });\n                stream.data(new StringDataInfo(serverData, true));\n            }\n        };\n\n        final CountDownLatch synLatch = new CountDownLatch(1);\n        final CountDownLatch serverDataLatch = new CountDownLatch(1);\n        Session.FrameListener clientSessionFrameListener = new Session.FrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertEquals(0, stream.getId() % 2);\n\n                stream.reply(new ReplyInfo(false));\n                stream.data(new StringDataInfo(clientData, true));\n                synLatch.countDown();\n\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteBuffer buffer = ByteBuffer.allocate(dataInfo.getBytesCount());\n                        dataInfo.getBytes(buffer);\n                        buffer.flip();\n                        String data = Charset.forName(\"UTF-8\").decode(buffer).toString();\n                        Assert.assertEquals(serverData, data);\n                        serverDataLatch.countDown();\n                    }\n                };\n            }\n        };\n\n        startClient(startSPDYServer(serverSessionFrameListener), clientSessionFrameListener);\n\n        Assert.assertTrue(synLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(serverDataLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(clientDataLatch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSynDataRst() throws Exception\n    {\n        final AtomicReference<RstInfo> ref = new AtomicReference<>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                // Do not send the reply, we expect a RST_STREAM\n                stream.data(new StringDataInfo(\"foo\", true));\n                return null;\n            }\n\n            @Override\n            public void onRst(Session session, RstInfo rstInfo)\n            {\n                ref.set(rstInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        Stream stream = session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n        RstInfo rstInfo = ref.get();\n        Assert.assertNotNull(rstInfo);\n        Assert.assertEquals(stream.getId(), rstInfo.getStreamId());\n        Assert.assertSame(StreamStatus.PROTOCOL_ERROR, rstInfo.getStreamStatus());\n    }","id":80345,"modified_method":"@Test\n    public void testSynDataRst() throws Exception\n    {\n        final AtomicReference<RstInfo> ref = new AtomicReference<>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                // Do not send the reply, we expect a RST_STREAM\n                stream.data(new StringDataInfo(\"foo\", true));\n                return null;\n            }\n\n            @Override\n            public void onRst(Session session, RstInfo rstInfo)\n            {\n                ref.set(rstInfo);\n                latch.countDown();\n            }\n        };\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        Stream stream = session.syn(SPDY.V2, new SynInfo(true), null);\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n        RstInfo rstInfo = ref.get();\n        Assert.assertNotNull(rstInfo);\n        Assert.assertEquals(stream.getId(), rstInfo.getStreamId());\n        Assert.assertSame(StreamStatus.PROTOCOL_ERROR, rstInfo.getStreamStatus());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSynReply() throws Exception\n    {\n        final AtomicReference<Session> sessionRef = new AtomicReference<>();\n        final CountDownLatch synLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                sessionRef.set(session);\n            }\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertTrue(stream.isHalfClosed());\n                stream.reply(new ReplyInfo(new Headers(), true));\n                synLatch.countDown();\n                return null;\n            }\n        };\n\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        final CountDownLatch streamCreatedLatch = new CountDownLatch(1);\n        final CountDownLatch streamRemovedLatch = new CountDownLatch(1);\n        session.addListener(new Session.StreamListener()\n        {\n            @Override\n            public void onStreamCreated(Stream stream)\n            {\n                streamCreatedLatch.countDown();\n            }\n\n            @Override\n            public void onStreamClosed(Stream stream)\n            {\n                streamRemovedLatch.countDown();\n            }\n        });\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(new Headers(), true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(stream.isClosed());\n                replyLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(synLatch.await(5, TimeUnit.SECONDS));\n        Session serverSession = sessionRef.get();\n        Assert.assertNotNull(serverSession);\n\n        Assert.assertTrue(streamCreatedLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(stream.isClosed());\n\n        Assert.assertTrue(streamRemovedLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertEquals(0, session.getStreams().size());\n    }","id":80346,"modified_method":"@Test\n    public void testSynReply() throws Exception\n    {\n        final AtomicReference<Session> sessionRef = new AtomicReference<>();\n        final CountDownLatch synLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                sessionRef.set(session);\n            }\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertTrue(stream.isHalfClosed());\n                stream.reply(new ReplyInfo(new Headers(), true));\n                synLatch.countDown();\n                return null;\n            }\n        };\n\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        final CountDownLatch streamCreatedLatch = new CountDownLatch(1);\n        final CountDownLatch streamRemovedLatch = new CountDownLatch(1);\n        session.addListener(new Session.StreamListener()\n        {\n            @Override\n            public void onStreamCreated(Stream stream)\n            {\n                streamCreatedLatch.countDown();\n            }\n\n            @Override\n            public void onStreamClosed(Stream stream)\n            {\n                streamRemovedLatch.countDown();\n            }\n        });\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(new Headers(), true), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(stream.isClosed());\n                replyLatch.countDown();\n            }\n        });\n\n        Assert.assertTrue(synLatch.await(5, TimeUnit.SECONDS));\n        Session serverSession = sessionRef.get();\n        Assert.assertNotNull(serverSession);\n\n        Assert.assertTrue(streamCreatedLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(stream.isClosed());\n\n        Assert.assertTrue(streamRemovedLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertEquals(0, session.getStreams().size());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSynDataReply() throws Exception\n    {\n        final byte[] dataBytes = \"foo\".getBytes(Charset.forName(\"UTF-8\"));\n\n        final AtomicReference<Session> sessionRef = new AtomicReference<>();\n        final CountDownLatch synLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                sessionRef.set(session);\n            }\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertFalse(stream.isHalfClosed());\n                synLatch.countDown();\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                        ByteBuffer buffer = ByteBuffer.allocate(2);\n                        while (!dataInfo.isConsumed())\n                        {\n                            dataInfo.getBytes(buffer);\n                            buffer.flip();\n                            bytes.write(buffer.array(), buffer.arrayOffset(), buffer.remaining());\n                            buffer.clear();\n                        }\n                        Assert.assertTrue(Arrays.equals(dataBytes, bytes.toByteArray()));\n                        Assert.assertTrue(stream.isHalfClosed());\n                        Assert.assertFalse(stream.isClosed());\n\n                        stream.reply(new ReplyInfo(new Headers(), true));\n                        Assert.assertTrue(stream.isClosed());\n                        dataLatch.countDown();\n                    }\n                };\n            }\n        };\n\n        Session session = startClient(startServer(serverSessionFrameListener), null);\n\n        final CountDownLatch streamRemovedLatch = new CountDownLatch(1);\n        session.addListener(new Session.StreamListener.Adapter()\n        {\n            @Override\n            public void onStreamClosed(Stream stream)\n            {\n                streamRemovedLatch.countDown();\n            }\n        });\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(new Headers(), false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(stream.isClosed());\n                replyLatch.countDown();\n            }\n        });\n        stream.data(new BytesDataInfo(dataBytes, true));\n\n        Assert.assertTrue(synLatch.await(5, TimeUnit.SECONDS));\n        Session serverSession = sessionRef.get();\n        Assert.assertNotNull(serverSession);\n\n        Assert.assertTrue(dataLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n\n        Assert.assertTrue(streamRemovedLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertEquals(0, session.getStreams().size());\n    }","id":80347,"modified_method":"@Test\n    public void testSynDataReply() throws Exception\n    {\n        final byte[] dataBytes = \"foo\".getBytes(Charset.forName(\"UTF-8\"));\n\n        final AtomicReference<Session> sessionRef = new AtomicReference<>();\n        final CountDownLatch synLatch = new CountDownLatch(1);\n        final CountDownLatch dataLatch = new CountDownLatch(1);\n        ServerSessionFrameListener serverSessionFrameListener = new ServerSessionFrameListener.Adapter()\n        {\n            @Override\n            public void onConnect(Session session)\n            {\n                sessionRef.set(session);\n            }\n\n            @Override\n            public Stream.FrameListener onSyn(Stream stream, SynInfo synInfo)\n            {\n                Assert.assertFalse(stream.isHalfClosed());\n                synLatch.countDown();\n                return new Stream.FrameListener.Adapter()\n                {\n                    @Override\n                    public void onData(Stream stream, DataInfo dataInfo)\n                    {\n                        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                        ByteBuffer buffer = ByteBuffer.allocate(2);\n                        while (!dataInfo.isConsumed())\n                        {\n                            dataInfo.getBytes(buffer);\n                            buffer.flip();\n                            bytes.write(buffer.array(), buffer.arrayOffset(), buffer.remaining());\n                            buffer.clear();\n                        }\n                        Assert.assertTrue(Arrays.equals(dataBytes, bytes.toByteArray()));\n                        Assert.assertTrue(stream.isHalfClosed());\n                        Assert.assertFalse(stream.isClosed());\n\n                        stream.reply(new ReplyInfo(new Headers(), true));\n                        Assert.assertTrue(stream.isClosed());\n                        dataLatch.countDown();\n                    }\n                };\n            }\n        };\n\n        Session session = startClient(startSPDYServer(serverSessionFrameListener), null);\n\n        final CountDownLatch streamRemovedLatch = new CountDownLatch(1);\n        session.addListener(new Session.StreamListener.Adapter()\n        {\n            @Override\n            public void onStreamClosed(Stream stream)\n            {\n                streamRemovedLatch.countDown();\n            }\n        });\n\n        final CountDownLatch replyLatch = new CountDownLatch(1);\n        Stream stream = session.syn(SPDY.V2, new SynInfo(new Headers(), false), new Stream.FrameListener.Adapter()\n        {\n            @Override\n            public void onReply(Stream stream, ReplyInfo replyInfo)\n            {\n                Assert.assertTrue(stream.isClosed());\n                replyLatch.countDown();\n            }\n        });\n        stream.data(new BytesDataInfo(dataBytes, true));\n\n        Assert.assertTrue(synLatch.await(5, TimeUnit.SECONDS));\n        Session serverSession = sessionRef.get();\n        Assert.assertNotNull(serverSession);\n\n        Assert.assertTrue(dataLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertTrue(replyLatch.await(5, TimeUnit.SECONDS));\n\n        Assert.assertTrue(streamRemovedLatch.await(5, TimeUnit.SECONDS));\n        Assert.assertEquals(0, session.getStreams().size());\n    }","commit_id":"ba25a485f28b1fd7f8b646b03263044cf96eefd4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private LinkedList<UndoableGroup> getStack() throws NothingToUndoException {\n    final DocumentReference[] documents = myEditor == null? null : myManager.getDocumentReferences(myEditor);\n    if (documents == null || documents.length == 0) {\n      return getStackHolder().getGlobalStack();\n    }\n    else {\n      long recentDocumentTimeStamp = -1;\n      LinkedList<UndoableGroup> result = null;\n      for (DocumentReference docRef : documents) {\n        LinkedList<UndoableGroup> stack = getStackHolder().getStack(docRef);\n        if (!stack.isEmpty()) {\n          long modificationStamp;\n          if (docRef instanceof DocumentReferenceByDocument) {\n            DocumentReferenceByDocument doc = (DocumentReferenceByDocument) docRef;\n            modificationStamp = doc.getDocument().getModificationStamp();\n          } else {\n            modificationStamp = docRef.getFile().getModificationStamp();\n          }\n          if (recentDocumentTimeStamp < modificationStamp) {\n            result = stack;\n            recentDocumentTimeStamp = modificationStamp;\n          }\n        }\n      }\n      if (result != null) {\n        return result;\n      }\n      else {\n        throw new NothingToUndoException();\n      }\n    }\n  }","id":80348,"modified_method":"private LinkedList<UndoableGroup> getStack() throws NothingToUndoException {\n    final DocumentReference[] documents = myEditor == null? null : myManager.getDocumentReferences(myEditor);\n    if (documents == null || documents.length == 0) {\n      return getStackHolder().getGlobalStack();\n    }\n    else {\n      long recentDocumentTimeStamp = -1;\n      LinkedList<UndoableGroup> result = null;\n      for (DocumentReference docRef : documents) {\n        LinkedList<UndoableGroup> stack = getStackHolder().getStack(docRef);\n        if (!stack.isEmpty()) {\n          long modificationStamp;\n          Document doc = docRef.getDocument();\n          modificationStamp = doc != null ? doc.getModificationStamp() : docRef.getFile().getTimeStamp();\n          if (recentDocumentTimeStamp < modificationStamp) {\n            result = stack;\n            recentDocumentTimeStamp = modificationStamp;\n          }\n        }\n      }\n      if (result != null) {\n        return result;\n      }\n      else {\n        throw new NothingToUndoException();\n      }\n    }\n  }","commit_id":"fa91d57804dd90f1fade6a36decc8bdab1a368c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public FileEditorState getState(final FileEditorStateLevel ignored) {\n    final Document document = FileDocumentManager.getInstance().getDocument(myFile);\n    final ArrayList<RadComponent> selection = FormEditingUtil.getSelectedComponents(myEditor);\n    final String[] ids = new String[selection.size()];\n    for (int i = ids.length - 1; i >= 0; i--) {\n      ids[i] = selection.get(i).getId();\n    }\n    return new MyEditorState(document.getModificationStamp(), ids);\n  }","id":80349,"modified_method":"@NotNull\n  public FileEditorState getState(final FileEditorStateLevel ignored) {\n    final Document document = FileDocumentManager.getInstance().getCachedDocument(myFile);\n    long modificationStamp = document != null ? document.getModificationStamp() : myFile.getModificationStamp();\n    final ArrayList<RadComponent> selection = FormEditingUtil.getSelectedComponents(myEditor);\n    final String[] ids = new String[selection.size()];\n    for (int i = ids.length - 1; i >= 0; i--) {\n      ids[i] = selection.get(i).getId();\n    }\n    return new MyEditorState(modificationStamp, ids);\n  }","commit_id":"c5cb5932c06ba6b3f24fbac003b270948e60a6e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public IndentOptions getIndentOptions(@NotNull CodeStyleSettings settings, @NotNull PsiFile file) {\n    if (!isEnabled(settings, file)) {\n      return null;\n    }\n\n    Project project = file.getProject();\n    PsiDocumentManager psiManager = PsiDocumentManager.getInstance(project);\n    Document document = psiManager.getDocument(file);\n    if (document == null) {\n      return null;\n    }\n\n    IndentOptions options = getValidCachedIndentOptions(file, document);\n    if (options != null) {\n      return options;\n    }\n\n    TimeStampedIndentOptions indentOptions = getDefault(file.getFileType(), project, document.getModificationStamp());\n    indentOptions.associateWithDocument(document);\n\n    DetectAndAdjustIndentOptionsTask task = new DetectAndAdjustIndentOptionsTask(project, document, indentOptions, BOUNDED_EXECUTOR);\n    task.scheduleInBackgroundForCommittedDocument();\n\n    return indentOptions;\n  }","id":80350,"modified_method":"@Nullable\n  @Override\n  public IndentOptions getIndentOptions(@NotNull CodeStyleSettings settings, @NotNull PsiFile file) {\n    if (!isEnabled(settings, file)) {\n      return null;\n    }\n\n    Project project = file.getProject();\n    PsiDocumentManager psiManager = PsiDocumentManager.getInstance(project);\n    Document document = psiManager.getDocument(file);\n    if (document == null) {\n      return null;\n    }\n\n    IndentOptions options = getValidCachedIndentOptions(file, document);\n    if (options != null) {\n      return options;\n    }\n\n    TimeStampedIndentOptions indentOptions = getDefaultIndentOptions(file, document);\n    indentOptions.associateWithDocument(document);\n\n    DetectAndAdjustIndentOptionsTask task = new DetectAndAdjustIndentOptionsTask(project, document, indentOptions, BOUNDED_EXECUTOR);\n    task.scheduleInBackgroundForCommittedDocument();\n\n    return indentOptions;\n  }","commit_id":"487fae24d38ad2a1d81cbe295d3470ffab0670fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IndentOptions getValidCachedIndentOptions(PsiFile file, Document document) {\n    IndentOptions options = IndentOptions.retrieveFromAssociatedDocument(file);\n    long documentStamp = document.getModificationStamp();\n    if (options instanceof TimeStampedIndentOptions) {\n      long optionsStamp = ((TimeStampedIndentOptions)options).getTimeStamp();\n      if (optionsStamp == documentStamp) {\n        return options;\n      }\n    }\n    return null;\n  }","id":80351,"modified_method":"public IndentOptions getValidCachedIndentOptions(PsiFile file, Document document) {\n    IndentOptions options = IndentOptions.retrieveFromAssociatedDocument(file);\n    if (options instanceof TimeStampedIndentOptions) {\n      final IndentOptions defaultIndentOptions = getDefaultIndentOptions(file, document);\n      final TimeStampedIndentOptions cachedInDocument = (TimeStampedIndentOptions)options;\n      if (!cachedInDocument.isOutdated(document, defaultIndentOptions)) {\n        return cachedInDocument;\n      }\n    }\n    return null;\n  }","commit_id":"487fae24d38ad2a1d81cbe295d3470ffab0670fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void scheduleInBackgroundForCommittedDocument() {\n    if (myProject.isDisposed()) return;\n    \n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      Continuation continuation = performInReadAction(new DumbProgressIndicator());\n      if (continuation != null) {\n        continuation.getAction().run();\n      }\n    }\n    else {\n      PsiDocumentManager manager = PsiDocumentManager.getInstance(myProject);\n      manager.performForCommittedDocument(myDocument, () -> scheduleWithWriteActionPriority(myExecutor, this));\n    }\n  }","id":80352,"modified_method":"public void scheduleInBackgroundForCommittedDocument() {\n    if (myProject.isDisposed()) return;\n    \n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n      Continuation continuation = performInReadAction(new DumbProgressIndicator());\n      if (continuation != null) {\n        continuation.getAction().run();\n      }\n    }\n    else {\n      PsiDocumentManager manager = PsiDocumentManager.getInstance(myProject);\n      manager.performForCommittedDocument(myDocument, () -> scheduleWithWriteActionPriority(myExecutor, this));\n    }\n  }","commit_id":"487fae24d38ad2a1d81cbe295d3470ffab0670fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void adjustOptions(IndentOptionsAdjuster adjuster) {\n    long stamp = myDocument.getModificationStamp();\n    adjuster.adjust(myOptionsToAdjust);\n    if (myOptionsToAdjust instanceof TimeStampedIndentOptions) {\n      ((TimeStampedIndentOptions)myOptionsToAdjust).setTimeStamp(stamp);\n    }\n  }","id":80353,"modified_method":"private void adjustOptions(IndentOptionsAdjuster adjuster) {\n    final PsiFile file = getFile();\n    if (file == null) return;\n\n    final IndentOptions currentDefault = getDefaultIndentOptions(file, myDocument);\n    myOptionsToAdjust.copyFrom(currentDefault);\n\n    adjuster.adjust(myOptionsToAdjust);\n    if (myOptionsToAdjust instanceof TimeStampedIndentOptions) {\n      TimeStampedIndentOptions cachedInDocument = (TimeStampedIndentOptions)myOptionsToAdjust;\n      cachedInDocument.setTimeStamp(myDocument.getModificationStamp());\n      cachedInDocument.setOriginalIndentOptionsHash(currentDefault.hashCode());\n    }\n  }","commit_id":"487fae24d38ad2a1d81cbe295d3470ffab0670fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n    long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n    long masterMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n    long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n    long workerMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n    LOG.info(\"Master launched {}, master count {}, \"\n        + \"requested master cpu {} and mem {} MB\",\n        mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n    for (Protos.Offer offer : offers) {\n      Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n      double offerCpu = 0;\n      double offerMem = 0;\n      for (Protos.Resource resource : offer.getResourcesList()) {\n        if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n          offerCpu += resource.getScalar().getValue();\n        } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n          offerMem += resource.getScalar().getValue();\n        } else {\n          // Other resources are currently ignored.\n        }\n      }\n\n      LOG.info(\"Received offer {} on host {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n          offer.getId().getValue(), offer.getHostname(), offerCpu, offerMem,\n          OfferUtils.hasAvailableMasterPorts(offer));\n\n      Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n      List<Protos.Resource> resources;\n      if (!mMasterLaunched\n          && offerCpu >= masterCpu\n          && offerMem >= masterMem\n          && mMasterCount < Configuration\n              .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT)\n          && OfferUtils.hasAvailableMasterPorts(offer)\n          && (mRequiredMasterHostname == null\n              || mRequiredMasterHostname.equals(offer.getHostname()))) {\n        LOG.debug(\"Creating Alluxio Master executor\");\n        executorBuilder\n            .setName(\"Alluxio Master Executor\")\n            .setSource(\"master\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_CONF_DIR\").setValue(\"conf\")\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_LOGS_DIR\").setValue(\"logs\")\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getMasterRequiredResources(masterCpu, masterMem);\n        mMasterHostname = offer.getHostname();\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n        mMasterCount++;\n        mMasterTaskId = mLaunchedTasks;\n      } else if (mMasterLaunched\n          && !mWorkers.contains(offer.getHostname())\n          && offerCpu >= workerCpu\n          && offerMem >= workerMem\n          && OfferUtils.hasAvailableWorkerPorts(offer)) {\n        LOG.debug(\"Creating Alluxio Worker executor\");\n        final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n        executorBuilder\n            .setName(\"Alluxio Worker Executor\")\n            .setSource(\"worker\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_CONF_DIR\").setValue(\"conf\")\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_LOGS_DIR\").setValue(\"logs\")\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MESOS_SITE_PROPERTIES_CONTENT\")\n                                    .setValue(createAlluxioSiteProperties())\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getWorkerRequiredResources(workerCpu, workerMem);\n        mWorkers.add(offer.getHostname());\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n      } else {\n        // The resource offer cannot be used to start either master or a worker.\n        LOG.info(\"Declining offer {}\", offer.getId().getValue());\n        driver.declineOffer(offer.getId());\n        continue;\n      }\n\n      Protos.TaskID taskId =\n          Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n      LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n      Protos.TaskInfo task =\n          Protos.TaskInfo\n              .newBuilder()\n              .setName(mTaskName)\n              .setTaskId(taskId)\n              .setSlaveId(offer.getSlaveId())\n              .addAllResources(resources)\n              .setExecutor(executorBuilder).build();\n\n      launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n      mLaunchedTasks++;\n\n      // NOTE: We use the new API `acceptOffers` here to launch tasks.\n      // The 'launchTasks' API will be deprecated.\n      List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n      offerIds.add(offer.getId());\n      List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n      Protos.Offer.Operation operation =\n          Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n              .setLaunch(launch).build();\n      operations.add(operation);\n      Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n      driver.acceptOffers(offerIds, operations, filters);\n    }\n  }","id":80354,"modified_method":"@Override\n  public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n    long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n    long masterMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n    long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n    long workerMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n    LOG.info(\"Master launched {}, master count {}, \"\n        + \"requested master cpu {} mem {} MB and required master hostname {}\",\n        mMasterLaunched, mMasterCount, masterCpu, masterMem, mRequiredMasterHostname);\n\n    for (Protos.Offer offer : offers) {\n      Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n      double offerCpu = 0;\n      double offerMem = 0;\n      for (Protos.Resource resource : offer.getResourcesList()) {\n        if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n          offerCpu += resource.getScalar().getValue();\n        } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n          offerMem += resource.getScalar().getValue();\n        } else {\n          // Other resources are currently ignored.\n        }\n      }\n\n      LOG.info(\"Received offer {} on host {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n          offer.getId().getValue(), offer.getHostname(), offerCpu, offerMem,\n          OfferUtils.hasAvailableMasterPorts(offer));\n\n      Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n      List<Protos.Resource> resources;\n      if (!mMasterLaunched\n          && offerCpu >= masterCpu\n          && offerMem >= masterMem\n          && mMasterCount < Configuration\n              .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT)\n          && OfferUtils.hasAvailableMasterPorts(offer)\n          && (mRequiredMasterHostname == null\n              || mRequiredMasterHostname.equals(offer.getHostname()))) {\n        LOG.debug(\"Creating Alluxio Master executor\");\n        executorBuilder\n            .setName(\"Alluxio Master Executor\")\n            .setSource(\"master\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MESOS_SITE_PROPERTIES_CONTENT\")\n                                    .setValue(createAlluxioSiteProperties())\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getMasterRequiredResources(masterCpu, masterMem);\n        mMasterHostname = offer.getHostname();\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n        mMasterCount++;\n        mMasterTaskId = mLaunchedTasks;\n      } else if (mMasterLaunched\n          && !mWorkers.contains(offer.getHostname())\n          && offerCpu >= workerCpu\n          && offerMem >= workerMem\n          && OfferUtils.hasAvailableWorkerPorts(offer)) {\n        LOG.debug(\"Creating Alluxio Worker executor\");\n        final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n        executorBuilder\n            .setName(\"Alluxio Worker Executor\")\n            .setSource(\"worker\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MESOS_SITE_PROPERTIES_CONTENT\")\n                                    .setValue(createAlluxioSiteProperties())\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getWorkerRequiredResources(workerCpu, workerMem);\n        mWorkers.add(offer.getHostname());\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n      } else {\n        // The resource offer cannot be used to start either master or a worker.\n        LOG.info(\"Declining offer {}\", offer.getId().getValue());\n        driver.declineOffer(offer.getId());\n        continue;\n      }\n\n      Protos.TaskID taskId =\n          Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n      LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n      Protos.TaskInfo task =\n          Protos.TaskInfo\n              .newBuilder()\n              .setName(mTaskName)\n              .setTaskId(taskId)\n              .setSlaveId(offer.getSlaveId())\n              .addAllResources(resources)\n              .setExecutor(executorBuilder).build();\n\n      launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n      mLaunchedTasks++;\n\n      // NOTE: We use the new API `acceptOffers` here to launch tasks.\n      // The 'launchTasks' API will be deprecated.\n      List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n      offerIds.add(offer.getId());\n      List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n      Protos.Offer.Operation operation =\n          Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n              .setLaunch(launch).build();\n      operations.add(operation);\n      Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n      driver.acceptOffers(offerIds, operations, filters);\n    }\n  }","commit_id":"dc720bd68cbdcb5b853a1c5b1876e0e9288dd6e9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the content that should be pasted into an alluxio-site.properties file to recreate the\n   *         current configuration\n   */\n  private String createAlluxioSiteProperties() {\n    StringBuilder siteProperties = new StringBuilder();\n    for (Entry<String, String> entry : Configuration.toMap().entrySet()) {\n      siteProperties.append(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n    }\n    return siteProperties.toString();\n  }","id":80355,"modified_method":"/**\n   * @return the content that should be pasted into an alluxio-site.properties file to recreate the\n   *         current configuration\n   */\n  private String createAlluxioSiteProperties() {\n    StringBuilder siteProperties = new StringBuilder();\n    for (Entry<String, String> entry : Configuration.toMap().entrySet()) {\n      siteProperties.append(String.format(\"%s=%s\\n\", entry.getKey(), entry.getValue()));\n    }\n    return siteProperties.toString();\n  }","commit_id":"dc720bd68cbdcb5b853a1c5b1876e0e9288dd6e9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n    long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n    long masterMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n    long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n    long workerMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n    LOG.info(\"Master launched {}, master count {}, \"\n        + \"requested master cpu {} and mem {} MB\",\n        mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n    for (Protos.Offer offer : offers) {\n      Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n      double offerCpu = 0;\n      double offerMem = 0;\n      for (Protos.Resource resource : offer.getResourcesList()) {\n        if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n          offerCpu += resource.getScalar().getValue();\n        } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n          offerMem += resource.getScalar().getValue();\n        } else {\n          // Other resources are currently ignored.\n        }\n      }\n\n      LOG.info(\"Received offer {} on host {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n          offer.getId().getValue(), offer.getHostname(), offerCpu, offerMem,\n          OfferUtils.hasAvailableMasterPorts(offer));\n\n      Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n      List<Protos.Resource> resources;\n      if (!mMasterLaunched\n          && offerCpu >= masterCpu\n          && offerMem >= masterMem\n          && mMasterCount < Configuration\n              .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT)\n          && OfferUtils.hasAvailableMasterPorts(offer)\n          && (mRequiredMasterHostname == null\n              || mRequiredMasterHostname.equals(offer.getHostname()))) {\n        LOG.debug(\"Creating Alluxio Master executor\");\n        executorBuilder\n            .setName(\"Alluxio Master Executor\")\n            .setSource(\"master\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_CONF_DIR\").setValue(\"conf\")\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_LOGS_DIR\").setValue(\"logs\")\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getMasterRequiredResources(masterCpu, masterMem);\n        mMasterHostname = offer.getHostname();\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n        mMasterCount++;\n        mMasterTaskId = mLaunchedTasks;\n      } else if (mMasterLaunched\n          && !mWorkers.contains(offer.getHostname())\n          && offerCpu >= workerCpu\n          && offerMem >= workerMem\n          && OfferUtils.hasAvailableWorkerPorts(offer)) {\n        LOG.debug(\"Creating Alluxio Worker executor\");\n        final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n        executorBuilder\n            .setName(\"Alluxio Worker Executor\")\n            .setSource(\"worker\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_CONF_DIR\").setValue(\"conf\")\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_LOGS_DIR\").setValue(\"logs\")\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getWorkerRequiredResources(workerCpu, workerMem);\n        mWorkers.add(offer.getHostname());\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n      } else {\n        // The resource offer cannot be used to start either master or a worker.\n        LOG.info(\"Declining offer {}\", offer.getId().getValue());\n        driver.declineOffer(offer.getId());\n        continue;\n      }\n\n      Protos.TaskID taskId =\n          Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n      LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n      Protos.TaskInfo task =\n          Protos.TaskInfo\n              .newBuilder()\n              .setName(mTaskName)\n              .setTaskId(taskId)\n              .setSlaveId(offer.getSlaveId())\n              .addAllResources(resources)\n              .setExecutor(executorBuilder).build();\n\n      launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n      mLaunchedTasks++;\n\n      // NOTE: We use the new API `acceptOffers` here to launch tasks.\n      // The 'launchTasks' API will be deprecated.\n      List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n      offerIds.add(offer.getId());\n      List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n      Protos.Offer.Operation operation =\n          Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n              .setLaunch(launch).build();\n      operations.add(operation);\n      Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n      driver.acceptOffers(offerIds, operations, filters);\n    }\n  }","id":80356,"modified_method":"@Override\n  public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n    long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n    long masterMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n    long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n    long workerMem =\n        Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n    LOG.info(\"Master launched {}, master count {}, \"\n        + \"requested master cpu {} and mem {} MB\",\n        mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n    for (Protos.Offer offer : offers) {\n      Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n      double offerCpu = 0;\n      double offerMem = 0;\n      for (Protos.Resource resource : offer.getResourcesList()) {\n        if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n          offerCpu += resource.getScalar().getValue();\n        } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n          offerMem += resource.getScalar().getValue();\n        } else {\n          // Other resources are currently ignored.\n        }\n      }\n\n      LOG.info(\"Received offer {} on host {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n          offer.getId().getValue(), offer.getHostname(), offerCpu, offerMem,\n          OfferUtils.hasAvailableMasterPorts(offer));\n\n      Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n      List<Protos.Resource> resources;\n      if (!mMasterLaunched\n          && offerCpu >= masterCpu\n          && offerMem >= masterMem\n          && mMasterCount < Configuration\n              .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT)\n          && OfferUtils.hasAvailableMasterPorts(offer)\n          && (mRequiredMasterHostname == null\n              || mRequiredMasterHostname.equals(offer.getHostname()))) {\n        LOG.debug(\"Creating Alluxio Master executor\");\n        executorBuilder\n            .setName(\"Alluxio Master Executor\")\n            .setSource(\"master\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getMasterRequiredResources(masterCpu, masterMem);\n        mMasterHostname = offer.getHostname();\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n        mMasterCount++;\n        mMasterTaskId = mLaunchedTasks;\n      } else if (mMasterLaunched\n          && !mWorkers.contains(offer.getHostname())\n          && offerCpu >= workerCpu\n          && offerMem >= workerMem\n          && OfferUtils.hasAvailableWorkerPorts(offer)) {\n        LOG.debug(\"Creating Alluxio Worker executor\");\n        final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n        executorBuilder\n            .setName(\"Alluxio Worker Executor\")\n            .setSource(\"worker\")\n            .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n            .addAllResources(getExecutorResources())\n            .setCommand(\n                Protos.CommandInfo\n                    .newBuilder()\n                    .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                    .addAllUris(getExecutorDependencyURIList())\n                    .setEnvironment(\n                        Protos.Environment\n                            .newBuilder()\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                    .build())\n                            .addVariables(\n                                Protos.Environment.Variable.newBuilder()\n                                    .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                    .build())\n                            .build()));\n        // pre-build resource list here, then use it to build Protos.Task later.\n        resources = getWorkerRequiredResources(workerCpu, workerMem);\n        mWorkers.add(offer.getHostname());\n        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n      } else {\n        // The resource offer cannot be used to start either master or a worker.\n        LOG.info(\"Declining offer {}\", offer.getId().getValue());\n        driver.declineOffer(offer.getId());\n        continue;\n      }\n\n      Protos.TaskID taskId =\n          Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n      LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n      Protos.TaskInfo task =\n          Protos.TaskInfo\n              .newBuilder()\n              .setName(mTaskName)\n              .setTaskId(taskId)\n              .setSlaveId(offer.getSlaveId())\n              .addAllResources(resources)\n              .setExecutor(executorBuilder).build();\n\n      launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n      mLaunchedTasks++;\n\n      // NOTE: We use the new API `acceptOffers` here to launch tasks.\n      // The 'launchTasks' API will be deprecated.\n      List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n      offerIds.add(offer.getId());\n      List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n      Protos.Offer.Operation operation =\n          Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n              .setLaunch(launch).build();\n      operations.add(operation);\n      Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n      driver.acceptOffers(offerIds, operations, filters);\n    }\n  }","commit_id":"948c07a940e4531821f20ebe5c21ddb0714a7a18","url":"https://github.com/amplab/tachyon"},{"original_method":"public ExportPlotSizeEditor(int initialWidth, \n                               int initialHeight,\n                               boolean keepRatio,\n                               Widget extraWidget,\n                               PlotsServerOperations server,\n                               final Observer observer)\n   {\n      // alias objects and resources\n      server_ = server;\n      ExportPlotResources resources = ExportPlotResources.INSTANCE;\n           \n      // main widget\n      VerticalPanel verticalPanel = new VerticalPanel();\n           \n      // if we have an extra widget then enclose it within a horizontal\n      // panel with it on the left and the options on the right\n      HorizontalPanel topPanel = new HorizontalPanel();\n      CellPanel optionsPanel = null;\n      HorizontalPanel widthAndHeightPanel = null;\n      if (extraWidget != null)\n      {\n         topPanel.setWidth(\"100%\");\n         \n         topPanel.add(extraWidget);\n         topPanel.setCellHorizontalAlignment(extraWidget, \n                                             HasHorizontalAlignment.ALIGN_LEFT);\n         \n         optionsPanel = new VerticalPanel();\n         optionsPanel.setStylePrimaryName(\n                                    resources.styles().verticalSizeOptions());\n         optionsPanel.setSpacing(0);\n         topPanel.add(optionsPanel);\n         topPanel.setCellHorizontalAlignment(\n                                       optionsPanel,\n                                       HasHorizontalAlignment.ALIGN_RIGHT);\n         \n         widthAndHeightPanel = new HorizontalPanel();\n         widthAndHeightPanel.setStylePrimaryName(\n                                    resources.styles().widthAndHeightEntry());\n         configureHorizontalOptionsPanel(widthAndHeightPanel);\n         optionsPanel.add(widthAndHeightPanel);\n      }\n      else\n      {\n         optionsPanel = topPanel ;\n         optionsPanel.setStylePrimaryName(\n                                 resources.styles().horizontalSizeOptions());\n         widthAndHeightPanel = topPanel;\n         configureHorizontalOptionsPanel(topPanel);  \n      }\n          \n      // image width\n      widthAndHeightPanel.add(createImageOptionLabel(\"Width:\"));\n      widthTextBox_ = createImageSizeTextBox();\n      widthTextBox_.addChangeHandler(new ChangeHandler() {\n         @Override\n         public void onChange(ChangeEvent event)\n         {\n            // screen out programmatic sets\n            if (settingDimenensionInProgress_)\n               return;\n            \n            // enforce min size\n            int width = constrainWidth(getImageWidth());\n           \n            // preserve aspect ratio if requested\n            if (getKeepRatio())\n            {  \n               double ratio = (double)lastHeight_ / (double)lastWidth_;\n               int height = constrainHeight((int) (ratio * (double)width));\n               setHeightTextBox(height);\n            }\n  \n            // set width\n            setWidthTextBox(width);\n         }\n         \n      });\n      widthAndHeightPanel.add(widthTextBox_);\n     \n      // image height\n      widthAndHeightPanel.add(new HTML(\"&nbsp;&nbsp;\"));\n      widthAndHeightPanel.add(createImageOptionLabel(\"Height:\"));\n      heightTextBox_ = createImageSizeTextBox();\n      heightTextBox_.addChangeHandler(new ChangeHandler() {\n         @Override\n         public void onChange(ChangeEvent event)\n         {\n            // screen out programmatic sets\n            if (settingDimenensionInProgress_)\n               return;\n            \n            // enforce min size\n            int height = constrainHeight(getImageHeight());\n            \n            // preserve aspect ratio if requested\n            if (getKeepRatio())\n            {\n               double ratio = (double)lastWidth_ / (double)lastHeight_;\n               int width = constrainWidth((int) (ratio * (double)height));\n               setWidthTextBox(width);\n            }\n           \n            // always set height\n            setHeightTextBox(height);\n         }\n         \n      });\n      widthAndHeightPanel.add(heightTextBox_);\n      \n      // add width and height panel to options panel container if necessary\n      if (widthAndHeightPanel != optionsPanel)\n         optionsPanel.add(widthAndHeightPanel);\n  \n      // lock ratio check box\n      keepRatioCheckBox_ = new CheckBox();\n      keepRatioCheckBox_.setStylePrimaryName(\n                           resources.styles().maintainAspectRatioCheckBox());\n      keepRatioCheckBox_.setValue(keepRatio);\n      keepRatioCheckBox_.setText(\"Maintain aspect ratio\");\n      optionsPanel.add(keepRatioCheckBox_);\n      \n      // image and sizer in layout panel (create now so we can call\n      // setSize in update button click handler)\n      final LayoutPanel previewPanel = new LayoutPanel(); \n     \n      \n      // update button\n      ThemedButton updateButton = new ThemedButton(\"Update Preview\", \n                                                    new ClickHandler(){\n         public void onClick(ClickEvent event) \n         {\n            previewPanel.setSize((getImageWidth() + IMAGE_INSET) + \"px\", \n                                (getImageHeight() + IMAGE_INSET) + \"px\");\n            updateImage();\n            \n            observer.onPlotResized(false);\n         }\n      });\n      updateButton.setStylePrimaryName(\n                                 resources.styles().updateImageSizeButton());\n      optionsPanel.add(updateButton);\n\n      // add top panel\n      verticalPanel.add(topPanel);\n         \n      // image frame\n      imageFrame_ = new ImageFrame();\n      imageFrame_.setUrl(\"about:blank\");\n      imageFrame_.setSize(\"100%\", \"100%\");\n      imageFrame_.setMarginHeight(0);\n      imageFrame_.setMarginWidth(0);\n      imageFrame_.setStylePrimaryName(resources.styles().imagePreview());\n      previewPanel.add(imageFrame_);\n      previewPanel.setWidgetLeftRight(imageFrame_, \n                                      0, Unit.PX, \n                                      IMAGE_INSET, Unit.PX);\n      previewPanel.setWidgetTopBottom(imageFrame_, \n                                      0, Unit.PX, \n                                      IMAGE_INSET, Unit.PX);\n      previewPanel.getWidgetContainerElement(\n                     imageFrame_).getStyle().setOverflow(Overflow.VISIBLE);\n      \n      // Stops mouse events from being routed to the iframe, which would\n      // interfere with resizing\n      FlowPanel imageSurface = new FlowPanel();\n      imageSurface.setSize(\"100%\", \"100%\");\n      previewPanel.add(imageSurface);\n      previewPanel.setWidgetTopBottom(imageSurface, 0, Unit.PX, 0, Unit.PX);\n      previewPanel.setWidgetLeftRight(imageSurface, 0, Unit.PX, 0, Unit.PX);\n      \n      // resize gripper\n      ResizeGripper gripper = new ResizeGripper(new ResizeGripper.Observer() \n      {\n         @Override\n         public void onResizingStarted()\n         {    \n            int startWidth = getImageWidth();\n            int startHeight = getImageHeight();\n            \n            widthAspectRatio_ = (double)startWidth / (double)startHeight;\n            heightAspectRatio_ = (double)startHeight / (double)startWidth;\n         }\n         \n         @Override\n         public void onResizing(int xDelta, int yDelta)\n         {\n            // get start width and height\n            int startWidth = getImageWidth();\n            int startHeight = getImageHeight();\n            \n            // calculate new height and width \n            int newWidth = constrainWidth(startWidth + xDelta);\n            int newHeight = constrainHeight(startHeight + yDelta);\n            \n            // preserve aspect ratio if requested\n            if (getKeepRatio())\n            {\n               if (Math.abs(xDelta) > Math.abs(yDelta))\n                  newHeight = (int) (heightAspectRatio_ * (double)newWidth);\n               else\n                  newWidth = (int) (widthAspectRatio_ * (double)newHeight);\n            }\n            \n            // set text boxes\n            setWidthTextBox(newWidth);\n            setHeightTextBox(newHeight);  \n            \n            // set image preview size\n            previewPanel.setSize(newWidth + IMAGE_INSET + \"px\", \n                                 newHeight + IMAGE_INSET + \"px\");\n         }\n\n         @Override\n         public void onResizingCompleted()\n         {\n            updateImage();\n            observer.onPlotResized(true);\n         } \n         \n         private double widthAspectRatio_ = 1.0;\n         private double heightAspectRatio_ = 1.0;\n      });\n      \n      // layout gripper\n      previewPanel.add(gripper);\n      previewPanel.setWidgetRightWidth(gripper, \n                                      0, Unit.PX, \n                                      gripper.getImageWidth(), Unit.PX);\n      previewPanel.setWidgetBottomHeight(gripper, \n                                        0, Unit.PX, \n                                        gripper.getImageHeight(), Unit.PX);\n     \n      // constrain dimensions\n      initialWidth = constrainWidth(initialWidth);\n      initialHeight = constrainHeight(initialHeight);\n            \n      // initialie text boxes\n      setWidthTextBox(initialWidth);\n      setHeightTextBox(initialHeight);\n \n      // initialize preview\n      previewPanel.setSize((initialWidth + IMAGE_INSET) + \"px\", \n                          (initialHeight + IMAGE_INSET) + \"px\");\n      \n      verticalPanel.add(previewPanel);\n      \n      // set initial focus widget\n      if (extraWidget == null)\n         initialFocusWidget_ = widthTextBox_;\n      else\n         initialFocusWidget_ = null;\n     \n      initWidget(verticalPanel);\n     \n   }","id":80357,"modified_method":"public ExportPlotSizeEditor(int initialWidth, \n                               int initialHeight,\n                               boolean keepRatio,\n                               Widget extraWidget,\n                               PlotsServerOperations server,\n                               final Observer observer)\n   {\n      // alias objects and resources\n      server_ = server;\n      ExportPlotResources resources = ExportPlotResources.INSTANCE;\n           \n      // main widget\n      VerticalPanel verticalPanel = new VerticalPanel();\n           \n      // if we have an extra widget then enclose it within a horizontal\n      // panel with it on the left and the options on the right\n      HorizontalPanel topPanel = new HorizontalPanel();\n      CellPanel optionsPanel = null;\n      HorizontalPanel widthAndHeightPanel = null;\n      if (extraWidget != null)\n      {\n         topPanel.setWidth(\"100%\");\n         \n         topPanel.add(extraWidget);\n         topPanel.setCellHorizontalAlignment(extraWidget, \n                                             HasHorizontalAlignment.ALIGN_LEFT);\n         \n         optionsPanel = new VerticalPanel();\n         optionsPanel.setStylePrimaryName(\n                                    resources.styles().verticalSizeOptions());\n         optionsPanel.setSpacing(0);\n         topPanel.add(optionsPanel);\n         topPanel.setCellHorizontalAlignment(\n                                       optionsPanel,\n                                       HasHorizontalAlignment.ALIGN_RIGHT);\n         \n         widthAndHeightPanel = new HorizontalPanel();\n         widthAndHeightPanel.setStylePrimaryName(\n                                    resources.styles().widthAndHeightEntry());\n         configureHorizontalOptionsPanel(widthAndHeightPanel);\n         optionsPanel.add(widthAndHeightPanel);\n      }\n      else\n      {\n         optionsPanel = topPanel ;\n         optionsPanel.setStylePrimaryName(\n                                 resources.styles().horizontalSizeOptions());\n         widthAndHeightPanel = topPanel;\n         configureHorizontalOptionsPanel(topPanel);  \n      }\n          \n      // image width\n      widthAndHeightPanel.add(createImageOptionLabel(\"Width:\"));\n      widthTextBox_ = createImageSizeTextBox();\n      widthTextBox_.addChangeHandler(new ChangeHandler() {\n         @Override\n         public void onChange(ChangeEvent event)\n         {\n            // screen out programmatic sets\n            if (settingDimenensionInProgress_)\n               return;\n            \n            // enforce min size\n            int width = constrainWidth(getImageWidth());\n           \n            // preserve aspect ratio if requested\n            if (getKeepRatio())\n            {  \n               double ratio = (double)lastHeight_ / (double)lastWidth_;\n               int height = constrainHeight((int) (ratio * (double)width));\n               setHeightTextBox(height);\n            }\n  \n            // set width\n            setWidthTextBox(width);\n         }\n         \n      });\n      widthAndHeightPanel.add(widthTextBox_);\n     \n      // image height\n      widthAndHeightPanel.add(new HTML(\"&nbsp;&nbsp;\"));\n      widthAndHeightPanel.add(createImageOptionLabel(\"Height:\"));\n      heightTextBox_ = createImageSizeTextBox();\n      heightTextBox_.addChangeHandler(new ChangeHandler() {\n         @Override\n         public void onChange(ChangeEvent event)\n         {\n            // screen out programmatic sets\n            if (settingDimenensionInProgress_)\n               return;\n            \n            // enforce min size\n            int height = constrainHeight(getImageHeight());\n            \n            // preserve aspect ratio if requested\n            if (getKeepRatio())\n            {\n               double ratio = (double)lastWidth_ / (double)lastHeight_;\n               int width = constrainWidth((int) (ratio * (double)height));\n               setWidthTextBox(width);\n            }\n           \n            // always set height\n            setHeightTextBox(height);\n         }\n         \n      });\n      widthAndHeightPanel.add(heightTextBox_);\n      \n      // add width and height panel to options panel container if necessary\n      if (widthAndHeightPanel != optionsPanel)\n         optionsPanel.add(widthAndHeightPanel);\n  \n      // lock ratio check box\n      keepRatioCheckBox_ = new CheckBox();\n      keepRatioCheckBox_.setStylePrimaryName(\n                           resources.styles().maintainAspectRatioCheckBox());\n      keepRatioCheckBox_.setValue(keepRatio);\n      keepRatioCheckBox_.setText(\"Maintain aspect ratio\");\n      optionsPanel.add(keepRatioCheckBox_);\n      \n      // image and sizer in layout panel (create now so we can call\n      // setSize in update button click handler)\n      final LayoutPanel previewPanel = new LayoutPanel(); \n     \n      \n      // update button\n      ThemedButton updateButton = new ThemedButton(\"Update Preview\", \n                                                    new ClickHandler(){\n         public void onClick(ClickEvent event) \n         {\n            previewPanel.setSize((getImageWidth() + IMAGE_INSET) + \"px\", \n                                (getImageHeight() + IMAGE_INSET) + \"px\");\n            updateImage();\n            \n            observer.onPlotResized(false);\n         }\n      });\n      updateButton.setStylePrimaryName(\n                                 resources.styles().updateImageSizeButton());\n      optionsPanel.add(updateButton);\n\n      // add top panel\n      verticalPanel.add(topPanel);\n\n      // image frame\n      imageFrame_ = new ImageFrame();\n      imageFrame_.setUrl(\"about:blank\");\n      imageFrame_.setSize(\"100%\", \"100%\");\n      imageFrame_.setMarginHeight(0);\n      imageFrame_.setMarginWidth(0);\n      imageFrame_.setStylePrimaryName(resources.styles().imagePreview());\n\n      // Stops mouse events from being routed to the iframe, which would\n      // interfere with resizing\n      final GlassPanel glassPanel = new GlassPanel(imageFrame_);\n      glassPanel.setSize(\"100%\", \"100%\");\n\n      previewPanel.add(glassPanel);\n      previewPanel.setWidgetLeftRight(glassPanel,\n                                      0, Unit.PX, \n                                      IMAGE_INSET, Unit.PX);\n      previewPanel.setWidgetTopBottom(glassPanel,\n                                      0, Unit.PX, \n                                      IMAGE_INSET, Unit.PX);\n      previewPanel.getWidgetContainerElement(\n                     glassPanel).getStyle().setOverflow(Overflow.VISIBLE);\n      \n      // resize gripper\n      ResizeGripper gripper = new ResizeGripper(new ResizeGripper.Observer() \n      {\n         @Override\n         public void onResizingStarted()\n         {    \n            int startWidth = getImageWidth();\n            int startHeight = getImageHeight();\n            \n            widthAspectRatio_ = (double)startWidth / (double)startHeight;\n            heightAspectRatio_ = (double)startHeight / (double)startWidth;\n\n            glassPanel.setGlass(true);\n         }\n         \n         @Override\n         public void onResizing(int xDelta, int yDelta)\n         {\n            // get start width and height\n            int startWidth = getImageWidth();\n            int startHeight = getImageHeight();\n            \n            // calculate new height and width \n            int newWidth = constrainWidth(startWidth + xDelta);\n            int newHeight = constrainHeight(startHeight + yDelta);\n            \n            // preserve aspect ratio if requested\n            if (getKeepRatio())\n            {\n               if (Math.abs(xDelta) > Math.abs(yDelta))\n                  newHeight = (int) (heightAspectRatio_ * (double)newWidth);\n               else\n                  newWidth = (int) (widthAspectRatio_ * (double)newHeight);\n            }\n            \n            // set text boxes\n            setWidthTextBox(newWidth);\n            setHeightTextBox(newHeight);  \n            \n            // set image preview size\n            previewPanel.setSize(newWidth + IMAGE_INSET + \"px\", \n                                 newHeight + IMAGE_INSET + \"px\");\n         }\n\n         @Override\n         public void onResizingCompleted()\n         {\n            glassPanel.setGlass(false);\n            updateImage();\n            observer.onPlotResized(true);\n         } \n         \n         private double widthAspectRatio_ = 1.0;\n         private double heightAspectRatio_ = 1.0;\n      });\n      \n      // layout gripper\n      previewPanel.add(gripper);\n      previewPanel.setWidgetRightWidth(gripper, \n                                      0, Unit.PX, \n                                      gripper.getImageWidth(), Unit.PX);\n      previewPanel.setWidgetBottomHeight(gripper, \n                                        0, Unit.PX, \n                                        gripper.getImageHeight(), Unit.PX);\n     \n      // constrain dimensions\n      initialWidth = constrainWidth(initialWidth);\n      initialHeight = constrainHeight(initialHeight);\n            \n      // initialie text boxes\n      setWidthTextBox(initialWidth);\n      setHeightTextBox(initialHeight);\n \n      // initialize preview\n      previewPanel.setSize((initialWidth + IMAGE_INSET) + \"px\", \n                          (initialHeight + IMAGE_INSET) + \"px\");\n      \n      verticalPanel.add(previewPanel);\n      \n      // set initial focus widget\n      if (extraWidget == null)\n         initialFocusWidget_ = widthTextBox_;\n      else\n         initialFocusWidget_ = null;\n     \n      initWidget(verticalPanel);\n     \n   }","commit_id":"c2b411fdce3809db4cf4cf728b79dd28ea0903eb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public HasSelectionCommitHandlers<CompilePdfError> errorList()\n   {\n      return this;\n   }","id":80358,"modified_method":"@Override\n   public HasSelectionCommitHandlers<CodeNavigationTarget> errorList()\n   {\n      return this;\n   }","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void clearAll()\n   {\n      outputWidget_.clearOutput();\n      lbErrors_.clear();\n      panel_.setWidget(outputWidget_);  \n   }","id":80359,"modified_method":"@Override\n   public void clearAll()\n   {\n      outputWidget_.clearOutput();\n      errorTable_.clear();\n      setWidths();\n      panel_.setWidget(outputWidget_);  \n   }","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showErrors(JsArray<CompilePdfError> errors)\n   {\n      errors_ = errors;\n      \n      lbErrors_.clear();\n      for (int i=0; i<errors.length(); i++)\n         lbErrors_.addItem(errors.get(i).asString(),\n                           errors.get(i).toSource());\n      \n      panel_.setWidget(lbErrors_);\n   }","id":80360,"modified_method":"@Override\n   public void showErrors(JsArray<CompilePdfError> errors)\n   {\n      ArrayList<CompilePdfError> errorList = new ArrayList<CompilePdfError>();\n      for (CompilePdfError error : JsUtil.asIterable(errors))\n         errorList.add(error);\n\n      errorTable_.addItems(errorList, false);\n      panel_.setWidget(errorPanel_);\n   }","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Widget createMainWidget()\n   {\n      panel_ = new SimplePanel();\n      \n      outputWidget_ = new ShellWidget(new AceEditor());\n      outputWidget_.setSize(\"100%\", \"100%\");\n      outputWidget_.setMaxOutputLines(1000);\n      outputWidget_.setReadOnly(true);\n      outputWidget_.setSuppressPendingInput(true);\n      panel_.setWidget(outputWidget_);\n      \n      lbErrors_ = new ListBox();\n      lbErrors_.setVisibleItemCount(100);\n      lbErrors_.setSize(\"100%\", \"100%\");\n      lbErrors_.addDoubleClickHandler(new DoubleClickHandler() \n      {\n         @Override\n         public void onDoubleClick(DoubleClickEvent event)\n         {\n            CompilePdfError error = errors_.get(lbErrors_.getSelectedIndex());  \n            SelectionCommitEvent.fire(CompilePdfOutputPane.this, error);\n         }\n      });\n      \n      return panel_;\n   }","id":80361,"modified_method":"@Override\n   protected Widget createMainWidget()\n   {\n      res_ = GWT.create(CompilePdfOutputResources.class);\n\n      panel_ = new SimplePanel();\n      \n      outputWidget_ = new ShellWidget(new AceEditor());\n      outputWidget_.setSize(\"100%\", \"100%\");\n      outputWidget_.setMaxOutputLines(1000);\n      outputWidget_.setReadOnly(true);\n      outputWidget_.setSuppressPendingInput(true);\n      panel_.setWidget(outputWidget_);\n\n      errorTable_ = new FastSelectTable<CompilePdfError, CodeNavigationTarget, Object>(\n            new CompilePdfErrorItemCodec(res_),\n            res_.styles().selectedRow(),\n            true,\n            false);\n      setWidths();\n      errorTable_.setStyleName(res_.styles().table());\n      errorTable_.setSize(\"100%\", \"100%\");\n      errorTable_.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (doubleClick_.checkForDoubleClick(event.getNativeEvent()))\n            {\n               ArrayList<CodeNavigationTarget> values =\n                                                errorTable_.getSelectedValues();\n               if (values.size() == 1)\n               {\n                  SelectionCommitEvent.fire(CompilePdfOutputPane.this,\n                                            values.get(0));\n               }\n            }\n         }\n         private final DoubleClickState doubleClick_ = new DoubleClickState();\n      });\n      errorPanel_ = new ScrollPanel(errorTable_);\n      errorPanel_.setSize(\"100%\", \"100%\");\n\n      return panel_;\n   }","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public HandlerRegistration addSelectionCommitHandler(\n                           SelectionCommitHandler<CompilePdfError> handler)\n   {\n      return addHandler(handler, SelectionCommitEvent.getType());\n   }","id":80362,"modified_method":"@Override\n   public HandlerRegistration addSelectionCommitHandler(\n                           SelectionCommitHandler<CodeNavigationTarget> handler)\n   {\n      return addHandler(handler, SelectionCommitEvent.getType());\n   }","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"HasSelectionCommitHandlers<CompilePdfError> errorList();","id":80363,"modified_method":"HasSelectionCommitHandlers<CodeNavigationTarget> errorList();","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public CompilePdfOutputPresenter(Display view,\n                                    GlobalDisplay globalDisplay,\n                                    CompilePdfServerOperations server,\n                                    FileTypeRegistry fileTypeRegistry)\n   {\n      super(view);\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      fileTypeRegistry_ = fileTypeRegistry;\n      \n      view_.stopButton().addClickHandler(new ClickHandler() {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            terminateCompilePdf(null);\n         }\n         \n      });\n      \n      view_.errorList().addSelectionCommitHandler(\n                              new SelectionCommitHandler<CompilePdfError>() {\n\n         @Override\n         public void onSelectionCommit(\n                              SelectionCommitEvent<CompilePdfError> event)\n         {\n            CompilePdfError error = event.getSelectedItem();\n            FileSystemItem fsi = FileSystemItem.createFile(error.getPath());\n            FilePosition pos = FilePosition.create(error.getLine(), 1);\n            fileTypeRegistry_.editFile(fsi, pos);\n         }\n      });\n   }","id":80364,"modified_method":"@Inject\n   public CompilePdfOutputPresenter(Display view,\n                                    GlobalDisplay globalDisplay,\n                                    CompilePdfServerOperations server,\n                                    FileTypeRegistry fileTypeRegistry)\n   {\n      super(view);\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      fileTypeRegistry_ = fileTypeRegistry;\n      \n      view_.stopButton().addClickHandler(new ClickHandler() {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            terminateCompilePdf(null);\n         }\n         \n      });\n      \n      view_.errorList().addSelectionCommitHandler(\n                              new SelectionCommitHandler<CodeNavigationTarget>() {\n\n         @Override\n         public void onSelectionCommit(\n                              SelectionCommitEvent<CodeNavigationTarget> event)\n         {\n            CodeNavigationTarget target = event.getSelectedItem();\n            FileSystemItem fsi = FileSystemItem.createFile(target.getFile());\n            fileTypeRegistry_.editFile(fsi, target.getPosition());\n         }\n      });\n   }","commit_id":"d1bfc5e642df364f4fb508f7966a389cd46ba4fa","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public SidePanel(WebTransMessages messages)\n   {\n      transUnitDetailContainer = new LayoutPanel();\n      validationDetailContainer = new LayoutPanel();\n\n      this.messages = messages;\n\n      rootPanel = uiBinder.createAndBindUi(this);\n      initWidget(rootPanel);\n\n      mainPanel.add(transUnitDetailContainer, messages.transUnitDetailsHeading(), 20);\n      mainPanel.add(validationDetailContainer, messages.validationDetailsHeading(), 20);\n   }","id":80365,"modified_method":"@Inject\n   public SidePanel(WebTransMessages messages)\n   {\n      validationDetailContainer = new LayoutPanel();\n\n      this.messages = messages;\n\n      rootPanel = uiBinder.createAndBindUi(this);\n      initWidget(rootPanel);\n\n      mainPanel.add(validationDetailContainer, messages.validationDetailsHeading(), 20);\n   }","commit_id":"a89011f3cc041b89053a822924f052e20d879f8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public SidePanelPresenter(final Display display, final EventBus eventBus, CachingDispatchAsync dispatcher, final TransUnitDetailsPresenter transUnitDetailsPresenter, final ValidationDetailsPresenter validationDetailsPresenter, final TransFilterPresenter transFilterPresenter)\n   {\n      super(display, eventBus);\n      this.transUnitDetailsPresenter = transUnitDetailsPresenter;\n      this.validationDetailsPresenter = validationDetailsPresenter;\n      this.dispatcher = dispatcher;\n   }","id":80366,"modified_method":"@Inject\n   public SidePanelPresenter(final Display display, final EventBus eventBus, CachingDispatchAsync dispatcher, final ValidationDetailsPresenter validationDetailsPresenter, final TransFilterPresenter transFilterPresenter)\n   {\n      super(display, eventBus);\n      this.validationDetailsPresenter = validationDetailsPresenter;\n      this.dispatcher = dispatcher;\n   }","commit_id":"a89011f3cc041b89053a822924f052e20d879f8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      transUnitDetailsPresenter.bind();\n      display.setTransUnitDetailView(transUnitDetailsPresenter.getDisplay().asWidget());\n\n      validationDetailsPresenter.bind();\n      display.setValidationDetailView(validationDetailsPresenter.getDisplay().asWidget());\n   }","id":80367,"modified_method":"@Override\n   protected void onBind()\n   {\n      validationDetailsPresenter.bind();\n      display.setValidationDetailView(validationDetailsPresenter.getDisplay().asWidget());\n   }","commit_id":"a89011f3cc041b89053a822924f052e20d879f8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void add(Widget w)\n   {\n      rightPanel.add(w);\n   }","id":80368,"modified_method":"public void add(Widget w)\n   {\n      topRightPanel.add(w);\n   }","commit_id":"a89011f3cc041b89053a822924f052e20d879f8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public SourcePanel(TransUnit value, NavigationMessages messages)\n   {\n      this.value = value;\n      panel = new HorizontalPanel();\n      panel.setSize(\"100%\", \"100%\");\n\n      initWidget(panel);\n      setStylePrimaryName(\"TableEditorSource\");\n\n      rightPanel = new HorizontalPanel();\n      rightPanel.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_RIGHT);\n      rightPanel.setSize(\"100%\", \"100%\");\n\n      sourceLabel = new HighlightingLabel(value.getSource());\n      sourceLabel.setStylePrimaryName(\"TableEditorContent\");\n      sourceLabel.setTitle(messages.sourceCommentLabel() + value.getSourceComment());\n\n      panel.add(sourceLabel);\n      panel.add(rightPanel);\n   }","id":80369,"modified_method":"public SourcePanel(TransUnit value, TableResources resources, NavigationMessages messages)\n   {\n      this.value = value;\n      panel = new VerticalPanel();\n      panel.setSize(\"100%\", \"100%\");\n\n      topPanel = new HorizontalPanel();\n      topPanel.setSize(\"100%\", \"100%\");\n\n      initWidget(panel);\n      setStylePrimaryName(\"TableEditorSource\");\n\n      topRightPanel = new HorizontalPanel();\n      topRightPanel.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_RIGHT);\n      topRightPanel.setSize(\"100%\", \"100%\");\n\n      sourceLabel = new HighlightingLabel(value.getSource());\n      sourceLabel.setStylePrimaryName(\"TableEditorContent\");\n      sourceLabel.setTitle(messages.sourceCommentLabel() + value.getSourceComment());\n\n      topPanel.add(sourceLabel);\n      topPanel.add(topRightPanel);\n\n      transUnitDetailsPanel = new TransUnitDetailsPanel(resources, messages, value);\n      transUnitDetailsPanel.setHeader(messages.transUnitDetailsHeading());\n\n      panel.add(topPanel);\n      panel.add(transUnitDetailsPanel);\n   }","commit_id":"a89011f3cc041b89053a822924f052e20d879f8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * The Binding EDSL is described in {@link com.google.inject.Binder}\n    */\n   @Override\n   protected void configure()\n   {\n      bind(EventBus.class).to(DefaultEventBus.class).in(Singleton.class);\n      bind(EventProcessor.class).in(Singleton.class);\n      bind(Resources.class).in(Singleton.class);\n      bind(WebTransMessages.class).in(Singleton.class);\n      bind(ValidationService.class).in(Singleton.class);\n\n      bindPresenter(AppPresenter.class, AppPresenter.Display.class, AppView.class);\n      bindPresenter(DocumentListPresenter.class, DocumentListPresenter.Display.class, DocumentListView.class);\n      bindPresenter(TranslationPresenter.class, TranslationPresenter.Display.class, TranslationView.class);\n      bindPresenter(TransFilterPresenter.class, TransFilterPresenter.Display.class, TransFilterView.class);\n      bindPresenter(TableEditorPresenter.class, TableEditorPresenter.Display.class, TableEditorView.class);\n      bindPresenter(WorkspaceUsersPresenter.class, WorkspaceUsersPresenter.Display.class, WorkspaceUsersView.class);\n      bindPresenter(TransMemoryPresenter.class, TransMemoryPresenter.Display.class, TransMemoryView.class);\n      bindPresenter(GlossaryPresenter.class, GlossaryPresenter.Display.class, GlossaryView.class);\n      bindPresenter(TransMemoryDetailsPresenter.class, TransMemoryDetailsPresenter.Display.class, TransMemoryDetailsView.class);\n      bindPresenter(TransUnitNavigationPresenter.class, TransUnitNavigationPresenter.Display.class, TransUnitNavigationView.class);\n      bindPresenter(SidePanelPresenter.class, SidePanelPresenter.Display.class, SidePanel.class);\n      bindPresenter(TranslationEditorPresenter.class, TranslationEditorPresenter.Display.class, TranslationEditorView.class);\n      bindPresenter(TransUnitDetailsPresenter.class, TransUnitDetailsPresenter.Display.class, TransUnitDetailsView.class);\n      bindPresenter(ValidationDetailsPresenter.class, ValidationDetailsPresenter.Display.class, ValidationDetailsView.class);\n      bindPresenter(UndoRedoPresenter.class, UndoRedoPresenter.Display.class, UndoRedoView.class);\n\n      bind(HasPageNavigation.class).to(TableEditorView.class).in(Singleton.class);\n\n      // NB: if we bind directly to SeamDispatchAsync, we can't use\n      // replace-class in\n      // the module definition unless the replacement extends SeamDispatchAsync\n      bind(CachingDispatchAsync.class).to(DelegatingDispatchAsync.class).in(Singleton.class);\n\n      bind(Identity.class).toProvider(IdentityProvider.class).in(Singleton.class);\n      bind(WorkspaceContext.class).toProvider(WorkspaceContextProvider.class).in(Singleton.class);\n\n   }","id":80370,"modified_method":"/**\n    * The Binding EDSL is described in {@link com.google.inject.Binder}\n    */\n   @Override\n   protected void configure()\n   {\n      bind(EventBus.class).to(DefaultEventBus.class).in(Singleton.class);\n      bind(EventProcessor.class).in(Singleton.class);\n      bind(Resources.class).in(Singleton.class);\n      bind(WebTransMessages.class).in(Singleton.class);\n      bind(ValidationService.class).in(Singleton.class);\n\n      bindPresenter(AppPresenter.class, AppPresenter.Display.class, AppView.class);\n      bindPresenter(DocumentListPresenter.class, DocumentListPresenter.Display.class, DocumentListView.class);\n      bindPresenter(TranslationPresenter.class, TranslationPresenter.Display.class, TranslationView.class);\n      bindPresenter(TransFilterPresenter.class, TransFilterPresenter.Display.class, TransFilterView.class);\n      bindPresenter(TableEditorPresenter.class, TableEditorPresenter.Display.class, TableEditorView.class);\n      bindPresenter(WorkspaceUsersPresenter.class, WorkspaceUsersPresenter.Display.class, WorkspaceUsersView.class);\n      bindPresenter(TransMemoryPresenter.class, TransMemoryPresenter.Display.class, TransMemoryView.class);\n      bindPresenter(GlossaryPresenter.class, GlossaryPresenter.Display.class, GlossaryView.class);\n      bindPresenter(TransMemoryDetailsPresenter.class, TransMemoryDetailsPresenter.Display.class, TransMemoryDetailsView.class);\n      bindPresenter(TransUnitNavigationPresenter.class, TransUnitNavigationPresenter.Display.class, TransUnitNavigationView.class);\n      bindPresenter(SidePanelPresenter.class, SidePanelPresenter.Display.class, SidePanel.class);\n      bindPresenter(TranslationEditorPresenter.class, TranslationEditorPresenter.Display.class, TranslationEditorView.class);\n      bindPresenter(ValidationDetailsPresenter.class, ValidationDetailsPresenter.Display.class, ValidationDetailsView.class);\n      bindPresenter(UndoRedoPresenter.class, UndoRedoPresenter.Display.class, UndoRedoView.class);\n\n      bind(HasPageNavigation.class).to(TableEditorView.class).in(Singleton.class);\n\n      // NB: if we bind directly to SeamDispatchAsync, we can't use\n      // replace-class in\n      // the module definition unless the replacement extends SeamDispatchAsync\n      bind(CachingDispatchAsync.class).to(DelegatingDispatchAsync.class).in(Singleton.class);\n\n      bind(Identity.class).toProvider(IdentityProvider.class).in(Singleton.class);\n      bind(WorkspaceContext.class).toProvider(WorkspaceContextProvider.class).in(Singleton.class);\n\n   }","commit_id":"a89011f3cc041b89053a822924f052e20d879f8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void executeSQL (Table table, Row row, String action)\n    {\n        if (config.getScriptWriter() != null)\n      {\n        if (action.equals(\"delete\"))\n          config.getScriptWriter().println(prepareDeleteStatement(row, false) + config.getStatementTerminator());\n        else if (action.equals(\"modify\"))\n        config.getScriptWriter().println(prepareUpdateStatement(row) + config.getStatementTerminator());\n        else if (action.equals(\"insert\"))\n        config.getScriptWriter().println(prepareInsertStatement(row, false) + config.getStatementTerminator());\n      }\n\n      if (supportsPreparedStatements)\n      {\n        String preparedStatement = \"\";\n        PreparedStatement pstmt = null;\n\n        try\n        {\n          if (action.equals(\"delete\"))\n            preparedStatement = prepareDeleteStatement(row, true);\n          else if (action.equals(\"modify\"))\n            preparedStatement = prepareUpdateStatement(row);\n          else if (action.equals(\"insert\"))\n          preparedStatement = prepareInsertStatement(row, true);\n          //config.getLog().println(preparedStatement);\n          pstmt = config.getConnection().prepareStatement(preparedStatement);\n          pstmt.clearParameters ();\n\n          // Loop through parameters and set them, checking for any that excede 4k\n          ArrayList columns = row.getColumns();\n          Iterator iterator = columns.iterator();\n\n          for (int i = 1; iterator.hasNext(); i++)\n          {\n            Column column = (Column)iterator.next();\n            String value = column.getValue();\n\n            // Get a java sql data type for column name\n            int javaSqlDataType = DomUtils.getJavaSqlDataTypeOfColumn(config, table.getName(), column.getName());\n            if (value==null || (value!=null && (value.equalsIgnoreCase(\"NULL\") || value.trim().length() == 0))) {\n              pstmt.setNull(i, javaSqlDataType);\n            }\n            else if (javaSqlDataType == Types.TIMESTAMP)\n            {\n              if (value.equals(\"SYSDATE\"))\n                pstmt.setTimestamp(i, new java.sql.Timestamp(System.currentTimeMillis()));\n              else\n                pstmt.setTimestamp(i, java.sql.Timestamp.valueOf(value));\n            }\n            else\n            {\n              value = value.trim(); // portal can't read xml properly without this, don't know why yet\n              int valueLength = value.length();\n\n              if (valueLength <= 4000)\n              {\n                try\n                {\n                  // Needed for Sybase and maybe others\n                  pstmt.setObject(i, value, javaSqlDataType);\n                }\n                catch (Exception e)\n                {\n                  // Needed for Oracle and maybe others\n                  pstmt.setObject(i, value);\n                }\n              }\n              else\n              {\n                try\n                {\n                  try\n                  {\n                    // Needed for Sybase and maybe others\n                    pstmt.setObject(i, value, javaSqlDataType);\n                  }\n                  catch (Exception e)\n                  {\n                   // Needed for Oracle and maybe others\n                   pstmt.setObject(i, value);\n                  }\n                }\n                catch (SQLException sqle)\n                {\n                  // For Oracle and maybe others\n                  pstmt.setCharacterStream(i, new StringReader(value), valueLength);\n                }\n              }\n            }\n          }\n          pstmt.executeUpdate();\n        }\n        catch (SQLException sqle)\n        {\n          config.getLog().println();\n          config.getLog().println(preparedStatement);\n          config.getLog().println(row.toString());\n          sqle.printStackTrace(config.getLog());\n        }\n        catch (Exception e)\n        {\n          config.getLog().println();\n          e.printStackTrace(config.getLog());\n        }\n        finally\n        {\n          try { if (pstmt != null) pstmt.close();  } catch (Exception e) {}\n        }\n      }\n      else\n      {\n        // If prepared statements aren't supported, try a normal sql statement\n        String statement = \"\";\n        if (action.equals(\"delete\"))\n          statement = prepareDeleteStatement(row, false);\n        else if (action.equals(\"modify\"))\n          statement = prepareUpdateStatement(row);\n        else if (action.equals(\"insert\"))\n          statement = prepareInsertStatement(row, false);\n        Statement stmt = null;\n\n        try\n        {\n          stmt = config.getConnection().createStatement();\n          stmt.executeUpdate(statement);\n        }\n        catch (Exception e)\n        {\n          config.getLog().println();\n          config.getLog().println(statement);\n          e.printStackTrace(config.getLog());\n        }\n        finally\n        {\n          try { if (stmt != null ) stmt.close(); } catch (Exception e) {}\n        }\n      }\n    }","id":80371,"modified_method":"private void executeSQL (Table table, Row row, String action)\n    {\n      dumpSQL(table, row, action);\n\n      if (supportsPreparedStatements)\n      {\n        String preparedStatement = \"\";\n        PreparedStatement pstmt = null;\n\n        try\n        {\n          if (action.equals(\"delete\"))\n            preparedStatement = prepareDeleteStatement(row, true);\n          else if (action.equals(\"modify\"))\n            preparedStatement = prepareUpdateStatement(row);\n          else if (action.equals(\"insert\"))\n          preparedStatement = prepareInsertStatement(row, true);\n          //config.getLog().println(preparedStatement);\n          pstmt = config.getConnection().prepareStatement(preparedStatement);\n          pstmt.clearParameters ();\n\n          // Loop through parameters and set them, checking for any that excede 4k\n          ArrayList columns = row.getColumns();\n          Iterator iterator = columns.iterator();\n\n          for (int i = 1; iterator.hasNext(); i++)\n          {\n            Column column = (Column)iterator.next();\n            String value = column.getValue();\n\n            // Get a java sql data type for column name\n            int javaSqlDataType = DomUtils.getJavaSqlDataTypeOfColumn(config, table.getName(), column.getName());\n            if (value==null || (value!=null && (value.equalsIgnoreCase(\"NULL\") || value.trim().length() == 0))) {\n              pstmt.setNull(i, javaSqlDataType);\n            }\n            else if (javaSqlDataType == Types.TIMESTAMP)\n            {\n              if (value.equals(\"SYSDATE\"))\n                pstmt.setTimestamp(i, new java.sql.Timestamp(System.currentTimeMillis()));\n              else\n                pstmt.setTimestamp(i, java.sql.Timestamp.valueOf(value));\n            }\n            else\n            {\n              value = value.trim(); // portal can't read xml properly without this, don't know why yet\n              int valueLength = value.length();\n\n              if (valueLength <= 4000)\n              {\n                try\n                {\n                  // Needed for Sybase and maybe others\n                  pstmt.setObject(i, value, javaSqlDataType);\n                }\n                catch (Exception e)\n                {\n                  // Needed for Oracle and maybe others\n                  pstmt.setObject(i, value);\n                }\n              }\n              else\n              {\n                try\n                {\n                  try\n                  {\n                    // Needed for Sybase and maybe others\n                    pstmt.setObject(i, value, javaSqlDataType);\n                  }\n                  catch (Exception e)\n                  {\n                   // Needed for Oracle and maybe others\n                   pstmt.setObject(i, value);\n                  }\n                }\n                catch (SQLException sqle)\n                {\n                  // For Oracle and maybe others\n                  pstmt.setCharacterStream(i, new StringReader(value), valueLength);\n                }\n              }\n            }\n          }\n          pstmt.executeUpdate();\n        }\n        catch (SQLException sqle)\n        {\n          config.getLog().println();\n          config.getLog().println(preparedStatement);\n          config.getLog().println(row.toString());\n          sqle.printStackTrace(config.getLog());\n        }\n        catch (Exception e)\n        {\n          config.getLog().println();\n          e.printStackTrace(config.getLog());\n        }\n        finally\n        {\n          try { if (pstmt != null) pstmt.close();  } catch (Exception e) {}\n        }\n      }\n      else\n      {\n        // If prepared statements aren't supported, try a normal sql statement\n        String statement = \"\";\n        if (action.equals(\"delete\"))\n          statement = prepareDeleteStatement(row, false);\n        else if (action.equals(\"modify\"))\n          statement = prepareUpdateStatement(row);\n        else if (action.equals(\"insert\"))\n          statement = prepareInsertStatement(row, false);\n        Statement stmt = null;\n\n        try\n        {\n          stmt = config.getConnection().createStatement();\n          stmt.executeUpdate(statement);\n        }\n        catch (Exception e)\n        {\n          config.getLog().println();\n          config.getLog().println(statement);\n          e.printStackTrace(config.getLog());\n        }\n        finally\n        {\n          try { if (stmt != null ) stmt.close(); } catch (Exception e) {}\n        }\n      }\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"private String prepareUpdateStatement (Row row)\n    {\n\n      StringBuffer sb = new StringBuffer(\"UPDATE \");\n      sb.append(table.getName()).append(\" SET \");\n\n      ArrayList columns = row.getColumns();\n      Iterator iterator = columns.iterator();\n\n      Hashtable setPairs = new Hashtable();\n      Hashtable wherePairs = new Hashtable();\n      String type;\n      Column column;\n\n      while (iterator.hasNext())\n      {\n        column = (Column) iterator.next();\n        type = column.getType();\n\n                   if (type != null && type.equals(\"select\"))\n        {\n          if (DomUtils.getJavaSqlDataTypeOfColumn(config, table.getName(), column.getName()) == Types.INTEGER)\n            wherePairs.put(column.getName(), column.getValue().trim());\n          else\n            wherePairs.put(column.getName(), \"'\" + column.getValue().trim() + \"'\");\n        }\n        else\n        {\n          if (DomUtils.getJavaSqlDataTypeOfColumn(config, table.getName(), column.getName()) == Types.INTEGER)\n            setPairs.put(column.getName(), column.getValue().trim());\n          else\n            setPairs.put(column.getName(), \"'\" + column.getValue().trim() + \"'\");\n        }\n      }\n\n      String nm;\n      String val;\n\n      Enumeration sKeys = setPairs.keys();\n      while (sKeys.hasMoreElements())\n      {\n        nm = (String) sKeys.nextElement();\n        val = (String) setPairs.get(nm);\n        sb.append( nm + \" = \" + sqlEscape(val) + \", \");\n      }\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      sb.append(\" WHERE \");\n\n      Enumeration wKeys = wherePairs.keys();\n      while (wKeys.hasMoreElements())\n      {\n        nm = (String) wKeys.nextElement();\n        val = (String) wherePairs.get(nm);\n        sb.append( nm + \"=\" + sqlEscape(val) + \" and \");\n      }\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      return sb.toString();\n\n    }","id":80372,"modified_method":"private String prepareUpdateStatement (Row row)\n    {\n\n      StringBuffer sb = new StringBuffer(\"UPDATE \");\n      sb.append(table.getName()).append(\" SET \");\n\n      ArrayList columns = row.getColumns();\n      Iterator iterator = columns.iterator();\n\n      Hashtable setPairs = new Hashtable();\n      Hashtable wherePairs = new Hashtable();\n      String type;\n      Column column;\n      int dataType;\n\n      while (iterator.hasNext())\n      {\n        column = (Column) iterator.next();\n        type = column.getType();\n        dataType = DomUtils.getJavaSqlDataTypeOfColumn(\n            config, table.getName(), column.getName());\n\n                   if (type != null && type.equals(\"select\"))\n        {\n          if (dataType == Types.INTEGER || dataType == Types.BIGINT)\n            wherePairs.put(column.getName(), column.getValue().trim());\n          else\n            wherePairs.put(column.getName(), \"'\" + column.getValue().trim() + \"'\");\n        }\n        else\n        {\n          if (dataType == Types.INTEGER || dataType == Types.BIGINT)\n            setPairs.put(column.getName(), column.getValue().trim());\n          else\n            setPairs.put(column.getName(), \"'\" + column.getValue().trim() + \"'\");\n        }\n      }\n\n      String nm;\n      String val;\n\n      Enumeration sKeys = setPairs.keys();\n      while (sKeys.hasMoreElements())\n      {\n        nm = (String) sKeys.nextElement();\n        val = (String) setPairs.get(nm);\n        sb.append( nm + \" = \" + sqlEscape(val) + \", \");\n      }\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      sb.append(\" WHERE \");\n\n      Enumeration wKeys = wherePairs.keys();\n      while (wKeys.hasMoreElements())\n      {\n        nm = (String) wKeys.nextElement();\n        val = (String) wherePairs.get(nm);\n        sb.append( nm + \"=\" + sqlEscape(val) + \" and \");\n      }\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      return sb.toString();\n\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void endElement (String namespaceURI, String localName, String qName) throws SAXException\n    {\n      if (qName.equals(\"data\"))\n        insideData = false;\n      else if (qName.equals(\"table\"))\n        insideTable = false;\n      else if (qName.equals(\"name\"))\n      {\n        insideName = false;\n\n        if (!insideColumn) // table name, log which table\n        {\n            table.setName(charBuff.toString());\n            config.getLog().println(\"  \" + table.getName());\n        }\n        else // column name\n          column.setName(charBuff.toString());\n      }\n      else if (qName.equals(\"row\"))\n      {\n        insideRow = false;\n\n        int sinceMajor = row.getSinceMajor();\n        int sinceMinor = row.getSinceMinor();\n\n        if (sinceMajor == -1) {\n           sinceMajor = table.getSinceMajor();\n           sinceMinor = table.getSinceMinor();\n        }\n        if ((sinceMajor == -1 || config.getUpgradeMajor() == -1)\n            || (sinceMajor > config.getUpgradeMajor()\n                || sinceMinor > config.getUpgradeMinor()))\n        {\n            if (action != null)\n            {\n                if (action.equals(\"delete\"))\n                    executeSQL(table, row, \"delete\");\n                else if (action.equals(\"modify\"))\n                    executeSQL(table, row, \"modify\");\n                else if (action.equals(\"add\"))\n                    executeSQL(table, row, \"insert\");\n            }\n            else if (config.getPopulateTables())\n                executeSQL(table, row, \"insert\");\n        }\n      }\n      else if (qName.equals(\"column\"))\n      {\n        insideColumn = false;\n        if (type != null) column.setType(type);\n        row.addColumn(column);\n      }\n      else if (qName.equals(\"value\"))\n      {\n        insideValue = false;\n\n        if (insideColumn) // column value\n          column.setValue(charBuff.toString());\n      }\n      else if (qName.equals(\"sequence\"))\n      {\n        insideSequence = false;\n        if (insideValue)\n        {\n          // if it's already been generated, return it, otherwise get the next one\n          String name = charBuff.toString();\n          if (sequences.get(name) != null) {\n            charBuff = (StringBuffer)sequences.get(name);\n          } else {\n            try {\n               charBuff = new StringBuffer(SequenceGenerator.instance().getNext(sequenceId));\n            } catch (Exception e) {\n               String msg = \"Error generating next ID in sequence: \"+e.getMessage();\n               config.getLog().println(msg);\n               e.printStackTrace(config.getLog());\n               throw new SAXException(msg, e);\n      }\n            sequences.put(name, charBuff);\n    }\n        }\n      }\n    }","id":80373,"modified_method":"public void endElement (String namespaceURI, String localName, String qName) throws SAXException\n    {\n      if (qName.equals(\"data\"))\n        insideData = false;\n      else if (qName.equals(\"table\"))\n        insideTable = false;\n      else if (qName.equals(\"name\"))\n      {\n        insideName = false;\n\n        if (!insideColumn) // table name, log which table\n        {\n            table.setName(charBuff.toString());\n            config.getLog().println(\"  \" + table.getName());\n        }\n        else // column name\n          column.setName(charBuff.toString());\n      }\n      else if (qName.equals(\"row\"))\n      {\n        insideRow = false;\n\n        int sinceMajor = row.getSinceMajor();\n        int sinceMinor = row.getSinceMinor();\n        \n        if (sinceMajor == -1) {\n           sinceMajor = table.getSinceMajor();\n           sinceMinor = table.getSinceMinor();\n        }\n        if ((sinceMajor == -1 || config.getUpgradeMajor() == -1)\n            || (sinceMajor > config.getUpgradeMajor()\n                || sinceMinor > config.getUpgradeMinor()))\n        {\n            if (action != null)\n            {\n                if (action.equals(\"delete\"))\n                    executeSQL(table, row, \"delete\");\n                else if (action.equals(\"modify\"))\n                    executeSQL(table, row, \"modify\");\n                else if (action.equals(\"add\"))\n                    executeSQL(table, row, \"insert\");\n            }\n            else if (config.getPopulateTables()) {\n                executeSQL(table, row, \"insert\");\n            } else if (config.getCreateScript()) {\n                dumpSQL(table, row, \"insert\");\n            }\n        }\n      }\n      else if (qName.equals(\"column\"))\n      {\n        insideColumn = false;\n        if (type != null) column.setType(type);\n        row.addColumn(column);\n      }\n      else if (qName.equals(\"value\"))\n      {\n        insideValue = false;\n\n        if (insideColumn) // column value\n          column.setValue(charBuff.toString());\n      }\n      else if (qName.equals(\"sequence\"))\n      {\n        insideSequence = false;\n        if (insideValue)\n        {\n          // if it's already been generated, return it, otherwise get the next one\n          String name = charBuff.toString();\n          if (sequences.get(name) != null) {\n            charBuff = (StringBuffer)sequences.get(name);\n          } else {\n            try {\n               charBuff = new StringBuffer(SequenceGenerator.instance().getNext(sequenceId));\n            } catch (Exception e) {\n               String msg = \"Error generating next ID in sequence: \"+e.getMessage();\n               config.getLog().println(msg);\n               e.printStackTrace(config.getLog());\n               throw new SAXException(msg, e);\n      }\n            sequences.put(name, charBuff);\n    }\n        }\n      }\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"private String prepareDeleteStatement (Row row, boolean preparedStatement)\n    {\n\n      StringBuffer sb = new StringBuffer(\"DELETE FROM \");\n      sb.append(table.getName()).append(\" WHERE \");\n\n      ArrayList columns = row.getColumns();\n      Iterator iterator = columns.iterator();\n      Column column;\n\n      while (iterator.hasNext())\n      {\n        column = (Column) iterator.next();\n        if (preparedStatement)\n          sb.append(column.getName() + \" = ? and \");\n        else if (DomUtils.getJavaSqlDataTypeOfColumn(config, table.getName(), column.getName()) == Types.INTEGER)\n          sb.append(column.getName() + \" = \" + sqlEscape(column.getValue().trim()) + \" and \");\n        else\n          sb.append(column.getName() + \" = \" + \"'\" + sqlEscape(column.getValue().trim()) + \"' and \");\n      }\n\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      if (!preparedStatement)\n        sb.deleteCharAt(sb.length() - 1);\n\n                 return sb.toString();\n\n    }","id":80374,"modified_method":"private String prepareDeleteStatement (Row row, boolean preparedStatement)\n    {\n\n      StringBuffer sb = new StringBuffer(\"DELETE FROM \");\n      sb.append(table.getName()).append(\" WHERE \");\n\n      ArrayList columns = row.getColumns();\n      Iterator iterator = columns.iterator();\n      Column column;\n      int dataType;\n\n      while (iterator.hasNext())\n      {\n        column = (Column) iterator.next();\n        dataType = DomUtils.getJavaSqlDataTypeOfColumn(\n            config, table.getName(), column.getName());\n        \n        if (preparedStatement)\n          sb.append(column.getName() + \" = ? and \");\n        else if (dataType == Types.INTEGER || dataType == Types.BIGINT)\n          sb.append(column.getName() + \" = \" + sqlEscape(column.getValue().trim()) + \" and \");\n        else\n          sb.append(column.getName() + \" = \" + \"'\" + sqlEscape(column.getValue().trim()) + \"' and \");\n      }\n\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      if (!preparedStatement)\n        sb.deleteCharAt(sb.length() - 1);\n\n                 return sb.toString();\n\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"private String prepareInsertStatement (Row row, boolean preparedStatement)\n    {\n      StringBuffer sb = new StringBuffer(\"INSERT INTO \");\n      sb.append(table.getName()).append(\" (\");\n\n      ArrayList columns = row.getColumns();\n      Iterator iterator = columns.iterator();\n\n      while (iterator.hasNext())\n      {\n        Column column = (Column)iterator.next();\n        sb.append(column.getName()).append(\", \");\n      }\n\n      // Delete comma and space after last column name (kind of sloppy, but it works)\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      sb.append(\") VALUES (\");\n      iterator = columns.iterator();\n\n      while (iterator.hasNext())\n      {\n        Column column = (Column)iterator.next();\n\n        if (preparedStatement)\n           sb.append(\"?\");\n        else\n        {\n          String value = column.getValue();\n\n          if (value != null)\n          {\n            if (value.equals(\"SYSDATE\"))\n              sb.append(value);\n            else if (value.equals(\"NULL\"))\n              sb.append(value);\n            else if (DomUtils.getJavaSqlDataTypeOfColumn(config, table.getName(), column.getName()) == Types.INTEGER)\n              // this column is an integer, so don't put quotes (Sybase cares about this)\n              sb.append(value);\n            else\n            {\n              sb.append(\"'\");\n              sb.append(sqlEscape(value.trim()));\n              sb.append(\"'\");\n            }\n          }\n          else\n            sb.append(\"''\");\n        }\n\n        sb.append(\", \");\n      }\n\n      // Delete comma and space after last value (kind of sloppy, but it works)\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      sb.append(\")\");\n\n      return sb.toString();\n    }","id":80375,"modified_method":"private String prepareInsertStatement (Row row, boolean preparedStatement)\n    {\n      StringBuffer sb = new StringBuffer(\"INSERT INTO \");\n      sb.append(table.getName()).append(\" (\");\n\n      ArrayList columns = row.getColumns();\n      Iterator iterator = columns.iterator();\n\n      while (iterator.hasNext())\n      {\n        Column column = (Column)iterator.next();\n        sb.append(column.getName()).append(\", \");\n      }\n\n      // Delete comma and space after last column name (kind of sloppy, but it works)\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      sb.append(\") VALUES (\");\n      iterator = columns.iterator();\n\n      while (iterator.hasNext())\n      {\n        Column column = (Column)iterator.next();\n\n        if (preparedStatement)\n           sb.append(\"?\");\n        else\n        {\n          String value = column.getValue();\n          int dataType = DomUtils.getJavaSqlDataTypeOfColumn(\n              config, table.getName(), column.getName());\n\n          if (value != null)\n          {\n            if (value.equals(\"SYSDATE\"))\n              sb.append(value);\n            else if (value.equals(\"NULL\"))\n              sb.append(value);\n            else if (dataType == Types.INTEGER || dataType == Types.BIGINT)\n              // this column is an integer, so don't put quotes (Sybase cares about this)\n              sb.append(value);\n            else\n            {\n              sb.append(\"'\");\n              sb.append(sqlEscape(value.trim()));\n              sb.append(\"'\");\n            }\n          }\n          else\n            sb.append(\"''\");\n        }\n\n        sb.append(\", \");\n      }\n\n      // Delete comma and space after last value (kind of sloppy, but it works)\n      sb.deleteCharAt(sb.length() - 1);\n      sb.deleteCharAt(sb.length() - 1);\n\n      sb.append(\")\");\n\n      return sb.toString();\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void process()\n      throws\n          SQLException,\n          PortalException,\n          IOException,\n          SAXException,\n          ParserConfigurationException\n    {\n        try\n        {\n            config.setConnection(RDBMServices.getConnection());\n\n\n           long startTime = System.currentTimeMillis();\n\n            DbUtils.logDbInfo(config);\n\n            if ( config.getDataURL() == null )\n                config.setDataURL(DbLoader.class.getResource(config.getDataUri()));\n\n            // okay, start processing\n            // get tablesURL and dataURL here\n            if ( config.getTablesURL() == null)\n              config.setTablesURL(DbLoader.class.getResource(config.getTablesUri()));\n\n            config.getLog().println(\"Getting tables from: \"+config.getTablesURL());\n            config.getLog().println(\"Getting data from: \"+config.getDataURL());\n\n            DocumentBuilder domParser = null;\n\n            // get a dom parser for handling tables.xml and/or indexes.xml\n            try\n            {\n                // Read tables.xml\n                DocumentBuilderFactory dbf = null;\n                dbf=DocumentBuilderFactory.newInstance();\n                domParser = dbf.newDocumentBuilder();\n            } catch (ParserConfigurationException pce) {\n                config.getLog().println(\n                    \"Unable to instantiate DOM parser. Pease check your JAXP \" +\n                    \"configuration.\");\n                pce.printStackTrace(config.getLog());\n                return;\n            }\n\n            // load tables.xml doc if we are creating or dropping tables or\n            // we are populating tables otherwise skip.\n            try\n            {\n                // Eventually, write and validate against a DTD\n                //domParser.setFeature (\"http://xml.org/sax/features/validation\", true);\n                domParser.setEntityResolver(new DTDResolver(\"tables.dtd\"));\n\n                //tablesURL = DbLoader.class.getResource(Configuration.properties.getTablesUri());\n                if (config.getCreateTables()\n                    || config.getDropTables()\n                    || config.getPopulateTables())\n                    config.setTablesDoc(\n                        domParser.parse(\n                            new InputSource(config.getTablesURL().openStream())));\n            }\n            catch(Exception e)\n            {\n                config.getLog().println(\n                    \"Could not process tablesURL '\" + config.getTablesURL() + \"'\");\n                e.printStackTrace(config.getLog());\n\n                return;\n            }\n\n            // Hold on to tables xml with generic types for populating tables\n            if (config.getPopulateTables())\n                config.setGenericTablesDoc(\n                    (Document) config.getTablesDoc().cloneNode(true));\n\n            // drop and create tables if indicated\n            if (config.getCreateTables() || config.getDropTables())\n            {\n                // Replace all generic data types with local data types\n                DomUtils.replaceDataTypes(config, config.getTablesDoc());\n\n                // tables.xml + tables.xsl --> DROP TABLE and CREATE TABLE sql statements\n                XSLT xslt = new XSLT(this);\n                xslt.setXML(config.getTablesDoc());\n                xslt.setXSL(config.getTablesXslUri());\n                xslt.setTarget(new TableHandler(config));\n\n                if (config.getUpgradeVersion() != null) {\n                    xslt.setStylesheetParameter(\"upgradeMajor\", Integer.toString(config.getUpgradeMajor()));\n                    xslt.setStylesheetParameter(\"upgradeMinor\", Integer.toString(config.getUpgradeMinor()));\n                }\n\n                xslt.transform();\n            }\n            else\n            {\n                config.getLog().println();\n                config.getLog().println(\"Dropping tables and Creating tables...Disabled\");\n                config.getLog().println();\n            }\n\n            // populate tables if indiicated\n            // data.xml --> INSERT sql statements\n\n            if ( config.getPopulateTables() )\n            {\n                config.getLog().println(\"Populating tables...\");\n                XMLReader parser = getXMLReader();\n                DataHandler dataHandler = new DataHandler(config);\n                parser.setContentHandler(dataHandler);\n                parser.setErrorHandler(dataHandler);\n                parser.setEntityResolver(new DTDResolver(\"data.dtd\"));\n                parser.parse(new InputSource(config.getDataURL().openStream()));\n            }\n            else\n                config.getLog().println(\"Populating tables...disabled.\");\n\n            // cleanup and exit\n            config.getLog().println(\"Done!\");\n            long endTime = System.currentTimeMillis();\n            config.getLog().println(\n                \"Elapsed time: \" + ((endTime - startTime) / 1000f) + \" seconds\");\n        } catch (DataAccessException dae) {\n            // we know this will be thrown by RDBMServices when getConnection() fails.\n            config.getLog().println(\n                    \"DbLoader couldn't obtain a database connection.  \" +\n                    \"See the portal log for details.\");\n                return;\n        }\n        finally\n        {\n            RDBMServices.releaseConnection(config.getConnection());\n        }\n    }","id":80376,"modified_method":"public void process()\n      throws\n          SQLException,\n          PortalException,\n          IOException,\n          SAXException,\n          ParserConfigurationException\n    {\n        try\n        {\n            config.setConnection(RDBMServices.getConnection());\n    \n           \n           long startTime = System.currentTimeMillis();\n\n            DbUtils.logDbInfo(config);\n          \n            if ( config.getDataURL() == null )\n                config.setDataURL(DbLoader.class.getResource(config.getDataUri()));\n\n            // okay, start processing\n            // get tablesURL and dataURL here\n            if ( config.getTablesURL() == null)\n              config.setTablesURL(DbLoader.class.getResource(config.getTablesUri()));\n            \n            config.getLog().println(\"Getting tables from: \"+config.getTablesURL());\n            config.getLog().println(\"Getting data from: \"+config.getDataURL());\n\n            DocumentBuilder domParser = null;\n\n            // get a dom parser for handling tables.xml and/or indexes.xml \n            try\n            {\n                // Read tables.xml\n                DocumentBuilderFactory dbf = null;\n                dbf=DocumentBuilderFactory.newInstance();\n                domParser = dbf.newDocumentBuilder();\n            } catch (ParserConfigurationException pce) {\n                config.getLog().println(\n                    \"Unable to instantiate DOM parser. Pease check your JAXP \" +\n                    \"configuration.\");\n                pce.printStackTrace(config.getLog());\n                return;\n            }\n\n            // load tables.xml doc if we are creating or dropping tables or\n            // we are populating tables otherwise skip.\n            try\n            {\n                // Eventually, write and validate against a DTD\n                //domParser.setFeature (\"http://xml.org/sax/features/validation\", true);\n                domParser.setEntityResolver(new DTDResolver(\"tables.dtd\"));\n\n                //tablesURL = DbLoader.class.getResource(Configuration.properties.getTablesUri());\n                if (config.getCreateTables()\n                    || config.getDropTables()\n                    || config.getPopulateTables()\n                    || config.getCreateScript())\n                    config.setTablesDoc(\n                        domParser.parse(\n                            new InputSource(config.getTablesURL().openStream())));\n            }\n            catch(Exception e)\n            {\n                config.getLog().println(\n                    \"Could not process tablesURL '\" + config.getTablesURL() + \"'\");\n                e.printStackTrace(config.getLog());\n\n                return;\n            }\n\n            // Hold on to tables xml with generic types for populating tables\n            if (config.getPopulateTables() || config.getCreateScript())\n                config.setGenericTablesDoc(\n                    (Document) config.getTablesDoc().cloneNode(true));\n\n            // drop and create tables if indicated\n            if (config.getCreateTables() || config.getDropTables() ||\n                config.getCreateScript())\n            {\n                // Replace all generic data types with local data types\n                DomUtils.replaceDataTypes(config, config.getTablesDoc());\n\n                // tables.xml + tables.xsl --> DROP TABLE and CREATE TABLE sql statements\n                XSLT xslt = new XSLT(this);\n                xslt.setXML(config.getTablesDoc());\n                xslt.setXSL(config.getTablesXslUri());\n                xslt.setTarget(new TableHandler(config));\n                \n                if (config.getUpgradeVersion() != null) {\n                    xslt.setStylesheetParameter(\"upgradeMajor\", Integer.toString(config.getUpgradeMajor()));\n                    xslt.setStylesheetParameter(\"upgradeMinor\", Integer.toString(config.getUpgradeMinor()));\n                }\n\n                xslt.transform();\n            }\n            else\n            {\n                config.getLog().println();\n                config.getLog().println(\"Dropping tables and Creating tables...Disabled\");\n                config.getLog().println();\n            }\n            \n            // populate tables if indiicated\n            // data.xml --> INSERT sql statements\n\n            if ( config.getPopulateTables() )\n            {\n                config.getLog().println(\"Populating tables...\");\n                XMLReader parser = getXMLReader();\n                DefaultHandler dataHandler =\n                    DataHandlerFactory.instance().getHandler(config);\n                parser.setContentHandler(dataHandler);\n                parser.setErrorHandler(dataHandler);\n                parser.setEntityResolver(new DTDResolver(\"data.dtd\"));\n                parser.parse(new InputSource(config.getDataURL().openStream()));\n            }\n            else if (config.getCreateScript()) {\n                config.getLog().println(\"Populating tables in the script...\");\n                XMLReader parser = getXMLReader();\n                DefaultHandler dataHandler =\n                    DataHandlerFactory.instance().getHandler(config);\n                parser.setContentHandler(dataHandler);\n                parser.setErrorHandler(dataHandler);\n                parser.setEntityResolver(new DTDResolver(\"data.dtd\"));\n                parser.parse(new InputSource(config.getDataURL().openStream()));\n            }\n            else\n                config.getLog().println(\"Populating tables...disabled.\");\n\n            // cleanup and exit\n            config.getLog().println(\"Done!\");\n            long endTime = System.currentTimeMillis();\n            config.getLog().println(\n                \"Elapsed time: \" + ((endTime - startTime) / 1000f) + \" seconds\");\n        } catch (DataAccessException dae) {\n            // we know this will be thrown by RDBMServices when getConnection() fails.\n            config.getLog().println(\n                    \"DbLoader couldn't obtain a database connection.  \" +\n                    \"See the portal log for details.\");\n                return;\n        }\n        finally\n        {\n            RDBMServices.releaseConnection(config.getConnection());\n        }          \n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"static void dumpTable(PrintWriter xmlOut, Statement stmt, String tableName) throws Exception {\n    String sql = \"SELECT * FROM \" + tableName;\n    ResultSet rs;\n    try {\n       rs = stmt.executeQuery(sql);\n    } catch (SQLException e) {\n      System.err.println(\"Problem accessing table \" + tableName + \": \" + e);\n      return;\n    }\n\n    xmlOut.println(\"  <table>\");\n    xmlOut.println(\"    <name>\" + tableName.toUpperCase() + \"<\/name>\");\n    xmlOut.println(\"    <rows>\");\n    try {\n      ResultSetMetaData rsmd = rs.getMetaData();\n      int columnCount = rsmd.getColumnCount();\n      int[] columnType = new int[columnCount];\n      String[] columnName = new String[columnCount];\n      for (int i = 0; i < columnCount; i++) {\n        columnType[i] = rsmd.getColumnType(i+1);\n        columnName[i] = rsmd.getColumnName(i+1);\n      }\n      while(rs.next()) {\n        xmlOut.println(\"      <row>\");\n        for (int i = 0; i < rsmd.getColumnCount(); i++) {\n          String value = \"\";\n          if (columnType[i] == java.sql.Types.VARCHAR ||\n            columnType[i] == java.sql.Types.LONGVARCHAR||\n            columnType[i] == java.sql.Types.CHAR) {\n            value = rs.getString(i+1);\n            value = XMLEscaper.escape(value);\n            if (value != null && value.startsWith(\"<?xml \")) {\n              value = \"<![CDATA[\\n\" + value + \"\\n]]>\";\n            }\n          } else if (columnType[i] == java.sql.Types.NUMERIC ||\n            columnType[i] == java.sql.Types.INTEGER) {\n            value = rs.getInt(i+1) + \"\";\n          } else if (columnType[i] == java.sql.Types.TIMESTAMP) {\n            java.sql.Timestamp ts = rs.getTimestamp(i+1);\n            if (!rs.wasNull()) {\n              value = ts.toString();\n            }\n          } else if (columnType[i] == java.sql.Types.DATE)\n          {\n\t\t\tjava.sql.Date dt= rs.getDate(i+1);\n\t\t\tif (!rs.wasNull()) {\n\t\t\t\tjava.sql.Timestamp ts = new java.sql.Timestamp(dt.getTime());\n\t\t\t  \tvalue = ts.toString();\n\t\t\t}\n          }\n          else{\n            throw new Exception(\"Unrecognized column type \" + columnType[i] + \" for column \" + (i + 1) +\n            \" in table \" + tableName);\n          }\n          if (rs.wasNull()) \n            xmlOut.println(\"        <column><name>\" + columnName[i].toUpperCase() + \"<\/name><\/column>\");\n          else\n            xmlOut.println(\"        <column><name>\" + columnName[i].toUpperCase() + \"<\/name><value>\" + value + \"<\/value><\/column>\");\n        }\n        xmlOut.println(\"      <\/row>\");\n      }\n    } finally {\n      rs.close();\n    }\n    xmlOut.println(\"    <\/rows>\");\n    xmlOut.println(\"  <\/table>\");\n    xmlOut.println();\n  }","id":80377,"modified_method":"static void dumpTable(PrintWriter xmlOut, Statement stmt, String tableName) throws Exception {\n    String sql = \"SELECT * FROM \" + tableName;\n    ResultSet rs;\n    try {\n       rs = stmt.executeQuery(sql);\n    } catch (SQLException e) {\n      System.err.println(\"Problem accessing table \" + tableName + \": \" + e);\n      return;\n    }\n\n    xmlOut.println(\"  <table>\");\n    xmlOut.println(\"    <name>\" + tableName.toUpperCase() + \"<\/name>\");\n    xmlOut.println(\"    <rows>\");\n    try {\n      ResultSetMetaData rsmd = rs.getMetaData();\n      int columnCount = rsmd.getColumnCount();\n      int[] columnType = new int[columnCount];\n      String[] columnName = new String[columnCount];\n      for (int i = 0; i < columnCount; i++) {\n        columnType[i] = rsmd.getColumnType(i+1);\n        columnName[i] = rsmd.getColumnName(i+1);\n      }\n      while(rs.next()) {\n        xmlOut.println(\"      <row>\");\n        for (int i = 0; i < rsmd.getColumnCount(); i++) {\n          String value = \"\";\n          if (columnType[i] == java.sql.Types.VARCHAR ||\n            columnType[i] == java.sql.Types.LONGVARCHAR||\n            columnType[i] == java.sql.Types.CHAR) {\n            value = rs.getString(i+1);\n            value = XMLEscaper.escape(value);\n            if (value != null && value.startsWith(\"<?xml \")) {\n              value = \"<![CDATA[\\n\" + value + \"\\n]]>\";\n            }\n          } else if (columnType[i] == java.sql.Types.NUMERIC ||\n            columnType[i] == java.sql.Types.INTEGER) {\n            value = rs.getInt(i+1) + \"\";\n          } else if (columnType[i] == java.sql.Types.BIGINT) {\n            value = rs.getLong(i+1) + \"\";\n          } else if (columnType[i] == java.sql.Types.TIMESTAMP) {\n            java.sql.Timestamp ts = rs.getTimestamp(i+1);\n            if (!rs.wasNull()) {\n              value = ts.toString();\n            }\n          } else if (columnType[i] == java.sql.Types.DATE)\n          {\n\t\t\tjava.sql.Date dt= rs.getDate(i+1);\n\t\t\tif (!rs.wasNull()) {\n\t\t\t\tjava.sql.Timestamp ts = new java.sql.Timestamp(dt.getTime());\n\t\t\t  \tvalue = ts.toString();\n\t\t\t}\n          }\n          else{\n            throw new Exception(\"Unrecognized column type \" + columnType[i] + \" for column \" + (i + 1) +\n            \" in table \" + tableName);\n          }\n          if (rs.wasNull()) \n            xmlOut.println(\"        <column><name>\" + columnName[i].toUpperCase() + \"<\/name><\/column>\");\n          else\n            xmlOut.println(\"        <column><name>\" + columnName[i].toUpperCase() + \"<\/name><value>\" + value + \"<\/value><\/column>\");\n        }\n        xmlOut.println(\"      <\/row>\");\n      }\n    } finally {\n      rs.close();\n    }\n    xmlOut.println(\"    <\/rows>\");\n    xmlOut.println(\"  <\/table>\");\n    xmlOut.println();\n  }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"static void createTable (Configuration config, String createTableStatement)\n    {\n        Statement stmt = null;\n\n        if (config.getScriptWriter() != null)\n            config.getScriptWriter().println(\n                createTableStatement + config.getStatementTerminator());\n\n      try\n      {\n        stmt = config.getConnection().createStatement();\n        stmt.executeUpdate(createTableStatement);\n      }\n      catch (Exception e)\n      {\n          config.getLog().println(createTableStatement);\n        e.printStackTrace(config.getLog());\n      }\n      finally\n      {\n        try { if (stmt != null) stmt.close(); } \n        catch (Exception e) { }\n      }\n    }","id":80378,"modified_method":"static void createTable (Configuration config, String createTableStatement)\n    {\n        Statement stmt = null;\n\n      try\n      {\n        stmt = config.getConnection().createStatement();\n        stmt.executeUpdate(createTableStatement);\n      }\n      catch (Exception e)\n      {\n          config.getLog().println(createTableStatement);\n        e.printStackTrace(config.getLog());\n      }\n      finally\n      {\n        try { if (stmt != null) stmt.close(); } \n        catch (Exception e) { }\n      }\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"static int getJavaSqlType (String genericDataTypeName)\n    {\n      // Find the type code for this generic type name\n      int dataTypeCode = 0;\n\n      if (genericDataTypeName.equalsIgnoreCase(\"BIT\"))\n        dataTypeCode = Types.BIT; // -7\n      else if (genericDataTypeName.equalsIgnoreCase(\"TINYINT\"))\n        dataTypeCode = Types.TINYINT; // -6\n      else if (genericDataTypeName.equalsIgnoreCase(\"SMALLINT\"))\n        dataTypeCode = Types.SMALLINT; // 5\n      else if (genericDataTypeName.equalsIgnoreCase(\"INTEGER\"))\n        dataTypeCode = Types.INTEGER; // 4\n      else if (genericDataTypeName.equalsIgnoreCase(\"BIGINT\"))\n        dataTypeCode = Types.BIGINT; // -5\n      else if (genericDataTypeName.equalsIgnoreCase(\"FLOAT\"))\n        dataTypeCode = Types.FLOAT; // 6\n      else if (genericDataTypeName.equalsIgnoreCase(\"REAL\"))\n        dataTypeCode = Types.REAL; // 7\n      else if (genericDataTypeName.equalsIgnoreCase(\"DOUBLE\"))\n        dataTypeCode = Types.DOUBLE; // 8\n      else if (genericDataTypeName.equalsIgnoreCase(\"NUMERIC\"))\n        dataTypeCode = Types.NUMERIC; // 2\n      else if (genericDataTypeName.equalsIgnoreCase(\"DECIMAL\"))\n        dataTypeCode = Types.DECIMAL; // 3\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"CHAR\"))\n        dataTypeCode = Types.CHAR; // 1\n      else if (genericDataTypeName.equalsIgnoreCase(\"VARCHAR\"))\n        dataTypeCode = Types.VARCHAR; // 12\n      else if (genericDataTypeName.equalsIgnoreCase(\"LONGVARCHAR\"))\n        dataTypeCode = Types.LONGVARCHAR; // -1\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"DATE\"))\n        dataTypeCode = Types.DATE; // 91\n      else if (genericDataTypeName.equalsIgnoreCase(\"TIME\"))\n        dataTypeCode = Types.TIME; // 92\n      else if (genericDataTypeName.equalsIgnoreCase(\"TIMESTAMP\"))\n        dataTypeCode = Types.TIMESTAMP; // 93\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"BINARY\"))\n        dataTypeCode = Types.BINARY; // -2\n      else if (genericDataTypeName.equalsIgnoreCase(\"VARBINARY\"))\n        dataTypeCode = Types.VARBINARY; // -3\n      else if (genericDataTypeName.equalsIgnoreCase(\"LONGVARBINARY\"))\n        dataTypeCode = Types.LONGVARBINARY;  // -4\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"NULL\"))\n        dataTypeCode = Types.NULL; // 0\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"OTHER\"))\n        dataTypeCode = Types.OTHER; // 1111\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"JAVA_OBJECT\"))\n        dataTypeCode = Types.JAVA_OBJECT; // 2000\n      else if (genericDataTypeName.equalsIgnoreCase(\"DISTINCT\"))\n        dataTypeCode = Types.DISTINCT; // 2001\n      else if (genericDataTypeName.equalsIgnoreCase(\"STRUCT\"))\n        dataTypeCode = Types.STRUCT; // 2002\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"ARRAY\"))\n        dataTypeCode = Types.ARRAY; // 2003\n      else if (genericDataTypeName.equalsIgnoreCase(\"BLOB\"))\n        dataTypeCode = Types.BLOB; // 2004\n      else if (genericDataTypeName.equalsIgnoreCase(\"CLOB\"))\n        dataTypeCode = Types.CLOB; // 2005\n      else if (genericDataTypeName.equalsIgnoreCase(\"REF\"))\n        dataTypeCode = Types.REF; // 2006\n    \n    else if (genericDataTypeName.equalsIgnoreCase(\"DATALINK\"))\n        dataTypeCode = 70; // Use Types.DATALINK when JDK 1.3 support is no longer needed\n    else if (genericDataTypeName.equalsIgnoreCase(\"BOOLEAN\"))\n        dataTypeCode = 16; // Use Types.BOOLEAN when JDK 1.3 support is no longer needed\n\n      return dataTypeCode;\n    }","id":80379,"modified_method":"static int getJavaSqlType (String genericDataTypeName)\n    {\n      // Find the type code for this generic type name\n      int dataTypeCode = 0;\n\n      if (genericDataTypeName.equalsIgnoreCase(\"BIT\"))\n        dataTypeCode = Types.BIT; // -7\n      else if (genericDataTypeName.equalsIgnoreCase(\"TINYINT\"))\n        dataTypeCode = Types.TINYINT; // -6\n      else if (genericDataTypeName.equalsIgnoreCase(\"SMALLINT\"))\n        dataTypeCode = Types.SMALLINT; // 5\n      else if (genericDataTypeName.equalsIgnoreCase(\"INTEGER\"))\n        dataTypeCode = Types.INTEGER; // 4\n      else if (genericDataTypeName.equalsIgnoreCase(\"BIGINT\") ||\n          genericDataTypeName.equalsIgnoreCase(\"BIGINTEGER\"))\n        dataTypeCode = Types.BIGINT; // -5\n      else if (genericDataTypeName.equalsIgnoreCase(\"FLOAT\"))\n        dataTypeCode = Types.FLOAT; // 6\n      else if (genericDataTypeName.equalsIgnoreCase(\"REAL\"))\n        dataTypeCode = Types.REAL; // 7\n      else if (genericDataTypeName.equalsIgnoreCase(\"DOUBLE\"))\n        dataTypeCode = Types.DOUBLE; // 8\n      else if (genericDataTypeName.equalsIgnoreCase(\"NUMERIC\"))\n        dataTypeCode = Types.NUMERIC; // 2\n      else if (genericDataTypeName.equalsIgnoreCase(\"DECIMAL\"))\n        dataTypeCode = Types.DECIMAL; // 3\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"CHAR\"))\n        dataTypeCode = Types.CHAR; // 1\n      else if (genericDataTypeName.equalsIgnoreCase(\"VARCHAR\"))\n        dataTypeCode = Types.VARCHAR; // 12\n      else if (genericDataTypeName.equalsIgnoreCase(\"LONGVARCHAR\"))\n        dataTypeCode = Types.LONGVARCHAR; // -1\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"DATE\"))\n        dataTypeCode = Types.DATE; // 91\n      else if (genericDataTypeName.equalsIgnoreCase(\"TIME\"))\n        dataTypeCode = Types.TIME; // 92\n      else if (genericDataTypeName.equalsIgnoreCase(\"TIMESTAMP\"))\n        dataTypeCode = Types.TIMESTAMP; // 93\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"BINARY\"))\n        dataTypeCode = Types.BINARY; // -2\n      else if (genericDataTypeName.equalsIgnoreCase(\"VARBINARY\"))\n        dataTypeCode = Types.VARBINARY; // -3\n      else if (genericDataTypeName.equalsIgnoreCase(\"LONGVARBINARY\"))\n        dataTypeCode = Types.LONGVARBINARY;  // -4\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"NULL\"))\n        dataTypeCode = Types.NULL; // 0\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"OTHER\"))\n        dataTypeCode = Types.OTHER; // 1111\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"JAVA_OBJECT\"))\n        dataTypeCode = Types.JAVA_OBJECT; // 2000\n      else if (genericDataTypeName.equalsIgnoreCase(\"DISTINCT\"))\n        dataTypeCode = Types.DISTINCT; // 2001\n      else if (genericDataTypeName.equalsIgnoreCase(\"STRUCT\"))\n        dataTypeCode = Types.STRUCT; // 2002\n\n      else if (genericDataTypeName.equalsIgnoreCase(\"ARRAY\"))\n        dataTypeCode = Types.ARRAY; // 2003\n      else if (genericDataTypeName.equalsIgnoreCase(\"BLOB\"))\n        dataTypeCode = Types.BLOB; // 2004\n      else if (genericDataTypeName.equalsIgnoreCase(\"CLOB\"))\n        dataTypeCode = Types.CLOB; // 2005\n      else if (genericDataTypeName.equalsIgnoreCase(\"REF\"))\n        dataTypeCode = Types.REF; // 2006\n    \n    else if (genericDataTypeName.equalsIgnoreCase(\"DATALINK\"))\n        dataTypeCode = 70; // Use Types.DATALINK when JDK 1.3 support is no longer needed\n    else if (genericDataTypeName.equalsIgnoreCase(\"BOOLEAN\"))\n        dataTypeCode = 16; // Use Types.BOOLEAN when JDK 1.3 support is no longer needed\n\n      return dataTypeCode;\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"static void dropTable (Configuration config, String dropTableStatement)\n    {\n        Statement stmt = null;\n\n        if (config.getScriptWriter() != null)\n      config.getScriptWriter().println(dropTableStatement + config.getStatementTerminator());\n\n      try\n      {\n        stmt = config.getConnection().createStatement();\n        try { stmt.executeUpdate(dropTableStatement); } \n        catch (SQLException sqle) {/*Table didn't exist*/}\n      }\n      catch (Exception e)\n      {\n          config.getLog().println(dropTableStatement);\n        e.printStackTrace(config.getLog());\n      }\n      finally\n      {\n        try { if (stmt != null) stmt.close(); } catch (Exception e) { }\n      }\n    }","id":80380,"modified_method":"static void dropTable (Configuration config, String dropTableStatement)\n    {\n        Statement stmt = null;\n\n\n      try\n      {\n        stmt = config.getConnection().createStatement();\n        try { stmt.executeUpdate(dropTableStatement); } \n        catch (SQLException sqle) {/*Table didn't exist*/}\n      }\n      catch (Exception e)\n      {\n          config.getLog().println(dropTableStatement);\n        e.printStackTrace(config.getLog());\n      }\n      finally\n      {\n        try { if (stmt != null) stmt.close(); } catch (Exception e) { }\n      }\n    }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void endElement (String namespaceURI, String localName, String qName)\n  {\n    if (qName.equals(\"statement\"))\n    {\n      String statement = stmtBuffer.toString();\n\n      switch (mode)\n      {\n        case DROP:\n          if (config.getDropTables())\n          {\n              config.getLog().println(\"  \" + tableName);\n              DbUtils.dropTable(config, statement);\n          }\n          break;\n        case CREATE:\n          if (config.getCreateTables())\n          {\n              config.getLog().println(\"  \" + tableName);\n              DbUtils.createTable(config, statement);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }","id":80381,"modified_method":"public void endElement (String namespaceURI, String localName, String qName)\n  {\n    if (qName.equals(\"statement\"))\n    {\n      String statement = stmtBuffer.toString();\n\n      switch (mode)\n      {\n        case DROP:\n          if (config.getDropTables())\n          {\n              config.getLog().println(\"  \" + tableName);\n              DbUtils.dropTable(config, statement);\n          }\n          if (config.getCreateScript()) {\n              config.getLog().println(\"  \" + tableName);\n              DbUtils.dumpTableAction(config, statement);\n          }\n          break;\n        case CREATE:\n          if (config.getCreateTables())\n          {\n              config.getLog().println(\"  \" + tableName);\n              DbUtils.createTable(config, statement);\n          }\n          if (config.getCreateScript()) {\n              config.getLog().println(\"  \" + tableName);\n              DbUtils.dumpTableAction(config, statement);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }","commit_id":"fd5fa381eabbe3633d17d3c2cca556f104a52833","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void parsePattern() {\n        PsiBuilder.Marker pattern = mark();\n\n        myJetParsing.parseAttributeList();\n\n        if (at(NAMESPACE_KEYWORD) || at(IDENTIFIER)) {\n            myJetParsing.parseUserTypeOrQualifiedName();\n            if (!myBuilder.newlineBeforeCurrentToken() && at(LPAR)) {\n                PsiBuilder.Marker list = mark();\n                parseTuplePattern(DECOMPOSER_ARGUMENT);\n                list.done(DECOMPOSER_ARGUMENT_LIST);\n                pattern.done(DECOMPOSER_PATTERN);\n            } else {\n                pattern.done(TYPE_PATTERN);\n            }\n        } else if (at(LPAR)) {\n            parseTuplePattern(TUPLE_PATTERN_ENTRY);\n            pattern.done(TUPLE_PATTERN);\n        } else if (at(LBRACE) || at(CAPITALIZED_THIS_KEYWORD)) {\n            myJetParsing.parseTypeRef();\n            pattern.done(TYPE_PATTERN);\n        }\n        else if (at(QUEST)) {\n            parseBindingPattern();\n            pattern.done(BINDING_PATTERN);\n        } else if (at(EQ)) {\n            advance(); // EQ\n            parseExpression();\n            pattern.done(EXPRESSION_PATTERN);\n        } else if (parseLiteralConstant()) {\n            pattern.done(EXPRESSION_PATTERN);\n        } else {\n            errorUntil(\"Pattern expected\", TokenSet.create(RBRACE, DOUBLE_ARROW));\n            pattern.drop();\n        }\n    }","id":80382,"modified_method":"private void parsePattern() {\n        PsiBuilder.Marker pattern = mark();\n\n        myJetParsing.parseAttributeList();\n\n        if (at(NAMESPACE_KEYWORD) || at(IDENTIFIER) || at(LBRACE) || at(THIS_KEYWORD)) {\n            PsiBuilder.Marker rollbackMarker = mark();\n            parseBinaryExpression(Precedence.ELVIS);\n            if (at(AT)) {\n                rollbackMarker.drop();\n                advance(); // AT\n                PsiBuilder.Marker list = mark();\n                parseTuplePattern(DECOMPOSER_ARGUMENT);\n                list.done(DECOMPOSER_ARGUMENT_LIST);\n                pattern.done(DECOMPOSER_PATTERN);\n            } else {\n                int expressionEndOffset = myBuilder.getCurrentOffset();\n                rollbackMarker.rollbackTo();\n                rollbackMarker = mark();\n\n                myJetParsing.parseTypeRef();\n                if (at(AT)) {\n                    errorAndAdvance(\"'@' is allowed only after a decomposer expression, not after a type\");\n                }\n                if (myBuilder.getCurrentOffset() < expressionEndOffset) {\n                    rollbackMarker.rollbackTo();\n                    parseBinaryExpression(Precedence.ELVIS);\n                    pattern.done(DECOMPOSER_PATTERN);\n                } else {\n                    rollbackMarker.drop();\n                    pattern.done(TYPE_PATTERN);\n                }\n            }\n        } else if (at(LPAR)) {\n            parseTuplePattern(TUPLE_PATTERN_ENTRY);\n            pattern.done(TUPLE_PATTERN);\n        }\n        else if (at(QUEST)) {\n            parseBindingPattern();\n            pattern.done(BINDING_PATTERN);\n        } else if (at(EQ)) {\n            advance(); // EQ\n            parseExpression();\n            pattern.done(EXPRESSION_PATTERN);\n        } else if (parseLiteralConstant()) {\n            pattern.done(EXPRESSION_PATTERN);\n        } else {\n            errorUntil(\"Pattern expected\", TokenSet.create(RBRACE, DOUBLE_ARROW));\n            pattern.drop();\n        }\n    }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseTuplePattern(JetNodeType entryType) {\n        assert _at(LPAR);\n\n        myBuilder.disableNewlines();\n        advance(); // LPAR\n\n        if (!at(RPAR)) {\n            while (true) {\n                while (at(COMMA)) errorAndAdvance(\"Expecting a pattern\");\n                if (at(RPAR)) {\n                    error(\"Expecting a pattern\");\n                    break;\n                }\n                PsiBuilder.Marker entry = mark();\n                if (at(IDENTIFIER) && lookahead(1) == EQ) {\n                    advance(); // IDENTIFIER\n                    advance(); // EQ\n                }\n                parsePattern();\n                entry.done(entryType);\n                if (!at(COMMA)) break;\n\n                advance(); // COMMA\n            }\n        }\n\n        expect(RPAR, \"Expecting ')'\");\n        myBuilder.restoreNewlinesState();\n    }","id":80383,"modified_method":"private void parseTuplePattern(JetNodeType entryType) {\n\n        myBuilder.disableNewlines();\n        expect(LPAR, \"Expecting '('\", getDecomposerExpressionFollow());\n\n        if (!at(RPAR)) {\n            while (true) {\n                while (at(COMMA)) errorAndAdvance(\"Expecting a pattern\");\n                if (at(RPAR)) {\n                    error(\"Expecting a pattern\");\n                    break;\n                }\n                PsiBuilder.Marker entry = mark();\n                if (at(IDENTIFIER) && lookahead(1) == EQ) {\n                    advance(); // IDENTIFIER\n                    advance(); // EQ\n                }\n                parsePattern();\n                entry.done(entryType);\n                if (!at(COMMA)) break;\n\n                advance(); // COMMA\n            }\n        }\n\n        expect(RPAR, \"Expecting ')'\");\n        myBuilder.restoreNewlinesState();\n    }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static int [] zzUnpackTrans() {\n    int [] result = new int[8778];\n    int offset = 0;\n    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);\n    return result;\n  }","id":80384,"modified_method":"private static int [] zzUnpackTrans() {\n    int [] result = new int[8911];\n    int offset = 0;\n    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);\n    return result;\n  }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static int [] zzUnpackRowMap() {\n    int [] result = new int[205];\n    int offset = 0;\n    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);\n    return result;\n  }","id":80385,"modified_method":"private static int [] zzUnpackRowMap() {\n    int [] result = new int[206];\n    int offset = 0;\n    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);\n    return result;\n  }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public IElementType advance() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    CharSequence zzBufferL = zzBuffer;\n    char[] zzBufferArrayL = zzBufferArray;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n\n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++]:zzBufferL.charAt(zzCurrentPosL++);\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++]:zzBufferL.charAt(zzCurrentPosL++);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 3: \n          { return JetTokens.IDENTIFIER;\n          }\n        case 89: break;\n        case 63: \n          { return JetTokens.FOR_KEYWORD ;\n          }\n        case 90: break;\n        case 85: \n          { return JetTokens.RETURN_KEYWORD ;\n          }\n        case 91: break;\n        case 71: \n          { return JetTokens.NULL_KEYWORD ;\n          }\n        case 92: break;\n        case 14: \n          { return JetTokens.LT        ;\n          }\n        case 93: break;\n        case 45: \n          { return JetTokens.DO_KEYWORD ;\n          }\n        case 94: break;\n        case 13: \n          { return JetTokens.PLUS      ;\n          }\n        case 95: break;\n        case 28: \n          { return JetTokens.LONG_LITERAL;\n          }\n        case 96: break;\n        case 60: \n          { return JetTokens.RAW_STRING_LITERAL;\n          }\n        case 97: break;\n        case 49: \n          { return JetTokens.PLUSEQ    ;\n          }\n        case 98: break;\n        case 26: \n          { return JetTokens.COMMA     ;\n          }\n        case 99: break;\n        case 15: \n          { return JetTokens.GT        ;\n          }\n        case 100: break;\n        case 4: \n          { return JetTokens.WHITE_SPACE;\n          }\n        case 101: break;\n        case 83: \n          { return JetTokens.TYPEOF_KEYWORD ;\n          }\n        case 102: break;\n        case 24: \n          { return JetTokens.RPAR      ;\n          }\n        case 103: break;\n        case 47: \n          { return JetTokens.DOUBLE_ARROW;\n          }\n        case 104: break;\n        case 73: \n          { return JetTokens.TRUE_KEYWORD ;\n          }\n        case 105: break;\n        case 30: \n          { return JetTokens.FIELD_IDENTIFIER;\n          }\n        case 106: break;\n        case 53: \n          { return JetTokens.ANDAND    ;\n          }\n        case 107: break;\n        case 59: \n          { return JetTokens.DOC_COMMENT;\n          }\n        case 108: break;\n        case 29: \n          { return JetTokens.FLOAT_LITERAL;\n          }\n        case 109: break;\n        case 31: \n          { return JetTokens.EOL_COMMENT;\n          }\n        case 110: break;\n        case 76: \n          { return JetTokens.WHEN_KEYWORD ;\n          }\n        case 111: break;\n        case 17: \n          { return JetTokens.COLON     ;\n          }\n        case 112: break;\n        case 51: \n          { return JetTokens.LTEQ      ;\n          }\n        case 113: break;\n        case 40: \n          { return JetTokens.ARROW     ;\n          }\n        case 114: break;\n        case 19: \n          { return JetTokens.LBRACKET  ;\n          }\n        case 115: break;\n        case 58: \n          { yypushback(2); return JetTokens.INTEGER_LITERAL;\n          }\n        case 116: break;\n        case 9: \n          { return JetTokens.CHARACTER_LITERAL;\n          }\n        case 117: break;\n        case 65: \n          { return JetTokens.VAR_KEYWORD ;\n          }\n        case 118: break;\n        case 52: \n          { return JetTokens.GTEQ      ;\n          }\n        case 119: break;\n        case 2: \n          { return JetTokens.INTEGER_LITERAL;\n          }\n        case 120: break;\n        case 22: \n          { return JetTokens.RBRACE    ;\n          }\n        case 121: break;\n        case 78: \n          { return JetTokens.CLASS_KEYWORD ;\n          }\n        case 122: break;\n        case 12: \n          { return JetTokens.EXCL      ;\n          }\n        case 123: break;\n        case 62: \n          { return JetTokens.TRY_KEYWORD ;\n          }\n        case 124: break;\n        case 48: \n          { return JetTokens.EXCLEQ    ;\n          }\n        case 125: break;\n        case 39: \n          { return JetTokens.MINUSEQ   ;\n          }\n        case 126: break;\n        case 79: \n          { return JetTokens.THROW_KEYWORD ;\n          }\n        case 127: break;\n        case 82: \n          { return JetTokens.WHILE_KEYWORD ;\n          }\n        case 128: break;\n        case 38: \n          { return JetTokens.MINUSMINUS;\n          }\n        case 129: break;\n        case 86: \n          { return JetTokens.CONTINUE_KEYWORD ;\n          }\n        case 130: break;\n        case 68: \n          { return JetTokens.NOT_IN;\n          }\n        case 131: break;\n        case 5: \n          { return JetTokens.DIV       ;\n          }\n        case 132: break;\n        case 56: \n          { return JetTokens.ELVIS     ;\n          }\n        case 133: break;\n        case 16: \n          { return JetTokens.QUEST     ;\n          }\n        case 134: break;\n        case 54: \n          { return JetTokens.OROR      ;\n          }\n        case 135: break;\n        case 18: \n          { return JetTokens.PERC      ;\n          }\n        case 136: break;\n        case 70: \n          { return JetTokens.EXCLEQEQEQ;\n          }\n        case 137: break;\n        case 57: \n          { return JetTokens.PERCEQ    ;\n          }\n        case 138: break;\n        case 36: \n          { return JetTokens.RANGE     ;\n          }\n        case 139: break;\n        case 1: \n          { return TokenType.BAD_CHARACTER;\n          }\n        case 140: break;\n        case 55: \n          { return JetTokens.SAFE_ACCESS;\n          }\n        case 141: break;\n        case 87: \n          { return JetTokens.NAMESPACE_KEYWORD ;\n          }\n        case 142: break;\n        case 69: \n          { return JetTokens.NOT_IS;\n          }\n        case 143: break;\n        case 6: \n          { return JetTokens.MUL       ;\n          }\n        case 144: break;\n        case 20: \n          { return JetTokens.RBRACKET  ;\n          }\n        case 145: break;\n        case 50: \n          { return JetTokens.PLUSPLUS  ;\n          }\n        case 146: break;\n        case 75: \n          { return JetTokens.THIS_KEYWORD ;\n          }\n        case 147: break;\n        case 7: \n          { return JetTokens.DOT       ;\n          }\n        case 148: break;\n        case 25: \n          { return JetTokens.SEMICOLON ;\n          }\n        case 149: break;\n        case 44: \n          { return JetTokens.IF_KEYWORD ;\n          }\n        case 150: break;\n        case 11: \n          { return JetTokens.EQ        ;\n          }\n        case 151: break;\n        case 23: \n          { return JetTokens.LPAR      ;\n          }\n        case 152: break;\n        case 8: \n          { return JetTokens.MINUS     ;\n          }\n        case 153: break;\n        case 80: \n          { return JetTokens.FALSE_KEYWORD ;\n          }\n        case 154: break;\n        case 74: \n          { return JetTokens.TYPE_KEYWORD ;\n          }\n        case 155: break;\n        case 64: \n          { return JetTokens.FUN_KEYWORD ;\n          }\n        case 156: break;\n        case 43: \n          { return JetTokens.IS_KEYWORD ;\n          }\n        case 157: break;\n        case 33: \n          { return JetTokens.DIVEQ     ;\n          }\n        case 158: break;\n        case 88: \n          { return JetTokens.EXTENSION_KEYWORD ;\n          }\n        case 159: break;\n        case 72: \n          { return JetTokens.ELSE_KEYWORD ;\n          }\n        case 160: break;\n        case 41: \n          { return JetTokens.AS_KEYWORD ;\n          }\n        case 161: break;\n        case 42: \n          { return JetTokens.IN_KEYWORD ;\n          }\n        case 162: break;\n        case 46: \n          { return JetTokens.EQEQ      ;\n          }\n        case 163: break;\n        case 66: \n          { return JetTokens.VAL_KEYWORD ;\n          }\n        case 164: break;\n        case 67: \n          { return JetTokens.EQEQEQ    ;\n          }\n        case 165: break;\n        case 77: \n          { return JetTokens.CAPITALIZED_THIS_KEYWORD ;\n          }\n        case 166: break;\n        case 61: \n          { return JetTokens.NEW_KEYWORD ;\n          }\n        case 167: break;\n        case 34: \n          { return JetTokens.MULTEQ    ;\n          }\n        case 168: break;\n        case 10: \n          { return JetTokens.STRING_LITERAL;\n          }\n        case 169: break;\n        case 21: \n          { return JetTokens.LBRACE    ;\n          }\n        case 170: break;\n        case 84: \n          { return JetTokens.OBJECT_KEYWORD ;\n          }\n        case 171: break;\n        case 81: \n          { return JetTokens.BREAK_KEYWORD ;\n          }\n        case 172: break;\n        case 32: \n          { return JetTokens.BLOCK_COMMENT;\n          }\n        case 173: break;\n        case 37: \n          { return JetTokens.FILTER    ;\n          }\n        case 174: break;\n        case 27: \n          { return JetTokens.HASH      ;\n          }\n        case 175: break;\n        case 35: \n          { return JetTokens.MAP       ;\n          }\n        case 176: break;\n        default:\n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n            return null;\n          }\n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }","id":80386,"modified_method":"/**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public IElementType advance() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    CharSequence zzBufferL = zzBuffer;\n    char[] zzBufferArrayL = zzBufferArray;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n\n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++]:zzBufferL.charAt(zzCurrentPosL++);\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++]:zzBufferL.charAt(zzCurrentPosL++);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 3: \n          { return JetTokens.IDENTIFIER;\n          }\n        case 90: break;\n        case 64: \n          { return JetTokens.FOR_KEYWORD ;\n          }\n        case 91: break;\n        case 86: \n          { return JetTokens.RETURN_KEYWORD ;\n          }\n        case 92: break;\n        case 72: \n          { return JetTokens.NULL_KEYWORD ;\n          }\n        case 93: break;\n        case 14: \n          { return JetTokens.LT        ;\n          }\n        case 94: break;\n        case 46: \n          { return JetTokens.DO_KEYWORD ;\n          }\n        case 95: break;\n        case 13: \n          { return JetTokens.PLUS      ;\n          }\n        case 96: break;\n        case 29: \n          { return JetTokens.LONG_LITERAL;\n          }\n        case 97: break;\n        case 61: \n          { return JetTokens.RAW_STRING_LITERAL;\n          }\n        case 98: break;\n        case 50: \n          { return JetTokens.PLUSEQ    ;\n          }\n        case 99: break;\n        case 26: \n          { return JetTokens.COMMA     ;\n          }\n        case 100: break;\n        case 15: \n          { return JetTokens.GT        ;\n          }\n        case 101: break;\n        case 4: \n          { return JetTokens.WHITE_SPACE;\n          }\n        case 102: break;\n        case 84: \n          { return JetTokens.TYPEOF_KEYWORD ;\n          }\n        case 103: break;\n        case 24: \n          { return JetTokens.RPAR      ;\n          }\n        case 104: break;\n        case 48: \n          { return JetTokens.DOUBLE_ARROW;\n          }\n        case 105: break;\n        case 74: \n          { return JetTokens.TRUE_KEYWORD ;\n          }\n        case 106: break;\n        case 31: \n          { return JetTokens.FIELD_IDENTIFIER;\n          }\n        case 107: break;\n        case 54: \n          { return JetTokens.ANDAND    ;\n          }\n        case 108: break;\n        case 60: \n          { return JetTokens.DOC_COMMENT;\n          }\n        case 109: break;\n        case 30: \n          { return JetTokens.FLOAT_LITERAL;\n          }\n        case 110: break;\n        case 32: \n          { return JetTokens.EOL_COMMENT;\n          }\n        case 111: break;\n        case 77: \n          { return JetTokens.WHEN_KEYWORD ;\n          }\n        case 112: break;\n        case 17: \n          { return JetTokens.COLON     ;\n          }\n        case 113: break;\n        case 52: \n          { return JetTokens.LTEQ      ;\n          }\n        case 114: break;\n        case 41: \n          { return JetTokens.ARROW     ;\n          }\n        case 115: break;\n        case 19: \n          { return JetTokens.LBRACKET  ;\n          }\n        case 116: break;\n        case 59: \n          { yypushback(2); return JetTokens.INTEGER_LITERAL;\n          }\n        case 117: break;\n        case 9: \n          { return JetTokens.CHARACTER_LITERAL;\n          }\n        case 118: break;\n        case 66: \n          { return JetTokens.VAR_KEYWORD ;\n          }\n        case 119: break;\n        case 53: \n          { return JetTokens.GTEQ      ;\n          }\n        case 120: break;\n        case 2: \n          { return JetTokens.INTEGER_LITERAL;\n          }\n        case 121: break;\n        case 22: \n          { return JetTokens.RBRACE    ;\n          }\n        case 122: break;\n        case 79: \n          { return JetTokens.CLASS_KEYWORD ;\n          }\n        case 123: break;\n        case 12: \n          { return JetTokens.EXCL      ;\n          }\n        case 124: break;\n        case 63: \n          { return JetTokens.TRY_KEYWORD ;\n          }\n        case 125: break;\n        case 49: \n          { return JetTokens.EXCLEQ    ;\n          }\n        case 126: break;\n        case 40: \n          { return JetTokens.MINUSEQ   ;\n          }\n        case 127: break;\n        case 80: \n          { return JetTokens.THROW_KEYWORD ;\n          }\n        case 128: break;\n        case 83: \n          { return JetTokens.WHILE_KEYWORD ;\n          }\n        case 129: break;\n        case 39: \n          { return JetTokens.MINUSMINUS;\n          }\n        case 130: break;\n        case 87: \n          { return JetTokens.CONTINUE_KEYWORD ;\n          }\n        case 131: break;\n        case 69: \n          { return JetTokens.NOT_IN;\n          }\n        case 132: break;\n        case 5: \n          { return JetTokens.DIV       ;\n          }\n        case 133: break;\n        case 57: \n          { return JetTokens.ELVIS     ;\n          }\n        case 134: break;\n        case 16: \n          { return JetTokens.QUEST     ;\n          }\n        case 135: break;\n        case 55: \n          { return JetTokens.OROR      ;\n          }\n        case 136: break;\n        case 18: \n          { return JetTokens.PERC      ;\n          }\n        case 137: break;\n        case 71: \n          { return JetTokens.EXCLEQEQEQ;\n          }\n        case 138: break;\n        case 58: \n          { return JetTokens.PERCEQ    ;\n          }\n        case 139: break;\n        case 37: \n          { return JetTokens.RANGE     ;\n          }\n        case 140: break;\n        case 1: \n          { return TokenType.BAD_CHARACTER;\n          }\n        case 141: break;\n        case 56: \n          { return JetTokens.SAFE_ACCESS;\n          }\n        case 142: break;\n        case 88: \n          { return JetTokens.NAMESPACE_KEYWORD ;\n          }\n        case 143: break;\n        case 70: \n          { return JetTokens.NOT_IS;\n          }\n        case 144: break;\n        case 6: \n          { return JetTokens.MUL       ;\n          }\n        case 145: break;\n        case 20: \n          { return JetTokens.RBRACKET  ;\n          }\n        case 146: break;\n        case 51: \n          { return JetTokens.PLUSPLUS  ;\n          }\n        case 147: break;\n        case 76: \n          { return JetTokens.THIS_KEYWORD ;\n          }\n        case 148: break;\n        case 7: \n          { return JetTokens.DOT       ;\n          }\n        case 149: break;\n        case 25: \n          { return JetTokens.SEMICOLON ;\n          }\n        case 150: break;\n        case 45: \n          { return JetTokens.IF_KEYWORD ;\n          }\n        case 151: break;\n        case 11: \n          { return JetTokens.EQ        ;\n          }\n        case 152: break;\n        case 28: \n          { return JetTokens.AT        ;\n          }\n        case 153: break;\n        case 23: \n          { return JetTokens.LPAR      ;\n          }\n        case 154: break;\n        case 8: \n          { return JetTokens.MINUS     ;\n          }\n        case 155: break;\n        case 81: \n          { return JetTokens.FALSE_KEYWORD ;\n          }\n        case 156: break;\n        case 75: \n          { return JetTokens.TYPE_KEYWORD ;\n          }\n        case 157: break;\n        case 65: \n          { return JetTokens.FUN_KEYWORD ;\n          }\n        case 158: break;\n        case 44: \n          { return JetTokens.IS_KEYWORD ;\n          }\n        case 159: break;\n        case 34: \n          { return JetTokens.DIVEQ     ;\n          }\n        case 160: break;\n        case 89: \n          { return JetTokens.EXTENSION_KEYWORD ;\n          }\n        case 161: break;\n        case 73: \n          { return JetTokens.ELSE_KEYWORD ;\n          }\n        case 162: break;\n        case 42: \n          { return JetTokens.AS_KEYWORD ;\n          }\n        case 163: break;\n        case 43: \n          { return JetTokens.IN_KEYWORD ;\n          }\n        case 164: break;\n        case 47: \n          { return JetTokens.EQEQ      ;\n          }\n        case 165: break;\n        case 67: \n          { return JetTokens.VAL_KEYWORD ;\n          }\n        case 166: break;\n        case 68: \n          { return JetTokens.EQEQEQ    ;\n          }\n        case 167: break;\n        case 78: \n          { return JetTokens.CAPITALIZED_THIS_KEYWORD ;\n          }\n        case 168: break;\n        case 62: \n          { return JetTokens.NEW_KEYWORD ;\n          }\n        case 169: break;\n        case 35: \n          { return JetTokens.MULTEQ    ;\n          }\n        case 170: break;\n        case 10: \n          { return JetTokens.STRING_LITERAL;\n          }\n        case 171: break;\n        case 21: \n          { return JetTokens.LBRACE    ;\n          }\n        case 172: break;\n        case 85: \n          { return JetTokens.OBJECT_KEYWORD ;\n          }\n        case 173: break;\n        case 82: \n          { return JetTokens.BREAK_KEYWORD ;\n          }\n        case 174: break;\n        case 33: \n          { return JetTokens.BLOCK_COMMENT;\n          }\n        case 175: break;\n        case 38: \n          { return JetTokens.FILTER    ;\n          }\n        case 176: break;\n        case 27: \n          { return JetTokens.HASH      ;\n          }\n        case 177: break;\n        case 36: \n          { return JetTokens.MAP       ;\n          }\n        case 178: break;\n        default:\n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n            return null;\n          }\n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static int [] zzUnpackAttribute() {\n    int [] result = new int[205];\n    int offset = 0;\n    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);\n    return result;\n  }","id":80387,"modified_method":"private static int [] zzUnpackAttribute() {\n    int [] result = new int[206];\n    int offset = 0;\n    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);\n    return result;\n  }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static int [] zzUnpackAction() {\n    int [] result = new int[205];\n    int offset = 0;\n    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);\n    return result;\n  }","id":80388,"modified_method":"private static int [] zzUnpackAction() {\n    int [] result = new int[206];\n    int offset = 0;\n    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);\n    return result;\n  }","commit_id":"691c79c47798b58448ebae0ebeda3e61f250d470","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseModifierList() {\n        PsiBuilder.Marker list = mark();\n        boolean empty = true;\n        while (!eof()) {\n            if (at(LBRACKET)) {\n                parseAttributeAnnotation();\n            } else if (atSet(MODIFIER_KEYWORDS)) {\n                advance(); // MODIFIER\n            }\n            else {\n                if (!parseModifierSoftKeyword()) break;\n            }\n            empty = false;\n        }\n        if (empty) {\n            list.drop();\n        } else {\n            list.done(MODIFIER_LIST);\n        }\n    }","id":80389,"modified_method":"private void parseModifierList() {\n        PsiBuilder.Marker list = mark();\n        boolean empty = true;\n        while (!eof()) {\n            if (at(LBRACKET)) {\n                parseAttributeAnnotation();\n            } else if (atSet(MODIFIER_KEYWORDS)) {\n                advance(); // MODIFIER\n            }\n            else {\n                break;\n            }\n            empty = false;\n        }\n        if (empty) {\n            list.drop();\n        } else {\n            list.done(MODIFIER_LIST);\n        }\n    }","commit_id":"407a8e168428a5e0458d2f889294cc7e0250bb5b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parsePrimaryConstructorParameter() {\n        PsiBuilder.Marker param = mark();\n        parseModifierList();\n\n        if (at(VAR_KEYWORD) || at(VAL_KEYWORD)) {\n            advance(); // VAR_KEYWORD | VAL_KEYWORD\n        }\n\n        parseFunctionParameterRest();\n\n        param.done(PRIMARY_CONSTRUCTOR_PARAMETER);\n    }","id":80390,"modified_method":"private void parsePrimaryConstructorParameter() {\n        PsiBuilder.Marker param = mark();\n\n        int lastId = findLastBefore(TokenSet.create(IDENTIFIER), TokenSet.create(COMMA, RPAR, COLON), false);\n        createTruncatedBuilder(lastId).parseModifierList();\n\n        if (at(VAR_KEYWORD) || at(VAL_KEYWORD)) {\n            advance(); // VAR_KEYWORD | VAL_KEYWORD\n        }\n\n        parseFunctionParameterRest();\n\n        param.done(PRIMARY_CONSTRUCTOR_PARAMETER);\n    }","commit_id":"407a8e168428a5e0458d2f889294cc7e0250bb5b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseDelegationSpecifier() {\n        PsiBuilder.Marker specifier = mark();\n        parseAttributeList();\n\n        PsiBuilder.Marker delegator = mark();\n        if (at(LPAR)) {\n            error(\"Expecting type name\");\n        }\n        else {\n            parseTypeRef();\n        }\n\n        if (at(BY_KEYWORD)) {\n            advance(); // BY_KEYWORD\n            myExpressionParsing.parseExpression();\n            delegator.done(DELEGATOR_BY);\n        }\n        else if (at(LPAR)) {\n            myExpressionParsing.parseValueArgumentList();\n            delegator.done(DELEGATOR_SUPER_CALL);\n        }\n        else {\n            delegator.done(DELEGATOR_SUPER_CLASS);\n        }\n\n        specifier.done(DELEGATION_SPECIFIER);\n    }","id":80391,"modified_method":"private void parseDelegationSpecifier() {\n        PsiBuilder.Marker specifier = mark();\n        parseAttributeList();\n\n        PsiBuilder.Marker delegator = mark();\n        parseTypeRef();\n\n        if (at(BY_KEYWORD)) {\n            advance(); // BY_KEYWORD\n            myExpressionParsing.parseExpression();\n            delegator.done(DELEGATOR_BY);\n        }\n        else if (at(LPAR)) {\n            myExpressionParsing.parseValueArgumentList();\n            delegator.done(DELEGATOR_SUPER_CALL);\n        }\n        else {\n            delegator.done(DELEGATOR_SUPER_CLASS);\n        }\n\n        specifier.done(DELEGATION_SPECIFIER);\n    }","commit_id":"407a8e168428a5e0458d2f889294cc7e0250bb5b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private JetNodeType parseProperty() {\n        assert at(VAL_KEYWORD) || at(VAR_KEYWORD);\n\n        advance(); // VAL_KEYWORD or VAR_KEYWORD\n\n        PsiBuilder.Marker receiverTypeAttributes = mark();\n        parseAttributeList();\n\n        TokenSet propertyNameFollow = TokenSet.create(COLON, EQ, LBRACE, EOL_OR_SEMICOLON);\n        if (at(IDENTIFIER) && propertyNameFollow.contains(lookahead(1))) { // There's no explicit receiver specified\n            // val [a] name = foo\n            receiverTypeAttributes.done(RECEIVER_TYPE_ATTRIBUTES);\n            advance(); // IDENTIFIER\n        }\n        else { // There must be an explicit receiver\n            receiverTypeAttributes.rollbackTo(); // Attributes are a part of the receiver type\n            if (!TYPE_REF_FIRST.contains(tt())) {\n                errorUntil(\"Expecting receiver type or property name\", propertyNameFollow);\n            }\n            else {\n                // TODO: if this type is annotated with an attribute, and it is a single identifier,\n                // TODO: it is NOT an error (fun [a] foo()) -- annotation on receiver\n                parseTypeRef();\n                // The property name may appear as the last section of the type\n                if (at(DOT)) {\n                    advance(); // DOT\n                    expect(IDENTIFIER, \"Expecting property name\", propertyNameFollow);\n                }\n            }\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseTypeRef();\n        }\n\n        if (at(EQ)) {\n            advance(); // EQ\n            myExpressionParsing.parseExpression();\n        }\n\n        if (!at(EOL_OR_SEMICOLON) && at(LBRACE)) {\n            advance(); // LBRACE\n\n            // TODO: review\n            // TODO: $field = foo or something like this\n            if (at(RBRACE)) {\n                error(\"Expecting a getter and/or setter\");\n            }\n            else {\n                parsePropertyGetterOrSetter();\n            }\n            if (!at(RBRACE)) parsePropertyGetterOrSetter();\n\n            if (!at(RBRACE)) {\n                errorUntil(\"Expecting '}'\", TokenSet.create(RBRACE));\n            }\n\n            expect(RBRACE, \"Expecting '}'\");\n        }\n\n        consumeIf(SEMICOLON);\n\n        return PROPERTY;\n    }","id":80392,"modified_method":"private JetNodeType parseProperty() {\n        assert at(VAL_KEYWORD) || at(VAR_KEYWORD);\n\n        advance(); // VAL_KEYWORD or VAR_KEYWORD\n\n        TokenSet propertyNameFollow = TokenSet.create(COLON, EQ, LBRACE, EOL_OR_SEMICOLON);\n\n        int lastDot = findLastDotBefore(propertyNameFollow);\n\n        if (lastDot == -1) {\n            parseAttributeList();\n            expect(IDENTIFIER, \"Expecting property name or receiver type\", propertyNameFollow);\n        }\n        else {\n            // The code below is NOT REENTRANT\n            myBuilder.setEOFPosition(lastDot);\n            parseTypeRef();\n            myBuilder.unSetEOFPosition();\n\n            expect(DOT, \"Expecting '.' before a property name\", propertyNameFollow);\n            expect(IDENTIFIER, \"Expecting property name\", propertyNameFollow);\n        }\n\n\n//        PsiBuilder.Marker receiverTypeAttributes = mark();\n//        parseAttributeList();\n//\n//        if (at(IDENTIFIER) && propertyNameFollow.contains(lookahead(1))) { // There's no explicit receiver specified\n//            // val [a] name = foo\n//            receiverTypeAttributes.done(RECEIVER_TYPE_ATTRIBUTES);\n//            advance(); // IDENTIFIER\n//        }\n//        else { // There must be an explicit receiver\n//            receiverTypeAttributes.rollbackTo(); // Attributes are a part of the receiver type\n//            if (!TYPE_REF_FIRST.contains(tt())) {\n//                errorUntil(\"Expecting receiver type or property name\", propertyNameFollow);\n//            }\n//            else {\n//                // TODO: if this type is annotated with an attribute, and it is a single identifier,\n//                // TODO: it is NOT an error (fun [a] foo()) -- annotation on receiver\n//                parseTypeRef();\n//                // The property name may appear as the last section of the type\n//                if (at(DOT)) {\n//                    advance(); // DOT\n//                    expect(IDENTIFIER, \"Expecting property name\", propertyNameFollow);\n//                }\n//            }\n//        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseTypeRef();\n        }\n\n        if (at(EQ)) {\n            advance(); // EQ\n            myExpressionParsing.parseExpression();\n        }\n\n        if (!at(EOL_OR_SEMICOLON) && at(LBRACE)) {\n            advance(); // LBRACE\n\n            // TODO: review\n            // TODO: $field = foo or something like this\n            if (at(RBRACE)) {\n                error(\"Expecting a getter and/or setter\");\n            }\n            else {\n                parsePropertyGetterOrSetter();\n            }\n            if (!at(RBRACE)) parsePropertyGetterOrSetter();\n\n            if (!at(RBRACE)) {\n                errorUntil(\"Expecting '}'\", TokenSet.create(RBRACE));\n            }\n\n            expect(RBRACE, \"Expecting '}'\");\n        }\n\n        consumeIf(SEMICOLON);\n\n        return PROPERTY;\n    }","commit_id":"6f241b7f9f97a3b6761f9f115805b621518556b2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private JetNodeType parseFunction() {\n        assert at(FUN_KEYWORD);\n\n        advance(); // FUN_KEYWORD\n\n        // TODO: This code is very close to what we have for properties\n\n\n        int lastDot = findLastDotBeforeLPAR();\n\n        if (lastDot == -1) { // There's no explicit receiver type specified\n            parseAttributeList();\n            expect(IDENTIFIER, \"Expecting function name or receiver type\");\n        } else {\n            // The code below in NOT REENTRANT\n            myBuilder.setEOFPosition(lastDot);\n            parseTypeRef();\n            myBuilder.unSetEOFPosition();\n\n            TokenSet functionNameFollow = TokenSet.create(LT, LPAR, COLON, EQ);\n            expect(DOT, \"Expecting '.' before a function name\", functionNameFollow);\n            expect(IDENTIFIER, \"Expecting function name\", functionNameFollow);\n\n        }\n\n//        PsiBuilder.Marker receiverTypeAttributes = mark();\n//\n//        parseAttributeList();\n//\n//        if (at(IDENTIFIER) && lookahead(1) == LPAR) { // There's no explicit receiver specified\n//            // fun [a] name() = foo\n//            receiverTypeAttributes.done(RECEIVER_TYPE_ATTRIBUTES);\n//            advance(); // IDENTIFIER\n//        }\n//        else { // There must be an explicit receiver\n//            receiverTypeAttributes.rollbackTo(); // Attributes are a part of the receiver type\n//            if (!TYPE_REF_FIRST.contains(tt())) {\n//                errorUntil(\"Expecting receiver type or property name\", TokenSet.create(LPAR, EOL_OR_SEMICOLON));\n//            }\n//            else {\n//                // TODO: if this type is annotated with an attribute, and it is a single identifier,\n//                // TODO: it is NOT an error (fun [a] foo()) -- annotation on receiver\n//                parseTypeRef();\n//                // The property name may appear as the last section of the type\n//                if (at(DOT)) {\n//                    advance(); // DOT\n//                    expect(IDENTIFIER, \"Expecting property name\", TokenSet.create(LPAR));\n//                }\n//            }\n//        }\n\n        TokenSet valueParametersFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON, RPAR);\n\n        parseTypeParameterList(TokenSet.orSet(TokenSet.create(LPAR), valueParametersFollow));\n\n        parseValueParameterList(false, valueParametersFollow);\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseTypeRef();\n        }\n\n        if (at(EOL_OR_SEMICOLON)) {\n            consumeIf(SEMICOLON);\n        } else {\n            parseFunctionBody();\n        }\n\n        return FUN;\n    }","id":80393,"modified_method":"private JetNodeType parseFunction() {\n        assert at(FUN_KEYWORD);\n\n        advance(); // FUN_KEYWORD\n\n        // TODO: This code is very close to what we have for properties\n\n\n        int lastDot = findLastDotBefore(TokenSet.create(LPAR));\n\n        if (lastDot == -1) { // There's no explicit receiver type specified\n            parseAttributeList();\n            expect(IDENTIFIER, \"Expecting function name or receiver type\");\n        } else {\n            // The code below in NOT REENTRANT\n            myBuilder.setEOFPosition(lastDot);\n            parseTypeRef();\n            myBuilder.unSetEOFPosition();\n\n            TokenSet functionNameFollow = TokenSet.create(LT, LPAR, COLON, EQ);\n            expect(DOT, \"Expecting '.' before a function name\", functionNameFollow);\n            expect(IDENTIFIER, \"Expecting function name\", functionNameFollow);\n        }\n\n//        PsiBuilder.Marker receiverTypeAttributes = mark();\n//\n//        parseAttributeList();\n//\n//        if (at(IDENTIFIER) && lookahead(1) == LPAR) { // There's no explicit receiver specified\n//            // fun [a] name() = foo\n//            receiverTypeAttributes.done(RECEIVER_TYPE_ATTRIBUTES);\n//            advance(); // IDENTIFIER\n//        }\n//        else { // There must be an explicit receiver\n//            receiverTypeAttributes.rollbackTo(); // Attributes are a part of the receiver type\n//            if (!TYPE_REF_FIRST.contains(tt())) {\n//                errorUntil(\"Expecting receiver type or property name\", TokenSet.create(LPAR, EOL_OR_SEMICOLON));\n//            }\n//            else {\n//                // TODO: if this type is annotated with an attribute, and it is a single identifier,\n//                // TODO: it is NOT an error (fun [a] foo()) -- annotation on receiver\n//                parseTypeRef();\n//                // The property name may appear as the last section of the type\n//                if (at(DOT)) {\n//                    advance(); // DOT\n//                    expect(IDENTIFIER, \"Expecting property name\", TokenSet.create(LPAR));\n//                }\n//            }\n//        }\n\n        TokenSet valueParametersFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON, RPAR);\n\n        parseTypeParameterList(TokenSet.orSet(TokenSet.create(LPAR), valueParametersFollow));\n\n\n        parseValueParameterList(false, valueParametersFollow);\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseTypeRef();\n        }\n\n        if (at(EOL_OR_SEMICOLON)) {\n            consumeIf(SEMICOLON);\n        } else {\n            parseFunctionBody();\n        }\n\n        return FUN;\n    }","commit_id":"6f241b7f9f97a3b6761f9f115805b621518556b2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseTopLevelObject() {\n        PsiBuilder.Marker decl = mark();\n        parseModifierList();\n\n        IElementType keywordToken = tt();\n        JetNodeType declType = null;\n        if (keywordToken == NAMESPACE_KEYWORD) {\n            declType = parseNamespaceBlock();\n        }\n        else if (keywordToken == CLASS_KEYWORD) {\n            declType = parseClass();\n        }\n        else if (keywordToken == EXTENSION_KEYWORD) {\n            declType = parseExtension();\n        }\n        else if (keywordToken == FUN_KEYWORD) {\n            declType = parseFunction();\n        }\n        else if (keywordToken == VAL_KEYWORD || keywordToken == VAR_KEYWORD) {\n            declType = parseProperty();\n        }\n        else if (keywordToken == TYPE_KEYWORD) {\n            declType = parseTypedef();\n        }\n        else if (keywordToken == DECOMPOSER_KEYWORD) {\n            declType = parseDecomposer();\n        }\n\n        if (declType == null) {\n            errorAndAdvance(\"Expecting namespace or top level declaration\");\n            decl.drop();\n        }\n        else {\n            decl.done(declType);\n        }\n    }","id":80394,"modified_method":"private void parseTopLevelObject() {\n        PsiBuilder.Marker decl = mark();\n        parseModifierList();\n\n        IElementType keywordToken = tt();\n        JetNodeType declType = null;\n        if (keywordToken == NAMESPACE_KEYWORD) {\n            declType = parseNamespaceBlock();\n        }\n        else if (keywordToken == CLASS_KEYWORD) {\n            declType = parseClass();\n        }\n        else if (keywordToken == EXTENSION_KEYWORD) {\n            declType = parseExtension();\n        }\n        else if (keywordToken == FUN_KEYWORD) {\n            declType = parseFunction();\n        }\n        else if (keywordToken == VAL_KEYWORD || keywordToken == VAR_KEYWORD) {\n            declType = parseProperty();\n        }\n        else if (keywordToken == TYPE_KEYWORD) {\n            declType = parseTypeDef();\n        }\n        else if (keywordToken == DECOMPOSER_KEYWORD) {\n            declType = parseDecomposer();\n        }\n\n        if (declType == null) {\n            errorAndAdvance(\"Expecting namespace or top level declaration\");\n            decl.drop();\n        }\n        else {\n            decl.done(declType);\n        }\n    }","commit_id":"6f241b7f9f97a3b6761f9f115805b621518556b2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private int findLastDotBeforeLPAR() {\n        PsiBuilder.Marker currentPosition = mark();\n        int lastDot = -1;\n        int openAngleBrackets = 0;\n        int openBraces = 0;\n        int openParentheses = 0;\n        int openBrackets = 0;\n        while (!eof()) {\n            if (at(LPAR)) {\n                if (openAngleBrackets == 0\n                    && openBrackets == 0\n                    && openBraces == 0\n                    && openParentheses == 0) break;\n                openParentheses++;\n            }\n            else if (at(LT)) {\n                openAngleBrackets++;\n            }\n            else if (at(LBRACE)) {\n                openBraces++;\n            }\n            else if (at(LBRACKET)) {\n                openBrackets++;\n            }\n            else if (at(RPAR)) {\n                openParentheses--;\n            }\n            else if (at(GT)) {\n                openAngleBrackets--;\n            }\n            else if (at(RBRACE)) {\n                openBraces--;\n            }\n            else if (at(RBRACKET)) {\n                openBrackets--;\n            }\n            else if (at(DOT)\n                    && openAngleBrackets == 0\n                    && openBrackets == 0\n                    && openBraces == 0\n                    && openParentheses == 0) {\n                lastDot = myBuilder.getCurrentOffset();\n            }\n            advance(); // skip token\n        }\n        currentPosition.rollbackTo();\n        return lastDot;\n    }","id":80395,"modified_method":"private int findLastDotBefore(TokenSet stopSet) {\n        PsiBuilder.Marker currentPosition = mark();\n        int lastDot = -1;\n        int openAngleBrackets = 0;\n        int openBraces = 0;\n        int openParentheses = 0;\n        int openBrackets = 0;\n        IElementType previousToken = null;\n        while (!eof()) {\n            if (atSet(stopSet)) {\n                if (openAngleBrackets == 0\n                    && openBrackets == 0\n                    && openBraces == 0\n                    && openParentheses == 0\n                    && previousToken != DOT) break;\n            }\n            if (at(LPAR)) {\n                openParentheses++;\n            }\n            else if (at(LT)) {\n                openAngleBrackets++;\n            }\n            else if (at(LBRACE)) {\n                openBraces++;\n            }\n            else if (at(LBRACKET)) {\n                openBrackets++;\n            }\n            else if (at(RPAR)) {\n                openParentheses--;\n            }\n            else if (at(GT)) {\n                openAngleBrackets--;\n            }\n            else if (at(RBRACE)) {\n                openBraces--;\n            }\n            else if (at(RBRACKET)) {\n                openBrackets--;\n            }\n            else if (at(DOT)\n                    && openAngleBrackets == 0\n                    && openBrackets == 0\n                    && openBraces == 0\n                    && openParentheses == 0) {\n                lastDot = myBuilder.getCurrentOffset();\n            }\n            previousToken = tt();\n            advance(); // skip token\n        }\n        currentPosition.rollbackTo();\n        return lastDot;\n    }","commit_id":"6f241b7f9f97a3b6761f9f115805b621518556b2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private JetNodeType parseTypedef() {\n        assert at(TYPE_KEYWORD);\n\n        advance(); // TYPE_KEYWORD\n\n        expect(IDENTIFIER, \"Type name expected\", TokenSet.orSet(TokenSet.create(LT, EQ, SEMICOLON), TOPLEVEL_OBJECT_FIRST));\n\n        parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        expect(EQ, \"Expecting '='\", TokenSet.orSet(TOPLEVEL_OBJECT_FIRST, TokenSet.create(SEMICOLON)));\n\n        parseTypeRef();\n\n        consumeIf(SEMICOLON);\n\n        return TYPEDEF;\n    }","id":80396,"modified_method":"private JetNodeType parseTypeDef() {\n        assert at(TYPE_KEYWORD);\n\n        advance(); // TYPE_KEYWORD\n\n        expect(IDENTIFIER, \"Type name expected\", TokenSet.orSet(TokenSet.create(LT, EQ, SEMICOLON), TOPLEVEL_OBJECT_FIRST));\n\n        parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        expect(EQ, \"Expecting '='\", TokenSet.orSet(TOPLEVEL_OBJECT_FIRST, TokenSet.create(SEMICOLON)));\n\n        parseTypeRef();\n\n        consumeIf(SEMICOLON);\n\n        return TYPEDEF;\n    }","commit_id":"6f241b7f9f97a3b6761f9f115805b621518556b2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Removes all top level folders that are hidden, header, or footer and\n     * then changes all node ids to their globally safe incorporated version.\n     */\n    void fragmentizeLayout( UserView view,\n                            FragmentDefinition fragment )\n    {\n        // if fragment not bound to user or layout empty due to error, return\n        if ( view.getUserId() == -1 ||\n             view.layout == null )\n            return;\n\n        // remove all non-regular or hidden top level folders\n        // skip root folder that is only child of top level layout element\n        Element layout = view.layout.getDocumentElement();\n        Element root = (Element) layout.getFirstChild();\n        NodeList children = root.getChildNodes();\n\n        // process the children backwards since as we delete some the indices\n        // shift around\n        for( int i=children.getLength()-1; i>=0; i-- )\n        {\n            Node node = children.item(i);\n            if ( node.getNodeType() == Node.ELEMENT_NODE &&\n                 node.getNodeName().equals(\"folder\") )\n            {\n                Element folder = (Element) node;\n\n                // strip out folder types 'header', 'footer' and regular, \n                // hidden folder \"User Preferences\" since users have their own\n                if ( ! folder.getAttribute( \"type\" ).equals( \"regular\" ) ||\n                     folder.getAttribute( \"hidden\" ).equals( \"true\" ) )\n                    try\n                    {\n                        root.removeChild( folder );\n                    }\n                    catch( Exception e )\n                    {\n                        throw new RuntimeException(\n                              \"Anomaly occurred while stripping out \" +\n                              \" portions of layout for fragment '\" +\n                              fragment.getName() +\n                              \"'. The fragment will not be available for \" +\n                              \"inclusion into user layouts.\", e );\n                    }\n            }\n        }\n        // now re-lable all remaining nodes below root to have a safe system\n        // wide id.\n\n        setIdsAndAttribs( layout, layout.getAttribute( Constants.ATT_ID ),\n                          \"\" + fragment.getIndex(),\n                          \"\" + fragment.getPrecedence() );\n    }","id":80397,"modified_method":"/**\n     * Removes unwanted and hidden folders, then changes all node ids to their \n     * globally safe incorporated version.\n     */\n    void fragmentizeLayout( UserView view,\n                            FragmentDefinition fragment )\n    {\n        // if fragment not bound to user or layout empty due to error, return\n        if ( view.getUserId() == -1 ||\n             view.layout == null )\n            return;\n\n        // Choose what types of content to apply from the fragment\n        Pattern contentPattern = STANDARD_PATTERN;  // default\n        boolean allowExpandedContent = Boolean.parseBoolean(PropertiesManager.getProperty(PROPERTY_ALLOW_EXPANDED_CONTENT));\n        if (allowExpandedContent) {\n            contentPattern = EXPANDED_PATTERN;\n        }\n\n        // remove all non-regular or hidden top level folders\n        // skip root folder that is only child of top level layout element\n        Element layout = view.layout.getDocumentElement();\n        Element root = (Element) layout.getFirstChild();\n        NodeList children = root.getChildNodes();\n\n        // process the children backwards since as we delete some the indices\n        // shift around\n        for( int i=children.getLength()-1; i>=0; i-- )\n        {\n            Node node = children.item(i);\n            if ( node.getNodeType() == Node.ELEMENT_NODE &&\n                 node.getNodeName().equals(\"folder\") )\n            {\n                Element folder = (Element) node;\n\n                // strip out folder types 'header', 'footer' and regular, \n                // hidden folder \"User Preferences\" since users have their own\n                boolean isApplicable = contentPattern.matcher(folder.getAttribute(\"type\")).matches();\n                if (!isApplicable || folder.getAttribute(\"hidden\").equals(\"true\")) {\n                    try\n                    {\n                        root.removeChild( folder );\n                    }\n                    catch( Exception e )\n                    {\n                        throw new RuntimeException(\n                              \"Anomaly occurred while stripping out \" +\n                              \" portions of layout for fragment '\" +\n                              fragment.getName() +\n                              \"'. The fragment will not be available for \" +\n                              \"inclusion into user layouts.\", e );\n                    }\n                }\n            }\n        }\n        // now re-lable all remaining nodes below root to have a safe system\n        // wide id.\n\n        setIdsAndAttribs( layout, layout.getAttribute( Constants.ATT_ID ),\n                          \"\" + fragment.getIndex(),\n                          \"\" + fragment.getPrecedence() );\n    }","commit_id":"ec5ba68d97ef2ecc708d3da6f4ae54d2e7e5f732","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Removes all top level folders that are hidden, header, or footer and\n     * then changes all node ids to their globally safe incorporated version.\n     */\n    void fragmentizeLayout( UserView view,\n                            FragmentDefinition fragment )\n    {\n        // if fragment not bound to user or layout empty due to error, return\n        if ( view.getUserId() == -1 ||\n             view.layout == null )\n            return;\n\n        // remove all non-regular or hidden top level folders\n        // skip root folder that is only child of top level layout element\n        Element layout = view.layout.getDocumentElement();\n        Element root = (Element) layout.getFirstChild();\n        NodeList children = root.getChildNodes();\n\n        // process the children backwards since as we delete some the indices\n        // shift around\n        for( int i=children.getLength()-1; i>=0; i-- )\n        {\n            Node node = children.item(i);\n            if ( node.getNodeType() == Node.ELEMENT_NODE &&\n                 node.getNodeName().equals(\"folder\") )\n            {\n                Element folder = (Element) node;\n\n                // strip out folder types 'header', 'footer' and regular, \n                // hidden folder \"User Preferences\" since users have their own\n                if ( ! folder.getAttribute( \"type\" ).equals( \"regular\" ) ||\n                     folder.getAttribute( \"hidden\" ).equals( \"true\" ) )\n                    try\n                    {\n                        root.removeChild( folder );\n                    }\n                    catch( Exception e )\n                    {\n                        throw new RuntimeException(\n                              \"Anomaly occurred while stripping out \" +\n                              \" portions of layout for fragment '\" +\n                              fragment.getName() +\n                              \"'. The fragment will not be available for \" +\n                              \"inclusion into user layouts.\", e );\n                    }\n            }\n        }\n        // now re-lable all remaining nodes below root to have a safe system\n        // wide id.\n\n        setIdsAndAttribs( layout, layout.getAttribute( Constants.ATT_ID ),\n                          \"\" + fragment.getIndex(),\n                          \"\" + fragment.getPrecedence() );\n    }","id":80398,"modified_method":"/**\n     * Removes all top level folders that are hidden, header, or footer and\n     * then changes all node ids to their globally safe incorporated version.\n     */\n    void fragmentizeLayout( UserView view,\n                            FragmentDefinition fragment )\n    {\n        // if fragment not bound to user or layout empty due to error, return\n        if ( view.getUserId() == -1 ||\n             view.layout == null )\n            return;\n        \n        // Choose what types of content to apply from the fragment\n        Pattern contentPattern = STANDARD_PATTERN;  // default\n        boolean allowExpandedContent = Boolean.parseBoolean(dls.getProperty(PROPERTY_ALLOW_EXPANDED_CONTENT));\n        if (allowExpandedContent) {\n            contentPattern = EXPANDED_PATTERN;\n        }\n\n        // remove all non-regular or hidden top level folders\n        // skip root folder that is only child of top level layout element\n        Element layout = view.layout.getDocumentElement();\n        Element root = (Element) layout.getFirstChild();\n        NodeList children = root.getChildNodes();\n\n        // process the children backwards since as we delete some the indices\n        // shift around\n        for( int i=children.getLength()-1; i>=0; i-- ) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"folder\")) {\n                Element folder = (Element) node;\n\n                // strip out folder types 'header', 'footer' and regular, \n                // hidden folder \"User Preferences\" since users have their own\n                boolean isApplicable = contentPattern.matcher(folder.getAttribute(\"type\")).matches();\n                if (!isApplicable || folder.getAttribute(\"hidden\").equals(\"true\")) {\n                    try {\n                        root.removeChild(folder);\n                    } catch(Exception e) {\n                        throw new RuntimeException(\n                              \"Anomaly occurred while stripping out \" +\n                              \" portions of layout for fragment '\" +\n                              fragment.getName() +\n                              \"'. The fragment will not be available for \" +\n                              \"inclusion into user layouts.\", e );\n                    }\n                }\n            }\n        }\n        // now re-lable all remaining nodes below root to have a safe system\n        // wide id.\n\n        setIdsAndAttribs( layout, layout.getAttribute( Constants.ATT_ID ),\n                          \"\" + fragment.getIndex(),\n                          \"\" + fragment.getPrecedence() );\n    }","commit_id":"eef4cd68737c22a4ad648dd916a2c3eb3e6748c7","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void writeImageToFile(BufferedImage image, File file) throws IOException {\n            Iterator iter = ImageIO.getImageWritersByFormatName(\"jpg\");\n\n            ImageWriter writer = (ImageWriter) iter.next();\n            ImageWriteParam iwp = writer.getDefaultWriteParam();\n            iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);\n            iwp.setCompressionQuality(0.96f);\n\n            FileImageOutputStream output = new FileImageOutputStream(file);\n            writer.setOutput(output);\n            IIOImage image2 = new IIOImage(image, null, null);\n            writer.write(null, image2, iwp);\n            writer.dispose();\n        }","id":80399,"modified_method":"private void writeImageToFile(BufferedImage image, File file) throws IOException {\n            Iterator iter = ImageIO.getImageWritersByFormatName(\"jpg\");\n\n            ImageWriter writer = (ImageWriter) iter.next();\n            ImageWriteParam iwp = writer.getDefaultWriteParam();\n            iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);\n            iwp.setCompressionQuality(0.96f);\n\n            FileImageOutputStream output = new FileImageOutputStream(file);\n            writer.setOutput(output);\n            IIOImage image2 = new IIOImage(image, null, null);\n            writer.write(null, image2, iwp);\n            writer.dispose();\n            output.close();\n        }","commit_id":"e0d4285a69e909c7e0da2ffd6dc40c2e14279dc8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n        public void run() {\n            try {\n                createDirForCard(card, imagesPath);\n\n                boolean withCollectorId = false;\n                if (card.getName().equals(\"Forest\") || card.getName().equals(\"Mountain\") || card.getName().equals(\"Swamp\")\n                        || card.getName().equals(\"Island\") || card.getName().equals(\"Plains\")) {\n                    withCollectorId = true;\n                }\n                File fileOut = new File(CardImageUtils.getImagePath(card, withCollectorId));\n\n                BufferedInputStream in = new BufferedInputStream(url.openConnection(p).getInputStream());\n                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(fileOut));\n\n                byte[] buf = new byte[1024];\n                int len = 0;\n                while ((len = in.read(buf)) != -1) {\n                    // user cancelled\n                    if (cancel) {\n                        in.close();\n                        out.flush();\n                        out.close();\n                        // delete what was written so far\n                        fileOut.delete();\n                    }\n                    out.write(buf, 0, len);\n                }\n\n                in.close();\n                out.flush();\n                out.close();\n\n                if (card.isTwoFacedCard()) {\n                    BufferedImage image = ImageIO.read(fileOut);\n                    if (image.getHeight() == 470) {\n                        BufferedImage renderedImage = new BufferedImage(265, 370, BufferedImage.TYPE_INT_RGB);\n                        renderedImage.getGraphics();\n                        Graphics2D graphics2D = renderedImage.createGraphics();\n                        if (card.isTwoFacedCard() && card.isSecondSide()) {\n                            graphics2D.drawImage(image, 0, 0, 265, 370, 313, 62, 578, 432, null);\n                        } else {\n                            graphics2D.drawImage(image, 0, 0, 265, 370, 41, 62, 306, 432, null);\n                        }\n                        graphics2D.dispose();\n                        writeImageToFile(renderedImage, fileOut);\n                    }\n                }\n\n                synchronized (sync) {\n                    update(cardIndex + 1);\n                }\n            } catch (Exception e) {\n                log.error(e, e);\n            }\n\n        }","id":80400,"modified_method":"@Override\n        public void run() {\n            try {\n                createDirForCard(card, imagesPath);\n\n                boolean withCollectorId = false;\n                if (basicLandPattern.matcher(card.getName()).matches()) {\n                    withCollectorId = true;\n                }\n                File fileOut = new File(CardImageUtils.getImagePath(card, withCollectorId));\n\n                BufferedInputStream in = new BufferedInputStream(url.openConnection(p).getInputStream());\n                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(fileOut));\n\n                byte[] buf = new byte[1024];\n                int len = 0;\n                while ((len = in.read(buf)) != -1) {\n                    // user cancelled\n                    if (cancel) {\n                        in.close();\n                        out.flush();\n                        out.close();\n                        // delete what was written so far\n                        fileOut.delete();\n                    }\n                    out.write(buf, 0, len);\n                }\n\n                in.close();\n                out.flush();\n                out.close();\n\n                if (card.isTwoFacedCard()) {\n                    BufferedImage image = ImageIO.read(fileOut);\n                    if (image.getHeight() == 470) {\n                        BufferedImage renderedImage = new BufferedImage(265, 370, BufferedImage.TYPE_INT_RGB);\n                        renderedImage.getGraphics();\n                        Graphics2D graphics2D = renderedImage.createGraphics();\n                        if (card.isTwoFacedCard() && card.isSecondSide()) {\n                            graphics2D.drawImage(image, 0, 0, 265, 370, 313, 62, 578, 432, null);\n                        } else {\n                            graphics2D.drawImage(image, 0, 0, 265, 370, 41, 62, 306, 432, null);\n                        }\n                        graphics2D.dispose();\n                        writeImageToFile(renderedImage, fileOut);\n                    }\n                }\n\n                synchronized (sync) {\n                    update(cardIndex + 1);\n                }\n            } catch (Exception e) {\n                log.error(e, e);\n            }\n\n        }","commit_id":"e0d4285a69e909c7e0da2ffd6dc40c2e14279dc8","url":"https://github.com/magefree/mage"},{"original_method":"public static boolean checkForNewCards(Set<Card> allCards, String imagesPath) {\n        File file;\n        for (Card card : allCards) {\n            if (card.getCardNumber() > 0 && !card.getExpansionSetCode().isEmpty()) {\n                CardInfo url = new CardInfo(card.getName(), card.getExpansionSetCode(), card.getCardNumber(), 0, false, card.canTransform(), card.isNightCard());\n                boolean withCollectorId = false;\n                if (card.getName().equals(\"Forest\") || card.getName().equals(\"Mountain\") || card.getName().equals(\"Swamp\") || card.getName().equals(\"Island\") || card.getName().equals(\"Plains\")) {\n                    withCollectorId = true;\n                }\n                file = new File(CardImageUtils.getImagePath(url, withCollectorId, imagesPath));\n                if (!file.exists())\n                    return true;\n            }\n        }        \n        return false;\n    }","id":80401,"modified_method":"public static boolean checkForNewCards(Set<Card> allCards, String imagesPath) {\n        File file;\n        for (Card card : allCards) {\n            if (card.getCardNumber() > 0 && !card.getExpansionSetCode().isEmpty()) {\n                CardInfo url = new CardInfo(card.getName(), card.getExpansionSetCode(), card.getCardNumber(), 0, false, card.canTransform(), card.isNightCard());\n                boolean withCollectorId = false;\n                if (basicLandPattern.matcher(card.getName()).matches()) {\n                    withCollectorId = true;\n                }\n                file = new File(CardImageUtils.getImagePath(url, withCollectorId, imagesPath));\n                if (!file.exists())\n                    return true;\n            }\n        }        \n        return false;\n    }","commit_id":"e0d4285a69e909c7e0da2ffd6dc40c2e14279dc8","url":"https://github.com/magefree/mage"},{"original_method":"private void update(int card) {\n        this.cardIndex = card;\n        int count = DownloadPictures.this.cards.size();\n\n        if (cardIndex < count) {\n        float mb = ((count - card) * cardImageSource.getAverageSize()) / 1024;\n            bar.setString(String.format(\"%d of %d cards finished! Please wait! [%.1f Mb]\",\n                    card, count, mb));\n        } else {\n            Iterator<CardInfo> cardsIterator = DownloadPictures.this.cards.iterator();\n            while (cardsIterator.hasNext()) {\n                CardInfo cardInfo = cardsIterator.next();\n                boolean withCollectorId = false;\n                if (cardInfo.getName().equals(\"Forest\") || cardInfo.getName().equals(\"Mountain\") || cardInfo.getName().equals(\"Swamp\") || cardInfo.getName().equals(\"Island\")\n                        || cardInfo.getName().equals(\"Plains\")) {\n                    withCollectorId = true;\n                }\n                File file = new File(CardImageUtils.getImagePath(cardInfo, withCollectorId));\n                if (file.exists()) {\n                    cardsIterator.remove();\n                }\n            }\n            count = DownloadPictures.this.cards.size();\n\n            if (count == 0) {\n                bar.setString(String.format(\"0 cards remaining! Please close!\", count));\n            } else {\n                bar.setString(String.format(\"%d cards remaining! Please choose another source!\", count));\n                executor = Executors.newFixedThreadPool(10);\n                startDownloadButton.setEnabled(true);\n            }\n        }\n    }","id":80402,"modified_method":"private void update(int card) {\n        this.cardIndex = card;\n        int count = DownloadPictures.this.cards.size();\n\n        if (cardIndex < count) {\n        float mb = ((count - card) * cardImageSource.getAverageSize()) / 1024;\n            bar.setString(String.format(\"%d of %d cards finished! Please wait! [%.1f Mb]\",\n                    card, count, mb));\n        } else {\n            Iterator<CardInfo> cardsIterator = DownloadPictures.this.cards.iterator();\n            while (cardsIterator.hasNext()) {\n                CardInfo cardInfo = cardsIterator.next();\n                boolean withCollectorId = false;\n                if (basicLandPattern.matcher(cardInfo.getName()).matches()) {\n                    withCollectorId = true;\n                }\n                File file = new File(CardImageUtils.getImagePath(cardInfo, withCollectorId));\n                if (file.exists()) {\n                    cardsIterator.remove();\n                }\n            }\n            count = DownloadPictures.this.cards.size();\n\n            if (count == 0) {\n                bar.setString(String.format(\"0 cards remaining! Please close!\", count));\n            } else {\n                bar.setString(String.format(\"%d cards remaining! Please choose another source!\", count));\n                executor = Executors.newFixedThreadPool(10);\n                startDownloadButton.setEnabled(true);\n            }\n        }\n    }","commit_id":"e0d4285a69e909c7e0da2ffd6dc40c2e14279dc8","url":"https://github.com/magefree/mage"},{"original_method":"private static ArrayList<CardInfo> getNeededCards(Set<Card> allCards, String imagesPath) {\n\n        ArrayList<CardInfo> cardsToDownload = new ArrayList<CardInfo>();\n\n        /**\n         * read all card names and urls\n         */\n        ArrayList<CardInfo> allCardsUrls = new ArrayList<CardInfo>();\n\n        try {\n            offlineMode = true;\n\n            for (Card card : allCards) {\n                if (card.getCardNumber() > 0 && !card.getExpansionSetCode().isEmpty()) {\n                    String cardName = card.getName();\n                    CardInfo url = new CardInfo(cardName, card.getExpansionSetCode(), card.getCardNumber(), 0, false, card.canTransform(), card.isNightCard());\n                    if (cardName.equals(\"Forest\") || cardName.equals(\"Swamp\") || cardName.equals(\"Mountain\") || cardName.equals(\"Island\") || cardName.equals(\"Plains\")) {\n                        url.setDownloadName(card.getClass().getName().replace(card.getClass().getPackage().getName() + \".\", \"\"));\n                    }\n                    if (card.isFlipCard()) {\n                        url.setFlipCard(true);\n                    }\n                    allCardsUrls.add(url);\n                    if (card.canTransform()) {\n                        // add second side for downloading\n                        // it has the same expansion set code and card number as original one\n                        // second side = true;\n                        Card secondSide = card.getSecondCardFace();\n                        url = new CardInfo(secondSide.getName(), card.getExpansionSetCode(), card.getCardNumber(), 0, false, card.canTransform(), true);\n                        allCardsUrls.add(url);\n                    }\n                } else {\n                    if (card.getCardNumber() < 1) {\n                        System.err.println(\"There was a critical error!\");\n                        log.error(\"Card has no collector ID and won't be sent to client: \" + card);\n                    } else if (card.getExpansionSetCode().isEmpty()) {\n                        System.err.println(\"There was a critical error!\");\n                        log.error(\"Card has no set name and won't be sent to client:\" + card);\n                    }\n                }\n            }\n\n            allCardsUrls.addAll(getTokenCardUrls());\n        } catch (Exception e) {\n            log.error(e);\n        }\n\n        File file;\n\n        /**\n         * check to see which cards we already have\n         */\n        for (CardInfo card : allCardsUrls) {\n            boolean withCollectorId = false;\n            if (card.getName().equals(\"Forest\") || card.getName().equals(\"Mountain\") || card.getName().equals(\"Swamp\") || card.getName().equals(\"Island\")\n                    || card.getName().equals(\"Plains\")) {\n                withCollectorId = true;\n            }\n            file = new File(CardImageUtils.getImagePath(card, withCollectorId, imagesPath));\n            if (!file.exists()) {\n                cardsToDownload.add(card);\n            }\n        }\n\n        for (CardInfo card : cardsToDownload) {\n            if (card.isToken()) {\n                log.info(\"Card to download: \" + card.getName() + \" (Token) \");\n            } else {\n                try {\n                    log.info(\"Card to download: \" + card.getName() + \" (\" + card.getSet() + \")\");\n                } catch (Exception e) {\n                    log.error(e);\n                }\n            }\n        }\n\n        return cardsToDownload;\n    }","id":80403,"modified_method":"private static ArrayList<CardInfo> getNeededCards(Set<Card> allCards, String imagesPath) {\n\n        ArrayList<CardInfo> cardsToDownload = new ArrayList<CardInfo>();\n\n        /**\n         * read all card names and urls\n         */\n        ArrayList<CardInfo> allCardsUrls = new ArrayList<CardInfo>();\n\n        try {\n            offlineMode = true;\n\n            for (Card card : allCards) {\n                if (card.getCardNumber() > 0 && !card.getExpansionSetCode().isEmpty()) {\n                    String cardName = card.getName();\n                    CardInfo url = new CardInfo(cardName, card.getExpansionSetCode(), card.getCardNumber(), 0, false, card.canTransform(), card.isNightCard());\n                    if (basicLandPattern.matcher(cardName).matches()) {\n                        url.setDownloadName(card.getClass().getName().replace(card.getClass().getPackage().getName() + \".\", \"\"));\n                    }\n                    if (card.isFlipCard()) {\n                        url.setFlipCard(true);\n                    }\n                    allCardsUrls.add(url);\n                    if (card.canTransform()) {\n                        // add second side for downloading\n                        // it has the same expansion set code and card number as original one\n                        // second side = true;\n                        Card secondSide = card.getSecondCardFace();\n                        url = new CardInfo(secondSide.getName(), card.getExpansionSetCode(), card.getCardNumber(), 0, false, card.canTransform(), true);\n                        allCardsUrls.add(url);\n                    }\n                } else {\n                    if (card.getCardNumber() < 1) {\n                        System.err.println(\"There was a critical error!\");\n                        log.error(\"Card has no collector ID and won't be sent to client: \" + card);\n                    } else if (card.getExpansionSetCode().isEmpty()) {\n                        System.err.println(\"There was a critical error!\");\n                        log.error(\"Card has no set name and won't be sent to client:\" + card);\n                    }\n                }\n            }\n\n            allCardsUrls.addAll(getTokenCardUrls());\n        } catch (Exception e) {\n            log.error(e);\n        }\n\n        File file;\n\n        /**\n         * check to see which cards we already have\n         */\n        for (CardInfo card : allCardsUrls) {\n            boolean withCollectorId = false;\n            if (basicLandPattern.matcher(card.getName()).matches()) {\n                withCollectorId = true;\n            }\n            file = new File(CardImageUtils.getImagePath(card, withCollectorId, imagesPath));\n            if (!file.exists()) {\n                cardsToDownload.add(card);\n            }\n        }\n\n        for (CardInfo card : cardsToDownload) {\n            if (card.isToken()) {\n                log.info(\"Card to download: \" + card.getName() + \" (Token) \");\n            } else {\n                try {\n                    log.info(\"Card to download: \" + card.getName() + \" (\" + card.getSet() + \")\");\n                } catch (Exception e) {\n                    log.error(e);\n                }\n            }\n        }\n\n        return cardsToDownload;\n    }","commit_id":"e0d4285a69e909c7e0da2ffd6dc40c2e14279dc8","url":"https://github.com/magefree/mage"},{"original_method":"public Artifact createIvyArtifact(PublishArtifact publishArtifact, ModuleRevisionId moduleRevisionId) {\n        Map extraAttributes = artifactsExtraAttributesStrategy.createExtraAttributes(publishArtifact);\n        if (GUtil.isTrue(publishArtifact.getClassifier())) {\n            extraAttributes.put(Dependency.CLASSIFIER, publishArtifact.getClassifier());\n        }\n        return new DefaultArtifact(\n                moduleRevisionId,\n                publishArtifact.getDate(),\n                publishArtifact.getName(),\n                publishArtifact.getType(),\n                publishArtifact.getExtension(),\n                extraAttributes);\n    }","id":80404,"modified_method":"public Artifact createIvyArtifact(PublishArtifact publishArtifact, ModuleRevisionId moduleRevisionId) {\n        Map<String, String> extraAttributes = artifactsExtraAttributesStrategy.createExtraAttributes(publishArtifact);\n        if (GUtil.isTrue(publishArtifact.getClassifier())) {\n            extraAttributes.put(Dependency.CLASSIFIER, publishArtifact.getClassifier());\n        }\n        return new DefaultArtifact(\n                moduleRevisionId,\n                publishArtifact.getDate(),\n                publishArtifact.getName(),\n                publishArtifact.getType(),\n                publishArtifact.getExtension(),\n                extraAttributes);\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCreateExcludeRule() {\n        String configurationName = \"someConf\";\n        Map excludeRuleArgs = GUtil.map(ExcludeRule.GROUP_KEY, \"someOrg\", ExcludeRule.MODULE_KEY, \"someModule\");\n        org.apache.ivy.core.module.descriptor.ExcludeRule ivyExcludeRule =\n                new DefaultExcludeRuleConverter().createExcludeRule(configurationName, new DefaultExcludeRule(excludeRuleArgs));\n        assertThat(ivyExcludeRule.getId().getModuleId().getOrganisation(),\n                Matchers.equalTo(excludeRuleArgs.get(ExcludeRule.GROUP_KEY)));\n        assertThat(ivyExcludeRule.getId().getName(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getExt(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getType(), \n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat((ExactPatternMatcher) ivyExcludeRule.getMatcher(),\n                Matchers.equalTo(ExactPatternMatcher.INSTANCE));\n        assertThat(ivyExcludeRule.getConfigurations(),\n                Matchers.equalTo(WrapUtil.toArray(configurationName)));\n    }","id":80405,"modified_method":"@Test\n    public void testCreateExcludeRule() {\n        String configurationName = \"someConf\";\n        Map<String, String> excludeRuleArgs = new HashMap<String, String>();\n        excludeRuleArgs.put(ExcludeRule.GROUP_KEY, \"someOrg\");\n        excludeRuleArgs.put(ExcludeRule.MODULE_KEY, \"someModule\");\n        org.apache.ivy.core.module.descriptor.ExcludeRule ivyExcludeRule =\n                new DefaultExcludeRuleConverter().createExcludeRule(configurationName, new DefaultExcludeRule(excludeRuleArgs));\n        assertThat(ivyExcludeRule.getId().getModuleId().getOrganisation(),\n                Matchers.equalTo(excludeRuleArgs.get(ExcludeRule.GROUP_KEY)));\n        assertThat(ivyExcludeRule.getId().getName(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getExt(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getType(), \n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat((ExactPatternMatcher) ivyExcludeRule.getMatcher(),\n                Matchers.equalTo(ExactPatternMatcher.INSTANCE));\n        assertThat(ivyExcludeRule.getConfigurations(),\n                Matchers.equalTo(WrapUtil.toArray(configurationName)));\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"public void setDirs(Iterable<?> dirs) {\n        this.dirs = new ArrayList<Object>(Arrays.asList(dirs));\n    }","id":80406,"modified_method":"public void setDirs(Iterable<?> dirs) {\n        this.dirs = toList(dirs);\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testResolveAndGetFilesWithDependencySubset() throws IOException, ParseException {\n        prepareResolveReport();\n        final ModuleDependency moduleDependencyDummy1 = context.mock(ModuleDependency.class, \"dep1\");\n        final ModuleDependency moduleDependencyDummy2 = context.mock(ModuleDependency.class, \"dep2\");\n        final SelfResolvingDependency selfResolvingDependencyDummy = context.mock(SelfResolvingDependency.class);\n        final ResolvedDependency root = context.mock(ResolvedDependency.class, \"root\");\n        final ResolvedDependency resolvedDependency1 = context.mock(ResolvedDependency.class, \"resolved1\");\n        final ResolvedDependency resolvedDependency2 = context.mock(ResolvedDependency.class, \"resolved2\");\n        ResolvedDependency resolvedDependency3 = context.mock(ResolvedDependency.class, \"resolved3\");\n        final IvyConversionResult conversionResultStub = context.mock(IvyConversionResult.class);\n        final DependencySet dependencies = context.mock(DependencySet.class);\n        final Map<Dependency, Set<ResolvedDependency>> firstLevelResolvedDependencies = GUtil.map(\n                moduleDependencyDummy1,\n                toSet(resolvedDependency1, resolvedDependency2),\n                moduleDependencyDummy2,\n                toSet(resolvedDependency3));\n\n        context.checking(new Expectations() {{\n            allowing(resolvedDependency1).getParentArtifacts(root);\n            will(returnValue(toSet(createResolvedArtifact(context, \"dep1parent\", \"someType\", \"someExtension\", new File(\"dep1parent\")))));\n            allowing(resolvedDependency1).getModuleArtifacts();\n            will(returnValue(toSet(createResolvedArtifact(context, \"dep1\", \"someType\", \"someExtension\", new File(\"dep1\")))));\n            allowing(resolvedDependency1).getChildren();\n            will(returnValue(toSet()));\n            allowing(resolvedDependency2).getParentArtifacts(root);\n            will(returnValue(toSet()));\n            allowing(resolvedDependency2).getModuleArtifacts();\n            will(returnValue(toSet(createResolvedArtifact(context, \"dep2\", \"someType\", \"someExtension\", new File(\"dep2\")))));\n            allowing(resolvedDependency2).getChildren();\n            will(returnValue(toSet()));\n            allowing(configurationStub).getAllDependencies();\n            will(returnValue(dependencies));\n            allowing(dependencies).withType(ModuleDependency.class);\n            will(returnValue(toDomainObjectSet(ModuleDependency.class, moduleDependencyDummy1, moduleDependencyDummy2)));\n            allowing(ivyReportConverterStub).convertReport(resolveReportMock, configurationStub);\n            will(returnValue(conversionResultStub));\n            allowing(conversionResultStub).getFirstLevelResolvedDependencies();\n            will(returnValue(firstLevelResolvedDependencies));\n            allowing(conversionResultStub).getRoot();\n            will(returnValue(root));\n        }});\n\n        ModuleDescriptor moduleDescriptor = createAnonymousModuleDescriptor();\n        prepareTestsThatRetrieveDependencies(moduleDescriptor);\n\n        ResolvedConfiguration resolvedConfig = ivyDependencyResolver.resolve(configurationStub);\n        Set<File> actualFiles = resolvedConfig.getFiles(\n                new Spec<Dependency>() {\n                    public boolean isSatisfiedBy(Dependency element) {\n                        return element == moduleDependencyDummy1 || element == selfResolvingDependencyDummy;\n                    }\n                });\n        assertThat(actualFiles, equalTo(toSet(new File(\"dep1\"), new File(\"dep2\"), new File(\"dep1parent\"))));\n\n        Set<ResolvedDependency> actualDeps = resolvedConfig.getFirstLevelModuleDependencies(\n                new Spec<Dependency>() {\n                    public boolean isSatisfiedBy(Dependency element) {\n                        return element == moduleDependencyDummy1;\n                    }\n                });\n        assertThat(actualDeps, equalTo(toSet(resolvedDependency1, resolvedDependency2)));\n    }","id":80407,"modified_method":"@Test\n    public void testResolveAndGetFilesWithDependencySubset() throws IOException, ParseException {\n        prepareResolveReport();\n        final ModuleDependency moduleDependencyDummy1 = context.mock(ModuleDependency.class, \"dep1\");\n        final ModuleDependency moduleDependencyDummy2 = context.mock(ModuleDependency.class, \"dep2\");\n        final SelfResolvingDependency selfResolvingDependencyDummy = context.mock(SelfResolvingDependency.class);\n        final ResolvedDependency root = context.mock(ResolvedDependency.class, \"root\");\n        final ResolvedDependency resolvedDependency1 = context.mock(ResolvedDependency.class, \"resolved1\");\n        final ResolvedDependency resolvedDependency2 = context.mock(ResolvedDependency.class, \"resolved2\");\n        ResolvedDependency resolvedDependency3 = context.mock(ResolvedDependency.class, \"resolved3\");\n        final IvyConversionResult conversionResultStub = context.mock(IvyConversionResult.class);\n        final DependencySet dependencies = context.mock(DependencySet.class);\n        final Map<Dependency, Set<ResolvedDependency>> firstLevelResolvedDependencies = new LinkedHashMap<Dependency, Set<ResolvedDependency>>();\n        firstLevelResolvedDependencies.put(moduleDependencyDummy1, toSet(resolvedDependency1, resolvedDependency2));\n        firstLevelResolvedDependencies.put(moduleDependencyDummy2, toSet(resolvedDependency3));\n\n        context.checking(new Expectations() {{\n            allowing(resolvedDependency1).getParentArtifacts(root);\n            will(returnValue(toSet(createResolvedArtifact(context, \"dep1parent\", \"someType\", \"someExtension\", new File(\"dep1parent\")))));\n            allowing(resolvedDependency1).getModuleArtifacts();\n            will(returnValue(toSet(createResolvedArtifact(context, \"dep1\", \"someType\", \"someExtension\", new File(\"dep1\")))));\n            allowing(resolvedDependency1).getChildren();\n            will(returnValue(emptySet()));\n            allowing(resolvedDependency2).getParentArtifacts(root);\n            will(returnValue(emptySet()));\n            allowing(resolvedDependency2).getModuleArtifacts();\n            will(returnValue(toSet(createResolvedArtifact(context, \"dep2\", \"someType\", \"someExtension\", new File(\"dep2\")))));\n            allowing(resolvedDependency2).getChildren();\n            will(returnValue(emptySet()));\n            allowing(configurationStub).getAllDependencies();\n            will(returnValue(dependencies));\n            allowing(dependencies).withType(ModuleDependency.class);\n            will(returnValue(toDomainObjectSet(ModuleDependency.class, moduleDependencyDummy1, moduleDependencyDummy2)));\n            allowing(ivyReportConverterStub).convertReport(resolveReportMock, configurationStub);\n            will(returnValue(conversionResultStub));\n            allowing(conversionResultStub).getFirstLevelResolvedDependencies();\n            will(returnValue(firstLevelResolvedDependencies));\n            allowing(conversionResultStub).getRoot();\n            will(returnValue(root));\n        }});\n\n        ModuleDescriptor moduleDescriptor = createAnonymousModuleDescriptor();\n        prepareTestsThatRetrieveDependencies(moduleDescriptor);\n\n        ResolvedConfiguration resolvedConfig = ivyDependencyResolver.resolve(configurationStub);\n        Set<File> actualFiles = resolvedConfig.getFiles(\n                new Spec<Dependency>() {\n                    public boolean isSatisfiedBy(Dependency element) {\n                        return element == moduleDependencyDummy1 || element == selfResolvingDependencyDummy;\n                    }\n                });\n        assertThat(actualFiles, equalTo(toSet(new File(\"dep1\"), new File(\"dep2\"), new File(\"dep1parent\"))));\n\n        Set<ResolvedDependency> actualDeps = resolvedConfig.getFirstLevelModuleDependencies(\n                new Spec<Dependency>() {\n                    public boolean isSatisfiedBy(Dependency element) {\n                        return element == moduleDependencyDummy1;\n                    }\n                });\n        assertThat(actualDeps, equalTo(toSet(resolvedDependency1, resolvedDependency2)));\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"public void setArtifactUrls(Iterable<?> urls) {\n        additionalUrls = GUtil.addLists(urls);\n    }","id":80408,"modified_method":"public void setArtifactUrls(Iterable<?> urls) {\n        additionalUrls = toList(urls);\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"public static ModuleRevisionId createModuleRevisionId(Module module) {\n        return createModuleRevisionId(module, new HashMap());\n    }","id":80409,"modified_method":"public static ModuleRevisionId createModuleRevisionId(Module module) {\n        return createModuleRevisionId(module, new HashMap<String, String>());\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void wrapsResolvedConfigurationProvidedByDelegate() {\n        context.checking(new Expectations() {{\n            one(delegate).resolve(configuration);\n            will(returnValue(resolvedConfiguration));\n            allowing(dependencies).iterator();\n            will(returnIterator());\n            allowing(configuration).isTransitive();\n            will(returnValue(true));\n        }});\n\n        ResolvedConfiguration configuration = resolver.resolve(this.configuration);\n        assertThat(configuration, not(sameInstance(resolvedConfiguration)));\n\n        final File file = new File(\"file\");\n\n        context.checking(new Expectations() {{\n            one(resolvedConfiguration).getFiles(Specs.SATISFIES_ALL);\n            will(returnValue(toSet(file)));\n        }});\n\n        assertThat(configuration.getFiles(Specs.SATISFIES_ALL), equalTo(toLinkedSet(file)));\n    }","id":80410,"modified_method":"@Test\n    public void wrapsResolvedConfigurationProvidedByDelegate() {\n        context.checking(new Expectations() {{\n            one(delegate).resolve(configuration);\n            will(returnValue(resolvedConfiguration));\n            allowing(dependencies).iterator();\n            will(returnIterator(emptyList()));\n            allowing(configuration).isTransitive();\n            will(returnValue(true));\n        }});\n\n        ResolvedConfiguration configuration = resolver.resolve(this.configuration);\n        assertThat(configuration, not(sameInstance(resolvedConfiguration)));\n\n        final File file = new File(\"file\");\n\n        context.checking(new Expectations() {{\n            one(resolvedConfiguration).getFiles(Specs.SATISFIES_ALL);\n            will(returnValue(toSet(file)));\n        }});\n\n        assertThat(configuration.getFiles(Specs.SATISFIES_ALL), equalTo(toLinkedSet(file)));\n    }","commit_id":"ea0a5dc45fc8386c67b44e847c3f31795beb7d51","url":"https://github.com/gradle/gradle"},{"original_method":"private Map<String, Object> getParameters( Session session ) throws ShellException\n    {\n        NodeOrRelationship self = getCurrent( session );\n        return MapUtil.map( \"self\", self.isNode() ? self.asNode() :self.asRelationship() );\n    }","id":80411,"modified_method":"private Map<String, Object> getParameters( Session session ) throws ShellException\n    {\n        Map<String, Object> params = new HashMap<String, Object>();\n        try\n        {\n            NodeOrRelationship self = getCurrent( session );\n            params.put( \"self\", self.isNode() ? self.asNode() :self.asRelationship() );\n        }\n        catch ( ShellException e )\n        { // OK, current didn't exist\n        }\n        return params;\n    }","commit_id":"287a9239c70365df4d72d531046b6c2f4d0e7603","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Collection<String> getIndexablePaths(SModule module) {\n    // todo: maybe move getIndexablePaths method to FileBasedModelRoot, or even in ModelRoot classes?\n    Set<String> result = new TreeSet<String>();\n\n    for (ModelRoot modelRoot : module.getModelRoots()) {\n      if (modelRoot instanceof FileBasedModelRoot) {\n        FileBasedModelRoot fileBasedModelRoot = (FileBasedModelRoot) modelRoot;\n        result.add(exposePath(fileBasedModelRoot.getContentRoot()));\n        // todo: use excluded & source folders like IDEA\n//        for (String fileKind : fileBasedModelRoot.getSupportedFileKinds()) {\n//          if (!FileBasedModelRoot.EXCLUDED.equals(fileKind)) {\n//            for (String file : fileBasedModelRoot.getFiles(fileKind)) {\n////              checkContentPath(file, module, modelRoot);\n//              result.add(exposePath(file));\n//            }\n//          }\n//        }\n      }\n\n      // todo: obsolete model root type\n      if (modelRoot instanceof FolderModelRootBase) {\n        result.add(exposePath(((FolderModelRootBase) modelRoot).getPath()));\n      }\n    }\n\n    return result;\n  }","id":80412,"modified_method":"public static Collection<String> getIndexablePaths(SModule module) {\n    // todo: maybe move getIndexablePaths method to FileBasedModelRoot, or even in ModelRoot classes?\n    Set<String> result = new TreeSet<String>();\n\n    for (ModelRoot modelRoot : module.getModelRoots()) {\n      if (modelRoot instanceof FileBasedModelRoot) {\n        FileBasedModelRoot fileBasedModelRoot = (FileBasedModelRoot) modelRoot;\n        String contentRoot = fileBasedModelRoot.getContentRoot();\n        if (contentRoot != null) {\n          result.add(exposePath(contentRoot));\n        }\n        // todo: use excluded & source folders like IDEA\n//        for (String fileKind : fileBasedModelRoot.getSupportedFileKinds()) {\n//          if (!FileBasedModelRoot.EXCLUDED.equals(fileKind)) {\n//            for (String file : fileBasedModelRoot.getFiles(fileKind)) {\n////              checkContentPath(file, module, modelRoot);\n//              result.add(exposePath(file));\n//            }\n//          }\n//        }\n      }\n\n      // todo: obsolete model root type\n      if (modelRoot instanceof FolderModelRootBase) {\n        result.add(exposePath(((FolderModelRootBase) modelRoot).getPath()));\n      }\n    }\n\n    return result;\n  }","commit_id":"69d2cf5be617fad64d247813e8beacaa150d0abd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void testLibraryDirInContent() throws Exception {\n    ModuleRootModificationUtil.addModuleLibrary(myModule, myModule1Dir.getUrl());\n\n    myIndex.checkConsistency();\n\n    checkInfo(myModule1Dir, myModule, true, false, \"\", null, myModule);\n    checkInfo(mySrcDir1, myModule, true, false, \"\", JavaSourceRootType.SOURCE, myModule);\n  }","id":80413,"modified_method":"public void testLibraryDirInContent() throws Exception {\n    ModuleRootModificationUtil.addModuleLibrary(myModule, myModule1Dir.getUrl());\n\n    myIndex.checkConsistency();\n\n    checkInfo(myModule1Dir, myModule, true, false, \"\", null, myModule);\n    checkInfo(mySrcDir1, myModule, true, false, \"\", JavaSourceRootType.SOURCE, myModule);\n    \n    checkInfo(myLibDir, myModule, true, false, \"lib\", null, myModule);\n    checkInfo(myLibClsDir, myModule, true, false, \"\", null, myModule2);\n    checkInfo(myLibSrcDir, myModule, true, true, \"\", null, myModule);\n    checkInfo(myResDir, myModule, true, false, \"\", JavaResourceRootType.RESOURCE, myModule);\n  }","commit_id":"71e03bb935f7a48986b098a9b2f6e4e44c76a7e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDirInfos() {\n    checkInfoNull(myRootVFile);\n\n    // beware: files in directory index\n    checkInfo(myFileLibSrc, null, false, true, \"\", null, myModule);\n    checkInfo(myFileLibCls, null, true, false, \"\", null, myModule);\n\n    checkInfo(myModule1Dir, myModule, false, false, null, null);\n    checkInfo(mySrcDir1, myModule, false, false, \"\", JavaSourceRootType.SOURCE, myModule);\n    checkInfo(myPack1Dir, myModule, false, false, \"pack1\", JavaSourceRootType.SOURCE, myModule);\n    checkInfo(myTestSrc1, myModule, false, false, \"\", JavaSourceRootType.TEST_SOURCE, myModule);\n    checkInfo(myPack2Dir, myModule, false, false, \"pack2\", JavaSourceRootType.TEST_SOURCE, myModule);\n    checkInfo(myResDir, myModule, false, false, \"\", JavaResourceRootType.RESOURCE, myModule);\n    checkInfo(myTestResDir, myModule, false, false, \"\", JavaResourceRootType.TEST_RESOURCE, myModule);\n\n    checkInfo(myLibDir, myModule, false, false, null, null);\n    checkInfo(myLibSrcDir, myModule, false, true, \"\", null, myModule2);\n    checkInfo(myLibClsDir, myModule, true, false, \"\", null, myModule2);\n\n    checkInfo(myModule2Dir, myModule2, false, false, null, null);\n    checkInfo(mySrcDir2, myModule2, false, false, \"\", JavaSourceRootType.SOURCE, myModule2, myModule3);\n    checkInfoNull(myCvsDir);\n    checkInfoNull(myExcludeDir);\n    checkInfoNull(myExcludedLibClsDir);\n    checkInfoNull(myExcludedLibSrcDir);\n\n    checkInfo(myModule3Dir, myModule3, false, false, null, null);\n  }","id":80414,"modified_method":"public void testDirInfos() {\n    checkInfoNull(myRootVFile);\n\n    // beware: files in directory index\n    checkInfo(myFileLibSrc, null, false, true, \"\", null, myModule);\n    checkInfo(myFileLibCls, null, true, false, \"\", null, myModule);\n\n    checkInfo(myModule1Dir, myModule, false, false, null, null);\n    checkInfo(mySrcDir1, myModule, false, false, \"\", JavaSourceRootType.SOURCE, myModule);\n    checkInfo(myPack1Dir, myModule, false, false, \"pack1\", JavaSourceRootType.SOURCE, myModule);\n    checkInfo(myTestSrc1, myModule, false, false, \"\", JavaSourceRootType.TEST_SOURCE, myModule);\n    checkInfo(myPack2Dir, myModule, false, false, \"pack2\", JavaSourceRootType.TEST_SOURCE, myModule);\n    checkInfo(myResDir, myModule, false, false, \"\", JavaResourceRootType.RESOURCE, myModule);\n    checkInfo(myTestResDir, myModule, false, false, \"\", JavaResourceRootType.TEST_RESOURCE, myModule);\n\n    checkInfo(myLibDir, myModule, false, false, null, null);\n    checkInfo(myLibSrcDir, myModule, false, true, \"\", null, myModule2);\n    checkInfo(myLibClsDir, myModule, true, false, \"\", null, myModule2);\n\n    checkInfo(myModule2Dir, myModule2, false, false, null, null);\n    checkInfo(mySrcDir2, myModule2, false, false, \"\", JavaSourceRootType.SOURCE, myModule2, myModule3);\n    checkInfoNull(myCvsDir);\n    checkInfoNull(myExcludeDir);\n    checkInfoNull(myExcludedLibClsDir);\n    checkInfoNull(myExcludedLibSrcDir);\n\n    assertEquals(myModule1Dir, checkInfoNotNull(myLibClsDir).getContentRoot());\n\n    checkInfo(myModule3Dir, myModule3, false, false, null, null);\n  }","commit_id":"71e03bb935f7a48986b098a9b2f6e4e44c76a7e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void mergeWithParentInfos() {\n    for (Map.Entry<VirtualFile, DirectoryInfo> entry : myRoots.entrySet()) {\n      DirectoryInfo info = entry.getValue();\n      Module module = info.getModule();\n      VirtualFile libraryClassRoot = info.getLibraryClassRoot();\n      boolean inModuleSource = info.isInModuleSource();\n      boolean inLibrarySource = info.isInLibrarySource();\n      \n      boolean nested = false;\n      \n      VirtualFile eachFile = entry.getKey().getParent();\n      while (eachFile != null) {\n        DirectoryInfo eachInfo = myRoots.get(eachFile);\n        if (eachInfo != null) {\n          nested = true;\n          if (module == null) {\n            module = eachInfo.getModule();\n          }\n          if (libraryClassRoot == null) {\n            libraryClassRoot = eachInfo.getLibraryClassRoot();\n          }\n          inModuleSource |= eachInfo.isInModuleSource();\n          inLibrarySource |= eachInfo.isInLibrarySource();\n        }\n        if (isAnyExcludeRoot(eachFile)) {\n          break;\n        }\n        \n        eachFile = eachFile.getParent();\n      }\n      if (nested) {\n        int sourceRootTypeData = DirectoryInfo.createSourceRootTypeData(inModuleSource, inLibrarySource, info.getSourceRootTypeId());\n        entry.setValue(info.with(module, info.getContentRoot(), info.getSourceRoot(), libraryClassRoot, sourceRootTypeData, info.getOrderEntries()));\n      }\n    }\n  }","id":80415,"modified_method":"private void mergeWithParentInfos() {\n    for (Map.Entry<VirtualFile, DirectoryInfo> entry : myRoots.entrySet()) {\n      DirectoryInfo info = entry.getValue();\n      Module module = info.getModule();\n      VirtualFile contentRoot = info.getContentRoot();\n      VirtualFile libraryClassRoot = info.getLibraryClassRoot();\n      boolean inModuleSource = info.isInModuleSource();\n      boolean inLibrarySource = info.isInLibrarySource();\n\n      OrderEntry[] orderEntries = info.getOrderEntries();\n      \n      boolean nested = false;\n      \n      VirtualFile eachFile = entry.getKey().getParent();\n      while (eachFile != null) {\n        DirectoryInfo eachInfo = myRoots.get(eachFile);\n        if (eachInfo != null) {\n          nested = true;\n\n          if (eachInfo.getLibraryClassRoot() != null && libraryClassRoot == null && !info.isInModuleSource()) {\n            orderEntries = eachInfo.getOrderEntries();\n          }\n\n          if (module == null) {\n            module = eachInfo.getModule();\n          }\n          if (libraryClassRoot == null) {\n            libraryClassRoot = eachInfo.getLibraryClassRoot();\n          }\n          if (contentRoot == null) {\n            contentRoot = eachInfo.getContentRoot();\n          }\n          inModuleSource |= eachInfo.isInModuleSource();\n          inLibrarySource |= eachInfo.isInLibrarySource();\n        }\n        if (isAnyExcludeRoot(eachFile)) {\n          break;\n        }\n        \n        eachFile = eachFile.getParent();\n      }\n      if (nested) {\n        int sourceRootTypeData = DirectoryInfo.createSourceRootTypeData(inModuleSource, inLibrarySource, info.getSourceRootTypeId());\n        if (orderEntries.length == 0) orderEntries = null;\n        entry.setValue(info.with(module, contentRoot, info.getSourceRoot(), libraryClassRoot, sourceRootTypeData, orderEntries));\n      }\n    }\n  }","commit_id":"71e03bb935f7a48986b098a9b2f6e4e44c76a7e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DirectoryInfo getInfoForDirectory(@NotNull final VirtualFile dir) {\n    int count = 0;\n    for (VirtualFile root = dir; root != null; root = root.getParent()) {\n      if (++count > 1000) {\n        throw new IllegalStateException(\"Possible loop in tree\");\n      }\n      final DirectoryInfo info = myRoots.get(root);\n      if (info != null) {\n        return info;\n      }\n      if (isAnyExcludeRoot(root) || FileTypeManager.getInstance().isFileIgnored(root)) {\n        return null;\n      }\n    }\n\n    return null;\n  }","id":80416,"modified_method":"@Nullable \n  public DirectoryInfo getInfoForDirectory(@NotNull final VirtualFile dir) {\n    if (!dir.isValid()) {\n      return null;\n    }\n    if (!dir.isDirectory()) {\n      return myRoots.get(dir);\n    }\n\n    int count = 0;\n    for (VirtualFile root = dir; root != null; root = root.getParent()) {\n      if (++count > 1000) {\n        throw new IllegalStateException(\"Possible loop in tree\");\n      }\n      final DirectoryInfo info = myRoots.get(root);\n      if (info != null) {\n        return info;\n      }\n      if (isAnyExcludeRoot(root) || FileTypeManager.getInstance().isFileIgnored(root)) {\n        return null;\n      }\n    }\n\n    return null;\n  }","commit_id":"71e03bb935f7a48986b098a9b2f6e4e44c76a7e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void setStorageType(@NotNull ModuleRootModel model, @NotNull String storageId) {\n    Module module = model.getModule();\n    String oldStorageType = ClassPathStorageUtil.getStorageType(module);\n    if (oldStorageType.equals(storageId)) {\n      return;\n    }\n\n    ClasspathStorageProvider provider = getProvider(oldStorageType);\n    if (provider != null) {\n      provider.detach(module);\n    }\n\n    provider = getProvider(storageId);\n    if (provider == null) {\n      module.clearOption(JpsProjectLoader.CLASSPATH_ATTRIBUTE);\n      module.clearOption(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE);\n    }\n    else {\n      module.setOption(JpsProjectLoader.CLASSPATH_ATTRIBUTE, storageId);\n      module.setOption(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE, provider.getContentRoot(model));\n    }\n  }","id":80417,"modified_method":"public static void setStorageType(@NotNull ModuleRootModel model, @NotNull String storageId) {\n    Module module = model.getModule();\n    String oldStorageType = ClassPathStorageUtil.getStorageType(module);\n    if (oldStorageType.equals(storageId)) {\n      return;\n    }\n\n    ClasspathStorageProvider provider = getProvider(oldStorageType);\n    if (provider != null) {\n      provider.detach(module);\n    }\n\n    provider = getProvider(storageId);\n    if (provider == null) {\n      module.clearOption(JpsProjectLoader.CLASSPATH_ATTRIBUTE);\n      module.clearOption(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE);\n    }\n    else {\n      module.setOption(JpsProjectLoader.CLASSPATH_ATTRIBUTE, storageId);\n      String root = provider.getContentRoot(model);\n      if (root == null) {\n        module.clearOption(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE);\n      }\n      else {\n        module.setOption(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE, root);\n      }\n    }\n  }","commit_id":"613179f88c20e78300b96534d185507f004a1fda","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClasspathStorage(@NotNull final Module module, @NotNull StateStorageManager storageManager) {\n    String storageType = module.getOptionValue(JpsProjectLoader.CLASSPATH_ATTRIBUTE);\n    if (storageType == null) {\n      throw new IllegalStateException(\"Classpath storage requires non-default storage type\");\n    }\n\n    ClasspathStorageProvider provider = getProvider(storageType);\n    if (provider == null) {\n      throw new IllegalStateException(\"Classpath storage provider not found, please ensure that Eclipse plugin is installed\");\n    }\n    myConverter = provider.createConverter(module);\n\n    myPathMacroSubstitutor = storageManager.getMacroSubstitutor();\n\n    final List<String> paths = myConverter.getFilePaths();\n    MessageBusConnection busConnection = module.getMessageBus().connect();\n    busConnection.subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener.Adapter() {\n      @Override\n      public void after(@NotNull List<? extends VFileEvent> events) {\n        for (VFileEvent event : events) {\n          if (!event.isFromRefresh() || !(event instanceof VFileContentChangeEvent)) {\n            continue;\n          }\n\n          for (String path : paths) {\n            if (path.equals(event.getPath())) {\n              module.getMessageBus().syncPublisher(StateStorageManager.STORAGE_TOPIC).storageFileChanged(event, ClasspathStorage.this, module);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    busConnection.subscribe(StateStorageManager.STORAGE_TOPIC, new StorageManagerListener() {\n      private String fileNameToModuleName(@NotNull String fileName) {\n        return fileName.substring(0, fileName.length() - ModuleFileType.DOT_DEFAULT_EXTENSION.length());\n      }\n\n      @Override\n      public void storageFileChanged(@NotNull VFileEvent event, @NotNull StateStorage storage, @NotNull ComponentManager componentManager) {\n        assert componentManager == module;\n        if (!(event instanceof VFilePropertyChangeEvent)) {\n          return;\n        }\n\n        VFilePropertyChangeEvent propertyEvent = (VFilePropertyChangeEvent)event;\n        if (propertyEvent.getPropertyName().equals(VirtualFile.PROP_NAME)) {\n          String oldFileName = (String)propertyEvent.getOldValue();\n          if (oldFileName.endsWith(ModuleFileType.DOT_DEFAULT_EXTENSION)) {\n            ClasspathStorageProvider provider = getProvider(ClassPathStorageUtil.getStorageType(module));\n            if (provider != null) {\n              provider.moduleRenamed(module, fileNameToModuleName(oldFileName), fileNameToModuleName((String)propertyEvent.getNewValue()));\n            }\n          }\n        }\n      }\n    });\n  }","id":80418,"modified_method":"public ClasspathStorage(@NotNull final Module module, @NotNull StateStorageManager storageManager) {\n    String storageType = module.getOptionValue(JpsProjectLoader.CLASSPATH_ATTRIBUTE);\n    if (storageType == null) {\n      throw new IllegalStateException(\"Classpath storage requires non-default storage type\");\n    }\n\n    ClasspathStorageProvider provider = getProvider(storageType);\n    if (provider == null) {\n      throw new IllegalStateException(\"Classpath storage provider \" + storageType + \" not found, please make sure the plugin is installed\");\n    }\n    myConverter = provider.createConverter(module);\n\n    myPathMacroSubstitutor = storageManager.getMacroSubstitutor();\n\n    final List<String> paths = myConverter.getFilePaths();\n    MessageBusConnection busConnection = module.getMessageBus().connect();\n    busConnection.subscribe(VirtualFileManager.VFS_CHANGES, new BulkFileListener.Adapter() {\n      @Override\n      public void after(@NotNull List<? extends VFileEvent> events) {\n        for (VFileEvent event : events) {\n          if (!event.isFromRefresh() || !(event instanceof VFileContentChangeEvent)) {\n            continue;\n          }\n\n          for (String path : paths) {\n            if (path.equals(event.getPath())) {\n              module.getMessageBus().syncPublisher(StateStorageManager.STORAGE_TOPIC).storageFileChanged(event, ClasspathStorage.this, module);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    busConnection.subscribe(StateStorageManager.STORAGE_TOPIC, new StorageManagerListener() {\n      private String fileNameToModuleName(@NotNull String fileName) {\n        return fileName.substring(0, fileName.length() - ModuleFileType.DOT_DEFAULT_EXTENSION.length());\n      }\n\n      @Override\n      public void storageFileChanged(@NotNull VFileEvent event, @NotNull StateStorage storage, @NotNull ComponentManager componentManager) {\n        assert componentManager == module;\n        if (!(event instanceof VFilePropertyChangeEvent)) {\n          return;\n        }\n\n        VFilePropertyChangeEvent propertyEvent = (VFilePropertyChangeEvent)event;\n        if (propertyEvent.getPropertyName().equals(VirtualFile.PROP_NAME)) {\n          String oldFileName = (String)propertyEvent.getOldValue();\n          if (oldFileName.endsWith(ModuleFileType.DOT_DEFAULT_EXTENSION)) {\n            ClasspathStorageProvider provider = getProvider(ClassPathStorageUtil.getStorageType(module));\n            if (provider != null) {\n              provider.moduleRenamed(module, fileNameToModuleName(oldFileName), fileNameToModuleName((String)propertyEvent.getNewValue()));\n            }\n          }\n        }\n      }\n    });\n  }","commit_id":"613179f88c20e78300b96534d185507f004a1fda","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Builds a Requisition based on the A records returned in a zone transfer from the\n     * specified zone.\n     * \n     * @return an instance of the JaxB annotated Requistion class than can be marshaled\n     *   into the XML and streamed to the Provisioner\n     *   \n     * @throws IOException\n     * @throws ZoneTransferException\n     */\n    private Requisition buildRequisitionFromZoneTransfer() throws IOException, ZoneTransferException {\n        \n        //ZoneTransferIn xfer = ZoneTransferIn.newAXFR(new Name(m_zone), m_host, m_key);\n        \n        ZoneTransferIn xfer = ZoneTransferIn.newIXFR(new Name(m_zone), \n                                      m_serial.longValue(), \n                                      m_fallback.booleanValue(), \n                                      m_url.getHost(), \n                                      m_port,\n                                      m_key);\n\n        List<Record> records = xfer.run();\n        \n        Requisition r = null;\n        \n        if (records.size() > 0) {\n            \n            //for now, set the foreign source to the specified dns zone\n            r = new Requisition(getForeignSource());\n            \n            for (Record rec : records) {\n                if (matchingRecord(rec)) {\n                    r.insertNode(createRequisitionNode(rec));\n                }\n            }\n        }\n        \n        return r;\n    }","id":80419,"modified_method":"/**\n     * Builds a Requisition based on the A records returned in a zone transfer from the\n     * specified zone.\n     * \n     * @return an instance of the JaxB annotated Requistion class than can be marshaled\n     *   into the XML and streamed to the Provisioner\n     *   \n     * @throws IOException\n     * @throws ZoneTransferException\n     */\n    private Requisition buildRequisitionFromZoneTransfer() throws IOException, ZoneTransferException {\n        \n        //ZoneTransferIn xfer = ZoneTransferIn.newAXFR(new Name(m_zone), m_host, m_key);\n        \n        ZoneTransferIn xfer = ZoneTransferIn.newIXFR(new Name(m_zone), \n                                      m_serial.longValue(), \n                                      m_fallback.booleanValue(), \n                                      m_url.getHost(), \n                                      m_port,\n                                      m_key);\n\n        List<Record> records = getRecords(xfer);\n        \n        Requisition r = null;\n        \n        if (records.size() > 0) {\n            \n            //for now, set the foreign source to the specified dns zone\n            r = new Requisition(getForeignSource());\n            \n            for (Record rec : records) {\n                if (matchingRecord(rec)) {\n                    r.insertNode(createRequisitionNode(rec));\n                }\n            }\n        }\n        \n        return r;\n    }","commit_id":"822167576305d50b6af9568aebd1cf64d128eb76","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Job newJob(TriggerFiredBundle bundle) throws SchedulerException {\n\n        JobDetail jobDetail = bundle.getJobDetail();\n        Class<ImportJob> jobClass = (Class<ImportJob>)jobDetail.getJobClass();\n        \n        ImportJob job = null;\n        \n        try {\n            job = jobClass.newInstance();\n            job.setProvisioner(getProvisioner());\n            return job;\n        } catch (Exception e) {\n            SchedulerException se = new SchedulerException(\"failed to create job class: \"+jobDetail.getJobClass().getName()+\"; \"+\n                                                           e.getLocalizedMessage(), e);\n            throw se;\n        }\n    }","id":80420,"modified_method":"public Job newJob(TriggerFiredBundle bundle) throws SchedulerException {\n\n        JobDetail jobDetail = bundle.getJobDetail();\n        Class<ImportJob> jobClass = getJobClass(jobDetail);\n        \n        ImportJob job = null;\n        \n        try {\n            job = jobClass.newInstance();\n            job.setProvisioner(getProvisioner());\n            return job;\n        } catch (Exception e) {\n            SchedulerException se = new SchedulerException(\"failed to create job class: \"+jobDetail.getJobClass().getName()+\"; \"+\n                                                           e.getLocalizedMessage(), e);\n            throw se;\n        }\n    }","commit_id":"822167576305d50b6af9568aebd1cf64d128eb76","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a Requisition based on the A records returned in a zone transfer from the\n     * specified zone.\n     * \n     * @return an instance of the JaxB annotated Requistion class than can be marshaled\n     *   into the XML and streamed to the Provisioner\n     *   \n     * @throws IOException\n     * @throws ZoneTransferException\n     */\n    private Requisition buildRequisitionFromZoneTransfer() throws IOException, ZoneTransferException {\n        \n        //ZoneTransferIn xfer = ZoneTransferIn.newAXFR(new Name(m_zone), m_host, m_key);\n        \n        ZoneTransferIn xfer = ZoneTransferIn.newIXFR(new Name(m_zone), \n                                      m_serial.longValue(), \n                                      m_fallback.booleanValue(), \n                                      m_url.getHost(), \n                                      m_port,\n                                      m_key);\n\n        List<Record> records = xfer.run();\n        \n        Requisition r = null;\n        \n        if (records.size() > 0) {\n            \n            //for now, set the foreign source to the specified dns zone\n            r = new Requisition(getForeignSource());\n            \n            for (Record rec : records) {\n                if (matchingRecord(rec)) {\n                    r.insertNode(createRequisitionNode(rec));\n                }\n            }\n        }\n        \n        return r;\n    }","id":80421,"modified_method":"/**\n     * Builds a Requisition based on the A records returned in a zone transfer from the\n     * specified zone.\n     * \n     * @return an instance of the JaxB annotated Requistion class than can be marshaled\n     *   into the XML and streamed to the Provisioner\n     *   \n     * @throws IOException\n     * @throws ZoneTransferException\n     */\n    private Requisition buildRequisitionFromZoneTransfer() throws IOException, ZoneTransferException {\n        \n        //ZoneTransferIn xfer = ZoneTransferIn.newAXFR(new Name(m_zone), m_host, m_key);\n        \n        ZoneTransferIn xfer = ZoneTransferIn.newIXFR(new Name(m_zone), \n                                      m_serial.longValue(), \n                                      m_fallback.booleanValue(), \n                                      m_url.getHost(), \n                                      m_port,\n                                      m_key);\n\n        List<Record> records = getRecords(xfer);\n        \n        Requisition r = null;\n        \n        if (records.size() > 0) {\n            \n            //for now, set the foreign source to the specified dns zone\n            r = new Requisition(getForeignSource());\n            \n            for (Record rec : records) {\n                if (matchingRecord(rec)) {\n                    r.insertNode(createRequisitionNode(rec));\n                }\n            }\n        }\n        \n        return r;\n    }","commit_id":"4233f55f12e44e424e051bf78fa4d3e599c87b5c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Job newJob(TriggerFiredBundle bundle) throws SchedulerException {\n\n        JobDetail jobDetail = bundle.getJobDetail();\n        Class<ImportJob> jobClass = (Class<ImportJob>)jobDetail.getJobClass();\n        \n        ImportJob job = null;\n        \n        try {\n            job = jobClass.newInstance();\n            job.setProvisioner(getProvisioner());\n            return job;\n        } catch (Exception e) {\n            SchedulerException se = new SchedulerException(\"failed to create job class: \"+jobDetail.getJobClass().getName()+\"; \"+\n                                                           e.getLocalizedMessage(), e);\n            throw se;\n        }\n    }","id":80422,"modified_method":"public Job newJob(TriggerFiredBundle bundle) throws SchedulerException {\n\n        JobDetail jobDetail = bundle.getJobDetail();\n        Class<ImportJob> jobClass = getJobClass(jobDetail);\n        \n        ImportJob job = null;\n        \n        try {\n            job = jobClass.newInstance();\n            job.setProvisioner(getProvisioner());\n            return job;\n        } catch (Exception e) {\n            SchedulerException se = new SchedulerException(\"failed to create job class: \"+jobDetail.getJobClass().getName()+\"; \"+\n                                                           e.getLocalizedMessage(), e);\n            throw se;\n        }\n    }","commit_id":"4233f55f12e44e424e051bf78fa4d3e599c87b5c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a Requisition based on the A records returned in a zone transfer from the\n     * specified zone.\n     * \n     * @return an instance of the JaxB annotated Requistion class than can be marshaled\n     *   into the XML and streamed to the Provisioner\n     *   \n     * @throws IOException\n     * @throws ZoneTransferException\n     */\n    private Requisition buildRequisitionFromZoneTransfer() throws IOException, ZoneTransferException {\n        \n        //ZoneTransferIn xfer = ZoneTransferIn.newAXFR(new Name(m_zone), m_host, m_key);\n        \n        ZoneTransferIn xfer = ZoneTransferIn.newIXFR(new Name(m_zone), \n                                      m_serial.longValue(), \n                                      m_fallback.booleanValue(), \n                                      m_url.getHost(), \n                                      m_port,\n                                      m_key);\n\n        List<Record> records = xfer.run();\n        \n        Requisition r = null;\n        \n        if (records.size() > 0) {\n            \n            //for now, set the foreign source to the specified dns zone\n            r = new Requisition(getForeignSource());\n            \n            for (Record rec : records) {\n                if (matchingRecord(rec)) {\n                    r.insertNode(createRequisitionNode(rec));\n                }\n            }\n        }\n        \n        return r;\n    }","id":80423,"modified_method":"/**\n     * Builds a Requisition based on the A records returned in a zone transfer from the\n     * specified zone.\n     * \n     * @return an instance of the JaxB annotated Requistion class than can be marshaled\n     *   into the XML and streamed to the Provisioner\n     *   \n     * @throws IOException\n     * @throws ZoneTransferException\n     */\n    private Requisition buildRequisitionFromZoneTransfer() throws IOException, ZoneTransferException {\n        \n        //ZoneTransferIn xfer = ZoneTransferIn.newAXFR(new Name(m_zone), m_host, m_key);\n        \n        ZoneTransferIn xfer = ZoneTransferIn.newIXFR(new Name(m_zone), \n                                      m_serial.longValue(), \n                                      m_fallback.booleanValue(), \n                                      m_url.getHost(), \n                                      m_port,\n                                      m_key);\n\n        List<Record> records = getRecords(xfer);\n        \n        Requisition r = null;\n        \n        if (records.size() > 0) {\n            \n            //for now, set the foreign source to the specified dns zone\n            r = new Requisition(getForeignSource());\n            \n            for (Record rec : records) {\n                if (matchingRecord(rec)) {\n                    r.insertNode(createRequisitionNode(rec));\n                }\n            }\n        }\n        \n        return r;\n    }","commit_id":"89a2c17a0fceb5a2ba772aace4a5eed40c2b1254","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Job newJob(TriggerFiredBundle bundle) throws SchedulerException {\n\n        JobDetail jobDetail = bundle.getJobDetail();\n        Class<ImportJob> jobClass = (Class<ImportJob>)jobDetail.getJobClass();\n        \n        ImportJob job = null;\n        \n        try {\n            job = jobClass.newInstance();\n            job.setProvisioner(getProvisioner());\n            return job;\n        } catch (Exception e) {\n            SchedulerException se = new SchedulerException(\"failed to create job class: \"+jobDetail.getJobClass().getName()+\"; \"+\n                                                           e.getLocalizedMessage(), e);\n            throw se;\n        }\n    }","id":80424,"modified_method":"public Job newJob(TriggerFiredBundle bundle) throws SchedulerException {\n\n        JobDetail jobDetail = bundle.getJobDetail();\n        Class<ImportJob> jobClass = getJobClass(jobDetail);\n        \n        ImportJob job = null;\n        \n        try {\n            job = jobClass.newInstance();\n            job.setProvisioner(getProvisioner());\n            return job;\n        } catch (Exception e) {\n            SchedulerException se = new SchedulerException(\"failed to create job class: \"+jobDetail.getJobClass().getName()+\"; \"+\n                                                           e.getLocalizedMessage(), e);\n            throw se;\n        }\n    }","commit_id":"89a2c17a0fceb5a2ba772aace4a5eed40c2b1254","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  protected ListCellRenderer createRenderer(UniqueNameBuilder<ReopenProjectAction> pathShortener) {\n    return new RecentProjectItemRenderer(myPathShortener) {\n       private GridBagConstraints nameCell;\n       private GridBagConstraints pathCell;\n       private GridBagConstraints closeButtonCell;\n\n      private void initConstraints () {\n        nameCell = new GridBagConstraints();\n        pathCell = new GridBagConstraints();\n        closeButtonCell = new GridBagConstraints();\n\n        nameCell.gridx = 0;\n        nameCell.gridy = 0;\n        nameCell.weightx = 1.0;\n        nameCell.weighty = 1.0;\n        nameCell.anchor = GridBagConstraints.FIRST_LINE_START;\n        nameCell.insets = JBUI.insets(6, 5, 1, 5);\n\n\n\n        pathCell.gridx = 0;\n        pathCell.gridy = 1;\n\n        pathCell.insets = JBUI.insets(1, 5, 6, 5);\n        pathCell.anchor = GridBagConstraints.LAST_LINE_START;\n\n\n        closeButtonCell.gridx = 1;\n        closeButtonCell.gridy = 0;\n        closeButtonCell.anchor = GridBagConstraints.FIRST_LINE_END;\n        closeButtonCell.insets = JBUI.insets(7, 7, 7, 7);\n        closeButtonCell.gridheight = 2;\n\n        //closeButtonCell.anchor = GridBagConstraints.WEST;\n      }\n\n      @Override\n      protected Color getListBackground(boolean isSelected, boolean hasFocus) {\n        return isSelected ? FlatWelcomeFrame.getListSelectionColor(hasFocus) : FlatWelcomeFrame.getProjectsBackground();\n      }\n\n      @Override\n      protected Color getListForeground(boolean isSelected, boolean hasFocus) {\n        return UIUtil.getListForeground(isSelected && hasFocus);\n      }\n\n      @Override\n      protected void layoutComponents() {\n        setLayout(new GridBagLayout());\n        initConstraints();\n        add(myName, nameCell);\n        add(myPath, pathCell);\n      }\n\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n\n        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n\n        if (Registry.is(\"removable.welcome.screen.projects\")) {\n          if (myHovered) {\n            add(myCloseThisItem, closeButtonCell);\n            list.revalidate();\n          }\n          else {\n            remove(myCloseThisItem);\n            list.revalidate();\n          }\n        }\n\n        return this;\n      }\n\n    };\n  }","id":80425,"modified_method":"@Override\n  protected ListCellRenderer createRenderer(UniqueNameBuilder<ReopenProjectAction> pathShortener) {\n    return new RecentProjectItemRenderer(myPathShortener) {\n       private GridBagConstraints nameCell;\n       private GridBagConstraints pathCell;\n       private GridBagConstraints closeButtonCell;\n\n      private void initConstraints () {\n        nameCell = new GridBagConstraints();\n        pathCell = new GridBagConstraints();\n        closeButtonCell = new GridBagConstraints();\n\n        nameCell.gridx = 0;\n        nameCell.gridy = 0;\n        nameCell.weightx = 1.0;\n        nameCell.weighty = 1.0;\n        nameCell.anchor = GridBagConstraints.FIRST_LINE_START;\n        nameCell.insets = JBUI.insets(6, 5, 1, 5);\n\n\n\n        pathCell.gridx = 0;\n        pathCell.gridy = 1;\n\n        pathCell.insets = JBUI.insets(1, 5, 6, 5);\n        pathCell.anchor = GridBagConstraints.LAST_LINE_START;\n\n\n        closeButtonCell.gridx = 1;\n        closeButtonCell.gridy = 0;\n        closeButtonCell.anchor = GridBagConstraints.FIRST_LINE_END;\n        closeButtonCell.insets = JBUI.insets(7, 7, 7, 7);\n        closeButtonCell.gridheight = 2;\n\n        //closeButtonCell.anchor = GridBagConstraints.WEST;\n      }\n\n      @Override\n      protected Color getListBackground(boolean isSelected, boolean hasFocus) {\n        return isSelected ? FlatWelcomeFrame.getListSelectionColor(hasFocus) : FlatWelcomeFrame.getProjectsBackground();\n      }\n\n      @Override\n      protected Color getListForeground(boolean isSelected, boolean hasFocus) {\n        return UIUtil.getListForeground(isSelected && hasFocus);\n      }\n\n      @Override\n      protected void layoutComponents() {\n        setLayout(new GridBagLayout());\n        initConstraints();\n        add(myName, nameCell);\n        add(myPath, pathCell);\n      }\n\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n\n        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n\n        if (Registry.is(\"removable.welcome.screen.projects\")) {\n          if (myHovered) {\n            add(myCloseThisItem, closeButtonCell);\n            list.revalidate();\n          }\n          else {\n            remove(myCloseThisItem);\n            list.revalidate();\n          }\n        }\n\n        return this;\n      }\n\n      @Override\n      public Dimension getPreferredSize() {\n        Dimension size = super.getPreferredSize();\n        int h = myName.getPreferredSize().height + myPath.getPreferredSize().height;\n        return new Dimension(size.width, h + JBUI.scale(26));\n      }\n    };\n  }","commit_id":"2068048af4b6d2e25a5812e956d8b18ac7f8e289","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getTitle2Text(ReopenProjectAction action, JComponent pathLabel) {\n      String fullText = action.getProjectPath();\n      if (fullText == null || fullText.length() == 0) return \" \";\n\n      fullText = FileUtil.getLocationRelativeToUserHome(fullText, false);\n\n      int labelWidth = pathLabel.getWidth();\n      if (pathLabel.getFontMetrics(pathLabel.getFont()).stringWidth(fullText) > labelWidth) {\n        return myShortener.getShortPath(action);\n      }\n\n      return fullText;\n    }","id":80426,"modified_method":"private String getTitle2Text(ReopenProjectAction action, JComponent pathLabel) {\n      String fullText = action.getProjectPath();\n      if (fullText == null || fullText.length() == 0) return \" \";\n\n      fullText = FileUtil.getLocationRelativeToUserHome(fullText, false);\n\n      FontMetrics fm = pathLabel.getFontMetrics(pathLabel.getFont());\n      int maxWidth = RecentProjectPanel.this.getWidth() - JBUI.scale(40);\n      if (fm.stringWidth(fullText) > maxWidth) {\n        int left = 1; int right = 1;\n        int center = fullText.length() / 2;\n        String s = fullText.substring(0, center - left) + \"...\" + fullText.substring(center + right);\n        while (fm.stringWidth(s) > maxWidth) {\n          if (left == right) {\n            left++;\n          } else {\n            right++;\n          }\n\n          if (center - left < 0 || center + right >= fullText.length()) {\n            return \"\";\n          }\n          s = fullText.substring(0, center - left) + \"...\" + fullText.substring(center + right);\n        }\n        return s;\n      }\n\n      return fullText;\n    }","commit_id":"2068048af4b6d2e25a5812e956d8b18ac7f8e289","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InlineProgressIndicator(boolean compact, TaskInfo processInfo) {\n    myCompact = compact;\n    myInfo = processInfo;\n\n    myCancelButton = new InplaceButton(new IconButton(processInfo.getCancelTooltipText(),\n                                                      IconLoader.getIcon(\"/process/stop.png\"),\n                                                      IconLoader.getIcon(\"/process/stopHovered.png\")) {\n    }, new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        cancelRequest();\n      }\n    }).setFillBg(true);\n\n    myCancelButton.setVisible(myInfo.isCancellable());\n    myCancelButton.setOpaque(false);\n    myCancelButton.setToolTipText(processInfo.getCancelTooltipText());\n    myCancelButton.setFillBg(false);\n\n    myProgress = new MyProgressBar(JProgressBar.HORIZONTAL, compact);\n\n    myComponent = new MyComponent(compact, myProcessName);\n    if (myCompact) {\n      myComponent.setOpaque(false);\n      myComponent.setLayout(new BorderLayout(2, 0));\n      final JPanel textAndProgress = new JPanel(new BorderLayout());\n      textAndProgress.setOpaque(false);\n      textAndProgress.add(myText, BorderLayout.CENTER);\n\n      final NonOpaquePanel progressWrapper = new NonOpaquePanel(new GridBagLayout());\n      final GridBagConstraints c = new GridBagConstraints();\n      c.weightx = 1;\n      c.weighty = 1;\n      c.insets = new Insets(0, 0, 1, myInfo.isCancellable() ? 0 : 4);\n      c.fill = GridBagConstraints.HORIZONTAL;\n      progressWrapper.add(myProgress, c);\n\n      textAndProgress.add(progressWrapper, BorderLayout.EAST);\n      myComponent.add(textAndProgress, BorderLayout.CENTER);\n      myComponent.add(myCancelButton, BorderLayout.EAST);\n      myComponent.setToolTipText(processInfo.getTitle() + \". \" + IdeBundle.message(\"progress.text.clickToViewProgressWindow\"));\n      myProgress.setActive(false);\n    } else {\n      myComponent.setLayout(new BorderLayout());\n      myProcessName.setText(processInfo.getTitle());\n      myComponent.add(myProcessName, BorderLayout.NORTH);\n      final Font font = myProcessName.getFont();\n\n      final boolean aqua = LafManager.getInstance().isUnderAquaLookAndFeel();\n\n      int size = font.getSize() - (aqua ? 4 : 2);\n      if (size < (aqua ? 8 : 10)) {\n        size = (aqua ? 8 : 10);\n      }\n      myProcessName.setFont(font.deriveFont(Font.PLAIN, size));\n      myProcessName.setForeground(UIManager.getColor(\"Panel.background\").brighter().brighter());\n      myProcessName.setBorder(new EmptyBorder(2, 2, 2, 2));\n      myProcessName.setDecorate(false);\n\n      final NonOpaquePanel content = new NonOpaquePanel(new BorderLayout());\n      content.setBorder(new EmptyBorder(2, 2, 2, myInfo.isCancellable() ? 2 : 4));\n      myComponent.add(content, BorderLayout.CENTER);\n\n      final Wrapper cancelWrapper = new Wrapper(myCancelButton);\n      cancelWrapper.setOpaque(false);\n      cancelWrapper.setBorder(new EmptyBorder(0, 3, 0, 2));\n\n      content.add(cancelWrapper, BorderLayout.EAST);\n      content.add(myText, BorderLayout.NORTH);\n      content.add(myProgress, BorderLayout.CENTER);\n      content.add(myText2, BorderLayout.SOUTH);\n\n      myText.setDecorate(false);\n      myText2.setDecorate(false);\n\n      myComponent.setBorder(new EmptyBorder(2, 2, 2, 2));\n      myProgress.setActive(false);\n    }\n\n    UIUtil.removeQuaquaVisualMarginsIn(myComponent);\n\n    if (!myCompact) {\n      myProcessName.recomputeSize();\n      myText.recomputeSize();\n      myText2.recomputeSize();\n    }\n\n  }","id":80427,"modified_method":"public InlineProgressIndicator(boolean compact, TaskInfo processInfo) {\n    myCompact = compact;\n    myInfo = processInfo;\n\n    myCancelButton = new InplaceButton(new IconButton(processInfo.getCancelTooltipText(),\n                                                      IconLoader.getIcon(\"/process/stop.png\"),\n                                                      IconLoader.getIcon(\"/process/stopHovered.png\")) {\n    }, new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        cancelRequest();\n      }\n    }).setFillBg(true);\n\n    myCancelButton.setVisible(myInfo.isCancellable());\n    myCancelButton.setOpaque(false);\n    myCancelButton.setToolTipText(processInfo.getCancelTooltipText());\n    myCancelButton.setFillBg(false);\n\n    myProgress = new MyProgressBar(JProgressBar.HORIZONTAL, compact);\n\n    myComponent = new MyComponent(compact, myProcessName);\n    if (myCompact) {\n      myComponent.setOpaque(false);\n      myComponent.setLayout(new BorderLayout(2, 0));\n      final JPanel textAndProgress = new JPanel(new BorderLayout());\n      textAndProgress.setOpaque(false);\n      textAndProgress.add(myText, BorderLayout.CENTER);\n\n      final NonOpaquePanel progressWrapper = new NonOpaquePanel(new GridBagLayout());\n      progressWrapper.setBorder(BorderFactory.createEmptyBorder(0, 4, 0, 0));\n      final GridBagConstraints c = new GridBagConstraints();\n      c.weightx = 1;\n      c.weighty = 1;\n      c.insets = new Insets(0, 0, 1, myInfo.isCancellable() ? 0 : 4);\n      c.fill = GridBagConstraints.HORIZONTAL;\n      progressWrapper.add(myProgress, c);\n\n      textAndProgress.add(progressWrapper, BorderLayout.EAST);\n      myComponent.add(textAndProgress, BorderLayout.CENTER);\n      myComponent.add(myCancelButton, BorderLayout.EAST);\n      myComponent.setToolTipText(processInfo.getTitle() + \". \" + IdeBundle.message(\"progress.text.clickToViewProgressWindow\"));\n      myProgress.setActive(false);\n    } else {\n      myComponent.setLayout(new BorderLayout());\n      myProcessName.setText(processInfo.getTitle());\n      myComponent.add(myProcessName, BorderLayout.NORTH);\n      final Font font = myProcessName.getFont();\n\n      final boolean aqua = LafManager.getInstance().isUnderAquaLookAndFeel();\n\n      int size = font.getSize() - (aqua ? 4 : 2);\n      if (size < (aqua ? 8 : 10)) {\n        size = (aqua ? 8 : 10);\n      }\n      myProcessName.setFont(font.deriveFont(Font.PLAIN, size));\n      myProcessName.setForeground(UIManager.getColor(\"Panel.background\").brighter().brighter());\n      myProcessName.setBorder(new EmptyBorder(2, 2, 2, 2));\n      myProcessName.setDecorate(false);\n\n      final NonOpaquePanel content = new NonOpaquePanel(new BorderLayout());\n      content.setBorder(new EmptyBorder(2, 2, 2, myInfo.isCancellable() ? 2 : 4));\n      myComponent.add(content, BorderLayout.CENTER);\n\n      final Wrapper cancelWrapper = new Wrapper(myCancelButton);\n      cancelWrapper.setOpaque(false);\n      cancelWrapper.setBorder(new EmptyBorder(0, 3, 0, 2));\n\n      content.add(cancelWrapper, BorderLayout.EAST);\n      content.add(myText, BorderLayout.NORTH);\n      content.add(myProgress, BorderLayout.CENTER);\n      content.add(myText2, BorderLayout.SOUTH);\n\n      myText.setDecorate(false);\n      myText2.setDecorate(false);\n\n      myComponent.setBorder(new EmptyBorder(2, 2, 2, 2));\n      myProgress.setActive(false);\n    }\n\n    UIUtil.removeQuaquaVisualMarginsIn(myComponent);\n\n    if (!myCompact) {\n      myProcessName.recomputeSize();\n      myText.recomputeSize();\n      myText2.recomputeSize();\n    }\n\n  }","commit_id":"77cb56f5916b0289e071d4cdc962acc93dd53ca5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintComponent(final Graphics g) {\n    final String s = getText();\n    if (s != null) {\n      final Rectangle bounds = getBounds();\n      final Insets insets = getInsets();\n\n      final Graphics2D g2 = (Graphics2D)g;\n      g2.setFont(getFont());\n\n      UIUtil.applyRenderingHints(g2);\n\n      int x = insets.left;\n      if (myAlignment == JComponent.CENTER_ALIGNMENT || myAlignment == JComponent.RIGHT_ALIGNMENT) {\n        final int sWidth = g2.getFontMetrics().stringWidth(s);\n        x = myAlignment == JComponent.CENTER_ALIGNMENT ? (bounds.width - sWidth) / 2 : bounds.width - insets.right - sWidth;\n      }\n\n      final int y = UIUtil.getStringY(s, bounds, g2);\n      if (SystemInfo.isMac && myDecorate) {\n        g2.setColor(new Color(215, 215, 215));\n        g2.drawString(s, x, y+1);\n      }\n\n      g2.setColor(getForeground());\n      g2.drawString(s, x, y);\n    }\n  }","id":80428,"modified_method":"@Override\n  protected void paintComponent(final Graphics g) {\n    String s = getText();\n    if (s != null) {\n      final Rectangle bounds = getBounds();\n      final Insets insets = getInsets();\n\n      final Graphics2D g2 = (Graphics2D)g;\n      g2.setFont(getFont());\n\n      UIUtil.applyRenderingHints(g2);\n\n      final FontMetrics fm = g2.getFontMetrics();\n      final int sWidth = fm.stringWidth(s);\n\n      int x = insets.left;\n      if (myAlignment == JComponent.CENTER_ALIGNMENT || myAlignment == JComponent.RIGHT_ALIGNMENT) {\n        x = myAlignment == JComponent.CENTER_ALIGNMENT ? (bounds.width - sWidth) / 2 : bounds.width - insets.right - sWidth;\n      }\n\n      final Rectangle textR = new Rectangle();\n      final Rectangle iconR = new Rectangle();\n      final Rectangle viewR = new Rectangle(bounds);\n      textR.x = textR.y = textR.width = textR.height = 0;\n\n      viewR.width -= insets.left;\n      viewR.width -= insets.right;\n\n      if (sWidth > (bounds.width - insets.left - insets.right)) {\n        s = SwingUtilities\n          .layoutCompoundLabel(fm, s, null, SwingUtilities.CENTER, SwingUtilities.CENTER, SwingUtilities.CENTER, SwingUtilities.TRAILING,\n                               bounds, iconR, textR, 0);\n      }\n\n      final int y = UIUtil.getStringY(s, bounds, g2);\n      if (SystemInfo.isMac && myDecorate) {\n        g2.setColor(new Color(215, 215, 215));\n        g2.drawString(s, x, y+1);\n      }\n\n      g2.setColor(getForeground());\n      g2.drawString(s, x, y);\n    }\n  }","commit_id":"77cb56f5916b0289e071d4cdc962acc93dd53ca5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Dimension getPreferredSize() {\n    if (!isToDrawCombo()) {\n      return super.getPreferredSize();\n    }\n\n    int width = 0;\n    for (int i = 0; i < myUi.myManager.getContentCount(); i++) {\n      String text = myUi.myManager.getContent(i).getDisplayName();\n      int eachTextWidth = getFontMetrics(getFont()).stringWidth(text);\n      width = Math.max(eachTextWidth, width);\n    }\n\n    Border border = getBorder();\n    if (border != null) {\n      Insets insets = border.getBorderInsets(this);\n      width += (insets.left + insets.right);\n    }\n\n    width += myComboIcon.getIconWidth();\n\n    return new Dimension(width, super.getPreferredSize().height);\n  }","id":80429,"modified_method":"@Override\n  public Dimension getPreferredSize() {\n    if (!isToDrawCombo()) {\n      return super.getPreferredSize();\n    }\n\n    int width = 0;\n    for (int i = 0; i < myUi.myManager.getContentCount(); i++) {\n      String text = myUi.myManager.getContent(i).getDisplayName();\n      FontMetrics metrics = getFontMetrics(getFont());\n      int eachTextWidth = metrics.stringWidth(text != null ? text : \"\");\n      width = Math.max(eachTextWidth, width);\n    }\n\n    Border border = getBorder();\n    if (border != null) {\n      Insets insets = border.getBorderInsets(this);\n      width += (insets.left + insets.right);\n    }\n\n    width += myComboIcon.getIconWidth();\n\n    return new Dimension(width, super.getPreferredSize().height);\n  }","commit_id":"3937fe3564a7a7c77eb07e5770ea4f7e835d98d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private JavaResolveResult[] resolveOptimised(@NotNull PsiReferenceExpression expression) {\n    JavaResolveResult[] results;\n    if (expression instanceof PsiReferenceExpressionImpl) {\n      results = JavaResolveUtil.resolveWithContainingFile(expression,\n                                                          PsiReferenceExpressionImpl.OurGenericsResolver.INSTANCE, true, true,\n                                                          myFile);\n    }\n    else {\n      results = expression.multiResolve(true);\n    }\n    return results;\n  }","id":80430,"modified_method":"private @Nullable JavaResolveResult[] resolveOptimised(@NotNull PsiReferenceExpression expression) {\n    try {\n      if (expression instanceof PsiReferenceExpressionImpl) {\n        PsiReferenceExpressionImpl.OurGenericsResolver resolver = PsiReferenceExpressionImpl.OurGenericsResolver.INSTANCE;\n        return JavaResolveUtil.resolveWithContainingFile(expression, resolver, true, true, myFile);\n      }\n      else {\n        return expression.multiResolve(true);\n      }\n    }\n    catch (IndexNotReadyException e) {\n      return null;\n    }\n  }","commit_id":"aec2327164a332307382546df921b6432e0bd483","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitReferenceExpression(PsiReferenceExpression expression) {\n    JavaResolveResult resultForIncompleteCode = doVisitReferenceElement(expression);\n\n    if (!myHolder.hasErrorResults()) {\n      visitExpression(expression);\n      if (myHolder.hasErrorResults()) return;\n    }\n\n    JavaResolveResult result;\n    JavaResolveResult[] results;\n    try {\n      results = resolveOptimised(expression);\n      result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n    }\n    catch (IndexNotReadyException e) {\n      return;\n    }\n\n    PsiElement resolved = result.getElement();\n    if (resolved instanceof PsiVariable && resolved.getContainingFile() == expression.getContainingFile()) {\n      if (!myHolder.hasErrorResults()) {\n        try {\n          myHolder.add(HighlightControlFlowUtil.checkVariableInitializedBeforeUsage(expression, (PsiVariable)resolved, myUninitializedVarProblems,myFile));\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n      PsiVariable variable = (PsiVariable)resolved;\n      boolean isFinal = variable.hasModifierProperty(PsiModifier.FINAL);\n      if (isFinal && !variable.hasInitializer()) {\n        if (!myHolder.hasErrorResults()) {\n          myHolder.add(HighlightControlFlowUtil.checkFinalVariableMightAlreadyHaveBeenAssignedTo(variable, expression, myFinalVarProblems));\n        }\n        if (!myHolder.hasErrorResults()) myHolder.add(HighlightControlFlowUtil.checkFinalVariableInitializedInLoop(expression, resolved));\n      }\n    }\n\n    PsiElement parent = expression.getParent();\n    if (parent instanceof PsiMethodCallExpression &&\n        ((PsiMethodCallExpression)parent).getMethodExpression() == expression &&\n        (!result.isAccessible() || !result.isStaticsScopeCorrect())) {\n      PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)parent;\n      PsiExpressionList list = methodCallExpression.getArgumentList();\n      if (!HighlightMethodUtil.isDummyConstructorCall(methodCallExpression, myResolveHelper, list, expression)) {\n        try {\n          myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallIdentifier(\n            expression, results, list, resolved, result, methodCallExpression, myResolveHelper));\n\n          if (!PsiTreeUtil.findChildrenOfType(methodCallExpression.getArgumentList(), PsiLambdaExpression.class).isEmpty()) {\n            PsiElement nameElement = expression.getReferenceNameElement();\n            if (nameElement != null) {\n              myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallArguments(\n                expression, results, list, resolved, result, methodCallExpression, myResolveHelper, nameElement));\n            }\n          }\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n    }\n\n    if (!myHolder.hasErrorResults() && resultForIncompleteCode != null) {\n      myHolder.add(HighlightUtil.checkExpressionRequired(expression, resultForIncompleteCode));\n    }\n\n    if (!myHolder.hasErrorResults() && resolved instanceof PsiField) {\n      try {\n        myHolder.add(HighlightUtil.checkIllegalForwardReferenceToField(expression, (PsiField)resolved));\n      }\n      catch (IndexNotReadyException ignored) { }\n    }\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkAccessStaticFieldFromEnumConstructor(expression, result));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkClassReferenceAfterQualifier(expression, resolved));\n    final PsiExpression qualifierExpression = expression.getQualifierExpression();\n    myHolder.add(HighlightUtil.checkUnqualifiedSuperInDefaultMethod(myLanguageLevel, expression, qualifierExpression));\n    if (!myHolder.hasErrorResults() && qualifierExpression != null) {\n      PsiType type = qualifierExpression.getType();\n      if (type instanceof PsiCapturedWildcardType) {\n        type = ((PsiCapturedWildcardType)type).getUpperBound();\n      }\n      final PsiClass psiClass = PsiUtil.resolveClassInType(type);\n      if (psiClass != null) {\n        myHolder.add(GenericsHighlightUtil.areSupersAccessible(psiClass, expression));\n      }\n    }\n  }","id":80431,"modified_method":"@Override\n  public void visitReferenceExpression(PsiReferenceExpression expression) {\n    JavaResolveResult resultForIncompleteCode = doVisitReferenceElement(expression);\n\n    if (!myHolder.hasErrorResults()) {\n      visitExpression(expression);\n      if (myHolder.hasErrorResults()) return;\n    }\n\n    JavaResolveResult[] results = resolveOptimised(expression);\n    if (results == null) return;\n    JavaResolveResult result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n\n    PsiElement resolved = result.getElement();\n    if (resolved instanceof PsiVariable && resolved.getContainingFile() == expression.getContainingFile()) {\n      if (!myHolder.hasErrorResults()) {\n        try {\n          myHolder.add(HighlightControlFlowUtil.checkVariableInitializedBeforeUsage(expression, (PsiVariable)resolved, myUninitializedVarProblems,myFile));\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n      PsiVariable variable = (PsiVariable)resolved;\n      boolean isFinal = variable.hasModifierProperty(PsiModifier.FINAL);\n      if (isFinal && !variable.hasInitializer()) {\n        if (!myHolder.hasErrorResults()) {\n          myHolder.add(HighlightControlFlowUtil.checkFinalVariableMightAlreadyHaveBeenAssignedTo(variable, expression, myFinalVarProblems));\n        }\n        if (!myHolder.hasErrorResults()) myHolder.add(HighlightControlFlowUtil.checkFinalVariableInitializedInLoop(expression, resolved));\n      }\n    }\n\n    PsiElement parent = expression.getParent();\n    if (parent instanceof PsiMethodCallExpression &&\n        ((PsiMethodCallExpression)parent).getMethodExpression() == expression &&\n        (!result.isAccessible() || !result.isStaticsScopeCorrect())) {\n      PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)parent;\n      PsiExpressionList list = methodCallExpression.getArgumentList();\n      if (!HighlightMethodUtil.isDummyConstructorCall(methodCallExpression, myResolveHelper, list, expression)) {\n        try {\n          myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallIdentifier(\n            expression, results, list, resolved, result, methodCallExpression, myResolveHelper));\n\n          if (!PsiTreeUtil.findChildrenOfType(methodCallExpression.getArgumentList(), PsiLambdaExpression.class).isEmpty()) {\n            PsiElement nameElement = expression.getReferenceNameElement();\n            if (nameElement != null) {\n              myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallArguments(\n                expression, results, list, resolved, result, methodCallExpression, myResolveHelper, nameElement));\n            }\n          }\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n    }\n\n    if (!myHolder.hasErrorResults() && resultForIncompleteCode != null) {\n      myHolder.add(HighlightUtil.checkExpressionRequired(expression, resultForIncompleteCode));\n    }\n\n    if (!myHolder.hasErrorResults() && resolved instanceof PsiField) {\n      try {\n        myHolder.add(HighlightUtil.checkIllegalForwardReferenceToField(expression, (PsiField)resolved));\n      }\n      catch (IndexNotReadyException ignored) { }\n    }\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkAccessStaticFieldFromEnumConstructor(expression, result));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkClassReferenceAfterQualifier(expression, resolved));\n    final PsiExpression qualifierExpression = expression.getQualifierExpression();\n    myHolder.add(HighlightUtil.checkUnqualifiedSuperInDefaultMethod(myLanguageLevel, expression, qualifierExpression));\n    if (!myHolder.hasErrorResults() && qualifierExpression != null) {\n      PsiType type = qualifierExpression.getType();\n      if (type instanceof PsiCapturedWildcardType) {\n        type = ((PsiCapturedWildcardType)type).getUpperBound();\n      }\n      final PsiClass psiClass = PsiUtil.resolveClassInType(type);\n      if (psiClass != null) {\n        myHolder.add(GenericsHighlightUtil.areSupersAccessible(psiClass, expression));\n      }\n    }\n  }","commit_id":"aec2327164a332307382546df921b6432e0bd483","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private JavaResolveResult resolveOptimised(@NotNull PsiJavaCodeReferenceElement ref) {\n    JavaResolveResult result;\n    if (ref instanceof PsiReferenceExpressionImpl) {\n      JavaResolveResult[] results = JavaResolveUtil.resolveWithContainingFile(ref,\n                                                                              PsiReferenceExpressionImpl.OurGenericsResolver.INSTANCE,\n                                                                              true, true,\n                                                                              myFile);\n      result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n    }\n    else {\n      result = ref.advancedResolve(true);\n    }\n    return result;\n  }","id":80432,"modified_method":"private @Nullable JavaResolveResult resolveOptimised(@NotNull PsiJavaCodeReferenceElement ref) {\n    try {\n      if (ref instanceof PsiReferenceExpressionImpl) {\n        PsiReferenceExpressionImpl.OurGenericsResolver resolver = PsiReferenceExpressionImpl.OurGenericsResolver.INSTANCE;\n        JavaResolveResult[] results = JavaResolveUtil.resolveWithContainingFile(ref, resolver, true, true, myFile);\n        return results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n      }\n      else {\n        return ref.advancedResolve(true);\n      }\n    }\n    catch (IndexNotReadyException e) {\n      return null;\n    }\n  }","commit_id":"aec2327164a332307382546df921b6432e0bd483","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JavaResolveResult doVisitReferenceElement(@NotNull PsiJavaCodeReferenceElement ref) {\n    JavaResolveResult result;\n    try {\n      result = resolveOptimised(ref);\n    }\n    catch (IndexNotReadyException e) {\n      return null;\n    }\n\n    PsiElement resolved = result.getElement();\n    PsiElement parent = ref.getParent();\n\n    if (myRefCountHolder != null) {\n      myRefCountHolder.registerReference(ref, result);\n    }\n\n    myHolder.add(HighlightUtil.checkReference(ref, result, myFile, myLanguageLevel));\n\n    if (parent instanceof PsiJavaCodeReferenceElement || ref.isQualified()) {\n      if (!myHolder.hasErrorResults() && resolved instanceof PsiTypeParameter) {\n        boolean cannotSelectFromTypeParameter = !myJavaSdkVersion.isAtLeast(JavaSdkVersion.JDK_1_7);\n        if (!cannotSelectFromTypeParameter) {\n          final PsiClass containingClass = PsiTreeUtil.getParentOfType(ref, PsiClass.class);\n          if (containingClass != null) {\n            if (PsiTreeUtil.isAncestor(containingClass.getExtendsList(), ref, false) ||\n                PsiTreeUtil.isAncestor(containingClass.getImplementsList(), ref, false)) {\n              cannotSelectFromTypeParameter = true;\n            }\n          }\n        }\n        if (cannotSelectFromTypeParameter) {\n          myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).descriptionAndTooltip(\"Cannot select from a type parameter\").range(ref).create());\n        }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightClassUtil.checkAbstractInstantiation(ref));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightClassUtil.checkExtendsDuplicate(ref, resolved,myFile));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightClassUtil.checkClassExtendsForeignInnerClass(ref, resolved));\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkSelectStaticClassFromParameterizedType(resolved, ref));\n    if (!myHolder.hasErrorResults()) {\n      myHolder.add(GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(resolved, ref, result.getSubstitutor(), myJavaSdkVersion));\n    }\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkCannotPassInner(ref));\n\n    if (resolved != null && parent instanceof PsiReferenceList) {\n      if (!myHolder.hasErrorResults()) {\n        PsiReferenceList referenceList = (PsiReferenceList)parent;\n        myHolder.add(HighlightUtil.checkElementInReferenceList(ref, referenceList, result));\n      }\n    }\n\n    if (parent instanceof PsiAnonymousClass && ref.equals(((PsiAnonymousClass)parent).getBaseClassReference()) &&\n        myOverrideEquivalentMethodsVisitedClasses.add((PsiClass)parent)) {\n      PsiClass aClass = (PsiClass)parent;\n      myHolder.addAll(GenericsHighlightUtil.checkOverrideEquivalentMethods(aClass));\n    }\n\n    if (resolved instanceof PsiVariable) {\n      PsiVariable variable = (PsiVariable)resolved;\n\n      PsiElement containingClass = PsiTreeUtil.getNonStrictParentOfType(ref, PsiClass.class, PsiLambdaExpression.class);\n      if ((containingClass instanceof PsiAnonymousClass || containingClass instanceof PsiLambdaExpression) &&\n          !PsiTreeUtil.isAncestor(containingClass, variable, false) &&\n          !(variable instanceof PsiField) &&\n          (containingClass instanceof PsiLambdaExpression ||\n           !PsiTreeUtil.isAncestor(((PsiAnonymousClass)containingClass).getArgumentList(), ref, false))) {\n        myHolder.add(HighlightInfo.newHighlightInfo(JavaHighlightInfoTypes.IMPLICIT_ANONYMOUS_CLASS_PARAMETER).range(ref).create());\n      }\n\n      if (variable instanceof PsiParameter && ref instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression)ref)) {\n        myReassignedParameters.put((PsiParameter)variable, 2);\n      }\n\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (!variable.hasModifierProperty(PsiModifier.FINAL) && isReassigned(variable)) {\n        myHolder.add(HighlightNamesUtil.highlightReassignedVariable(variable, ref));\n      }\n      else {\n        PsiElement nameElement = ref.getReferenceNameElement();\n        if (nameElement != null) {\n          myHolder.add(HighlightNamesUtil.highlightVariableName(variable, nameElement, colorsScheme));\n        }\n      }\n      myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(ref, colorsScheme));\n    }\n    else {\n      highlightReferencedMethodOrClassName(ref, resolved);\n    }\n\n    if (parent instanceof PsiNewExpression &&\n        !(resolved instanceof PsiClass) &&\n        resolved instanceof PsiNamedElement &&\n        ((PsiNewExpression)parent).getClassOrAnonymousClassReference() == ref) {\n      String text = JavaErrorMessages.message(\"cannot.resolve.symbol\", ((PsiNamedElement)resolved).getName());\n      myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(ref).descriptionAndTooltip(text).create());\n    }\n\n    if (!myHolder.hasErrorResults() && resolved instanceof PsiClass) {\n      final PsiClass aClass = ((PsiClass)resolved).getContainingClass();\n      if (aClass != null) {\n        final PsiElement qualifier = ref.getQualifier();\n        final PsiElement place;\n        if (qualifier instanceof PsiJavaCodeReferenceElement) {\n          place = ((PsiJavaCodeReferenceElement)qualifier).resolve();\n        }\n        else {\n          if (parent instanceof PsiNewExpression) {\n            final PsiExpression newQualifier = ((PsiNewExpression)parent).getQualifier();\n            place = newQualifier == null ? ref : PsiUtil.resolveClassInType(newQualifier.getType());\n          }\n          else {\n            place = ref;\n          }\n        }\n        if (place != null && PsiTreeUtil.isAncestor(aClass, place, false) && aClass.hasTypeParameters()) {\n          myHolder.add(HighlightClassUtil.checkCreateInnerClassFromStaticContext(ref, place, (PsiClass)resolved));\n        }\n      }\n      else if (resolved instanceof PsiTypeParameter) {\n        final PsiTypeParameterListOwner owner = ((PsiTypeParameter)resolved).getOwner();\n        if (owner instanceof PsiClass) {\n          final PsiClass outerClass = (PsiClass)owner;\n          if (!InheritanceUtil.hasEnclosingInstanceInScope(outerClass, ref, false, false)) {\n            myHolder.add(HighlightClassUtil.reportIllegalEnclosingUsage(ref, null, (PsiClass)owner, ref));\n          }\n        }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkPackageAndClassConflict(ref, myFile));\n\n    return result;\n  }","id":80433,"modified_method":"private JavaResolveResult doVisitReferenceElement(@NotNull PsiJavaCodeReferenceElement ref) {\n    JavaResolveResult result = resolveOptimised(ref);\n    if (result == null) return null;\n\n    PsiElement resolved = result.getElement();\n    PsiElement parent = ref.getParent();\n\n    if (myRefCountHolder != null) {\n      myRefCountHolder.registerReference(ref, result);\n    }\n\n    myHolder.add(HighlightUtil.checkReference(ref, result, myFile, myLanguageLevel));\n\n    if (parent instanceof PsiJavaCodeReferenceElement || ref.isQualified()) {\n      if (!myHolder.hasErrorResults() && resolved instanceof PsiTypeParameter) {\n        boolean cannotSelectFromTypeParameter = !myJavaSdkVersion.isAtLeast(JavaSdkVersion.JDK_1_7);\n        if (!cannotSelectFromTypeParameter) {\n          final PsiClass containingClass = PsiTreeUtil.getParentOfType(ref, PsiClass.class);\n          if (containingClass != null) {\n            if (PsiTreeUtil.isAncestor(containingClass.getExtendsList(), ref, false) ||\n                PsiTreeUtil.isAncestor(containingClass.getImplementsList(), ref, false)) {\n              cannotSelectFromTypeParameter = true;\n            }\n          }\n        }\n        if (cannotSelectFromTypeParameter) {\n          myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).descriptionAndTooltip(\"Cannot select from a type parameter\").range(ref).create());\n        }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightClassUtil.checkAbstractInstantiation(ref));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightClassUtil.checkExtendsDuplicate(ref, resolved,myFile));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightClassUtil.checkClassExtendsForeignInnerClass(ref, resolved));\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkSelectStaticClassFromParameterizedType(resolved, ref));\n    if (!myHolder.hasErrorResults()) {\n      myHolder.add(GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(resolved, ref, result.getSubstitutor(), myJavaSdkVersion));\n    }\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkCannotPassInner(ref));\n\n    if (resolved != null && parent instanceof PsiReferenceList) {\n      if (!myHolder.hasErrorResults()) {\n        PsiReferenceList referenceList = (PsiReferenceList)parent;\n        myHolder.add(HighlightUtil.checkElementInReferenceList(ref, referenceList, result));\n      }\n    }\n\n    if (parent instanceof PsiAnonymousClass && ref.equals(((PsiAnonymousClass)parent).getBaseClassReference()) &&\n        myOverrideEquivalentMethodsVisitedClasses.add((PsiClass)parent)) {\n      PsiClass aClass = (PsiClass)parent;\n      myHolder.addAll(GenericsHighlightUtil.checkOverrideEquivalentMethods(aClass));\n    }\n\n    if (resolved instanceof PsiVariable) {\n      PsiVariable variable = (PsiVariable)resolved;\n\n      PsiElement containingClass = PsiTreeUtil.getNonStrictParentOfType(ref, PsiClass.class, PsiLambdaExpression.class);\n      if ((containingClass instanceof PsiAnonymousClass || containingClass instanceof PsiLambdaExpression) &&\n          !PsiTreeUtil.isAncestor(containingClass, variable, false) &&\n          !(variable instanceof PsiField) &&\n          (containingClass instanceof PsiLambdaExpression ||\n           !PsiTreeUtil.isAncestor(((PsiAnonymousClass)containingClass).getArgumentList(), ref, false))) {\n        myHolder.add(HighlightInfo.newHighlightInfo(JavaHighlightInfoTypes.IMPLICIT_ANONYMOUS_CLASS_PARAMETER).range(ref).create());\n      }\n\n      if (variable instanceof PsiParameter && ref instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression)ref)) {\n        myReassignedParameters.put((PsiParameter)variable, 2);\n      }\n\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (!variable.hasModifierProperty(PsiModifier.FINAL) && isReassigned(variable)) {\n        myHolder.add(HighlightNamesUtil.highlightReassignedVariable(variable, ref));\n      }\n      else {\n        PsiElement nameElement = ref.getReferenceNameElement();\n        if (nameElement != null) {\n          myHolder.add(HighlightNamesUtil.highlightVariableName(variable, nameElement, colorsScheme));\n        }\n      }\n      myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(ref, colorsScheme));\n    }\n    else {\n      highlightReferencedMethodOrClassName(ref, resolved);\n    }\n\n    if (parent instanceof PsiNewExpression &&\n        !(resolved instanceof PsiClass) &&\n        resolved instanceof PsiNamedElement &&\n        ((PsiNewExpression)parent).getClassOrAnonymousClassReference() == ref) {\n      String text = JavaErrorMessages.message(\"cannot.resolve.symbol\", ((PsiNamedElement)resolved).getName());\n      myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(ref).descriptionAndTooltip(text).create());\n    }\n\n    if (!myHolder.hasErrorResults() && resolved instanceof PsiClass) {\n      final PsiClass aClass = ((PsiClass)resolved).getContainingClass();\n      if (aClass != null) {\n        final PsiElement qualifier = ref.getQualifier();\n        final PsiElement place;\n        if (qualifier instanceof PsiJavaCodeReferenceElement) {\n          place = ((PsiJavaCodeReferenceElement)qualifier).resolve();\n        }\n        else {\n          if (parent instanceof PsiNewExpression) {\n            final PsiExpression newQualifier = ((PsiNewExpression)parent).getQualifier();\n            place = newQualifier == null ? ref : PsiUtil.resolveClassInType(newQualifier.getType());\n          }\n          else {\n            place = ref;\n          }\n        }\n        if (place != null && PsiTreeUtil.isAncestor(aClass, place, false) && aClass.hasTypeParameters()) {\n          myHolder.add(HighlightClassUtil.checkCreateInnerClassFromStaticContext(ref, place, (PsiClass)resolved));\n        }\n      }\n      else if (resolved instanceof PsiTypeParameter) {\n        final PsiTypeParameterListOwner owner = ((PsiTypeParameter)resolved).getOwner();\n        if (owner instanceof PsiClass) {\n          final PsiClass outerClass = (PsiClass)owner;\n          if (!InheritanceUtil.hasEnclosingInstanceInScope(outerClass, ref, false, false)) {\n            myHolder.add(HighlightClassUtil.reportIllegalEnclosingUsage(ref, null, (PsiClass)owner, ref));\n          }\n        }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkPackageAndClassConflict(ref, myFile));\n\n    return result;\n  }","commit_id":"aec2327164a332307382546df921b6432e0bd483","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitExpressionList(PsiExpressionList list) {\n    super.visitExpressionList(list);\n    PsiElement parent = list.getParent();\n    if (parent instanceof PsiMethodCallExpression) {\n      PsiMethodCallExpression expression = (PsiMethodCallExpression)parent;\n      if (expression.getArgumentList() == list) {\n        PsiReferenceExpression referenceExpression = expression.getMethodExpression();\n        JavaResolveResult result;\n        JavaResolveResult[] results;\n        try {\n          results = resolveOptimised(referenceExpression);\n          result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n        }\n        catch (IndexNotReadyException e) {\n          return;\n        }\n        PsiElement resolved = result.getElement();\n\n        if ((!result.isAccessible() || !result.isStaticsScopeCorrect()) &&\n            !HighlightMethodUtil.isDummyConstructorCall(expression, myResolveHelper, list, referenceExpression) &&\n            // this check is for fake expression from JspMethodCallImpl\n            referenceExpression.getParent() == expression) {\n          try {\n            if (PsiTreeUtil.findChildrenOfType(expression.getArgumentList(), PsiLambdaExpression.class).isEmpty()) {\n              myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallArguments(referenceExpression, results, list, resolved, result, expression, myResolveHelper, list));\n            }\n          }\n          catch (IndexNotReadyException ignored) { }\n        }\n      }\n    }\n  }","id":80434,"modified_method":"@Override\n  public void visitExpressionList(PsiExpressionList list) {\n    super.visitExpressionList(list);\n    PsiElement parent = list.getParent();\n    if (parent instanceof PsiMethodCallExpression) {\n      PsiMethodCallExpression expression = (PsiMethodCallExpression)parent;\n      if (expression.getArgumentList() == list) {\n        PsiReferenceExpression referenceExpression = expression.getMethodExpression();\n        JavaResolveResult[] results = resolveOptimised(referenceExpression);\n        if (results == null) return;\n        JavaResolveResult result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n        PsiElement resolved = result.getElement();\n\n        if ((!result.isAccessible() || !result.isStaticsScopeCorrect()) &&\n            !HighlightMethodUtil.isDummyConstructorCall(expression, myResolveHelper, list, referenceExpression) &&\n            // this check is for fake expression from JspMethodCallImpl\n            referenceExpression.getParent() == expression) {\n          try {\n            if (PsiTreeUtil.findChildrenOfType(expression.getArgumentList(), PsiLambdaExpression.class).isEmpty()) {\n              myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallArguments(referenceExpression, results, list, resolved, result, expression, myResolveHelper, list));\n            }\n          }\n          catch (IndexNotReadyException ignored) { }\n        }\n      }\n    }\n  }","commit_id":"aec2327164a332307382546df921b6432e0bd483","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Split the data into a series of read-only Bucket's.\n\t * @param origData The original data Bucket.\n\t * @param splitSize The number of bytes to put into each bucket.\n\t *\n\t * If the passed-in Bucket is a FileBucket, will be efficiently\n\t * split into ReadOnlyFileSliceBuckets, otherwise new buckets are created\n\t * and the data written to them.\n\t * \n\t * Note that this method will allocate a buffer of size splitSize.\n\t * @param freeData\n\t * @throws IOException If there is an error creating buckets, reading from\n\t * the provided bucket, or writing to created buckets.\n\t */\n\tpublic static Bucket[] split(Bucket origData, int splitSize, BucketFactory bf, boolean freeData) throws IOException {\n\t\tif(origData instanceof FileBucket) {\n\t\t\tif(freeData)\n\t\t\t\tLogger.error(BucketTools.class, \"Asked to free data when splitting a FileBucket ?!?!? Not freeing as this would clobber the split result...\");\n\t\t\treturn ((FileBucket)origData).split(splitSize);\n\t\t}\n\t\tif(origData instanceof BucketChainBucket) {\n\t\t\tBucketChainBucket data = (BucketChainBucket) origData;\n\t\t\tif(data.bucketSize == splitSize) {\n\t\t\t\tif(freeData)\n\t\t\t\t\tdata.clear();\n\t\t\t\treturn data.getBuckets();\n\t\t\t} else\n\t\t\t\tLogger.error(BucketTools.class, \"Incompatible split size splitting a BucketChainBucket: his split size is \" + data.bucketSize + \" but mine is \" + splitSize + \" - we will copy the data, but this suggests a bug\", new Exception(\"debug\"));\n\t\t}\n\t\tlong length = origData.size();\n\t\tif(length > ((long)Integer.MAX_VALUE) * splitSize)\n\t\t\tthrow new IllegalArgumentException(\"Way too big!: \"+length+\" for \"+splitSize);\n\t\tint bucketCount = (int) (length / splitSize);\n\t\tif(length % splitSize > 0) bucketCount++;\n\t\tif(Logger.shouldLog(Logger.MINOR, BucketTools.class))\n\t\t\tLogger.minor(BucketTools.class, \"Splitting bucket \"+origData+\" of size \"+length+\" into \"+bucketCount+\" buckets\");\n\t\tBucket[] buckets = new Bucket[bucketCount];\n\t\tInputStream is = origData.getInputStream();\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tdis = new DataInputStream(is);\n\t\t\tlong remainingLength = length;\n\t\t\tbyte[] buf = new byte[splitSize];\n\t\t\tfor(int i=0;i<bucketCount;i++) {\n\t\t\t\tint len = (int) Math.min(splitSize, remainingLength);\n\t\t\t\tBucket bucket = bf.makeBucket(len);\n\t\t\t\tbuckets[i] = bucket;\n\t\t\t\tdis.readFully(buf, 0, len);\n\t\t\t\tremainingLength -= len;\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\ttry {\n\t\t\t\t\tos.write(buf, 0, len);\n\t\t\t\t} finally {\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif(dis != null)\n\t\t\t\tdis.close();\n\t\t\telse\n\t\t\t\tis.close();\n\t\t}\n\t\tif(freeData)\n\t\t\torigData.free();\n\t\treturn buckets;\n\t}","id":80435,"modified_method":"/**\n\t * Split the data into a series of read-only Bucket's.\n\t * @param origData The original data Bucket.\n\t * @param splitSize The number of bytes to put into each bucket.\n\t *\n\t * If the passed-in Bucket is a FileBucket, will be efficiently\n\t * split into ReadOnlyFileSliceBuckets, otherwise new buckets are created\n\t * and the data written to them.\n\t * \n\t * Note that this method will allocate a buffer of size splitSize.\n\t * @param freeData \n\t * @throws IOException If there is an error creating buckets, reading from\n\t * the provided bucket, or writing to created buckets.\n\t */\n\tpublic static Bucket[] split(Bucket origData, int splitSize, BucketFactory bf, boolean freeData) throws IOException {\n\t\tif(origData instanceof FileBucket) {\n\t\t\tif(freeData) {\n\t\t\t\tLogger.error(BucketTools.class, \"Asked to free data when splitting a FileBucket ?!?!? Not freeing as this would clobber the split result...\");\n\t\t\t}\n\t\t\treturn ((FileBucket)origData).split(splitSize);\n\t\t}\n\t\tif(origData instanceof BucketChainBucket) {\n\t\t\tBucketChainBucket data = (BucketChainBucket)origData;\n\t\t\tif(data.bucketSize == splitSize) {\n\t\t\t\tBucket[] buckets = data.getBuckets();\n\t\t\t\tif(freeData)\n\t\t\t\t\tdata.clear();\n\t\t\t\treturn buckets;\n\t\t\t} else {\n\t\t\t\tLogger.error(BucketTools.class, \"Incompatible split size splitting a BucketChainBucket: his split size is \"+data.bucketSize+\" but mine is \"+splitSize+\" - we will copy the data, but this suggests a bug\", new Exception(\"debug\"));\n\t\t\t}\n\t\t}\n\t\tlong length = origData.size();\n\t\tif(length > ((long)Integer.MAX_VALUE) * splitSize)\n\t\t\tthrow new IllegalArgumentException(\"Way too big!: \"+length+\" for \"+splitSize);\n\t\tint bucketCount = (int) (length / splitSize);\n\t\tif(length % splitSize > 0) bucketCount++;\n\t\tif(Logger.shouldLog(Logger.MINOR, BucketTools.class))\n\t\t\tLogger.minor(BucketTools.class, \"Splitting bucket \"+origData+\" of size \"+length+\" into \"+bucketCount+\" buckets\");\n\t\tBucket[] buckets = new Bucket[bucketCount];\n\t\tInputStream is = origData.getInputStream();\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tdis = new DataInputStream(is);\n\t\t\tlong remainingLength = length;\n\t\t\tbyte[] buf = new byte[splitSize];\n\t\t\tfor(int i=0;i<bucketCount;i++) {\n\t\t\t\tint len = (int) Math.min(splitSize, remainingLength);\n\t\t\t\tBucket bucket = bf.makeBucket(len);\n\t\t\t\tbuckets[i] = bucket;\n\t\t\t\tdis.readFully(buf, 0, len);\n\t\t\t\tremainingLength -= len;\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\ttry {\n\t\t\t\t\tos.write(buf, 0, len);\n\t\t\t\t} finally {\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif(dis != null)\n\t\t\t\tdis.close();\n\t\t\telse\n\t\t\t\tis.close();\n\t\t}\n\t\tif(freeData)\n\t\t\torigData.free();\n\t\treturn buckets;\n\t}","commit_id":"0f2047d5f60819eee7f2793e0492ba8b1df1e3d4","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t* Set the default language used by the framework.\n\t*\n\t* @param selectedLanguage (2 letter code)\n\t* @throws MissingResourceException\n\t*/\n\tpublic static void setLanguage(String selectedLanguage) throws MissingResourceException {\n\t\tselectedLanguage = mapLanguageNameToLongName(selectedLanguage);\n\t\tsynchronized (sync) {\n\t\t\tLogger.normal(CLASS_NAME, \"Changing the current language to : \" + selectedLanguage);\n\t\t\tcurrentClass = new L10n(selectedLanguage);\n\t\t\tif(currentClass == null) {\n\t\t\t\tcurrentClass = new L10n(FALLBACK_DEFAULT);\n\t\t\t\tLogger.error(CLASS_NAME, \"The requested translation is not available!\" + selectedLanguage);\n\t\t\t\tthrow new MissingResourceException(\"The requested translation (\" + selectedLanguage + \") hasn't been found!\", CLASS_NAME, selectedLanguage);\n\t\t\t}\n\t\t}\n\t}","id":80436,"modified_method":"/**\n\t* Set the default language used by the framework.\n\t*\n\t* @param selectedLanguage (2 letter code)\n\t* @throws MissingResourceException\n\t*/\n\tpublic static void setLanguage(String selectedLanguage) throws MissingResourceException {\n\t\tsynchronized (sync) {\n\t\t\tLogger.normal(CLASS_NAME, \"Changing the current language to : \" + selectedLanguage);\n\t\t\tcurrentClass = new L10n(selectedLanguage);\n\t\t\tif(currentClass == null) {\n\t\t\t\tcurrentClass = new L10n(FALLBACK_DEFAULT);\n\t\t\t\tLogger.error(CLASS_NAME, \"The requested translation is not available!\" + selectedLanguage);\n\t\t\t\tthrow new MissingResourceException(\"The requested translation (\" + selectedLanguage + \") hasn't been found!\", CLASS_NAME, selectedLanguage);\n\t\t\t}\n\t\t}\n\t}","commit_id":"0f2047d5f60819eee7f2793e0492ba8b1df1e3d4","url":"https://github.com/freenet/fred"},{"original_method":"private void tryCompress() throws InsertException {\n\t\t// First, determine how small it needs to be\n\t\tBucket origData = block.getData();\n\t\tBucket data = origData;\n\t\tint blockSize;\n\t\tint oneBlockCompressedSize;\n\t\tboolean dontCompress = ctx.dontCompress;\n\t\t\n\t\tlong origSize = data.size();\n\t\tString type = block.desiredURI.getKeyType();\n\t\tif(type.equals(\"SSK\") || type.equals(\"KSK\") || type.equals(\"USK\")) {\n\t\t\tblockSize = SSKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = SSKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else if(type.equals(\"CHK\")) {\n\t\t\tblockSize = CHKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else {\n\t\t\tthrow new InsertException(InsertException.INVALID_URI, \"Unknown key type: \"+type, null);\n\t\t}\n\t\t\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\n\t\tboolean tryCompress = (origSize > blockSize) && (!ctx.dontCompress) && (!dontCompress);\n\t\tif(tryCompress) {\n\t\t\t// Try to compress the data.\n\t\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\t\tint algos = Compressor.countCompressAlgorithms();\n\t\t\ttry {\n\t\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\t\tif(parent == cb)\n\t\t\t\t\t\tctx.eventProducer.produceEvent(new StartedCompressionEvent(i));\n\t\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\t\tBucket result;\n\t\t\t\t\tresult = comp.compress(origData, new BucketChainBucketFactory(ctx.persistentBucketFactory, NodeCHK.BLOCK_SIZE), origData.size());\n\t\t\t\t\tif(result.size() < oneBlockCompressedSize) {\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.free();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// Impossible\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\tboolean freeData = false;\n\t\tif(bestCompressedData != null) {\n\t\t\tdata = bestCompressedData;\n\t\t\tfreeData = true;\n\t\t}\n\t\t\n\t\tif(parent == cb) {\n\t\t\tif(tryCompress)\n\t\t\t\tctx.eventProducer.produceEvent(new FinishedCompressionEvent(bestCodec == null ? -1 : bestCodec.codecNumberForMetadata(), origSize, data.size()));\n\t\t\tif(logMINOR) Logger.minor(this, \"Compressed \"+origSize+\" to \"+data.size()+\" on \"+this);\n\t\t}\n\t\t\n\t\t// Compressed data\n\t\t\n\t\t// Insert it...\n\t\tshort codecNumber = bestCodec == null ? -1 : bestCodec.codecNumberForMetadata();\n\t\tlong compressedDataSize = data.size();\n\t\tboolean fitsInOneBlockAsIs = bestCodec == null ? compressedDataSize < blockSize : compressedDataSize < oneBlockCompressedSize;\n\t\tboolean fitsInOneCHK = bestCodec == null ? compressedDataSize < CHKBlock.DATA_LENGTH : compressedDataSize < CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\n\t\tif((fitsInOneBlockAsIs || fitsInOneCHK) && block.getData().size() > Integer.MAX_VALUE)\n\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"2GB+ should not encode to one block!\", null);\n\n\t\tboolean noMetadata = ((block.clientMetadata == null) || block.clientMetadata.isTrivial()) && targetFilename == null;\n\t\tif(noMetadata && !insertAsArchiveManifest) {\n\t\t\tif(fitsInOneBlockAsIs) {\n\t\t\t\t// Just insert it\n\t\t\t\tClientPutState bi =\n\t\t\t\t\tcreateInserter(parent, data, codecNumber, block.desiredURI, ctx, cb, metadata, (int)block.getData().size(), -1, getCHKOnly, true, true);\n\t\t\t\tcb.onTransition(this, bi);\n\t\t\t\tbi.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fitsInOneCHK) {\n\t\t\t// Insert single block, then insert pointer to it\n\t\t\tif(reportMetadataOnly) {\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, cb, metadata, (int)origSize, -1, getCHKOnly, true, true, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tcb.onMetadata(meta, this);\n\t\t\t\tcb.onTransition(this, dataPutter);\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t} else {\n\t\t\t\tMultiPutCompletionCallback mcb = \n\t\t\t\t\tnew MultiPutCompletionCallback(cb, parent, token);\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, mcb, metadata, (int)origSize, -1, getCHKOnly, true, false, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tBucket metadataBucket;\n\t\t\t\ttry {\n\t\t\t\t\tmetadataBucket = BucketTools.makeImmutableBucket(ctx.bf, meta.writeToByteArray());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t// Impossible, we're not inserting a manifest.\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"Got MetadataUnresolvedException in SingleFileInserter: \"+e.toString(), null);\n\t\t\t\t}\n\t\t\t\tClientPutState metaPutter = createInserter(parent, metadataBucket, (short) -1, block.desiredURI, ctx, mcb, true, (int)origSize, -1, getCHKOnly, true, false);\n\t\t\t\tmcb.addURIGenerator(metaPutter);\n\t\t\t\tmcb.add(dataPutter);\n\t\t\t\tcb.onTransition(this, mcb);\n\t\t\t\tLogger.minor(this, \"\"+mcb+\" : data \"+dataPutter+\" meta \"+metaPutter);\n\t\t\t\tmcb.arm();\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tif(metaPutter instanceof SingleBlockInserter)\n\t\t\t\t\t((SingleBlockInserter)metaPutter).encode();\n\t\t\t\tmetaPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Otherwise the file is too big to fit into one block\n\t\t// We therefore must make a splitfile\n\t\t// Job of SplitHandler: when the splitinserter has the metadata,\n\t\t// insert it. Then when the splitinserter has finished, and the\n\t\t// metadata insert has finished too, tell the master callback.\n\t\tif(reportMetadataOnly) {\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, cb, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tcb.onTransition(this, sfi);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t} else {\n\t\t\tSplitHandler sh = new SplitHandler();\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, sh, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tsh.sfi = sfi;\n\t\t\tcb.onTransition(this, sh);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t}\n\t}","id":80437,"modified_method":"private void tryCompress() throws InsertException {\n\t\t// First, determine how small it needs to be\n\t\tBucket origData = block.getData();\n\t\tBucket data = origData;\n\t\tint blockSize;\n\t\tint oneBlockCompressedSize;\n\t\tboolean dontCompress = ctx.dontCompress;\n\t\t\n\t\tlong origSize = data.size();\n\t\tString type = block.desiredURI.getKeyType();\n\t\tif(type.equals(\"SSK\") || type.equals(\"KSK\") || type.equals(\"USK\")) {\n\t\t\tblockSize = SSKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = SSKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else if(type.equals(\"CHK\")) {\n\t\t\tblockSize = CHKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else {\n\t\t\tthrow new InsertException(InsertException.INVALID_URI, \"Unknown key type: \"+type, null);\n\t\t}\n\t\t\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\n\t\tboolean tryCompress = (origSize > blockSize) && (!ctx.dontCompress) && (!dontCompress);\n\t\tif(tryCompress) {\n\t\t\t// Try to compress the data.\n\t\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\t\tint algos = Compressor.countCompressAlgorithms();\n\t\t\ttry {\n\t\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\t\tif(parent == cb)\n\t\t\t\t\t\tctx.eventProducer.produceEvent(new StartedCompressionEvent(i));\n\t\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\t\tBucket result;\n\t\t\t\t\tresult = comp.compress(origData, ctx.persistentBucketFactory, origData.size());\n\t\t\t\t\tif(result.size() < oneBlockCompressedSize) {\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.free();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// Impossible\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\tboolean freeData = false;\n\t\tif(bestCompressedData != null) {\n\t\t\tdata = bestCompressedData;\n\t\t\tfreeData = true;\n\t\t}\n\t\t\n\t\tif(parent == cb) {\n\t\t\tif(tryCompress)\n\t\t\t\tctx.eventProducer.produceEvent(new FinishedCompressionEvent(bestCodec == null ? -1 : bestCodec.codecNumberForMetadata(), origSize, data.size()));\n\t\t\tif(logMINOR) Logger.minor(this, \"Compressed \"+origSize+\" to \"+data.size()+\" on \"+this);\n\t\t}\n\t\t\n\t\t// Compressed data\n\t\t\n\t\t// Insert it...\n\t\tshort codecNumber = bestCodec == null ? -1 : bestCodec.codecNumberForMetadata();\n\t\tlong compressedDataSize = data.size();\n\t\tboolean fitsInOneBlockAsIs = bestCodec == null ? compressedDataSize < blockSize : compressedDataSize < oneBlockCompressedSize;\n\t\tboolean fitsInOneCHK = bestCodec == null ? compressedDataSize < CHKBlock.DATA_LENGTH : compressedDataSize < CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\n\t\tif((fitsInOneBlockAsIs || fitsInOneCHK) && block.getData().size() > Integer.MAX_VALUE)\n\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"2GB+ should not encode to one block!\", null);\n\n\t\tboolean noMetadata = ((block.clientMetadata == null) || block.clientMetadata.isTrivial()) && targetFilename == null;\n\t\tif(noMetadata && !insertAsArchiveManifest) {\n\t\t\tif(fitsInOneBlockAsIs) {\n\t\t\t\t// Just insert it\n\t\t\t\tClientPutState bi =\n\t\t\t\t\tcreateInserter(parent, data, codecNumber, block.desiredURI, ctx, cb, metadata, (int)block.getData().size(), -1, getCHKOnly, true, true);\n\t\t\t\tcb.onTransition(this, bi);\n\t\t\t\tbi.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fitsInOneCHK) {\n\t\t\t// Insert single block, then insert pointer to it\n\t\t\tif(reportMetadataOnly) {\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, cb, metadata, (int)origSize, -1, getCHKOnly, true, true, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tcb.onMetadata(meta, this);\n\t\t\t\tcb.onTransition(this, dataPutter);\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t} else {\n\t\t\t\tMultiPutCompletionCallback mcb = \n\t\t\t\t\tnew MultiPutCompletionCallback(cb, parent, token);\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, mcb, metadata, (int)origSize, -1, getCHKOnly, true, false, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tBucket metadataBucket;\n\t\t\t\ttry {\n\t\t\t\t\tmetadataBucket = BucketTools.makeImmutableBucket(ctx.bf, meta.writeToByteArray());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t// Impossible, we're not inserting a manifest.\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"Got MetadataUnresolvedException in SingleFileInserter: \"+e.toString(), null);\n\t\t\t\t}\n\t\t\t\tClientPutState metaPutter = createInserter(parent, metadataBucket, (short) -1, block.desiredURI, ctx, mcb, true, (int)origSize, -1, getCHKOnly, true, false);\n\t\t\t\tmcb.addURIGenerator(metaPutter);\n\t\t\t\tmcb.add(dataPutter);\n\t\t\t\tcb.onTransition(this, mcb);\n\t\t\t\tLogger.minor(this, \"\"+mcb+\" : data \"+dataPutter+\" meta \"+metaPutter);\n\t\t\t\tmcb.arm();\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tif(metaPutter instanceof SingleBlockInserter)\n\t\t\t\t\t((SingleBlockInserter)metaPutter).encode();\n\t\t\t\tmetaPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Otherwise the file is too big to fit into one block\n\t\t// We therefore must make a splitfile\n\t\t// Job of SplitHandler: when the splitinserter has the metadata,\n\t\t// insert it. Then when the splitinserter has finished, and the\n\t\t// metadata insert has finished too, tell the master callback.\n\t\tif(reportMetadataOnly) {\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, cb, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tcb.onTransition(this, sfi);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t} else {\n\t\t\tSplitHandler sh = new SplitHandler();\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, sh, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tsh.sfi = sfi;\n\t\t\tcb.onTransition(this, sh);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t}\n\t}","commit_id":"0f2047d5f60819eee7f2793e0492ba8b1df1e3d4","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Split the data into a series of read-only Bucket's.\n\t * @param origData The original data Bucket.\n\t * @param splitSize The number of bytes to put into each bucket.\n\t *\n\t * If the passed-in Bucket is a FileBucket, will be efficiently\n\t * split into ReadOnlyFileSliceBuckets, otherwise new buckets are created\n\t * and the data written to them.\n\t * \n\t * Note that this method will allocate a buffer of size splitSize.\n\t * @param freeData\n\t * @throws IOException If there is an error creating buckets, reading from\n\t * the provided bucket, or writing to created buckets.\n\t */\n\tpublic static Bucket[] split(Bucket origData, int splitSize, BucketFactory bf, boolean freeData) throws IOException {\n\t\tif(origData instanceof FileBucket) {\n\t\t\tif(freeData)\n\t\t\t\tLogger.error(BucketTools.class, \"Asked to free data when splitting a FileBucket ?!?!? Not freeing as this would clobber the split result...\");\n\t\t\treturn ((FileBucket)origData).split(splitSize);\n\t\t}\n\t\tif(origData instanceof BucketChainBucket) {\n\t\t\tBucketChainBucket data = (BucketChainBucket) origData;\n\t\t\tif(data.bucketSize == splitSize) {\n\t\t\t\tif(freeData)\n\t\t\t\t\tdata.clear();\n\t\t\t\treturn data.getBuckets();\n\t\t\t} else\n\t\t\t\tLogger.error(BucketTools.class, \"Incompatible split size splitting a BucketChainBucket: his split size is \" + data.bucketSize + \" but mine is \" + splitSize + \" - we will copy the data, but this suggests a bug\", new Exception(\"debug\"));\n\t\t}\n\t\tlong length = origData.size();\n\t\tif(length > ((long)Integer.MAX_VALUE) * splitSize)\n\t\t\tthrow new IllegalArgumentException(\"Way too big!: \"+length+\" for \"+splitSize);\n\t\tint bucketCount = (int) (length / splitSize);\n\t\tif(length % splitSize > 0) bucketCount++;\n\t\tif(Logger.shouldLog(Logger.MINOR, BucketTools.class))\n\t\t\tLogger.minor(BucketTools.class, \"Splitting bucket \"+origData+\" of size \"+length+\" into \"+bucketCount+\" buckets\");\n\t\tBucket[] buckets = new Bucket[bucketCount];\n\t\tInputStream is = origData.getInputStream();\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tdis = new DataInputStream(is);\n\t\t\tlong remainingLength = length;\n\t\t\tbyte[] buf = new byte[splitSize];\n\t\t\tfor(int i=0;i<bucketCount;i++) {\n\t\t\t\tint len = (int) Math.min(splitSize, remainingLength);\n\t\t\t\tBucket bucket = bf.makeBucket(len);\n\t\t\t\tbuckets[i] = bucket;\n\t\t\t\tdis.readFully(buf, 0, len);\n\t\t\t\tremainingLength -= len;\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\ttry {\n\t\t\t\t\tos.write(buf, 0, len);\n\t\t\t\t} finally {\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif(dis != null)\n\t\t\t\tdis.close();\n\t\t\telse\n\t\t\t\tis.close();\n\t\t}\n\t\tif(freeData)\n\t\t\torigData.free();\n\t\treturn buckets;\n\t}","id":80438,"modified_method":"/**\n\t * Split the data into a series of read-only Bucket's.\n\t * @param origData The original data Bucket.\n\t * @param splitSize The number of bytes to put into each bucket.\n\t *\n\t * If the passed-in Bucket is a FileBucket, will be efficiently\n\t * split into ReadOnlyFileSliceBuckets, otherwise new buckets are created\n\t * and the data written to them.\n\t * \n\t * Note that this method will allocate a buffer of size splitSize.\n\t * @param freeData \n\t * @throws IOException If there is an error creating buckets, reading from\n\t * the provided bucket, or writing to created buckets.\n\t */\n\tpublic static Bucket[] split(Bucket origData, int splitSize, BucketFactory bf, boolean freeData) throws IOException {\n\t\tif(origData instanceof FileBucket) {\n\t\t\tif(freeData) {\n\t\t\t\tLogger.error(BucketTools.class, \"Asked to free data when splitting a FileBucket ?!?!? Not freeing as this would clobber the split result...\");\n\t\t\t}\n\t\t\treturn ((FileBucket)origData).split(splitSize);\n\t\t}\n\t\tif(origData instanceof BucketChainBucket) {\n\t\t\tBucketChainBucket data = (BucketChainBucket)origData;\n\t\t\tif(data.bucketSize == splitSize) {\n\t\t\t\tBucket[] buckets = data.getBuckets();\n\t\t\t\tif(freeData)\n\t\t\t\t\tdata.clear();\n\t\t\t\treturn buckets;\n\t\t\t} else {\n\t\t\t\tLogger.error(BucketTools.class, \"Incompatible split size splitting a BucketChainBucket: his split size is \"+data.bucketSize+\" but mine is \"+splitSize+\" - we will copy the data, but this suggests a bug\", new Exception(\"debug\"));\n\t\t\t}\n\t\t}\n\t\tlong length = origData.size();\n\t\tif(length > ((long)Integer.MAX_VALUE) * splitSize)\n\t\t\tthrow new IllegalArgumentException(\"Way too big!: \"+length+\" for \"+splitSize);\n\t\tint bucketCount = (int) (length / splitSize);\n\t\tif(length % splitSize > 0) bucketCount++;\n\t\tif(Logger.shouldLog(Logger.MINOR, BucketTools.class))\n\t\t\tLogger.minor(BucketTools.class, \"Splitting bucket \"+origData+\" of size \"+length+\" into \"+bucketCount+\" buckets\");\n\t\tBucket[] buckets = new Bucket[bucketCount];\n\t\tInputStream is = origData.getInputStream();\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tdis = new DataInputStream(is);\n\t\t\tlong remainingLength = length;\n\t\t\tbyte[] buf = new byte[splitSize];\n\t\t\tfor(int i=0;i<bucketCount;i++) {\n\t\t\t\tint len = (int) Math.min(splitSize, remainingLength);\n\t\t\t\tBucket bucket = bf.makeBucket(len);\n\t\t\t\tbuckets[i] = bucket;\n\t\t\t\tdis.readFully(buf, 0, len);\n\t\t\t\tremainingLength -= len;\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\ttry {\n\t\t\t\t\tos.write(buf, 0, len);\n\t\t\t\t} finally {\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif(dis != null)\n\t\t\t\tdis.close();\n\t\t\telse\n\t\t\t\tis.close();\n\t\t}\n\t\tif(freeData)\n\t\t\torigData.free();\n\t\treturn buckets;\n\t}","commit_id":"6c27263582d29685eac4e9715450b4ea04610c3d","url":"https://github.com/freenet/fred"},{"original_method":"private void tryCompress() throws InsertException {\n\t\t// First, determine how small it needs to be\n\t\tBucket origData = block.getData();\n\t\tBucket data = origData;\n\t\tint blockSize;\n\t\tint oneBlockCompressedSize;\n\t\tboolean dontCompress = ctx.dontCompress;\n\t\t\n\t\tlong origSize = data.size();\n\t\tString type = block.desiredURI.getKeyType();\n\t\tif(type.equals(\"SSK\") || type.equals(\"KSK\") || type.equals(\"USK\")) {\n\t\t\tblockSize = SSKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = SSKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else if(type.equals(\"CHK\")) {\n\t\t\tblockSize = CHKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else {\n\t\t\tthrow new InsertException(InsertException.INVALID_URI, \"Unknown key type: \"+type, null);\n\t\t}\n\t\t\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\n\t\tboolean tryCompress = (origSize > blockSize) && (!ctx.dontCompress) && (!dontCompress);\n\t\tif(tryCompress) {\n\t\t\t// Try to compress the data.\n\t\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\t\tint algos = Compressor.countCompressAlgorithms();\n\t\t\ttry {\n\t\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\t\tif(parent == cb)\n\t\t\t\t\t\tctx.eventProducer.produceEvent(new StartedCompressionEvent(i));\n\t\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\t\tBucket result;\n\t\t\t\t\tresult = comp.compress(origData, new BucketChainBucketFactory(ctx.persistentBucketFactory, NodeCHK.BLOCK_SIZE), origData.size());\n\t\t\t\t\tif(result.size() < oneBlockCompressedSize) {\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.free();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// Impossible\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\tboolean freeData = false;\n\t\tif(bestCompressedData != null) {\n\t\t\tdata = bestCompressedData;\n\t\t\tfreeData = true;\n\t\t}\n\t\t\n\t\tif(parent == cb) {\n\t\t\tif(tryCompress)\n\t\t\t\tctx.eventProducer.produceEvent(new FinishedCompressionEvent(bestCodec == null ? -1 : bestCodec.codecNumberForMetadata(), origSize, data.size()));\n\t\t\tif(logMINOR) Logger.minor(this, \"Compressed \"+origSize+\" to \"+data.size()+\" on \"+this);\n\t\t}\n\t\t\n\t\t// Compressed data\n\t\t\n\t\t// Insert it...\n\t\tshort codecNumber = bestCodec == null ? -1 : bestCodec.codecNumberForMetadata();\n\t\tlong compressedDataSize = data.size();\n\t\tboolean fitsInOneBlockAsIs = bestCodec == null ? compressedDataSize < blockSize : compressedDataSize < oneBlockCompressedSize;\n\t\tboolean fitsInOneCHK = bestCodec == null ? compressedDataSize < CHKBlock.DATA_LENGTH : compressedDataSize < CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\n\t\tif((fitsInOneBlockAsIs || fitsInOneCHK) && block.getData().size() > Integer.MAX_VALUE)\n\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"2GB+ should not encode to one block!\", null);\n\n\t\tboolean noMetadata = ((block.clientMetadata == null) || block.clientMetadata.isTrivial()) && targetFilename == null;\n\t\tif(noMetadata && !insertAsArchiveManifest) {\n\t\t\tif(fitsInOneBlockAsIs) {\n\t\t\t\t// Just insert it\n\t\t\t\tClientPutState bi =\n\t\t\t\t\tcreateInserter(parent, data, codecNumber, block.desiredURI, ctx, cb, metadata, (int)block.getData().size(), -1, getCHKOnly, true, true);\n\t\t\t\tcb.onTransition(this, bi);\n\t\t\t\tbi.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fitsInOneCHK) {\n\t\t\t// Insert single block, then insert pointer to it\n\t\t\tif(reportMetadataOnly) {\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, cb, metadata, (int)origSize, -1, getCHKOnly, true, true, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tcb.onMetadata(meta, this);\n\t\t\t\tcb.onTransition(this, dataPutter);\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t} else {\n\t\t\t\tMultiPutCompletionCallback mcb = \n\t\t\t\t\tnew MultiPutCompletionCallback(cb, parent, token);\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, mcb, metadata, (int)origSize, -1, getCHKOnly, true, false, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tBucket metadataBucket;\n\t\t\t\ttry {\n\t\t\t\t\tmetadataBucket = BucketTools.makeImmutableBucket(ctx.bf, meta.writeToByteArray());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t// Impossible, we're not inserting a manifest.\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"Got MetadataUnresolvedException in SingleFileInserter: \"+e.toString(), null);\n\t\t\t\t}\n\t\t\t\tClientPutState metaPutter = createInserter(parent, metadataBucket, (short) -1, block.desiredURI, ctx, mcb, true, (int)origSize, -1, getCHKOnly, true, false);\n\t\t\t\tmcb.addURIGenerator(metaPutter);\n\t\t\t\tmcb.add(dataPutter);\n\t\t\t\tcb.onTransition(this, mcb);\n\t\t\t\tLogger.minor(this, \"\"+mcb+\" : data \"+dataPutter+\" meta \"+metaPutter);\n\t\t\t\tmcb.arm();\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tif(metaPutter instanceof SingleBlockInserter)\n\t\t\t\t\t((SingleBlockInserter)metaPutter).encode();\n\t\t\t\tmetaPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Otherwise the file is too big to fit into one block\n\t\t// We therefore must make a splitfile\n\t\t// Job of SplitHandler: when the splitinserter has the metadata,\n\t\t// insert it. Then when the splitinserter has finished, and the\n\t\t// metadata insert has finished too, tell the master callback.\n\t\tif(reportMetadataOnly) {\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, cb, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tcb.onTransition(this, sfi);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t} else {\n\t\t\tSplitHandler sh = new SplitHandler();\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, sh, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tsh.sfi = sfi;\n\t\t\tcb.onTransition(this, sh);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t}\n\t}","id":80439,"modified_method":"private void tryCompress() throws InsertException {\n\t\t// First, determine how small it needs to be\n\t\tBucket origData = block.getData();\n\t\tBucket data = origData;\n\t\tint blockSize;\n\t\tint oneBlockCompressedSize;\n\t\tboolean dontCompress = ctx.dontCompress;\n\t\t\n\t\tlong origSize = data.size();\n\t\tString type = block.desiredURI.getKeyType();\n\t\tif(type.equals(\"SSK\") || type.equals(\"KSK\") || type.equals(\"USK\")) {\n\t\t\tblockSize = SSKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = SSKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else if(type.equals(\"CHK\")) {\n\t\t\tblockSize = CHKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else {\n\t\t\tthrow new InsertException(InsertException.INVALID_URI, \"Unknown key type: \"+type, null);\n\t\t}\n\t\t\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\n\t\tboolean tryCompress = (origSize > blockSize) && (!ctx.dontCompress) && (!dontCompress);\n\t\tif(tryCompress) {\n\t\t\t// Try to compress the data.\n\t\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\t\tint algos = Compressor.countCompressAlgorithms();\n\t\t\ttry {\n\t\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\t\tif(parent == cb)\n\t\t\t\t\t\tctx.eventProducer.produceEvent(new StartedCompressionEvent(i));\n\t\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\t\tBucket result;\n\t\t\t\t\tresult = comp.compress(origData, ctx.persistentBucketFactory, origData.size());\n\t\t\t\t\tif(result.size() < oneBlockCompressedSize) {\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.free();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// Impossible\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\tboolean freeData = false;\n\t\tif(bestCompressedData != null) {\n\t\t\tdata = bestCompressedData;\n\t\t\tfreeData = true;\n\t\t}\n\t\t\n\t\tif(parent == cb) {\n\t\t\tif(tryCompress)\n\t\t\t\tctx.eventProducer.produceEvent(new FinishedCompressionEvent(bestCodec == null ? -1 : bestCodec.codecNumberForMetadata(), origSize, data.size()));\n\t\t\tif(logMINOR) Logger.minor(this, \"Compressed \"+origSize+\" to \"+data.size()+\" on \"+this);\n\t\t}\n\t\t\n\t\t// Compressed data\n\t\t\n\t\t// Insert it...\n\t\tshort codecNumber = bestCodec == null ? -1 : bestCodec.codecNumberForMetadata();\n\t\tlong compressedDataSize = data.size();\n\t\tboolean fitsInOneBlockAsIs = bestCodec == null ? compressedDataSize < blockSize : compressedDataSize < oneBlockCompressedSize;\n\t\tboolean fitsInOneCHK = bestCodec == null ? compressedDataSize < CHKBlock.DATA_LENGTH : compressedDataSize < CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\n\t\tif((fitsInOneBlockAsIs || fitsInOneCHK) && block.getData().size() > Integer.MAX_VALUE)\n\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"2GB+ should not encode to one block!\", null);\n\n\t\tboolean noMetadata = ((block.clientMetadata == null) || block.clientMetadata.isTrivial()) && targetFilename == null;\n\t\tif(noMetadata && !insertAsArchiveManifest) {\n\t\t\tif(fitsInOneBlockAsIs) {\n\t\t\t\t// Just insert it\n\t\t\t\tClientPutState bi =\n\t\t\t\t\tcreateInserter(parent, data, codecNumber, block.desiredURI, ctx, cb, metadata, (int)block.getData().size(), -1, getCHKOnly, true, true);\n\t\t\t\tcb.onTransition(this, bi);\n\t\t\t\tbi.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fitsInOneCHK) {\n\t\t\t// Insert single block, then insert pointer to it\n\t\t\tif(reportMetadataOnly) {\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, cb, metadata, (int)origSize, -1, getCHKOnly, true, true, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tcb.onMetadata(meta, this);\n\t\t\t\tcb.onTransition(this, dataPutter);\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t} else {\n\t\t\t\tMultiPutCompletionCallback mcb = \n\t\t\t\t\tnew MultiPutCompletionCallback(cb, parent, token);\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, mcb, metadata, (int)origSize, -1, getCHKOnly, true, false, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tBucket metadataBucket;\n\t\t\t\ttry {\n\t\t\t\t\tmetadataBucket = BucketTools.makeImmutableBucket(ctx.bf, meta.writeToByteArray());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.BUCKET_ERROR, e, null);\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t// Impossible, we're not inserting a manifest.\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InsertException(InsertException.INTERNAL_ERROR, \"Got MetadataUnresolvedException in SingleFileInserter: \"+e.toString(), null);\n\t\t\t\t}\n\t\t\t\tClientPutState metaPutter = createInserter(parent, metadataBucket, (short) -1, block.desiredURI, ctx, mcb, true, (int)origSize, -1, getCHKOnly, true, false);\n\t\t\t\tmcb.addURIGenerator(metaPutter);\n\t\t\t\tmcb.add(dataPutter);\n\t\t\t\tcb.onTransition(this, mcb);\n\t\t\t\tLogger.minor(this, \"\"+mcb+\" : data \"+dataPutter+\" meta \"+metaPutter);\n\t\t\t\tmcb.arm();\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tif(metaPutter instanceof SingleBlockInserter)\n\t\t\t\t\t((SingleBlockInserter)metaPutter).encode();\n\t\t\t\tmetaPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Otherwise the file is too big to fit into one block\n\t\t// We therefore must make a splitfile\n\t\t// Job of SplitHandler: when the splitinserter has the metadata,\n\t\t// insert it. Then when the splitinserter has finished, and the\n\t\t// metadata insert has finished too, tell the master callback.\n\t\tif(reportMetadataOnly) {\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, cb, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tcb.onTransition(this, sfi);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t} else {\n\t\t\tSplitHandler sh = new SplitHandler();\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, sh, data, bestCodec, origSize, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, freeData);\n\t\t\tsh.sfi = sfi;\n\t\t\tcb.onTransition(this, sh);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t}\n\t}","commit_id":"6c27263582d29685eac4e9715450b4ea04610c3d","url":"https://github.com/freenet/fred"},{"original_method":"public OutputStream getOutputStream() throws IOException {\n\t\tBucket[] list;\n\t\tsynchronized(this) {\n\t\t\tif(readOnly) throw new IOException(\"Read-only\");\n\t\t\tif(freed) throw new IOException(\"Freed\");\n\t\t\tsize = 0;\n\t\t\tlist = getBuckets();\n\t\t\tbuckets.clear();\n\t\t}\n\t\tfor(int i=0;i<list.length;i++) {\n\t\t\tlist[i].free();\n\t\t}\n\t\treturn new OutputStream() {\n\n\t\t\tprivate int bucketNo = 0;\n\t\t\tprivate OutputStream curBucketStream = makeBucketOutputStream(0);\n\t\t\tprivate long bucketLength = 0;\n\t\t\t\n\t\t\tpublic void write(int c) throws IOException {\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tif(freed) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Freed\");\n\t\t\t\t\t}\n\t\t\t\t\tif(readOnly) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Read-only\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bucketLength == bucketSize) {\n\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\tcurBucketStream = makeBucketOutputStream(bucketNo++);\n\t\t\t\t\tbucketLength = 0;\n\t\t\t\t}\n\t\t\t\tcurBucketStream.write(c);\n\t\t\t\tbucketLength++;\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic void write(byte[] buf) throws IOException {\n\t\t\t\twrite(buf, 0, buf.length);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void write(byte[] buf, int offset, int length) throws IOException {\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tif(freed) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Freed\");\n\t\t\t\t\t}\n\t\t\t\t\tif(readOnly) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Read-only\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(length <= 0) return;\n\t\t\t\tif(bucketLength == bucketSize) {\n\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\tcurBucketStream = makeBucketOutputStream(bucketNo++);\n\t\t\t\t\tbucketLength = 0;\n\t\t\t\t}\n\t\t\t\tif(bucketLength + length > bucketSize) {\n\t\t\t\t\tint split = (int) (bucketSize - bucketLength);\n\t\t\t\t\twrite(buf, offset, split);\n\t\t\t\t\twrite(buf, offset + split, length - split);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurBucketStream.write(buf, offset, length);\n\t\t\t\tbucketLength += length;\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tsize += length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic void close() throws IOException {\n\t\t\t\tif(curBucketStream != null)\n\t\t\t\t\tcurBucketStream.close();\n\t\t\t}\n\t\t\t\n\t\t};\n\t}","id":80440,"modified_method":"public OutputStream getOutputStream() throws IOException {\n\t\tBucket[] list;\n\t\tsynchronized(this) {\n\t\t\tif(readOnly) throw new IOException(\"Read-only\");\n\t\t\tif(freed) throw new IOException(\"Freed\");\n\t\t\tsize = 0;\n\t\t\tlist = getBuckets();\n\t\t\tbuckets.clear();\n\t\t}\n\t\tfor(int i=0;i<list.length;i++) {\n\t\t\tlist[i].free();\n\t\t}\n\t\treturn new OutputStream() {\n\n\t\t\tprivate int bucketNo = 0;\n\t\t\tprivate OutputStream curBucketStream = makeBucketOutputStream(0);\n\t\t\tprivate long bucketLength = 0;\n\t\t\t\n\t\t\tpublic void write(int c) throws IOException {\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tif(freed) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Freed\");\n\t\t\t\t\t}\n\t\t\t\t\tif(readOnly) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Read-only\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bucketLength == bucketSize) {\n\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\tcurBucketStream = makeBucketOutputStream(++bucketNo);\n\t\t\t\t\tbucketLength = 0;\n\t\t\t\t}\n\t\t\t\tcurBucketStream.write(c);\n\t\t\t\tbucketLength++;\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic void write(byte[] buf) throws IOException {\n\t\t\t\twrite(buf, 0, buf.length);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void write(byte[] buf, int offset, int length) throws IOException {\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tif(freed) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Freed\");\n\t\t\t\t\t}\n\t\t\t\t\tif(readOnly) {\n\t\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\t\tcurBucketStream = null;\n\t\t\t\t\t\tthrow new IOException(\"Read-only\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(length <= 0) return;\n\t\t\t\tif(bucketLength == bucketSize) {\n\t\t\t\t\tcurBucketStream.close();\n\t\t\t\t\tcurBucketStream = makeBucketOutputStream(++bucketNo);\n\t\t\t\t\tbucketLength = 0;\n\t\t\t\t}\n\t\t\t\tif(bucketLength + length > bucketSize) {\n\t\t\t\t\tint split = (int) (bucketSize - bucketLength);\n\t\t\t\t\twrite(buf, offset, split);\n\t\t\t\t\twrite(buf, offset + split, length - split);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurBucketStream.write(buf, offset, length);\n\t\t\t\tbucketLength += length;\n\t\t\t\tsynchronized(BucketChainBucket.this) {\n\t\t\t\t\tsize += length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic void close() throws IOException {\n\t\t\t\tif(curBucketStream != null)\n\t\t\t\t\tcurBucketStream.close();\n\t\t\t}\n\t\t\t\n\t\t};\n\t}","commit_id":"250ca2fb313fbe4072fd847af69f067ef11fe845","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Split the data into a series of read-only Bucket's.\n\t * @param origData The original data Bucket.\n\t * @param splitSize The number of bytes to put into each bucket.\n\t *\n\t * If the passed-in Bucket is a FileBucket, will be efficiently\n\t * split into ReadOnlyFileSliceBuckets, otherwise new buckets are created\n\t * and the data written to them.\n\t * \n\t * Note that this method will allocate a buffer of size splitSize.\n\t * @param freeData \n\t * @throws IOException If there is an error creating buckets, reading from\n\t * the provided bucket, or writing to created buckets.\n\t */\n\tpublic static Bucket[] split(Bucket origData, int splitSize, BucketFactory bf, boolean freeData) throws IOException {\n\t\tif(origData instanceof FileBucket) {\n\t\t\tif(freeData) {\n\t\t\t\tLogger.error(BucketTools.class, \"Asked to free data when splitting a FileBucket ?!?!? Not freeing as this would clobber the split result...\");\n\t\t\t}\n\t\t\treturn ((FileBucket)origData).split(splitSize);\n\t\t}\n\t\tif(origData instanceof BucketChainBucket) {\n\t\t\tBucketChainBucket data = (BucketChainBucket)origData;\n\t\t\tif(data.bucketSize == splitSize) {\n\t\t\t\tif(freeData)\n\t\t\t\t\tdata.clear();\n\t\t\t\treturn data.getBuckets();\n\t\t\t} else {\n\t\t\t\tLogger.error(BucketTools.class, \"Incompatible split size splitting a BucketChainBucket: his split size is \"+data.bucketSize+\" but mine is \"+splitSize+\" - we will copy the data, but this suggests a bug\", new Exception(\"debug\"));\n\t\t\t}\n\t\t}\n\t\tlong length = origData.size();\n\t\tif(length > ((long)Integer.MAX_VALUE) * splitSize)\n\t\t\tthrow new IllegalArgumentException(\"Way too big!: \"+length+\" for \"+splitSize);\n\t\tint bucketCount = (int) (length / splitSize);\n\t\tif(length % splitSize > 0) bucketCount++;\n\t\tif(Logger.shouldLog(Logger.MINOR, BucketTools.class))\n\t\t\tLogger.minor(BucketTools.class, \"Splitting bucket \"+origData+\" of size \"+length+\" into \"+bucketCount+\" buckets\");\n\t\tBucket[] buckets = new Bucket[bucketCount];\n\t\tInputStream is = origData.getInputStream();\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tdis = new DataInputStream(is);\n\t\t\tlong remainingLength = length;\n\t\t\tbyte[] buf = new byte[splitSize];\n\t\t\tfor(int i=0;i<bucketCount;i++) {\n\t\t\t\tint len = (int) Math.min(splitSize, remainingLength);\n\t\t\t\tBucket bucket = bf.makeBucket(len);\n\t\t\t\tbuckets[i] = bucket;\n\t\t\t\tdis.readFully(buf, 0, len);\n\t\t\t\tremainingLength -= len;\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\ttry {\n\t\t\t\t\tos.write(buf, 0, len);\n\t\t\t\t} finally {\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif(dis != null)\n\t\t\t\tdis.close();\n\t\t\telse\n\t\t\t\tis.close();\n\t\t}\n\t\tif(freeData)\n\t\t\torigData.free();\n\t\treturn buckets;\n\t}","id":80441,"modified_method":"/**\n\t * Split the data into a series of read-only Bucket's.\n\t * @param origData The original data Bucket.\n\t * @param splitSize The number of bytes to put into each bucket.\n\t *\n\t * If the passed-in Bucket is a FileBucket, will be efficiently\n\t * split into ReadOnlyFileSliceBuckets, otherwise new buckets are created\n\t * and the data written to them.\n\t * \n\t * Note that this method will allocate a buffer of size splitSize.\n\t * @param freeData \n\t * @throws IOException If there is an error creating buckets, reading from\n\t * the provided bucket, or writing to created buckets.\n\t */\n\tpublic static Bucket[] split(Bucket origData, int splitSize, BucketFactory bf, boolean freeData) throws IOException {\n\t\tif(origData instanceof FileBucket) {\n\t\t\tif(freeData) {\n\t\t\t\tLogger.error(BucketTools.class, \"Asked to free data when splitting a FileBucket ?!?!? Not freeing as this would clobber the split result...\");\n\t\t\t}\n\t\t\treturn ((FileBucket)origData).split(splitSize);\n\t\t}\n\t\tif(origData instanceof BucketChainBucket) {\n\t\t\tBucketChainBucket data = (BucketChainBucket)origData;\n\t\t\tif(data.bucketSize == splitSize) {\n\t\t\t\tBucket[] buckets = data.getBuckets();\n\t\t\t\tif(freeData)\n\t\t\t\t\tdata.clear();\n\t\t\t\treturn buckets;\n\t\t\t} else {\n\t\t\t\tLogger.error(BucketTools.class, \"Incompatible split size splitting a BucketChainBucket: his split size is \"+data.bucketSize+\" but mine is \"+splitSize+\" - we will copy the data, but this suggests a bug\", new Exception(\"debug\"));\n\t\t\t}\n\t\t}\n\t\tlong length = origData.size();\n\t\tif(length > ((long)Integer.MAX_VALUE) * splitSize)\n\t\t\tthrow new IllegalArgumentException(\"Way too big!: \"+length+\" for \"+splitSize);\n\t\tint bucketCount = (int) (length / splitSize);\n\t\tif(length % splitSize > 0) bucketCount++;\n\t\tif(Logger.shouldLog(Logger.MINOR, BucketTools.class))\n\t\t\tLogger.minor(BucketTools.class, \"Splitting bucket \"+origData+\" of size \"+length+\" into \"+bucketCount+\" buckets\");\n\t\tBucket[] buckets = new Bucket[bucketCount];\n\t\tInputStream is = origData.getInputStream();\n\t\tDataInputStream dis = null;\n\t\ttry {\n\t\t\tdis = new DataInputStream(is);\n\t\t\tlong remainingLength = length;\n\t\t\tbyte[] buf = new byte[splitSize];\n\t\t\tfor(int i=0;i<bucketCount;i++) {\n\t\t\t\tint len = (int) Math.min(splitSize, remainingLength);\n\t\t\t\tBucket bucket = bf.makeBucket(len);\n\t\t\t\tbuckets[i] = bucket;\n\t\t\t\tdis.readFully(buf, 0, len);\n\t\t\t\tremainingLength -= len;\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\ttry {\n\t\t\t\t\tos.write(buf, 0, len);\n\t\t\t\t} finally {\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif(dis != null)\n\t\t\t\tdis.close();\n\t\t\telse\n\t\t\t\tis.close();\n\t\t}\n\t\tif(freeData)\n\t\t\torigData.free();\n\t\treturn buckets;\n\t}","commit_id":"250ca2fb313fbe4072fd847af69f067ef11fe845","url":"https://github.com/freenet/fred"},{"original_method":"@Nullable\n  public A visitLambdaExpressionType(PsiLambdaExpressionType lambdaExpressionType) {\n    final PsiLambdaExpression lambdaExpression = lambdaExpressionType.getExpression();\n    return visitType(lambdaExpression.getFunctionalInterfaceType());\n  }","id":80442,"modified_method":"@Nullable\n  public A visitLambdaExpressionType(PsiLambdaExpressionType lambdaExpressionType) {\n    final PsiLambdaExpression lambdaExpression = lambdaExpressionType.getExpression();\n    final PsiType interfaceType = lambdaExpression.getFunctionalInterfaceType();\n    if (interfaceType != null) return interfaceType.accept(this);\n    return visitType(interfaceType);\n  }","commit_id":"30dcf05e5908d391e33d5873ee7eb798a551eddd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final PsiElement element = descriptor.getPsiElement();\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(element)) return;\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n      if (lambdaExpression == null) return;\n      PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n      if (functionalInterfaceType == null || !functionalInterfaceType.isValid()) return;\n      final String methodRefText = createMethodReferenceText(element, functionalInterfaceType,\n                                                             lambdaExpression.getParameterList().getParameters());\n\n      if (methodRefText != null) {\n        final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n        final PsiExpression psiExpression = factory.createExpressionFromText(methodRefText, lambdaExpression);\n        final SmartTypePointer typePointer = SmartTypePointerManager.getInstance(project).createSmartTypePointer(functionalInterfaceType);\n        PsiElement replace = lambdaExpression.replace(psiExpression);\n        if (((PsiMethodReferenceExpression)replace).getFunctionalInterfaceType() == null) { //ambiguity\n          final PsiTypeCastExpression cast = (PsiTypeCastExpression)factory.createExpressionFromText(\"(A)a\", replace);\n          functionalInterfaceType = typePointer.getType();\n          if (functionalInterfaceType != null) {\n            cast.getCastType().replace(factory.createTypeElement(functionalInterfaceType));\n            cast.getOperand().replace(replace);\n            replace = replace.replace(cast);\n          }\n        }\n        JavaCodeStyleManager.getInstance(project).shortenClassReferences(replace);\n      }\n    }","id":80443,"modified_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final PsiElement element = descriptor.getPsiElement();\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(element)) return;\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n      if (lambdaExpression == null) return;\n      PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n      if (functionalInterfaceType == null || !functionalInterfaceType.isValid()) return;\n      String functionalTypeText = functionalInterfaceType.getCanonicalText();\n      final String methodRefText = createMethodReferenceText(element, functionalInterfaceType,\n                                                             lambdaExpression.getParameterList().getParameters());\n\n      if (methodRefText != null) {\n        final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n        final PsiExpression psiExpression = factory.createExpressionFromText(methodRefText, lambdaExpression);\n        final SmartTypePointer typePointer = SmartTypePointerManager.getInstance(project).createSmartTypePointer(functionalInterfaceType);\n        PsiElement replace = lambdaExpression.replace(psiExpression);\n        final PsiType functionalTypeAfterReplacement = ((PsiMethodReferenceExpression)replace).getFunctionalInterfaceType();\n        functionalInterfaceType = typePointer.getType();\n        if (functionalTypeAfterReplacement == null || functionalInterfaceType != null && !functionalTypeAfterReplacement.equals(functionalInterfaceType)) { //ambiguity\n          final PsiTypeCastExpression cast = (PsiTypeCastExpression)factory.createExpressionFromText(\"(A)a\", replace);\n          cast.getCastType().replace(factory.createTypeElement(functionalInterfaceType));\n          cast.getOperand().replace(replace);\n          replace = replace.replace(cast);\n        }\n        JavaCodeStyleManager.getInstance(project).shortenClassReferences(replace);\n      }\n    }","commit_id":"bcbc25e1dee129a9a3044b0f81fbf127c70a5ec6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitReturnStatement(PsiReturnStatement statement) {\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(statement, PsiLambdaExpression.class);\n      final PsiMethod interfaceMethod = lambdaExpression != null ? LambdaUtil.getFunctionalInterfaceMethod(lambdaExpression.getFunctionalInterfaceType()) : null;\n      final PsiMethod scopeMethod = interfaceMethod != null ? interfaceMethod : PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n      if (scopeMethod != null) {\n        PsiType type = scopeMethod.getReturnType();\n        if (type != null) {\n          ExpectedTypeInfoImpl info = createInfoImpl(type, ExpectedTypeInfo.TYPE_OR_SUBTYPE, type,\n                                                     TailType.SEMICOLON);\n          if (PropertyUtil.isSimplePropertyAccessor(scopeMethod)) {\n            info.expectedName = new NullableComputable<String>() {\n              @Override\n              public String compute() {\n                return PropertyUtil.getPropertyName(scopeMethod);\n              }\n            };\n          }\n\n          myResult = new ExpectedTypeInfo[]{info};\n        }\n        else {\n          myResult = ExpectedTypeInfo.EMPTY_ARRAY;\n        }\n      }\n    }","id":80444,"modified_method":"@Override public void visitReturnStatement(PsiReturnStatement statement) {\n      final PsiMethod method;\n      final PsiType type;\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(statement, PsiLambdaExpression.class);\n      if (lambdaExpression != null) {\n        final PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n        method = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n        type = LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType);\n      }\n      else {\n        method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n        type = method != null ? method.getReturnType() : null;\n      }\n\n      if (method != null) {\n        visitMethodReturnType(method, type);\n      }\n    }","commit_id":"659d9f325164c0db88cbf2b4f8f6ccfe69f00e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JmsEndpoint(String endpointUri, JmsBinding binding, JmsConfiguration configuration, String destination, boolean pubSubDomain) {\n        super(endpointUri);\n        this.binding = binding;\n        this.configuration = configuration;\n        this.destination = destination;\n        this.pubSubDomain = pubSubDomain;\n    }","id":80445,"modified_method":"public JmsEndpoint(String endpointUri, JmsBinding binding, JmsConfiguration configuration, String destinationName, boolean pubSubDomain) {\n        super(endpointUri);\n        this.binding = binding;\n        this.configuration = configuration;\n        this.destinationName = destinationName;\n        this.pubSubDomain = pubSubDomain;\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"public JmsEndpoint(String uri, JmsComponent component, String destination, boolean pubSubDomain, JmsConfiguration configuration) {\n        super(uri, component);\n        this.configuration = configuration;\n        this.destination = destination;\n        this.pubSubDomain = pubSubDomain;\n    }","id":80446,"modified_method":"public JmsEndpoint(String uri, JmsComponent component, String destinationName, boolean pubSubDomain, JmsConfiguration configuration) {\n        super(uri, component);\n        this.configuration = configuration;\n        this.destinationName = destinationName;\n        this.pubSubDomain = pubSubDomain;\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Factory method for creating a new template for InOnly message exchanges\n     */\n    public JmsOperations createInOnlyTemplate() {\n        return configuration.createInOnlyTemplate(this, pubSubDomain, destination);\n    }","id":80447,"modified_method":"/**\n     * Factory method for creating a new template for InOnly message exchanges\n     */\n    public JmsOperations createInOnlyTemplate() {\n        return configuration.createInOnlyTemplate(this, pubSubDomain, destinationName);\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"public String getDestination() {\n        return destination;\n    }","id":80448,"modified_method":"public Destination getDestination() {\n        return destination;\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a consumer using the given processor and listener container\n     *\n     * @param processor         the processor to use to process the messages\n     * @param listenerContainer the listener container\n     * @return a newly created consumer\n     * @throws Exception if the consumer cannot be created\n     */\n    public JmsConsumer createConsumer(Processor processor, AbstractMessageListenerContainer listenerContainer) throws Exception {\n        listenerContainer.setDestinationName(destination);\n        listenerContainer.setPubSubDomain(pubSubDomain);\n        return new JmsConsumer(this, processor, listenerContainer);\n    }","id":80449,"modified_method":"/**\n     * Creates a consumer using the given processor and listener container\n     *\n     * @param processor         the processor to use to process the messages\n     * @param listenerContainer the listener container\n     * @return a newly created consumer\n     * @throws Exception if the consumer cannot be created\n     */\n    public JmsConsumer createConsumer(Processor processor, AbstractMessageListenerContainer listenerContainer) throws Exception {\n        if (destinationName != null) {\n            listenerContainer.setDestinationName(destinationName);\n        } else if (destination != null) {\n            listenerContainer.setDestination(destination);\n        } else {\n            DestinationResolver resolver = getDestinationResolver();\n            if (resolver != null) {\n                listenerContainer.setDestinationResolver(resolver);\n            } else {\n                throw new IllegalArgumentException(\"Neither destination, destinationName or destinationResolver are specified on this endpoint!\");\n            }\n        }\n        listenerContainer.setPubSubDomain(pubSubDomain);\n        return new JmsConsumer(this, processor, listenerContainer);\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"public JmsEndpoint(String endpointUri, String destination, boolean pubSubDomain) {\n        this(endpointUri, new JmsBinding(), new JmsConfiguration(), destination, pubSubDomain);\n    }","id":80450,"modified_method":"public JmsEndpoint(String endpointUri, String destinationName, boolean pubSubDomain) {\n        this(endpointUri, new JmsBinding(), new JmsConfiguration(), destinationName, pubSubDomain);\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a pub-sub endpoint with the given destination\n     */\n    public JmsEndpoint(String endpointUri, String destination) {\n        this(endpointUri, destination, true);\n    }","id":80451,"modified_method":"/**\n     * Creates a pub-sub endpoint with the given destination\n     */\n    public JmsEndpoint(String endpointUri, String destinationName) {\n        this(endpointUri, destinationName, true);\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Factory method for creating a new template for InOut message exchanges\n     */\n    public JmsOperations createInOutTemplate() {\n        return configuration.createInOutTemplate(this, pubSubDomain, destination, configuration.getRequestTimeout());\n    }","id":80452,"modified_method":"/**\n     * Factory method for creating a new template for InOut message exchanges\n     */\n    public JmsOperations createInOutTemplate() {\n        return configuration.createInOutTemplate(this, pubSubDomain, destinationName, configuration.getRequestTimeout());\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a producer using the given template for InOnly message exchanges\n     */\n    public JmsProducer createProducer(JmsOperations template) throws Exception {\n        JmsProducer answer = createProducer();\n        if (template instanceof JmsTemplate) {\n            JmsTemplate jmsTemplate = (JmsTemplate) template;\n            jmsTemplate.setPubSubDomain(pubSubDomain);\n            jmsTemplate.setDefaultDestinationName(destination);\n        }\n        answer.setInOnlyTemplate(template);\n        return answer;\n    }","id":80453,"modified_method":"/**\n     * Creates a producer using the given template for InOnly message exchanges\n     */\n    public JmsProducer createProducer(JmsOperations template) throws Exception {\n        JmsProducer answer = createProducer();\n        if (template instanceof JmsTemplate) {\n            JmsTemplate jmsTemplate = (JmsTemplate) template;\n            jmsTemplate.setPubSubDomain(pubSubDomain);\n            if (destinationName != null) {\n                jmsTemplate.setDefaultDestinationName(destinationName);\n            }\n            else if (destination != null) {\n                jmsTemplate.setDefaultDestination(destination);\n            }\n            /*\n            else {\n                DestinationResolver resolver = getDestinationResolver();\n                if (resolver != null) {\n                    jmsTemplate.setDestinationResolver(resolver);\n                }\n                else {\n                    throw new IllegalArgumentException(\"Neither destination, destinationName or destinationResolver are specified on this endpoint!\");\n                }\n            }\n            */\n        }\n        answer.setInOnlyTemplate(template);\n        return answer;\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"public void process(final Exchange exchange) {\n        final org.apache.camel.Message in = exchange.getIn();\n\n        if (exchange.getPattern().isOutCapable()) {\n\n            testAndSetRequestor();\n\n            // note due to JMS transaction semantics we cannot use a single transaction\n            // for sending the request and receiving the response\n            final Destination replyTo = requestor.getReplyTo();\n\n            if (replyTo == null) {\n                throw new RuntimeExchangeException(\"Failed to resolve replyTo destination\", exchange);\n            }\n\n            final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();\n            String correlationId = in.getHeader(\"JMSCorrelationID\", String.class);\n\n            if (correlationId == null && !msgIdAsCorrId) {\n                in.setHeader(\"JMSCorrelationID\", getUuidGenerator().generateId());\n            }\n\n            final ValueHolder<FutureTask> futureHolder = new ValueHolder<FutureTask>();\n            final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap.createDeferredMessageSentCallback() : null;\n\n            final CamelJmsTemplate template = (CamelJmsTemplate)getInOutTemplate();\n            template.send(endpoint.getDestination(), new MessageCreator() {\n                public Message createMessage(Session session) throws JMSException {\n                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);\n                    message.setJMSReplyTo(replyTo);\n                    requestor.setReplyToSelectorHeader(in, message);\n\n                    FutureTask future = null;\n                    future = (!msgIdAsCorrId)\n                        ? requestor.getReceiveFuture(message.getJMSCorrelationID(), endpoint.getConfiguration().getRequestTimeout())\n                            : requestor.getReceiveFuture(callback);\n\n                    futureHolder.set(future);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(endpoint + \" sending JMS message: \" + message);\n                    }\n                    return message;\n                }\n            }, callback);\n\n            setMessageId(exchange);\n\n            // lets wait and return the response\n            long requestTimeout = endpoint.getConfiguration().getRequestTimeout();\n            try {\n                Message message = null;\n                try {\n                    if (requestTimeout < 0) {\n                        message = (Message)futureHolder.get().get();\n                    } else {\n                        message = (Message)futureHolder.get().get(requestTimeout, TimeUnit.MILLISECONDS);\n                    }\n                } catch (InterruptedException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Future interupted: \" + e, e);\n                    }\n                } catch (TimeoutException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Future timed out: \" + e, e);\n                    }\n                }\n                if (message != null) {\n                    exchange.setOut(new JmsMessage(message, endpoint.getBinding()));\n                    if (correlationId != null) {\n                        message.setJMSCorrelationID(correlationId);\n                        exchange.getOut(false).setHeader(\"JMSCorrelationID\", correlationId);\n                    }\n                } else {\n                    // lets set a timed out exception\n                    exchange.setException(new ExchangeTimedOutException(exchange, requestTimeout));\n                }\n            } catch (Exception e) {\n                exchange.setException(e);\n            }\n        } else {\n            getInOnlyTemplate().send(endpoint.getDestination(), new MessageCreator() {\n                public Message createMessage(Session session) throws JMSException {\n                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(endpoint + \" sending JMS message: \" + message);\n                    }\n                    return message;\n                }\n            });\n\n            setMessageId(exchange);\n        }\n    }","id":80454,"modified_method":"public void process(final Exchange exchange) {\n        final org.apache.camel.Message in = exchange.getIn();\n\n        String destinationName = endpoint.getDestinationName();\n        Destination destination = endpoint.getDestination();\n        if (exchange.getPattern().isOutCapable()) {\n\n            testAndSetRequestor();\n\n            // note due to JMS transaction semantics we cannot use a single transaction\n            // for sending the request and receiving the response\n            final Destination replyTo = requestor.getReplyTo();\n\n            if (replyTo == null) {\n                throw new RuntimeExchangeException(\"Failed to resolve replyTo destination\", exchange);\n            }\n\n            final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();\n            String correlationId = in.getHeader(\"JMSCorrelationID\", String.class);\n\n            if (correlationId == null && !msgIdAsCorrId) {\n                in.setHeader(\"JMSCorrelationID\", getUuidGenerator().generateId());\n            }\n\n            final ValueHolder<FutureTask> futureHolder = new ValueHolder<FutureTask>();\n            final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap.createDeferredMessageSentCallback() : null;\n\n            final CamelJmsTemplate template = (CamelJmsTemplate)getInOutTemplate();\n            MessageCreator messageCreator = new MessageCreator() {\n                public Message createMessage(Session session) throws JMSException {\n                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);\n                    message.setJMSReplyTo(replyTo);\n                    requestor.setReplyToSelectorHeader(in, message);\n\n                    FutureTask future = null;\n                    future = (!msgIdAsCorrId)\n                            ? requestor.getReceiveFuture(message.getJMSCorrelationID(), endpoint.getConfiguration().getRequestTimeout())\n                            : requestor.getReceiveFuture(callback);\n\n                    futureHolder.set(future);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(endpoint + \" sending JMS message: \" + message);\n                    }\n                    return message;\n                }\n            };\n\n            if (destinationName != null) {\n                template.send(destinationName, messageCreator, callback);\n            }\n            else if (destination != null) {\n                // TODO cannot pass in callback using destination?\n                template.send(destination.toString(), messageCreator, callback);\n                // template.send(destination, messageCreator);\n            }\n            else {\n                throw new IllegalArgumentException(\"Neither destination nor destinationName is specified on this endpoint: \" + endpoint);\n            }\n\n            setMessageId(exchange);\n\n            // lets wait and return the response\n            long requestTimeout = endpoint.getConfiguration().getRequestTimeout();\n            try {\n                Message message = null;\n                try {\n                    if (requestTimeout < 0) {\n                        message = (Message)futureHolder.get().get();\n                    } else {\n                        message = (Message)futureHolder.get().get(requestTimeout, TimeUnit.MILLISECONDS);\n                    }\n                } catch (InterruptedException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Future interupted: \" + e, e);\n                    }\n                } catch (TimeoutException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Future timed out: \" + e, e);\n                    }\n                }\n                if (message != null) {\n                    exchange.setOut(new JmsMessage(message, endpoint.getBinding()));\n                    if (correlationId != null) {\n                        message.setJMSCorrelationID(correlationId);\n                        exchange.getOut(false).setHeader(\"JMSCorrelationID\", correlationId);\n                    }\n                } else {\n                    // lets set a timed out exception\n                    exchange.setException(new ExchangeTimedOutException(exchange, requestTimeout));\n                }\n            } catch (Exception e) {\n                exchange.setException(e);\n            }\n        } else {\n            MessageCreator messageCreator = new MessageCreator() {\n                public Message createMessage(Session session) throws JMSException {\n                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(endpoint + \" sending JMS message: \" + message);\n                    }\n                    return message;\n                }\n            };\n            if (destinationName != null) {\n                getInOnlyTemplate().send(destinationName, messageCreator);\n            }\n            else if (destination != null) {\n                getInOnlyTemplate().send(destination, messageCreator);\n            }\n            else {\n                throw new IllegalArgumentException(\"Neither destination nor destinationName is specified on this endpoint: \" + endpoint);\n            }\n\n            setMessageId(exchange);\n        }\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"public List<Exchange> getExchanges() {\n        if (queueBrowseStrategy == null) {\n            return Collections.EMPTY_LIST;\n        }\n        String queue = getDestination();\n        JmsOperations template = getConfiguration().createInOnlyTemplate(this, false, queue);\n        return queueBrowseStrategy.browse(template, queue, this);\n    }","id":80455,"modified_method":"public List<Exchange> getExchanges() {\n        if (queueBrowseStrategy == null) {\n            return Collections.EMPTY_LIST;\n        }\n        String queue = getDestinationName();\n        JmsOperations template = getConfiguration().createInOnlyTemplate(this, false, queue);\n        return queueBrowseStrategy.browse(template, queue, this);\n    }","commit_id":"697805feca4b5b570159f1e4ef08d3bfe96183c4","url":"https://github.com/apache/camel"},{"original_method":"public Object send(String destinationName, Message message, long timeout)\n\t\tthrows MessageBusException {\n\n\t\tif (!_messageBus.hasDestination(destinationName)) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"No destination configured for: \" + destinationName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_messageBus.getDestination(destinationName).\n\t\t\t\tgetMessageListenerCount() == 0) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"No service providers listening on: \" + destinationName);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tmessage.setDestinationName(destinationName);\n\n\t\tString responseDestinationName = message.getResponseDestinationName();\n\n\t\t// Create a temporary destination if no response destination is\n\t\t// configured\n\n\t\tif (Validator.isNull(responseDestinationName) ||\n\t\t\t!_messageBus.hasDestination(responseDestinationName)) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Response destination \" + responseDestinationName +\n\t\t\t\t\t\t\" is not configured\");\n\t\t\t}\n\n\t\t\tmessage.setResponseDestinationName(\n\t\t\t\tDestinationNames.MESSAGE_BUS_DEFAULT_RESPONSE);\n\t\t}\n\n\t\tString responseId = _portalUUID.generate();\n\n\t\tmessage.setResponseId(responseId);\n\n\t\tSynchronousMessageListener synchronousMessageListener =\n\t\t\tnew SynchronousMessageListener(_messageBus, message, timeout);\n\n\t\treturn synchronousMessageListener.send();\n\t}","id":80456,"modified_method":"public Object send(String destinationName, Message message, long timeout)\n\t\tthrows MessageBusException {\n\n\t\tDestination destination = _messageBus.getDestination(destinationName);\n\n\t\tif (destination == null) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Destination \" + destinationName + \" is not configured\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (destination.getMessageListenerCount() == 0) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Destination \" + destinationName +\n\t\t\t\t\t\t\" does not have any message listeners\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tmessage.setDestinationName(destinationName);\n\n\t\tString responseDestinationName = message.getResponseDestinationName();\n\n\t\t// Create a temporary destination if no response destination is\n\t\t// configured\n\n\t\tif (Validator.isNull(responseDestinationName) ||\n\t\t\t!_messageBus.hasDestination(responseDestinationName)) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Response destination \" + responseDestinationName +\n\t\t\t\t\t\t\" is not configured\");\n\t\t\t}\n\n\t\t\tmessage.setResponseDestinationName(\n\t\t\t\tDestinationNames.MESSAGE_BUS_DEFAULT_RESPONSE);\n\t\t}\n\n\t\tString responseId = _portalUUID.generate();\n\n\t\tmessage.setResponseId(responseId);\n\n\t\tSynchronousMessageListener synchronousMessageListener =\n\t\t\tnew SynchronousMessageListener(_messageBus, message, timeout);\n\n\t\treturn synchronousMessageListener.send();\n\t}","commit_id":"115219321f9a0924fafb372a5494b5b6c1ac00fd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void reloadConfig() {\n        LOG.info(\"Reloading configuration for {}.\", getName());\n        m_configDao.reload();\n        final String destinationName = m_destination.getName();\n        m_destination = getConfig().getDestination(destinationName);\n        LOG.info(\"Destroying Syslog Northbound Instance {}.\", destinationName);\n        Syslog.destroyInstance(destinationName);\n        createNorthboundInstance();\n    }","id":80457,"modified_method":"@Override\n    public void reloadConfig() {\n        LOG.info(\"Reloading configuration for {}.\", getName());\n        m_configDao.reload();\n        final String destinationName = m_destination.getName();\n        SyslogDestination destination = getConfig().getDestination(destinationName);\n        if (destination == null) {\n            LOG.error(\"Aborting the reload operation because the destination {} can't be found on the configuration file.\", destinationName);\n            return;\n        }\n        m_destination = destination;\n        LOG.info(\"Destroying Syslog Northbound Instance {}.\", destinationName);\n        Syslog.destroyInstance(destinationName);\n        createNorthboundInstance();\n    }","commit_id":"28a2d6ead417835b76899c2e9b7504691cc138b3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * Process shutdown server removing any assignments.\n   * @param sn Server that went down.\n   * @return list of regions in transition on this server\n   */\n  public List<RegionState> processServerShutdown(final ServerName sn) {\n    // Clean out any existing assignment plans for this server\n    synchronized (this.regionPlans) {\n      for (Iterator <Map.Entry<String, RegionPlan>> i =\n          this.regionPlans.entrySet().iterator(); i.hasNext();) {\n        Map.Entry<String, RegionPlan> e = i.next();\n        if (e.getValue().getDestination().equals(sn)) {\n          // Use iterator's remove else we'll get CME\n          i.remove();\n        }\n      }\n    }\n    // TODO: Do we want to sync on RIT here?\n    // Remove this server from map of servers to regions, and remove all regions\n    // of this server from online map of regions.\n    Set<HRegionInfo> deadRegions = null;\n    List<RegionState> rits = new ArrayList<RegionState>();\n    synchronized (this.regions) {\n      List<HRegionInfo> assignedRegions = this.servers.remove(sn);\n      if (assignedRegions == null || assignedRegions.isEmpty()) {\n        // No regions on this server, we are done, return empty list of RITs\n        return rits;\n      }\n      deadRegions = new TreeSet<HRegionInfo>(assignedRegions);\n      for (HRegionInfo region : deadRegions) {\n        this.regions.remove(region);\n      }\n    }\n    // See if any of the regions that were online on this server were in RIT\n    // If they are, normal timeouts will deal with them appropriately so\n    // let's skip a manual re-assignment.\n    synchronized (regionsInTransition) {\n      for (RegionState region : this.regionsInTransition.values()) {\n        if (deadRegions.remove(region.getRegion())) {\n          rits.add(region);\n        }\n      }\n    }\n    return rits;\n  }","id":80458,"modified_method":"/**\n   * Process shutdown server removing any assignments.\n   * @param sn Server that went down.\n   * @return list of regions in transition on this server\n   */\n  public List<RegionState> processServerShutdown(final ServerName sn) {\n    // Clean out any existing assignment plans for this server\n    synchronized (this.regionPlans) {\n      for (Iterator <Map.Entry<String, RegionPlan>> i =\n          this.regionPlans.entrySet().iterator(); i.hasNext();) {\n        Map.Entry<String, RegionPlan> e = i.next();\n        ServerName otherSn = e.getValue().getDestination();\n        // The name will be null if the region is planned for a random assign.\n        if (otherSn != null && otherSn.equals(sn)) {\n          // Use iterator's remove else we'll get CME\n          i.remove();\n        }\n      }\n    }\n    // TODO: Do we want to sync on RIT here?\n    // Remove this server from map of servers to regions, and remove all regions\n    // of this server from online map of regions.\n    Set<HRegionInfo> deadRegions = null;\n    List<RegionState> rits = new ArrayList<RegionState>();\n    synchronized (this.regions) {\n      List<HRegionInfo> assignedRegions = this.servers.remove(sn);\n      if (assignedRegions == null || assignedRegions.isEmpty()) {\n        // No regions on this server, we are done, return empty list of RITs\n        return rits;\n      }\n      deadRegions = new TreeSet<HRegionInfo>(assignedRegions);\n      for (HRegionInfo region : deadRegions) {\n        this.regions.remove(region);\n      }\n    }\n    // See if any of the regions that were online on this server were in RIT\n    // If they are, normal timeouts will deal with them appropriately so\n    // let's skip a manual re-assignment.\n    synchronized (regionsInTransition) {\n      for (RegionState region : this.regionsInTransition.values()) {\n        if (deadRegions.remove(region.getRegion())) {\n          rits.add(region);\n        }\n      }\n    }\n    return rits;\n  }","commit_id":"d64c76fe105c9fa20fed733f8ffbbefdf1e8b8a0","url":"https://github.com/apache/hbase"},{"original_method":"private void mergeCandidatePackages(\n        Module current, Requirement currentReq, Capability candCap,\n        Map<Module, Packages> modulePkgMap, Map<Requirement, Set<Capability>> candidateMap)\n    {\n        if (candCap.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n        {\n            mergeCandidatePackage(\n                current, false, currentReq, candCap, modulePkgMap);\n        }\n        else if (candCap.getNamespace().equals(Capability.MODULE_NAMESPACE))\n        {\n// TODO: FELIX3 - THIS NEXT LINE IS A HACK. IMPROVE HOW/WHEN WE CALCULATE EXPORTS.\n            calculateExportedPackages(candCap.getModule(), modulePkgMap);\n\n            // Get the candidate's package space to determine which packages\n            // will be visible to the current module.\n            Packages candPkgs = modulePkgMap.get(candCap.getModule());\n\n            // We have to merge all exported packages from the candidate,\n            // since the current module requires it.\n// TODO: FELIX3 - If a module imports its exports, then imported exports should\n//       be reexported to requiring bundles.\n            for (Entry<String, Blame> entry : candPkgs.m_exportedPkgs.entrySet())\n            {\n                mergeCandidatePackage(\n                    current,\n                    true,\n                    currentReq,\n                    entry.getValue().m_cap,\n                    modulePkgMap);\n            }\n\n            // If the candidate requires any other bundles with reexport visibility,\n            // then we also need to merge their packages too.\n            for (Requirement req : candCap.getModule().getRequirements())\n            {\n                if (req.getNamespace().equals(Capability.MODULE_NAMESPACE))\n                {\n                    Directive dir = req.getDirective(Constants.VISIBILITY_DIRECTIVE);\n                    if ((dir != null) && dir.getValue().equals(Constants.VISIBILITY_REEXPORT)\n                        && (candidateMap.get(req) != null))\n                    {\n                        mergeCandidatePackages(\n                            current,\n                            currentReq,\n                            candidateMap.get(req).iterator().next(),\n                            modulePkgMap,\n                            candidateMap);\n                    }\n                }\n            }\n        }\n    }","id":80459,"modified_method":"private void mergeCandidatePackages(\n        Module current, Requirement currentReq, Capability candCap,\n        Map<Module, Packages> modulePkgMap, Map<Requirement, Set<Capability>> candidateMap)\n    {\n        if (candCap.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n        {\n            mergeCandidatePackage(\n                current, false, currentReq, candCap, modulePkgMap);\n        }\n        else if (candCap.getNamespace().equals(Capability.MODULE_NAMESPACE))\n        {\n// TODO: FELIX3 - THIS NEXT LINE IS A HACK. IMPROVE HOW/WHEN WE CALCULATE EXPORTS.\n            calculateExportedPackages(\n                candCap.getModule(), candidateMap, modulePkgMap);\n\n            // Get the candidate's package space to determine which packages\n            // will be visible to the current module.\n            Packages candPkgs = modulePkgMap.get(candCap.getModule());\n\n            // We have to merge all exported packages from the candidate,\n            // since the current module requires it.\n            for (Entry<String, Blame> entry : candPkgs.m_exportedPkgs.entrySet())\n            {\n                mergeCandidatePackage(\n                    current,\n                    true,\n                    currentReq,\n                    entry.getValue().m_cap,\n                    modulePkgMap);\n            }\n\n            // If the candidate requires any other bundles with reexport visibility,\n            // then we also need to merge their packages too.\n            for (Requirement req : candCap.getModule().getRequirements())\n            {\n                if (req.getNamespace().equals(Capability.MODULE_NAMESPACE))\n                {\n                    Directive dir = req.getDirective(Constants.VISIBILITY_DIRECTIVE);\n                    if ((dir != null) && dir.getValue().equals(Constants.VISIBILITY_REEXPORT)\n                        && (candidateMap.get(req) != null))\n                    {\n                        mergeCandidatePackages(\n                            current,\n                            currentReq,\n                            candidateMap.get(req).iterator().next(),\n                            modulePkgMap,\n                            candidateMap);\n                    }\n                }\n            }\n        }\n    }","commit_id":"3ca0af4f9b08e67687f1fc2bd6f8c2c257ff5fdb","url":"https://github.com/apache/felix"},{"original_method":"private void calculatePackageSpaces(\n        Module module,\n        Map<Requirement, Set<Capability>> candidateMap,\n        Map<Module, Packages> modulePkgMap,\n        Map<Capability, List<Module>> usesCycleMap,\n        Set<Module> cycle)\n    {\n        if (cycle.contains(module))\n        {\n            return;\n        }\n        cycle.add(module);\n\n        // Create a map of wires or proposed wired depending on whether\n        // the module is resolved or not.\n        List<Requirement> reqs = new ArrayList();\n        List<Capability> caps = new ArrayList();\n        if (module.isResolved())\n        {\n            // Use wires to get actual requirements and satisfying capabilities.\n            for (Wire wire : module.getWires())\n            {\n                reqs.add(wire.getRequirement());\n                caps.add(wire.getCapability());\n            }\n\n            // Since the module is resolved, it could be dynamically importing,\n            // so check to see if there are candidates for any of its dynamic\n            // imports.\n            for (Requirement req : module.getDynamicRequirements())\n            {\n                // Get the candidates for the current requirement.\n                Set<Capability> candCaps = candidateMap.get(req);\n                // Optional requirements may not have any candidates.\n                if (candCaps == null)\n                {\n                    continue;\n                }\n\n                Capability cap = candCaps.iterator().next();\n                reqs.add(req);\n                caps.add(cap);\n                // Can only dynamically import one at a time, so break\n                // out of the loop after the first.\n                break;\n            }\n        }\n        else\n        {\n            for (Requirement req : module.getRequirements())\n            {\n                // Get the candidates for the current requirement.\n                Set<Capability> candCaps = candidateMap.get(req);\n                // Optional requirements may not have any candidates.\n                if (candCaps == null)\n                {\n                    continue;\n                }\n\n                Capability cap = candCaps.iterator().next();\n                reqs.add(req);\n                caps.add(cap);\n            }\n        }\n\n        // First, add all exported packages to our package space.\n        calculateExportedPackages(module, modulePkgMap);\n        Packages modulePkgs = modulePkgMap.get(module);\n\n        // Second, add all imported packages to our candidate space.\n        for (int i = 0; i < reqs.size(); i++)\n        {\n            Requirement req = reqs.get(i);\n            Capability cap = caps.get(i);\n            calculateExportedPackages(cap.getModule(), modulePkgMap);\n            mergeCandidatePackages(module, req, cap, modulePkgMap, candidateMap);\n        }\n\n        // Third, ask our candidates to calculate their package spaces.\n        for (int i = 0; i < caps.size(); i++)\n        {\n            calculatePackageSpaces(\n                caps.get(i).getModule(), candidateMap, modulePkgMap,\n                usesCycleMap, cycle);\n        }\n\n        // Fourth, add all of the uses constraints implied by our imported\n        // and required packages.\n        for (Entry<String, List<Blame>> entry : modulePkgs.m_importedPkgs.entrySet())\n        {\n            for (Blame blame : entry.getValue())\n            {\n                // Ignore modules that import from themselves.\n                if (!blame.m_cap.getModule().equals(module))\n                {\n                    List<Requirement> blameReqs = new ArrayList();\n                    blameReqs.add(blame.m_reqs.get(0));\n\n                    mergeUses(\n                        module,\n                        modulePkgs,\n                        blame.m_cap,\n                        blameReqs,\n                        modulePkgMap,\n                        candidateMap,\n                        usesCycleMap);\n                }\n            }\n        }\n        for (Entry<String, List<Blame>> entry : modulePkgs.m_requiredPkgs.entrySet())\n        {\n            for (Blame blame : entry.getValue())\n            {\n                List<Requirement> blameReqs = new ArrayList();\n                blameReqs.add(blame.m_reqs.get(0));\n\n                mergeUses(\n                    module,\n                    modulePkgs,\n                    blame.m_cap,\n                    blameReqs,\n                    modulePkgMap,\n                    candidateMap,\n                    usesCycleMap);\n            }\n        }\n    }","id":80460,"modified_method":"private void calculatePackageSpaces(\n        Module module,\n        Map<Requirement, Set<Capability>> candidateMap,\n        Map<Module, Packages> modulePkgMap,\n        Map<Capability, List<Module>> usesCycleMap,\n        Set<Module> cycle)\n    {\n        if (cycle.contains(module))\n        {\n            return;\n        }\n        cycle.add(module);\n\n        // Create a map of wires or proposed wired depending on whether\n        // the module is resolved or not.\n        List<Requirement> reqs = new ArrayList();\n        List<Capability> caps = new ArrayList();\n        if (module.isResolved())\n        {\n            // Use wires to get actual requirements and satisfying capabilities.\n            for (Wire wire : module.getWires())\n            {\n                reqs.add(wire.getRequirement());\n                caps.add(wire.getCapability());\n            }\n\n            // Since the module is resolved, it could be dynamically importing,\n            // so check to see if there are candidates for any of its dynamic\n            // imports.\n            for (Requirement req : module.getDynamicRequirements())\n            {\n                // Get the candidates for the current requirement.\n                Set<Capability> candCaps = candidateMap.get(req);\n                // Optional requirements may not have any candidates.\n                if (candCaps == null)\n                {\n                    continue;\n                }\n\n                Capability cap = candCaps.iterator().next();\n                reqs.add(req);\n                caps.add(cap);\n                // Can only dynamically import one at a time, so break\n                // out of the loop after the first.\n                break;\n            }\n        }\n        else\n        {\n            for (Requirement req : module.getRequirements())\n            {\n                // Get the candidates for the current requirement.\n                Set<Capability> candCaps = candidateMap.get(req);\n                // Optional requirements may not have any candidates.\n                if (candCaps == null)\n                {\n                    continue;\n                }\n\n                Capability cap = candCaps.iterator().next();\n                reqs.add(req);\n                caps.add(cap);\n            }\n        }\n\n        // First, add all exported packages to our package space.\n        calculateExportedPackages(module, candidateMap, modulePkgMap);\n        Packages modulePkgs = modulePkgMap.get(module);\n\n        // Second, add all imported packages to our candidate space.\n        for (int i = 0; i < reqs.size(); i++)\n        {\n            Requirement req = reqs.get(i);\n            Capability cap = caps.get(i);\n            calculateExportedPackages(cap.getModule(), candidateMap, modulePkgMap);\n            mergeCandidatePackages(module, req, cap, modulePkgMap, candidateMap);\n        }\n\n        // Third, ask our candidates to calculate their package spaces.\n        for (int i = 0; i < caps.size(); i++)\n        {\n            calculatePackageSpaces(\n                caps.get(i).getModule(), candidateMap, modulePkgMap,\n                usesCycleMap, cycle);\n        }\n\n        // Fourth, add all of the uses constraints implied by our imported\n        // and required packages.\n        for (Entry<String, List<Blame>> entry : modulePkgs.m_importedPkgs.entrySet())\n        {\n            for (Blame blame : entry.getValue())\n            {\n                // Ignore modules that import from themselves.\n                if (!blame.m_cap.getModule().equals(module))\n                {\n                    List<Requirement> blameReqs = new ArrayList();\n                    blameReqs.add(blame.m_reqs.get(0));\n\n                    mergeUses(\n                        module,\n                        modulePkgs,\n                        blame.m_cap,\n                        blameReqs,\n                        modulePkgMap,\n                        candidateMap,\n                        usesCycleMap);\n                }\n            }\n        }\n        for (Entry<String, List<Blame>> entry : modulePkgs.m_requiredPkgs.entrySet())\n        {\n            for (Blame blame : entry.getValue())\n            {\n                List<Requirement> blameReqs = new ArrayList();\n                blameReqs.add(blame.m_reqs.get(0));\n\n                mergeUses(\n                    module,\n                    modulePkgs,\n                    blame.m_cap,\n                    blameReqs,\n                    modulePkgMap,\n                    candidateMap,\n                    usesCycleMap);\n            }\n        }\n    }","commit_id":"3ca0af4f9b08e67687f1fc2bd6f8c2c257ff5fdb","url":"https://github.com/apache/felix"},{"original_method":"private static void calculateExportedPackages(\n        Module module, Map<Module, Packages> modulePkgMap)\n    {\n        Packages packages = modulePkgMap.get(module);\n        if (packages != null)\n        {\n            return;\n        }\n        packages = new Packages(module);\n\n        List<Capability> caps = module.getCapabilities();\n\n        if (caps.size() > 0)\n        {\n            // Grab all exported packages that are not also imported.\n            for (int i = 0; i < caps.size(); i++)\n            {\n// TODO: FELIX3 - Assume if a module imports the same package it\n//       exports that the import will overlap the export.\n                if (caps.get(i).getNamespace().equals(Capability.PACKAGE_NAMESPACE)\n                    && !hasOverlappingImport(module, caps.get(i)))\n                {\n                    packages.m_exportedPkgs.put(\n                        (String) caps.get(i).getAttribute(Capability.PACKAGE_ATTR).getValue(),\n                        new Blame(caps.get(i), null));\n                }\n            }\n        }\n\n        modulePkgMap.put(module, packages);\n    }","id":80461,"modified_method":"private static void calculateExportedPackages(\n        Module module,\n        Map<Requirement, Set<Capability>> candidateMap,\n        Map<Module, Packages> modulePkgMap)\n    {\n        Packages packages = modulePkgMap.get(module);\n        if (packages != null)\n        {\n            return;\n        }\n        packages = new Packages(module);\n\n        // Get all exported packages.\n        Map<String, Capability> exports =\n            new HashMap<String, Capability>(module.getCapabilities().size());\n        for (Capability cap : module.getCapabilities())\n        {\n            if (cap.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n            {\n                exports.put(\n                    (String) cap.getAttribute(Capability.PACKAGE_ATTR).getValue(),\n                    cap);\n            }\n        }\n        // Remove substitutable exports that were imported.\n        // For resolved modules look at the wires, for resolving\n        // modules look in the candidate map to determine which\n        // exports are substitutable.\n        if (module.isResolved())\n        {\n            for (Wire wire : module.getWires())\n            {\n                if (wire.getRequirement().getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n                {\n                    String pkgName = (String) wire.getCapability()\n                        .getAttribute(Capability.PACKAGE_ATTR).getValue();\n                    exports.remove(pkgName);\n                }\n            }\n        }\n        else\n        {\n            for (Requirement req : module.getRequirements())\n            {\n                if (req.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n                {\n                    Set<Capability> cands = candidateMap.get(req);\n                    if ((cands != null) && !cands.isEmpty())\n                    {\n                        String pkgName = (String) cands.iterator().next()\n                            .getAttribute(Capability.PACKAGE_ATTR).getValue();\n                        exports.remove(pkgName);\n                    }\n                }\n            }\n        }\n        // Add all non-substituted exports to the module's package space.\n        for (Entry<String, Capability> entry : exports.entrySet())\n        {\n            packages.m_exportedPkgs.put(\n                entry.getKey(), new Blame(entry.getValue(), null));\n        }\n\n        modulePkgMap.put(module, packages);\n    }","commit_id":"3ca0af4f9b08e67687f1fc2bd6f8c2c257ff5fdb","url":"https://github.com/apache/felix"},{"original_method":"public void handleContentName(ConfigSlice syncSlice, ContentName syncedContent) {\n\t\tLog.fine(Log.FAC_TEST, \"Callback for name: {0}\", syncedContent);\n\t\tsynchronized (callbackNames) {\n\t\t\tcallbackNames.add(syncedContent);\n\t\t}\n\t}","id":80462,"modified_method":"public void handleContentName(ConfigSlice syncSlice, ContentName syncedContent) {\n\t\tLog.info(Log.FAC_TEST, \"Callback for name: {0}\", syncedContent);\n\t\tsynchronized (callbackNames) {\n\t\t\tcallbackNames.add(syncedContent);\n\t\t}\n\t}","commit_id":"acf78ac458d3c1eaca2fafe6e100af8f8231eb1b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void registerCallback(CCNSyncHandler syncHandler, ConfigSlice slice) throws IOException {\n\t\t_topo = slice.topo;\n\t\t_sliceHash = slice.getHash();\n\t\t_nextRoot = new SyncTreeEntry(_sliceHash, _decoder);\n\t\t_currentRoot = new SyncTreeEntry(_sliceHash, _decoder);\n\t\t_hashes.put(new HashEntry(_sliceHash), _nextRoot);\n\t\tsynchronized (callbacks) {\n\t\t\tregisterCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tContentName rootAdvise = new ContentName(slice.topo, Sync.SYNC_ROOT_ADVISE_MARKER, slice.getHash());\n\t\tInterest interest = new Interest(rootAdvise);\n\t\tinterest.scope(1);\n\t\t_handle.registerFilter(rootAdvise, this);\n\t\t_handle.expressInterest(interest, this);\n\t}","id":80463,"modified_method":"public void registerCallback(CCNSyncHandler syncHandler, ConfigSlice slice) throws IOException {\n\t\tsynchronized (callbacks) {\n\t\t\tregisterCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tSliceComparator sc = new SliceComparator(syncHandler, slice, _handle);\n\t\tsynchronized (this) {\n\t\t\tSyncHashEntry she = new SyncHashEntry(slice.getHash());\n\t\t\tArrayList<SliceComparator> al = _comparators.get(she);\n\t\t\tif (null == al)\n\t\t\t\tal = new ArrayList<SliceComparator>();\n\t\t\tal.add(sc);\n\t\t\t_comparators.put(new SyncHashEntry(slice.getHash()), al);\n\t\t}\n\t\tContentName rootAdvise = new ContentName(slice.topo, Sync.SYNC_ROOT_ADVISE_MARKER, slice.getHash());\n\t\tInterest interest = new Interest(rootAdvise);\n\t\tinterest.scope(1);\n\t\t_handle.registerFilter(rootAdvise, this);\n\t\t_handle.expressInterest(interest, this);\n\t}","commit_id":"acf78ac458d3c1eaca2fafe6e100af8f8231eb1b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tContentName name = data.name();\n\t\tint hashComponent = name.containsWhere(Sync.SYNC_ROOT_ADVISE_MARKER);\n\t\tif (hashComponent < 0) {\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect content in sync: {0}\", name);\n\t\t\treturn null;\n\t\t}\n\t\tLog.info(Log.FAC_SYNC, \"Saw new content from sync: {0}\", name);\n\t\tboolean newRound = false;\n\t\tsynchronized (this) {\n\t\t\tSyncTreeEntry ste = new SyncTreeEntry(_decoder);\n\t\t\tste.setRawContent(data.content());\n\t\t\t_pendingEntries.add(ste);\n\t\t\tif (_state == SyncCompareState.DONE) {\n\t\t\t\t_state = SyncCompareState.INIT;\n\t\t\t\tnewRound = true;\n\t\t\t}\n\t\t}\n\t\tif (newRound)\n\t\t\tkickCompare();\t// Don't want to do this inside lock\n\t\treturn null;\n\t}","id":80464,"modified_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tContentName name = data.name();\n\t\tint hashComponent = name.containsWhere(Sync.SYNC_ROOT_ADVISE_MARKER);\n\t\tif (hashComponent < 0 || name.count() < hashComponent + 3) {\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect content in sync: {0}\", name);\n\t\t\treturn null;\n\t\t}\n\t\tLog.info(Log.FAC_SYNC, \"Saw new content from sync: {0}\", name);\n\t\tSyncHashEntry she = new SyncHashEntry(name.component(hashComponent + 1));\n\t\tArrayList<SliceComparator> al = null;\n\t\tsynchronized (this) {\n\t\t\tal = _comparators.get(she);\n\t\t}\n\t\tif (null != al) {\n\t\t\tfor (SliceComparator sc : al) {\nLog.info(Log.FAC_SYNC, \"Adding data for slice {0}\", Component.printURI(she._hash));\n\t\t\t\tsc.addPending(data.content());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"acf78ac458d3c1eaca2fafe6e100af8f8231eb1b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void removeCallback(CCNSyncHandler syncHandler, ConfigSlice slice) {\n\t\tsynchronized (callbacks) {\n\t\t\tremoveCallbackInternal(syncHandler, slice);\n\t\t}\n\t}","id":80465,"modified_method":"public void removeCallback(CCNSyncHandler syncHandler, ConfigSlice slice) {\n\t\tsynchronized (callbacks) {\n\t\t\tremoveCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tSyncHashEntry she = new SyncHashEntry(slice.getHash());\n\t\tsynchronized (this) {\n\t\t\tArrayList<SliceComparator> al = _comparators.get(she);\n\t\t\tSliceComparator thisOne = null;\n\t\t\tfor (SliceComparator sc : al) {\n\t\t\t\tif (syncHandler == sc.getCallback()) {\n\t\t\t\t\tthisOne = sc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null != thisOne) {\n\t\t\t\tal.remove(thisOne);\n\t\t\t\tif (al.size() == 0)\n\t\t\t\t\t_comparators.remove(she);\n\t\t\t}\n\t\t}\n\t}","commit_id":"acf78ac458d3c1eaca2fafe6e100af8f8231eb1b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public ProtocolBasedSyncMonitor(CCNHandle handle) {\n\t\t_handle = handle;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(DECODER_SIZE);\n\t}","id":80466,"modified_method":"public ProtocolBasedSyncMonitor(CCNHandle handle) {\n\t\t_handle = handle;\n\t}","commit_id":"acf78ac458d3c1eaca2fafe6e100af8f8231eb1b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void startSync(CCNHandle handle, ConfigSlice syncSlice, CCNSyncHandler syncCallback) throws IOException, ConfigurationException{\n\t\ttry {\n\t\t\tsyncSlice.checkAndCreate(handle);\n\t\t\tif (syncMon == null)\n\t\t\t\tsyncMon = new ProtocolBasedSyncMonitor(handle);\n\t\t\tsyncMon.registerCallback(syncCallback, syncSlice);\n\t\t} catch (Exception e) {\n\t\t\tLog.warning(Log.FAC_REPO, \"Error when starting sync for slice: {0}\", syncSlice);\n\t\t\tthrow new IOException(\"Unable to create sync slice: \"+e.getMessage());\n\t\t}\n\t}","id":80467,"modified_method":"public void startSync(CCNHandle handle, ConfigSlice syncSlice, CCNSyncHandler syncCallback, byte[] startHash, ContentName startName) throws IOException, ConfigurationException{\n\t\ttry {\n\t\t\tsyncSlice.checkAndCreate(handle);\n\t\t\tif (syncMon == null)\n\t\t\t\tsyncMon = new ProtocolBasedSyncMonitor(handle);\n\t\t\tsyncMon.registerCallback(syncCallback, syncSlice);\n\t\t} catch (Exception e) {\n\t\t\tLog.warning(Log.FAC_REPO, \"Error when starting sync for slice: {0}\", syncSlice);\n\t\t\tthrow new IOException(\"Unable to create sync slice: \"+e.getMessage());\n\t\t}\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tContentName name = data.name();\n\t\tint hashComponent = name.containsWhere(Sync.SYNC_ROOT_ADVISE_MARKER);\n\t\tif (hashComponent < 0) {\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect content in sync: {0}\", name);\n\t\t\treturn null;\n\t\t}\n\t\tLog.info(Log.FAC_SYNC, \"Saw new content from sync: {0}\", name);\n\t\tContentName topo = name.cut(Sync.SYNC_ROOT_ADVISE_MARKER.getBytes());\n\t\tbyte[] hash = name.component(hashComponent + 1);\n\t\tSliceReferences sr = getReferencesBySliceHash(topo, hash);\n\t\tif (null != sr) {\n\t\t\tboolean newRound = false;\n\t\t\tsynchronized (sr) {\n\t\t\t\tSyncTreeEntry ste = new SyncTreeEntry(_decoder);\n\t\t\t\tste.setRawContent(data.content());\n\t\t\t\tsr.addPending(ste);\n\t\t\t\tif (sr.getState() == SyncCompareState.DONE) {\n\t\t\t\t\tsr.setState(SyncCompareState.INIT);\n\t\t\t\t\tnewRound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newRound)\n\t\t\t\tkickCompare();\t// Don't want to do this inside lock\n\t\t}\n\t\treturn null;\n\t}","id":80468,"modified_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tContentName name = data.name();\n\t\tint hashComponent = name.containsWhere(Sync.SYNC_ROOT_ADVISE_MARKER);\n\t\tif (hashComponent < 0) {\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect content in sync: {0}\", name);\n\t\t\treturn null;\n\t\t}\n\t\tLog.info(Log.FAC_SYNC, \"Saw new content from sync: {0}\", name);\n\t\tboolean newRound = false;\n\t\tsynchronized (this) {\n\t\t\tSyncTreeEntry ste = new SyncTreeEntry(_decoder);\n\t\t\tste.setRawContent(data.content());\n\t\t\t_pendingEntries.add(ste);\n\t\t\tif (_state == SyncCompareState.DONE) {\n\t\t\t\t_state = SyncCompareState.INIT;\n\t\t\t\tnewRound = true;\n\t\t\t}\n\t\t}\n\t\tif (newRound)\n\t\t\tkickCompare();\t// Don't want to do this inside lock\n\t\treturn null;\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void doComparisonWithCallbacks(ContentName topo, SliceReferences sr, HashMap<ConfigSlice, ArrayList<CCNSyncHandler>> callbacks) {\n\t\tSyncTreeEntry srtY = null;\n\t\tSyncTreeEntry srtX = null;\n\t\t\n\t\tsynchronized (sr) {\n\t\t\tsrtY = sr.getNextHead();\n\t\t\tsrtX = sr.getCurrentHead();\n\t\t}\n\t\twhile (null != srtY) {\n\t\t\tboolean lastPos = false;\n\t\t\tSyncNodeComposite.SyncNodeElement sneX = null;\n\t\t\tSyncNodeComposite.SyncNodeElement sneY = null;\n\t\t\tsynchronized (sr) {\n\t\t\t\tSyncNodeComposite snc = srtY.getNodeX();\n\t\t\t\tif (null != snc) {\n\t\t\t\t\tsneY = srtY.getCurrentElement();\n\t\t\t\t\tif (null == sneY)\n\t\t\t\t\t\tlastPos = true;\n\t\t\t\t}\n\t\t\t\tif (null != srtX) {\n\t\t\t\t\tsnc = srtX.getNodeX();\n\t\t\t\t\tif (null != snc) {\n\t\t\t\t\t\tsneX = srtX.getCurrentElement();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null == sneX && null != sneY && !lastPos) {\nLog.info(\"Comparing hash for {0}, type is {1}\", Component.printURI(srtY.getHash()), sneY.getType());\n\t\t\t\tswitch (sneY.getType()) {\n\t\t\t\tcase LEAF:\n\t\t\t\t\tdoCallbacks(callbacks, sneY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase HASH:\n\t\t\t\t\tbyte[] hash = sneY.getData();\n\t\t\t\t\tSyncTreeEntry entry = sr.getByHash(new HashEntry(hash));\n\t\t\t\t\tif (null == entry) {\n\t\t\t\t\t\tif (requestNode(topo, sr, sneY.getData())) {\nLog.info(\"requested from compare\");\n\t\t\t\t\t\t\tsynchronized (sr) {\n\t\t\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsr.pushNext(entry);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsynchronized (sr) {\n\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\twhile (null != srtY && srtY.lastPos()) {\n\t\t\t\t\t\tsr.popNext();\n\t\t\t\t\t\tsrtY = sr.getNextHead();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (null == sneY  && !lastPos) {\n\t\t\t\tLog.info(\"No data for {0}, pos is {1}\", Component.printURI(srtY.getHash()), srtY.getPos());\n\t\t\t\trequestNode(topo, sr, srtY.getHash());\n\t\t\t\treturn;\n\t\t\t} else if (null != sneX) {\n\t\t\t\tif (sneX.getType() == SyncNodeType.LEAF && sneY.getType() == SyncNodeType.LEAF) {\n\t\t\t\t\tint comp = sneX.getName().compareTo(sneY.getName());\nLog.info(\"name 1 is {0}, name 2 is {1}, comp is {2}\", sneX.getName(), sneY.getName(), comp);\n\t\t\t\t\tif (comp == 0) {\n\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t} else if (comp > 0) {\n\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoCallbacks(callbacks, sneY);\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsynchronized (sr) {\n\t\t\t\t\twhile (null != srtY && srtY.lastPos()) {\n\t\t\t\t\t\tsr.popNext();\n\t\t\t\t\t\tsrtY = sr.getNextHead();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsynchronized (sr) {\n\t\t\tif (sr.getState() == SyncCompareState.COMPARE)\n\t\t\t\tsr.setState(SyncCompareState.DONE);\n\t\t}\nLog.info(\"Exited 1 and status was: {0}\", sr.getState());\n\t}","id":80469,"modified_method":"private void doComparisonWithCallbacks(ContentName topo, HashMap<ConfigSlice, ArrayList<CCNSyncHandler>> callbacks) {\n\t\tSyncTreeEntry srtY = null;\n\t\tSyncTreeEntry srtX = null;\n\t\t\n\t\tsynchronized (this) {\n\t\t\tsrtY = getNextHead();\n\t\t\tsrtX = getCurrentHead();\n\t\t}\n\t\twhile (null != srtY) {\n\t\t\tboolean lastPos = false;\n\t\t\tSyncNodeComposite.SyncNodeElement sneX = null;\n\t\t\tSyncNodeComposite.SyncNodeElement sneY = null;\n\t\t\tsynchronized (this) {\n\t\t\t\tSyncNodeComposite snc = srtY.getNodeX();\n\t\t\t\tif (null != snc) {\n\t\t\t\t\tsneY = srtY.getCurrentElement();\n\t\t\t\t\tif (null == sneY)\n\t\t\t\t\t\tlastPos = true;\n\t\t\t\t}\n\t\t\t\tif (null != srtX) {\n\t\t\t\t\tsnc = srtX.getNodeX();\n\t\t\t\t\tif (null != snc) {\n\t\t\t\t\t\tsneX = srtX.getCurrentElement();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null == sneX && null != sneY && !lastPos) {\nLog.info(\"Comparing hash for {0}, type is {1}\", Component.printURI(srtY.getHash()), sneY.getType());\n\t\t\t\tswitch (sneY.getType()) {\n\t\t\t\tcase LEAF:\n\t\t\t\t\tdoCallbacks(callbacks, sneY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase HASH:\n\t\t\t\t\tbyte[] hash = sneY.getData();\n\t\t\t\t\tSyncTreeEntry entry = _hashes.get(new HashEntry(hash));\n\t\t\t\t\tif (null == entry) {\n\t\t\t\t\t\tif (requestNode(topo, sneY.getData())) {\nLog.info(\"requested from compare\");\n\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t_state = SyncCompareState.PRELOAD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushNext(entry);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\twhile (null != srtY && srtY.lastPos()) {\n\t\t\t\t\t\tpopNext();\n\t\t\t\t\t\tsrtY = getNextHead();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (null == sneY  && !lastPos) {\n\t\t\t\tLog.info(\"No data for {0}, pos is {1}\", Component.printURI(srtY.getHash()), srtY.getPos());\n\t\t\t\trequestNode(topo, srtY.getHash());\n\t\t\t\treturn;\n\t\t\t} else if (null != sneX) {\n\t\t\t\tif (sneX.getType() == SyncNodeType.LEAF && sneY.getType() == SyncNodeType.LEAF) {\n\t\t\t\t\tint comp = sneX.getName().compareTo(sneY.getName());\nLog.info(\"name 1 is {0}, name 2 is {1}, comp is {2}\", sneX.getName(), sneY.getName(), comp);\n\t\t\t\t\tif (comp == 0) {\n\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t} else if (comp > 0) {\n\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoCallbacks(callbacks, sneY);\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\twhile (null != srtY && srtY.lastPos()) {\n\t\t\t\t\t\tpopNext();\n\t\t\t\t\t\tgetNextHead();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsynchronized (this) {\n\t\t\tif (_state == SyncCompareState.COMPARE)\n\t\t\t\t_state = SyncCompareState.DONE;\n\t\t}\nLog.info(\"Exited 1 and status was: {0}\", _state);\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * \n\t * @param sr\n\t * @param topo\n\t * @param srt\n\t * @return false if no preloads requested\n\t */\n\tprivate boolean doPreload(ContentName topo, SliceReferences sr, SyncTreeEntry srt) {\n\t\tBoolean ret = false;\n\t\tsynchronized (sr) {\n\t\t\tSyncNodeComposite snc = srt.getNodeX();\n\t\t\tif (null != snc) {\n\t\t\t\tfor (SyncNodeElement sne : snc.getRefs()) {\n\t\t\t\t\tif (sne.getType() == SyncNodeType.HASH) {\n\t\t\t\t\t\tbyte[] hash = sne.getData();\n\t\t\t\t\t\tret = requestNode(topo, sr, hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","id":80470,"modified_method":"/**\n\t * \n\t * @param sr\n\t * @param topo\n\t * @param srt\n\t * @return false if no preloads requested\n\t */\n\tprivate boolean doPreload(ContentName topo, SyncTreeEntry srt) {\n\t\tBoolean ret = false;\n\t\tsynchronized (this) {\n\t\t\tSyncNodeComposite snc = srt.getNodeX();\n\t\t\tif (null != snc) {\n\t\t\t\tfor (SyncNodeElement sne : snc.getRefs()) {\n\t\t\t\t\tif (sne.getType() == SyncNodeType.HASH) {\n\t\t\t\t\t\tbyte[] hash = sne.getData();\n\t\t\t\t\t\tret = requestNode(topo, hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\t\tContentName name = data.name();\n\t\t\tint hashComponent = name.containsWhere(Sync.SYNC_NODE_FETCH_MARKER);\n\t\t\tif (hashComponent < 0 || name.count() < (hashComponent + 1)) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect node content in sync: {0}\", name);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tContentName topo = name.cut(Sync.SYNC_NODE_FETCH_MARKER.getBytes());\n\t\t\tbyte[] sliceHash = name.component(hashComponent + 1);\n\t\t\tbyte[] hash = name.component(hashComponent + 2);\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Saw data from nodefind: hash: {0}\", name);\n\t\t\tSliceReferences sr = getReferencesBySliceHash(topo, sliceHash);\n\t\t\tif (null != sr) {\n\t\t\t\tsynchronized (sr) {\n\t\t\t\t\tSyncTreeEntry srt = null;\n\t\t\t\t\tsrt = addHash(sr, hash);\n\t\t\t\t\tsrt.setRawContent(data.content());\n\t\t\t\t\tsrt.setPending(false);\n\t\t\t\t\tif (null != srt) {\n\t\t\t\t\t\tsr.pushNext(srt);\n\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\tkickCompare();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","id":80471,"modified_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\t\tContentName name = data.name();\n\n\t\t\tint hashComponent = name.containsWhere(Sync.SYNC_NODE_FETCH_MARKER);\n\t\t\tif (hashComponent < 0 || name.count() < (hashComponent + 1)) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect node content in sync: {0}\", name);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbyte[] hash = name.component(hashComponent + 2);\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Saw data from nodefind: hash: {0}\", name);\n\t\t\tsynchronized (this) {\n\t\t\t\tSyncTreeEntry srt = null;\n\t\t\t\tsrt = addHash(hash);\n\t\t\t\tsrt.setRawContent(data.content());\n\t\t\t\tsrt.setPending(false);\n\t\t\t\tif (null != srt) {\n\t\t\t\t\tpushNext(srt);\n\t\t\t\t\t_state = SyncCompareState.PRELOAD;\n\t\t\t\t\tkickCompare();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private SyncTreeEntry addHash(SliceReferences sr, byte[] hash) {\n\t\tsynchronized (sr) {\n\t\t\tSyncTreeEntry entry = sr.getByHash(new HashEntry(hash));\n\t\t\tif (null == entry) {\n\t\t\t\tentry = new SyncTreeEntry(hash, _decoder);\n\t\t\t\tsr.addHash(hash, entry);\n\t\t\t}\n\t\t\treturn entry;\n\t\t}\n\t}","id":80472,"modified_method":"private SyncTreeEntry addHash(byte[] hash) {\n\t\tsynchronized (this) {\n\t\t\tSyncTreeEntry entry = _hashes.get(new HashEntry(hash));\n\t\t\tif (null == entry) {\n\t\t\t\tentry = new SyncTreeEntry(hash, _decoder);\n\t\t\t\t_hashes.put(new HashEntry(hash), entry);\n\t\t\t}\n\t\t\treturn entry;\n\t\t}\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void removeCallback(CCNSyncHandler syncHandler, ConfigSlice slice) {\n\t\tsynchronized (callbacks) {\n\t\t\tremoveCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tsynchronized (_rootsByTopo) {\n\t\t\tHashMap<ConfigSlice, SliceReferences> topoMap = _rootsByTopo.get(slice.topo);\n\t\t\tif (topoMap != null) {\n\t\t\t\ttopoMap.remove(slice);\n\t\t\t\tif (topoMap.isEmpty()) {\n\t\t\t\t\t_rootsByTopo.remove(slice.topo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":80473,"modified_method":"public void removeCallback(CCNSyncHandler syncHandler, ConfigSlice slice) {\n\t\tsynchronized (callbacks) {\n\t\t\tremoveCallbackInternal(syncHandler, slice);\n\t\t}\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void run() {\n\t\ttry {\n\t\t\tArrayList<ContentName> topos = new ArrayList<ContentName>();\t\t\n\t\t\tdo {\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t_needToCompare = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttopos.clear();\n\t\t\t\tsynchronized (_rootsByTopo) {\n\t\t\t\t\tfor (ContentName topo : _rootsByTopo.keySet()) {\n\t\t\t\t\t\ttopos.add(topo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (ContentName topo : topos) {\n\t\t\t\t\tArrayList<SliceReferences> slicesForTopo = new ArrayList<SliceReferences>();\n\t\t\t\t\tsynchronized (_rootsByTopo) {\n\t\t\t\t\t\tHashMap<ConfigSlice, SliceReferences> hm = _rootsByTopo.get(topo);\n\t\t\t\t\t\tif (null != hm) {\n\t\t\t\t\t\t\tfor (ConfigSlice cs : hm.keySet()) {\n\t\t\t\t\t\t\t\tslicesForTopo.add(hm.get(cs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (SliceReferences sr : slicesForTopo) {\n\t\t\t\t\t\tswitch (sr.getState()) {\n\t\t\t\t\t\tcase BUSY:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INIT:\n\t\t\t\t\t\t\tsynchronized (sr) {\n\t\t\t\t\t\t\t\tif (!sr.hasPending()) {\n\t\t\t\t\t\t\t\t\tsr.setState(SyncCompareState.DONE);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsr.nextRound();\n\t\t\t\t\t\t\t\tArrayList<SyncTreeEntry> entries = sr.getPending();\n\t\t\t\t\t\t\t\tfor (SyncTreeEntry ste : entries) {\n\t\t\t\t\t\t\t\t\tSyncNodeComposite snc = ste.getNodeX();\n\t\t\t\t\t\t\t\t\tif (null != snc) {\n\t\t\t\t\t\t\t\t\t\tsr.addHash(ste.setHash(), ste);\n\t\t\t\t\t\t\t\t\t\tsr.pushNext(ste);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsr.clearPending();\n\t\t\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase PRELOAD:\n\t\t\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t\t\tif (null == sr.getNextHead()) {\n\t\t\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (doPreload(topo, sr, sr.getNextHead())) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsr.setState(SyncCompareState.COMPARE);\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase COMPARE:\n\t\t\t\t\t\t\tdoComparison(topo, sr);\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase DONE:\n\t\t\t\t\t\t\tsynchronized (sr) {\n\t\t\t\t\t\t\t\tif (sr.hasPending()) {\n\t\t\t\t\t\t\t\t\tsr.setState(SyncCompareState.INIT);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\tif (!_keepComparing)\n\t\t\t\t\t\t_needToCompare = true;\n\t\t\t\t}\n\t\t\t} while (_keepComparing);\n\t\t} catch (Exception ex) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, ex);} \t\n\t\t  catch (Error er) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, er);} \n\t}","id":80474,"modified_method":"public void run() {\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t_needToCompare = false;\n\t\t\t\t}\n\t\t\t\tswitch (_state) {\n\t\t\t\tcase BUSY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase INIT:\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (_pendingEntries.size() == 0) {\n\t\t\t\t\t\t\t_state = SyncCompareState.DONE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextRound();\n\t\t\t\t\t\tfor (SyncTreeEntry ste : _pendingEntries) {\n\t\t\t\t\t\t\tSyncNodeComposite snc = ste.getNodeX();\n\t\t\t\t\t\t\tif (null != snc) {\n\t\t\t\t\t\t\t\t_hashes.put(new HashEntry(ste.setHash()), ste);\n\t\t\t\t\t\t\t\tpushNext(ste);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_pendingEntries.clear();\n\t\t\t\t\t\t_state = SyncCompareState.PRELOAD;\n\t\t\t\t\t}\n\t\t\t\t\t// Fall through\n\t\t\t\tcase PRELOAD:\n\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\tif (null == getNextHead()) {\n\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (doPreload(_topo, getNextHead())) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_state = SyncCompareState.COMPARE;\n\t\t\t\t\t// Fall through\n\t\t\t\tcase COMPARE:\n\t\t\t\t\tdoComparison(_topo);\n\t\t\t\t\t// Fall through\n\t\t\t\tcase DONE:\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (_pendingEntries.size() > 0) {\n\t\t\t\t\t\t\t_state = SyncCompareState.INIT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\tif (!_keepComparing)\n\t\t\t\t\t\t_needToCompare = true;\n\t\t\t\t}\n\t\t\t} while (_keepComparing);\n\t\t} catch (Exception ex) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, ex);} \t\n\t\t  catch (Error er) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, er);} \n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void doComparison(ContentName topo, SliceReferences sr) {\nLog.info(\"started compare\");\n\t\tHashMap<ConfigSlice, ArrayList<CCNSyncHandler>> tCallbacks = null;\n\t\t\n\t\tsynchronized(callbacks) {\n\t\t\t// We can't call the callback with locks held so extract what we will call \n\t\t\t// under the lock\n\t\t\ttCallbacks = new HashMap<ConfigSlice, ArrayList<CCNSyncHandler>>(callbacks.size());\n\t\t\tfor (ConfigSlice cs : callbacks.keySet()) {\n\t\t\t\tArrayList<CCNSyncHandler> tal = new ArrayList<CCNSyncHandler>();\n\t\t\t\tfor (CCNSyncHandler csh : callbacks.get(cs)) {\n\t\t\t\t\ttal.add(csh);\n\t\t\t\t}\n\t\t\t\ttCallbacks.put(cs, tal);\n\t\t\t}\n\t\t}\n\t\tdoComparisonWithCallbacks(topo, sr, tCallbacks);\n\t}","id":80475,"modified_method":"private void doComparison(ContentName topo) {\nLog.info(\"started compare\");\n\t\tHashMap<ConfigSlice, ArrayList<CCNSyncHandler>> tCallbacks = null;\n\t\t\n\t\tsynchronized(callbacks) {\n\t\t\t// We can't call the callback with locks held so extract what we will call \n\t\t\t// under the lock\n\t\t\ttCallbacks = new HashMap<ConfigSlice, ArrayList<CCNSyncHandler>>(callbacks.size());\n\t\t\tfor (ConfigSlice cs : callbacks.keySet()) {\n\t\t\t\tArrayList<CCNSyncHandler> tal = new ArrayList<CCNSyncHandler>();\n\t\t\t\tfor (CCNSyncHandler csh : callbacks.get(cs)) {\n\t\t\t\t\ttal.add(csh);\n\t\t\t\t}\n\t\t\t\ttCallbacks.put(cs, tal);\n\t\t\t}\n\t\t}\n\t\tdoComparisonWithCallbacks(topo, tCallbacks);\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * \n\t * @param topo\n\t * @param sr\n\t * @param hash\n\t * @return true if request made\n\t */\n\tprivate boolean requestNode(ContentName topo, SliceReferences sr, byte[] hash) {\n\t\tboolean ret = false;\n\t\tif (null != topo) {\n\t\t\tsynchronized (sr) {\n\t\t\t\tSyncTreeEntry tsrt = addHash(sr, hash);\n\t\t\t\tif (tsrt.getNodeX() == null && !tsrt.getPending()) {\n\t\t\t\t\ttsrt.setPending(true);\n\t\t\t\t\tLog.info(\"requesting node for hash: {0}\", Component.printURI(hash));\n\t\t\t\t\tret = getHash(topo, sr.getSliceHash(), hash);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","id":80476,"modified_method":"/**\n\t * \n\t * @param topo\n\t * @param sr\n\t * @param hash\n\t * @return true if request made\n\t */\n\tprivate boolean requestNode(ContentName topo, byte[] hash) {\n\t\tboolean ret = false;\n\t\tif (null != topo) {\n\t\t\tsynchronized (this) {\n\t\t\t\tSyncTreeEntry tsrt = addHash(hash);\n\t\t\t\tif (tsrt.getNodeX() == null && !tsrt.getPending()) {\n\t\t\t\t\ttsrt.setPending(true);\n\t\t\t\t\tLog.info(\"requesting node for hash: {0}\", Component.printURI(hash));\n\t\t\t\t\tret = getHash(topo, _sliceHash, hash);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void registerCallback(CCNSyncHandler syncHandler, ConfigSlice slice) throws IOException {\n\t\tsynchronized (_rootsByTopo) {\n\t\t\tHashMap<ConfigSlice, SliceReferences> topoMap = _rootsByTopo.get(slice.topo);\n\t\t\tif (null == topoMap) {\n\t\t\t\ttopoMap = new HashMap<ConfigSlice, SliceReferences>();\n\t\t\t}\n\t\t\tbyte[] hash = slice.getHash();\n\t\t\tSliceReferences sr = topoMap.get(slice);\n\t\t\tif (null == sr) {\n\t\t\t\tsr = new SliceReferences(slice.topo, hash);\n\t\t\t\ttopoMap.put(slice, sr);\n\t\t\t\t_rootsByTopo.put(slice.topo, topoMap);\n\t\t\t\taddHash(sr, hash);\n\t\t\t} else {\n\t\t\t\tsynchronized (sr) {\n\t\t\t\t\tSyncTreeEntry ste = sr.getCurrentHead();\n\t\t\t\t\tif (null != ste)\n\t\t\t\t\t\tdoCurrentTreeCallbacks(syncHandler, slice, ste);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsynchronized (callbacks) {\n\t\t\tregisterCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tContentName rootAdvise = new ContentName(slice.topo, Sync.SYNC_ROOT_ADVISE_MARKER, slice.getHash());\n\t\tInterest interest = new Interest(rootAdvise);\n\t\tinterest.scope(1);\n\t\t_handle.registerFilter(rootAdvise, this);\n\t\t_handle.expressInterest(interest, this);\n\t}","id":80477,"modified_method":"public void registerCallback(CCNSyncHandler syncHandler, ConfigSlice slice) throws IOException {\n\t\t_topo = slice.topo;\n\t\t_sliceHash = slice.getHash();\n\t\t_nextRoot = new SyncTreeEntry(_sliceHash, _decoder);\n\t\t_currentRoot = new SyncTreeEntry(_sliceHash, _decoder);\n\t\t_hashes.put(new HashEntry(_sliceHash), _nextRoot);\n\t\tsynchronized (callbacks) {\n\t\t\tregisterCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tContentName rootAdvise = new ContentName(slice.topo, Sync.SYNC_ROOT_ADVISE_MARKER, slice.getHash());\n\t\tInterest interest = new Interest(rootAdvise);\n\t\tinterest.scope(1);\n\t\t_handle.registerFilter(rootAdvise, this);\n\t\t_handle.expressInterest(interest, this);\n\t}","commit_id":"588e1943f4b5772506bfd8e052eaa0101ed400df","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Set<ResolvedInclude> getResolvedIncludes() {\n        return resolvedIncludes;\n    }","id":80478,"modified_method":"public ImmutableSet<ResolvedInclude> getResolvedIncludes() {\n        return resolvedIncludes;\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public List<File> getSourceInputs() {\n        return sourceInputs;\n    }","id":80479,"modified_method":"public ImmutableSet<File> getSourceInputs() {\n        return sourceInputs;\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public CompilationStateSerializer() {\n        fileSerializer = serializerFactory.getSerializerFor(File.class);\n        fileListSerializer = new ListSerializer<File>(fileSerializer);\n        stateMapSerializer = new MapSerializer<File, CompilationFileState>(fileSerializer, new CompilationFileStateSerializer());\n    }","id":80480,"modified_method":"public CompilationStateSerializer() {\n        fileSerializer = serializerFactory.getSerializerFor(File.class);\n        fileSetSerializer = new SetSerializer<File>(fileSerializer);\n        stateMapSerializer = new MapSerializer<File, CompilationFileState>(fileSerializer, new CompilationFileStateSerializer());\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public IncludeDirectives read(Decoder decoder) throws Exception {\n            DefaultIncludeDirectives sourceIncludes = new DefaultIncludeDirectives();\n            sourceIncludes.addAll(includeListSerializer.read(decoder));\n            return sourceIncludes;\n        }","id":80481,"modified_method":"@Override\n        public IncludeDirectives read(Decoder decoder) throws Exception {\n            return new DefaultIncludeDirectives(includeListSerializer.read(decoder));\n        }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public CompilationFileState read(Decoder decoder) throws Exception {\n            CompilationFileState fileState = new CompilationFileState(hashSerializer.read(decoder));\n            fileState.setResolvedIncludes(resolveIncludesSerializer.read(decoder));\n            fileState.setIncludeDirectives(sourceIncludesSerializer.read(decoder));\n            return fileState;\n        }","id":80482,"modified_method":"@Override\n        public CompilationFileState read(Decoder decoder) throws Exception {\n            HashCode hash = hashSerializer.read(decoder);\n            ImmutableSet<ResolvedInclude> resolvedIncludes = ImmutableSet.copyOf(resolveIncludesSerializer.read(decoder));\n            IncludeDirectives includeDirectives = sourceIncludesSerializer.read(decoder);\n            return new CompilationFileState(hash, includeDirectives, resolvedIncludes);\n        }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void write(Encoder encoder, CompilationState value) throws Exception {\n        encoder.writeInt(SERIAL_VERSION);\n        fileListSerializer.write(encoder, value.sourceInputs);\n        stateMapSerializer.write(encoder, value.fileStates);\n    }","id":80483,"modified_method":"@Override\n    public void write(Encoder encoder, CompilationState value) throws Exception {\n        fileSetSerializer.write(encoder, value.getSourceInputs());\n        stateMapSerializer.write(encoder, value.getFileStates());\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public CompilationState read(Decoder decoder) throws Exception {\n        CompilationState compilationState = new CompilationState();\n        int version = decoder.readInt();\n        if (version != SERIAL_VERSION) {\n            return compilationState;\n        }\n\n        compilationState.sourceInputs.addAll(fileListSerializer.read(decoder));\n        compilationState.fileStates.putAll(stateMapSerializer.read(decoder));\n        return compilationState;\n    }","id":80484,"modified_method":"@Override\n    public CompilationState read(Decoder decoder) throws Exception {\n        ImmutableSet<File> sourceInputs = ImmutableSet.copyOf(fileSetSerializer.read(decoder));\n        ImmutableMap<File, CompilationFileState> fileStates = ImmutableMap.copyOf(stateMapSerializer.read(decoder));\n        return new CompilationState(sourceInputs, fileStates);\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public IncludeDirectives parseIncludes(File sourceFile) {\n        IncludeDirectives parsedIncludes = sourceParser.parseSource(sourceFile);\n        if (importAware) {\n            return parsedIncludes;\n        } else {\n            DefaultIncludeDirectives includesOnly = new DefaultIncludeDirectives();\n            includesOnly.addAll(parsedIncludes.getIncludesOnly());\n            return includesOnly;\n        }\n    }","id":80485,"modified_method":"@Override\n    public IncludeDirectives parseIncludes(File sourceFile) {\n        IncludeDirectives parsedIncludes = sourceParser.parseSource(sourceFile);\n        if (importAware) {\n            return parsedIncludes;\n        } else {\n            return new DefaultIncludeDirectives(parsedIncludes.getIncludesOnly());\n        }\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public IncrementalCompilation processSourceFiles(Collection<File> sourceFiles) {\n        CompilationState previousCompileState = previousCompileStateCache.get();\n        final IncrementalCompileFiles result = new IncrementalCompileFiles(previousCompileState);\n\n        for (File sourceFile : sourceFiles) {\n            result.processSource(sourceFile);\n        }\n\n        return new DefaultIncrementalCompilation(result.current, result.getModifiedSources(), result.getRemovedSources(), result.getDiscoveredInputs());\n    }","id":80486,"modified_method":"public IncrementalCompilation processSourceFiles(Collection<File> sourceFiles) {\n        CompilationState previousCompileState = previousCompileStateCache.get();\n        final IncrementalCompileFiles result = new IncrementalCompileFiles(previousCompileState);\n\n        for (File sourceFile : sourceFiles) {\n            result.processSource(sourceFile);\n        }\n\n        return new DefaultIncrementalCompilation(result.current.snapshot(), result.getModifiedSources(), result.getRemovedSources(), result.getDiscoveredInputs());\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean checkChangedAndUpdateState(File file) {\n            boolean changed = false;\n\n            if (processed.containsKey(file)) {\n                return processed.get(file);\n            }\n\n            if (!file.exists()) {\n                return true;\n            }\n\n            // Assume unchanged if we recurse to the same file due to dependency cycle\n            processed.put(file, false);\n\n            CompilationFileState previousState = previous.getState(file);\n            CompilationFileState newState = new CompilationFileState(snapshotter.snapshot(file).getHash());\n\n            if (!sameHash(previousState, newState)) {\n                changed = true;\n                newState.setIncludeDirectives(sourceIncludesParser.parseIncludes(file));\n            } else {\n                newState.setIncludeDirectives(previousState.getIncludeDirectives());\n            }\n\n            SourceIncludesResolver.ResolvedSourceIncludes resolutionResult = resolveIncludes(file, newState.getIncludeDirectives());\n            newState.setResolvedIncludes(resolutionResult.getResolvedIncludes());\n            discoveredInputs.addAll(resolutionResult.getCheckedLocations());\n\n            // Compare the previous resolved includes with resolving now.\n            if (!sameResolved(previousState, newState)) {\n                changed = true;\n            }\n\n            current.setState(file, newState);\n\n            for (ResolvedInclude dep : newState.getResolvedIncludes()) {\n                if (dep.isUnknown()) {\n                    LOGGER.info(\"Cannot determine changed state of included '{}' in source file '{}'. Assuming changed.\", dep.getInclude(), file.getName());\n                    changed = true;\n                } else {\n                    boolean depChanged = checkChangedAndUpdateState(dep.getFile());\n                    changed = changed || depChanged;\n                }\n            }\n\n            processed.put(file, changed);\n\n            return changed;\n        }","id":80487,"modified_method":"public boolean checkChangedAndUpdateState(File file) {\n            boolean changed = false;\n\n            if (processed.containsKey(file)) {\n                return processed.get(file);\n            }\n\n            if (!file.exists()) {\n                return true;\n            }\n\n            // Assume unchanged if we recurse to the same file due to dependency cycle\n            processed.put(file, false);\n\n            CompilationFileState previousState = previous.getState(file);\n            HashCode newHash = snapshotter.snapshot(file).getHash();\n\n            IncludeDirectives includeDirectives;\n            if (!sameHash(previousState, newHash)) {\n                changed = true;\n                includeDirectives = sourceIncludesParser.parseIncludes(file);\n            } else {\n                includeDirectives = previousState.getIncludeDirectives();\n            }\n            SourceIncludesResolver.ResolvedSourceIncludes resolutionResult = resolveIncludes(file, includeDirectives);\n\n            CompilationFileState newState = new CompilationFileState(newHash, includeDirectives, ImmutableSet.copyOf(resolutionResult.getResolvedIncludes()));\n\n            discoveredInputs.addAll(resolutionResult.getCheckedLocations());\n\n            // Compare the previous resolved includes with resolving now.\n            if (!sameResolved(previousState, newState)) {\n                changed = true;\n            }\n\n            current.setState(file, newState);\n\n            for (ResolvedInclude dep : newState.getResolvedIncludes()) {\n                if (dep.isUnknown()) {\n                    LOGGER.info(\"Cannot determine changed state of included '{}' in source file '{}'. Assuming changed.\", dep.getInclude(), file.getName());\n                    changed = true;\n                } else {\n                    boolean depChanged = checkChangedAndUpdateState(dep.getFile());\n                    changed = changed || depChanged;\n                }\n            }\n\n            processed.put(file, changed);\n\n            return changed;\n        }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean sameHash(CompilationFileState previousState, CompilationFileState newState) {\n            return previousState != null && newState.getHash().equals(previousState.getHash());\n        }","id":80488,"modified_method":"private boolean sameHash(CompilationFileState previousState, HashCode newHash) {\n            return previousState != null && newHash.equals(previousState.getHash());\n        }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends NativeCompileSpec> Compiler<T> createIncrementalCompiler(TaskInternal task, Compiler<T> compiler, NativeToolChain toolchain) {\n        return new IncrementalNativeCompiler<T>(task, cacheAccess, fileSnapshotter, compilationStateCacheFactory, compiler, toolchain, directoryFileTreeFactory);\n    }","id":80489,"modified_method":"public <T extends NativeCompileSpec> Compiler<T> createIncrementalCompiler(TaskInternal task, Compiler<T> compiler, NativeToolChain toolchain) {\n        return new IncrementalNativeCompiler<T>(task, fileSnapshotter, compilationStateCacheFactory, compiler, toolchain, directoryFileTreeFactory);\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public IncrementalCompilerBuilder(TaskArtifactStateCacheAccess cacheAccess, FileSnapshotter fileSnapshotter, CompilationStateCacheFactory compilationStateCacheFactory, DirectoryFileTreeFactory directoryFileTreeFactory) {\n        this.cacheAccess = cacheAccess;\n        this.fileSnapshotter = fileSnapshotter;\n        this.compilationStateCacheFactory = compilationStateCacheFactory;\n        this.directoryFileTreeFactory = directoryFileTreeFactory;\n    }","id":80490,"modified_method":"public IncrementalCompilerBuilder(FileSnapshotter fileSnapshotter, CompilationStateCacheFactory compilationStateCacheFactory, DirectoryFileTreeFactory directoryFileTreeFactory) {\n        this.fileSnapshotter = fileSnapshotter;\n        this.compilationStateCacheFactory = compilationStateCacheFactory;\n        this.directoryFileTreeFactory = directoryFileTreeFactory;\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public WorkResult execute(final T spec) {\n        final PersistentStateCache<CompilationState> compileStateCache = compilationStateCacheFactory.create(task.getPath());\n        final IncrementalCompilation compilation = cacheAccess.useCache(\"process source files\", new Factory<IncrementalCompilation>() {\n            public IncrementalCompilation create() {\n                DefaultSourceIncludesParser sourceIncludesParser = new DefaultSourceIncludesParser(sourceParser, importsAreIncludes);\n                IncrementalCompileProcessor processor = createProcessor(compileStateCache, sourceIncludesParser, spec.getIncludeRoots());\n                return processor.processSourceFiles(spec.getSourceFiles());\n            }\n        });\n\n        spec.setSourceFileIncludeDirectives(mapIncludes(spec.getSourceFiles(), compilation.getFinalState()));\n\n        handleDiscoveredInputs(spec, compilation, spec.getDiscoveredInputRecorder());\n\n        WorkResult workResult;\n        if (spec.isIncrementalCompile()) {\n            workResult = doIncrementalCompile(compilation, spec);\n        } else {\n            workResult = doCleanIncrementalCompile(spec);\n        }\n\n        cacheAccess.useCache(\"update compilation state\", new Factory<Void>() {\n            public Void create() {\n                compileStateCache.set(compilation.getFinalState());\n                return null;\n            }\n        });\n\n        return workResult;\n    }","id":80491,"modified_method":"@Override\n    public WorkResult execute(final T spec) {\n        PersistentStateCache<CompilationState> compileStateCache = compilationStateCacheFactory.create(task.getPath());\n        DefaultSourceIncludesParser sourceIncludesParser = new DefaultSourceIncludesParser(sourceParser, importsAreIncludes);\n        IncrementalCompileProcessor processor = createProcessor(compileStateCache, sourceIncludesParser, spec.getIncludeRoots());\n        IncrementalCompilation compilation = processor.processSourceFiles(spec.getSourceFiles());\n\n        spec.setSourceFileIncludeDirectives(mapIncludes(spec.getSourceFiles(), compilation.getFinalState()));\n\n        handleDiscoveredInputs(spec, compilation, spec.getDiscoveredInputRecorder());\n\n        WorkResult workResult;\n        if (spec.isIncrementalCompile()) {\n            workResult = doIncrementalCompile(compilation, spec);\n        } else {\n            workResult = doCleanIncrementalCompile(spec);\n        }\n\n        compileStateCache.set(compilation.getFinalState());\n\n        return workResult;\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"public IncrementalNativeCompiler(TaskInternal task, TaskArtifactStateCacheAccess cacheAccess, FileSnapshotter fileSnapshotter, CompilationStateCacheFactory compilationStateCacheFactory, Compiler<T> delegateCompiler, NativeToolChain toolChain, DirectoryFileTreeFactory directoryFileTreeFactory) {\n        this.task = task;\n        this.cacheAccess = cacheAccess;\n        this.fileSnapshotter = fileSnapshotter;\n        this.compilationStateCacheFactory = compilationStateCacheFactory;\n        this.delegateCompiler = delegateCompiler;\n        this.directoryFileTreeFactory = directoryFileTreeFactory;\n        this.importsAreIncludes = Clang.class.isAssignableFrom(toolChain.getClass()) || Gcc.class.isAssignableFrom(toolChain.getClass());\n    }","id":80492,"modified_method":"public IncrementalNativeCompiler(TaskInternal task, FileSnapshotter fileSnapshotter, CompilationStateCacheFactory compilationStateCacheFactory, Compiler<T> delegateCompiler, NativeToolChain toolChain, DirectoryFileTreeFactory directoryFileTreeFactory) {\n        this.task = task;\n        this.fileSnapshotter = fileSnapshotter;\n        this.compilationStateCacheFactory = compilationStateCacheFactory;\n        this.delegateCompiler = delegateCompiler;\n        this.directoryFileTreeFactory = directoryFileTreeFactory;\n        this.importsAreIncludes = Clang.class.isAssignableFrom(toolChain.getClass()) || Gcc.class.isAssignableFrom(toolChain.getClass());\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public IncludeDirectives parseSource(File sourceFile) {\n        DefaultIncludeDirectives sourceIncludes = new DefaultIncludeDirectives();\n        sourceIncludes.addAll(parseFile(sourceFile));\n        return sourceIncludes;\n    }","id":80493,"modified_method":"@Override\n    public IncludeDirectives parseSource(File sourceFile) {\n        return new DefaultIncludeDirectives(parseFile(sourceFile));\n    }","commit_id":"a74b00a9768ceaca10793168dee4482f6a34c69a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public int run(String[] args) throws Exception {\n    Options opts = new Options();\n    String title = null;\n    if (args.length > 0 && args[0].equalsIgnoreCase(APPLICATION)) {\n      title = APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt = new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(',');\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt = new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(',');\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using 'appId' option.\");\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length > 0 && args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title = APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length > 0 && args[0].equalsIgnoreCase(CONTAINER)) {\n      title = CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode = -1;\n    CommandLine cliParser = null;\n    try {\n      cliParser = new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length != 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode = printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode = printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode = printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates = false;\n        Set<String> appTypes = new HashSet<String>();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types = cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types != null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet<YarnApplicationState> appStates = EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states = cliParser.getOptionValues(APP_STATE_CMD);\n          if (states != null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates = true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length != 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length != 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length != 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length < 3 || args.length > 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs = cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId = signalArgs[0];\n      SignalContainerCommand command =\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length == 2) {\n        command = SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }","id":80494,"modified_method":"@Override\n  public int run(String[] args) throws Exception {\n    Options opts = new Options();\n    String title = null;\n    if (args.length > 0 && args[0].equalsIgnoreCase(APPLICATION)) {\n      title = APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt = new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(',');\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt = new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(',');\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using 'appId' option.\");\n      Option killOpt = new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(' ');\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length > 0 && args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title = APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length > 0 && args[0].equalsIgnoreCase(CONTAINER)) {\n      title = CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode = -1;\n    CommandLine cliParser = null;\n    try {\n      cliParser = new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length != 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode = printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode = printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode = printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates = false;\n        Set<String> appTypes = new HashSet<String>();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types = cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types != null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet<YarnApplicationState> appStates = EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states = cliParser.getOptionValues(APP_STATE_CMD);\n          if (states != null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates = true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length != 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length != 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length < 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length < 3 || args.length > 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs = cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId = signalArgs[0];\n      SignalContainerCommand command =\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length == 2) {\n        command = SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }","commit_id":"e91e8b711c68273460b36557fc37fdfc86be097b","url":"https://github.com/apache/hadoop"},{"original_method":"private String createApplicationCLIHelpMessage() throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    PrintWriter pw = new PrintWriter(baos);\n    pw.println(\"usage: application\");\n    pw.println(\" -appId <Application ID>         Specify Application Id to be operated\");\n    pw.println(\" -appStates <States>             Works with -list to filter applications\");\n    pw.println(\"                                 based on input comma-separated list of\");\n    pw.println(\"                                 application states. The valid application\");\n    pw.println(\"                                 state can be one of the following:\");\n    pw.println(\"                                 ALL,NEW,NEW_SAVING,SUBMITTED,ACCEPTED,RUN\");\n    pw.println(\"                                 NING,FINISHED,FAILED,KILLED\");\n    pw.println(\" -appTypes <Types>               Works with -list to filter applications\");\n    pw.println(\"                                 based on input comma-separated list of\");\n    pw.println(\"                                 application types.\");\n    pw.println(\" -help                           Displays help for all commands.\");\n    pw.println(\" -kill <Application ID>          Kills the application.\");\n    pw.println(\" -list                           List applications. Supports optional use\");\n    pw.println(\"                                 of -appTypes to filter applications based\");\n    pw.println(\"                                 on application type, and -appStates to\");\n    pw.println(\"                                 filter applications based on application\");\n    pw.println(\"                                 state.\");\n    pw.println(\" -movetoqueue <Application ID>   Moves the application to a different\");\n    pw.println(\"                                 queue.\");\n    pw.println(\" -queue <Queue Name>             Works with the movetoqueue command to\");\n    pw.println(\"                                 specify which queue to move an\");\n    pw.println(\"                                 application to.\");\n    pw.println(\" -status <Application ID>        Prints the status of the application.\");\n    pw.println(\" -updatePriority <Priority>      update priority of an application.\");\n    pw.println(\"                                 ApplicationId can be passed using 'appId'\");\n    pw.println(\"                                 option.\");\n    pw.close();\n    String appsHelpStr = baos.toString(\"UTF-8\");\n    return appsHelpStr;\n  }","id":80495,"modified_method":"private String createApplicationCLIHelpMessage() throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    PrintWriter pw = new PrintWriter(baos);\n    pw.println(\"usage: application\");\n    pw.println(\" -appId <Application ID>         Specify Application Id to be operated\");\n    pw.println(\" -appStates <States>             Works with -list to filter applications\");\n    pw.println(\"                                 based on input comma-separated list of\");\n    pw.println(\"                                 application states. The valid application\");\n    pw.println(\"                                 state can be one of the following:\");\n    pw.println(\"                                 ALL,NEW,NEW_SAVING,SUBMITTED,ACCEPTED,RUN\");\n    pw.println(\"                                 NING,FINISHED,FAILED,KILLED\");\n    pw.println(\" -appTypes <Types>               Works with -list to filter applications\");\n    pw.println(\"                                 based on input comma-separated list of\");\n    pw.println(\"                                 application types.\");\n    pw.println(\" -help                           Displays help for all commands.\");\n    pw.println(\" -kill <Application ID>          Kills the application. Set of\");\n    pw.println(\"                                 applications can be provided separated\");\n    pw.println(\"                                 with space\");\n    pw.println(\" -list                           List applications. Supports optional use\");\n    pw.println(\"                                 of -appTypes to filter applications based\");\n    pw.println(\"                                 on application type, and -appStates to\");\n    pw.println(\"                                 filter applications based on application\");\n    pw.println(\"                                 state.\");\n    pw.println(\" -movetoqueue <Application ID>   Moves the application to a different\");\n    pw.println(\"                                 queue.\");\n    pw.println(\" -queue <Queue Name>             Works with the movetoqueue command to\");\n    pw.println(\"                                 specify which queue to move an\");\n    pw.println(\"                                 application to.\");\n    pw.println(\" -status <Application ID>        Prints the status of the application.\");\n    pw.println(\" -updatePriority <Priority>      update priority of an application.\");\n    pw.println(\"                                 ApplicationId can be passed using 'appId'\");\n    pw.println(\"                                 option.\");\n    pw.close();\n    String appsHelpStr = baos.toString(\"UTF-8\");\n    return appsHelpStr;\n  }","commit_id":"e91e8b711c68273460b36557fc37fdfc86be097b","url":"https://github.com/apache/hadoop"},{"original_method":"@Test (timeout = 10000)\n  public void testAppsHelpCommand() throws Exception {\n    ApplicationCLI cli = createAndGetAppCLI();\n    ApplicationCLI spyCli = spy(cli);\n    int result = spyCli.run(new String[] { \"application\", \"-help\" });\n    Assert.assertTrue(result == 0);\n    verify(spyCli).printUsage(any(String.class), any(Options.class));\n    Assert.assertEquals(createApplicationCLIHelpMessage(),\n        sysOutStream.toString());\n\n    sysOutStream.reset();\n    ApplicationId applicationId = ApplicationId.newInstance(1234, 5);\n    result = cli.run(\n        new String[] {\"application\", \"-kill\", applicationId.toString(), \"args\" });\n    verify(spyCli).printUsage(any(String.class), any(Options.class));\n    Assert.assertEquals(createApplicationCLIHelpMessage(),\n        sysOutStream.toString());\n\n    sysOutStream.reset();\n    NodeId nodeId = NodeId.newInstance(\"host0\", 0);\n    result = cli.run(\n        new String[] { \"application\", \"-status\", nodeId.toString(), \"args\" });\n    verify(spyCli).printUsage(any(String.class), any(Options.class));\n    Assert.assertEquals(createApplicationCLIHelpMessage(),\n        sysOutStream.toString());\n  }","id":80496,"modified_method":"@Test (timeout = 10000)\n  public void testAppsHelpCommand() throws Exception {\n    ApplicationCLI cli = createAndGetAppCLI();\n    ApplicationCLI spyCli = spy(cli);\n    int result = spyCli.run(new String[] { \"application\", \"-help\" });\n    Assert.assertTrue(result == 0);\n    verify(spyCli).printUsage(any(String.class), any(Options.class));\n    Assert.assertEquals(createApplicationCLIHelpMessage(),\n        sysOutStream.toString());\n\n    sysOutStream.reset();\n    NodeId nodeId = NodeId.newInstance(\"host0\", 0);\n    result = cli.run(\n        new String[] { \"application\", \"-status\", nodeId.toString(), \"args\" });\n    verify(spyCli).printUsage(any(String.class), any(Options.class));\n    Assert.assertEquals(createApplicationCLIHelpMessage(),\n        sysOutStream.toString());\n  }","commit_id":"e91e8b711c68273460b36557fc37fdfc86be097b","url":"https://github.com/apache/hadoop"},{"original_method":"private void buildOptions() {\n    options = new Options();\n    options.addOption(null, \"host\", true, \"To specify the hostname of the router\");\n    options.addOption(null, \"filename\", true, \"To specify a file to load where a snapshot is saved\");\n    options.addOption(null, \"save\", true, \"To specify where the snapshot downloaded on \" +\n                                          \"hostname --host should be persisted on your disk\");\n    options.addOption(null, \"ids\", false, \"To view all the transaction IDs contained in the snapshot\");\n    options.addOption(null, \"transaction\", true, \"To specify a transaction ID to look for\");\n    options.addOption(null, \"port\", true, \"To specify the port to use. The default value is --port \" +\n                                          Constants.Gateway.DEFAULT_PORT);\n    options.addOption(null, \"help\", false, \"To print this message\");\n  }","id":80497,"modified_method":"private void buildOptions() {\n    options = new Options();\n    options.addOption(null, HOST_OPTION, true, \"To specify the hostname of the router\");\n    options.addOption(null, FILENAME_OPTION, true, \"To specify a file to load a snapshot from in view mode. \" +\n                                                   \"If the host option is specified, filename will be ignored\");\n    options.addOption(null, SAVE_OPTION, true, \"To specify where the snapshot downloaded on hostname --host \" +\n                                               \"should be persisted on your disk when using the view mode\");\n    options.addOption(null, IDS_OPTION, false, \"To view all the transaction IDs contained in the \" +\n                                               \"snapshot when using the view mode\");\n    options.addOption(null, TRANSACTION_OPTION, true, \"To specify a transaction ID. Mandatory in invalidate mode, \" +\n                                                      \"optional in view mode\");\n    options.addOption(null, PORT_OPTION, true, \"To specify the port to use. The default value is --port \" +\n                                               Constants.Gateway.DEFAULT_PORT);\n    options.addOption(null, HELP_OPTION, false, \"To print this message\");\n  }","commit_id":"2295685845d8bed1192aa498b7e65c99b8b56c9d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Parse the arguments from the command line and execute the different modes.\n   * @param args command line arguments\n   * @param conf default configuration\n   * @return True if the arguments where parsed successfully and comply with the expected usage\n   */\n  private boolean parseArgsAndExecMode(String[] args, CConfiguration conf) {\n    CommandLineParser parser = new GnuParser();\n    // Check all the options of the command line\n    try {\n      CommandLine line = parser.parse(options, args);\n      if (line.hasOption(\"help\")) {\n        printUsage(false);\n        return true;\n      }\n\n      switch (this.mode) {\n        case VIEW:\n          if (!line.hasOption(\"host\") && !line.hasOption(\"filename\")) {\n            usage(\"Either specify a hostname to download a new snapshot, \" +\n                  \"or a filename of an existing snapshot.\");\n            return false;\n          }\n          hostname = line.getOptionValue(\"host\");\n          existingFilename = line.getOptionValue(\"filename\");\n          persistingFilename = line.hasOption(\"save\") ? line.getOptionValue(\"save\") : null;\n          showTxids = line.hasOption(\"ids\") ? true : false;\n          txId = line.hasOption(\"transaction\") ? Long.valueOf(line.getOptionValue(\"transaction\")) : null;\n          portNumber = line.hasOption(\"port\") ? Integer.valueOf(line.getOptionValue(\"port\")) :\n                       conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n          // Execute mode\n          executeViewMode();\n          break;\n        case INVALIDATE:\n          if (!line.hasOption(\"host\") || !line.hasOption(\"transaction\")) {\n            usage(\"Specify a host name and a transaction id.\");\n            return false;\n          }\n          hostname = line.getOptionValue(\"host\");\n          portNumber = line.hasOption(\"port\") ? Integer.valueOf(line.getOptionValue(\"port\")) :\n                       conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n          txId = Long.valueOf(line.getOptionValue(\"transaction\"));\n          // Execute mode\n          executeInvalidateMode();\n          break;\n        case RESET:\n          if (!line.hasOption(\"host\")) {\n            usage(\"Specify a host name.\");\n            return false;\n          }\n          hostname = line.getOptionValue(\"host\");\n          portNumber = line.hasOption(\"port\") ? Integer.valueOf(line.getOptionValue(\"port\")) :\n                       conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n          // Execute mode\n          executeResetMode();\n          break;\n        default:\n          printUsage(true);\n          return false;\n      }\n    } catch (ParseException e) {\n      printUsage(true);\n      return false;\n    }\n    return true;\n  }","id":80498,"modified_method":"/**\n   * Parse the arguments from the command line and execute the different modes.\n   * @param args command line arguments\n   * @param conf default configuration\n   * @return true if the arguments were parsed successfully and comply with the expected usage\n   */\n  private boolean parseArgsAndExecMode(String[] args, CConfiguration conf) {\n    CommandLineParser parser = new GnuParser();\n    // Check all the options of the command line\n    try {\n      CommandLine line = parser.parse(options, args);\n      if (line.hasOption(HELP_OPTION)) {\n        printUsage(false);\n        return true;\n      }\n\n      switch (this.mode) {\n        case VIEW:\n          if (!line.hasOption(HOST_OPTION) && !line.hasOption(FILENAME_OPTION)) {\n            usage(\"Either specify a hostname to download a new snapshot, \" +\n                  \"or a filename of an existing snapshot.\");\n            return false;\n          }\n          hostname = line.getOptionValue(HOST_OPTION);\n          existingFilename = line.getOptionValue(FILENAME_OPTION);\n          persistingFilename = line.hasOption(SAVE_OPTION) ? line.getOptionValue(SAVE_OPTION) : null;\n          showTxids = line.hasOption(IDS_OPTION) ? true : false;\n          txId = line.hasOption(TRANSACTION_OPTION) ? Long.valueOf(line.getOptionValue(TRANSACTION_OPTION)) : null;\n          portNumber = line.hasOption(PORT_OPTION) ? Integer.valueOf(line.getOptionValue(PORT_OPTION)) :\n                       conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n          // Execute mode\n          executeViewMode();\n          break;\n        case INVALIDATE:\n          if (!line.hasOption(HOST_OPTION) || !line.hasOption(TRANSACTION_OPTION)) {\n            usage(\"Specify a host name and a transaction id.\");\n            return false;\n          }\n          hostname = line.getOptionValue(HOST_OPTION);\n          portNumber = line.hasOption(PORT_OPTION) ? Integer.valueOf(line.getOptionValue(PORT_OPTION)) :\n                       conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n          txId = Long.valueOf(line.getOptionValue(TRANSACTION_OPTION));\n          // Execute mode\n          executeInvalidateMode();\n          break;\n        case RESET:\n          if (!line.hasOption(HOST_OPTION)) {\n            usage(\"Specify a host name.\");\n            return false;\n          }\n          hostname = line.getOptionValue(HOST_OPTION);\n          portNumber = line.hasOption(PORT_OPTION) ? Integer.valueOf(line.getOptionValue(PORT_OPTION)) :\n                       conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n          // Execute mode\n          executeResetMode();\n          break;\n        default:\n          printUsage(true);\n          return false;\n      }\n    } catch (ParseException e) {\n      printUsage(true);\n      return false;\n    }\n    return true;\n  }","commit_id":"2295685845d8bed1192aa498b7e65c99b8b56c9d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      \n      // always include build all\n      toolbar.addLeftWidget(commands_.buildAll().createToolbarButton());\n      \n      // makefiles get extra build menu entries\n      String type = session_.getSessionInfo().getBuildToolsType();\n      if (type.equals(SessionInfo.BUILD_TOOLS_MAKEFILE))\n      {\n         ToolbarPopupMenu buildMenu = new ToolbarPopupMenu();\n         buildMenu.addItem(commands_.buildAll().createMenuItem(false));\n         buildMenu.addItem(commands_.rebuildAll().createMenuItem(false));\n         buildMenu.addSeparator();\n         buildMenu.addItem(commands_.cleanAll().createMenuItem(false));\n         ToolbarButton buildMenuButton = new ToolbarButton(buildMenu, true);\n         toolbar.addLeftWidget(buildMenuButton);\n      }\n      \n      // packages get additional commands \n      else if (type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n      {\n         ToolbarPopupMenu buildMenu = new ToolbarPopupMenu();\n         buildMenu.addItem(commands_.devtoolsLoadAll().createMenuItem(false));\n         buildMenu.addSeparator();\n         buildMenu.addItem(commands_.buildSourcePackage().createMenuItem(false));\n         buildMenu.addItem(commands_.buildBinaryPackage().createMenuItem(false));\n         buildMenu.addSeparator();\n         buildMenu.addItem(commands_.roxygenizePackage().createMenuItem(false));\n         ToolbarButton buildMenuButton = new ToolbarButton(buildMenu, true);\n         toolbar.addLeftWidget(buildMenuButton);\n         toolbar.addLeftSeparator();\n         toolbar.addLeftWidget(commands_.checkPackage().createToolbarButton());\n      }\n      \n      toolbar.addLeftSeparator();\n      \n      // always include configuration\n      toolbar.addLeftWidget(\n               commands_.buildToolsProjectSetup().createToolbarButton());\n      \n      // stop button (initially hidden)\n      ImageResource stopImage = commands_.interruptR().getImageResource();\n      stopButton_ = new ToolbarButton(stopImage, null);\n      stopButton_.setVisible(false);\n      toolbar.addRightWidget(stopButton_);\n      \n      return toolbar;\n   }","id":80499,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      \n      // always include build all\n      toolbar.addLeftWidget(commands_.buildAll().createToolbarButton());\n      toolbar.addLeftSeparator();\n      \n      // packages get check package\n      String type = session_.getSessionInfo().getBuildToolsType();\n      if (type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n      {\n         toolbar.addLeftWidget(commands_.checkPackage().createToolbarButton());\n         toolbar.addLeftSeparator();\n      }\n      \n      // create more menu\n      ToolbarPopupMenu moreMenu = new ToolbarPopupMenu();\n      if (type.equals(SessionInfo.BUILD_TOOLS_MAKEFILE))\n      {\n         moreMenu.addItem(commands_.rebuildAll().createMenuItem(false));\n         moreMenu.addItem(commands_.cleanAll().createMenuItem(false));\n         moreMenu.addSeparator();\n      }\n      \n      // packages get additional commands \n      else if (type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n      {\n         moreMenu.addItem(commands_.devtoolsLoadAll().createMenuItem(false));\n         moreMenu.addSeparator();\n         moreMenu.addItem(commands_.buildSourcePackage().createMenuItem(false));\n         moreMenu.addItem(commands_.buildBinaryPackage().createMenuItem(false));\n         moreMenu.addSeparator();\n         moreMenu.addItem(commands_.roxygenizePackage().createMenuItem(false));   \n         moreMenu.addSeparator();\n      }\n      moreMenu.addItem(commands_.buildToolsProjectSetup().createMenuItem(false));\n      \n      // add more menu\n      ToolbarButton moreButton = new ToolbarButton(\n                                   \"More\",\n                                   StandardIcons.INSTANCE.more_actions(),\n                                   moreMenu);\n      toolbar.addLeftWidget(moreButton);\n      \n      // stop button (initially hidden)\n      ImageResource stopImage = commands_.interruptR().getImageResource();\n      stopButton_ = new ToolbarButton(stopImage, null);\n      stopButton_.setVisible(false);\n      toolbar.addRightWidget(stopButton_);\n      \n      return toolbar;\n   }","commit_id":"508bc83d512233e463ec386741b0521f9bb3e5c0","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void installStandardUI()\n   {\n      // plot history navigation\n      addLeftWidget(commands_.previousPlot().createToolbarButton());\n      addLeftWidget(commands_.nextPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // popout current plot\n      addLeftWidget(commands_.zoomPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // export commands\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.savePlotAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.savePlotAsPdf().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.copyPlotToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.publishPlotToRPubs().createMenuItem(false));\n      ToolbarButton exportButton = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      addLeftWidget(exportButton);\n      addLeftSeparator();\n      \n      addLeftWidget(commands_.removePlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // clear all plots\n      addLeftWidget(commands_.clearPlots().createToolbarButton());\n      \n      // refresh\n      addRightWidget(commands_.refreshPlot().createToolbarButton());\n   }","id":80500,"modified_method":"private void installStandardUI()\n   {\n      // plot history navigation\n      addLeftWidget(commands_.previousPlot().createToolbarButton());\n      addLeftWidget(commands_.nextPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // popout current plot\n      addLeftWidget(commands_.zoomPlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // export commands\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.savePlotAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.savePlotAsPdf().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.copyPlotToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.publishPlotToRPubs().createMenuItem(false));\n      ToolbarButton exportButton = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      addLeftWidget(exportButton);\n      addLeftSeparator();\n      \n      addLeftWidget(commands_.removePlot().createToolbarButton());\n      addLeftSeparator();\n      \n      // clear all plots\n      addLeftWidget(commands_.clearPlots().createToolbarButton());\n      \n      // refresh\n      addLeftSeparator();\n      addLeftWidget(commands_.refreshPlot().createToolbarButton());\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showOutput(RmdPreviewParams params, boolean enablePublish, \n                          boolean enableDeploy, boolean refresh)\n   {\n      // remember output parameters\n      outputParms_ = params;\n\n      // remember target file (for invoking editor)\n      targetFile_ = FileSystemItem.createFile(params.getTargetFile());\n      \n      // slide navigation (may be null)\n      slideNavigation_ = params.getResult().getSlideNavigation();\n      handlerManager_.fireEvent(new SlideNavigationChangedEvent(slideNavigation_));\n      slideChangeMonitor_.cancel();\n      \n      // file label\n      if (params.isShinyDocument())\n      {\n         fileLabel_.setVisible(false);\n         fileLabelSeparator_.setVisible(false);\n         shinyUrl_ = StringUtil.makeAbsoluteUrl(params.getOutputUrl());\n         isShiny_ = true;\n      }\n      else\n      {\n         fileLabel_.setVisible(true);\n         fileLabelSeparator_.setVisible(true);\n         fileLabel_.setText(FileSystemItem.createFile(\n                                          params.getOutputFile()).getName());\n         isShiny_ = false;\n      }\n      \n      // RPubs\n      boolean showPublish = enablePublish && \n                            params.getResult().isHtml() &&\n                            params.getResult().getFormat() != null &&\n                            params.getResult().getFormat().isSelfContained();\n      publishButton_.setText(params.getResult().getRpubsPublished() ? \n            \"Republish\" : \"Publish\");\n      publishButton_.setVisible(showPublish);\n      publishButtonSeparator_.setVisible(showPublish);\n      \n      // RSConnect\n      boolean showDeploy = enableDeploy && params.isShinyDocument();\n      deployButton_.setVisible(showDeploy);\n      deployButton_.setText(\"Publish\");\n      deployButtonSeparator_.setVisible(showDeploy);\n      \n      // find text box\n      boolean showFind = params.getResult().isHtml() && \n                         !params.getResult().isHtmlPresentation();\n      findTextBox_.setVisible(showFind);\n      findSeparator_.setVisible(showFind);\n      \n      // when refreshing, reapply the current scroll position and anchor\n      scrollPosition_ = refresh ? \n            getScrollPosition() : params.getScrollPosition();\n     \n      // get the URL to load\n      String url = getDocumentUrl();\n\n      // check for an anchor implied by a preview_slide field\n      String anchor = \"\";\n      if (params.getResult().getPreviewSlide() > 0)\n         anchor = String.valueOf(params.getResult().getPreviewSlide());\n            \n      // check for an explicit anchor if there wasn't one implied\n      // by the preview_slide\n      if (anchor.length() == 0)\n         anchor = params.getAnchor();\n      \n      // add the anchor if necessary\n      if (anchor.length() > 0)\n         url += \"#\" + anchor;\n      \n      showUrl(url);\n   }","id":80501,"modified_method":"@Override\n   public void showOutput(RmdPreviewParams params, boolean enablePublish, \n                          boolean enableDeploy, boolean refresh)\n   {\n      // remember output parameters\n      outputParms_ = params;\n\n      // remember target file (for invoking editor)\n      targetFile_ = FileSystemItem.createFile(params.getTargetFile());\n      \n      // slide navigation (may be null)\n      slideNavigation_ = params.getResult().getSlideNavigation();\n      handlerManager_.fireEvent(new SlideNavigationChangedEvent(slideNavigation_));\n      slideChangeMonitor_.cancel();\n      \n      // file label\n      if (params.isShinyDocument())\n      {\n         fileLabel_.setVisible(false);\n         fileLabelSeparator_.setVisible(false);\n         shinyUrl_ = StringUtil.makeAbsoluteUrl(params.getOutputUrl());\n         isShiny_ = true;\n      }\n      else\n      {\n         fileLabel_.setVisible(true);\n         fileLabelSeparator_.setVisible(true);\n         fileLabel_.setText(FileSystemItem.createFile(\n                                          params.getOutputFile()).getName());\n         isShiny_ = false;\n      }\n      \n      // RPubs\n      boolean showPublish = enablePublish && \n                            params.getResult().isHtml() &&\n                            params.getResult().getFormat() != null &&\n                            params.getResult().getFormat().isSelfContained();\n      publishButton_.setText(params.getResult().getRpubsPublished() ? \n            \"Republish\" : \"Publish\");\n      publishButton_.setVisible(showPublish);\n      \n      // RSConnect\n      boolean showDeploy = enableDeploy && params.isShinyDocument();\n      deployButton_.setVisible(showDeploy);\n      deployButton_.setText(\"Publish\");\n      \n      // find text box\n      boolean showFind = params.getResult().isHtml() && \n                         !params.getResult().isHtmlPresentation();\n      findTextBox_.setVisible(showFind);\n      findSeparator_.setVisible(showFind);\n      \n      // when refreshing, reapply the current scroll position and anchor\n      scrollPosition_ = refresh ? \n            getScrollPosition() : params.getScrollPosition();\n     \n      // get the URL to load\n      String url = getDocumentUrl();\n\n      // check for an anchor implied by a preview_slide field\n      String anchor = \"\";\n      if (params.getResult().getPreviewSlide() > 0)\n         anchor = String.valueOf(params.getResult().getPreviewSlide());\n            \n      // check for an explicit anchor if there wasn't one implied\n      // by the preview_slide\n      if (anchor.length() == 0)\n         anchor = params.getAnchor();\n      \n      // add the anchor if necessary\n      if (anchor.length() > 0)\n         url += \"#\" + anchor;\n      \n      showUrl(url);\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void initToolbar (Toolbar toolbar, Commands commands)\n   {\n      slideNavigationMenu_ = new SlideNavigationToolbarMenu(toolbar, \n                                                            400, \n                                                            100,\n                                                            true);\n      \n      fileLabel_ = new ToolbarLabel();\n      fileLabel_.addStyleName(ThemeStyles.INSTANCE.subtitle());\n      fileLabel_.getElement().getStyle().setMarginRight(7, Unit.PX);\n      toolbar.addLeftWidget(fileLabel_);\n      fileLabelSeparator_ = toolbar.addLeftSeparator();\n      ToolbarButton popoutButton = \n            commands.viewerPopout().createToolbarButton();\n      popoutButton.setText(\"Open in Browser\");\n      toolbar.addLeftWidget(popoutButton);\n      publishButtonSeparator_ = toolbar.addLeftSeparator();\n      publishButton_ = commands.publishHTML().createToolbarButton(false);\n      toolbar.addLeftWidget(publishButton_);\n\n      deployButtonSeparator_ = toolbar.addLeftSeparator();\n      deployButton_ = new ToolbarButton(\"Publish\", \n            commands.rsconnectDeploy().getImageResource(), \n            new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent evt)\n         {\n            events_.fireEvent(new RSConnectActionEvent(\n                  RSConnectActionEvent.ACTION_TYPE_DEPLOY, \n                  targetFile_.getPath()));\n         }\n      });\n      toolbar.addLeftWidget(deployButton_);\n\n      findTextBox_ = new FindTextBox(\"Find\");\n      findTextBox_.setIconVisible(true);\n      findTextBox_.setOverrideWidth(120);\n      findTextBox_.getElement().getStyle().setMarginRight(6, Unit.PX);\n      toolbar.addRightWidget(findTextBox_);\n      \n      findTextBox_.addKeyDownHandler(new KeyDownHandler() {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            // enter key triggers a find\n            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n            {\n               event.preventDefault();\n               event.stopPropagation();\n               findInTopic(findTextBox_.getValue().trim(), findTextBox_);\n               findTextBox_.focus();\n            }\n            else if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE)\n            {\n               findTextBox_.setValue(\"\");\n            }       \n         }\n         \n         private void findInTopic(String term, CanFocus findInputSource)\n         {\n            // get content window\n            WindowEx contentWindow = getFrame().getWindow();\n            if (contentWindow == null)\n               return;\n                \n            if (!contentWindow.find(term, false, false, true, false))\n            {\n               RStudioGinjector.INSTANCE.getGlobalDisplay().showMessage(\n                     MessageDialog.INFO,\n                     \"Find in Page\", \n                     \"No occurences found\",\n                     findInputSource);\n            }     \n         }\n         \n      });\n      toolbar.addRightWidget(findTextBox_);\n      findSeparator_ = toolbar.addRightSeparator();\n      \n      toolbar.addRightWidget(commands.viewerRefresh().createToolbarButton());\n   }","id":80502,"modified_method":"@Override\n   protected void initToolbar (Toolbar toolbar, Commands commands)\n   {\n      slideNavigationMenu_ = new SlideNavigationToolbarMenu(toolbar, \n                                                            400, \n                                                            100,\n                                                            true);\n      \n      fileLabel_ = new ToolbarLabel();\n      fileLabel_.addStyleName(ThemeStyles.INSTANCE.subtitle());\n      fileLabel_.getElement().getStyle().setMarginRight(7, Unit.PX);\n      toolbar.addLeftWidget(fileLabel_);\n      fileLabelSeparator_ = toolbar.addLeftSeparator();\n      ToolbarButton popoutButton = \n            commands.viewerPopout().createToolbarButton();\n      popoutButton.setText(\"Open in Browser\");\n      toolbar.addLeftWidget(popoutButton);\n\n      findTextBox_ = new FindTextBox(\"Find\");\n      findTextBox_.setIconVisible(true);\n      findTextBox_.setOverrideWidth(120);\n      findTextBox_.getElement().getStyle().setMarginRight(6, Unit.PX);\n      findSeparator_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(findTextBox_);\n      \n      findTextBox_.addKeyDownHandler(new KeyDownHandler() {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            // enter key triggers a find\n            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n            {\n               event.preventDefault();\n               event.stopPropagation();\n               findInTopic(findTextBox_.getValue().trim(), findTextBox_);\n               findTextBox_.focus();\n            }\n            else if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE)\n            {\n               findTextBox_.setValue(\"\");\n            }       \n         }\n         \n         private void findInTopic(String term, CanFocus findInputSource)\n         {\n            // get content window\n            WindowEx contentWindow = getFrame().getWindow();\n            if (contentWindow == null)\n               return;\n                \n            if (!contentWindow.find(term, false, false, true, false))\n            {\n               RStudioGinjector.INSTANCE.getGlobalDisplay().showMessage(\n                     MessageDialog.INFO,\n                     \"Find in Page\", \n                     \"No occurences found\",\n                     findInputSource);\n            }     \n         }\n         \n      });\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands.viewerRefresh().createToolbarButton());\n      \n      publishButton_ = commands.publishHTML().createToolbarButton(false);\n      toolbar.addRightWidget(publishButton_);\n\n      deployButton_ = new ToolbarButton(\"Publish\", \n            commands.rsconnectDeploy().getImageResource(), \n            new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent evt)\n         {\n            events_.fireEvent(new RSConnectActionEvent(\n                  RSConnectActionEvent.ACTION_TYPE_DEPLOY, \n                  targetFile_.getPath()));\n         }\n      });\n      toolbar.addRightWidget(deployButton_);\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showApp(ShinyApplicationParams params, boolean showDeploy)\n   {\n      appParams_ = params;\n\n      deployButtonSeparator_.setVisible(showDeploy);\n      deployButton_.setVisible(showDeploy);\n         \n      String url = params.getUrl();\n      \n      // ensure that we display a full url in server mode\n      if (!url.startsWith(\"http\"))\n         url = GWT.getHostPageBaseURL() + url;\n      urlBox_.setText(url);\n\n      showUrl(url);\n   }","id":80503,"modified_method":"@Override\n   public void showApp(ShinyApplicationParams params, boolean showDeploy)\n   {\n      appParams_ = params;\n\n      deployButton_.setVisible(showDeploy);\n         \n      String url = params.getUrl();\n      \n      // ensure that we display a full url in server mode\n      if (!url.startsWith(\"http\"))\n         url = GWT.getHostPageBaseURL() + url;\n      urlBox_.setText(url);\n\n      showUrl(url);\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override \n   protected void initToolbar(Toolbar toolbar, Commands commands)\n   {\n      urlBox_ = new Label(\"\");\n      Style style = urlBox_.getElement().getStyle();\n      style.setColor(\"#606060\");\n      urlBox_.addStyleName(ThemeStyles.INSTANCE.selectableText());\n      urlBox_.getElement().getStyle().setMarginRight(7, Unit.PX);\n      toolbar.addLeftWidget(urlBox_);\n      toolbar.addLeftSeparator();  \n\n      ToolbarButton popoutButton = \n            commands.viewerPopout().createToolbarButton();\n      popoutButton.setText(\"Open in Browser\");\n      toolbar.addLeftWidget(popoutButton);\n\n      deployButtonSeparator_ = toolbar.addLeftSeparator();\n      deployButton_ = new ToolbarButton(\"Publish\", \n            commands.rsconnectDeploy().getImageResource(), \n            new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent evt)\n         {\n            if (appParams_ != null)\n            {\n               // we initiate deployment from a specific file; choose server.R\n               // (it's okay if it doesn't exist since we're just going to \n               // deploy its parent)\n               String deployPath = appParams_.getPath();\n               if (!deployPath.endsWith(\"/\"))\n                  deployPath += \"/\";\n               deployPath += \"server.R\";\n               events_.fireEvent(new RSConnectActionEvent(\n                     RSConnectActionEvent.ACTION_TYPE_DEPLOY,\n                     deployPath));\n            }\n         }\n      });\n      toolbar.addLeftWidget(deployButton_);\n\n      ToolbarButton refreshButton = \n            commands.reloadShinyApp().createToolbarButton();\n      refreshButton.setLeftImage(commands.viewerRefresh().getImageResource());\n      refreshButton.getElement().getStyle().setMarginTop(2, Unit.PX);\n      toolbar.addRightWidget(refreshButton);\n   }","id":80504,"modified_method":"@Override \n   protected void initToolbar(Toolbar toolbar, Commands commands)\n   {\n      urlBox_ = new Label(\"\");\n      Style style = urlBox_.getElement().getStyle();\n      style.setColor(\"#606060\");\n      urlBox_.addStyleName(ThemeStyles.INSTANCE.selectableText());\n      urlBox_.getElement().getStyle().setMarginRight(7, Unit.PX);\n      toolbar.addLeftWidget(urlBox_);\n      toolbar.addLeftSeparator();  \n\n      ToolbarButton popoutButton = \n            commands.viewerPopout().createToolbarButton();\n      popoutButton.setText(\"Open in Browser\");\n      toolbar.addLeftWidget(popoutButton);\n\n      toolbar.addLeftSeparator();\n      ToolbarButton refreshButton = \n            commands.reloadShinyApp().createToolbarButton();\n      refreshButton.setLeftImage(commands.viewerRefresh().getImageResource());\n      refreshButton.getElement().getStyle().setMarginTop(1, Unit.PX);\n      toolbar.addLeftWidget(refreshButton);\n      \n      deployButton_ = new ToolbarButton(\"Publish\", \n            commands.rsconnectDeploy().getImageResource(), \n            new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent evt)\n         {\n            if (appParams_ != null)\n            {\n               // we initiate deployment from a specific file; choose server.R\n               // (it's okay if it doesn't exist since we're just going to \n               // deploy its parent)\n               String deployPath = appParams_.getPath();\n               if (!deployPath.endsWith(\"/\"))\n                  deployPath += \"/\";\n               deployPath += \"server.R\";\n               events_.fireEvent(new RSConnectActionEvent(\n                     RSConnectActionEvent.ACTION_TYPE_DEPLOY,\n                     deployPath));\n            }\n         }\n      });\n      toolbar.addRightWidget(deployButton_);\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      toolbar_ = new Toolbar();\n      \n      // add html widget buttons\n      toolbar_.addLeftWidget(commands_.viewerBack().createToolbarButton());\n      toolbar_.addLeftWidget(commands_.viewerForward().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerZoom().createToolbarButton());\n      \n      // export commands\n      exportButtonSeparator_ = toolbar_.addLeftSeparator();\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.viewerSaveAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.viewerCopyToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerSaveAsWebPage().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerPublishToRPubs().createMenuItem(false));\n      \n      exportButton_ = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      toolbar_.addLeftWidget(exportButton_);  \n      exportButton_.setVisible(false);\n      exportButtonSeparator_.setVisible(false);\n      \n      // add publish button \n      publishButtonSeparator_ = toolbar_.addLeftSeparator();\n      publishButton_ = commands_.publishHTML().createToolbarButton(false);\n      toolbar_.addLeftWidget(publishButton_);\n      publishButtonSeparator_.setVisible(false);\n      publishButton_.setVisible(false);\n     \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClear().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClearAll().createToolbarButton());\n      \n      toolbar_.addRightWidget(commands_.viewerStop().createToolbarButton());\n      toolbar_.addRightSeparator();\n      toolbar_.addRightWidget(commands_.viewerPopout().createToolbarButton());\n      toolbar_.addRightSeparator();\n      toolbar_.addRightWidget(commands_.viewerRefresh().createToolbarButton());\n      return toolbar_;\n   }","id":80505,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      toolbar_ = new Toolbar();\n      \n      // add html widget buttons\n      toolbar_.addLeftWidget(commands_.viewerBack().createToolbarButton());\n      toolbar_.addLeftWidget(commands_.viewerForward().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerZoom().createToolbarButton());\n      \n      // export commands\n      exportButtonSeparator_ = toolbar_.addLeftSeparator();\n      ToolbarPopupMenu exportMenu = new ToolbarPopupMenu();\n      exportMenu.addItem(commands_.viewerSaveAsImage().createMenuItem(false));\n      exportMenu.addItem(commands_.viewerCopyToClipboard().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerSaveAsWebPage().createMenuItem(false));\n      exportMenu.addSeparator();\n      exportMenu.addItem(commands_.viewerPublishToRPubs().createMenuItem(false));\n      \n      exportButton_ = new ToolbarButton(\n            \"Export\", StandardIcons.INSTANCE.export_menu(),\n            exportMenu);\n      toolbar_.addLeftWidget(exportButton_);  \n      exportButton_.setVisible(false);\n      exportButtonSeparator_.setVisible(false);\n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClear().createToolbarButton());\n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerClearAll().createToolbarButton());\n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerRefresh().createToolbarButton());\n     \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerPopout().createToolbarButton());\n     \n      \n      toolbar_.addLeftSeparator();\n      toolbar_.addLeftWidget(commands_.viewerStop().createToolbarButton());\n     \n      // add publish button \n      publishButton_ = commands_.publishHTML().createToolbarButton(false);\n      toolbar_.addRightWidget(publishButton_);\n      publishButton_.setVisible(false);\n      \n      return toolbar_;\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void previewRmd(RmdPreviewParams params)\n   {\n      navigate(params.getOutputUrl(), true);\n      publishButton_.setVisible(!params.isShinyDocument());\n      publishButtonSeparator_.setVisible(!params.isShinyDocument());\n      if (!params.isShinyDocument())\n         publishButton_.setText(params.getResult().getRpubsPublished() ? \n               \"Republish\" : \"Publish\");\n      rmdPreviewParams_ = params;\n      toolbar_.invalidateSeparators();\n   }","id":80506,"modified_method":"@Override\n   public void previewRmd(RmdPreviewParams params)\n   {\n      navigate(params.getOutputUrl(), true);\n      publishButton_.setVisible(!params.isShinyDocument());\n      if (!params.isShinyDocument())\n         publishButton_.setText(params.getResult().getRpubsPublished() ? \n               \"Republish\" : \"Publish\");\n      rmdPreviewParams_ = params;\n      toolbar_.invalidateSeparators();\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void navigate(String url)\n   {\n      navigate(url, false);\n      publishButton_.setVisible(false);\n      publishButtonSeparator_.setVisible(false);\n      rmdPreviewParams_ = null;\n   }","id":80507,"modified_method":"@Override\n   public void navigate(String url)\n   {\n      navigate(url, false);\n      publishButton_.setVisible(false);\n      rmdPreviewParams_ = null;\n   }","commit_id":"089d2460b0581e9dc0b0e5fb287f8fe658172081","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar(TextFileType fileType)\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n       \n      toolbar.addLeftWidget(commands_.saveSourceDoc().createToolbarButton());\n      sourceOnSave_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(sourceOnSave_);\n      srcOnSaveLabel_.getElement().getStyle().setMarginRight(9, Unit.PX);\n      toolbar.addLeftWidget(srcOnSaveLabel_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.checkSpelling().createToolbarButton());\n      \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(createCodeTransformMenuButton());\n      \n      texSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(texToolbarButton_ = createLatexFormatButton());\n      \n      ToolbarPopupMenu helpMenu = new ToolbarPopupMenu();\n      helpMenu.addItem(commands_.usingRMarkdownHelp().createMenuItem(false));\n      helpMenu.addItem(commands_.authoringRPresentationsHelp().createMenuItem(false));\n      helpMenu.addSeparator();\n      helpMenu.addItem(commands_.markdownHelp().createMenuItem(false));\n      helpMenuButton_ = new ToolbarButton(null, \n                                          StandardIcons.INSTANCE.help(), \n                                          helpMenu);\n      toolbar.addLeftWidget(helpMenuButton_);\n      toolbar.addLeftWidget(rcppHelpButton_ = commands_.rcppHelp().createToolbarButton());\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(previewHTMLButton_ = commands_.previewHTML().createToolbarButton());\n      toolbar.addLeftWidget(knitDocumentButton_ = commands_.knitDocument().createToolbarButton());\n      toolbar.addLeftWidget(compilePdfButton_ = commands_.compilePDF().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.synctexSearch().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(editRmdFormatButton_ = commands_.editRmdFormatOptions().createToolbarButton(false));\n      rmdFormatButton_ = new ToolbarPopupMenuButton();\n      rmdFormatButton_.setText(\"Format\");\n      toolbar.addLeftWidget(rmdFormatButton_);\n\n      toolbar.addRightWidget(runButton_ = commands_.executeCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(runLastButton_ = commands_.executeLastCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      final String SOURCE_BUTTON_TITLE = \"Source the active document\"; \n      \n      sourceButton_ = new ToolbarButton(\n            \"Source\", \n            commands_.sourceActiveDocument().getImageResource(), \n            new ClickHandler() \n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (uiPrefs_.sourceWithEcho().getValue())\n                     commands_.sourceActiveDocumentWithEcho().execute();\n                  else\n                     commands_.sourceActiveDocument().execute();\n               }\n            });\n      \n      sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n      toolbar.addRightWidget(sourceButton_);\n      \n      uiPrefs_.sourceWithEcho().addValueChangeHandler(\n                                       new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            if (event.getValue())\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE + \" (with echo)\");\n            else\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n         }\n      });\n            \n      ToolbarPopupMenu sourceMenu = new ToolbarPopupMenu();\n      sourceMenu.addItem(commands_.sourceActiveDocument().createMenuItem(false));\n      sourceMenu.addItem(commands_.sourceActiveDocumentWithEcho().createMenuItem(false));\n      sourceMenu.addSeparator();\n      sourceMenu.addItem(commands_.compileNotebook().createMenuItem(false));\n      \n      sourceMenuButton_ = new ToolbarButton(sourceMenu, true);\n      toolbar.addRightWidget(sourceMenuButton_);  \n\n      toolbar.addRightSeparator();\n     \n      ToolbarPopupMenu chunksMenu = new ToolbarPopupMenu();\n      chunksMenu.addItem(commands_.insertChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.jumpTo().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeCurrentChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeNextChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeAllCode().createMenuItem(false));\n      chunksButton_ = new ToolbarButton(\n                       \"Chunks\",  \n                       StandardIcons.INSTANCE.chunk_menu(), \n                       chunksMenu, \n                       true);\n      toolbar.addRightWidget(chunksButton_);\n      \n      ToolbarPopupMenu shinyLaunchMenu = shinyViewerMenu_;\n      shinyLaunchButton_ = new ToolbarButton(\n                       \"\", \n                       StandardIcons.INSTANCE.viewer_window(),\n                       shinyLaunchMenu, \n                       true);\n      shinyLaunchButton_.setVisible(false);\n      toolbar.addRightWidget(shinyLaunchButton_);\n      return toolbar;\n   }","id":80508,"modified_method":"private Toolbar createToolbar(TextFileType fileType)\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n       \n      toolbar.addLeftWidget(commands_.saveSourceDoc().createToolbarButton());\n      sourceOnSave_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(sourceOnSave_);\n      srcOnSaveLabel_.getElement().getStyle().setMarginRight(9, Unit.PX);\n      toolbar.addLeftWidget(srcOnSaveLabel_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.checkSpelling().createToolbarButton());\n      \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(createCodeTransformMenuButton());\n      \n      texSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(texToolbarButton_ = createLatexFormatButton());\n      \n      ToolbarPopupMenu helpMenu = new ToolbarPopupMenu();\n      helpMenu.addItem(commands_.usingRMarkdownHelp().createMenuItem(false));\n      helpMenu.addItem(commands_.authoringRPresentationsHelp().createMenuItem(false));\n      helpMenu.addSeparator();\n      helpMenu.addItem(commands_.markdownHelp().createMenuItem(false));\n      helpMenuButton_ = new ToolbarButton(null, \n                                          StandardIcons.INSTANCE.help(), \n                                          helpMenu);\n      toolbar.addLeftWidget(helpMenuButton_);\n      toolbar.addLeftWidget(rcppHelpButton_ = commands_.rcppHelp().createToolbarButton());\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(previewHTMLButton_ = commands_.previewHTML().createToolbarButton());\n      toolbar.addLeftWidget(knitDocumentButton_ = commands_.knitDocument().createToolbarButton());\n      toolbar.addLeftWidget(compilePdfButton_ = commands_.compilePDF().createToolbarButton());\n      rmdFormatButton_ = new ToolbarPopupMenuButton();\n      rmdFormatButton_.setText(\"Format\");\n      toolbar.addLeftWidget(rmdFormatButton_);\n      toolbar.addLeftWidget(editRmdFormatButton_ = commands_.editRmdFormatOptions().createToolbarButton(false));\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.synctexSearch().createToolbarButton());\n\n      toolbar.addRightWidget(runButton_ = commands_.executeCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(runLastButton_ = commands_.executeLastCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      final String SOURCE_BUTTON_TITLE = \"Source the active document\"; \n      \n      sourceButton_ = new ToolbarButton(\n            \"Source\", \n            commands_.sourceActiveDocument().getImageResource(), \n            new ClickHandler() \n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (uiPrefs_.sourceWithEcho().getValue())\n                     commands_.sourceActiveDocumentWithEcho().execute();\n                  else\n                     commands_.sourceActiveDocument().execute();\n               }\n            });\n      \n      sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n      toolbar.addRightWidget(sourceButton_);\n      \n      uiPrefs_.sourceWithEcho().addValueChangeHandler(\n                                       new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            if (event.getValue())\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE + \" (with echo)\");\n            else\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n         }\n      });\n            \n      ToolbarPopupMenu sourceMenu = new ToolbarPopupMenu();\n      sourceMenu.addItem(commands_.sourceActiveDocument().createMenuItem(false));\n      sourceMenu.addItem(commands_.sourceActiveDocumentWithEcho().createMenuItem(false));\n      sourceMenu.addSeparator();\n      sourceMenu.addItem(commands_.compileNotebook().createMenuItem(false));\n      \n      sourceMenuButton_ = new ToolbarButton(sourceMenu, true);\n      toolbar.addRightWidget(sourceMenuButton_);  \n\n      toolbar.addRightSeparator();\n     \n      ToolbarPopupMenu chunksMenu = new ToolbarPopupMenu();\n      chunksMenu.addItem(commands_.insertChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.jumpTo().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeCurrentChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeNextChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeAllCode().createMenuItem(false));\n      chunksButton_ = new ToolbarButton(\n                       \"Chunks\",  \n                       StandardIcons.INSTANCE.chunk_menu(), \n                       chunksMenu, \n                       true);\n      toolbar.addRightWidget(chunksButton_);\n      \n      ToolbarPopupMenu shinyLaunchMenu = shinyViewerMenu_;\n      shinyLaunchButton_ = new ToolbarButton(\n                       \"\", \n                       StandardIcons.INSTANCE.viewer_window(),\n                       shinyLaunchMenu, \n                       true);\n      shinyLaunchButton_.setVisible(false);\n      toolbar.addRightWidget(shinyLaunchButton_);\n      return toolbar;\n   }","commit_id":"8b6e6191bc1473f21077328905afd83f358cc317","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void configure()\n   {\n      bind(EventBus.class).in(Singleton.class) ;\n      bind(Session.class).in(Singleton.class) ;\n      bind(Projects.class).in(Singleton.class);\n      bind(Satellite.class).in(Singleton.class);\n      bind(SatelliteManager.class).in(Singleton.class);\n      bind(AskPassManager.class).in(Singleton.class);\n      bind(WorkbenchContext.class).asEagerSingleton();\n      bind(WorkbenchListManager.class).asEagerSingleton();\n      bind(ApplicationQuit.class).asEagerSingleton();\n      bind(ApplicationInterrupt.class).asEagerSingleton();\n      bind(ClientStateUpdater.class).asEagerSingleton();\n      bind(ConsoleProcessFactory.class).asEagerSingleton();\n      bind(RnwWeaveRegistry.class).asEagerSingleton();\n      bind(LatexProgramRegistry.class).asEagerSingleton();\n      bind(Commands.class).in(Singleton.class);\n      bind(DefaultCRANMirror.class).in(Singleton.class);\n      bind(ChooseFile.class).in(Singleton.class);\n      bind(ConsoleDispatcher.class).in(Singleton.class);\n      bind(FileTypeCommands.class).in(Singleton.class);\n      bind(Synctex.class).in(Singleton.class);\n      bind(PDFViewer.class).in(Singleton.class);\n      bind(HTMLPreview.class).in(Singleton.class);      \n      bind(BreakpointManager.class).asEagerSingleton();\n      bind(DebugCommander.class).asEagerSingleton();\n\n      bind(ApplicationView.class).to(ApplicationWindow.class)\n            .in(Singleton.class) ;\n      \n      bind(VCSApplicationView.class).to(VCSApplicationWindow.class)\n            .in(Singleton.class);\n      bind(ReviewPresenter.class).to(ReviewPresenterImpl.class);\n      \n      bind(PDFViewerApplicationView.class).to(PDFViewerApplicationWindow.class);\n      bind(HTMLPreviewApplicationView.class).to(HTMLPreviewApplicationWindow.class);\n      \n      bind(Server.class).to(RemoteServer.class) ;\n      bind(WorkbenchServerOperations.class).to(RemoteServer.class) ;\n\n      bind(EditingTargetSource.class).to(EditingTargetSource.Impl.class);\n\n      // Bind workbench views\n      bindPane(\"Console\", ConsolePane.class); // eager loaded\n      bind(Source.Display.class).to(SourcePane.class);\n      bind(History.Display.class).to(HistoryPane.class);\n      bind(Data.Display.class).to(DataPane.class);\n      bind(Files.Display.class).to(FilesPane.class);\n      bind(Plots.Display.class).to(PlotsPane.class);\n      bind(Packages.Display.class).to(PackagesPane.class);\n      bind(Help.Display.class).to(HelpPane.class);\n      bind(Edit.Display.class).to(EditView.class);\n      bind(GitPresenter.Display.class).to(GitPane.class);\n      bind(SVNPresenter.Display.class).to(SVNPane.class);\n      bind(BuildPresenter.Display.class).to(BuildPane.class);\n      bind(Presentation.Display.class).to(PresentationPane.class);\n      bind(EnvironmentPresenter.Display.class).to(EnvironmentPane.class);\n      bind(ViewerPresenter.Display.class).to(ViewerPane.class);\n      bind(Ignore.Display.class).to(IgnoreDialog.class);\n      bind(CompilePdfOutputPresenter.Display.class).to(CompilePdfOutputPane.class);\n      bind(FindOutputPresenter.Display.class).to(FindOutputPane.class);\n      bind(SourceCppOutputPresenter.Display.class).to(SourceCppOutputPane.class);\n      bindTab(\"History\", HistoryTab.class);\n      bindTab(\"Data\", DataTab.class);\n      bindTab(\"Files\", FilesTab.class);\n      bindTab(\"Plots\", PlotsTab.class);\n      bindTab(\"Packages\", PackagesTab.class);\n      bindTab(\"Help\", HelpTab.class);\n      bindTab(\"VCS\", VCSTab.class);\n      bindTab(\"Build\", BuildTab.class);\n      bindTab(\"Presentation\", PresentationTab.class);\n      bindTab(\"Environment\", EnvironmentTab.class);\n      bindTab(\"Viewer\", ViewerTab.class);\n      bindTab(\"Compile PDF\", CompilePdfOutputTab.class);\n      bindTab(\"Find\", FindOutputTab.class);\n      bindTab(\"Source Cpp\", SourceCppOutputTab.class);\n\n      bind(Shell.Display.class).to(ShellPane.class) ;\n           \n      bind(HelpSearch.Display.class).to(HelpSearchWidget.class) ;\n      bind(CodeSearch.Display.class).to(CodeSearchWidget.class);\n\n      bind(GitReviewPresenter.Display.class).to(GitReviewPanel.class);\n      bind(SVNReviewPresenter.Display.class).to(SVNReviewPanel.class);\n      bind(LineTablePresenter.Display.class).to(LineTableView.class);\n      bind(HistoryPresenter.DisplayBuilder.class).to(\n                                                    HistoryPanel.Builder.class);\n      \n      bind(PDFViewerPresenter.Display.class).to(PDFViewerPanel.class);\n      bind(HTMLPreviewPresenter.Display.class).to(HTMLPreviewPanel.class);\n      \n      bind(GlobalDisplay.class)\n            .to(DefaultGlobalDisplay.class)\n            .in(Singleton.class) ;\n\n      bind(ApplicationServerOperations.class).to(RemoteServer.class) ;\n      bind(ChooseFileServerOperations.class).to(RemoteServer.class) ;\n      bind(CodeToolsServerOperations.class).to(RemoteServer.class) ;\n      bind(ConsoleServerOperations.class).to(RemoteServer.class) ;\n      bind(SourceServerOperations.class).to(RemoteServer.class) ;\n      bind(DataServerOperations.class).to(RemoteServer.class);\n      bind(FilesServerOperations.class).to(RemoteServer.class) ;\n      bind(HistoryServerOperations.class).to(RemoteServer.class) ;\n      bind(PlotsServerOperations.class).to(RemoteServer.class) ;\n      bind(PackagesServerOperations.class).to(RemoteServer.class) ;\n      bind(HelpServerOperations.class).to(RemoteServer.class) ;\n      bind(EditServerOperations.class).to(RemoteServer.class) ;\n      bind(MirrorsServerOperations.class).to(RemoteServer.class);\n      bind(VCSServerOperations.class).to(RemoteServer.class);\n      bind(GitServerOperations.class).to(RemoteServer.class);\n      bind(SVNServerOperations.class).to(RemoteServer.class);\n      bind(PrefsServerOperations.class).to(RemoteServer.class);\n      bind(ProjectsServerOperations.class).to(RemoteServer.class);\n      bind(CodeSearchServerOperations.class).to(RemoteServer.class);\n      bind(WorkbenchListsServerOperations.class).to(RemoteServer.class);\n      bind(CryptoServerOperations.class).to(RemoteServer.class);\n      bind(TexServerOperations.class).to(RemoteServer.class);\n      bind(SpellingServerOperations.class).to(RemoteServer.class);\n      bind(CompilePdfServerOperations.class).to(RemoteServer.class);\n      bind(FindInFilesServerOperations.class).to(RemoteServer.class);\n      bind(SynctexServerOperations.class).to(RemoteServer.class);\n      bind(HTMLPreviewServerOperations.class).to(RemoteServer.class);\n      bind(ShinyServerOperations.class).to(RemoteServer.class);\n      bind(RPubsServerOperations.class).to(RemoteServer.class);\n      bind(BuildServerOperations.class).to(RemoteServer.class);\n      bind(PresentationServerOperations.class).to(RemoteServer.class);\n      bind(EnvironmentServerOperations.class).to(RemoteServer.class);\n      bind(DebuggingServerOperations.class).to(RemoteServer.class);\n      bind(MetaServerOperations.class).to(RemoteServer.class);\n\n      bind(WorkbenchMainView.class).to(WorkbenchScreen.class) ;\n\n      bind(DocDisplay.class).to(AceEditor.class);\n   }","id":80509,"modified_method":"@Override\n   protected void configure()\n   {\n      bind(EventBus.class).in(Singleton.class) ;\n      bind(Session.class).in(Singleton.class) ;\n      bind(Projects.class).in(Singleton.class);\n      bind(Satellite.class).in(Singleton.class);\n      bind(SatelliteManager.class).in(Singleton.class);\n      bind(AskPassManager.class).in(Singleton.class);\n      bind(WorkbenchContext.class).asEagerSingleton();\n      bind(WorkbenchListManager.class).asEagerSingleton();\n      bind(ApplicationQuit.class).asEagerSingleton();\n      bind(ApplicationInterrupt.class).asEagerSingleton();\n      bind(ClientStateUpdater.class).asEagerSingleton();\n      bind(ConsoleProcessFactory.class).asEagerSingleton();\n      bind(RnwWeaveRegistry.class).asEagerSingleton();\n      bind(LatexProgramRegistry.class).asEagerSingleton();\n      bind(Commands.class).in(Singleton.class);\n      bind(DefaultCRANMirror.class).in(Singleton.class);\n      bind(ChooseFile.class).in(Singleton.class);\n      bind(ConsoleDispatcher.class).in(Singleton.class);\n      bind(FileTypeCommands.class).in(Singleton.class);\n      bind(Synctex.class).in(Singleton.class);\n      bind(PDFViewer.class).in(Singleton.class);\n      bind(HTMLPreview.class).in(Singleton.class);      \n      bind(BreakpointManager.class).asEagerSingleton();\n      bind(DebugCommander.class).asEagerSingleton();\n\n      bind(ApplicationView.class).to(ApplicationWindow.class)\n            .in(Singleton.class) ;\n      \n      bind(VCSApplicationView.class).to(VCSApplicationWindow.class)\n            .in(Singleton.class);\n      bind(ReviewPresenter.class).to(ReviewPresenterImpl.class);\n      \n      bind(PDFViewerApplicationView.class).to(PDFViewerApplicationWindow.class);\n      bind(HTMLPreviewApplicationView.class).to(HTMLPreviewApplicationWindow.class);\n      \n      bind(Server.class).to(RemoteServer.class) ;\n      bind(WorkbenchServerOperations.class).to(RemoteServer.class) ;\n\n      bind(EditingTargetSource.class).to(EditingTargetSource.Impl.class);\n\n      // Bind workbench views\n      bindPane(\"Console\", ConsolePane.class); // eager loaded\n      bind(Source.Display.class).to(SourcePane.class);\n      bind(History.Display.class).to(HistoryPane.class);\n      bind(Data.Display.class).to(DataPane.class);\n      bind(Files.Display.class).to(FilesPane.class);\n      bind(Plots.Display.class).to(PlotsPane.class);\n      bind(Packages.Display.class).to(PackagesPane.class);\n      bind(Help.Display.class).to(HelpPane.class);\n      bind(Edit.Display.class).to(EditView.class);\n      bind(GitPresenter.Display.class).to(GitPane.class);\n      bind(SVNPresenter.Display.class).to(SVNPane.class);\n      bind(BuildPresenter.Display.class).to(BuildPane.class);\n      bind(Presentation.Display.class).to(PresentationPane.class);\n      bind(EnvironmentPresenter.Display.class).to(EnvironmentPane.class);\n      bind(ViewerPresenter.Display.class).to(ViewerPane.class);\n      bind(Ignore.Display.class).to(IgnoreDialog.class);\n      bind(CompilePdfOutputPresenter.Display.class).to(CompilePdfOutputPane.class);\n      bind(FindOutputPresenter.Display.class).to(FindOutputPane.class);\n      bind(SourceCppOutputPresenter.Display.class).to(SourceCppOutputPane.class);\n      bindTab(\"History\", HistoryTab.class);\n      bindTab(\"Data\", DataTab.class);\n      bindTab(\"Files\", FilesTab.class);\n      bindTab(\"Plots\", PlotsTab.class);\n      bindTab(\"Packages\", PackagesTab.class);\n      bindTab(\"Help\", HelpTab.class);\n      bindTab(\"VCS\", VCSTab.class);\n      bindTab(\"Build\", BuildTab.class);\n      bindTab(\"Presentation\", PresentationTab.class);\n      bindTab(\"Environment\", EnvironmentTab.class);\n      bindTab(\"Viewer\", ViewerTab.class);\n      bindTab(\"Compile PDF\", CompilePdfOutputTab.class);\n      bindTab(\"Find\", FindOutputTab.class);\n      bindTab(\"Source Cpp\", SourceCppOutputTab.class);\n\n      bind(Shell.Display.class).to(ShellPane.class) ;\n           \n      bind(HelpSearch.Display.class).to(HelpSearchWidget.class) ;\n      bind(CodeSearch.Display.class).to(CodeSearchWidget.class);\n\n      bind(GitReviewPresenter.Display.class).to(GitReviewPanel.class);\n      bind(SVNReviewPresenter.Display.class).to(SVNReviewPanel.class);\n      bind(LineTablePresenter.Display.class).to(LineTableView.class);\n      bind(HistoryPresenter.DisplayBuilder.class).to(\n                                                    HistoryPanel.Builder.class);\n      \n      bind(PDFViewerPresenter.Display.class).to(PDFViewerPanel.class);\n      bind(HTMLPreviewPresenter.Display.class).to(HTMLPreviewPanel.class);\n      \n      bind(GlobalDisplay.class)\n            .to(DefaultGlobalDisplay.class)\n            .in(Singleton.class) ;\n\n      bind(ApplicationServerOperations.class).to(RemoteServer.class) ;\n      bind(ChooseFileServerOperations.class).to(RemoteServer.class) ;\n      bind(CodeToolsServerOperations.class).to(RemoteServer.class) ;\n      bind(ConsoleServerOperations.class).to(RemoteServer.class) ;\n      bind(SourceServerOperations.class).to(RemoteServer.class) ;\n      bind(DataServerOperations.class).to(RemoteServer.class);\n      bind(FilesServerOperations.class).to(RemoteServer.class) ;\n      bind(HistoryServerOperations.class).to(RemoteServer.class) ;\n      bind(PlotsServerOperations.class).to(RemoteServer.class) ;\n      bind(PackagesServerOperations.class).to(RemoteServer.class) ;\n      bind(HelpServerOperations.class).to(RemoteServer.class) ;\n      bind(EditServerOperations.class).to(RemoteServer.class) ;\n      bind(MirrorsServerOperations.class).to(RemoteServer.class);\n      bind(VCSServerOperations.class).to(RemoteServer.class);\n      bind(GitServerOperations.class).to(RemoteServer.class);\n      bind(SVNServerOperations.class).to(RemoteServer.class);\n      bind(PrefsServerOperations.class).to(RemoteServer.class);\n      bind(ProjectsServerOperations.class).to(RemoteServer.class);\n      bind(CodeSearchServerOperations.class).to(RemoteServer.class);\n      bind(WorkbenchListsServerOperations.class).to(RemoteServer.class);\n      bind(CryptoServerOperations.class).to(RemoteServer.class);\n      bind(TexServerOperations.class).to(RemoteServer.class);\n      bind(SpellingServerOperations.class).to(RemoteServer.class);\n      bind(CompilePdfServerOperations.class).to(RemoteServer.class);\n      bind(FindInFilesServerOperations.class).to(RemoteServer.class);\n      bind(SynctexServerOperations.class).to(RemoteServer.class);\n      bind(HTMLPreviewServerOperations.class).to(RemoteServer.class);\n      bind(ShinyServerOperations.class).to(RemoteServer.class);\n      bind(RPubsServerOperations.class).to(RemoteServer.class);\n      bind(BuildServerOperations.class).to(RemoteServer.class);\n      bind(PresentationServerOperations.class).to(RemoteServer.class);\n      bind(EnvironmentServerOperations.class).to(RemoteServer.class);\n      bind(DebuggingServerOperations.class).to(RemoteServer.class);\n      bind(MetaServerOperations.class).to(RemoteServer.class);\n      bind(ViewerServerOperations.class).to(RemoteServer.class);\n\n      bind(WorkbenchMainView.class).to(WorkbenchScreen.class) ;\n\n      bind(DocDisplay.class).to(AceEditor.class);\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public ViewerPane(Commands commands)\n   {\n      super(\"Viewer\");\n      commands_ = commands;\n      ensureWidget();\n   }","id":80510,"modified_method":"@Inject\n   public ViewerPane(Commands commands, GlobalDisplay globalDisplay)\n   {\n      super(\"Viewer\");\n      commands_ = commands;\n      globalDisplay_ = globalDisplay;\n      ensureWidget();\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.viewerBack().createToolbarButton());\n      toolbar.addLeftWidget(commands_.viewerForward().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.viewerPrint().createToolbarButton());\n      toolbar.addLeftWidget(commands_.viewerPopout().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.viewerClearHistory().createToolbarButton());\n      toolbar.addRightWidget(commands_.viewerRefresh().createToolbarButton());\n      return toolbar;\n   }","id":80511,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.viewerPopout().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.viewerPrint().createToolbarButton());\n      toolbar.addRightWidget(commands_.viewerStop().createToolbarButton());\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(commands_.viewerRefresh().createToolbarButton());\n      return toolbar;\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void popout()\n   {\n      \n      \n   }","id":80512,"modified_method":"@Override\n   public void popout()\n   {\n      String url = frame_.getUrl();\n      if (url != null)\n         globalDisplay_.openWindow(url);\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void refresh()\n   {\n      \n      \n   }","id":80513,"modified_method":"@Override\n   public void refresh()\n   {\n      String url = frame_.getUrl();\n      if (url != null)\n         navigate(url);\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void print()\n   {\n      \n      \n   }","id":80514,"modified_method":"@Override\n   public void print()\n   {\n      frame_.print();\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Handler\n   public void onViewerBack() { display_.back(); }","id":80515,"modified_method":"@Handler\n   public void onViewerStop()\n   {\n      enableCommands(false);\n      \n      display_.navigate(\"about:blank\");\n      \n      commands_.interruptR().execute();\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void onViewerNavigate(ViewerNavigateEvent event)\n   {\n      display_.bringToFront();\n      \n      if (event.getFullHeight())\n         display_.maximize();\n      \n      display_.navigate(event.getURL());\n   }","id":80516,"modified_method":"public void onViewerNavigate(ViewerNavigateEvent event)\n   {\n      enableCommands(true);\n      \n      display_.bringToFront();\n      \n      if (event.getFullHeight())\n         display_.maximize();\n      \n      display_.navigate(event.getURL());\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public ViewerPresenter(Display display, \n                          Commands commands,\n                          Binder binder)\n   {\n      super(display);\n      display_ = display;\n      \n      binder.bind(commands, this);\n   }","id":80517,"modified_method":"@Inject\n   public ViewerPresenter(Display display, \n                          EventBus eventBus,\n                          Commands commands,\n                          Binder binder)\n   {\n      super(display);\n      display_ = display;\n      commands_ = commands;\n      \n      binder.bind(commands, this);\n      \n      enableCommands(false);\n      \n      // show a stop button when the console is busy\n      commands_.viewerStop().setVisible(commands_.interruptR().isEnabled());\n      commands_.interruptR().addEnabledChangedHandler(\n                                                new EnabledChangedHandler() {\n         @Override\n         public void onEnabledChanged(AppCommand command)\n         {\n            commands_.viewerStop().setVisible(command.isEnabled());\n         }\n      });\n   }","commit_id":"6c5ed4c93f446954e048491b9783e0b9afabb4ff","url":"https://github.com/rstudio/rstudio"},{"original_method":"public synchronized void addURI(URI uri)\n        {\n            try {\n                URL url = new URL(null, uri.toString(), handlerFactory.createURLStreamHandler(uri.getScheme()));\n                int len = this.urls.length;\n                URL[] urls = new URL[len + 1];\n                System.arraycopy(this.urls, 0, urls, 0, len);\n                urls[len] = url;\n                this.urls = urls;\n            } catch (MalformedURLException e) {\n                throw new IllegalArgumentException(e.getMessage());\n            }\n        }","id":80518,"modified_method":"public synchronized void addURI(URI uri)\n        {\n            try {\n                URL url =\n                    new URL(null, uri.toString(), handlerFactory != null ? handlerFactory.createURLStreamHandler(uri\n                        .getScheme()) : null);\n                int len = this.urls.length;\n                URL[] urls = new URL[len + 1];\n                System.arraycopy(this.urls, 0, urls, 0, len);\n                urls[len] = url;\n                this.urls = urls;\n            } catch (MalformedURLException e) {\n                throw new IllegalArgumentException(e.getMessage());\n            }\n        }","commit_id":"14e1dd93af485f1a3fb7aaf448f5b3fe469a1387","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public URIResourceFinder(URI[] uris, URLStreamHandlerFactory handlerFactory)\n        {\n            this.handlerFactory = handlerFactory;\n            try {\n                this.loader = new ResourceLoader(handlerFactory.createURLStreamHandler(\"jar\"));\n                URL[] urls = new URL[uris.length];\n                for (int i = 0; i < uris.length; i++) {\n                    urls[i] =\n                        new URL(null, uris[i].toString(), handlerFactory.createURLStreamHandler(uris[i].getScheme()));\n                }\n                this.urls = urls;\n            } catch (MalformedURLException e) {\n                throw new IllegalArgumentException(e.getMessage());\n            }\n        }","id":80519,"modified_method":"public URIResourceFinder(URI[] uris, URLStreamHandlerFactory handlerFactory)\n        {\n            this.handlerFactory = handlerFactory;\n            try {\n                this.loader =\n                    new ResourceLoader(handlerFactory != null ? handlerFactory.createURLStreamHandler(\"jar\") : null);\n                URL[] urls = new URL[uris.length];\n                for (int i = 0; i < uris.length; i++) {\n                    urls[i] =\n                        new URL(null, uris[i].toString(), handlerFactory != null\n                            ? handlerFactory.createURLStreamHandler(uris[i].getScheme()) : null);\n                }\n                this.urls = urls;\n            } catch (MalformedURLException e) {\n                throw new IllegalArgumentException(e.getMessage());\n            }\n        }","commit_id":"14e1dd93af485f1a3fb7aaf448f5b3fe469a1387","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private URLStreamHandler getBuiltInStreamHandler(String protocol, URLStreamHandlerFactory factory)\n    {\n        synchronized (m_builtIn)\n        {\n            if (m_builtIn.containsKey(protocol))\n            {\n                return (URLStreamHandler) m_builtIn.get(protocol);\n            }\n        }\n        if (factory != null)\n        {\n            URLStreamHandler result = factory.createURLStreamHandler(protocol);\n            if (result != null)\n            {\n                return addToCache(protocol, result);\n            }\n        }\n        // Check for built-in handlers for the mime type.\n        // Iterate over built-in packages.\n        URLStreamHandler handler = loadBuiltInStreamHandler(protocol, null);\n        if (handler == null)\n        {\n            handler = loadBuiltInStreamHandler(protocol, ClassLoader.getSystemClassLoader());\n        }\n        return addToCache(protocol, handler);\n    }","id":80520,"modified_method":"private URLStreamHandler getBuiltInStreamHandler(String protocol, URLStreamHandlerFactory factory)\n    {\n        URLStreamHandler handler = getFromCache(m_builtIn, protocol);\n\n        if (handler != null)\n        {\n            return handler;\n        }\n\n        if (factory != null)\n        {\n            handler = factory.createURLStreamHandler(protocol);\n        }\n\n        if (handler == null)\n        {\n            // Check for built-in handlers for the mime type.\n            // Iterate over built-in packages.\n            handler = loadBuiltInStreamHandler(protocol, null);\n        }\n\n        if (handler == null)\n        {\n            handler = loadBuiltInStreamHandler(protocol, ClassLoader.getSystemClassLoader());\n        }\n\n        return addToCache(m_builtIn, protocol, handler);\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"private void init(String protocol, URLStreamHandlerFactory factory)\n    {\n        try\n        {\n            URLStreamHandler handler = getBuiltInStreamHandler(protocol, factory);\n            if (handler != null)\n            {\n                URL url = new URL(protocol, null, -1, \"\", handler);\n                m_handlerToURL.put(handler, url);\n            }\n        }\n        catch (Throwable ex)\n        {\n            // Ignore, this is a best effort (maybe log it or something).\n        }\n    }","id":80521,"modified_method":"private void init(String protocol, URLStreamHandlerFactory factory)\n    {\n        try\n        {\n            URLStreamHandler handler = getBuiltInStreamHandler(protocol, factory);\n            if (handler != null)\n            {\n                URL url = new URL(protocol, null, -1, \"\", handler);\n                addToCache(m_handlerToURL, handler, url);\n            }\n        }\n        catch (Throwable ex)\n        {\n            // Ignore, this is a best effort (maybe log it or something).\n        }\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>ContentHandlerFactory<\/tt>\n     * interface. It simply creates a content handler proxy object for the\n     * specified mime type. It caches the returned proxy; therefore, subsequent\n     * requests for the same content type will receive the same handler proxy.\n     * <\/p>\n     * @param mimeType the mime type for which a content handler should be returned.\n     * @return a content handler proxy for the specified mime type.\n    **/\n    public ContentHandler createContentHandler(String mimeType)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        ContentHandler handler = getFromContentCache(mimeType);\n\n        if (handler != null)\n        {\n            return handler;\n        }\n\n        return addToContentCache(mimeType,\n            new URLHandlersContentHandlerProxy(mimeType, m_secureAction,\n            (m_contentHandlerFactory != this) ? m_contentHandlerFactory : null));\n    }","id":80522,"modified_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>ContentHandlerFactory<\/tt>\n     * interface. It simply creates a content handler proxy object for the\n     * specified mime type. It caches the returned proxy; therefore, subsequent\n     * requests for the same content type will receive the same handler proxy.\n     * <\/p>\n     * @param mimeType the mime type for which a content handler should be returned.\n     * @return a content handler proxy for the specified mime type.\n    **/\n    public ContentHandler createContentHandler(String mimeType)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        ContentHandler handler = getFromCache(m_contentHandlerCache, mimeType);\n\n        if (handler != null)\n        {\n            return handler;\n        }\n\n        return addToCache(m_contentHandlerCache, mimeType,\n            new URLHandlersContentHandlerProxy(mimeType, m_secureAction,\n            (m_contentHandlerFactory != this) ? m_contentHandlerFactory : null));\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * This method returns the system bundle context for the caller.\n     * It determines the appropriate system bundle by retrieving the\n     * class call stack and find the first class that is loaded from\n     * a bundle. It then checks to see which of the registered framework\n     * instances owns the class and returns its system bundle context.\n     * <\/p>\n     * @return the system bundle context associated with the caller or\n     *         <tt>null<\/tt> if no associated framework was found.\n    **/\n    public static Object getFrameworkFromContext()\n    {\n        // This is a hack. The idea is to return the only registered framework\n        synchronized (m_classloaderToFrameworkLists)\n        {\n            if (m_classloaderToFrameworkLists.isEmpty())\n            {\n                synchronized (m_frameworks)\n                {\n                    if ((m_counter == 1) && (m_frameworks.size() == 1))\n                    {\n                        return m_frameworks.get(0);\n                    }\n                }\n            }\n        }\n        // get the current class call stack.\n        Class[] stack = m_sm.getClassContext();\n        // Find the first class that is loaded from a bundle.\n        Class targetClass = null;\n        for (int i = 0; i < stack.length; i++)\n        {\n            if (stack[i].getClassLoader() != null)\n            {\n                String name = stack[i].getClassLoader().getClass().getName();\n                if (name.startsWith(\"org.apache.felix.framework.ModuleImpl$ModuleClassLoader\")\n                    || name.equals(\"org.apache.felix.framework.searchpolicy.ContentClassLoader\")\n                    || name.startsWith(\"org.apache.felix.framework.BundleWiringImpl$BundleClassLoader\"))\n                {\n                    targetClass = stack[i];\n                    break;\n                }\n            }\n        }\n\n        // If we found a class loaded from a bundle, then iterate\n        // over the framework instances and see which framework owns\n        // the bundle that loaded the class.\n        if (targetClass != null)\n        {\n            synchronized (m_classloaderToFrameworkLists)\n            {\n                ClassLoader index = targetClass.getClassLoader().getClass().getClassLoader();\n\n                List frameworks = (List) m_classloaderToFrameworkLists.get(\n                    index);\n\n                if ((frameworks == null) && (index == URLHANDLERS_CLASS.getClassLoader()))\n                {\n                    frameworks = m_frameworks;\n                }\n                if (frameworks != null)\n                {\n                    synchronized (frameworks)\n                    {\n                        // Check the registry of framework instances\n                        for (int i = 0; i < frameworks.size(); i++)\n                        {\n                            Object framework = frameworks.get(i);\n                            try\n                            {\n                                if (m_secureAction.invoke(\n                                    m_secureAction.getDeclaredMethod(framework.getClass(),\n                                    \"getBundle\", CLASS_TYPE),\n                                    framework, new Object[]{targetClass}) != null)\n                                {\n                                    return framework;\n                                }\n                            }\n                            catch (Exception ex)\n                            {\n                                // This should not happen but if it does there is\n                                // not much we can do other then ignore it.\n                                // Maybe log this or something.\n                                ex.printStackTrace();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }","id":80523,"modified_method":"/**\n     * <p>\n     * This method returns the system bundle context for the caller.\n     * It determines the appropriate system bundle by retrieving the\n     * class call stack and find the first class that is loaded from\n     * a bundle. It then checks to see which of the registered framework\n     * instances owns the class and returns its system bundle context.\n     * <\/p>\n     * @return the system bundle context associated with the caller or\n     *         <tt>null<\/tt> if no associated framework was found.\n    **/\n    public static Object getFrameworkFromContext()\n    {\n        // This is a hack. The idea is to return the only registered framework quickly\n        int attempts = 0;\n        while (m_classloaderToFrameworkLists.isEmpty() && (m_counter == 1) && (m_frameworks.size() == 1))\n        {\n            Object framework = m_frameworks.get(0);\n\n            if (framework != null)\n            {\n                return framework;\n            }\n            else if (attempts++ > 3)\n            {\n                break;\n            }\n        }\n\n        // get the current class call stack.\n        Class[] stack = m_sm.getClassContext();\n        // Find the first class that is loaded from a bundle.\n        Class targetClass = null;\n        for (int i = 0; i < stack.length; i++)\n        {\n            if (stack[i].getClassLoader() != null)\n            {\n                String name = stack[i].getClassLoader().getClass().getName();\n                if (name.startsWith(\"org.apache.felix.framework.ModuleImpl$ModuleClassLoader\")\n                    || name.equals(\"org.apache.felix.framework.searchpolicy.ContentClassLoader\")\n                    || name.startsWith(\"org.apache.felix.framework.BundleWiringImpl$BundleClassLoader\"))\n                {\n                    targetClass = stack[i];\n                    break;\n                }\n            }\n        }\n\n        // If we found a class loaded from a bundle, then iterate\n        // over the framework instances and see which framework owns\n        // the bundle that loaded the class.\n        if (targetClass != null)\n        {\n            ClassLoader index = targetClass.getClassLoader().getClass().getClassLoader();\n\n            List frameworks = (List) m_classloaderToFrameworkLists.get(index);\n\n            if ((frameworks == null) && (index == URLHANDLERS_CLASS.getClassLoader()))\n            {\n                frameworks = m_frameworks;\n            }\n            if (frameworks != null)\n            {\n                // Check the registry of framework instances\n                for (Object framework : frameworks)\n                {\n                    try\n                    {\n                        if (m_secureAction.invoke(\n                            m_secureAction.getDeclaredMethod(framework.getClass(),\n                            \"getBundle\", CLASS_TYPE),\n                            framework, new Object[]{targetClass}) != null)\n                        {\n                            return framework;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        // This should not happen but if it does there is\n                        // not much we can do other then ignore it.\n                        // Maybe log this or something.\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        }\n        return null;\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>URLStreamHandlerFactory<\/tt>\n     * interface. It simply creates a stream handler proxy object for the\n     * specified protocol. It caches the returned proxy; therefore, subsequent\n     * requests for the same protocol will receive the same handler proxy.\n     * <\/p>\n     * @param protocol the protocol for which a stream handler should be returned.\n     * @return a stream handler proxy for the specified protocol.\n    **/\n    public URLStreamHandler createURLStreamHandler(String protocol)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        URLStreamHandler handler = getFromStreamCache(protocol);\n\n        if (handler != null)\n        {\n            return handler;\n        }\n        // If this is the framework's \"bundle:\" protocol, then return\n        // a handler for that immediately, since no one else can be\n        // allowed to deal with it.\n        if (protocol.equals(FelixConstants.BUNDLE_URL_PROTOCOL))\n        {\n            return addToStreamCache(protocol,\n                new URLHandlersBundleStreamHandler(m_secureAction));\n        }\n\n       handler = getBuiltInStreamHandler(protocol,\n           (m_streamHandlerFactory != this) ? m_streamHandlerFactory : null);\n\n        // If built-in content handler, then create a proxy handler.\n        return addToStreamCache(protocol,\n            new URLHandlersStreamHandlerProxy(protocol, m_secureAction,\n                handler, (URL) m_handlerToURL.get(handler)));\n    }","id":80524,"modified_method":"/**\n     * <p>\n     * This is a method implementation for the <tt>URLStreamHandlerFactory<\/tt>\n     * interface. It simply creates a stream handler proxy object for the\n     * specified protocol. It caches the returned proxy; therefore, subsequent\n     * requests for the same protocol will receive the same handler proxy.\n     * <\/p>\n     * @param protocol the protocol for which a stream handler should be returned.\n     * @return a stream handler proxy for the specified protocol.\n    **/\n    public URLStreamHandler createURLStreamHandler(String protocol)\n    {\n        // See if there is a cached stream handler.\n        // IMPLEMENTATION NOTE: Caching is not strictly necessary for\n        // stream handlers since the Java runtime caches them. Caching is\n        // performed for code consistency between stream and content\n        // handlers and also because caching behavior may not be guaranteed\n        // across different JRE implementations.\n        URLStreamHandler handler = getFromCache(m_streamHandlerCache, protocol);\n\n        if (handler != null)\n        {\n            return handler;\n        }\n        // If this is the framework's \"bundle:\" protocol, then return\n        // a handler for that immediately, since no one else can be\n        // allowed to deal with it.\n        if (protocol.equals(FelixConstants.BUNDLE_URL_PROTOCOL))\n        {\n            return addToCache(m_streamHandlerCache, protocol,\n                new URLHandlersBundleStreamHandler(m_secureAction));\n        }\n\n        handler = getBuiltInStreamHandler(protocol,\n            (m_streamHandlerFactory != this) ? m_streamHandlerFactory : null);\n\n        // If built-in content handler, then create a proxy handler.\n        return addToCache(m_streamHandlerCache, protocol,\n            new URLHandlersStreamHandlerProxy(protocol, m_secureAction,\n                handler, getFromCache(m_handlerToURL,handler)));\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"protected synchronized URLConnection openConnection(URL url) throws IOException\n    {\n        if (!\"felix\".equals(url.getAuthority()))\n        {\n            checkPermission(url);\n        }\n        if (m_framework != null)\n        {\n            return new URLHandlersBundleURLConnection(url, m_framework);\n        }\n        \n        Object framework = URLHandlers.getFrameworkFromContext();\n        \n        if (framework != null)\n        {\n            if (framework instanceof Felix)\n            {\n                return new URLHandlersBundleURLConnection(url, (Felix) framework);\n            }\n            try\n            {\n                Class targetClass = framework.getClass().getClassLoader().loadClass(\n                    URLHandlersBundleURLConnection.class.getName());\n                \n                Constructor constructor = m_action.getConstructor(targetClass, \n                        new Class[]{URL.class, framework.getClass().getClassLoader().loadClass(\n                                Felix.class.getName())});\n                m_action.setAccesssible(constructor);\n                return (URLConnection) m_action.invoke(constructor, new Object[]{url, framework});\n            }\n            catch (Exception ex)\n            {\n                throw new IOException(ex.getMessage());\n            }\n        }\n        throw new IOException(\"No framework context found\");\n    }","id":80525,"modified_method":"protected URLConnection openConnection(URL url) throws IOException\n    {\n        if (!\"felix\".equals(url.getAuthority()))\n        {\n            checkPermission(url);\n        }\n        if (m_framework != null)\n        {\n            return new URLHandlersBundleURLConnection(url, m_framework);\n        }\n\n        Object framework = URLHandlers.getFrameworkFromContext();\n\n        if (framework != null)\n        {\n            if (framework instanceof Felix)\n            {\n                return new URLHandlersBundleURLConnection(url, (Felix) framework);\n            }\n            try\n            {\n                Class targetClass = framework.getClass().getClassLoader().loadClass(\n                    URLHandlersBundleURLConnection.class.getName());\n\n                Constructor constructor = m_action.getConstructor(targetClass,\n                        new Class[]{URL.class, framework.getClass().getClassLoader().loadClass(\n                                Felix.class.getName())});\n                m_action.setAccesssible(constructor);\n                return (URLConnection) m_action.invoke(constructor, new Object[]{url, framework});\n            }\n            catch (Exception ex)\n            {\n                throw new IOException(ex.getMessage());\n            }\n        }\n        throw new IOException(\"No framework context found\");\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"protected String toExternalForm(URL u) \n    {\n        StringBuffer result = new StringBuffer();\n        result.append(u.getProtocol());\n        result.append(\"://\");\n        result.append(u.getHost());\n        result.append(':');\n        result.append(u.getPort());\n        if (u.getPath() != null) \n        {\n            result.append(u.getPath());\n        }\n        if (u.getQuery() != null) \n        {\n            result.append('?');\n            result.append(u.getQuery());\n        }\n        if (u.getRef() != null) \n        {\n            result.append(\"#\");\n            result.append(u.getRef());\n        }\n        return result.toString();\n    }","id":80526,"modified_method":"protected String toExternalForm(URL u)\n    {\n        StringBuilder result = new StringBuilder();\n        result.append(u.getProtocol());\n        result.append(\"://\");\n        result.append(u.getHost());\n        result.append(':');\n        result.append(u.getPort());\n        if (u.getPath() != null)\n        {\n            result.append(u.getPath());\n        }\n        if (u.getQuery() != null)\n        {\n            result.append('?');\n            result.append(u.getQuery());\n        }\n        if (u.getRef() != null)\n        {\n            result.append(\"#\");\n            result.append(u.getRef());\n        }\n        return result.toString();\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"private ContentHandler getBuiltIn()\n    {\n        synchronized (m_builtIn)\n        {\n            if (m_builtIn.containsKey(m_mimeType))\n            {\n                return (ContentHandler) m_builtIn.get(m_mimeType);\n            }\n        }\n        if (m_factory != null)\n        {\n            ContentHandler result = m_factory.createContentHandler(m_mimeType);\n            if (result != null)\n            {\n                return addToCache(m_mimeType, result);\n            }\n        }\n        // Check for built-in handlers for the mime type.\n        // Remove periods, slashes, and dashes from mime type.\n        String fixedType = m_mimeType.replace('.', '_').replace('/', '.').replace('-', '_');\n\n        // Iterate over built-in packages.\n        StringTokenizer pkgTok = new StringTokenizer(m_pkgs, \"| \");\n        while (pkgTok.hasMoreTokens())\n        {\n            String pkg = pkgTok.nextToken().trim();\n            String className = pkg + \".\" + fixedType;\n            try\n            {\n                // If a built-in handler is found then cache and return it\n                Class handler = m_action.forName(className, null);\n                if (handler != null)\n                {\n                    return addToCache(m_mimeType,\n                        (ContentHandler) handler.newInstance());\n                }\n            }\n            catch (Exception ex)\n            {\n                // This could be a class not found exception or an\n                // instantiation exception, not much we can do in either\n                // case other than ignore it.\n            }\n        }\n        return addToCache(m_mimeType, null);\n    }","id":80527,"modified_method":"private ContentHandler getBuiltIn()\n    {\n        ContentHandler result = m_builtIn.get(m_mimeType);\n\n        if (result == null)\n        {\n            return result;\n        }\n\n        if (m_factory != null)\n        {\n            result = m_factory.createContentHandler(m_mimeType);\n            if (result != null)\n            {\n                return putIfAbsentAndReturn(m_builtIn, m_mimeType, result);\n            }\n        }\n        // Check for built-in handlers for the mime type.\n        // Remove periods, slashes, and dashes from mime type.\n        String fixedType = m_mimeType.replace('.', '_').replace('/', '.').replace('-', '_');\n\n        // Iterate over built-in packages.\n        StringTokenizer pkgTok = new StringTokenizer(m_pkgs, \"| \");\n        while (pkgTok.hasMoreTokens())\n        {\n            String pkg = pkgTok.nextToken().trim();\n            String className = pkg + \".\" + fixedType;\n            try\n            {\n                // If a built-in handler is found then cache and return it\n                Class handler = m_action.forName(className, null);\n                if (handler != null)\n                {\n                    return putIfAbsentAndReturn(m_builtIn, m_mimeType,\n                        (ContentHandler) handler.newInstance());\n                }\n            }\n            catch (Exception ex)\n            {\n                // This could be a class not found exception or an\n                // instantiation exception, not much we can do in either\n                // case other than ignore it.\n            }\n        }\n        return null;\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"public Object invoke(Object obj, Method method, Object[] params)\n        throws Throwable\n    {\n        try\n        {\n\n            Class[] types = method.getParameterTypes();\n            if (m_service == null)\n            {\n                return m_action.invoke(m_action.getMethod(this.getClass(), method.getName(), types), this, params);\n            }\n            if (\"parseURL\".equals(method.getName()))\n            {\n                types[0] = m_service.getClass().getClassLoader().loadClass(\n                    URLStreamHandlerSetter.class.getName());\n                params[0] = Proxy.newProxyInstance(\n                    m_service.getClass().getClassLoader(), new Class[]{types[0]},\n                    (URLHandlersStreamHandlerProxy) params[0]);\n            }\n            return m_action.invokeDirect(m_action.getDeclaredMethod(m_service.getClass(),\n                method.getName(), types), m_service, params);\n        }\n        catch (Exception ex)\n        {\n            throw ex;\n        }\n    }","id":80528,"modified_method":"public Object invoke(Object obj, Method method, Object[] params)\n        throws Throwable\n    {\n        Class[] types = method.getParameterTypes();\n        if (m_service == null)\n        {\n            return m_action.invoke(m_action.getMethod(this.getClass(), method.getName(), types), this, params);\n        }\n        if (\"parseURL\".equals(method.getName()))\n        {\n            types[0] = m_service.getClass().getClassLoader().loadClass(\n                URLStreamHandlerSetter.class.getName());\n            params[0] = Proxy.newProxyInstance(\n                m_service.getClass().getClassLoader(), new Class[]{types[0]},\n                (URLHandlersStreamHandlerProxy) params[0]);\n        }\n        return m_action.invokeDirect(m_action.getDeclaredMethod(m_service.getClass(),\n            method.getName(), types), m_service, params);\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * Private method to retrieve the stream handler service from the\n     * framework instance associated with the current call stack. A\n     * simple service tracker is created and cached for the associated\n     * framework instance when this method is called.\n     * <\/p>\n     * @return the stream handler service from the framework instance\n     *         associated with the current call stack or <tt>null<\/tt>\n     *         is no service is available.\n    **/\n    private Object getStreamHandlerService()\n    {\n        try\n        {\n            // Get the framework instance associated with call stack.\n            Object framework = URLHandlers.getFrameworkFromContext();\n         \n            if (framework == null)\n            {\n                return m_builtIn;\n            }\n\n\n            Object service = null;\n            if (framework instanceof Felix)\n            {\n                service = ((Felix) framework).getStreamHandlerService(m_protocol);\n            }\n            else\n            {\n                service = m_action.invoke(\n                    m_action.getDeclaredMethod(framework.getClass(), \"getStreamHandlerService\", STRING_TYPES),\n                    framework, new Object[]{m_protocol});\n            }\n\n            if (service == null)\n            {\n                return m_builtIn;\n            }\n            if (service instanceof URLStreamHandlerService)\n            {\n                return (URLStreamHandlerService) service;\n            }\n            return (URLStreamHandlerService) Proxy.newProxyInstance(\n                URLStreamHandlerService.class.getClassLoader(),\n                new Class[]{URLStreamHandlerService.class},\n                new URLHandlersStreamHandlerProxy(service, m_action));\n        }\n        catch (ThreadDeath td)\n        {\n            throw td;\n        }\n        catch (Throwable t)\n        {\n            // In case that we are inside tomcat - the problem is that the webapp classloader\n            // creates a new url to load a class. This gets us to this method. Now, if we\n            // trigger a classload while executing tomcat is creating a new url and we end-up with\n            // a loop which is cut short after two iterations (because of a circularclassload).\n            // We catch this exception (and all others) and just return the built-in handler\n            // (if we have any) as this way we at least eventually get started (this just means\n            // that we don't use the potentially provided built-in handler overwrite).\n            return m_builtIn;\n        }\n    }","id":80529,"modified_method":"/**\n     * <p>\n     * Private method to retrieve the stream handler service from the\n     * framework instance associated with the current call stack. A\n     * simple service tracker is created and cached for the associated\n     * framework instance when this method is called.\n     * <\/p>\n     * @return the stream handler service from the framework instance\n     *         associated with the current call stack or <tt>null<\/tt>\n     *         is no service is available.\n    **/\n    private Object getStreamHandlerService()\n    {\n        try\n        {\n            // Get the framework instance associated with call stack.\n            Object framework = URLHandlers.getFrameworkFromContext();\n\n            if (framework == null)\n            {\n                return m_builtIn;\n            }\n\n\n            Object service;\n            if (framework instanceof Felix)\n            {\n                service = ((Felix) framework).getStreamHandlerService(m_protocol);\n            }\n            else\n            {\n                service = m_action.invoke(\n                    m_action.getDeclaredMethod(framework.getClass(), \"getStreamHandlerService\", STRING_TYPES),\n                    framework, new Object[]{m_protocol});\n            }\n\n            if (service == null)\n            {\n                return m_builtIn;\n            }\n            if (service instanceof URLStreamHandlerService)\n            {\n                return (URLStreamHandlerService) service;\n            }\n            return (URLStreamHandlerService) Proxy.newProxyInstance(\n                URLStreamHandlerService.class.getClassLoader(),\n                new Class[]{URLStreamHandlerService.class},\n                new URLHandlersStreamHandlerProxy(service, m_action));\n        }\n        catch (ThreadDeath td)\n        {\n            throw td;\n        }\n        catch (Throwable t)\n        {\n            // In case that we are inside tomcat - the problem is that the webapp classloader\n            // creates a new url to load a class. This gets us to this method. Now, if we\n            // trigger a classload while executing, tomcat is creating a new url and we end-up with\n            // a loop which is cut short after two iterations (because of a circularclassload).\n            // We catch this exception (and all others) and just return the built-in handler\n            // (if we have any) as this way we at least eventually get started (this just means\n            // that we don't use the potentially provided built-in handler overwrite).\n            return m_builtIn;\n        }\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"private String toExternalForm(URL url, Object svc)\n    {\n        if (svc == null)\n        {\n            throw new IllegalStateException(\n                \"Unknown protocol: \" + url.getProtocol());\n        }\n        if (svc instanceof URLStreamHandlerService)\n        {\n            return ((URLStreamHandlerService) svc).toExternalForm(url);\n        }\n        try\n        {\n            try\n            {\n                String result = (String) TO_EXTERNAL_FORM.invoke(\n                    svc, new Object[]{url});\n\n                // mika does return an invalid format if we have a url with the\n                // protocol only (<proto>://null) - we catch this case now\n                if ((result != null) && (result.equals(url.getProtocol() + \"://null\")))\n                {\n                    result = url.getProtocol() + \":\";\n                }\n\n                return result;\n            }\n            catch (InvocationTargetException ex)\n            {\n               Throwable t = ex.getTargetException();\n               if (t instanceof Exception)\n               {\n                   throw (Exception) t;\n               }\n               else if (t instanceof Error)\n               {\n                   throw (Error) t;\n               }\n               else\n               {\n                   throw new IllegalStateException(\"Unknown throwable: \" + t);\n               }\n            }\n        }\n        catch (NullPointerException ex)\n        {\n            // workaround for harmony and possibly J9. The issue is that\n            // their implementation of URLStreamHandler.toExternalForm()\n            // assumes that URL.getFile() doesn't return null but in our\n            // case it can -- hence, we catch the NPE and do the work\n            // ourselvs. The only difference is that we check whether the\n            // URL.getFile() is null or not.\n            StringBuffer answer = new StringBuffer();\n            answer.append(url.getProtocol());\n            answer.append(':');\n            String authority = url.getAuthority();\n            if ((authority != null) && (authority.length() > 0))\n            {\n                answer.append(\"//\"); //$NON-NLS-1$\n                answer.append(url.getAuthority());\n            }\n\n            String file = url.getFile();\n            String ref = url.getRef();\n            if (file != null)\n            {\n                answer.append(file);\n            }\n            if (ref != null)\n            {\n                answer.append('#');\n                answer.append(ref);\n            }\n            return answer.toString();\n        }\n        catch (Exception ex)\n        {\n            throw new IllegalStateException(\"Stream handler unavailable due to: \" + ex.getMessage());\n        }\n    }","id":80530,"modified_method":"private String toExternalForm(URL url, Object svc)\n    {\n        if (svc == null)\n        {\n            throw new IllegalStateException(\n                \"Unknown protocol: \" + url.getProtocol());\n        }\n        if (svc instanceof URLStreamHandlerService)\n        {\n            return ((URLStreamHandlerService) svc).toExternalForm(url);\n        }\n        try\n        {\n            try\n            {\n                String result = (String) TO_EXTERNAL_FORM.invoke(\n                    svc, new Object[]{url});\n\n                // mika does return an invalid format if we have a url with the\n                // protocol only (<proto>://null) - we catch this case now\n                if ((result != null) && (result.equals(url.getProtocol() + \"://null\")))\n                {\n                    result = url.getProtocol() + \":\";\n                }\n\n                return result;\n            }\n            catch (InvocationTargetException ex)\n            {\n               Throwable t = ex.getTargetException();\n               if (t instanceof Exception)\n               {\n                   throw (Exception) t;\n               }\n               else if (t instanceof Error)\n               {\n                   throw (Error) t;\n               }\n               else\n               {\n                   throw new IllegalStateException(\"Unknown throwable: \" + t);\n               }\n            }\n        }\n        catch (NullPointerException ex)\n        {\n            // workaround for harmony and possibly J9. The issue is that\n            // their implementation of URLStreamHandler.toExternalForm()\n            // assumes that URL.getFile() doesn't return null but in our\n            // case it can -- hence, we catch the NPE and do the work\n            // ourselvs. The only difference is that we check whether the\n            // URL.getFile() is null or not.\n            StringBuilder answer = new StringBuilder();\n            answer.append(url.getProtocol());\n            answer.append(':');\n            String authority = url.getAuthority();\n            if ((authority != null) && (authority.length() > 0))\n            {\n                answer.append(\"//\"); //$NON-NLS-1$\n                answer.append(url.getAuthority());\n            }\n\n            String file = url.getFile();\n            String ref = url.getRef();\n            if (file != null)\n            {\n                answer.append(file);\n            }\n            if (ref != null)\n            {\n                answer.append('#');\n                answer.append(ref);\n            }\n            return answer.toString();\n        }\n        catch (Exception ex)\n        {\n            throw new IllegalStateException(\"Stream handler unavailable due to: \" + ex.getMessage());\n        }\n    }","commit_id":"63f5cca320bafa225af1cd40d3659607d3c84de2","url":"https://github.com/apache/felix"},{"original_method":"/**\n   * Add the specified files to the project.\n   *\n   * @param project The project to add files to\n   * @param files   The files to add\n   * @throws VcsException If an error occurs\n   */\n  public static void addFiles(@NotNull Project project, @NotNull VirtualFile[] files) throws VcsException {\n    final Map<VirtualFile, List<VirtualFile>> roots = GitUtil.sortFilesByGitRoot(Arrays.asList(files));\n    for (Map.Entry<VirtualFile, List<VirtualFile>> entry : roots.entrySet()) {\n      GitSimpleHandler h = GitSimpleHandler.addFiles(project, entry.getKey(), entry.getValue());\n      h.run();\n    }\n    VcsDirtyScopeManager mgr = VcsDirtyScopeManager.getInstance(project);\n    for (VirtualFile file : files) {\n      mgr.fileDirty(file);\n      file.refresh(true, true);\n    }\n  }","id":80531,"modified_method":"/**\n   * Add the specified files to the project.\n   *\n   * @param project The project to add files to\n   * @param files   The files to add\n   * @throws VcsException If an error occurs\n   */\n  public static void addFiles(@NotNull Project project, @NotNull VirtualFile[] files) throws VcsException {\n    final Map<VirtualFile, List<VirtualFile>> roots = GitUtil.sortFilesByGitRoot(Arrays.asList(files));\n    for (Map.Entry<VirtualFile, List<VirtualFile>> entry : roots.entrySet()) {\n      GitFileUtils.addFiles(project, entry.getKey(), entry.getValue());\n    }\n    VcsDirtyScopeManager mgr = VcsDirtyScopeManager.getInstance(project);\n    for (VirtualFile file : files) {\n      mgr.fileDirty(file);\n      file.refresh(true, true);\n    }\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Update index (delete and remove files)\n   *\n   * @param project    the project\n   * @param root       a vcs root\n   * @param added      a added/modified files to commit\n   * @param added      a removed files to commit\n   * @param exceptions a list of exceptions to update\n   * @return true if index was updated successfully\n   */\n  private static boolean updateIndex(final Project project,\n                                     final VirtualFile root,\n                                     final Collection<FilePath> added,\n                                     final Collection<FilePath> removed,\n                                     final List<VcsException> exceptions) {\n    boolean rc = true;\n    if (!added.isEmpty()) {\n      try {\n        GitSimpleHandler.addPaths(project, root, added).run();\n      }\n      catch (VcsException ex) {\n        exceptions.add(ex);\n        rc = false;\n      }\n    }\n    if (!removed.isEmpty()) {\n      try {\n        GitSimpleHandler handler = new GitSimpleHandler(project, root, GitHandler.RM);\n        handler.addParameters(\"--ignore-unmatch\");\n        handler.addRelativePaths(removed);\n        handler.setNoSSH(true);\n        handler.run();\n      }\n      catch (VcsException ex) {\n        exceptions.add(ex);\n        rc = false;\n      }\n    }\n    return rc;\n  }","id":80532,"modified_method":"/**\n   * Update index (delete and remove files)\n   *\n   * @param project    the project\n   * @param root       a vcs root\n   * @param added      a added/modified files to commit\n   * @param added      a removed files to commit\n   * @param exceptions a list of exceptions to update\n   * @return true if index was updated successfully\n   */\n  private static boolean updateIndex(final Project project,\n                                     final VirtualFile root,\n                                     final Collection<FilePath> added,\n                                     final Collection<FilePath> removed,\n                                     final List<VcsException> exceptions) {\n    boolean rc = true;\n    if (!added.isEmpty()) {\n      try {\n        GitFileUtils.addPaths(project, root, added);\n      }\n      catch (VcsException ex) {\n        exceptions.add(ex);\n        rc = false;\n      }\n    }\n    if (!removed.isEmpty()) {\n      try {\n        GitSimpleHandler handler = new GitSimpleHandler(project, root, GitHandler.RM);\n        handler.addParameters(\"--ignore-unmatch\");\n        handler.addRelativePaths(removed);\n        handler.setNoSSH(true);\n        handler.run();\n      }\n      catch (VcsException ex) {\n        exceptions.add(ex);\n        rc = false;\n      }\n    }\n    return rc;\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  public List<VcsException> scheduleMissingFileForDeletion(List<FilePath> files) {\n    ArrayList<VcsException> rc = new ArrayList<VcsException>();\n    Map<VirtualFile, List<FilePath>> sortedFiles = GitUtil.sortFilePathsByVcsRoot(myProject, files);\n    for (Map.Entry<VirtualFile, List<FilePath>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitSimpleHandler.delete(myProject, root, e.getValue()).run();\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        rc.add(ex);\n      }\n    }\n    return rc;\n  }","id":80533,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  public List<VcsException> scheduleMissingFileForDeletion(List<FilePath> files) {\n    ArrayList<VcsException> rc = new ArrayList<VcsException>();\n    Map<VirtualFile, List<FilePath>> sortedFiles = GitUtil.sortFilePathsByVcsRoot(myProject, files);\n    for (Map.Entry<VirtualFile, List<FilePath>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitFileUtils.delete(myProject, root, e.getValue());\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        rc.add(ex);\n      }\n    }\n    return rc;\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  public List<VcsException> scheduleUnversionedFilesForAddition(List<VirtualFile> files) {\n    ArrayList<VcsException> rc = new ArrayList<VcsException>();\n    Map<VirtualFile, List<VirtualFile>> sortedFiles = GitUtil.sortFilesByGitRoot(files);\n    for (Map.Entry<VirtualFile, List<VirtualFile>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitSimpleHandler.addFiles(myProject, root, e.getValue()).run();\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        rc.add(ex);\n      }\n    }\n    return rc;\n  }","id":80534,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  public List<VcsException> scheduleUnversionedFilesForAddition(List<VirtualFile> files) {\n    ArrayList<VcsException> rc = new ArrayList<VcsException>();\n    Map<VirtualFile, List<VirtualFile>> sortedFiles = GitUtil.sortFilesByGitRoot(files);\n    for (Map.Entry<VirtualFile, List<VirtualFile>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitFileUtils.addFiles(myProject, root, e.getValue());\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        rc.add(ex);\n      }\n    }\n    return rc;\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  @NotNull\n  public MergeData loadRevisions(VirtualFile file) throws VcsException {\n    final MergeData mergeData = new MergeData();\n    if (file == null) return mergeData;\n    final FilePath path = VcsUtil.getFilePath(file.getPath());\n\n    VcsRunnable runnable = new VcsRunnable() {\n      @SuppressWarnings({\"ConstantConditions\"})\n      public void run() throws VcsException {\n        GitContentRevision original = new GitContentRevision(path, new GitRevisionNumber(\":1\"), myProject);\n        GitContentRevision current = new GitContentRevision(path, new GitRevisionNumber(\":2\"), myProject);\n        GitContentRevision last = new GitContentRevision(path, new GitRevisionNumber(\":3\"), myProject);\n        mergeData.ORIGINAL = original.getContent().getBytes();\n        mergeData.CURRENT = current.getContent().getBytes();\n        mergeData.LAST = last.getContent().getBytes();\n        mergeData.LAST_REVISION_NUMBER = new GitRevisionNumber(THEIRS_REVISION);\n      }\n    };\n    VcsUtil.runVcsProcessWithProgress(runnable, GitBundle.message(\"merge.load.files\"), false, myProject);\n    return mergeData;\n  }","id":80535,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  @NotNull\n  public MergeData loadRevisions(VirtualFile file) throws VcsException {\n    final MergeData mergeData = new MergeData();\n    if (file == null) return mergeData;\n    final FilePath path = VcsUtil.getFilePath(file.getPath());\n\n    VcsRunnable runnable = new VcsRunnable() {\n      @SuppressWarnings({\"ConstantConditions\"})\n      public void run() throws VcsException {\n        GitContentRevision original = new GitContentRevision(path, new GitRevisionNumber(\":\" + ORIGINAL_REVNUM), myProject);\n        GitContentRevision current = new GitContentRevision(path, new GitRevisionNumber(\":\" + YOURS_REVNUM), myProject);\n        GitContentRevision last = new GitContentRevision(path, new GitRevisionNumber(\":\" + THEIRS_REVNUM), myProject);\n        mergeData.ORIGINAL = original.getContent().getBytes();\n        mergeData.CURRENT = current.getContent().getBytes();\n        mergeData.LAST = last.getContent().getBytes();\n        mergeData.LAST_REVISION_NUMBER = new GitRevisionNumber(THEIRS_REVISION);\n      }\n    };\n    VcsUtil.runVcsProcessWithProgress(runnable, GitBundle.message(\"merge.load.files\"), false, myProject);\n    return mergeData;\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  public void conflictResolvedForFile(VirtualFile file) {\n    if (file == null) return;\n    try {\n      GitSimpleHandler.addFiles(myProject, GitUtil.getVcsRoot(myProject, file), file).run();\n    }\n    catch (VcsException e) {\n      log.error(\"Confirming conflict resolution failed\", e);\n    }\n  }","id":80536,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  public void conflictResolvedForFile(VirtualFile file) {\n    if (file == null) return;\n    try {\n      GitFileUtils.addFiles(myProject, GitUtil.getVcsRoot(myProject, file), file);\n    }\n    catch (VcsException e) {\n      log.error(\"Confirming conflict resolution failed\", e);\n    }\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  protected void performDeletion(final List<FilePath> filesToDelete) {\n    Map<VirtualFile, List<FilePath>> sortedFiles = GitUtil.sortFilePathsByVcsRoot(myProject, filesToDelete);\n    for (Map.Entry<VirtualFile, List<FilePath>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitSimpleHandler.delete(myProject, root, e.getValue()).run();\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        ((GitVcs)myVcs).showMessages(ex.getMessage());\n      }\n    }\n  }","id":80537,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  protected void performDeletion(final List<FilePath> filesToDelete) {\n    Map<VirtualFile, List<FilePath>> sortedFiles = GitUtil.sortFilePathsByVcsRoot(myProject, filesToDelete);\n    for (Map.Entry<VirtualFile, List<FilePath>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitFileUtils.delete(myProject, root, e.getValue());\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        ((GitVcs)myVcs).showMessages(ex.getMessage());\n      }\n    }\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  protected void performAdding(final Collection<VirtualFile> addedFiles, final Map<VirtualFile, VirtualFile> copyFromMap) {\n    Map<VirtualFile, List<VirtualFile>> sortedFiles = GitUtil.sortFilesByVcsRoot(myProject, addedFiles);\n    // note that copied files are not processed because they are included into added files.\n    for (Map.Entry<VirtualFile, List<VirtualFile>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitSimpleHandler.addFiles(myProject, root, e.getValue()).run();\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        ((GitVcs)myVcs).showMessages(ex.getMessage());\n      }\n    }\n  }","id":80538,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  protected void performAdding(final Collection<VirtualFile> addedFiles, final Map<VirtualFile, VirtualFile> copyFromMap) {\n    Map<VirtualFile, List<VirtualFile>> sortedFiles = GitUtil.sortFilesByVcsRoot(myProject, addedFiles);\n    // note that copied files are not processed because they are included into added files.\n    for (Map.Entry<VirtualFile, List<VirtualFile>> e : sortedFiles.entrySet()) {\n      try {\n        final VirtualFile root = e.getKey();\n        GitFileUtils.addFiles(myProject, root, e.getValue());\n        markRootDirty(root);\n      }\n      catch (VcsException ex) {\n        ((GitVcs)myVcs).showMessages(ex.getMessage());\n      }\n    }\n  }","commit_id":"d8501cb998b992a1d30738f4b5b0a2e4b143380f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void suggestRecentlyAddedTags(JPanel p, final AutoCompletingComboBox keys, final AutoCompletingComboBox values, List<JosmAction> tagsActions, int tagsToShow, final FocusAdapter focus) {\n        if (tagsToShow > 0 && !recentTags.isEmpty()) {\n            p.add(new JLabel(tr(\"Recently added tags\")), GBC.eol());\n            \n            int count = 1;\n            // We store the maximum number (9) of recent tags to allow dynamic change of number of tags shown in the preferences.\n            // This implies to iterate in descending order, as the oldest elements will only be removed after we reach the maximum numbern and not the number of tags to show.\n            // However, as Set does not allow to iterate in descending order, we need to copy its elements into a List we can access in reverse order.\n            List<Tag> tags = new LinkedList<Tag>(recentTags.keySet());\n            for (int i = tags.size()-1; i >= 0 && count <= tagsToShow; i--, count++) {\n                final Tag t = tags.get(i);\n                // Find and display icon\n                ImageIcon icon = MapPaintStyles.getNodeIcon(t, false); // Filters deprecated icon\n                if (icon == null) {\n                    icon = new ImageIcon(new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB));\n                }\n                GridBagConstraints gbc = new GridBagConstraints();\n                gbc.ipadx = 5;\n                p.add(new JLabel(icon), gbc);\n                // Create action for reusing the tag, with keyboard shortcut Ctrl+(1-5)\n                String actionShortcutKey = \"properties:recent:\"+count;\n                Shortcut sc = Shortcut.registerShortcut(actionShortcutKey, null, KeyEvent.VK_0+count, Shortcut.CTRL);\n                final JosmAction action = new JosmAction(actionShortcutKey, null, tr(\"Use this tag again\"), sc, false) {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        keys.setSelectedItem(t.getKey());\n                        values.setSelectedItem(t.getValue());\n                        // Update list of values (fix #7951) \n                        focus.focusGained(null);\n                    }\n                };\n                tagsActions.add(action);\n                // Disable action if its key is already set on the object (the key being absent from the keys list for this reason\n                // performing this action leads to autocomplete to the next key (see #7671 comments)\n                for (int j = 0; j < propertyData.getRowCount(); ++j) {\n                    System.out.println(propertyData.getValueAt(j, 0));\n                    if (t.getKey().equals(propertyData.getValueAt(j, 0))) {\n                        action.setEnabled(false);\n                        break;\n                    }\n                }\n                // Create tag label\n                final JLabel tagLabel = new JLabel(\"<html>\"\n                    + \"<style>td{border:1px solid gray; font-weight:normal;}<\/style>\" \n                    + \"<table><tr><td>\" + t.toString() + \"<\/td><\/tr><\/table><\/html>\");\n                if (action.isEnabled()) {\n                    // Register action\n                    p.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(sc.getKeyStroke(), actionShortcutKey);\n                    p.getActionMap().put(actionShortcutKey, action);\n                    // Make the tag label clickable and set tooltip to the action description (this displays also the keyboard shortcut)\n                    tagLabel.setToolTipText((String) action.getValue(Action.SHORT_DESCRIPTION));\n                    tagLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n                    tagLabel.addMouseListener(new MouseAdapter() {\n                        @Override\n                        public void mouseClicked(MouseEvent e) {\n                            action.actionPerformed(null);\n                        }\n                    });\n                } else {\n                    // Disable tag label\n                    tagLabel.setEnabled(false);\n                    // Explain in the tooltip why\n                    tagLabel.setToolTipText(tr(\"The key ''{0}'' is already used\", t.getKey()));\n                }\n                // Finally add label to the resulting panel\n                JPanel tagPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));\n                tagPanel.add(tagLabel);\n                p.add(tagPanel, GBC.eol());\n            }\n        }\n    }","id":80539,"modified_method":"private void suggestRecentlyAddedTags(JPanel p, final AutoCompletingComboBox keys, final AutoCompletingComboBox values, List<JosmAction> tagsActions, int tagsToShow, final FocusAdapter focus) {\n        if (tagsToShow > 0 && !recentTags.isEmpty()) {\n            p.add(new JLabel(tr(\"Recently added tags\")), GBC.eol());\n            \n            int count = 1;\n            // We store the maximum number (9) of recent tags to allow dynamic change of number of tags shown in the preferences.\n            // This implies to iterate in descending order, as the oldest elements will only be removed after we reach the maximum numbern and not the number of tags to show.\n            // However, as Set does not allow to iterate in descending order, we need to copy its elements into a List we can access in reverse order.\n            List<Tag> tags = new LinkedList<Tag>(recentTags.keySet());\n            for (int i = tags.size()-1; i >= 0 && count <= tagsToShow; i--, count++) {\n                final Tag t = tags.get(i);\n                // Find and display icon\n                ImageIcon icon = MapPaintStyles.getNodeIcon(t, false); // Filters deprecated icon\n                if (icon == null) {\n                    icon = new ImageIcon(new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB));\n                }\n                GridBagConstraints gbc = new GridBagConstraints();\n                gbc.ipadx = 5;\n                p.add(new JLabel(icon), gbc);\n                // Create action for reusing the tag, with keyboard shortcut Ctrl+(1-5)\n                String actionShortcutKey = \"properties:recent:\"+count;\n                Shortcut sc = Shortcut.registerShortcut(actionShortcutKey, null, KeyEvent.VK_0+count, Shortcut.CTRL);\n                final JosmAction action = new JosmAction(actionShortcutKey, null, tr(\"Use this tag again\"), sc, false) {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        keys.setSelectedItem(t.getKey());\n                        values.setSelectedItem(t.getValue());\n                        // Update list of values (fix #7951) \n                        focus.focusGained(null);\n                    }\n                };\n                tagsActions.add(action);\n                // Disable action if its key is already set on the object (the key being absent from the keys list for this reason\n                // performing this action leads to autocomplete to the next key (see #7671 comments)\n                for (int j = 0; j < propertyData.getRowCount(); ++j) {\n                    System.out.println(propertyData.getValueAt(j, 0));\n                    if (t.getKey().equals(propertyData.getValueAt(j, 0))) {\n                        action.setEnabled(false);\n                        break;\n                    }\n                }\n                // Create tag label\n                final JLabel tagLabel = new JLabel(\"<html>\"\n                    + \"<style>td{border:1px solid gray; font-weight:normal;}<\/style>\" \n                    + \"<table><tr><td>\" + t.toString() + \"<\/td><\/tr><\/table><\/html>\");\n                if (action.isEnabled()) {\n                    // Register action\n                    p.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(sc.getKeyStroke(), actionShortcutKey);\n                    p.getActionMap().put(actionShortcutKey, action);\n                    // Make the tag label clickable and set tooltip to the action description (this displays also the keyboard shortcut)\n                    tagLabel.setToolTipText((String) action.getValue(Action.SHORT_DESCRIPTION));\n                    tagLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n                    tagLabel.addMouseListener(new MouseAdapter() {\n                        @Override\n                        public void mouseClicked(MouseEvent e) {\n                            action.actionPerformed(null);\n                        }\n                    });\n                } else {\n                    // Disable tag label\n                    tagLabel.setEnabled(false);\n                    // Explain in the tooltip why\n                    tagLabel.setToolTipText(tr(\"The key ''{0}'' is already used\", t.getKey()));\n                }\n                // Finally add label to the resulting panel\n                JPanel tagPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));\n                tagPanel.add(tagLabel);\n                p.add(tagPanel, GBC.eol().fill(GBC.HORIZONTAL));\n            }\n        }\n    }","commit_id":"666fc347e55a6783cf1b5b13678b0b7c6a216d0b","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n        public boolean addToPanel(JPanel p, Collection<OsmPrimitive> sel, boolean presetInitiallyMatches) {\r\n            initializeLocaleText(tr(\"More information about this feature\"));\r\n            String url = locale_href;\r\n            if (url == null) {\r\n                url = href;\r\n            }\r\n            if (url != null) {\r\n                p.add(new UrlLabel(url, locale_text, 2), GBC.eol().insets(0, 10, 0, 0));\r\n            }\r\n            return false;\r\n        }","id":80540,"modified_method":"@Override\r\n        public boolean addToPanel(JPanel p, Collection<OsmPrimitive> sel, boolean presetInitiallyMatches) {\r\n            initializeLocaleText(tr(\"More information about this feature\"));\r\n            String url = locale_href;\r\n            if (url == null) {\r\n                url = href;\r\n            }\r\n            if (url != null) {\r\n                p.add(new UrlLabel(url, locale_text, 2), GBC.eol().insets(0, 10, 0, 0).fill(GBC.HORIZONTAL));\r\n            }\r\n            return false;\r\n        }","commit_id":"9118a66fcb54b893e09d74a37c11311a9bdd9699","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void addLabel(JPanel p, String label) {\r\n            p.add(new JLabel(label), GBC.eol());\r\n        }","id":80541,"modified_method":"/**\r\n         * Adds a new {@code JLabel} to the given panel.\r\n         * @param p The panel\r\n         * @param label The text label\r\n         */\r\n        public static void addLabel(JPanel p, String label) {\r\n            p.add(new JLabel(label), GBC.eol().fill(GBC.HORIZONTAL));\r\n        }","commit_id":"9118a66fcb54b893e09d74a37c11311a9bdd9699","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Open the add selection dialog and add a new key/value to the table (and\n     * to the dataset, of course).\n     */\n    private void addProperty() {\n        Collection<OsmPrimitive> sel;\n        if (Main.map.mapMode instanceof DrawAction) {\n            sel = ((DrawAction) Main.map.mapMode).getInProgressSelection();\n        } else {\n            DataSet ds = Main.main.getCurrentDataSet();\n            if (ds == null) return;\n            sel = ds.getSelected();\n        }\n        if (sel.isEmpty()) return;\n\n        JPanel p = new JPanel(new GridBagLayout());\n        p.add(new JLabel(\"<html>\"+trn(\"This will change up to {0} object.\",\n                \"This will change up to {0} objects.\", sel.size(),sel.size())\n                +\"<br><br>\"+tr(\"Please select a key\")), GBC.eol());\n        final AutoCompletingComboBox keys = new AutoCompletingComboBox();\n        AutoCompletionManager autocomplete = Main.main.getEditLayer().data.getAutoCompletionManager();\n        List<AutoCompletionListItem> keyList = autocomplete.getKeys();\n\n        AutoCompletionListItem itemToSelect = null;\n        // remove the object's tag keys from the list\n        Iterator<AutoCompletionListItem> iter = keyList.iterator();\n        while (iter.hasNext()) {\n            AutoCompletionListItem item = iter.next();\n            if (item.getValue().equals(lastAddKey)) {\n                itemToSelect = item;\n            }\n            for (int i = 0; i < propertyData.getRowCount(); ++i) {\n                if (item.getValue().equals(propertyData.getValueAt(i, 0))) {\n                    if (itemToSelect == item) {\n                        itemToSelect = null;\n                    }\n                    iter.remove();\n                    break;\n                }\n            }\n        }\n\n        Collections.sort(keyList, defaultACItemComparator);\n        keys.setPossibleACItems(keyList);\n        keys.setEditable(true);\n\n        p.add(keys, GBC.eop().fill());\n\n        p.add(new JLabel(tr(\"Please select a value\")), GBC.eol());\n        final AutoCompletingComboBox values = new AutoCompletingComboBox();\n        values.setEditable(true);\n        p.add(values, GBC.eop().fill());\n        if (itemToSelect != null) {\n            keys.setSelectedItem(itemToSelect);\n            /* don't add single chars, as they are no properly selected */\n            if(lastAddValue != null && lastAddValue.length() > 1) {\n                values.setSelectedItem(lastAddValue);\n            }\n        }\n        \n        int recentTagsToShow = Main.pref.getInteger(\"properties.recently-added-tags\", DEFAULT_LRU_TAGS_NUMBER);\n        if (recentTagsToShow > MAX_LRU_TAGS_NUMBER) {\n            recentTagsToShow = MAX_LRU_TAGS_NUMBER;\n        }\n        List<JosmAction> recentTagsActions = new ArrayList<JosmAction>();\n        suggestRecentlyAddedTags(p, keys, values, recentTagsActions, recentTagsToShow);\n\n        FocusAdapter focus = addFocusAdapter(-1, keys, values, autocomplete, defaultACItemComparator);\n        // fire focus event in advance or otherwise the popup list will be too small at first\n        focus.focusGained(null);\n\n        JOptionPane pane = new JOptionPane(p, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION){\n            @Override public void selectInitialValue() {\n                // save unix system selection (middle mouse paste)\n                Clipboard sysSel = Toolkit.getDefaultToolkit().getSystemSelection();\n                if(sysSel != null) {\n                    Transferable old = sysSel.getContents(null);\n                    keys.requestFocusInWindow();\n                    keys.getEditor().selectAll();\n                    sysSel.setContents(old, null);\n                } else {\n                    keys.requestFocusInWindow();\n                    keys.getEditor().selectAll();\n                }\n            }\n        };\n        JDialog dialog = pane.createDialog(Main.parent, tr(\"Add value?\"));\n        dialog.setModalityType(ModalityType.DOCUMENT_MODAL);\n        dialog.setVisible(true);\n        \n        for (JosmAction action : recentTagsActions) {\n            action.destroy();\n        }\n\n        if (!Integer.valueOf(JOptionPane.OK_OPTION).equals(pane.getValue()))\n            return;\n        String key = keys.getEditor().getItem().toString().trim();\n        String value = values.getEditor().getItem().toString().trim();\n        if (key.isEmpty() || value.isEmpty())\n            return;\n        lastAddKey = key;\n        lastAddValue = value;\n        recentTags.put(new Tag(key, value), null);\n        Main.main.undoRedo.add(new ChangePropertyCommand(sel, key, value));\n        btnAdd.requestFocusInWindow();\n    }","id":80542,"modified_method":"/**\n     * Open the add selection dialog and add a new key/value to the table (and\n     * to the dataset, of course).\n     */\n    private void addProperty() {\n        Collection<OsmPrimitive> sel;\n        if (Main.map.mapMode instanceof DrawAction) {\n            sel = ((DrawAction) Main.map.mapMode).getInProgressSelection();\n        } else {\n            DataSet ds = Main.main.getCurrentDataSet();\n            if (ds == null) return;\n            sel = ds.getSelected();\n        }\n        if (sel.isEmpty()) return;\n\n        JPanel p = new JPanel(new GridBagLayout());\n        p.add(new JLabel(\"<html>\"+trn(\"This will change up to {0} object.\",\n                \"This will change up to {0} objects.\", sel.size(),sel.size())\n                +\"<br><br>\"+tr(\"Please select a key\")), GBC.eol().fill(GBC.HORIZONTAL));\n        final AutoCompletingComboBox keys = new AutoCompletingComboBox();\n        AutoCompletionManager autocomplete = Main.main.getEditLayer().data.getAutoCompletionManager();\n        List<AutoCompletionListItem> keyList = autocomplete.getKeys();\n\n        AutoCompletionListItem itemToSelect = null;\n        // remove the object's tag keys from the list\n        Iterator<AutoCompletionListItem> iter = keyList.iterator();\n        while (iter.hasNext()) {\n            AutoCompletionListItem item = iter.next();\n            if (item.getValue().equals(lastAddKey)) {\n                itemToSelect = item;\n            }\n            for (int i = 0; i < propertyData.getRowCount(); ++i) {\n                if (item.getValue().equals(propertyData.getValueAt(i, 0))) {\n                    if (itemToSelect == item) {\n                        itemToSelect = null;\n                    }\n                    iter.remove();\n                    break;\n                }\n            }\n        }\n\n        Collections.sort(keyList, defaultACItemComparator);\n        keys.setPossibleACItems(keyList);\n        keys.setEditable(true);\n\n        p.add(keys, GBC.eop().fill());\n\n        p.add(new JLabel(tr(\"Please select a value\")), GBC.eol());\n        final AutoCompletingComboBox values = new AutoCompletingComboBox();\n        values.setEditable(true);\n        p.add(values, GBC.eop().fill());\n        if (itemToSelect != null) {\n            keys.setSelectedItem(itemToSelect);\n            /* don't add single chars, as they are no properly selected */\n            if(lastAddValue != null && lastAddValue.length() > 1) {\n                values.setSelectedItem(lastAddValue);\n            }\n        }\n        \n        int recentTagsToShow = Main.pref.getInteger(\"properties.recently-added-tags\", DEFAULT_LRU_TAGS_NUMBER);\n        if (recentTagsToShow > MAX_LRU_TAGS_NUMBER) {\n            recentTagsToShow = MAX_LRU_TAGS_NUMBER;\n        }\n        List<JosmAction> recentTagsActions = new ArrayList<JosmAction>();\n        suggestRecentlyAddedTags(p, keys, values, recentTagsActions, recentTagsToShow);\n\n        FocusAdapter focus = addFocusAdapter(-1, keys, values, autocomplete, defaultACItemComparator);\n        // fire focus event in advance or otherwise the popup list will be too small at first\n        focus.focusGained(null);\n\n        JOptionPane pane = new JOptionPane(p, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION){\n            @Override public void selectInitialValue() {\n                // save unix system selection (middle mouse paste)\n                Clipboard sysSel = Toolkit.getDefaultToolkit().getSystemSelection();\n                if(sysSel != null) {\n                    Transferable old = sysSel.getContents(null);\n                    keys.requestFocusInWindow();\n                    keys.getEditor().selectAll();\n                    sysSel.setContents(old, null);\n                } else {\n                    keys.requestFocusInWindow();\n                    keys.getEditor().selectAll();\n                }\n            }\n        };\n        JDialog dialog = pane.createDialog(Main.parent, tr(\"Add value?\"));\n        dialog.setModalityType(ModalityType.DOCUMENT_MODAL);\n        dialog.setVisible(true);\n        \n        for (JosmAction action : recentTagsActions) {\n            action.destroy();\n        }\n\n        if (!Integer.valueOf(JOptionPane.OK_OPTION).equals(pane.getValue()))\n            return;\n        String key = keys.getEditor().getItem().toString().trim();\n        String value = values.getEditor().getItem().toString().trim();\n        if (key.isEmpty() || value.isEmpty())\n            return;\n        lastAddKey = key;\n        lastAddValue = value;\n        recentTags.put(new Tag(key, value), null);\n        Main.main.undoRedo.add(new ChangePropertyCommand(sel, key, value));\n        btnAdd.requestFocusInWindow();\n    }","commit_id":"4143a6a48b1798fc22ca8b6d86b39ca65c4c1d01","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Displays a screen where the actions that would be taken are displayed and\n     * give the user the possibility to cancel the upload.\n     * @param errors The errors displayed in the screen\n     * @return <code>true<\/code>, if the upload should continue. <code>false<\/code>\n     *          if the user requested cancel.\n     */\n    private boolean displayErrorScreen(List<TestError> errors) {\n        JPanel p = new JPanel(new GridBagLayout());\n        ValidatorTreePanel errorPanel = new ValidatorTreePanel(errors);\n        errorPanel.expandAll();\n        HtmlPanel pnlMessage = new HtmlPanel();\n        pnlMessage.setText(\"<html><body>\"\n                + tr(\"The following are results of automatic validation. Try fixing\"\n                + \" these, but be careful (don''t destroy valid data).\"\n                + \" When in doubt ignore them.<br>When you\"\n                + \" cancel this dialog, you can find the entries in the validator\"\n                + \" side panel to inspect them.\")\n                + \"<table align=\\\"center\\\">\"\n                + \"<tr><td align=\\\"left\\\"><b>\"+tr(\"Errors\")\n                + \"&nbsp;<\/b><\/td><td align=\\\"left\\\">\"\n                + tr(\"Usually this should be fixed.\")+\"<\/td><\/tr>\"\n                + \"<tr><td align=\\\"left\\\"><b>\"+tr(\"Warnings\")\n                + \"&nbsp;<\/b><\/td><td align=\\\"left\\\">\"\n                + tr(\"Fix these when possible.\")+\"<\/td><\/tr>\"\n                + \"<tr><td align=\\\"left\\\"><b>\"+tr(\"Other\")\n                + \"&nbsp;<\/b><\/td><td align=\\\"left\\\">\"\n                + tr(\"Informational warnings, expect many false entries.\")+\"<\/td><\/tr>\"\n                + \"<\/table>\"\n        );\n        pnlMessage.setPreferredSize(new Dimension(500, 150));\n        p.add(pnlMessage, GBC.eol());\n        p.add(new JScrollPane(errorPanel), GBC.eol().fill(GBC.BOTH));\n\n        ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                tr(\"Suspicious data found. Upload anyway?\"),\n                new String[] {tr(\"Continue upload\"), tr(\"Cancel\")});\n        ed.setButtonIcons(new String[] {\"ok.png\", \"cancel.png\"});\n        ed.setContent(p);\n        ed.showDialog();\n\n        if (ed.getValue() != 1) {\n            OsmValidator.initializeErrorLayer();\n            Main.map.validatorDialog.unfurlDialog();\n            Main.main.getCurrentDataSet().fireSelectionChanged();\n            return false;\n        }\n        return true;\n    }","id":80543,"modified_method":"/**\n     * Displays a screen where the actions that would be taken are displayed and\n     * give the user the possibility to cancel the upload.\n     * @param errors The errors displayed in the screen\n     * @return <code>true<\/code>, if the upload should continue. <code>false<\/code>\n     *          if the user requested cancel.\n     */\n    private boolean displayErrorScreen(List<TestError> errors) {\n        JPanel p = new JPanel(new GridBagLayout());\n        ValidatorTreePanel errorPanel = new ValidatorTreePanel(errors);\n        errorPanel.expandAll();\n        HtmlPanel pnlMessage = new HtmlPanel();\n        pnlMessage.setText(\"<html><body>\"\n                + tr(\"The following are results of automatic validation. Try fixing\"\n                + \" these, but be careful (don''t destroy valid data).\"\n                + \" When in doubt ignore them.<br>When you\"\n                + \" cancel this dialog, you can find the entries in the validator\"\n                + \" side panel to inspect them.\")\n                + \"<table align=\\\"center\\\">\"\n                + \"<tr><td align=\\\"left\\\"><b>\"+tr(\"Errors\")\n                + \"&nbsp;<\/b><\/td><td align=\\\"left\\\">\"\n                + tr(\"Usually this should be fixed.\")+\"<\/td><\/tr>\"\n                + \"<tr><td align=\\\"left\\\"><b>\"+tr(\"Warnings\")\n                + \"&nbsp;<\/b><\/td><td align=\\\"left\\\">\"\n                + tr(\"Fix these when possible.\")+\"<\/td><\/tr>\"\n                + \"<tr><td align=\\\"left\\\"><b>\"+tr(\"Other\")\n                + \"&nbsp;<\/b><\/td><td align=\\\"left\\\">\"\n                + tr(\"Informational warnings, expect many false entries.\")+\"<\/td><\/tr>\"\n                + \"<\/table>\"\n        );\n        pnlMessage.setPreferredSize(new Dimension(500, 150));\n        p.add(pnlMessage, GBC.eol().fill(GBC.HORIZONTAL));\n        p.add(new JScrollPane(errorPanel), GBC.eol().fill(GBC.BOTH));\n\n        ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                tr(\"Suspicious data found. Upload anyway?\"),\n                new String[] {tr(\"Continue upload\"), tr(\"Cancel\")});\n        ed.setButtonIcons(new String[] {\"ok.png\", \"cancel.png\"});\n        ed.setContent(p);\n        ed.showDialog();\n\n        if (ed.getValue() != 1) {\n            OsmValidator.initializeErrorLayer();\n            Main.map.validatorDialog.unfurlDialog();\n            Main.main.getCurrentDataSet().fireSelectionChanged();\n            return false;\n        }\n        return true;\n    }","commit_id":"5950bef50ab75dc7773fc478d2aff7efc43d2806","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        if (!isEnabled())\n            return;\n\n        LatLonDialog dialog = new LatLonDialog(Main.parent, tr(\"Add Node...\"), ht(\"/Action/AddNode\"));\n        dialog.setVisible(true);\n        if (dialog.isCanceled())\n            return;\n\n        LatLon coordinates = dialog.getCoordinates();\n        if (coordinates == null)\n            return;\n        Node nnew = new Node(coordinates);\n\n        // add the node\n        Main.main.undoRedo.add(new AddCommand(nnew));\n        getCurrentDataSet().setSelected(nnew);\n        Main.map.mapView.repaint();\n    }","id":80544,"modified_method":"public void actionPerformed(ActionEvent e) {\n        if (!isEnabled())\n            return;\n\n        LatLonDialog dialog = new LatLonDialog(Main.parent, tr(\"Add Node...\"), ht(\"/Action/AddNode\"));\n\n        if (text != null) {\n            dialog.setText(text);\n        }\n\n        dialog.setVisible(true);\n        if (dialog.isCanceled())\n            return;\n\n        LatLon coordinates = dialog.getCoordinates();\n        if (coordinates == null)\n            return;\n\n        text = dialog.getText();\n\n        Node nnew = new Node(coordinates);\n\n        // add the node\n        Main.main.undoRedo.add(new AddCommand(nnew));\n        getCurrentDataSet().setSelected(nnew);\n        Main.map.mapView.repaint();\n    }","commit_id":"5686692b9e8f1c1143ce87b3d5dfec83672a949b","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void parseUserInput() {\r\n        Double lat = parseLatFromUserInput();\r\n        Double lon = parseLonFromUserInput();\r\n        if (lat == null || lon == null) {\r\n            coordinates = null;\r\n            actOK.setEnabled(false);\r\n        } else {\r\n            coordinates = new LatLon(lat,lon);\r\n            actOK.setEnabled(true);\r\n        }\r\n    }","id":80545,"modified_method":"protected void parseUserInput() {\r\n        LatLon latLon;\r\n        try {\r\n            latLon = parse(tfLatLon.getText());\r\n            if (!LatLon.isValidLat(latLon.lat()) || !LatLon.isValidLon(latLon.lon())) {\r\n                latLon = null;\r\n            }\r\n        } catch (IllegalArgumentException e) {\r\n            latLon = null;\r\n        }\r\n        if (latLon == null) {\r\n            setErrorFeedback(tfLatLon, tr(\"Please enter a GPS coordinates\"));\r\n            coordinates = null;\r\n            actOK.setEnabled(false);\r\n        } else {\r\n            clearErrorFeedback(tfLatLon,tr(\"Please enter a GPS coordinates\"));\r\n            coordinates = latLon;\r\n            actOK.setEnabled(true);\r\n        }\r\n    }","commit_id":"5686692b9e8f1c1143ce87b3d5dfec83672a949b","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected Double parseDoubleFromUserInput(String input) {\r\n        if (input == null) return null;\r\n        // remove white space and an optional degree symbol\r\n        //\r\n        input = input.trim();\r\n        input = input.replaceAll(\"\\u00B0\", \"\"); // the degree symbol\r\n\r\n        // try to parse using the current locale\r\n        //\r\n        NumberFormat f = NumberFormat.getNumberInstance();\r\n        Number n=null;\r\n        ParsePosition pp = new ParsePosition(0);\r\n        n = f.parse(input,pp);\r\n        if (pp.getErrorIndex() >= 0 || pp.getIndex()<input.length()) {\r\n            // fall back - try to parse with the english locale\r\n            //\r\n            pp = new ParsePosition(0);\r\n            f = NumberFormat.getNumberInstance(Locale.ENGLISH);\r\n            n = f.parse(input, pp);\r\n            if (pp.getErrorIndex() >= 0 || pp.getIndex()<input.length())\r\n                return null;\r\n        }\r\n        return n== null ? null : n.doubleValue();\r\n    }","id":80546,"modified_method":"protected Double parseDoubleFromUserInput(String input) {\r\n        if (input == null) return null;\r\n        // remove white space and an optional degree symbol\r\n        //\r\n        input = input.trim();\r\n        input = input.replaceAll(DEG, \"\");\r\n\r\n        // try to parse using the current locale\r\n        //\r\n        NumberFormat f = NumberFormat.getNumberInstance();\r\n        Number n=null;\r\n        ParsePosition pp = new ParsePosition(0);\r\n        n = f.parse(input,pp);\r\n        if (pp.getErrorIndex() >= 0 || pp.getIndex()<input.length()) {\r\n            // fall back - try to parse with the english locale\r\n            //\r\n            pp = new ParsePosition(0);\r\n            f = NumberFormat.getNumberInstance(Locale.ENGLISH);\r\n            n = f.parse(input, pp);\r\n            if (pp.getErrorIndex() >= 0 || pp.getIndex()<input.length())\r\n                return null;\r\n        }\r\n        return n== null ? null : n.doubleValue();\r\n    }","commit_id":"5686692b9e8f1c1143ce87b3d5dfec83672a949b","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected JPanel buildInputForm() {\r\n        JPanel pnl = new JPanel(new GridBagLayout());\r\n        pnl.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\r\n        pnl.add(new JLabel(\"<html>\"+\r\n                tr(\"Enter the coordinates for the new node.\") +\r\n                \"<br>\" + tr(\"Use decimal degrees.\") +\r\n                \"<br>\" + tr(\"Negative values denote Western/Southern hemisphere.\")),\r\n                GBC.eol());\r\n\r\n        pnl.add(new JLabel(tr(\"Latitude\")), GBC.std().insets(0,10,5,0));\r\n        tfLat = new JTextField(12);\r\n        pnl.add(tfLat, GBC.eol().insets(0,10,0,0));\r\n        pnl.add(new JLabel(tr(\"Longitude\")), GBC.std().insets(0,0,5,10));\r\n        tfLon = new JTextField(12);\r\n        pnl.add(tfLon, GBC.eol().insets(0,0,0,10));\r\n\r\n        // parse and verify input on the fly\r\n        //\r\n        LatLonInputVerifier inputVerifier = new LatLonInputVerifier();\r\n        tfLat.getDocument().addDocumentListener(inputVerifier);\r\n        tfLon.getDocument().addDocumentListener(inputVerifier);\r\n\r\n        // select the text in the field on focus\r\n        //\r\n        TextFieldFocusHandler focusHandler = new TextFieldFocusHandler();\r\n        tfLat.addFocusListener(focusHandler);\r\n        tfLon.addFocusListener(focusHandler);\r\n        return pnl;\r\n    }","id":80547,"modified_method":"protected JPanel buildInputForm() {\r\n        JPanel pnl = new JPanel(new GridBagLayout());\r\n        pnl.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\r\n\r\n        pnl.add(new JLabel(tr(\"Coordinates:\")), GBC.std().insets(0,10,5,0));\r\n        tfLatLon = new JTextField(24);\r\n        pnl.add(tfLatLon, GBC.eol().insets(0,10,0,0).fill(GBC.HORIZONTAL).weight(1.0, 0.0));\r\n\r\n        pnl.add(new JSeparator(), GBC.eol().fill(GBC.HORIZONTAL).insets(0,5,0,5));\r\n\r\n        pnl.add(new HtmlPanel(\r\n                tr(\"Enter the coordinates for the new node.<br/>You can separate longitude and latitude with space, comma or semicolon.<br/>\" +\r\n                \t\t\"Use positive numbers or N, E characters to indicate North or East cardinal direction.<br/>\" +\r\n                \t\t\"For South and West cardinal directions you can use either negative numbers or S, W characters.<br/>\" +\r\n                \t\t\"Coordinate value can be in one of three formats:<ul>\" +\r\n                        \"<li><i>degrees<\/i><tt>&deg;<\/tt><\/li>\" +\r\n                        \"<li><i>degrees<\/i><tt>&deg;<\/tt> <i>minutes<\/i><tt>&#39;<\/tt><\/li>\" +\r\n                        \"<li><i>degrees<\/i><tt>&deg;<\/tt> <i>minutes<\/i><tt>&#39;<\/tt> <i>seconds<\/i><tt>&quot<\/tt><\/li>\" +\r\n                \t\t\"<\/ul>\" +\r\n                \t\t\"Symbols <tt>&deg;<\/tt>, <tt>&#39;<\/tt>, <tt>&prime;<\/tt>, <tt>&quot;<\/tt>, <tt>&Prime;<\/tt> are optional.<br/><br/>\" +\r\n                \t\t\"Some examples:<ul>\" +\r\n                        \"<li>49.29918&deg; 19.24788&deg;<\/li>\" +\r\n                        \"<li>N 49.29918 E 19.24788<\/li>\" +\r\n                        \"<li>W 49&deg;29.918&#39; S 19&deg;24.788&#39;<\/li>\" +\r\n                        \"<li>N 49&deg;29&#39;04&quot; E 19&deg;24&#39;43&quot;<\/li>\" +\r\n                        \"<li>49.29918 N, 19.24788 E<\/li>\" +\r\n                        \"<li>49&deg;29&#39;21&quot; N 19&deg;24&#39;38&quot; E<\/li>\" +\r\n                        \"<li>49 29 51, 19 24 18<\/li>\" +\r\n                        \"<li>49 29, 19 24<\/li>\" +\r\n                        \"<li>E 49 29, N 19 24<\/li>\" +\r\n                        \"<li>49&deg; 29; 19&deg; 24<\/li>\" +\r\n                        \"<li>N 49&deg; 29, W 19&deg; 24<\/li>\" +\r\n                        \"<li>49&deg; 29.5 S, 19&deg; 24.6 E<\/li>\" +\r\n                        \"<li>N 49 29.918 E 19 15.88<\/li>\" +\r\n                        \"<li>49 29.4 19 24.5<\/li>\" +\r\n                        \"<li>-49 29.4 N -19 24.5 W<\/li><\/ul>\" +\r\n                        \"<li>48 deg 42' 52.13\\\" N, 21 deg 11' 47.60\\\" E<\/li><\/ul>\"\r\n                \t\t)),\r\n                GBC.eol().fill().weight(1.0, 1.0));\r\n\r\n        // parse and verify input on the fly\r\n        //\r\n        LatLonInputVerifier inputVerifier = new LatLonInputVerifier();\r\n        tfLatLon.getDocument().addDocumentListener(inputVerifier);\r\n\r\n        // select the text in the field on focus\r\n        //\r\n        TextFieldFocusHandler focusHandler = new TextFieldFocusHandler();\r\n        tfLatLon.addFocusListener(focusHandler);\r\n        return pnl;\r\n    }","commit_id":"5686692b9e8f1c1143ce87b3d5dfec83672a949b","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void setCoordinates(LatLon coordinates) {\r\n        if (coordinates == null) {\r\n            coordinates = new LatLon(0,0);\r\n        }\r\n        this.coordinates = coordinates;\r\n        tfLat.setText(coordinates.latToString(CoordinateFormat.DECIMAL_DEGREES));\r\n        tfLon.setText(coordinates.lonToString(CoordinateFormat.DECIMAL_DEGREES));\r\n        actOK.setEnabled(true);\r\n    }","id":80548,"modified_method":"public void setCoordinates(LatLon coordinates) {\r\n        if (coordinates == null) {\r\n            coordinates = new LatLon(0,0);\r\n        }\r\n        this.coordinates = coordinates;\r\n        tfLatLon.setText(coordinates.latToString(CoordinateFormat.DEGREES_MINUTES_SECONDS) + \" \" + coordinates.lonToString(CoordinateFormat.DEGREES_MINUTES_SECONDS));\r\n        actOK.setEnabled(true);\r\n    }","commit_id":"5686692b9e8f1c1143ce87b3d5dfec83672a949b","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n        public void windowOpened(WindowEvent e) {\r\n            tfLat.requestFocusInWindow();\r\n        }","id":80549,"modified_method":"@Override\r\n        public void windowOpened(WindowEvent e) {\r\n            tfLatLon.requestFocusInWindow();\r\n        }","commit_id":"5686692b9e8f1c1143ce87b3d5dfec83672a949b","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void enterMode() {\n        super.enterMode();\n        if (layer == null)\n            return;\n        if (!layer.isVisible()) {\n            layer.setVisible(true);\n        }\n        Main.map.mapView.addMouseListener(this);\n        Main.map.mapView.addMouseMotionListener(this);\n        oldDx = layer.getDx();\n        oldDy = layer.getDy();\n        offsetDialog = new ImageryOffsetDialog();\n        offsetDialog.setVisible(true);\n    }","id":80550,"modified_method":"@Override public void enterMode() {\n        super.enterMode();\n        if (layer == null)\n            return;\n        if (!layer.isVisible()) {\n            layer.setVisible(true);\n        }\n        Main.map.mapView.addMouseListener(this);\n        Main.map.mapView.addMouseMotionListener(this);\n        oldDx = layer.getDx();\n        oldDy = layer.getDy();\n        try {\n            Toolkit.getDefaultToolkit().addAWTEventListener(this, AWTEvent.KEY_EVENT_MASK);\n        } catch (SecurityException ex) {\n        }\n        offsetDialog = new ImageryOffsetDialog();\n        offsetDialog.setVisible(true);\n    }","commit_id":"3511ec2d70a738b31e9d252e2ecbe8f7b08172ac","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void exitMode() {\n        super.exitMode();\n        if (offsetDialog != null) {\n            layer.setOffset(oldDx, oldDy);\n            offsetDialog.setVisible(false);\n            offsetDialog = null;\n        }\n        Main.map.mapView.removeMouseListener(this);\n        Main.map.mapView.removeMouseMotionListener(this);\n    }","id":80551,"modified_method":"@Override public void exitMode() {\n        super.exitMode();\n        if (offsetDialog != null) {\n            layer.setOffset(oldDx, oldDy);\n            offsetDialog.setVisible(false);\n            offsetDialog = null;\n        }\n        try {\n            Toolkit.getDefaultToolkit().removeAWTEventListener(this);\n        } catch (SecurityException ex) {\n        }\n        Main.map.mapView.removeMouseListener(this);\n        Main.map.mapView.removeMouseMotionListener(this);\n    }","commit_id":"3511ec2d70a738b31e9d252e2ecbe8f7b08172ac","url":"https://github.com/openstreetmap/josm"},{"original_method":"public ImageryOffsetDialog() {\n            super(Main.parent,\n                    tr(\"Adjust imagery offset\"),\n                    new String[] { tr(\"OK\"),tr(\"Cancel\") },\n                    false);\n            setButtonIcons(new String[] { \"ok\", \"cancel\" });\n            contentInsets = new Insets(15, 15, 5, 15);\n            JPanel pnl = new JPanel();\n            pnl.setLayout(new GridBagLayout());\n            pnl.add(new JLabel(tr(\"Easting\") + \": \"),GBC.std());\n            pnl.add(easting,GBC.std().fill(GBC.HORIZONTAL).insets(0, 0, 5, 0));\n            pnl.add(new JLabel(tr(\"Northing\") + \": \"),GBC.std());\n            pnl.add(northing,GBC.eol());\n            pnl.add(new JLabel(tr(\"Bookmark name: \")),GBC.eol().insets(0,5,0,0));\n            pnl.add(tBookmarkName,GBC.eol().fill(GBC.HORIZONTAL));\n            easting.setColumns(8);\n            northing.setColumns(8);\n            easting.setValue(layer.getDx());\n            northing.setValue(layer.getDy());\n            easting.addPropertyChangeListener(\"value\",this);\n            northing.addPropertyChangeListener(\"value\",this);\n            setContent(pnl);\n            setupDialog();\n        }","id":80552,"modified_method":"public ImageryOffsetDialog() {\n            super(Main.parent,\n                    tr(\"Adjust imagery offset\"),\n                    new String[] { tr(\"OK\"),tr(\"Cancel\") },\n                    false);\n            setButtonIcons(new String[] { \"ok\", \"cancel\" });\n            contentInsets = new Insets(10, 15, 5, 15);\n            JPanel pnl = new JPanel(new GridBagLayout());\n            pnl.add(new JMultilineLabel(tr(\"Use arrow keys or drag the imagery layer with mouse to adjust the imagery offset.\\n\" +\n                    \"You can also enter east and north offset in the {0} coordinates.\\n\" +\n                    \"If you want to save the offset as bookmark, enter the bookmark name below\",Main.proj.toString())), GBC.eop());\n            pnl.add(new JLabel(tr(\"Easting\") + \": \"),GBC.std());\n            pnl.add(easting,GBC.std().fill(GBC.HORIZONTAL).insets(0, 0, 5, 0));\n            pnl.add(new JLabel(tr(\"Northing\") + \": \"),GBC.std());\n            pnl.add(northing,GBC.eol().fill(GBC.HORIZONTAL));\n            pnl.add(new JLabel(tr(\"Bookmark name: \")),GBC.eol().insets(0,5,0,0));\n            pnl.add(tBookmarkName,GBC.eol().fill(GBC.HORIZONTAL));\n            easting.setColumns(8);\n            northing.setColumns(8);\n            easting.setValue(layer.getDx());\n            northing.setValue(layer.getDy());\n            easting.addPropertyChangeListener(\"value\",this);\n            northing.addPropertyChangeListener(\"value\",this);\n            setContent(pnl);\n            setupDialog();\n        }","commit_id":"3511ec2d70a738b31e9d252e2ecbe8f7b08172ac","url":"https://github.com/openstreetmap/josm"},{"original_method":"public IClassPathItem getModuleWithDependenciesClassPathItem() {\n    Set<IModule> module = getScope().getVisibleModules();\n\n    CompositeClassPathItem item = new CompositeClassPathItem();\n    for (IModule m : module) {\n      for (String s : ((AbstractModule) m).getClassPath()) {\n        File f = new File(s);\n        if (!f.exists()) {\n          continue;\n        }\n\n        if (f.isDirectory()) {\n          item.add(new FileClassPathItem(s));\n        } else {\n          item.add(new JarFileClassPathItem(s));\n        }\n      }\n    }\n\n    return item;\n  }","id":80553,"modified_method":"public IClassPathItem getModuleWithDependenciesClassPathItem() {\n    CompositeClassPathItem item = new CompositeClassPathItem();\n    for (IModule m : getScope().getVisibleModules()) {\n      for (String s : ((AbstractModule) m).getClassPath()) {\n        IClassPathItem classPathItem = createClassPathItem(s);\n        if (classPathItem != null) {\n          item.add(classPathItem);\n        }\n      }\n    }\n\n    for (Language l : getScope().getVisibleLanguages()) {\n      for (String s : l.getClassPath()) {\n        IClassPathItem classPathItem = createClassPathItem(s);\n        if (classPathItem != null) {\n          item.add(classPathItem);\n        }\n      }\n    }\n\n    return item;\n  }","commit_id":"261395afad1b277749b1ddcad19d261f0fcef7c3","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected ElementPatternCondition(final ElementPatternCondition<T> original,\n                                    final PatternCondition<? super T> condition) {\n    myInitialCondition = original.getInitialCondition();\n    myConditions = new SmartList<PatternCondition<? super T>>(original.getConditions());\n    myConditions.add(condition);\n  }","id":80554,"modified_method":"private ElementPatternCondition(ElementPatternCondition<T> original, PatternCondition<? super T> condition) {\n    myInitialCondition = original.getInitialCondition();\n    myConditions = new SmartList<PatternCondition<? super T>>(original.getConditions());\n    myConditions.add(condition);\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final ElementPatternCondition getCondition() {\n    return myCondition;\n  }","id":80555,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public final ElementPatternCondition<T> getCondition() {\n    if (myConditions == null) {\n      return new ElementPatternCondition<T>(myInitialCondition);\n    }\n    if (myConditions instanceof PatternCondition) {\n      PatternCondition<? super T> singleCondition = (PatternCondition)myConditions;\n      return new ElementPatternCondition<T>(myInitialCondition, Collections.<PatternCondition<? super T>>singletonList(singleCondition));\n    }\n    return new ElementPatternCondition<T>(myInitialCondition, (List)myConditions);\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ObjectPattern(@NotNull final InitialPatternCondition<T> condition) {\n    myCondition = new ElementPatternCondition<T>(condition);\n  }","id":80556,"modified_method":"protected ObjectPattern(@NotNull final InitialPatternCondition<T> condition) {\n    myInitialCondition = condition;\n    myConditions = null;\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ObjectPattern(final Class<T> aClass) {\n    final Condition<Object> checker = InstanceofCheckerGenerator.getInstance().getInstanceofChecker(aClass);\n    myCondition = new ElementPatternCondition<T>(new InitialPatternCondition<T>(aClass) {\n      public boolean accepts(@Nullable final Object o, final ProcessingContext context) {\n        return checker.value(o);\n      }\n    });\n  }","id":80557,"modified_method":"protected ObjectPattern(final Class<T> aClass) {\n    this(new InitialPatternCondition<T>(aClass) {\n      final Condition<Object> checker = InstanceofCheckerGenerator.getInstance().getInstanceofChecker(aClass);\n      public boolean accepts(@Nullable final Object o, final ProcessingContext context) {\n        return checker.value(o);\n      }\n    });\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Self with(final PatternCondition<? super T> pattern) {\n    final ElementPatternCondition<T> condition = myCondition.append(pattern);\n    return adapt(condition);\n  }","id":80558,"modified_method":"public Self with(final PatternCondition<? super T> pattern) {\n    final ElementPatternCondition<T> condition = getCondition().append(pattern);\n    return adapt(condition);\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final boolean accepts(@Nullable Object t) {\n    return myCondition.accepts(t, new ProcessingContext());\n  }","id":80559,"modified_method":"public final boolean accepts(@Nullable Object t) {\n    return accepts(t, new ProcessingContext());\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    return myCondition.toString();\n  }","id":80560,"modified_method":"public String toString() {\n    return getCondition().toString();\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean accepts(@Nullable final Object o, final ProcessingContext context) {\n    return myCondition.accepts(o, context);\n  }","id":80561,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public boolean accepts(@Nullable final Object o, final ProcessingContext context) {\n    if (!myInitialCondition.accepts(o, context)) return false;\n    if (myConditions == null) return true;\n    if (o == null) return false;\n\n    if (myConditions instanceof PatternCondition) {\n      return ((PatternCondition)myConditions).accepts(o, context);\n    }\n\n    List<PatternCondition<T>> list = (List<PatternCondition<T>>)myConditions;\n    final int listSize = list.size();\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0; i < listSize; i++) {\n      if (!list.get(i).accepts((T)o, context)) return false;\n    }\n    return true;\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Self adapt(final ElementPatternCondition<T> condition) {\n    try {\n      final ObjectPattern s = (ObjectPattern)clone();\n      s.myCondition = condition;\n      return (Self)s;\n    }\n    catch (CloneNotSupportedException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":80562,"modified_method":"private Self adapt(final ElementPatternCondition<T> condition) {\n    try {\n      final ObjectPattern s = (ObjectPattern)clone();\n      s.myInitialCondition = condition.getInitialCondition();\n      List<PatternCondition<? super T>> conditions = condition.getConditions();\n      s.myConditions = conditions.isEmpty() ? null : conditions.size() == 1 ? conditions.get(0) : conditions;\n      //noinspection unchecked\n      return (Self)s;\n    }\n    catch (CloneNotSupportedException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"c51af451c8019f2ab784becb7f3aa1c286a154e0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Condition<PsiClass> createSuitabilityCondition(final PsiElement position) {\n    if (IN_CATCH_TYPE.accepts(position) ||\n        IN_MULTI_CATCH_TYPE.accepts(position) ||\n        JavaSmartCompletionContributor.AFTER_THROW_NEW.accepts(position) ||\n        INSIDE_METHOD_THROWS_CLAUSE.accepts(position)) {\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          return InheritanceUtil.isInheritor(psiClass, CommonClassNames.JAVA_LANG_THROWABLE);\n        }\n      };\n    }\n\n    if (IN_RESOURCE_TYPE.accepts(position)) {\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          return InheritanceUtil.isInheritor(psiClass, CommonClassNames.JAVA_LANG_AUTO_CLOSEABLE);\n        }\n      };\n    }\n\n    if (psiElement().withParents(PsiJavaCodeReferenceElement.class, PsiAnnotation.class).accepts(position)) {\n      final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(position, PsiAnnotation.class);\n      assert annotation != null;\n      final PsiAnnotation.TargetType[] targets = PsiImplUtil.getTargetsForLocation(annotation.getOwner());\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          return psiClass.isAnnotationType() && PsiImplUtil.findApplicableTarget(psiClass, targets) != null;\n        }\n      };\n    }\n\n    //noinspection unchecked\n    return Condition.FALSE;\n  }","id":80563,"modified_method":"private static Condition<PsiClass> createSuitabilityCondition(final PsiElement position) {\n    if (IN_CATCH_TYPE.accepts(position) || IN_MULTI_CATCH_TYPE.accepts(position)) {\n      PsiTryStatement tryStatement = PsiTreeUtil.getParentOfType(position, PsiTryStatement.class);\n      final List<PsiClass> thrownExceptions = ContainerUtil.newArrayList();\n      if (tryStatement != null && tryStatement.getTryBlock() != null) {\n        for (PsiClassType type : ExceptionUtil.getThrownExceptions(tryStatement.getTryBlock())) {\n          ContainerUtil.addIfNotNull(thrownExceptions, type.resolve());\n        }\n      }\n      if (thrownExceptions.isEmpty()) {\n        ContainerUtil.addIfNotNull(thrownExceptions, \n                                   JavaPsiFacade.getInstance(position.getProject()).findClass(\n                                     CommonClassNames.JAVA_LANG_THROWABLE, position.getResolveScope()));\n      }\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          for (PsiClass exception : thrownExceptions) {\n            if (InheritanceUtil.isInheritorOrSelf(psiClass, exception, true)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      };\n    }\n    else if (JavaSmartCompletionContributor.AFTER_THROW_NEW.accepts(position) || INSIDE_METHOD_THROWS_CLAUSE.accepts(position)) {\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          return InheritanceUtil.isInheritor(psiClass, CommonClassNames.JAVA_LANG_THROWABLE);\n        }\n      };\n    }\n\n    if (IN_RESOURCE_TYPE.accepts(position)) {\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          return InheritanceUtil.isInheritor(psiClass, CommonClassNames.JAVA_LANG_AUTO_CLOSEABLE);\n        }\n      };\n    }\n\n    if (psiElement().withParents(PsiJavaCodeReferenceElement.class, PsiAnnotation.class).accepts(position)) {\n      final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(position, PsiAnnotation.class);\n      assert annotation != null;\n      final PsiAnnotation.TargetType[] targets = PsiImplUtil.getTargetsForLocation(annotation.getOwner());\n      return new Condition<PsiClass>() {\n        @Override\n        public boolean value(PsiClass psiClass) {\n          return psiClass.isAnnotationType() && PsiImplUtil.findApplicableTarget(psiClass, targets) != null;\n        }\n      };\n    }\n\n    //noinspection unchecked\n    return Condition.FALSE;\n  }","commit_id":"6a538846f18c0e6b963599d6d98b3d534eb190be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isInCode() {\n    if (isCodeFragmentType(getTreeParent().getElementType()) || getParent() instanceof PsiAnnotation) {\n      return false;\n    }\n\n    PsiElement superParent = getParent();\n    while (superParent != null) {\n      if (superParent instanceof PsiCodeBlock || superParent instanceof PsiLocalVariable) {\n        return true;\n      }\n      if (superParent instanceof PsiClass) {\n        return false;\n      }\n      superParent = superParent.getParent();\n    }\n    return false;\n  }","id":80564,"modified_method":"private boolean isInCode() {\n    if (isCodeFragmentType(getTreeParent().getElementType()) || getParent() instanceof PsiAnnotation) {\n      return false;\n    }\n\n    PsiElement superParent = getParent();\n    while (superParent != null) {\n      if (superParent instanceof PsiCodeBlock || superParent instanceof PsiLocalVariable) {\n        return true;\n      }\n      if (superParent instanceof PsiClass || superParent instanceof PsiCatchSection) {\n        return false;\n      }\n      superParent = superParent.getParent();\n    }\n    return false;\n  }","commit_id":"6a538846f18c0e6b963599d6d98b3d534eb190be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet result) {\n    if (PsiJavaPatterns.psiElement(JavaDocTokenType.DOC_COMMENT_DATA).accepts(parameters.getPosition())) return;\n\n    super.fillCompletionVariants(parameters, result);\n  }","id":80565,"modified_method":"@Override\n  public void fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet result) {\n\n    PsiElement position = parameters.getPosition();\n    if (PsiJavaPatterns.psiElement(JavaDocTokenType.DOC_COMMENT_DATA).accepts(position)) {\n      final PsiParameter param = getDocTagParam(position.getParent());\n      if (param != null) {\n        suggestSimilarParameterDescriptions(result, position, param);\n      }\n\n      return;\n    }\n\n    super.fillCompletionVariants(parameters, result);\n  }","commit_id":"360bf1705d87bff383163f9fa57b2168b700c33c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Comparable weigh(@NotNull LookupElement element, @NotNull CompletionLocation location) {\n    final PsiElement position = location.getCompletionParameters().getPosition();\n    if (!(position.getContainingFile() instanceof GroovyFileBase)) return null;\n    if (!(position.getParent() instanceof GrReferenceElement)) return null;\n\n    final GrReferenceElement parent = (GrReferenceElement)position.getParent();\n\n    Object o = element.getObject();\n    if (o instanceof ResolveResult) {\n      o = ((ResolveResult)o).getElement();\n    }\n\n\n    final PsiElement qualifier = parent.getQualifier();\n    if (qualifier == null) {\n      if (o instanceof NamedArgumentDescriptor) {\n        switch (((NamedArgumentDescriptor)o).getPriority()) {\n          case ALWAYS_ON_TOP:\n            return NotQualifiedKind.onTop;\n          case AS_LOCAL_VARIABLE:\n            return NotQualifiedKind.local;\n          default:\n            return NotQualifiedKind.unknown;\n        }\n      }\n      if (o instanceof PsiVariable && !(o instanceof PsiField)) {\n        return NotQualifiedKind.local;\n      }\n      if (isPriorityKeyword(o)) return NotQualifiedKind.local;\n      if (isLightElement(o)) return NotQualifiedKind.unknown;\n      if (o instanceof PsiMember) {\n        final PsiClass containingClass = ((PsiMember)o).getContainingClass();\n        if (isAccessor((PsiMember)o)) return NotQualifiedKind.accessor;\n        if (o instanceof PsiClass && ((PsiClass)o).getContainingClass() == null || o instanceof PsiPackage) return NotQualifiedKind.unknown;\n        if (o instanceof PsiClass) return NotQualifiedKind.innerClass;\n        if (PsiTreeUtil.isContextAncestor(containingClass, position, false)) return NotQualifiedKind.currentClassMember;\n        return NotQualifiedKind.member;\n      }\n      return NotQualifiedKind.unknown;\n    }\n    else {\n      if (o instanceof PsiEnumConstant) return QualifiedKind.enumConstant;\n\n      if (isLightElement(o)) return QualifiedKind.unknown;\n      if (o instanceof PsiMember) {\n        if (isTrashMethod((PsiMember)o)) return QualifiedKind.unknown;\n        if (isAccessor((PsiMember)o)) return QualifiedKind.accessor;\n        if (isQualifierClassMember((PsiMember)o, qualifier)) {\n          return QualifiedKind.currentClassMember;\n        }\n        if (o instanceof PsiClass && ((PsiClass)o).getContainingClass() == null || o instanceof PsiPackage) return QualifiedKind.unknown;\n        if (o instanceof PsiClass) return QualifiedKind.innerClass;\n        return QualifiedKind.member;\n      }\n      return QualifiedKind.unknown;\n    }\n  }","id":80566,"modified_method":"@Override\n  public Comparable weigh(@NotNull LookupElement element, @NotNull CompletionLocation location) {\n    final PsiElement position = location.getCompletionParameters().getPosition();\n    if (!(position.getContainingFile() instanceof GroovyFileBase)) return null;\n\n    Object o = element.getObject();\n    if (o instanceof ResolveResult) {\n      o = ((ResolveResult)o).getElement();\n    }\n\n    final PsiElement parent = position.getParent();\n    final PsiElement qualifier = parent instanceof GrReferenceElement ? ((GrReferenceElement)parent).getQualifier() : null;\n    if (qualifier == null) {\n      if (o instanceof NamedArgumentDescriptor) {\n        switch (((NamedArgumentDescriptor)o).getPriority()) {\n          case ALWAYS_ON_TOP:\n            return NotQualifiedKind.onTop;\n          case AS_LOCAL_VARIABLE:\n            return NotQualifiedKind.local;\n          default:\n            return NotQualifiedKind.unknown;\n        }\n      }\n      if (o instanceof PsiVariable && !(o instanceof PsiField)) {\n        return NotQualifiedKind.local;\n      }\n      if (isPriorityKeyword(o)) return NotQualifiedKind.local;\n      if (isLightElement(o)) return NotQualifiedKind.unknown;\n      if (o instanceof PsiMember) {\n        final PsiClass containingClass = ((PsiMember)o).getContainingClass();\n        if (isAccessor((PsiMember)o)) return NotQualifiedKind.accessor;\n        if (o instanceof PsiClass && ((PsiClass)o).getContainingClass() == null || o instanceof PsiPackage) return NotQualifiedKind.unknown;\n        if (o instanceof PsiClass) return NotQualifiedKind.innerClass;\n        if (PsiTreeUtil.isContextAncestor(containingClass, position, false)) return NotQualifiedKind.currentClassMember;\n        return NotQualifiedKind.member;\n      }\n      return NotQualifiedKind.unknown;\n    }\n    else {\n      if (o instanceof PsiEnumConstant) return QualifiedKind.enumConstant;\n\n      if (isLightElement(o)) return QualifiedKind.unknown;\n      if (o instanceof PsiMember) {\n        if (isTrashMethod((PsiMember)o)) return QualifiedKind.unknown;\n        if (isAccessor((PsiMember)o)) return QualifiedKind.accessor;\n        if (isQualifierClassMember((PsiMember)o, qualifier)) {\n          return QualifiedKind.currentClassMember;\n        }\n        if (o instanceof PsiClass && ((PsiClass)o).getContainingClass() == null || o instanceof PsiPackage) return QualifiedKind.unknown;\n        if (o instanceof PsiClass) return QualifiedKind.innerClass;\n        return QualifiedKind.member;\n      }\n      return QualifiedKind.unknown;\n    }\n  }","commit_id":"cebd3f601741f2aafaf781a7b359744b6e93d509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isPriorityKeyword(Object o) {\n    return PsiKeyword.INSTANCEOF.equals(o);\n  }","id":80567,"modified_method":"private static boolean isPriorityKeyword(Object o) {\n    //noinspection SuspiciousMethodCalls\n    return PRIORITY_KEYWORDS.contains(o);\n  }","commit_id":"cebd3f601741f2aafaf781a7b359744b6e93d509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void completeReference(final CompletionParameters parameters,\n                                        final CompletionResultSet result,\n                                        GrReferenceElement reference, final InheritorsHolder inheritorsHolder) {\n    final PsiElement position = parameters.getPosition();\n\n    if (GroovySmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      GroovySmartCompletionContributor.generateInheritorVariants(parameters, result.getPrefixMatcher(), inheritorsHolder);\n    }\n\n    final int invocationCount = parameters.getInvocationCount();\n    final boolean firstCompletionInvoked = invocationCount < 2;\n\n    final String prefix = result.getPrefixMatcher().getPrefix();\n    final boolean skipAccessors = firstCompletionInvoked && !prefix.startsWith(\"g\") && !prefix.startsWith(\"s\") && !prefix.startsWith(\"i\");\n    result.restartCompletionOnPrefixChange(\"g\");\n    result.restartCompletionOnPrefixChange(\"i\");\n    result.restartCompletionOnPrefixChange(\"s\");\n\n    final Map<PsiModifierListOwner, LookupElement> staticMembers = hashMap();\n    final PsiElement qualifier = reference.getQualifier();\n    final PsiType qualifierType = qualifier instanceof GrExpression ? ((GrExpression)qualifier).getType() : null;\n\n    final ElementFilter classFilter = getClassFilter(position);\n\n    reference.processVariants(result.getPrefixMatcher(), parameters, new Consumer<Object>() {\n      public void consume(Object element) {\n        if (element instanceof PsiClass && inheritorsHolder.alreadyProcessed((PsiClass)element)) {\n          return;\n        }\n        if (element instanceof LookupElement && inheritorsHolder.alreadyProcessed((LookupElement)element)) {\n          return;\n        }\n\n        final LookupElement lookupElement = element instanceof PsiClass\n                                            ? GroovyCompletionUtil.createClassLookupItem((PsiClass)element)\n                                            : GroovyCompletionUtil.getLookupElement(element);\n        Object object = lookupElement.getObject();\n        PsiSubstitutor substitutor = null;\n        GroovyResolveResult resolveResult = null;\n        if (object instanceof GroovyResolveResult) {\n          resolveResult = (GroovyResolveResult)object;\n          substitutor = resolveResult.getSubstitutor();\n          object = ((GroovyResolveResult)object).getElement();\n        }\n\n        if (object instanceof PsiMember && JavaCompletionUtil.isInExcludedPackage((PsiMember)object)) {\n          return;\n        }\n\n        final boolean autopopup = parameters.getInvocationCount() == 0;\n        //skip default groovy methods\n        if (firstCompletionInvoked &&\n            object instanceof GrGdkMethod &&\n            GroovyCompletionUtil.skipDefGroovyMethod((GrGdkMethod)object, substitutor, qualifierType)) {\n          if (!autopopup) {\n            showInfo();\n          }\n          return;\n        }\n\n        //skip operator methods\n        if (firstCompletionInvoked &&\n            object instanceof PsiMethod &&\n            GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(((PsiMethod)object).getName())) {\n          if (!checkForIterator((PsiMethod)object)) {\n            if (!autopopup) {\n              showInfo();\n            }\n            return;\n          }\n        }\n\n        //skip accessors if there is no get, set, is prefix\n        if (skipAccessors && object instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyAccessor((PsiMethod)object)) {\n          if (!autopopup) {\n            showInfo();\n          }\n          return;\n        }\n\n        //skip inaccessible elements\n        if (firstCompletionInvoked && resolveResult != null && !resolveResult.isAccessible()) {\n          if (!autopopup) {\n            showInfo();\n          }\n          return;\n        }\n\n        if ((object instanceof PsiMethod || object instanceof PsiField) &&\n            ((PsiModifierListOwner)object).hasModifierProperty(PsiModifier.STATIC)) {\n          if (lookupElement.getLookupString().equals(((PsiMember)object).getName())) {\n            staticMembers.put((PsiModifierListOwner)object, lookupElement);\n            return;\n          }\n        }\n        if (object instanceof PsiClass && !classFilter.isAcceptable(object, position)) {\n          return;\n        }\n        result.addElement(JavaCompletionUtil.highlightIfNeeded(qualifierType, lookupElement, object));\n      }\n    });\n\n    if (qualifier == null) {\n      completeStaticMembers(parameters).processMembersOfRegisteredClasses(null, new PairConsumer<PsiMember, PsiClass>() {\n        @Override\n        public void consume(PsiMember member, PsiClass psiClass) {\n          if (member instanceof GrAccessorMethod) {\n            member = ((GrAccessorMethod)member).getProperty();\n          }\n          final String name = member.getName();\n          if (name == null || !result.getPrefixMatcher().prefixMatches(name)) {\n            staticMembers.remove(member);\n            return;\n          }\n          staticMembers.put(member, createGlobalMemberElement(member, psiClass, true));\n\n        }\n      });\n\n    }\n    result.addAllElements(staticMembers.values());\n  }","id":80568,"modified_method":"private static void completeReference(final CompletionParameters parameters,\n                                        final CompletionResultSet result,\n                                        GrReferenceElement reference, final InheritorsHolder inheritorsHolder) {\n    final PsiElement position = parameters.getPosition();\n\n    if (GroovySmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      GroovySmartCompletionContributor.generateInheritorVariants(parameters, result.getPrefixMatcher(), inheritorsHolder);\n    }\n\n    final int invocationCount = parameters.getInvocationCount();\n    final boolean firstCompletionInvoked = invocationCount < 2;\n\n    final String prefix = result.getPrefixMatcher().getPrefix();\n    final boolean skipAccessors = firstCompletionInvoked && !prefix.startsWith(\"g\") && !prefix.startsWith(\"s\") && !prefix.startsWith(\"i\");\n    result.restartCompletionOnPrefixChange(\"g\");\n    result.restartCompletionOnPrefixChange(\"i\");\n    result.restartCompletionOnPrefixChange(\"s\");\n\n    final Map<PsiModifierListOwner, LookupElement> staticMembers = hashMap();\n    final PsiElement qualifier = reference.getQualifier();\n    final PsiType qualifierType = qualifier instanceof GrExpression ? ((GrExpression)qualifier).getType() : null;\n\n    final ElementFilter classFilter = getClassFilter(position);\n\n    reference.processVariants(result.getPrefixMatcher(), parameters, new Consumer<Object>() {\n      public void consume(Object element) {\n        if (element instanceof PsiClass && inheritorsHolder.alreadyProcessed((PsiClass)element)) {\n          return;\n        }\n        if (element instanceof LookupElement && inheritorsHolder.alreadyProcessed((LookupElement)element)) {\n          return;\n        }\n\n        if (element instanceof LookupElement && ((LookupElement)element).getObject() instanceof PsiClass) {\n          element = ((LookupElement)element).getObject();\n        }\n\n        final LookupElement lookupElement = element instanceof PsiClass\n                                            ? GroovyCompletionUtil.createClassLookupItem(CompletionUtil.getOriginalOrSelf((PsiClass)element))\n                                            : GroovyCompletionUtil.getLookupElement(element);\n        Object object = lookupElement.getObject();\n        PsiSubstitutor substitutor = null;\n        GroovyResolveResult resolveResult = null;\n        if (object instanceof GroovyResolveResult) {\n          resolveResult = (GroovyResolveResult)object;\n          substitutor = resolveResult.getSubstitutor();\n          object = ((GroovyResolveResult)object).getElement();\n        }\n\n        if (object instanceof PsiMember && JavaCompletionUtil.isInExcludedPackage((PsiMember)object)) {\n          return;\n        }\n\n        final boolean autopopup = parameters.getInvocationCount() == 0;\n        //skip default groovy methods\n        if (firstCompletionInvoked &&\n            object instanceof GrGdkMethod &&\n            GroovyCompletionUtil.skipDefGroovyMethod((GrGdkMethod)object, substitutor, qualifierType)) {\n          if (!autopopup) {\n            showInfo();\n          }\n          return;\n        }\n\n        //skip operator methods\n        if (firstCompletionInvoked &&\n            object instanceof PsiMethod &&\n            GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(((PsiMethod)object).getName())) {\n          if (!checkForIterator((PsiMethod)object)) {\n            if (!autopopup) {\n              showInfo();\n            }\n            return;\n          }\n        }\n\n        //skip accessors if there is no get, set, is prefix\n        if (skipAccessors && object instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyAccessor((PsiMethod)object)) {\n          if (!autopopup) {\n            showInfo();\n          }\n          return;\n        }\n\n        //skip inaccessible elements\n        if (firstCompletionInvoked && resolveResult != null && !resolveResult.isAccessible()) {\n          if (!autopopup) {\n            showInfo();\n          }\n          return;\n        }\n\n        if ((object instanceof PsiMethod || object instanceof PsiField) &&\n            ((PsiModifierListOwner)object).hasModifierProperty(PsiModifier.STATIC)) {\n          if (lookupElement.getLookupString().equals(((PsiMember)object).getName())) {\n            staticMembers.put((PsiModifierListOwner)object, lookupElement);\n            return;\n          }\n        }\n        if (object instanceof PsiClass && !classFilter.isAcceptable(object, position)) {\n          return;\n        }\n        result.addElement(JavaCompletionUtil.highlightIfNeeded(qualifierType, lookupElement, object));\n      }\n    });\n\n    if (qualifier == null) {\n      completeStaticMembers(parameters).processMembersOfRegisteredClasses(null, new PairConsumer<PsiMember, PsiClass>() {\n        @Override\n        public void consume(PsiMember member, PsiClass psiClass) {\n          if (member instanceof GrAccessorMethod) {\n            member = ((GrAccessorMethod)member).getProperty();\n          }\n          final String name = member.getName();\n          if (name == null || !result.getPrefixMatcher().prefixMatches(name)) {\n            staticMembers.remove(member);\n            return;\n          }\n          staticMembers.put(member, createGlobalMemberElement(member, psiClass, true));\n\n        }\n      });\n\n    }\n    result.addAllElements(staticMembers.values());\n  }","commit_id":"cebd3f601741f2aafaf781a7b359744b6e93d509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyCompletionContributor() {\n    //provide 'this' and 'super' completions in ClassName.<caret>\n    extend(CompletionType.BASIC, AFTER_DOT, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n\n        assert position.getParent() instanceof GrReferenceExpression;\n        final GrReferenceExpression refExpr = ((GrReferenceExpression)position.getParent());\n        final GrExpression qualifier = refExpr.getQualifierExpression();\n        if (!(qualifier instanceof GrReferenceExpression)) return;\n\n        GrReferenceExpression referenceExpression = (GrReferenceExpression)qualifier;\n        final PsiElement resolved = referenceExpression.resolve();\n        if (!(resolved instanceof PsiClass)) return;\n\n        if (CompletionService.getCompletionService().getAdvertisementText() == null && parameters.getInvocationCount() > 0 &&\n            CompletionUtil.shouldShowFeature(parameters, JavaCompletionFeatures.GLOBAL_MEMBER_NAME)) {\n          final String shortcut = getActionShortcut(IdeActions.ACTION_CLASS_NAME_COMPLETION);\n          if (shortcut != null) {\n            CompletionService.getCompletionService().setAdvertisementText(\"Pressing \" + shortcut + \" without a class qualifier would show all accessible static methods\");\n          }\n        }\n\n        if (!PsiUtil.hasEnclosingInstanceInScope((PsiClass)resolved, position, false)) return;\n\n        for (String keyword : THIS_SUPER) {\n          result.addElement(LookupElementBuilder.create(keyword));\n        }\n      }\n    });\n\n    MapArgumentCompletionProvider.register(this);\n    GroovyConfigSlurperCompletionProvider.register(this);\n    MapKeysCompletionProvider.register(this);\n\n    // class name stuff\n\n    extend(CompletionType.CLASS_NAME, psiElement().withParent(GrReferenceElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (((GrReferenceElement)position.getParent()).getQualifier() != null) return;\n\n        if (StringUtil.isEmpty(result.getPrefixMatcher().getPrefix())) return;\n\n        completeStaticMembers(parameters).processStaticMethodsGlobally(result);\n      }\n    });\n\n   extend(CompletionType.CLASS_NAME, psiElement(), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        result.stopHere();\n        addAllClasses(parameters, result.withPrefixMatcher(CompletionUtil.findJavaIdentifierPrefix(parameters)), new InheritorsHolder(parameters.getPosition(), result));\n      }\n    });\n\n    extend(CompletionType.BASIC, STATEMENT_START, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        result.addElement(LookupElementBuilder.create(\"if\").setBold().setInsertHandler(new InsertHandler<LookupElement>() {\n          @Override\n          public void handleInsert(InsertionContext context, LookupElement item) {\n            if (context.getCompletionChar() != ' ') {\n              TailTypes.IF_LPARENTH.processTail(context.getEditor(), context.getTailOffset());\n            }\n            if (context.getCompletionChar() == '(') {\n              context.setAddCompletionChar(false);\n            }\n            }\n        }));\n      }\n    });\n\n    extend(CompletionType.BASIC, psiElement(PsiElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        GroovyCompletionData.addGroovyDocKeywords(parameters, result);\n\n        PsiElement position = parameters.getPosition();\n        if (psiElement().inside(false, psiElement(PsiComment.class)).accepts(position)) {\n          return;\n        }\n\n        GroovyCompletionData.addGroovyKeywords(parameters, result);\n\n\n        suggestVariableNames(position, result);\n\n        addUnfinishedMethodTypeParameters(position, result);\n\n        final PsiElement parent = position.getParent();\n        if (parent instanceof GrReferenceElement) {\n          GrReferenceElement reference = (GrReferenceElement)parent;\n          if (parent.getParent() instanceof GrImportStatement && reference.getQualifier() != null) {\n            result.addElement(LookupElementBuilder.create(\"*\"));\n          }\n\n          InheritorsHolder inheritors = new InheritorsHolder(position, result);\n          completeReference(parameters, result, reference, inheritors);\n\n          if (reference.getQualifier() == null) {\n            GroovySmartCompletionContributor.addExpectedClassMembers(parameters, result);\n\n            if (isClassNamePossible(position) && JavaCompletionContributor.mayStartClassName(result, parameters.isRelaxedMatching())) {\n              if (JavaCompletionContributor.mayShowAllClasses(parameters)) {\n                addAllClasses(parameters, result, inheritors);\n              } else {\n                JavaCompletionContributor.advertiseSecondCompletion(position.getProject());\n              }\n            }\n          }\n\n        } else if (IN_CATCH_TYPE.accepts(position) ||\n                   AFTER_AT.accepts(position) ||\n                   GroovyCompletionUtil.isFirstElementAfterPossibleModifiersInVariableDeclaration(position, true)) {\n          addAllClasses(parameters, result, new InheritorsHolder(position, result));\n        }\n      }\n    });\n\n    extend(CompletionType.BASIC, psiElement().withParent(GrLiteral.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final Set<String> usedWords = new THashSet<String>();\n        result.runRemainingContributors(parameters, new Consumer<CompletionResult>() {\n          public void consume(CompletionResult element) {\n            result.passResult(element);\n            usedWords.add(element.getLookupElement().getLookupString());\n          }\n        });\n        PsiReference reference = parameters.getPosition().getContainingFile().findReferenceAt(parameters.getOffset());\n        if (reference == null || reference.isSoft()) {\n          WordCompletionContributor.addWordCompletionVariants(result, parameters, usedWords);\n        }\n      }\n    });\n\n  }","id":80569,"modified_method":"public GroovyCompletionContributor() {\n    //provide 'this' and 'super' completions in ClassName.<caret>\n    extend(CompletionType.BASIC, AFTER_DOT, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n\n        assert position.getParent() instanceof GrReferenceExpression;\n        final GrReferenceExpression refExpr = ((GrReferenceExpression)position.getParent());\n        final GrExpression qualifier = refExpr.getQualifierExpression();\n        if (!(qualifier instanceof GrReferenceExpression)) return;\n\n        GrReferenceExpression referenceExpression = (GrReferenceExpression)qualifier;\n        final PsiElement resolved = referenceExpression.resolve();\n        if (!(resolved instanceof PsiClass)) return;\n\n        if (CompletionService.getCompletionService().getAdvertisementText() == null && parameters.getInvocationCount() > 0 &&\n            CompletionUtil.shouldShowFeature(parameters, JavaCompletionFeatures.GLOBAL_MEMBER_NAME)) {\n          final String shortcut = getActionShortcut(IdeActions.ACTION_CLASS_NAME_COMPLETION);\n          if (shortcut != null) {\n            CompletionService.getCompletionService().setAdvertisementText(\"Pressing \" + shortcut + \" without a class qualifier would show all accessible static methods\");\n          }\n        }\n\n        if (!PsiUtil.hasEnclosingInstanceInScope((PsiClass)resolved, position, false)) return;\n\n        for (String keyword : THIS_SUPER) {\n          result.addElement(LookupElementBuilder.create(keyword));\n        }\n      }\n    });\n\n    MapArgumentCompletionProvider.register(this);\n    GroovyConfigSlurperCompletionProvider.register(this);\n    MapKeysCompletionProvider.register(this);\n\n    // class name stuff\n\n    extend(CompletionType.CLASS_NAME, psiElement().withParent(GrReferenceElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        if (((GrReferenceElement)position.getParent()).getQualifier() != null) return;\n\n        if (StringUtil.isEmpty(result.getPrefixMatcher().getPrefix())) return;\n\n        completeStaticMembers(parameters).processStaticMethodsGlobally(result);\n      }\n    });\n\n   extend(CompletionType.CLASS_NAME, psiElement(), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        result.stopHere();\n        addAllClasses(parameters, result.withPrefixMatcher(CompletionUtil.findJavaIdentifierPrefix(parameters)), new InheritorsHolder(parameters.getPosition(), result));\n      }\n    });\n\n    extend(CompletionType.BASIC, STATEMENT_START, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        result.addElement(LookupElementBuilder.create(\"if\").setBold().setInsertHandler(new InsertHandler<LookupElement>() {\n          @Override\n          public void handleInsert(InsertionContext context, LookupElement item) {\n            if (context.getCompletionChar() != ' ') {\n              TailTypes.IF_LPARENTH.processTail(context.getEditor(), context.getTailOffset());\n            }\n            if (context.getCompletionChar() == '(') {\n              context.setAddCompletionChar(false);\n            }\n            }\n        }));\n      }\n    });\n\n    extend(CompletionType.BASIC, psiElement(PsiElement.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        GroovyCompletionData.addGroovyDocKeywords(parameters, result);\n\n        PsiElement position = parameters.getPosition();\n        if (psiElement().inside(false, psiElement(PsiComment.class)).accepts(position)) {\n          return;\n        }\n\n        GroovyCompletionData.addGroovyKeywords(parameters, result);\n\n\n        suggestVariableNames(position, result);\n\n        addUnfinishedMethodTypeParameters(position, result);\n\n        final PsiElement parent = position.getParent();\n        GrReferenceElement reference;\n        if (parent instanceof GrReferenceElement) {\n          reference = (GrReferenceElement)parent;\n          if (reference.getParent() instanceof GrImportStatement && reference.getQualifier() != null) {\n            result.addElement(LookupElementBuilder.create(\"*\"));\n          }\n        } else if (couldContainReference(position)) {\n          reference = GroovyPsiElementFactory.getInstance(position.getProject()).createReferenceElementFromText(\"Foo\", position);\n        } else {\n          return;\n        }\n\n        InheritorsHolder inheritors = new InheritorsHolder(position, result);\n        completeReference(parameters, result, reference, inheritors);\n\n        if (reference.getQualifier() == null) {\n          GroovySmartCompletionContributor.addExpectedClassMembers(parameters, result);\n\n          if (isClassNamePossible(position) && JavaCompletionContributor.mayStartClassName(result, parameters.isRelaxedMatching())) {\n            if (JavaCompletionContributor.mayShowAllClasses(parameters)) {\n              addAllClasses(parameters, result, inheritors);\n            } else {\n              JavaCompletionContributor.advertiseSecondCompletion(position.getProject());\n            }\n          }\n        }\n      }\n    });\n\n    extend(CompletionType.BASIC, psiElement().withParent(GrLiteral.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull final CompletionResultSet result) {\n        final Set<String> usedWords = new THashSet<String>();\n        result.runRemainingContributors(parameters, new Consumer<CompletionResult>() {\n          public void consume(CompletionResult element) {\n            result.passResult(element);\n            usedWords.add(element.getLookupElement().getLookupString());\n          }\n        });\n        PsiReference reference = parameters.getPosition().getContainingFile().findReferenceAt(parameters.getOffset());\n        if (reference == null || reference.isSoft()) {\n          WordCompletionContributor.addWordCompletionVariants(result, parameters, usedWords);\n        }\n      }\n    });\n\n  }","commit_id":"cebd3f601741f2aafaf781a7b359744b6e93d509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isClassNamePossible(PsiElement position) {\n    PsiElement parent = position.getParent();\n    return parent instanceof GrReferenceElement && ((GrReferenceElement)parent).getQualifier() == null &&\n           !PsiJavaPatterns.psiElement().inside(GrImportStatement.class).accepts(position);\n  }","id":80570,"modified_method":"public static boolean isClassNamePossible(PsiElement position) {\n    if (PsiJavaPatterns.psiElement().inside(GrImportStatement.class).accepts(position)) {\n      return false;\n    }\n\n    PsiElement parent = position.getParent();\n    if (parent instanceof GrReferenceElement) {\n      return ((GrReferenceElement)parent).getQualifier() == null;\n    }\n    return couldContainReference(position);\n  }","commit_id":"cebd3f601741f2aafaf781a7b359744b6e93d509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addPrimitiveTypes(CompletionResultSet result, PsiElement position) {\n    boolean inCast = psiElement()\n      .afterLeaf(psiElement().withText(\"(\").withParent(psiElement(PsiParenthesizedExpression.class, PsiTypeCastExpression.class)))\n      .accepts(position);\n\n    boolean typeFragment = position.getContainingFile() instanceof PsiTypeCodeFragment && PsiTreeUtil.prevVisibleLeaf(position) == null;\n    boolean declaration = DECLARATION_START.accepts(position);\n    boolean expressionPosition = isExpressionPosition(position);\n    if (START_FOR.accepts(position) ||\n        isInsideParameterList(position) && !AFTER_DOT.accepts(position) ||\n        VARIABLE_AFTER_FINAL.accepts(position) ||\n        inCast ||\n        declaration ||\n        typeFragment ||\n        expressionPosition ||\n        isStatementPosition(position)) {\n      for (String primitiveType : PRIMITIVE_TYPES) {\n        LookupElement keyword = createKeyword(position, primitiveType);\n        result.addElement(inCast || typeFragment || expressionPosition ? keyword : new OverrideableSpace(keyword, TailType.HUMBLE_SPACE_BEFORE_WORD));\n      }\n    }\n    if (declaration) {\n      result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.VOID), TailType.HUMBLE_SPACE_BEFORE_WORD));\n    } else if (typeFragment && ((PsiTypeCodeFragment)position.getContainingFile()).isVoidValid()) {\n      result.addElement(createKeyword(position, PsiKeyword.VOID));\n    }\n  }","id":80571,"modified_method":"private static void addPrimitiveTypes(CompletionResultSet result, PsiElement position) {\n    if (AFTER_DOT.accepts(position)) {\n      return;\n    }\n\n    boolean inCast = psiElement()\n      .afterLeaf(psiElement().withText(\"(\").withParent(psiElement(PsiParenthesizedExpression.class, PsiTypeCastExpression.class)))\n      .accepts(position);\n\n    boolean typeFragment = position.getContainingFile() instanceof PsiTypeCodeFragment && PsiTreeUtil.prevVisibleLeaf(position) == null;\n    boolean declaration = DECLARATION_START.accepts(position);\n    boolean expressionPosition = isExpressionPosition(position);\n    boolean inGenerics = PsiTreeUtil.getParentOfType(position, PsiReferenceParameterList.class) != null;\n    if (START_FOR.accepts(position) ||\n        isInsideParameterList(position) ||\n        inGenerics ||\n        VARIABLE_AFTER_FINAL.accepts(position) ||\n        inCast ||\n        declaration ||\n        typeFragment ||\n        expressionPosition ||\n        isStatementPosition(position)) {\n      boolean needSpace = !inCast && !typeFragment && !expressionPosition && !inGenerics;\n      for (String primitiveType : PRIMITIVE_TYPES) {\n        LookupElement keyword = createKeyword(position, primitiveType);\n        result.addElement(needSpace ? new OverrideableSpace(keyword, TailType.HUMBLE_SPACE_BEFORE_WORD) : keyword);\n      }\n    }\n    if (declaration) {\n      result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.VOID), TailType.HUMBLE_SPACE_BEFORE_WORD));\n    }\n    else if (typeFragment && ((PsiTypeCodeFragment)position.getContainingFile()).isVoidValid()) {\n      result.addElement(createKeyword(position, PsiKeyword.VOID));\n    }\n  }","commit_id":"18a6cf6a1b3a159f6504754127a5679d0d00d4e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static ElementFilter getReferenceFilter(PsiElement position) {\n    // Completion after extends in interface, type parameter and implements in class\n    final PsiClass containingClass = PsiTreeUtil.getParentOfType(position, PsiClass.class, false, PsiCodeBlock.class, PsiMethod.class, PsiExpressionList.class, PsiVariable.class);\n    if (containingClass != null && psiElement().afterLeaf(PsiKeyword.EXTENDS, PsiKeyword.IMPLEMENTS, \",\", \"&\").accepts(position)) {\n      return new AndFilter(ElementClassFilter.CLASS, new NotFilter(new AssignableFromContextFilter()));\n    }\n\n    if (JavaCompletionData.DECLARATION_START.isAcceptable(position, position) ||\n        JavaCompletionData.INSIDE_PARAMETER_LIST.accepts(position)) {\n      return new OrFilter(ElementClassFilter.CLASS, ElementClassFilter.PACKAGE_FILTER);\n    }\n\n    if (INSIDE_METHOD_THROWS_CLAUSE.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE);\n    }\n\n    if (psiElement().afterLeaf(PsiKeyword.INSTANCEOF).accepts(position)) {\n      return new ElementExtractorFilter(ElementClassFilter.CLASS);\n    }\n\n    if (JavaCompletionData.VARIABLE_AFTER_FINAL.accepts(position)) {\n      return ElementClassFilter.CLASS;\n    }\n\n    if (JavaCompletionData.AFTER_TRY_BLOCK.isAcceptable(position, position) ||\n        JavaCompletionData.START_SWITCH.isAcceptable(position, position) ||\n        JavaCompletionData.INSTANCEOF_PLACE.isAcceptable(position, position)) {\n      return null;\n    }\n\n    if (JavaCompletionData.START_FOR.accepts(position)) {\n      return ElementClassFilter.VARIABLE;\n    }\n\n    if (IN_CATCH_TYPE.accepts(position) || IN_MULTI_CATCH_TYPE.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE);\n    }\n\n    if (IN_RESOURCE_TYPE.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_AUTO_CLOSEABLE);\n    }\n\n    if (JavaSmartCompletionContributor.AFTER_THROW_NEW.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE);\n    }\n\n    if (JavaSmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      return ElementClassFilter.CLASS;\n    }\n\n    if (psiElement().inside(PsiReferenceParameterList.class).accepts(position)) {\n      return ElementClassFilter.CLASS;\n    }\n\n    if (psiElement().inside(PsiAnnotationParameterList.class).accepts(position)) {\n      return new OrFilter(new ClassFilter(PsiAnnotationMethod.class),\n                          ElementClassFilter.CLASS,\n                          ElementClassFilter.PACKAGE_FILTER,\n                          new AndFilter(new ClassFilter(PsiField.class), new ModifierFilter(PsiModifier.STATIC, PsiModifier.FINAL)));\n    }\n\n    if (psiElement().afterLeaf(\"=\").inside(PsiVariable.class).accepts(position)) {\n      return new OrFilter(\n        new ClassFilter(PsiVariable.class, false),\n        new ExcludeDeclaredFilter(new ClassFilter(PsiVariable.class)));\n    }\n\n    if (SWITCH_LABEL.accepts(position)) {\n      return new ClassFilter(PsiField.class) {\n        @Override\n        public boolean isAcceptable(Object element, PsiElement context) {\n          return element instanceof PsiEnumConstant;\n        }\n      };\n    }\n\n    return TrueFilter.INSTANCE;\n  }","id":80572,"modified_method":"@Nullable\n  private static ElementFilter getReferenceFilter(PsiElement position) {\n    // Completion after extends in interface, type parameter and implements in class\n    final PsiClass containingClass = PsiTreeUtil.getParentOfType(position, PsiClass.class, false, PsiCodeBlock.class, PsiMethod.class, PsiExpressionList.class, PsiVariable.class);\n    if (containingClass != null && psiElement().afterLeaf(PsiKeyword.EXTENDS, PsiKeyword.IMPLEMENTS, \",\", \"&\").accepts(position)) {\n      return new AndFilter(ElementClassFilter.CLASS, new NotFilter(new AssignableFromContextFilter()));\n    }\n\n    if (JavaCompletionData.DECLARATION_START.isAcceptable(position, position) ||\n        JavaCompletionData.INSIDE_PARAMETER_LIST.accepts(position)) {\n      return new OrFilter(ElementClassFilter.CLASS, ElementClassFilter.PACKAGE_FILTER);\n    }\n\n    if (INSIDE_METHOD_THROWS_CLAUSE.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE);\n    }\n\n    if (psiElement().afterLeaf(PsiKeyword.INSTANCEOF).accepts(position)) {\n      return new ElementExtractorFilter(ElementClassFilter.CLASS);\n    }\n\n    if (JavaCompletionData.VARIABLE_AFTER_FINAL.accepts(position)) {\n      return ElementClassFilter.CLASS;\n    }\n\n    if (JavaCompletionData.AFTER_TRY_BLOCK.isAcceptable(position, position) ||\n        JavaCompletionData.START_SWITCH.isAcceptable(position, position) ||\n        JavaCompletionData.INSTANCEOF_PLACE.isAcceptable(position, position) ||\n        JavaCompletionData.isAfterPrimitiveOrArrayType(position)) {\n      return null;\n    }\n\n    if (JavaCompletionData.START_FOR.accepts(position)) {\n      return ElementClassFilter.VARIABLE;\n    }\n\n    if (IN_CATCH_TYPE.accepts(position) || IN_MULTI_CATCH_TYPE.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE);\n    }\n\n    if (IN_RESOURCE_TYPE.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_AUTO_CLOSEABLE);\n    }\n\n    if (JavaSmartCompletionContributor.AFTER_THROW_NEW.accepts(position)) {\n      return new AssignableFromFilter(CommonClassNames.JAVA_LANG_THROWABLE);\n    }\n\n    if (JavaSmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      return ElementClassFilter.CLASS;\n    }\n\n    if (psiElement().inside(PsiReferenceParameterList.class).accepts(position)) {\n      return ElementClassFilter.CLASS;\n    }\n\n    if (psiElement().inside(PsiAnnotationParameterList.class).accepts(position)) {\n      return new OrFilter(new ClassFilter(PsiAnnotationMethod.class),\n                          ElementClassFilter.CLASS,\n                          ElementClassFilter.PACKAGE_FILTER,\n                          new AndFilter(new ClassFilter(PsiField.class), new ModifierFilter(PsiModifier.STATIC, PsiModifier.FINAL)));\n    }\n\n    if (psiElement().afterLeaf(\"=\").inside(PsiVariable.class).accepts(position)) {\n      return new OrFilter(\n        new ClassFilter(PsiVariable.class, false),\n        new ExcludeDeclaredFilter(new ClassFilter(PsiVariable.class)));\n    }\n\n    if (SWITCH_LABEL.accepts(position)) {\n      return new ClassFilter(PsiField.class) {\n        @Override\n        public boolean isAcceptable(Object element, PsiElement context) {\n          return element instanceof PsiEnumConstant;\n        }\n      };\n    }\n\n    return TrueFilter.INSTANCE;\n  }","commit_id":"9ddcf4fde83d75c47acbeafd03ac8a1898551c36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet _result) {\n    if (parameters.getCompletionType() != CompletionType.BASIC) {\n      return;\n    }\n\n    final PsiElement position = parameters.getPosition();\n    if (!position.getContainingFile().getLanguage().isKindOf(StdLanguages.JAVA)) {\n      return;\n    }\n\n    if (AFTER_NUMBER_LITERAL.accepts(position)) {\n      _result.stopHere();\n      return;\n    }\n\n    final CompletionResultSet result = JavaCompletionSorting.addJavaSorting(parameters, _result);\n\n    if (ANNOTATION_ATTRIBUTE_NAME.accepts(position)) {\n      completeAnnotationAttributeName(result, position, parameters);\n      result.stopHere();\n      return;\n    }\n\n    final InheritorsHolder inheritors = new InheritorsHolder(position, result);\n    if (JavaSmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      new JavaInheritorsGetter(ConstructorInsertHandler.BASIC_INSTANCE).generateVariants(parameters, result.getPrefixMatcher(), inheritors);\n    }\n\n    if (IMPORT_REFERENCE.accepts(position)) {\n      result.addElement(LookupElementBuilder.create(\"*\"));\n    }\n\n    Set<String> usedWords = addReferenceVariants(parameters, result, inheritors);\n\n    addKeywords(parameters, result);\n\n    if (psiElement().inside(PsiLiteralExpression.class).accepts(position)) {\n      PsiReference reference = position.getContainingFile().findReferenceAt(parameters.getOffset());\n      if (reference == null || reference.isSoft()) {\n        WordCompletionContributor.addWordCompletionVariants(result, parameters, usedWords);\n      }\n    }\n\n    addAllClasses(parameters, result, inheritors);\n    result.stopHere();\n  }","id":80573,"modified_method":"public void fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet _result) {\n    if (parameters.getCompletionType() != CompletionType.BASIC) {\n      return;\n    }\n\n    final PsiElement position = parameters.getPosition();\n    if (!position.getContainingFile().getLanguage().isKindOf(StdLanguages.JAVA)) {\n      return;\n    }\n\n    if (AFTER_NUMBER_LITERAL.accepts(position)) {\n      _result.stopHere();\n      return;\n    }\n\n    final CompletionResultSet result = JavaCompletionSorting.addJavaSorting(parameters, _result);\n\n    if (ANNOTATION_ATTRIBUTE_NAME.accepts(position) && !JavaCompletionData.isAfterPrimitiveOrArrayType(position)) {\n      completeAnnotationAttributeName(result, position, parameters);\n      result.stopHere();\n      return;\n    }\n\n    final InheritorsHolder inheritors = new InheritorsHolder(position, result);\n    if (JavaSmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      new JavaInheritorsGetter(ConstructorInsertHandler.BASIC_INSTANCE).generateVariants(parameters, result.getPrefixMatcher(), inheritors);\n    }\n\n    if (IMPORT_REFERENCE.accepts(position)) {\n      result.addElement(LookupElementBuilder.create(\"*\"));\n    }\n\n    Set<String> usedWords = addReferenceVariants(parameters, result, inheritors);\n\n    addKeywords(parameters, result);\n\n    if (psiElement().inside(PsiLiteralExpression.class).accepts(position)) {\n      PsiReference reference = position.getContainingFile().findReferenceAt(parameters.getOffset());\n      if (reference == null || reference.isSoft()) {\n        WordCompletionContributor.addWordCompletionVariants(result, parameters, usedWords);\n      }\n    }\n\n    addAllClasses(parameters, result, inheritors);\n    result.stopHere();\n  }","commit_id":"9ddcf4fde83d75c47acbeafd03ac8a1898551c36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isClassNamePossible(final PsiElement position) {\n    final PsiElement parent = position.getParent();\n    if (!(parent instanceof PsiJavaCodeReferenceElement)) return false;\n    if (((PsiJavaCodeReferenceElement)parent).getQualifier() != null) return false;\n\n    if (parent instanceof PsiJavaCodeReferenceElementImpl &&\n        ((PsiJavaCodeReferenceElementImpl)parent).getKind() == PsiJavaCodeReferenceElementImpl.PACKAGE_NAME_KIND) {\n      return false;\n    }\n\n    PsiElement grand = parent.getParent();\n    if (grand instanceof PsiSwitchLabelStatement) {\n      return false;\n    }\n\n    if (psiElement().inside(PsiImportStatement.class).accepts(parent)) {\n      return false;\n    }\n\n    if (grand instanceof PsiAnonymousClass) {\n      grand = grand.getParent();\n    }\n    if (grand instanceof PsiNewExpression && ((PsiNewExpression)grand).getQualifier() != null) {\n      return false;\n    }\n    return true;\n  }","id":80574,"modified_method":"public static boolean isClassNamePossible(final PsiElement position) {\n    final PsiElement parent = position.getParent();\n    if (!(parent instanceof PsiJavaCodeReferenceElement)) return false;\n    if (((PsiJavaCodeReferenceElement)parent).getQualifier() != null) return false;\n\n    if (parent instanceof PsiJavaCodeReferenceElementImpl &&\n        ((PsiJavaCodeReferenceElementImpl)parent).getKind() == PsiJavaCodeReferenceElementImpl.PACKAGE_NAME_KIND) {\n      return false;\n    }\n\n    PsiElement grand = parent.getParent();\n    if (grand instanceof PsiSwitchLabelStatement) {\n      return false;\n    }\n\n    if (psiElement().inside(PsiImportStatement.class).accepts(parent)) {\n      return false;\n    }\n\n    if (grand instanceof PsiAnonymousClass) {\n      grand = grand.getParent();\n    }\n    if (grand instanceof PsiNewExpression && ((PsiNewExpression)grand).getQualifier() != null) {\n      return false;\n    }\n\n    if (JavaCompletionData.isAfterPrimitiveOrArrayType(position)) {\n      return false;\n    }\n    \n    return true;\n  }","commit_id":"9ddcf4fde83d75c47acbeafd03ac8a1898551c36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addClassLiteral(CompletionResultSet result, PsiElement position) {\n    if (psiElement().afterLeaf(psiElement().withText(\".\").afterLeaf(\n      or(\n        psiElement().withParent(psiElement().referencing(psiClass())),\n        psiElement().withText(string().oneOf(\"]\", PsiKeyword.VOID)),\n        psiElement().withText(string().oneOf(PRIMITIVE_TYPES))\n      ))).accepts(position) &&\n        !INSIDE_PARAMETER_LIST.accepts(position) &&\n        !(position.getContainingFile() instanceof PsiJavaCodeReferenceCodeFragment)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n  }","id":80575,"modified_method":"private static void addClassLiteral(CompletionResultSet result, PsiElement position) {\n    if (INSIDE_PARAMETER_LIST.accepts(position) || position.getContainingFile() instanceof PsiJavaCodeReferenceCodeFragment) {\n      return;\n    }\n\n    if (psiElement().afterLeaf(psiElement().withText(\".\").afterLeaf(CLASS_REFERENCE)).accepts(position) ||\n        isAfterPrimitiveOrArrayType(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n  }","commit_id":"9ddcf4fde83d75c47acbeafd03ac8a1898551c36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public URL getResource(String name) \n    {\n        return findResource(name);\n    }","id":80576,"modified_method":"public URL getResource( String name ) \n    {\n        URL url = findResource( name );\n        if ( url == null )\n        {\n            url = super.getResource( name );\n        }\n        return url;\n    }","commit_id":"a05009e82b6076852e2412b91ef1968735e6f005","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Enumeration getResources(String name) throws IOException \n    {\n        return findResources(name);\n    }","id":80577,"modified_method":"public Enumeration getResources( String name ) throws IOException \n    {\n        Enumeration en = findResources( name );\n        if ( en == null || !en.hasMoreElements() )\n        {\n            en = super.getResources( name );\n        }\n        return en;\n    }","commit_id":"a05009e82b6076852e2412b91ef1968735e6f005","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)\n     */\n    public void start(BundleContext context) throws Exception {\n        this.packageAdminTracker = new ServiceTracker(context, PACKAGE_ADMIN_NAME, null);\n        this.packageAdminTracker.open();\n\n        // register service\n        final Hashtable<String, String> props = new Hashtable<String, String>();\n        props.put(Constants.SERVICE_DESCRIPTION, \"Apache Sling Dynamic Class Loader Service\");\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        this.service = new DynamicClassLoaderManagerFactory(context,\n                (PackageAdmin)this.packageAdminTracker.getService());\n        this.serviceReg = context.registerService(new String[] {DynamicClassLoaderManager.class.getName()}, service, props);\n    }","id":80578,"modified_method":"/**\n     * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)\n     */\n    public void start(BundleContext context) {\n        this.bundleContext = context;\n\n        this.packageAdminTracker = new ServiceTracker(this.bundleContext, PACKAGE_ADMIN_NAME, null);\n        this.packageAdminTracker.open();\n\n        // register service\n        this.registerManagerFactory();\n        this.bundleContext.addBundleListener(this);\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n     */\n    public void stop(BundleContext context) throws Exception {\n        if ( this.serviceReg != null ) {\n            this.serviceReg.unregister();\n            this.serviceReg = null;\n        }\n        if ( this.service != null ) {\n            this.service = null;\n        }\n        if ( this.packageAdminTracker != null ) {\n            this.packageAdminTracker.close();\n            this.packageAdminTracker = null;\n        }\n    }","id":80579,"modified_method":"/**\n     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n     */\n    public void stop(BundleContext context) {\n        context.removeBundleListener(this);\n        this.unregisterManagerFactory();\n        if ( this.packageAdminTracker != null ) {\n            this.packageAdminTracker.close();\n            this.packageAdminTracker = null;\n        }\n        this.bundleContext = null;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#loadClass(java.lang.String)\n     */\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        final ClassLoader[] loaders = manager.getDynamicClassLoaders();\n        for(final ClassLoader cl : loaders) {\n            if ( cl != null ) {\n                try {\n                    final Class<?> c = cl.loadClass(name);\n                    return c;\n                } catch (Exception cnfe) {\n                    // we just ignore this and try the next class loader\n                }\n            }\n        }\n        throw new ClassNotFoundException(\"Class not found: \" + name);\n    }","id":80580,"modified_method":"/**\n     * @see java.lang.ClassLoader#loadClass(java.lang.String)\n     */\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        if ( !this.manager.isActive() ) {\n            throw new RuntimeException(\"Dynamic class loader has already been deactivated.\");\n        }\n        final Class<?> cachedClass = this.classCache.get(name);\n        if ( cachedClass != null ) {\n            return cachedClass;\n        }\n        final ClassLoader[] loaders = manager.getDynamicClassLoaders();\n        for(final ClassLoader cl : loaders) {\n            if ( cl != null ) {\n                try {\n                    final Class<?> c = cl.loadClass(name);\n                    this.classCache.put(name, c);\n                    return c;\n                } catch (Exception cnfe) {\n                    cnfe.printStackTrace();\n                    // we just ignore this and try the next class loader\n                }\n            }\n        }\n        throw new ClassNotFoundException(\"Class not found: \" + name);\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#getResources(java.lang.String)\n     */\n    public Enumeration<URL> getResources(String name) throws IOException {\n        final ClassLoader[] loaders = manager.getDynamicClassLoaders();\n        for(final ClassLoader cl : loaders) {\n            if ( cl != null ) {\n                final Enumeration<URL> e = cl.getResources(name);\n                if ( e != null && e.hasMoreElements() ) {\n                    return e;\n                }\n            }\n        }\n        return null;\n    }","id":80581,"modified_method":"/**\n     * @see java.lang.ClassLoader#getResources(java.lang.String)\n     */\n    public Enumeration<URL> getResources(String name) throws IOException {\n        if ( !this.manager.isActive() ) {\n            throw new RuntimeException(\"Dynamic class loader has already been deactivated.\");\n        }\n        final ClassLoader[] loaders = manager.getDynamicClassLoaders();\n        for(final ClassLoader cl : loaders) {\n            if ( cl != null ) {\n                final Enumeration<URL> e = cl.getResources(name);\n                if ( e != null && e.hasMoreElements() ) {\n                    return e;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#getResource(java.lang.String)\n     */\n    public URL getResource(String name) {\n        final ClassLoader[] loaders = manager.getDynamicClassLoaders();\n        for(final ClassLoader cl : loaders) {\n            if ( cl != null ) {\n                final URL u = cl.getResource(name);\n                if ( u != null ) {\n                    return u;\n                }\n            }\n        }\n        return null;\n    }","id":80582,"modified_method":"/**\n     * @see java.lang.ClassLoader#getResource(java.lang.String)\n     */\n    public URL getResource(String name) {\n        if ( !this.manager.isActive() ) {\n            throw new RuntimeException(\"Dynamic class loader has already been deactivated.\");\n        }\n        final URL cachedURL = urlCache.get(name);\n        if ( cachedURL != null ) {\n            return cachedURL;\n        }\n        final ClassLoader[] loaders = manager.getDynamicClassLoaders();\n        for(final ClassLoader cl : loaders) {\n            if ( cl != null ) {\n                final URL u = cl.getResource(name);\n                if ( u != null ) {\n                    urlCache.put(name, u);\n                    return u;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method tests the dynamic class loading through the package admin.\n     * The returned class changes from map to array list.\n     */\n    @Test public void testLoading() throws Exception {\n        final Sequence sequence = this.context.sequence(\"load-sequence\");\n        final BundleContext bundleContext = this.context.mock(BundleContext.class);\n        final PackageAdmin packageAdmin = this.context.mock(PackageAdmin.class);\n        final ExportedPackage ep = this.context.mock(ExportedPackage.class);\n        final Bundle bundle = this.context.mock(Bundle.class);\n        this.context.checking(new Expectations() {{\n            allowing(bundleContext).createFilter(with(any(String.class)));\n            will(returnValue(null));\n            allowing(bundleContext).addServiceListener(with(any(ServiceListener.class)), with(any(String.class)));\n            allowing(bundleContext).removeServiceListener(with(any(ServiceListener.class)));\n            allowing(bundleContext).getServiceReferences(with(any(String.class)), with(any(String.class)));\n            will(returnValue(null));\n            allowing(packageAdmin).getExportedPackage(\"org.apache.sling.test\");\n            will(returnValue(ep));\n            allowing(ep).getExportingBundle();\n            will(returnValue(bundle));\n            one(bundle).loadClass(\"org.apache.sling.test.A\"); inSequence(sequence);\n            will(returnValue(java.util.Map.class));\n            one(bundle).loadClass(\"org.apache.sling.test.A\"); inSequence(sequence);\n            will(returnValue(java.util.Map.class));\n            one(bundle).loadClass(\"org.apache.sling.test.A\"); inSequence(sequence);\n            will(returnValue(java.util.ArrayList.class));\n        }});\n        DynamicClassLoaderManagerImpl manager = new DynamicClassLoaderManagerImpl(bundleContext, packageAdmin, null);\n        final ClassLoader cl = manager.getDynamicClassLoader();\n        final Class c1 = cl.loadClass(\"org.apache.sling.test.A\");\n        Assert.assertEquals(\"java.util.Map\", c1.getName());\n        final Class c2 = cl.loadClass(\"org.apache.sling.test.A\");\n        Assert.assertEquals(\"java.util.Map\", c2.getName());\n        final Class c3 = cl.loadClass(\"org.apache.sling.test.A\");\n        Assert.assertEquals(\"java.util.ArrayList\", c3.getName());\n    }","id":80583,"modified_method":"/**\n     * This method tests the dynamic class loading through the package admin.\n     * The returned class changes from map to array list.\n     */\n    @Test public void testLoading() throws Exception {\n        final Sequence sequence = this.context.sequence(\"load-sequence\");\n        final BundleContext bundleContext = this.context.mock(BundleContext.class);\n        final PackageAdmin packageAdmin = this.context.mock(PackageAdmin.class);\n        final ExportedPackage ep = this.context.mock(ExportedPackage.class);\n        final Bundle bundle = this.context.mock(Bundle.class);\n        this.context.checking(new Expectations() {{\n            allowing(bundleContext).createFilter(with(any(String.class)));\n            will(returnValue(null));\n            allowing(bundleContext).addServiceListener(with(any(ServiceListener.class)), with(any(String.class)));\n            allowing(bundleContext).removeServiceListener(with(any(ServiceListener.class)));\n            allowing(bundleContext).getServiceReferences(with(any(String.class)), with(any(String.class)));\n            will(returnValue(null));\n            allowing(packageAdmin).getExportedPackage(\"org.apache.sling.test\");\n            will(returnValue(ep));\n            allowing(ep).getExportingBundle();\n            will(returnValue(bundle));\n            allowing(bundle).getBundleId();\n            will(returnValue(2L));\n            one(bundle).loadClass(\"org.apache.sling.test.A\"); inSequence(sequence);\n            will(returnValue(java.util.Map.class));\n            one(bundle).loadClass(\"org.apache.sling.test.A\"); inSequence(sequence);\n            will(returnValue(java.util.Map.class));\n            one(bundle).loadClass(\"org.apache.sling.test.A\"); inSequence(sequence);\n            will(returnValue(java.util.ArrayList.class));\n        }});\n        DynamicClassLoaderManagerImpl manager = new DynamicClassLoaderManagerImpl(bundleContext, packageAdmin, null,\n            new DynamicClassLoaderManagerFactory(bundleContext, packageAdmin));\n        final ClassLoader cl = manager.getDynamicClassLoader();\n        final Class c1 = cl.loadClass(\"org.apache.sling.test.A\");\n        Assert.assertEquals(\"java.util.Map\", c1.getName());\n        final Class c2 = cl.loadClass(\"org.apache.sling.test.A\");\n        Assert.assertEquals(\"java.util.Map\", c2.getName());\n        // as we cache the result, we still get the map!\n        final Class c3 = cl.loadClass(\"org.apache.sling.test.A\");\n        Assert.assertEquals(\"java.util.Map\", c3.getName());\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.osgi.framework.ServiceFactory#getService(org.osgi.framework.Bundle, org.osgi.framework.ServiceRegistration)\n     */\n    public Object getService(final Bundle bundle,\n                             final ServiceRegistration registration) {\n        return new DynamicClassLoaderManagerImpl(this.context, this.pckAdmin, new BundleProxyClassLoader(bundle));\n    }","id":80584,"modified_method":"/**\n     * @see org.osgi.framework.ServiceFactory#getService(org.osgi.framework.Bundle, org.osgi.framework.ServiceRegistration)\n     */\n    public Object getService(final Bundle bundle,\n                             final ServiceRegistration registration) {\n        return new DynamicClassLoaderManagerImpl(this.context, this.pckAdmin, new BundleProxyClassLoader(bundle), this);\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create a new service instance\n     * @param ctx The bundle context of the class loader bundle\n     * @param pckAdmin The package admin.\n     * @param parent The parent class loader.\n     */\n    public DynamicClassLoaderManagerImpl(final BundleContext ctx,\n            final PackageAdmin pckAdmin,\n            final ClassLoader parent) {\n        super(ctx, DynamicClassLoaderProvider.class.getName(), null);\n        this.context = ctx;\n        this.pckAdminCL = new PackageAdminClassLoader(pckAdmin, parent);\n        this.cache = new ClassLoader[] {this.pckAdminCL};\n        this.open();\n        this.facade = new ClassLoaderFacade(this);\n    }","id":80585,"modified_method":"/**\n     * Create a new service instance\n     * @param ctx The bundle context of the class loader bundle\n     * @param pckAdmin The package admin.\n     * @param parent The parent class loader.\n     */\n    public DynamicClassLoaderManagerImpl(final BundleContext ctx,\n            final PackageAdmin pckAdmin,\n            final ClassLoader parent,\n            final DynamicClassLoaderManagerFactory factory) {\n        super(ctx, DynamicClassLoaderProvider.class.getName(), null);\n        this.context = ctx;\n        this.pckAdminCL = new PackageAdminClassLoader(pckAdmin, parent, factory);\n        this.cache = new ClassLoader[] {this.pckAdminCL};\n        this.open();\n        this.facade = new ClassLoaderFacade(this);\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"private synchronized void updateCache() {\n        if ( this.updateCache ) {\n            final ServiceReference[] refs = this.getServiceReferences();\n            final ClassLoader[] loaders = new ClassLoader[1 + refs.length];\n            Arrays.sort(refs, ServiceReferenceComparator.INSTANCE);\n            loaders[0] = this.pckAdminCL;\n            int index = 1;\n            for(final ServiceReference ref : refs) {\n                final DynamicClassLoaderProvider provider = (DynamicClassLoaderProvider)this.getService(ref);\n                if ( provider != null ) {\n                    loaders[index] = provider.getClassLoader(this.pckAdminCL);\n                }\n                index++;\n            }\n            // and now use new array\n            this.cache = loaders;\n            this.updateCache = false;\n        }\n    }","id":80586,"modified_method":"private synchronized void updateCache() {\n        if ( this.updateCache ) {\n            final ServiceReference[] refs = this.getServiceReferences();\n            final ClassLoader[] loaders = new ClassLoader[1 + refs.length];\n            Arrays.sort(refs, ServiceReferenceComparator.INSTANCE);\n            int index = 0;\n            for(final ServiceReference ref : refs) {\n                final DynamicClassLoaderProvider provider = (DynamicClassLoaderProvider)this.getService(ref);\n                if ( provider != null ) {\n                    loaders[index] = provider.getClassLoader(this.pckAdminCL);\n                }\n                index++;\n            }\n            loaders[index] = this.pckAdminCL;\n            // and now use new array\n            this.cache = loaders;\n            this.updateCache = false;\n        }\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deactivate this service.\n     */\n    public void deactivate() {\n        this.close();\n    }","id":80587,"modified_method":"/**\n     * Deactivate this service.\n     */\n    public void deactivate() {\n        this.active = false;\n        this.close();\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#getResources(java.lang.String)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Enumeration<URL> getResources(String name) throws IOException {\n        final Bundle bundle = this.findBundleForPackage(getPackageFromResource(name));\n        if ( bundle == null ) {\n            return super.getResources(name);\n        }\n        return bundle.getResources(name);\n    }","id":80588,"modified_method":"/**\n     * @see java.lang.ClassLoader#getResources(java.lang.String)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Enumeration<URL> getResources(String name) throws IOException {\n        Enumeration<URL> e = super.getResources(name);\n        if ( e == null || !e.hasMoreElements() ) {\n            final Bundle bundle = this.findBundleForPackage(getPackageFromResource(name));\n            if ( bundle != null ) {\n                e = bundle.getResources(name);\n                if ( e != null && e.hasMoreElements() ) {\n                    this.factory.addUsedBundle(bundle);\n                }\n            }\n        }\n        return e;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"private Bundle findBundleForPackage(final String pckName) {\n        final ExportedPackage exportedPackage = this.packageAdmin.getExportedPackage(pckName);\n        return (exportedPackage == null ? null : exportedPackage.getExportingBundle());\n    }","id":80589,"modified_method":"/**\n     * Find the bundle for a given package.\n     * @param pckName The package name.\n     * @return The bundle or <code>null<\/code>\n     */\n    private Bundle findBundleForPackage(final String pckName) {\n        final ExportedPackage exportedPackage = this.packageAdmin.getExportedPackage(pckName);\n        final Bundle bundle = (exportedPackage == null ? null : exportedPackage.getExportingBundle());\n        return bundle;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#findResource(java.lang.String)\n     */\n    public URL findResource(String name) {\n        final Bundle bundle = this.findBundleForPackage(getPackageFromResource(name));\n        if ( bundle == null ) {\n            return super.findResource(name);\n        }\n        return bundle.getResource(name);\n    }","id":80590,"modified_method":"/**\n     * @see java.lang.ClassLoader#findResource(java.lang.String)\n     */\n    public URL findResource(String name) {\n        URL url = super.findResource(name);\n        if ( url == null ) {\n            final Bundle bundle = this.findBundleForPackage(getPackageFromResource(name));\n            if ( bundle != null ) {\n                url = bundle.getResource(name);\n                if ( url != null ) {\n                    this.factory.addUsedBundle(bundle);\n                }\n            }\n        }\n        return url;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"public PackageAdminClassLoader(final PackageAdmin pckAdmin, final ClassLoader parent) {\n        super(parent);\n        this.packageAdmin = pckAdmin;\n    }","id":80591,"modified_method":"public PackageAdminClassLoader(final PackageAdmin pckAdmin,\n                                   final ClassLoader parent,\n                                   final DynamicClassLoaderManagerFactory factory) {\n        super(parent);\n        this.packageAdmin = pckAdmin;\n        this.factory = factory;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"private String getPackageFromResource(final String resource) {\n        final int lastSlash = resource.lastIndexOf('/');\n        final String pckName = (lastSlash == -1 ? \"\" : resource.substring(0, lastSlash).replace('/', '.'));\n        return pckName;\n    }","id":80592,"modified_method":"/**\n     * Return the package from a resource.\n     * @param resource The resource path.\n     * @return The package name.\n     */\n    private String getPackageFromResource(final String resource) {\n        final int lastSlash = resource.lastIndexOf('/');\n        final String pckName = (lastSlash == -1 ? \"\" : resource.substring(0, lastSlash).replace('/', '.'));\n        return pckName;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#findClass(java.lang.String)\n     */\n    public Class<?> findClass(String name) throws ClassNotFoundException {\n        final Bundle bundle = this.findBundleForPackage(getPackageFromClassName(name));\n        if ( bundle == null ) {\n            return super.findClass(name);\n        }\n        return bundle.loadClass(name);\n    }","id":80593,"modified_method":"/**\n     * @see java.lang.ClassLoader#findClass(java.lang.String)\n     */\n    public Class<?> findClass(String name) throws ClassNotFoundException {\n        Class<?> clazz = null;\n        try {\n            clazz = super.findClass(name);\n        } catch (ClassNotFoundException cnfe) {\n            final Bundle bundle = this.findBundleForPackage(getPackageFromClassName(name));\n            if ( bundle != null ) {\n                clazz = bundle.loadClass(name);\n                this.factory.addUsedBundle(bundle);\n            }\n        }\n        if ( clazz == null ) {\n            throw new ClassNotFoundException(\"Class not found \" + name);\n        }\n        return clazz;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.ClassLoader#loadClass(java.lang.String, boolean)\n     */\n    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        final Bundle bundle = this.findBundleForPackage(getPackageFromClassName(name));\n        if ( bundle == null ) {\n            return super.loadClass(name, resolve);\n        }\n        return bundle.loadClass(name);\n    }","id":80594,"modified_method":"/**\n     * @see java.lang.ClassLoader#loadClass(java.lang.String, boolean)\n     */\n    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        Class<?> clazz = null;\n        try {\n            clazz = super.loadClass(name, resolve);\n        } catch (ClassNotFoundException cnfe) {\n            final Bundle bundle = this.findBundleForPackage(getPackageFromClassName(name));\n            if ( bundle != null ) {\n                clazz = bundle.loadClass(name);\n                this.factory.addUsedBundle(bundle);\n            }\n        }\n        if ( clazz == null ) {\n            throw new ClassNotFoundException(\"Class not found \" + name);\n        }\n        return clazz;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"private String getPackageFromClassName(final String name) {\n        final int lastDot = name.lastIndexOf('.');\n        final String pckName = (lastDot == -1 ? \"\" : name.substring(0, lastDot));\n        return pckName;\n    }","id":80595,"modified_method":"/**\n     * Return the package from a class.\n     * @param resource The class name.\n     * @return The package name.\n     */\n    private String getPackageFromClassName(final String name) {\n        final int lastDot = name.lastIndexOf('.');\n        final String pckName = (lastDot == -1 ? \"\" : name.substring(0, lastDot));\n        return pckName;\n    }","commit_id":"ab9075c803253830c7da063f5db4d15018cd6788","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Read configuration for the specified classloader.\n     *\n     * @param classLoader\n     * @throws IOException Error\n     */\n    protected void readConfiguration(ClassLoader classLoader)\n        throws IOException {\n\n        InputStream is = null;\n        // Special case for URL classloaders which are used in containers:\n        // only look in the local repositories to avoid redefining loggers 20 times\n        try {\n            if ((classLoader instanceof URLClassLoader)\n                    && (((URLClassLoader) classLoader).findResource(\"logging.properties\") != null)) {\n                is = classLoader.getResourceAsStream(\"logging.properties\");\n            }\n        } catch (AccessControlException ace) {\n            // No permission to configure logging in context\n            // Log and carry on\n            ClassLoaderLogInfo info = classLoaderLoggers.get(ClassLoader.getSystemClassLoader());\n            if (info != null) {\n                Logger log = info.loggers.get(\"\");\n                if (log != null) {\n                    Permission perm = ace.getPermission();\n                    if (perm instanceof FilePermission && perm.getActions().equals(\"read\")) {\n                        log.warning(\"Reading \" + perm.getName() + \" is not permitted. See \\\"per context logging\\\" in the default catalina.policy file.\");\n                    }\n                    else {\n                        log.warning(\"Reading logging.properties is not permitted in some context. See \\\"per context logging\\\" in the default catalina.policy file.\");\n                        log.warning(\"Original error was: \" + ace.getMessage());\n                    }\n                }\n            }\n        }\n        if ((is == null) && (classLoader == ClassLoader.getSystemClassLoader())) {\n            String configFileStr = System.getProperty(\"java.util.logging.config.file\");\n            if (configFileStr != null) {\n                try {\n                    is = new FileInputStream(replace(configFileStr));\n                } catch (IOException e) {\n                    // Ignore\n                }\n            }\n            // Try the default JVM configuration\n            if (is == null) {\n                File defaultFile = new File(new File(System.getProperty(\"java.home\"), \"lib\"),\n                    \"logging.properties\");\n                try {\n                    is = new FileInputStream(defaultFile);\n                } catch (IOException e) {\n                    // Critical problem, do something ...\n                }\n            }\n        }\n\n        Logger localRootLogger = new RootLogger();\n        if (is == null) {\n            // Retrieve the root logger of the parent classloader instead\n            ClassLoader current = classLoader.getParent();\n            ClassLoaderLogInfo info = null;\n            while (current != null && info == null) {\n                info = getClassLoaderInfo(current);\n                current = current.getParent();\n            }\n            if (info != null) {\n                localRootLogger.setParent(info.rootNode.logger);\n            }\n        }\n        ClassLoaderLogInfo info =\n            new ClassLoaderLogInfo(new LogNode(null, localRootLogger));\n        classLoaderLoggers.put(classLoader, info);\n\n        if (is != null) {\n            readConfiguration(is, classLoader);\n        }\n        addLogger(localRootLogger);\n\n    }","id":80596,"modified_method":"/**\n     * Read configuration for the specified classloader.\n     *\n     * @param classLoader\n     * @throws IOException Error\n     */\n    protected void readConfiguration(ClassLoader classLoader)\n        throws IOException {\n\n        InputStream is = null;\n        // Special case for URL classloaders which are used in containers:\n        // only look in the local repositories to avoid redefining loggers 20 times\n        try {\n            if (classLoader instanceof URLClassLoader)\n            {\n                URL logConfig = ((URLClassLoader)classLoader).findResource(\"logging.properties\");\n\n                if(null != logConfig)\n                {\n                    if(Boolean.getBoolean(DEBUG_PROPERTY))\n                        System.err.println(\"Found logging.properties at \" + logConfig);\n\n                    is = classLoader.getResourceAsStream(\"logging.properties\");\n                }\n                else\n                {\n                    if(Boolean.getBoolean(DEBUG_PROPERTY))\n                        System.err.println(\"Found no logging.properties\");\n                }\n            }\n        } catch (AccessControlException ace) {\n            // No permission to configure logging in context\n            // Log and carry on\n            ClassLoaderLogInfo info = classLoaderLoggers.get(ClassLoader.getSystemClassLoader());\n            if (info != null) {\n                Logger log = info.loggers.get(\"\");\n                if (log != null) {\n                    Permission perm = ace.getPermission();\n                    if (perm instanceof FilePermission && perm.getActions().equals(\"read\")) {\n                        log.warning(\"Reading \" + perm.getName() + \" is not permitted. See \\\"per context logging\\\" in the default catalina.policy file.\");\n                    }\n                    else {\n                        log.warning(\"Reading logging.properties is not permitted in some context. See \\\"per context logging\\\" in the default catalina.policy file.\");\n                        log.warning(\"Original error was: \" + ace.getMessage());\n                    }\n                }\n            }\n        }\n        if ((is == null) && (classLoader == ClassLoader.getSystemClassLoader())) {\n            String configFileStr = System.getProperty(\"java.util.logging.config.file\");\n            if (configFileStr != null) {\n                try {\n                    is = new FileInputStream(replace(configFileStr));\n                } catch (IOException e) {\n                    // Ignore\n                }\n            }\n            // Try the default JVM configuration\n            if (is == null) {\n                File defaultFile = new File(new File(System.getProperty(\"java.home\"), \"lib\"),\n                    \"logging.properties\");\n                try {\n                    is = new FileInputStream(defaultFile);\n                } catch (IOException e) {\n                    // Critical problem, do something ...\n                }\n            }\n        }\n\n        Logger localRootLogger = new RootLogger();\n        if (is == null) {\n            // Retrieve the root logger of the parent classloader instead\n            ClassLoader current = classLoader.getParent();\n            ClassLoaderLogInfo info = null;\n            while (current != null && info == null) {\n                info = getClassLoaderInfo(current);\n                current = current.getParent();\n            }\n            if (info != null) {\n                localRootLogger.setParent(info.rootNode.logger);\n            }\n        }\n        ClassLoaderLogInfo info =\n            new ClassLoaderLogInfo(new LogNode(null, localRootLogger));\n        classLoaderLoggers.put(classLoader, info);\n\n        if (is != null) {\n            readConfiguration(is, classLoader);\n        }\n        addLogger(localRootLogger);\n\n    }","commit_id":"b7318f9f089b1d1409acedfe7d7cbd905084d803","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n  public Object getComponentInstance(final PicoContainer container)\n    throws PicoInitializationException,\n           PicoIntrospectionException,\n           AssignabilityRegistrationException,\n           NotConcreteRegistrationException,\n           ProcessCanceledException {\n    if (myComponentInstance == null) {\n      if (Element.class.equals(getComponentImplementation())) {\n        myComponentInstance = myExtensionElement;\n      }\n      else {\n        Object componentInstance = getDelegate().getComponentInstance(container);\n\n        if (myDeserializeInstance) {\n          try {\n            XmlSerializer.deserializeInto(componentInstance, myExtensionElement);\n          }\n          catch (Exception e) {\n            throw new PicoInitializationException(e);\n          }\n        }\n\n        ExtensionInitializer initializer = (ExtensionInitializer)container.getComponentInstance(ExtensionInitializer.class);\n        if (initializer != null) {\n          initializer.initExtension(componentInstance);\n        }\n        myComponentInstance = componentInstance;\n      }\n      if (myComponentInstance instanceof PluginAware) {\n        PluginAware pluginAware = (PluginAware) myComponentInstance;\n        pluginAware.setPluginDescriptor(myPluginDescriptor);\n      }\n    }\n\n    return myComponentInstance;\n  }","id":80597,"modified_method":"@Override\n  public Object getComponentInstance(final PicoContainer container) throws PicoException, ProcessCanceledException {\n    if (myComponentInstance == null) {\n      try {\n        if (Element.class.equals(getComponentImplementation())) {\n          myComponentInstance = myExtensionElement;\n        }\n        else {\n          Object componentInstance = getDelegate().getComponentInstance(container);\n\n          if (myDeserializeInstance) {\n            try {\n              XmlSerializer.deserializeInto(componentInstance, myExtensionElement);\n            }\n            catch (Exception e) {\n              throw new PicoInitializationException(e);\n            }\n          }\n\n          ExtensionInitializer initializer = (ExtensionInitializer)container.getComponentInstance(ExtensionInitializer.class);\n          if (initializer != null) {\n            initializer.initExtension(componentInstance);\n          }\n\n          myComponentInstance = componentInstance;\n        }\n      }\n      catch (ProcessCanceledException e) {\n        throw e;\n      }\n      catch (Throwable t) {\n        PluginId pluginId = myPluginDescriptor != null ? myPluginDescriptor.getPluginId() : null;\n        throw new PicoPluginExtensionInitializationException(t.getMessage(), t, pluginId);\n      }\n\n      if (myComponentInstance instanceof PluginAware) {\n        PluginAware pluginAware = (PluginAware)myComponentInstance;\n        pluginAware.setPluginDescriptor(myPluginDescriptor);\n      }\n    }\n\n    return myComponentInstance;\n  }","commit_id":"aacf1e4c19e25f3e0d501e48635713cafc7f3390","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized ComponentAdapter getDelegate() {\n    if (myDelegate == null) {\n      myDelegate = new CachingComponentAdapter(new ConstructorInjectionComponentAdapter(getComponentKey(), loadClass(myImplementationClassName), null, true));\n    }\n\n    return myDelegate;\n  }","id":80598,"modified_method":"private synchronized ComponentAdapter getDelegate() {\n    if (myDelegate == null) {\n      Class impl = loadClass(myImplementationClassName);\n      myDelegate = new CachingComponentAdapter(new ConstructorInjectionComponentAdapter(getComponentKey(), impl, null, true));\n    }\n\n    return myDelegate;\n  }","commit_id":"aacf1e4c19e25f3e0d501e48635713cafc7f3390","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void processException(Throwable t) {\n    StartupAbortedException se = null;\n\n    if (t instanceof StartupAbortedException) {\n      se = (StartupAbortedException)t;\n    }\n    else if (!IdeaApplication.isLoaded()) {\n      se = new StartupAbortedException(t);\n    }\n\n    if (se != null) {\n      if (se.logError()) {\n        try {\n          if (Logger.isInitialized() && !(t instanceof ProcessCanceledException)) {\n            getLogger().error(t);\n          }\n        }\n        catch (Throwable ignore) { }\n\n        Main.showMessage(\"Start Failed\", t);\n      }\n\n      System.exit(se.exitCode());\n    }\n\n    if (!(t instanceof ProcessCanceledException)) {\n      getLogger().error(t);\n    }\n  }","id":80599,"modified_method":"public static void processException(Throwable t) {\n    StartupAbortedException se = null;\n\n    if (t instanceof StartupAbortedException) {\n      se = (StartupAbortedException)t;\n    }\n    else if (t.getCause() instanceof StartupAbortedException) {\n      se = (StartupAbortedException)t.getCause();\n    }\n    else if (!IdeaApplication.isLoaded()) {\n      se = new StartupAbortedException(t);\n    }\n\n    if (se != null) {\n      if (se.logError()) {\n        try {\n          if (Logger.isInitialized() && !(t instanceof ProcessCanceledException)) {\n            getLogger().error(t);\n          }\n        }\n        catch (Throwable ignore) { }\n\n        Main.showMessage(\"Start Failed\", t);\n      }\n\n      System.exit(se.exitCode());\n    }\n\n    if (!(t instanceof ProcessCanceledException)) {\n      getLogger().error(t);\n    }\n  }","commit_id":"aacf1e4c19e25f3e0d501e48635713cafc7f3390","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void handleComponentError(Throwable t, String componentClassName, ComponentConfig config) {\n    if (t instanceof StartupAbortedException) {\n      throw (StartupAbortedException)t;\n    }\n\n    PluginId pluginId = config != null ? config.getPluginId() : getPluginByClassName(componentClassName);\n\n    if (pluginId != null && !CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      getLogger().warn(t);\n\n      disablePlugin(pluginId.getIdString());\n\n      String message =\n        \"Plugin '\" + pluginId.getIdString() + \"' failed to initialize and will be disabled\\n\" +\n        \"(reason: \" + t.getMessage() + \")\\n\\n\" +\n        ApplicationNamesInfo.getInstance().getFullProductName() + \" will be restarted.\";\n      Main.showMessage(\"Plugin Error\", message, false);\n\n      throw new StartupAbortedException(t).exitCode(Main.PLUGIN_ERROR).logError(false);\n    }\n    else {\n      throw new StartupAbortedException(\"Fatal error initializing '\" + componentClassName + \"'\", t);\n    }\n  }","id":80600,"modified_method":"public static void handleComponentError(Throwable t, String componentClassName, ComponentConfig config) {\n    if (t instanceof StartupAbortedException) {\n      throw (StartupAbortedException)t;\n    }\n\n    PluginId pluginId = null;\n    if (config != null) {\n      pluginId = config.getPluginId();\n    }\n    if (pluginId == null || CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      pluginId = getPluginByClassName(componentClassName);\n    }\n    if (pluginId == null || CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      if (t instanceof PicoPluginExtensionInitializationException) {\n        pluginId = ((PicoPluginExtensionInitializationException)t).getPluginId();\n      }\n    }\n\n    if (pluginId != null && !CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      getLogger().warn(t);\n\n      disablePlugin(pluginId.getIdString());\n\n      String message =\n        \"Plugin '\" + pluginId.getIdString() + \"' failed to initialize and will be disabled\\n\" +\n        \"(reason: \" + t.getMessage() + \")\\n\\n\" +\n        \"Please restart \" + ApplicationNamesInfo.getInstance().getFullProductName() + \".\";\n      Main.showMessage(\"Plugin Error\", message, false);\n\n      throw new StartupAbortedException(t).exitCode(Main.PLUGIN_ERROR).logError(false);\n    }\n    else {\n      throw new StartupAbortedException(\"Fatal error initializing '\" + componentClassName + \"'\", t);\n    }\n  }","commit_id":"aacf1e4c19e25f3e0d501e48635713cafc7f3390","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getId(@NotNull IdeaPluginDescriptor plugin) {\n      return plugin.isBundled() ? PluginManagerCore.CORE_PLUGIN_ID : plugin.getPluginId().getIdString();\n    }","id":80601,"modified_method":"@NotNull\n    private static String getId(@NotNull IdeaPluginDescriptor plugin) {\n      PluginId pluginId = plugin.getPluginId();\n      return pluginId != null ? pluginId.getIdString() : PluginManagerCore.CORE_PLUGIN_ID;\n    }","commit_id":"e3bfaeb257fcf9cde859a50f075ddc7152926d27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkJetBrainsPlugin(IdeaPlugin ideaPlugin, DomElementAnnotationHolder holder) {\n    final Module module = ideaPlugin.getModule();\n    if (module == null) return;\n    if (!PsiUtil.isIdeaProject(module.getProject())) return;\n\n    if (ideaPlugin.getPluginId() == null) return;\n\n    final Vendor vendor = ContainerUtil.getFirstItem(ideaPlugin.getVendors());\n    if (vendor == null) {\n      holder.createProblem(DomUtil.getFileElement(ideaPlugin), \"Plugin developed as a part of IntelliJ IDEA project should specify 'JetBrains' as its vendor\",\n                           new SpecifyJetBrainsAsVendorQuickFix());\n    }\n    else if (!PluginManagerMain.isDevelopedByJetBrains(vendor.getValue())) {\n      holder.createProblem(vendor, \"Plugin developed as a part of IntelliJ IDEA project should include 'JetBrains' as one of its vendors\");\n    }\n  }","id":80602,"modified_method":"private static void checkJetBrainsPlugin(IdeaPlugin ideaPlugin, DomElementAnnotationHolder holder) {\n    final Module module = ideaPlugin.getModule();\n    if (module == null) return;\n    if (!PsiUtil.isIdeaProject(module.getProject())) return;\n\n    String pluginId = ideaPlugin.getPluginId();\n    if (pluginId == null || pluginId.equals(PluginManagerCore.CORE_PLUGIN_ID)) return;\n\n    final Vendor vendor = ContainerUtil.getFirstItem(ideaPlugin.getVendors());\n    if (vendor == null) {\n      holder.createProblem(DomUtil.getFileElement(ideaPlugin), \"Plugin developed as a part of IntelliJ IDEA project should specify 'JetBrains' as its vendor\",\n                           new SpecifyJetBrainsAsVendorQuickFix());\n    }\n    else if (!PluginManagerMain.isDevelopedByJetBrains(vendor.getValue())) {\n      holder.createProblem(vendor, \"Plugin developed as a part of IntelliJ IDEA project should include 'JetBrains' as one of its vendors\");\n    }\n  }","commit_id":"56eadd220402f2b18c5c3fe927027d6c85ce618c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tprotected boolean hasPermissionImplicitlyGranted(\n\t\t\tPermissionChecker permissionChecker, Group group, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tif (group.isUser()) {\n\t\t\treturn super.hasPermissionImplicitlyGranted(\n\t\t\t\tpermissionChecker, group, portlet);\n\t\t}\n\n\t\treturn GroupPermissionUtil.contains(\n\t\t\tpermissionChecker, group, ActionKeys.MANAGE_LAYOUTS);\n\t}","id":80603,"modified_method":"@Override\n\tprotected boolean hasPermissionImplicitlyGranted(\n\t\t\tPermissionChecker permissionChecker, Group group, Portlet portlet)\n\t\tthrows Exception {\n\n\t\treturn GroupPermissionUtil.contains(\n\t\t\tpermissionChecker, group, ActionKeys.MANAGE_LAYOUTS);\n\t}","commit_id":"45d218e32d7221aa2e3bf6d45806fdece50866db","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected boolean hasAccessPermissionDenied(\n\t\t\tPermissionChecker permissionChecker, Group group, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tif (group.isUser()) {\n\t\t\treturn hasUserLayoutsAccesPermissionDenied(permissionChecker);\n\t\t}\n\n\t\treturn group.isCompany();\n\t}","id":80604,"modified_method":"@Override\n\tprotected boolean hasAccessPermissionDenied(\n\t\t\tPermissionChecker permissionChecker, Group group, Portlet portlet)\n\t\tthrows Exception {\n\n\t\tif (group.isCompany()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"45d218e32d7221aa2e3bf6d45806fdece50866db","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isVisible(User user, Group group) {\n\t\tif ((group == null) || !group.isCompany()) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":80605,"modified_method":"@Override\n\tpublic boolean isVisible(User user, Group group) {\n\t\tif ((group != null) && group.isCompany()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (group != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tThemeDisplay themeDisplay = serviceContext.getThemeDisplay();\n\n\t\tHttpServletRequest request = themeDisplay.getRequest();\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t(LayoutSetPrototype)request.getAttribute(\"site.layoutSetPrototype\");\n\n\t\tif (layoutSetPrototype != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"b700a0237b0d81c1573be5941d6971872b130ff0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isVisible(\n\t\t\tPortlet portlet, String category, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString controlPanelCategory = themeDisplay.getControlPanelCategory();\n\n\t\tif (controlPanelCategory.equals(PortletCategoryKeys.CONTENT)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tGroup scopeGroup = themeDisplay.getScopeGroup();\n\t\t\n\t\tif (scopeGroup.isUser() ||\n\t\t\t\t!(GroupPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), \n\t\t\t\t\tscopeGroup.getGroupId(), ActionKeys.UPDATE))) {\n\t\t\t\n\t\t}\n\n\t\tboolean visible = super.isVisible(portlet, category, themeDisplay);\n\n\t\tif (!visible) {\n\t\t\tvisible = GroupPermissionUtil.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\tthemeDisplay.getScopeGroupId(), ActionKeys.MANAGE_LAYOUTS);\n\t\t}\n\n\t\tif (visible) {\n\t\t\tif (scopeGroup.isCompany() ) {\n\t\t\t\tvisible = false;\n\t\t\t}\n\t\t}\n\n\t\treturn visible;\n\t}","id":80606,"modified_method":"@Override\n\tpublic boolean isVisible(\n\t\t\tPortlet portlet, String category, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString controlPanelCategory = themeDisplay.getControlPanelCategory();\n\n\t\tif (controlPanelCategory.equals(PortletCategoryKeys.CONTENT)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tGroup scopeGroup = themeDisplay.getScopeGroup();\n\t\t\n\t\tif (scopeGroup.isUser() || scopeGroup.isCompany() ||\n\t\t\t!(GroupPermissionUtil.contains(\n\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\tscopeGroup.getGroupId(), ActionKeys.UPDATE))) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn super.isVisible(portlet, category, themeDisplay);\n\t}","commit_id":"32188b4b7a75ebc44a2428d0895d265f108037c0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Map extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                DocletTag paramTag = field.getTagByName( PARAMETER );\n\n                if ( paramTag != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }","id":80607,"modified_method":"private Map extractFieldParameterTags( JavaClass javaClass )\n    {\n        Map rawParams;\n\n        // we have to add the parent fields first, so that they will be overwritten by the local fields if\n        // that actually happens...\n        JavaClass superClass = javaClass.getSuperJavaClass();\n\n        if ( superClass != null )\n        {\n            rawParams = extractFieldParameterTags( superClass );\n        }\n        else\n        {\n            rawParams = new TreeMap();\n        }\n\n        JavaField[] classFields = javaClass.getFields();\n\n        if ( classFields != null )\n        {\n            for ( int i = 0; i < classFields.length; i++ )\n            {\n                JavaField field = classFields[i];\n\n                if ( field.getTagByName( PARAMETER ) != null || field.getTagByName( COMPONENT ) != null )\n                {\n                    rawParams.put( field.getName(), field );\n                }\n            }\n        }\n        return rawParams;\n    }","commit_id":"bc77a5ba07e5f26c0c841bf1bd1f370f5f24d956","url":"https://github.com/apache/maven"},{"original_method":"private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass ) throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Entry) it.next();\n            String paramName = (String) entry.getKey();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            DocletTag parameter = field.getTagByName( PARAMETER );\n\n            Parameter pd = new Parameter();\n\n            pd.setName( paramName );\n\n            pd.setType( field.getType().getValue() );\n\n            pd.setDescription( field.getComment() );\n\n            pd.setRequired( field.getTagByName( REQUIRED ) != null );\n\n            pd.setEditable( field.getTagByName( READONLY ) == null );\n\n            DocletTag deprecationTag = field.getTagByName( DEPRECATED );\n            if ( deprecationTag != null )\n            {\n                pd.setDeprecated( deprecationTag.getValue() );\n            }\n\n            String alias = parameter.getNamedParameter( \"alias\" );\n\n            if ( !StringUtils.isEmpty( alias ) )\n            {\n                pd.setAlias( alias );\n            }\n\n            pd.setExpression( parameter.getNamedParameter( PARAMETER_EXPRESSION ) );\n\n            pd.setDefaultValue( parameter.getNamedParameter( PARAMETER_DEFAULT_VALUE ) );\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }","id":80608,"modified_method":"private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass )\n        throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = extractFieldParameterTags( javaClass );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n            String paramName = (String) entry.getKey();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            Parameter pd = new Parameter();\n\n            pd.setName( paramName );\n\n            pd.setType( field.getType().getValue() );\n\n            pd.setDescription( field.getComment() );\n\n            DocletTag componentTag = field.getTagByName( COMPONENT );\n            if ( componentTag != null )\n            {\n                String role = componentTag.getNamedParameter( \"role\" );\n                if ( role == null )\n                {\n                    role = field.getType().toString();\n                }\n\n                String roleHint = componentTag.getNamedParameter( \"roleHint\" );\n                pd.setRequirement( new Requirement( role, roleHint ) );\n            }\n            else\n            {\n                DocletTag parameter = field.getTagByName( PARAMETER );\n\n                pd.setRequired( field.getTagByName( REQUIRED ) != null );\n\n                pd.setEditable( field.getTagByName( READONLY ) == null );\n\n                DocletTag deprecationTag = field.getTagByName( DEPRECATED );\n                if ( deprecationTag != null )\n                {\n                    pd.setDeprecated( deprecationTag.getValue() );\n                }\n\n                String alias = parameter.getNamedParameter( \"alias\" );\n\n                if ( !StringUtils.isEmpty( alias ) )\n                {\n                    pd.setAlias( alias );\n                }\n\n                pd.setExpression( parameter.getNamedParameter( PARAMETER_EXPRESSION ) );\n\n                pd.setDefaultValue( parameter.getNamedParameter( PARAMETER_DEFAULT_VALUE ) );\n            }\n            mojoDescriptor.addParameter( pd );\n        }\n    }","commit_id":"bc77a5ba07e5f26c0c841bf1bd1f370f5f24d956","url":"https://github.com/apache/maven"},{"original_method":"public MojoDefinitionTagLibrary()\n    {\n        registerTag( \"aggregator\", AggregatorTag.class );\n        registerTag( \"default\", ParamDefaultTag.class );\n        registerTag( \"description\", DescriptionTag.class );\n        registerTag( \"execute\", ExecuteTag.class );\n        registerTag( \"executionStrategy\", ExecutionStrategyTag.class );\n        registerTag( \"expression\", ParamExpressionTag.class );\n        registerTag( \"goal\", GoalTag.class );\n        registerTag( \"inheritByDefault\", InheritByDefaultTag.class );\n        registerTag( \"instantiationStrategy\", InstantiationStrategyTag.class );\n        registerTag( \"lifecyclePhase\", LifecyclePhaseTag.class );\n        registerTag( \"metadata\", MetadataTag.class );\n        registerTag( \"mojo\", MojoTag.class );\n        registerTag( \"name\", ParamNameTag.class );\n        registerTag( \"parameters\", ParametersTag.class );\n        registerTag( \"parameter\", ParameterTag.class );\n        registerTag( \"phase\", LifecyclePhaseTag.class );\n        registerTag( \"required\", ParamRequiredTag.class );\n        registerTag( \"requiresDependencyResolution\", RequiresDependencyResolutionTag.class );\n        registerTag( \"requiresProject\", RequiresProjectTag.class );\n        registerTag( \"requiresOnline\", RequiresOnlineTag.class );\n        registerTag( \"type\", ParamTypeTag.class );\n    }","id":80609,"modified_method":"public MojoDefinitionTagLibrary()\n    {\n        registerTag( \"aggregator\", AggregatorTag.class );\n        registerTag( \"default\", ParamDefaultTag.class );\n        registerTag( \"description\", DescriptionTag.class );\n        registerTag( \"execute\", ExecuteTag.class );\n        registerTag( \"executionStrategy\", ExecutionStrategyTag.class );\n        registerTag( \"expression\", ParamExpressionTag.class );\n        registerTag( \"goal\", GoalTag.class );\n        registerTag( \"inheritByDefault\", InheritByDefaultTag.class );\n        registerTag( \"instantiationStrategy\", InstantiationStrategyTag.class );\n        registerTag( \"lifecyclePhase\", LifecyclePhaseTag.class );\n        registerTag( \"metadata\", MetadataTag.class );\n        registerTag( \"mojo\", MojoTag.class );\n        registerTag( \"name\", ParamNameTag.class );\n        registerTag( \"parameters\", ParametersTag.class );\n        registerTag( \"parameter\", ParameterTag.class );\n        registerTag( \"phase\", LifecyclePhaseTag.class );\n        registerTag( \"required\", ParamRequiredTag.class );\n        registerTag( \"requiresDependencyResolution\", RequiresDependencyResolutionTag.class );\n        registerTag( \"requiresProject\", RequiresProjectTag.class );\n        registerTag( \"requiresOnline\", RequiresOnlineTag.class );\n        registerTag( \"requirement\", RequirementTag.class );\n        registerTag( \"role\", RequirementRoleTag.class );\n        registerTag( \"roleHint\", RequirementRoleHintTag.class );\n        registerTag( \"type\", ParamTypeTag.class );\n    }","commit_id":"bc77a5ba07e5f26c0c841bf1bd1f370f5f24d956","url":"https://github.com/apache/maven"},{"original_method":"private Parameter buildParameter()\n    {\n        Parameter param = new Parameter();\n\n        param.setName( name );\n        param.setDescription( description );\n        param.setExpression( expression );\n        param.setRequired( required );\n        param.setType( type );\n        param.setDeprecated( deprecated );\n        param.setDefaultValue( defaultVal );\n\n        return param;\n    }","id":80610,"modified_method":"private Parameter buildParameter()\n    {\n        Parameter param = new Parameter();\n\n        param.setName( name );\n        param.setDescription( description );\n        param.setExpression( expression );\n        param.setRequired( required );\n        param.setType( type );\n        param.setDeprecated( deprecated );\n        param.setDefaultValue( defaultVal );\n        param.setRequirement( requirement );\n\n        return param;\n    }","commit_id":"bc77a5ba07e5f26c0c841bf1bd1f370f5f24d956","url":"https://github.com/apache/maven"},{"original_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n\n        w.writeText( mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresDirectInvocation\", \"\" + mojoDescriptor.isDirectInvocationOnly() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"aggregator\", \"\" + mojoDescriptor.isAggregator() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"inheritedByDefault\", \"\" + mojoDescriptor.isInheritedByDefault() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( mojoDescriptor.getExecuteLifecycle() != null )\n        {\n            element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n\n            w.writeText( mojoDescriptor.getComponentComposer() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n\n        Set configuration = new HashSet();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                Parameter parameter = (Parameter) parameters.get( j );\n\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    requirements.add( parameter );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        element( w, \"deprecated\", parameter.getDeprecated() );\n                    }\n\n                    element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    element( w, \"description\", parameter.getDescription() );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ||\n                        StringUtils.isNotEmpty( parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( parameter.getExpression() != null )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                // remove \"component.\" plus expression delimiters\n                String expression = requirement.getExpression();\n                String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                element( w, \"role\", role );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","id":80611,"modified_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n\n        w.writeText( mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresDirectInvocation\", \"\" + mojoDescriptor.isDirectInvocationOnly() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"aggregator\", \"\" + mojoDescriptor.isAggregator() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"inheritedByDefault\", \"\" + mojoDescriptor.isInheritedByDefault() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        if ( mojoDescriptor.getExecuteLifecycle() != null )\n        {\n            element( w, \"executeLifecycle\", mojoDescriptor.getExecuteLifecycle() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n\n            w.writeText( mojoDescriptor.getComponentComposer() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Map requirements = new HashMap();\n\n        Set configuration = new HashSet();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                Parameter parameter = (Parameter) parameters.get( j );\n\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    // remove \"component.\" plus expression delimiters\n                    String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                    // TODO: remove deprecated expression\n                    requirements.put( parameter.getName(), new Requirement( role ) );\n                }\n                else if ( parameter.getRequirement() != null )\n                {\n                    requirements.put( parameter.getName(), parameter.getRequirement() );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        element( w, \"deprecated\", parameter.getDeprecated() );\n                    }\n\n                    element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    element( w, \"description\", parameter.getDescription() );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ||\n                        StringUtils.isNotEmpty( parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( parameter.getExpression() != null )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.keySet().iterator(); i.hasNext(); )\n            {\n                String key = (String) i.next();\n                Requirement requirement = (Requirement) requirements.get( key );\n\n                w.startElement( \"requirement\" );\n\n                element( w, \"role\", requirement.getRole() );\n\n                if ( requirement.getRoleHint() != null )\n                {\n                    element( w, \"role-hint\", requirement.getRoleHint() );\n                }\n\n                element( w, \"field-name\", key );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","commit_id":"bc77a5ba07e5f26c0c841bf1bd1f370f5f24d956","url":"https://github.com/apache/maven"},{"original_method":"private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"table\" );\n\n        w.startElement( \"tr\" );\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Parameter\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Type\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Expression\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Default Value\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Description\" );\n\n        w.endElement(); // th\n\n        w.endElement(); // tr\n\n        List parameters = mojoDescriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            w.startElement( \"tr\" );\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            String paramName = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( paramName ) )\n            {\n                paramName = parameter.getName();\n            }\n\n            w.startElement( \"code\" );\n\n            w.writeText( paramName );\n\n            w.endElement(); // code\n\n            if ( !parameter.isRequired() )\n            {\n                w.writeMarkup( \" <i>(Optional)<\/i>\" );\n            }\n\n            if ( parameter.getExpression() != null && parameter.getExpression().startsWith( \"${component.\" ) )\n            {\n                w.writeMarkup( \" <i>(Discovered)<\/i>\" );\n            }\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            w.addAttribute( \"title\", parameter.getType() );\n\n            int index = parameter.getType().lastIndexOf( \".\" );\n            if ( index >= 0 )\n            {\n                w.writeText( parameter.getType().substring( index + 1 ) );\n            }\n            else\n            {\n                w.writeText( parameter.getType() );\n            }\n\n            w.endElement(); // code\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) &&\n                !parameter.getExpression().startsWith( \"${component.\" ) )\n            {\n                w.writeText( parameter.getExpression() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement(); // code\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeText( parameter.getDefaultValue() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement(); // code\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                w.writeMarkup( parameter.getDescription() );\n            }\n            else\n            {\n                w.writeText( \"No description.\" );\n            }\n\n            String deprecationWarning = parameter.getDeprecated();\n            if ( deprecationWarning != null )\n            {\n                w.writeMarkup( \"<br/><b>Deprecated:<\/b> \" );\n                w.writeMarkup( deprecationWarning );\n                if ( deprecationWarning.length() == 0 )\n                {\n                    w.writeText( \"No reason given.\" );\n                }\n            }\n\n            w.endElement(); // td\n\n            w.endElement(); // tr\n        }\n\n        w.endElement(); // table\n    }","id":80612,"modified_method":"private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"table\" );\n\n        w.startElement( \"tr\" );\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Parameter\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Type\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Expression\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Default Value\" );\n\n        w.endElement(); // th\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Description\" );\n\n        w.endElement(); // th\n\n        w.endElement(); // tr\n\n        List parameters = mojoDescriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            w.startElement( \"tr\" );\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            String paramName = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( paramName ) )\n            {\n                paramName = parameter.getName();\n            }\n\n            w.startElement( \"code\" );\n\n            w.writeText( paramName );\n\n            w.endElement(); // code\n\n            if ( !parameter.isRequired() )\n            {\n                w.writeMarkup( \" <i>(Optional)<\/i>\" );\n            }\n\n            if ( parameter.getExpression() != null && parameter.getExpression().startsWith( \"${component.\" ) )\n            {\n                w.writeMarkup( \" <i>(Discovered)<\/i>\" );\n            }\n            else if ( parameter.getRequirement() != null )\n            {\n                w.writeMarkup( \" <i>(Discovered)<\/i>\" );\n            }\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            w.addAttribute( \"title\", parameter.getType() );\n\n            int index = parameter.getType().lastIndexOf( \".\" );\n            if ( index >= 0 )\n            {\n                w.writeText( parameter.getType().substring( index + 1 ) );\n            }\n            else\n            {\n                w.writeText( parameter.getType() );\n            }\n\n            w.endElement(); // code\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) &&\n                !parameter.getExpression().startsWith( \"${component.\" ) )\n            {\n                w.writeText( parameter.getExpression() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement(); // code\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) )\n            {\n                w.writeText( parameter.getDefaultValue() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement(); // code\n\n            w.endElement(); // td\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                w.writeMarkup( parameter.getDescription() );\n            }\n            else\n            {\n                w.writeText( \"No description.\" );\n            }\n\n            String deprecationWarning = parameter.getDeprecated();\n            if ( deprecationWarning != null )\n            {\n                w.writeMarkup( \"<br/><b>Deprecated:<\/b> \" );\n                w.writeMarkup( deprecationWarning );\n                if ( deprecationWarning.length() == 0 )\n                {\n                    w.writeText( \"No reason given.\" );\n                }\n            }\n\n            w.endElement(); // td\n\n            w.endElement(); // tr\n        }\n\n        w.endElement(); // table\n    }","commit_id":"bc77a5ba07e5f26c0c841bf1bd1f370f5f24d956","url":"https://github.com/apache/maven"},{"original_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_PROJECT_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Project project) throws URISyntaxException{\n\t\t\n\t\tHProject hProject = projectDAO.getBySlug(project.getId());\n\t\tif(hProject == null){\n\t\t\treturn Response.status(Status.BAD_REQUEST).build();\n\t\t}\n\t\t//hProject = new org.fedorahosted.flies.core.model.HIterationProject();\n\t\thProject.setSlug(project.getId());\n\t\thProject.setName(project.getName());\n\t\thProject.setDescription(project.getDescription());\n\t\tHAccount hAccount = accountDAO.getByUsername(Identity.instance().getCredentials().getUsername());\n\t\tif(hAccount != null && hAccount.getPerson() != null) {\n\t\t\thProject.getMaintainers().add(hAccount.getPerson());\n\t\t}\n\t\t\n\t\ttry{\n\t\t\tsession.flush();\n\t\t\treturn Response.ok().build();\n\t\t}\n        catch(InvalidStateException e){\n        \treturn Response.status(Status.BAD_REQUEST).build();\n        }\n        catch(HibernateException e){\n\t\t\treturn Response.status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t}\n\t}","id":80613,"modified_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_PROJECT_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Project project) throws URISyntaxException{\n\t\t\n\t\tHProject hProject = projectDAO.getBySlug(project.getId());\n\t\tif(hProject == null){\n\t\t\thProject = new org.fedorahosted.flies.core.model.HIterationProject();\n\t\t\thProject.setSlug(project.getId());\n\t\t\thProject.setName(project.getName());\n\t\t\thProject.setDescription(project.getDescription());\n\t\t}\n\t\telse{\n\t\t\thProject.setSlug(project.getId());\n\t\t\thProject.setName(project.getName());\n\t\t\thProject.setDescription(project.getDescription());\n\t\t}\n\t\t\n\t\ttry{\n\t\t\tif(!session.contains(hProject)) {\n\t\t\t\tsession.save(hProject);\n\t\t\t\tsession.flush();\n\t\t\t\tHAccount hAccount = accountDAO.getByUsername(Identity.instance().getCredentials().getUsername());\n\t\t\t\tif(hAccount != null && hAccount.getPerson() != null) {\n\t\t\t\t\thProject.getMaintainers().add(hAccount.getPerson());\n\t\t\t\t}\n\t\t\t\tsession.flush();\n\t\t\t\treturn Response.created( new URI(\"/projects/p/\"+hProject.getSlug()) ).build();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsession.flush();\n\t\t\t\treturn Response.ok().build();\n\t\t\t}\n\t\t}\n        catch(InvalidStateException e){\n        \treturn Response.status(Status.BAD_REQUEST).build();\n        }\n        catch(HibernateException e){\n\t\t\treturn Response.status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t}\n        \n\t}","commit_id":"664adb0d47b11885b94cf38fe666a20e4ec0bbb5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeClass\n\tpublic void prepareSharedEnvironment() throws Exception {\n\t\tsharedEnvironment = new ResourceRequestEnvironment(this) {\n\t\t\t@Override\n\t\t\tpublic Map<String, Object> getDefaultHeaders() {\n\t\t\t\treturn new HashMap<String, Object>() {\n\t\t\t\t\t{\n\t\t\t\t\t\tput(\"X-Auth-Token\", \"12345678901234567890123456789012\");\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}","id":80614,"modified_method":"@BeforeMethod(firstTimeOnly=true)\n\tpublic void prepareSharedEnvironment() throws Exception {\n\t\tsharedEnvironment = new ResourceRequestEnvironment(this) {\n\t\t\t@Override\n\t\t\tpublic Map<String, Object> getDefaultHeaders() {\n\t\t\t\treturn new HashMap<String, Object>() {\n\t\t\t\t\t{\n\t\t\t\t\t\tput(\"X-Auth-User\", \"admin\");\n\t\t\t\t\t\tput(\"X-Auth-Token\", \"12345678901234567890123456789012\");\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}","commit_id":"664adb0d47b11885b94cf38fe666a20e4ec0bbb5","url":"https://github.com/zanata/zanata-server"},{"original_method":"private ExtensionSummary createExtensionSummaryFromQueryResult(Object[] entry)\n    {\n        ExtensionSummary extension;\n        ExtensionVersionSummary extensionVersion;\n        if (entry.length == 3) {\n            extension = this.objectFactory.createExtensionSummary();\n            extensionVersion = null;\n        } else {\n            extension = extensionVersion = this.objectFactory.createExtensionVersionSummary();\n            extensionVersion.setVersion((String) entry[3]);\n        }\n\n        extension.setId((String) entry[0]);\n        extension.setType((String) entry[1]);\n        extension.setName((String) entry[2]);\n\n        return extension;\n    }","id":80615,"modified_method":"private ExtensionSummary createExtensionSummaryFromQueryResult(Object[] entry)\n    {\n        ExtensionSummary extension;\n        ExtensionVersionSummary extensionVersion;\n        if (entry.length == EPROPERTIES_SUMMARY.length) {\n            // It's a extension summary without version\n            extension = this.objectFactory.createExtensionSummary();\n            extensionVersion = null;\n        } else {\n            extension = extensionVersion = this.objectFactory.createExtensionVersionSummary();\n            extensionVersion.setVersion((String) entry[EPROPERTIES_SUMMARY.length]);\n        }\n\n        extension.setId(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ID));\n        extension.setType(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_TYPE));\n        extension.setName(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_NAME));\n\n        return extension;\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Query createExtensionsCountQuery(String from, String where) throws QueryException\n    {\n        // select\n\n        String select = \"count(extension.id)\";\n\n        return createExtensionsQuery(select, from, where, 0, -1, false);\n    }","id":80616,"modified_method":"protected Query createExtensionsCountQuery(String from, String where) throws QueryException\n    {\n        // select\n\n        String select = \"count(extension.\" + XWikiRepositoryModel.PROP_EXTENSION_ID + \")\";\n\n        return createExtensionsQuery(select, from, where, 0, -1, false);\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Query createExtensionsQuery(String from, String where, int offset, int number) throws QueryException\n    {\n        // select\n\n        String select =\n            \"distinct extension.id, extension.type, extension.name\"\n                + \", extension.summary, extension.description, extension.website, extension.authors, extension.features\";\n\n        // TODO: add support for real lists: need a HQL or JPQL equivalent to MySQL GROUP_CONCAT\n        // * dependencies\n\n        if (where != null) {\n            where = \"(\" + where + \") and extensionVersion.version = extension.lastVersion\";\n        } else {\n            where = \"extensionVersion.version = extension.lastVersion\";\n        }\n\n        return createExtensionsQuery(select, from, where, offset, number, true);\n    }","id":80617,"modified_method":"protected Query createExtensionsQuery(String from, String where, int offset, int number) throws QueryException\n    {\n        // select\n\n        String select = SELECT_EXTENSION;\n\n        // TODO: add support for real lists: need a HQL or JPQL equivalent to MySQL GROUP_CONCAT\n        // * dependencies\n\n        // Link to last version object\n\n        if (where != null) {\n            where = \"(\" + where + \") and \";\n        } else {\n            where = \"\";\n        }\n        where +=\n            \"extensionVersion.\" + XWikiRepositoryModel.PROP_VERSION_VERSION + \" = extension.\"\n                + XWikiRepositoryModel.PROP_EXTENSION_LASTVERSION;\n\n        return createExtensionsQuery(select, from, where, offset, number, true);\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Document getExtensionDocument(String extensionId) throws XWikiException, QueryException\n    {\n        Query query =\n            this.queryManager.createQuery(\"from doc.object(\" + XWikiRepositoryModel.EXTENSION_CLASSNAME\n                + \") as extension where extension.id = :extensionId\", Query.XWQL);\n\n        query.bindValue(\"extensionId\", extensionId);\n\n        List<String> documentNames = query.execute();\n\n        if (documentNames.isEmpty()) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        return Utils.getXWikiApi(this.componentManager).getDocument(documentNames.get(0));\n    }","id":80618,"modified_method":"protected Document getExtensionDocument(String extensionId) throws XWikiException, QueryException\n    {\n        Query query =\n            this.queryManager.createQuery(\"from doc.object(\" + XWikiRepositoryModel.EXTENSION_CLASSNAME\n                + \") as extension where extension.\" + XWikiRepositoryModel.PROP_EXTENSION_ID + \" = :extensionId\",\n                Query.XWQL);\n\n        query.bindValue(\"extensionId\", extensionId);\n\n        List<String> documentNames = query.execute();\n\n        if (documentNames.isEmpty()) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        return Utils.getXWikiApi(this.componentManager).getDocument(documentNames.get(0));\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Query createExtensionsQuery(String select, String from, String where, int offset, int number,\n        boolean versions) throws QueryException\n    {\n        // select\n\n        StringBuilder queryStr = new StringBuilder(\"select \");\n        queryStr.append(select);\n\n        if (versions) {\n            queryStr.append(\", extensionVersion.version\");\n        }\n\n        // from\n\n        queryStr\n            .append(\" from Document doc, doc.object(\" + XWikiRepositoryModel.EXTENSION_CLASSNAME + \") as extension\");\n\n        if (versions) {\n            queryStr\n                .append(\", doc.object(\" + XWikiRepositoryModel.EXTENSIONVERSION_CLASSNAME + \") as extensionVersion\");\n        }\n\n        if (from != null) {\n            queryStr.append(',');\n            queryStr.append(from);\n        }\n\n        // where\n\n        queryStr.append(\" where \");\n        if (where != null) {\n            queryStr.append('(');\n            queryStr.append(where);\n            queryStr.append(')');\n            queryStr.append(\" and \");\n        }\n        queryStr.append(\"extension.\" + XWikiRepositoryModel.PROP_EXTENSION_VALIDEXTENSION + \" = 1\");\n\n        Query query = this.queryManager.createQuery(queryStr.toString(), Query.XWQL);\n\n        if (offset > 0) {\n            query.setOffset(offset);\n        }\n        if (number > 0) {\n            query.setLimit(number);\n        }\n\n        return query;\n    }","id":80619,"modified_method":"private Query createExtensionsQuery(String select, String from, String where, int offset, int number,\n        boolean versions) throws QueryException\n    {\n        // select\n\n        StringBuilder queryStr = new StringBuilder(\"select \");\n        queryStr.append(select);\n\n        if (versions) {\n            queryStr.append(\", extensionVersion.\" + XWikiRepositoryModel.PROP_VERSION_VERSION + \"\");\n        }\n\n        // from\n\n        queryStr\n            .append(\" from Document doc, doc.object(\" + XWikiRepositoryModel.EXTENSION_CLASSNAME + \") as extension\");\n\n        if (versions) {\n            queryStr\n                .append(\", doc.object(\" + XWikiRepositoryModel.EXTENSIONVERSION_CLASSNAME + \") as extensionVersion\");\n        }\n\n        if (from != null) {\n            queryStr.append(',');\n            queryStr.append(from);\n        }\n\n        // where\n\n        queryStr.append(\" where \");\n        if (where != null) {\n            queryStr.append('(');\n            queryStr.append(where);\n            queryStr.append(')');\n            queryStr.append(\" and \");\n        }\n        queryStr.append(\"extension.\" + XWikiRepositoryModel.PROP_EXTENSION_VALIDEXTENSION + \" = 1\");\n\n        Query query = this.queryManager.createQuery(queryStr.toString(), Query.XWQL);\n\n        if (offset > 0) {\n            query.setOffset(offset);\n        }\n        if (number > 0) {\n            query.setLimit(number);\n        }\n\n        return query;\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Query createExtensionsSummariesQuery(String from, String where, int offset, int number, boolean versions)\n        throws QueryException\n    {\n        String select = \"extension.id, extension.type, extension.name\";\n\n        return createExtensionsQuery(select, from, where, offset, number, versions);\n    }","id":80620,"modified_method":"protected Query createExtensionsSummariesQuery(String from, String where, int offset, int number, boolean versions)\n        throws QueryException\n    {\n        String select = SELECT_EXTENSIONSUMMARY;\n\n        return createExtensionsQuery(select, from, where, offset, number, versions);\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private ExtensionVersion createExtensionVersionFromQueryResult(Object[] entry)\n    {\n        ExtensionVersion extension = this.objectFactory.createExtensionVersion();\n\n        extension.setId((String) entry[0]);\n        extension.setType((String) entry[1]);\n        extension.setName((String) entry[2]);\n        extension.setSummary((String) entry[3]);\n        extension.setDescription((String) entry[4]);\n        extension.setWebsite((String) entry[5]);\n\n        // Authors\n        for (String authorId : ListClass.getListFromString((String) entry[6], \"|\", false)) {\n            extension.getAuthors().add(resolveExtensionAuthor(authorId));\n        }\n\n        // Features\n        extension.getFeatures().addAll(ListClass.getListFromString((String) entry[7], \"|\", false));\n\n        extension.setVersion((String) entry[8]);\n\n        // TODO: add support for\n        // * dependencies\n\n        return extension;\n    }","id":80621,"modified_method":"private ExtensionVersion createExtensionVersionFromQueryResult(Object[] entry)\n    {\n        ExtensionVersion extension = this.objectFactory.createExtensionVersion();\n\n        extension.setId(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_ID));\n        extension.setType(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_TYPE));\n        extension.setName(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_NAME));\n        extension.setSummary(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_SUMMARY));\n        extension.setDescription(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_DESCRIPTION));\n        extension.setWebsite(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_WEBSITE));\n\n        // Authors\n        for (String authorId : ListClass.getListFromString(\n            this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_AUTHORS), \"|\", false)) {\n            extension.getAuthors().add(resolveExtensionAuthor(authorId));\n        }\n\n        // Features\n        extension.getFeatures().addAll(\n            ListClass.getListFromString(\n                this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_FEATURES), \"|\", false));\n\n        // License\n        License license = this.objectFactory.createLicense();\n        license.setName(this.<String> getQueryValue(entry, XWikiRepositoryModel.PROP_EXTENSION_LICENSENAME));\n        extension.getLicenses().add(license);\n\n        // Version\n        extension.setVersion((String) entry[EPROPERTIES_INDEX.size()]);\n\n        // TODO: add support for\n        // * dependencies\n\n        return extension;\n    }","commit_id":"c4eb828b0f710e6686a6e3431b2911721244439f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Returns elements for the search result matching the given options.<p>\n     * \n     * @param options the search options\n     * @param types the supported container types\n     * \n     * @return JSON object with 2 properties, {@link CmsADEServer#P_ELEMENTS} and {@link CmsADEServer#P_HASMORE}\n     * \n     * @throws JSONException if something goes wrong\n     */\n    protected JSONObject getSearchResult(CmsSearchOptions options, Set<String> types) throws JSONException {\n\n        CmsObject cms = getCmsObject();\n\n        JSONObject result = new JSONObject();\n        JSONArray elements = new JSONArray();\n        result.put(CmsADEServer.P_ELEMENTS, elements);\n\n        // get the configured search index \n        CmsUser user = cms.getRequestContext().currentUser();\n        String indexName = new CmsUserSettings(user).getWorkplaceSearchIndexName();\n\n        // get the page size\n        Integer pageSize = (Integer)user.getAdditionalInfo(ADDINFO_ADE_SEARCHPAGE_SIZE);\n        if (pageSize == null) {\n            pageSize = new Integer(DEFAULT_SEARCHPAGE_SIZE);\n        }\n\n        // set the search parameters\n        CmsSearchParameters params = new CmsSearchParameters(options.getText());\n        params.setIndex(indexName);\n        params.setMatchesPerPage(pageSize.intValue());\n        params.setSearchPage(options.getPage() + 1);\n        params.setResourceTypes(CmsStringUtil.splitAsList(options.getType(), \",\"));\n\n        // search\n        CmsSearch searchBean = new CmsSearch();\n        searchBean.init(cms);\n        searchBean.setParameters(params);\n        searchBean.setSearchRoot(options.getLocation());\n        List<CmsSearchResult> searchResults = searchBean.getSearchResult();\n\n        // helper\n        CmsElementUtil elemUtil = new CmsElementUtil(cms, getRequest(), getResponse(), getRequest().getParameter(\n            PARAMETER_URL));\n\n        // iterate result list and generate the elements\n        Iterator<CmsSearchResult> it = searchResults.iterator();\n        while (it.hasNext()) {\n            CmsSearchResult sr = it.next();\n            // get the element data\n            String uri = cms.getRequestContext().removeSiteRoot(sr.getPath());\n            try {\n                JSONObject resElement = elemUtil.getElementData(uri, types);\n                // store element data\n                elements.put(resElement);\n            } catch (Exception e) {\n                LOG.warn(e.getLocalizedMessage(), e);\n            }\n        }\n\n        // check if there are more search pages\n        int results = searchBean.getSearchPage() * searchBean.getMatchesPerPage();\n        boolean hasMore = (searchBean.getSearchResultCount() > results);\n        result.put(CmsADEServer.P_HASMORE, hasMore);\n\n        // cache the search options, but with page=0\n        m_cache.cacheADESearchOptions(user.getId().toString(), options.resetPage());\n\n        return result;\n    }","id":80622,"modified_method":"/**\n     * Returns elements for the search result matching the given options.<p>\n     * \n     * @param options the search options\n     * @param types the supported container types\n     * \n     * @return JSON object with 2 properties, {@link CmsADEServer#P_ELEMENTS} and {@link CmsADEServer#P_HASMORE}\n     * \n     * @throws JSONException if something goes wrong\n     */\n    protected JSONObject getSearchResult(CmsSearchOptions options, Set<String> types) throws JSONException {\n\n        CmsObject cms = getCmsObject();\n\n        JSONObject result = new JSONObject();\n        JSONArray elements = new JSONArray();\n        result.put(CmsADEServer.P_ELEMENTS, elements);\n\n        CmsUser user = cms.getRequestContext().currentUser();\n\n        // if there is no type or no text to search, no search is needed \n        if (options.isValid()) {\n            // get the configured search index \n            String indexName = new CmsUserSettings(user).getWorkplaceSearchIndexName();\n\n            // get the page size\n            Integer pageSize = (Integer)user.getAdditionalInfo(ADDINFO_ADE_SEARCHPAGE_SIZE);\n            if (pageSize == null) {\n                pageSize = new Integer(DEFAULT_SEARCHPAGE_SIZE);\n            }\n\n            // set the search parameters\n            CmsSearchParameters params = new CmsSearchParameters(options.getText());\n            params.setIndex(indexName);\n            params.setMatchesPerPage(pageSize.intValue());\n            params.setSearchPage(options.getPage() + 1);\n            params.setResourceTypes(options.getTypesAsList());\n\n            // search\n            CmsSearch searchBean = new CmsSearch();\n            searchBean.init(cms);\n            searchBean.setParameters(params);\n            searchBean.setSearchRoot(options.getLocation());\n            List<CmsSearchResult> searchResults = searchBean.getSearchResult();\n\n            // helper\n            CmsElementUtil elemUtil = new CmsElementUtil(cms, getRequest(), getResponse(), getRequest().getParameter(\n                PARAMETER_URL));\n\n            // iterate result list and generate the elements\n            Iterator<CmsSearchResult> it = searchResults.iterator();\n            while (it.hasNext()) {\n                CmsSearchResult sr = it.next();\n                // get the element data\n                String uri = cms.getRequestContext().removeSiteRoot(sr.getPath());\n                try {\n                    JSONObject resElement = elemUtil.getElementData(uri, types);\n                    // store element data\n                    elements.put(resElement);\n                } catch (Exception e) {\n                    LOG.warn(e.getLocalizedMessage(), e);\n                }\n            }\n            // check if there are more search pages\n            int results = searchBean.getSearchPage() * searchBean.getMatchesPerPage();\n            boolean hasMore = (searchBean.getSearchResultCount() > results);\n            result.put(CmsADEServer.P_HASMORE, hasMore);\n        } else {\n            // no search\n            result.put(CmsADEServer.P_HASMORE, false);\n        }\n\n        // cache the search options, but with page=0\n        m_cache.cacheADESearchOptions(user.getId().toString(), options.resetPage());\n\n        return result;\n    }","commit_id":"c4c57c3d66ae20ed87a2e8fdfd7b2f6a19c2038b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Handles all ADE get requests.<p>\n     * \n     * @return the result\n     * \n     * @throws JSONException if there is any problem with JSON\n     * @throws CmsException if there is a problem with the cms context\n     */\n    protected JSONObject executeActionGet() throws CmsException, JSONException {\n\n        JSONObject result = new JSONObject();\n\n        HttpServletRequest request = getRequest();\n\n        String objParam = request.getParameter(PARAMETER_OBJ);\n        if (objParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_OBJ));\n            return result;\n        }\n        String urlParam = request.getParameter(PARAMETER_URL);\n        if (urlParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_URL));\n            return result;\n        }\n\n        CmsObject cms = getCmsObject();\n        CmsResource cntPageRes = cms.readResource(urlParam);\n        CmsContainerPageBean cntPage = CmsContainerPageCache.getInstance().getCache(\n            cms,\n            cntPageRes,\n            cms.getRequestContext().getLocale());\n\n        if (objParam.equals(OBJ_ALL)) {\n            // first load, get everything\n            result = getContainerPage(cntPageRes, cntPage);\n        } else if (objParam.equals(OBJ_ELEM)) {\n            // get element data\n            String elemParam = request.getParameter(PARAMETER_ELEM);\n            if (elemParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_ELEM));\n                return result;\n            }\n            CmsElementUtil elemUtil = new CmsElementUtil(cms, request, getResponse(), urlParam);\n            JSONObject resElements = new JSONObject();\n            if (elemParam.startsWith(\"[\")) {\n                // element list\n                JSONArray elems = new JSONArray(elemParam);\n                for (int i = 0; i < elems.length(); i++) {\n                    String elem = elems.getString(i);\n                    resElements.put(elem, elemUtil.getElementData(CmsElementUtil.parseId(elem), cntPage.getTypes()));\n                }\n            } else {\n                // single element\n                resElements.put(elemParam, elemUtil.getElementData(\n                    CmsElementUtil.parseId(elemParam),\n                    cntPage.getTypes()));\n            }\n            result.put(P_ELEMENTS, resElements);\n        } else if (objParam.equals(OBJ_FAV)) {\n            // get the favorite list\n            result.put(P_FAVORITES, getFavoriteList(null, cntPage.getTypes()));\n        } else if (objParam.equals(OBJ_REC)) {\n            // get recent list\n            result.put(P_RECENT, getRecentList(null, cntPage.getTypes()));\n        } else if (objParam.equals(OBJ_SEARCH)) {\n            // new search\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = getSearchResult(searchOptions, cntPage.getTypes());\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_LS)) {\n            // last search\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = getLastSearchResult(searchOptions, cntPage.getTypes());\n\n            // we need those on the client side to make scrolling work\n            CmsSearchOptions oldOptions = getSearchOptionsFromCache();\n            result.put(PARAMETER_TYPE, oldOptions.getType());\n            result.put(PARAMETER_TEXT, oldOptions.getText());\n            result.put(PARAMETER_LOCATION, oldOptions.getLocation());\n\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_NEW)) {\n            // get a new element\n            String dataParam = request.getParameter(PARAMETER_DATA);\n            if (dataParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_DATA));\n                return result;\n            }\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n\n            String type = dataParam;\n            CmsElementCreator elemCreator = new CmsElementCreator(cms, cntPage.getNewConfig());\n\n            CmsResource newResource = elemCreator.createElement(cms, type);\n            result.put(P_ID, CmsElementUtil.createId(newResource.getStructureId()));\n            result.put(P_URI, cms.getSitePath(newResource));\n        } else {\n            result.put(RES_ERROR, Messages.get().getBundle().key(\n                Messages.ERR_JSON_WRONG_PARAMETER_VALUE_2,\n                PARAMETER_OBJ,\n                objParam));\n        }\n        return result;\n    }","id":80623,"modified_method":"/**\n     * Handles all ADE get requests.<p>\n     * \n     * @return the result\n     * \n     * @throws JSONException if there is any problem with JSON\n     * @throws CmsException if there is a problem with the cms context\n     */\n    protected JSONObject executeActionGet() throws CmsException, JSONException {\n\n        JSONObject result = new JSONObject();\n\n        HttpServletRequest request = getRequest();\n\n        String objParam = request.getParameter(PARAMETER_OBJ);\n        if (objParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_OBJ));\n            return result;\n        }\n        String urlParam = request.getParameter(PARAMETER_URL);\n        if (urlParam == null) {\n            result.put(RES_ERROR, Messages.get().getBundle().key(Messages.ERR_JSON_MISSING_PARAMETER_1, PARAMETER_URL));\n            return result;\n        }\n\n        CmsObject cms = getCmsObject();\n        CmsResource cntPageRes = cms.readResource(urlParam);\n        CmsContainerPageBean cntPage = CmsContainerPageCache.getInstance().getCache(\n            cms,\n            cntPageRes,\n            cms.getRequestContext().getLocale());\n\n        if (objParam.equals(OBJ_ALL)) {\n            // first load, get everything\n            result = getContainerPage(cntPageRes, cntPage);\n        } else if (objParam.equals(OBJ_ELEM)) {\n            // get element data\n            String elemParam = request.getParameter(PARAMETER_ELEM);\n            if (elemParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_ELEM));\n                return result;\n            }\n            CmsElementUtil elemUtil = new CmsElementUtil(cms, request, getResponse(), urlParam);\n            JSONObject resElements = new JSONObject();\n            if (elemParam.startsWith(\"[\")) {\n                // element list\n                JSONArray elems = new JSONArray(elemParam);\n                for (int i = 0; i < elems.length(); i++) {\n                    String elem = elems.getString(i);\n                    resElements.put(elem, elemUtil.getElementData(CmsElementUtil.parseId(elem), cntPage.getTypes()));\n                }\n            } else {\n                // single element\n                resElements.put(elemParam, elemUtil.getElementData(\n                    CmsElementUtil.parseId(elemParam),\n                    cntPage.getTypes()));\n            }\n            result.put(P_ELEMENTS, resElements);\n        } else if (objParam.equals(OBJ_FAV)) {\n            // get the favorite list\n            result.put(P_FAVORITES, getFavoriteList(null, cntPage.getTypes()));\n        } else if (objParam.equals(OBJ_REC)) {\n            // get recent list\n            result.put(P_RECENT, getRecentList(null, cntPage.getTypes()));\n        } else if (objParam.equals(OBJ_SEARCH)) {\n            // new search\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = getSearchResult(searchOptions, cntPage.getTypes());\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_LS)) {\n            // last search\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n            CmsSearchOptions searchOptions = new CmsSearchOptions(request);\n            JSONObject searchResult = getLastSearchResult(searchOptions, cntPage.getTypes());\n\n            // we need those on the client side to make scrolling work\n            CmsSearchOptions oldOptions = getSearchOptionsFromCache();\n            result.put(PARAMETER_TYPE, oldOptions.getTypes());\n            result.put(PARAMETER_TEXT, oldOptions.getText());\n            result.put(PARAMETER_LOCATION, oldOptions.getLocation());\n\n            result.merge(searchResult, true, false);\n        } else if (objParam.equals(OBJ_NEW)) {\n            // get a new element\n            String dataParam = request.getParameter(PARAMETER_DATA);\n            if (dataParam == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_DATA));\n                return result;\n            }\n            String containerPageUri = request.getParameter(PARAMETER_URL);\n            if (containerPageUri == null) {\n                result.put(RES_ERROR, Messages.get().getBundle().key(\n                    Messages.ERR_JSON_MISSING_PARAMETER_1,\n                    PARAMETER_URL));\n                return result;\n            }\n\n            String type = dataParam;\n            CmsElementCreator elemCreator = new CmsElementCreator(cms, cntPage.getNewConfig());\n\n            CmsResource newResource = elemCreator.createElement(cms, type);\n            result.put(P_ID, CmsElementUtil.createId(newResource.getStructureId()));\n            result.put(P_URI, cms.getSitePath(newResource));\n        } else {\n            result.put(RES_ERROR, Messages.get().getBundle().key(\n                Messages.ERR_JSON_WRONG_PARAMETER_VALUE_2,\n                PARAMETER_OBJ,\n                objParam));\n        }\n        return result;\n    }","commit_id":"c4c57c3d66ae20ed87a2e8fdfd7b2f6a19c2038b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Validates all parameters.<p>\n     * \n     * @param location the vfs location to search\n     * @param text the search query\n     * @param type the type of resources to search\n     * @param page the page number to use, zero based\n     */\n    protected void init(String location, String text, String type, int page) {\n\n        m_text = text;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_text)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_JSON_MISSING_PARAMETER_1,\n                CmsADEServer.PARAMETER_TEXT));\n        }\n        m_location = location;\n        if (m_location == null) {\n            m_location = \"/\";\n        }\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(type)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_JSON_MISSING_PARAMETER_1,\n                CmsADEServer.PARAMETER_TYPE));\n        }\n        m_type = type;\n        m_page = page;\n        if (m_page < 0) {\n            m_page = 0;\n        }\n    }","id":80624,"modified_method":"/**\n     * Validates all parameters.<p>\n     * \n     * @param location the vfs location to search\n     * @param text the search query\n     * @param type the type of resources to search\n     * @param page the page number to use, zero based\n     */\n    protected void init(String location, String text, String type, int page) {\n\n        m_text = text;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_text)) {\n            m_text = \"\";\n        }\n        m_location = location;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_location)) {\n            m_location = \"/\";\n        }\n        m_type = type;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_type)) {\n            m_type = \"[]\";\n        }\n        m_page = page;\n        if (m_page < 0) {\n            m_page = 0;\n        }\n    }","commit_id":"c4c57c3d66ae20ed87a2e8fdfd7b2f6a19c2038b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the configuration file to use.<p>\n     * \n     * @param cms the current cms context\n     * @param containerPageUri the container page uri\n     * \n     * @return the configuration file to use, or <code>null<\/code> if not found\n     */\n    protected CmsResource getConfigurationFile(CmsObject cms, String containerPageUri) {\n\n        // get the resource type configuration file, will be the same for every locale\n        String cfgPath = null;\n        try {\n            cfgPath = cms.readPropertyObject(containerPageUri, PROPERTY_CONTAINER_CONFIG, true).getValue();\n        } catch (CmsException e) {\n            LOG.debug(e.getLocalizedMessage(), e);\n        }\n        CmsResource resTypeConfigRes = null;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            LOG.warn(Messages.get().getBundle().key(\n                Messages.ERR_CONFIG_NOT_SET_2,\n                containerPageUri,\n                PROPERTY_CONTAINER_CONFIG));\n        } else {\n            try {\n                resTypeConfigRes = cms.readResource(cfgPath);\n            } catch (Exception e) {\n                throw new CmsIllegalStateException(Messages.get().container(\n                    Messages.ERR_CONFIG_NOT_FOUND_3,\n                    containerPageUri,\n                    PROPERTY_CONTAINER_CONFIG,\n                    cfgPath));\n            }\n        }\n        return resTypeConfigRes;\n    }","id":80625,"modified_method":"/**\n     * Returns the configuration file to use.<p>\n     * \n     * @param cms the current cms context\n     * @param containerPageUri the container page uri\n     * \n     * @return the configuration file to use, or <code>null<\/code> if not found\n     */\n    protected CmsResource getConfigurationFile(CmsObject cms, String containerPageUri) {\n\n        String cfgPath = null;\n        try {\n            // get the resource type configuration file from the vfs tree\n            cfgPath = cms.readPropertyObject(containerPageUri, PROPERTY_CONTAINER_CONFIG, true).getValue();\n        } catch (CmsException e) {\n            // should never happen \n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            // if not found try at the template\n            try {\n                // retrieve the template uri\n                String templateUri = cms.readPropertyObject(\n                    containerPageUri,\n                    CmsPropertyDefinition.PROPERTY_TEMPLATE,\n                    true).getValue();\n                // get the resource type configuration file from the template itself\n                cfgPath = cms.readPropertyObject(templateUri, PROPERTY_CONTAINER_CONFIG, true).getValue();\n            } catch (CmsException e) {\n                // should never happen\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            // configuration could not be found\n            LOG.warn(Messages.get().getBundle().key(\n                Messages.ERR_CONFIG_NOT_SET_2,\n                containerPageUri,\n                PROPERTY_CONTAINER_CONFIG));\n            return null;\n        }\n\n        try {\n            // read configuration file\n            return cms.readResource(cfgPath);\n        } catch (Exception e) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_NOT_FOUND_3,\n                containerPageUri,\n                PROPERTY_CONTAINER_CONFIG,\n                cfgPath));\n        }\n    }","commit_id":"4d131b854a94ec8d6e4c3577bd1846a2c6def06f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the fields parameter value.<p>\n     *\n     * @param fields the fields parameter value to set\n     */\n    public void setFields(String fields) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(fields)) {\n            throw new CmsIllegalStateException(org.opencms.workplace.search.Messages.get().container(\n                org.opencms.workplace.search.Messages.ERR_VALIDATE_SEARCH_PARAMS_0));\n        }\n        m_searchParams.setFields(CmsStringUtil.splitAsList(fields, \",\"));\n    }","id":80626,"modified_method":"/**\n     * Sets the fields parameter value.<p>\n     *\n     * @param fields the fields parameter value to set\n     */\n    public void setFields(String fields) {\n\n        String searchPage = getJsp().getRequest().getParameter(\"searchPage\");\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(searchPage) && CmsStringUtil.isEmptyOrWhitespaceOnly(fields)) {\n            throw new CmsIllegalStateException(org.opencms.workplace.search.Messages.get().container(\n                org.opencms.workplace.search.Messages.ERR_VALIDATE_SEARCH_PARAMS_0));\n        }\n        m_searchParams.setFields(CmsStringUtil.splitAsList(fields, \",\"));\n    }","commit_id":"9cd5d83f8c7403f687a58da45325d7c70e1b284f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public OIndex load(final ODatabaseRecord iDatabase, final ODocument iConfiguration) {\r\n\t\tfinal OIndex index = newInstance((String) iConfiguration.field(OIndex.CONFIG_TYPE));\r\n\t\tindex.loadFromConfiguration(iConfiguration);\r\n\t\treturn index;\r\n\t}","id":80627,"modified_method":"public OIndex load(final ODatabaseRecord iDatabase, final ODocument iConfiguration) {\r\n\t\tOIndex index = newInstance((String) iConfiguration.field(OIndex.CONFIG_TYPE));\r\n\t\tindex = index.loadFromConfiguration(iConfiguration);\r\n\t\treturn index;\r\n\t}","commit_id":"320ebca42ead5e940d9a441e6697b1fe7b0a4a67","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic OIndex loadFromConfiguration(final ODocument iConfig) {\r\n\t\tconfiguration = iConfig;\r\n\t\tname = configuration.field(OIndex.CONFIG_NAME);\r\n\t\tautomatic = (Boolean) (configuration.field(OIndex.CONFIG_AUTOMATIC) != null ? configuration.field(OIndex.CONFIG_AUTOMATIC)\r\n\t\t\t\t: true);\r\n\t\tclustersToIndex.clear();\r\n\t\tclustersToIndex.addAll((Collection<? extends String>) configuration.field(CONFIG_CLUSTERS));\r\n\t\tload(iConfig.getDatabase(), (ORID) iConfig.field(CONFIG_MAP_RID, ORID.class));\r\n\t\treturn this;\r\n\t}","id":80628,"modified_method":"public OIndex loadFromConfiguration(final ODocument iConfig) {\r\n\t\tfinal ORID rid = (ORID) iConfig.field(CONFIG_MAP_RID, ORID.class);\r\n\t\tif (rid == null)\r\n\t\t\treturn null;\r\n\t\t\r\n\t\tconfiguration = iConfig;\r\n\t\tname = configuration.field(OIndex.CONFIG_NAME);\r\n\t\tautomatic = (Boolean) (configuration.field(OIndex.CONFIG_AUTOMATIC) != null ? configuration.field(OIndex.CONFIG_AUTOMATIC)\r\n\t\t\t\t: true);\r\n\t\tclustersToIndex.clear();\r\n\r\n\t\tfinal Collection<? extends String> clusters = configuration.field(CONFIG_CLUSTERS);\r\n\t\tif (clusters != null)\r\n\t\t\tclustersToIndex.addAll(clusters);\r\n\r\n\t\tload(iConfig.getDatabase(), rid);\r\n\r\n\t\treturn this;\r\n\t}","commit_id":"320ebca42ead5e940d9a441e6697b1fe7b0a4a67","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Load a previously created index. This method is kept for compatibility with 0.9.24 databases\r\n\t * \r\n\t * @COMPATIBILITY\r\n\t */\r\n\tpublic OIndex loadIndex(final String iName, final ODocument iConfiguration) {\r\n\t\tfinal OIndex index = OIndexFactory.instance().load(database, iConfiguration);\r\n\t\tindexes.put(iName.toLowerCase(), index);\r\n\t\tsetDirty();\r\n\t\tsave();\r\n\r\n\t\treturn index;\r\n\t}","id":80629,"modified_method":"/**\r\n\t * Load a previously created index. This method is kept for compatibility with 0.9.24 databases\r\n\t * \r\n\t * @COMPATIBILITY\r\n\t */\r\n\tpublic OIndex loadIndex(final String iName, final ODocument iConfiguration) {\r\n\t\tfinal OIndex index = OIndexFactory.instance().load(database, iConfiguration);\r\n\t\tif (index != null) {\r\n\t\t\tindexes.put(iName.toLowerCase(), index);\r\n\t\t\tsetDirty();\r\n\t\t\tsave();\r\n\t\t}\r\n\r\n\t\treturn index;\r\n\t}","commit_id":"320ebca42ead5e940d9a441e6697b1fe7b0a4a67","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OPropertyIndex(final ODatabaseRecord iDatabase, final OClass iClass, final String[] iFields, final ODocument iConfiguration) {\r\n\t\tfields = iFields;\r\n\t\tfinal String indexName = getIndexName(iClass, iFields);\r\n\r\n\t\tdelegate = iDatabase.getMetadata().getIndexManager().loadIndex(indexName, iConfiguration);\r\n\t\tdelegate.setCallback(this);\r\n\t}","id":80630,"modified_method":"public OPropertyIndex(final ODatabaseRecord iDatabase, final OClass iClass, final String[] iFields, final ODocument iConfiguration) {\r\n\t\tfields = iFields;\r\n\t\tfinal String indexName = getIndexName(iClass, iFields);\r\n\r\n\t\tdelegate = iDatabase.getMetadata().getIndexManager().loadIndex(indexName, iConfiguration);\r\n\t\tif (delegate != null)\r\n\t\t\tdelegate.setCallback(this);\r\n\t}","commit_id":"320ebca42ead5e940d9a441e6697b1fe7b0a4a67","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public Object execute(final ODistributedRequestId msgId, final OServer iServer, ODistributedServerManager iManager,\n      final ODatabaseDocumentInternal database) throws Exception {\n    ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n        \"%s transaction db=%s originalReqId=%s...\", (success ? \"Committing\" : fixTasks.isEmpty() ? \"Rolling back\" : \"Fixing\"),\n        database.getName(), requestId, requestId);\n\n    ODatabaseRecordThreadLocal.INSTANCE.set(database);\n\n    // UNLOCK ALL LOCKS ACQUIRED IN TX\n    final ODistributedDatabase ddb = iManager.getMessageService().getDatabase(database.getName());\n\n    final ODistributedTxContext pRequest = ddb.popTxContext(requestId);\n    try {\n      if (success) {\n        // COMMIT\n        if (pRequest != null)\n          pRequest.commit();\n        else {\n          // UNABLE TO FIND TX CONTEXT\n          ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n              \"Error on committing transaction %s db=%s\", requestId, database.getName());\n        }\n\n      } else if (fixTasks.isEmpty()) {\n        // ROLLBACK\n        if (pRequest != null)\n          pRequest.rollback(database);\n        else {\n          // UNABLE TO FIND TX CONTEXT\n          ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n              \"Error on rolling back transaction %s db=%s\", requestId, database.getName());\n        }\n      } else {\n\n        if (pRequest == null)\n          ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n              \"Tx %s db=%s was not found for fix, probably has been already fixed for timeout reason\", requestId,\n              database.getName());\n        else\n          // FIX TRANSACTION CONTENT\n          pRequest.fix(database, fixTasks);\n\n      }\n    } finally {\n      if (pRequest != null)\n        pRequest.destroy();\n    }\n\n    return Boolean.TRUE;\n  }","id":80631,"modified_method":"@Override\n  public Object execute(final ODistributedRequestId msgId, final OServer iServer, ODistributedServerManager iManager,\n      final ODatabaseDocumentInternal database) throws Exception {\n    ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n        \"%s transaction db=%s originalReqId=%s...\", (success ? \"Committing\" : fixTasks.isEmpty() ? \"Rolling back\" : \"Fixing\"),\n        database.getName(), requestId, requestId);\n\n    ODatabaseRecordThreadLocal.INSTANCE.set(database);\n\n    // UNLOCK ALL LOCKS ACQUIRED IN TX\n    final ODistributedDatabase ddb = iManager.getMessageService().getDatabase(database.getName());\n\n    final ODistributedTxContext pRequest = ddb.popTxContext(requestId);\n    try {\n      if (success) {\n        // COMMIT\n        if (pRequest != null)\n          pRequest.commit();\n        else {\n          // UNABLE TO FIND TX CONTEXT\n          ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n              \"Error on committing distributed transaction %s db=%s\", requestId, database.getName());\n          return Boolean.FALSE;\n        }\n\n      } else if (fixTasks.isEmpty()) {\n        // ROLLBACK\n        if (pRequest != null)\n          pRequest.rollback(database);\n        else {\n          // UNABLE TO FIND TX CONTEXT\n          ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n              \"Error on rolling back distributed transaction %s db=%s\", requestId, database.getName());\n          return Boolean.FALSE;\n        }\n      } else {\n\n        // FIX TRANSACTION CONTENT\n        if (pRequest != null)\n          pRequest.fix(database, fixTasks);\n        else {\n          // UNABLE TO FIX TX CONTEXT\n          ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n              \"Error on fixing distributed transaction %s db=%s\", requestId, database.getName());\n          return Boolean.FALSE;\n        }\n\n      }\n    } finally {\n      if (pRequest != null)\n        pRequest.destroy();\n    }\n\n    return Boolean.TRUE;\n  }","commit_id":"bae596ed391c24e9a53678870d20405d37b2b1db","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Distributed requests against the available workers. This guarantee the sequence of the operations against the same record\n   * cluster.\n   */\n  public void processRequest(final ODistributedRequest request) {\n    final ORemoteTask task = request.getTask();\n    final int partitionKey = task.getPartitionKey();\n\n    if (partitionKey < 0) {\n      processLock.writeLock().lock();\n      try {\n        // COUNT HOW MANY QUEUE ARE NOT EMPTY AND WAIT ONLY THEM ARE FREE BEFORE TO EXECUTE CURRENT COMMAND\n        int anyQueueWorkerIsWorking = 0;\n        final boolean[] workingQueues = new boolean[workerThreads.size()];\n        for (int i = 0; i < workerThreads.size(); ++i) {\n          final ODistributedWorker w = workerThreads.get(i);\n          workingQueues[i] = !w.localQueue.isEmpty();\n          if (workingQueues[i])\n            anyQueueWorkerIsWorking++;\n        }\n\n        if (anyQueueWorkerIsWorking > 0) {\n          // WAIT ALL THE REQUESTS ARE MANAGED\n          ODistributedServerLog.debug(this, getLocalNodeName(), null, DIRECTION.NONE,\n              \"Request %s on database %s waiting for all the previous requests to be completed\", request, databaseName);\n\n          final CountDownLatch emptyQueues = new CountDownLatch(anyQueueWorkerIsWorking);\n\n          // PUT THE SYNC TASK ONLY IN THE WORKING QUEUES\n          for (int i = 0; i < workerThreads.size(); ++i) {\n            if (workingQueues[i]) {\n              final ODistributedRequest req = new ODistributedRequest(manager.getTaskFactory(), request.getId().getNodeId(), -1,\n                  databaseName, new OSynchronizedTaskWrapper(emptyQueues), ODistributedRequest.EXECUTION_MODE.NO_RESPONSE);\n              workerThreads.get(i).processRequest(req);\n            }\n          }\n\n          try {\n            // WAIT ALL WORKERS HAVE DONE\n            emptyQueues.await();\n\n            final CountDownLatch queueLatch = new CountDownLatch(1);\n\n            final String senderNodeName = manager.getNodeNameById(request.getId().getNodeId());\n            request.setTask(new OSynchronizedTaskWrapper(queueLatch, senderNodeName, task));\n            workerThreads.get(0).processRequest(request);\n\n            // WAIT FOR THE ASYNC OPERATION TO FINISH\n            queueLatch.await();\n\n          } catch (InterruptedException e) {\n          }\n        } else {\n          // EMPTY QUEUES: JUST EXECUTE IT\n          ODistributedServerLog.debug(this, getLocalNodeName(), null, DIRECTION.NONE,\n              \"Synchronous request %s on database %s dispatched to the worker 0\", request, databaseName);\n\n          workerThreads.get(0).processRequest(request);\n        }\n\n      } finally {\n        processLock.writeLock().unlock();\n      }\n\n    } else {\n      processLock.readLock().lock();\n      try {\n\n        final int partition = partitionKey % workerThreads.size();\n\n        ODistributedServerLog.debug(this, getLocalNodeName(), null, DIRECTION.NONE,\n            \"Request %s on database %s dispatched to the worker %d\", request, databaseName, partition);\n\n        final ODistributedWorker worker = workerThreads.get(partition);\n        worker.processRequest(request);\n\n      } finally {\n        processLock.readLock().unlock();\n      }\n    }\n  }","id":80632,"modified_method":"/**\n   * Distributed requests against the available workers. This guarantee the sequence of the operations against the same record\n   * cluster.\n   */\n  public void processRequest(final ODistributedRequest request) {\n    final ORemoteTask task = request.getTask();\n    final int partitionKey = task.getPartitionKey();\n\n    if (partitionKey < 0) {\n      processLock.writeLock().lock();\n      try {\n        // COUNT HOW MANY QUEUE ARE NOT EMPTY AND WAIT ONLY THEM ARE FREE BEFORE TO EXECUTE CURRENT COMMAND\n        int anyQueueWorkerIsWorking = 0;\n        final boolean[] workingQueues = new boolean[workerThreads.size()];\n        for (int i = 0; i < workerThreads.size(); ++i) {\n          final ODistributedWorker w = workerThreads.get(i);\n          workingQueues[i] = !w.localQueue.isEmpty();\n          if (workingQueues[i])\n            anyQueueWorkerIsWorking++;\n        }\n\n        if (anyQueueWorkerIsWorking > 0) {\n          // WAIT ALL THE REQUESTS ARE MANAGED\n          ODistributedServerLog.debug(this, getLocalNodeName(), null, DIRECTION.NONE,\n              \"Request %s on database '%s' waiting for all the previous requests to be completed\", request, databaseName);\n\n          final CountDownLatch emptyQueues = new CountDownLatch(anyQueueWorkerIsWorking);\n\n          // PUT THE SYNC TASK ONLY IN THE WORKING QUEUES\n          for (int i = 0; i < workerThreads.size(); ++i) {\n            if (workingQueues[i]) {\n              final ODistributedRequest req = new ODistributedRequest(manager.getTaskFactory(), request.getId().getNodeId(), -1,\n                  databaseName, new OSynchronizedTaskWrapper(emptyQueues), ODistributedRequest.EXECUTION_MODE.NO_RESPONSE);\n              workerThreads.get(i).processRequest(req);\n            }\n          }\n\n          try {\n            // WAIT ALL WORKERS HAVE DONE\n            emptyQueues.await();\n\n            final CountDownLatch queueLatch = new CountDownLatch(1);\n\n            final String senderNodeName = manager.getNodeNameById(request.getId().getNodeId());\n            request.setTask(new OSynchronizedTaskWrapper(queueLatch, senderNodeName, task));\n            workerThreads.get(0).processRequest(request);\n\n            // WAIT FOR THE ASYNC OPERATION TO FINISH\n            queueLatch.await();\n\n          } catch (InterruptedException e) {\n          }\n        } else {\n          // EMPTY QUEUES: JUST EXECUTE IT\n          ODistributedServerLog.debug(this, getLocalNodeName(), null, DIRECTION.NONE,\n              \"Synchronous request %s on database '%s' dispatched to the worker 0\", request, databaseName);\n\n          workerThreads.get(0).processRequest(request);\n        }\n\n      } finally {\n        processLock.writeLock().unlock();\n      }\n\n    } else {\n      processLock.readLock().lock();\n      try {\n\n        final int partition = partitionKey % workerThreads.size();\n\n        ODistributedServerLog.debug(this, getLocalNodeName(), null, DIRECTION.NONE,\n            \"Request %s on database '%s' dispatched to the worker %d\", request, databaseName, partition);\n\n        final ODistributedWorker worker = workerThreads.get(partition);\n        worker.processRequest(request);\n\n      } finally {\n        processLock.readLock().unlock();\n      }\n    }\n  }","commit_id":"bae596ed391c24e9a53678870d20405d37b2b1db","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean processCommitResult(final String localNodeName, final OTransaction iTx, final OTxTask txTask,\n      final Set<String> involvedClusters, final Iterable<ORecordOperation> tmpEntries, final Collection<String> nodes,\n      final int autoRetryDelay, final ODistributedRequestId reqId, final ODistributedResponse dResponse, final boolean isLastRetry)\n      throws InterruptedException {\n    final Object result = dResponse.getPayload();\n\n    if (result instanceof OTxTaskResult) {\n      final OTxTaskResult txResult = (OTxTaskResult) result;\n\n      final List<Object> list = txResult.results;\n\n      for (int i = 0; i < txTask.getTasks().size(); ++i) {\n        final Object o = list.get(i);\n\n        final OAbstractRecordReplicatedTask task = txTask.getTasks().get(i);\n\n        if (task instanceof OCreateRecordTask) {\n          final OCreateRecordTask t = (OCreateRecordTask) task;\n          iTx.updateIdentityAfterCommit(t.getRid(), ((OPlaceholder) o).getIdentity());\n          ORecordInternal.setVersion(iTx.getRecord(t.getRid()), ((OPlaceholder) o).getVersion());\n        } else if (task instanceof OUpdateRecordTask) {\n          final OUpdateRecordTask t = (OUpdateRecordTask) task;\n          ORecordInternal.setVersion(iTx.getRecord(t.getRid()), (Integer) o);\n        } else if (task instanceof ODeleteRecordTask) {\n\n        }\n      }\n\n      // RESET DIRTY FLAGS TO AVOID CALLING AUTO-SAVE\n      for (ORecordOperation op : tmpEntries) {\n        final ORecord record = op.getRecord();\n        if (record != null)\n          ORecordInternal.unsetDirty(record);\n      }\n\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s completed\", reqId);\n\n      sendTxCompleted(localNodeName, involvedClusters, nodes, reqId, true);\n\n    } else if (result instanceof ODistributedRecordLockedException) {\n      // AUTO RETRY\n\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s error: record %s is locked\", reqId, ((ODistributedRecordLockedException) result).getRid());\n\n      // ctx.unlock();\n\n      // if this the the last retry (and it failed), we don't need to wait anymore\n      if (autoRetryDelay > 0 && !isLastRetry)\n        Thread.sleep(autoRetryDelay);\n\n      // acquireMultipleRecordLocks(iTx, maxAutoRetry, autoRetryDelay, eventListener, ctx);\n\n      // RETRY\n      return false;\n\n    } else if (result instanceof Exception) {\n      // EXCEPTION: LOG IT AND ADD AS NESTED EXCEPTION\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s error: %s\", reqId, result, result.toString());\n\n      // ROLLBACK TX NOT TO SEND TX COMPLETED BECAUSE ALREADY UNDO\n      storage.executeUndoOnLocalServer(dResponse.getRequestId(), txTask);\n\n      if (result instanceof OTransactionException || result instanceof ONeedRetryException)\n        throw (RuntimeException) result;\n\n      throw OException.wrapException(new OTransactionException(\"Error on committing distributed transaction\"), (Exception) result);\n\n    } else {\n      // UNKNOWN RESPONSE TYPE\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.info(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s error, received unknown response type: %s\", reqId, result);\n\n      // ROLLBACK TX\n      storage.executeUndoOnLocalServer(dResponse.getRequestId(), txTask);\n      sendTxCompleted(localNodeName, involvedClusters, nodes, dResponse.getRequestId(), false);\n\n      throw new OTransactionException(\"Error on committing distributed transaction, received unknown response type \" + result);\n    }\n    return true;\n  }","id":80633,"modified_method":"protected boolean processCommitResult(final String localNodeName, final OTransaction iTx, final OTxTask txTask,\n      final Set<String> involvedClusters, final Iterable<ORecordOperation> tmpEntries, final Collection<String> nodes,\n      final int autoRetryDelay, final ODistributedRequestId reqId, final ODistributedResponse dResponse, final boolean isLastRetry)\n      throws InterruptedException {\n    final Object result = dResponse.getPayload();\n\n    if (result instanceof OTxTaskResult) {\n      final OTxTaskResult txResult = (OTxTaskResult) result;\n\n      final List<Object> list = txResult.results;\n\n      for (int i = 0; i < txTask.getTasks().size(); ++i) {\n        final Object o = list.get(i);\n\n        final OAbstractRecordReplicatedTask task = txTask.getTasks().get(i);\n\n        if (task instanceof OCreateRecordTask) {\n          final OCreateRecordTask t = (OCreateRecordTask) task;\n          iTx.updateIdentityAfterCommit(t.getRid(), ((OPlaceholder) o).getIdentity());\n          ORecordInternal.setVersion(iTx.getRecord(t.getRid()), ((OPlaceholder) o).getVersion());\n        } else if (task instanceof OUpdateRecordTask) {\n          final OUpdateRecordTask t = (OUpdateRecordTask) task;\n          ORecordInternal.setVersion(iTx.getRecord(t.getRid()), (Integer) o);\n        } else if (task instanceof ODeleteRecordTask) {\n\n        }\n      }\n\n      // RESET DIRTY FLAGS TO AVOID CALLING AUTO-SAVE\n      for (ORecordOperation op : tmpEntries) {\n        final ORecord record = op.getRecord();\n        if (record != null)\n          ORecordInternal.unsetDirty(record);\n      }\n\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s completed\", reqId);\n\n      sendTxCompleted(localNodeName, involvedClusters, nodes, reqId, true);\n\n    } else if (result instanceof ODistributedRecordLockedException) {\n      // AUTO RETRY\n\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s error: record %s is locked\", reqId, ((ODistributedRecordLockedException) result).getRid());\n\n      // ctx.unlock();\n\n      // if this the the last retry (and it failed), we don't need to wait anymore\n      if (autoRetryDelay > 0 && !isLastRetry)\n        Thread.sleep(autoRetryDelay);\n\n      // acquireMultipleRecordLocks(iTx, maxAutoRetry, autoRetryDelay, eventListener, ctx);\n\n      // RETRY\n      return false;\n\n    } else if (result instanceof Exception) {\n      // EXCEPTION: LOG IT AND ADD AS NESTED EXCEPTION\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s received error: %s\", reqId, result, result.toString());\n\n      // LET TO THE CALLER TO UNDO IT\n      if (result instanceof OTransactionException || result instanceof ONeedRetryException)\n        throw (RuntimeException) result;\n\n      throw OException.wrapException(new OTransactionException(\"Error on committing distributed transaction\"), (Exception) result);\n\n    } else {\n      // UNKNOWN RESPONSE TYPE\n      if (ODistributedServerLog.isDebugEnabled())\n        ODistributedServerLog.info(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n            \"Distributed transaction %s error, received unknown response type: %s\", reqId, result);\n\n      // ROLLBACK TX\n      storage.executeUndoOnLocalServer(dResponse.getRequestId(), txTask);\n      sendTxCompleted(localNodeName, involvedClusters, nodes, dResponse.getRequestId(), false);\n\n      throw new OTransactionException(\"Error on committing distributed transaction, received unknown response type \" + result);\n    }\n    return true;\n  }","commit_id":"bae596ed391c24e9a53678870d20405d37b2b1db","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public Object executeRecordTask(ODistributedRequestId requestId, final OServer iServer, ODistributedServerManager iManager,\n      final ODatabaseDocumentInternal database) throws Exception {\n    if (ODistributedServerLog.isDebugEnabled())\n      ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN, \"updating record %s/%s v.%d\",\n          database.getName(), rid.toString(), version);\n\n    checkRecordExists();\n\n    ORecord loadedRecord = previousRecord.copy();\n\n    if (loadedRecord instanceof ODocument) {\n      // APPLY CHANGES FIELD BY FIELD TO MARK DIRTY FIELDS FOR INDEXES/HOOKS\n      final ODocument newDocument = (ODocument) getRecord();\n\n      ODocument loadedDocument = (ODocument) loadedRecord;\n      int loadedRecordVersion = loadedDocument.merge(newDocument, false, false).getVersion();\n      ORecordInternal.setVersion(loadedDocument, version);\n    } else\n      ORecordInternal.fill(loadedRecord, rid, version, content, true);\n\n    loadedRecord.setDirty();\n\n    record = database.save(loadedRecord);\n\n    if (ODistributedServerLog.isDebugEnabled())\n      ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN, \"+-> updated record %s/%s v.%d [%s]\",\n          database.getName(), rid.toString(), record.getVersion(), record);\n\n    return record.getVersion();\n  }","id":80634,"modified_method":"@Override\n  public Object executeRecordTask(ODistributedRequestId requestId, final OServer iServer, ODistributedServerManager iManager,\n      final ODatabaseDocumentInternal database) throws Exception {\n    if (ODistributedServerLog.isDebugEnabled())\n      ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN, \"updating record %s/%s v.%d\",\n          database.getName(), rid.toString(), version);\n\n    prepareUndoOperation();\n    if (previousRecord == null) {\n      // RESURRECT/CREATE IT\n\n      new OCreateRecordTask(rid, content, version, recordType).executeRecordTask(requestId, iServer, iManager, database);\n\n    } else {\n      // UPDATE IT\n      final ORecord loadedRecord = previousRecord.copy();\n\n      if (loadedRecord instanceof ODocument) {\n        // APPLY CHANGES FIELD BY FIELD TO MARK DIRTY FIELDS FOR INDEXES/HOOKS\n        final ODocument newDocument = (ODocument) getRecord();\n\n        final ODocument loadedDocument = (ODocument) loadedRecord;\n        loadedDocument.merge(newDocument, false, false).getVersion();\n        ORecordInternal.setVersion(loadedDocument, version);\n      } else\n        ORecordInternal.fill(loadedRecord, rid, version, content, true);\n\n      loadedRecord.setDirty();\n\n      record = database.save(loadedRecord);\n    }\n\n    if (ODistributedServerLog.isDebugEnabled())\n      ODistributedServerLog.debug(this, iManager.getLocalNodeName(), getNodeSource(), DIRECTION.IN,\n          \"+-> updated record %s/%s v.%d [%s]\", database.getName(), rid.toString(), record.getVersion(), record);\n\n    return record.getVersion();\n  }","commit_id":"bae596ed391c24e9a53678870d20405d37b2b1db","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n  public void test() throws Exception {\n    startupNodesInSequence = true;\n    useTransactions = false;\n    count = 600;\n    maxRetries = 10;\n    delayWriter = 0;\n    init(SERVERS);\n    prepare(false);\n\n    // EXECUTE TESTS ONLY ON FIRST 2 NODES LEAVING NODE3 AD BACKUP ONLY REPLICA\n    executeTestsOnServers = new ArrayList<ServerRun>();\n    for (int i = 0; i < serverInstance.size() - 1; ++i) {\n      executeTestsOnServers.add(serverInstance.get(i));\n    }\n\n    execute();\n  }","id":80635,"modified_method":"@Test\n  public void test() throws Exception {\n    startupNodesInSequence = true;\n    useTransactions = false;\n    count = 300;\n    maxRetries = 10;\n    delayWriter = 0;\n    init(SERVERS);\n    prepare(false);\n\n    // EXECUTE TESTS ONLY ON FIRST 2 NODES LEAVING NODE3 AD BACKUP ONLY REPLICA\n    executeTestsOnServers = new ArrayList<ServerRun>();\n    for (int i = 0; i < serverInstance.size() - 1; ++i) {\n      executeTestsOnServers.add(serverInstance.get(i));\n    }\n\n    execute();\n  }","commit_id":"bae596ed391c24e9a53678870d20405d37b2b1db","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  protected void onServerStarted(final ServerRun server) {\n    super.onServerStarted(server);\n\n    if (serverStarted == 0) {\n      // INSTALL ON FIRST SERVER ONLY THE SERVER MONITOR TO CHECK IF HAS BEEN RESTARTED\n      server.server.getDistributedManager().registerLifecycleListener(new ODistributedLifecycleListener() {\n        @Override\n        public boolean onNodeJoining(String iNode) {\n          return true;\n        }\n\n        @Override\n        public void onNodeJoined(String iNode) {\n          nodeReJoined.add(iNode);\n        }\n\n        @Override\n        public void onNodeLeft(String iNode) {\n          nodeReJoined.clear();\n          nodeLefts.incrementAndGet();\n        }\n\n        @Override\n        public void onDatabaseChangeStatus(String iNode, String iDatabaseName, ODistributedServerManager.DB_STATUS iNewStatus) {\n        }\n      });\n    }\n\n    if (serverStarted++ == (SERVERS - 1)) {\n\n      // BACKUP LAST SERVER, RUN ASYNCHRONOUSLY\n      new Thread(new Runnable() {\n\n        @Override\n        public void run() {\n          try {\n            // CRASH LAST SERVER try {\n            executeWhen(0, new OCallable<Boolean, ODatabaseDocumentTx>() {\n              // CONDITION\n              @Override\n              public Boolean call(ODatabaseDocumentTx database) {\n                return database.countClass(\"Person\") > (count * writerCount * (SERVERS-1) * 1 / 5);\n              }\n            }, // ACTION\n                new OCallable<Boolean, ODatabaseDocumentTx>() {\n              @Override\n              public Boolean call(final ODatabaseDocumentTx database) {\n                Assert.assertTrue(\"Insert was too fast\", inserting);\n\n                banner(\"RESTARTING SERVER \" + (SERVERS - 1));\n\n                delayWriter = 10;\n\n                try {\n                  final String nodeName = server.server.getDistributedManager().getLocalNodeName();\n                  ((OHazelcastPlugin) serverInstance.get(0).getServerInstance().getDistributedManager()).restartNode(nodeName);\n                } catch (Exception e) {\n                  e.printStackTrace();\n                }\n\n                return null;\n              }\n            });\n\n          } catch (Exception e) {\n            e.printStackTrace();\n            Assert.fail(\"Error on execution flow\");\n          }\n        }\n\n      }).start();\n    }\n  }","id":80636,"modified_method":"@Override\n  protected void onServerStarted(final ServerRun server) {\n    super.onServerStarted(server);\n\n    if (serverStarted == 0) {\n      // INSTALL ON FIRST SERVER ONLY THE SERVER MONITOR TO CHECK IF HAS BEEN RESTARTED\n      server.server.getDistributedManager().registerLifecycleListener(new ODistributedLifecycleListener() {\n        @Override\n        public boolean onNodeJoining(String iNode) {\n          return true;\n        }\n\n        @Override\n        public void onNodeJoined(String iNode) {\n          nodeReJoined.add(iNode);\n        }\n\n        @Override\n        public void onNodeLeft(String iNode) {\n          nodeReJoined.clear();\n          nodeLefts.incrementAndGet();\n        }\n\n        @Override\n        public void onDatabaseChangeStatus(String iNode, String iDatabaseName, ODistributedServerManager.DB_STATUS iNewStatus) {\n        }\n      });\n    }\n\n    if (serverStarted++ == (SERVERS - 1)) {\n\n      // BACKUP LAST SERVER, RUN ASYNCHRONOUSLY\n      new Thread(new Runnable() {\n\n        @Override\n        public void run() {\n          try {\n            // CRASH LAST SERVER try {\n            executeWhen(0, new OCallable<Boolean, ODatabaseDocumentTx>() {\n              // CONDITION\n              @Override\n              public Boolean call(ODatabaseDocumentTx database) {\n                return database.countClass(\"Person\") > (count * writerCount * (SERVERS-1) * 1 / 3);\n              }\n            }, // ACTION\n                new OCallable<Boolean, ODatabaseDocumentTx>() {\n              @Override\n              public Boolean call(final ODatabaseDocumentTx database) {\n                Assert.assertTrue(\"Insert was too fast\", inserting);\n\n                banner(\"RESTARTING SERVER \" + (SERVERS - 1));\n\n                delayWriter = 10;\n\n                try {\n                  final String nodeName = server.server.getDistributedManager().getLocalNodeName();\n                  ((OHazelcastPlugin) serverInstance.get(0).getServerInstance().getDistributedManager()).restartNode(nodeName);\n                } catch (Exception e) {\n                  e.printStackTrace();\n                }\n\n                return null;\n              }\n            });\n\n          } catch (Exception e) {\n            e.printStackTrace();\n            Assert.fail(\"Error on execution flow\");\n          }\n        }\n\n      }).start();\n    }\n  }","commit_id":"bae596ed391c24e9a53678870d20405d37b2b1db","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n\t * @param id\n\t *            The identifier\n\t * @return Any page having the given id\n\t */\n\tpublic final Page get(final String id)\n\t{\n\t\tfinal Page page = (Page)getPages().get(id);\n\t\tpage.setDirty(true);\n\t\treturn page;\n\t}","id":80637,"modified_method":"/**\n\t * @param id\n\t *            The identifier\n\t * @return Any page having the given id\n\t */\n\tpublic final Page get(final String id)\n\t{\n\t\tfinal Page page = (Page)getPages().get(id);\n\t\tif (page != null)\n\t\t{\n\t\t\tpage.setDirty(true);\n\t\t}\n\t\treturn page;\n\t}","commit_id":"ba6682135f3d7d8eb186830c2fba7e33318cc56b","url":"https://github.com/apache/wicket"},{"original_method":"public boolean processLocatableEvent(final SuspendContextCommandImpl action, final LocatableEvent event) {\n    final SuspendContextImpl context = action.getSuspendContext();\n    if(!isValid()) {\n      context.getDebugProcess().getRequestsManager().deleteRequest(this);\n      return true;\n    }\n\n    final String[] title = new String[] {DebuggerBundle.message(\"title.error.evaluating.breakpoint.condition\") };\n\n    try {\n      StackFrameProxyImpl frameProxy = context.getThread().frame(0);\n\n      EvaluationContextImpl evaluationContext = new EvaluationContextImpl(action.getSuspendContext(), frameProxy,\n        Breakpoint.this.getThisObject(context, event));\n\n      if(!evaluateCondition(evaluationContext, event)) {\n        return true;\n      }\n\n      title[0] = DebuggerBundle.message(\"title.error.evaluating.breakpoint.action\");\n      runAction(evaluationContext, event);\n    }\n    catch (final EvaluateException ex) {\n      if(ApplicationManager.getApplication().isUnitTestMode()) {\n        System.out.println(ex.getMessage());\n        return true;\n      }\n\n      final boolean[] shouldResume = new boolean[]{true};\n      DebuggerInvocationUtil.invokeAndWait(getProject(), new Runnable() {\n          public void run() {\n            DebuggerSession session = DebuggerManagerEx.getInstanceEx(getProject()).getSession(context.getDebugProcess());\n            DebuggerPanelsManager.getInstance(getProject()).toFront(session);\n            final String text = DebuggerBundle.message(\"error.evaluating.breakpoint.condition.or.action\", getDisplayName(), ex.getMessage());\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(text);\n            }\n            shouldResume[0] = Messages.showYesNoDialog(getProject(), text, title[0], Messages.getQuestionIcon()) != 0;\n          }\n        }, ModalityState.NON_MMODAL);\n\n      return shouldResume[0];\n    } \n\n    return false;\n  }","id":80638,"modified_method":"public boolean processLocatableEvent(final SuspendContextCommandImpl action, final LocatableEvent event) {\n    final SuspendContextImpl context = action.getSuspendContext();\n    if(!isValid()) {\n      context.getDebugProcess().getRequestsManager().deleteRequest(this);\n      return true;\n    }\n\n    final String[] title = new String[] {DebuggerBundle.message(\"title.error.evaluating.breakpoint.condition\") };\n\n    try {\n      final StackFrameProxyImpl frameProxy = context.getThread().frame(0);\n      if (frameProxy == null) {\n        // might be if the thread has been collected\n        return true;\n      }\n\n      final EvaluationContextImpl evaluationContext = new EvaluationContextImpl(\n        action.getSuspendContext(),\n        frameProxy,\n        getThisObject(context, event)\n      );\n\n      if(!evaluateCondition(evaluationContext, event)) {\n        return true;\n      }\n\n      title[0] = DebuggerBundle.message(\"title.error.evaluating.breakpoint.action\");\n      runAction(evaluationContext, event);\n    }\n    catch (final EvaluateException ex) {\n      if(ApplicationManager.getApplication().isUnitTestMode()) {\n        System.out.println(ex.getMessage());\n        return true;\n      }\n\n      final boolean[] shouldResume = new boolean[]{true};\n      DebuggerInvocationUtil.invokeAndWait(getProject(), new Runnable() {\n          public void run() {\n            DebuggerSession session = DebuggerManagerEx.getInstanceEx(getProject()).getSession(context.getDebugProcess());\n            DebuggerPanelsManager.getInstance(getProject()).toFront(session);\n            final String text = DebuggerBundle.message(\"error.evaluating.breakpoint.condition.or.action\", getDisplayName(), ex.getMessage());\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(text);\n            }\n            shouldResume[0] = Messages.showYesNoDialog(getProject(), text, title[0], Messages.getQuestionIcon()) != 0;\n          }\n        }, ModalityState.NON_MMODAL);\n\n      return shouldResume[0];\n    } \n\n    return false;\n  }","commit_id":"6238dd84f46255cf0882e94da1def1882260e449","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StackFrameProxyImpl frame(int i) throws EvaluateException {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    if(!getThreadReference().isSuspended()) return null;\n    checkFrames();\n    return myFramesFromBottom.get(frameCount() - i  - 1);\n  }","id":80639,"modified_method":"public StackFrameProxyImpl frame(int i) throws EvaluateException {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    final ThreadReference threadReference = getThreadReference();\n    if(threadReference == null || !threadReference.isSuspended()) {\n      return null;\n    }\n    checkFrames();\n    return myFramesFromBottom.get(frameCount() - i  - 1);\n  }","commit_id":"6238dd84f46255cf0882e94da1def1882260e449","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String name() {\n    checkValid();\n    if (myName == null) {\n      try {\n        myName = getThreadReference().name();\n      }\n      catch (ObjectCollectedException e) {\n        myName = \"\";\n      }\n    }\n    return myName;\n  }","id":80640,"modified_method":"public String name() {\n    checkValid();\n    if (myName == null) {\n      try {\n        final ThreadReference threadReference = getThreadReference();\n        // when thread ref is collected, the returned reference will be null\n        myName = threadReference == null? \"\" : threadReference.name();\n      }\n      catch (ObjectCollectedException e) {\n        myName = \"\";\n      }\n    }\n    return myName;\n  }","commit_id":"42b19ac8b42e33044e70bce6a492a0ac8b648636","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void suspend() {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    getThreadReference().suspend();\n    clearCaches();\n  }","id":80641,"modified_method":"public void suspend() {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    final ThreadReference threadReference = getThreadReference();\n    if (threadReference != null) {\n      threadReference.suspend();\n    }\n    clearCaches();\n  }","commit_id":"110574a844644b23b44eaee43963f2673ae05f9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isSuspended() {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    return getThreadReference().isSuspended();\n  }","id":80642,"modified_method":"public boolean isSuspended() {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    final ThreadReference thread = getThreadReference();\n    return thread != null && thread.isSuspended();\n  }","commit_id":"665223048a9584da2c1b6e0d6e41137ef159ff46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CacheEntryModified\n    public void modified(CacheEntryModifiedEvent<Address, Map.Entry<K, V>> event) {\n        if (event.isPre() || event.isOriginLocal()) return;\n        if (!this.listeners.isEmpty()) {\n            Map.Entry<K, V> entry = event.getCache().get(event.getKey());\n            if (entry != null) {\n                for (Listener<K, V> listener: this.listeners) {\n                    listener.updatedEntries(Collections.singletonMap(entry.getKey(), entry.getValue()));\n                }\n            }\n        }\n    }","id":80643,"modified_method":"@CacheEntryModified\n    public void modified(CacheEntryModifiedEvent<Address, Map.Entry<K, V>> event) {\n        if (event.isPre() || event.isOriginLocal()) return;\n        if (!this.listeners.isEmpty()) {\n            Map.Entry<K, V> entry = event.getValue();\n            Map.Entry<K, V> old = event.getCache().get(event.getKey());\n            if (entry != null) {\n                for (Listener<K, V> listener: this.listeners) {\n                    if (old == null) {\n                        listener.addedEntries(Collections.singletonMap(entry.getKey(), entry.getValue()));\n                    } else {\n                        listener.updatedEntries(Collections.singletonMap(entry.getKey(), entry.getValue()));\n                    }\n                }\n            }\n        }\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Starts 2 nodes with the clustered beans deployed on each node. Invokes a (deployment descriptor based) clustered SFSB a few times.\n     * Then stops a node from among the cluster (the one which received the last invocation) and continues invoking\n     * on the same SFSB. These subsequent invocations are expected to failover to the other node and also have the\n     * correct state of the SFSB.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testFailoverFromRemoteClientWhenOneNodeGoesDown() throws Exception {\n        // Container is unmanaged, so start it ourselves\n        this.container.start(CONTAINER_1);\n        // deploy to container1\n        this.deployer.deploy(DEPLOYMENT_1);\n\n        // start the other container too\n        this.container.start(CONTAINER_2);\n        this.deployer.deploy(DEPLOYMENT_2);\n\n        final ContextSelector<EJBClientContext> previousSelector = this.setupEJBClientContextSelector();\n        final String jndiName = \"ejb:\" + \"\" + \"/\" + MODULE_NAME + \"/\" + \"\" + \"/\" + DDBasedClusteredSFSB.class.getSimpleName() + \"!\" + RemoteCounter.class.getName() + \"?stateful\";\n        boolean container1Stopped = false;\n        boolean container2Stopped = false;\n        try {\n            final RemoteCounter remoteCounter = (RemoteCounter) context.lookup(jndiName);\n            // invoke on the bean a few times\n            final int NUM_TIMES = 25;\n            for (int i = 0; i < NUM_TIMES; i++) {\n                final CounterResult result = remoteCounter.increment();\n                logger.info(\"Counter incremented to \" + result.getCount() + \" on node \" + result.getNodeName());\n            }\n            final CounterResult result = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter was null\", result);\n            Assert.assertEquals(\"Unexpected count from remote counter\", NUM_TIMES, result.getCount());\n\n            // shutdown the node on which the previous invocation happened\n            final int totalCountBeforeShuttingDownANode = result.getCount();\n            final String previousInvocationNodeName = result.getNodeName();\n            // the value is configured in arquillian.xml of the project\n            if (previousInvocationNodeName.equals(\"node-udp-0\")) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n                container1Stopped = true;\n            } else {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n                container2Stopped = true;\n            }\n            // invoke again\n            CounterResult resultAfterShuttingDownANode = remoteCounter.increment();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", totalCountBeforeShuttingDownANode + 1, resultAfterShuttingDownANode.getCount());\n            Assert.assertFalse(\"Result was received from an unexpected node, after shutting down a node\", previousInvocationNodeName.equals(resultAfterShuttingDownANode.getNodeName()));\n\n            // repeat invocations\n            final int countBeforeDecrementing = resultAfterShuttingDownANode.getCount();\n            final String aliveNode = resultAfterShuttingDownANode.getNodeName();\n            for (int i = NUM_TIMES; i > 0; i--) {\n                resultAfterShuttingDownANode = remoteCounter.decrement();\n                Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n                Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, resultAfterShuttingDownANode.getNodeName());\n                logger.info(\"Counter decremented to \" + resultAfterShuttingDownANode.getCount() + \" on node \" + resultAfterShuttingDownANode.getNodeName());\n            }\n            final CounterResult finalResult = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", finalResult);\n            final int finalCount = finalResult.getCount();\n            final String finalNodeName = finalResult.getNodeName();\n            Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, finalNodeName);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", countBeforeDecrementing - NUM_TIMES, finalCount);\n        } finally {\n            // reset the selector\n            if (previousSelector != null) {\n                EJBClientContext.setSelector(previousSelector);\n            }\n            // shutdown the containers\n            if (!container1Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n            }\n\n            if (!container2Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n            }\n        }\n    }","id":80644,"modified_method":"/**\n     * Starts 2 nodes with the clustered beans deployed on each node. Invokes a (deployment descriptor based) clustered SFSB a few times.\n     * Then stops a node from among the cluster (the one which received the last invocation) and continues invoking\n     * on the same SFSB. These subsequent invocations are expected to failover to the other node and also have the\n     * correct state of the SFSB.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testFailoverFromRemoteClientWhenOneNodeGoesDown() throws Exception {\n        // Container is unmanaged, so start it ourselves\n        this.container.start(CONTAINER_1);\n        // deploy to container1\n        this.deployer.deploy(DEPLOYMENT_1);\n\n        // start the other container too\n        this.container.start(CONTAINER_2);\n        this.deployer.deploy(DEPLOYMENT_2);\n\n        final ContextSelector<EJBClientContext> previousSelector = EJBClientContextSelector.setup(\"cluster/ejb3/stateful/failover/sfsb-failover-jboss-ejb-client.properties\");\n        boolean container1Stopped = false;\n        boolean container2Stopped = false;\n        try {\n            final RemoteCounter remoteCounter = context.lookupStateful(DDBasedClusteredSFSB.class, RemoteCounter.class);\n            // invoke on the bean a few times\n            final int NUM_TIMES = 25;\n            for (int i = 0; i < NUM_TIMES; i++) {\n                final CounterResult result = remoteCounter.increment();\n                logger.info(\"Counter incremented to \" + result.getCount() + \" on node \" + result.getNodeName());\n            }\n            final CounterResult result = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter was null\", result);\n            Assert.assertEquals(\"Unexpected count from remote counter\", NUM_TIMES, result.getCount());\n\n            // shutdown the node on which the previous invocation happened\n            final int totalCountBeforeShuttingDownANode = result.getCount();\n            final String previousInvocationNodeName = result.getNodeName();\n            // the value is configured in arquillian.xml of the project\n            if (previousInvocationNodeName.equals(\"node-udp-0\")) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n                container1Stopped = true;\n            } else {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n                container2Stopped = true;\n            }\n            // invoke again\n            CounterResult resultAfterShuttingDownANode = remoteCounter.increment();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", totalCountBeforeShuttingDownANode + 1, resultAfterShuttingDownANode.getCount());\n            Assert.assertFalse(\"Result was received from an unexpected node, after shutting down a node\", previousInvocationNodeName.equals(resultAfterShuttingDownANode.getNodeName()));\n\n            // repeat invocations\n            final int countBeforeDecrementing = resultAfterShuttingDownANode.getCount();\n            final String aliveNode = resultAfterShuttingDownANode.getNodeName();\n            for (int i = NUM_TIMES; i > 0; i--) {\n                resultAfterShuttingDownANode = remoteCounter.decrement();\n                Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n                Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, resultAfterShuttingDownANode.getNodeName());\n                logger.info(\"Counter decremented to \" + resultAfterShuttingDownANode.getCount() + \" on node \" + resultAfterShuttingDownANode.getNodeName());\n            }\n            final CounterResult finalResult = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", finalResult);\n            final int finalCount = finalResult.getCount();\n            final String finalNodeName = finalResult.getNodeName();\n            Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, finalNodeName);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", countBeforeDecrementing - NUM_TIMES, finalCount);\n        } finally {\n            // reset the selector\n            if (previousSelector != null) {\n                EJBClientContext.setSelector(previousSelector);\n            }\n            // shutdown the containers\n            if (!container1Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n            }\n\n            if (!container2Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n            }\n        }\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@BeforeClass\n    public static void beforeClass() throws Exception {\n        final Hashtable props = new Hashtable();\n        props.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        context = new InitialContext(props);\n\n    }","id":80645,"modified_method":"@BeforeClass\n    public static void beforeClass() throws Exception {\n        context = new RemoteEJBDirectory(MODULE_NAME);\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Starts 2 nodes with the clustered beans deployed on each node. Invokes a clustered SFSB a few times.\n     * Then stops a node from among the cluster (the one which received the last invocation) and continues invoking\n     * on the same SFSB. These subsequent invocations are expected to failover to the other node and also have the\n     * correct state of the SFSB.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testFailoverFromRemoteClientWhenOneNodeGoesDown() throws Exception {\n        // Container is unmanaged, so start it ourselves\n        this.container.start(CONTAINER_1);\n        // deploy to container1\n        this.deployer.deploy(DEPLOYMENT_1);\n\n        // start the other container too\n        this.container.start(CONTAINER_2);\n        this.deployer.deploy(DEPLOYMENT_2);\n\n        final ContextSelector<EJBClientContext> previousSelector = this.setupEJBClientContextSelector();\n        final String jndiName = \"ejb:\" + \"\" + \"/\" + MODULE_NAME + \"/\" + \"\" + \"/\" + CounterBean.class.getSimpleName() + \"!\" + RemoteCounter.class.getName() + \"?stateful\";\n        final String destructionCounterJndiName = \"ejb:\" + \"\" + \"/\" + MODULE_NAME + \"/\" + \"\" + \"/\" + DestructionCounterSingleton.class.getSimpleName() + \"!\" + DestructionCounterRemote.class.getName();\n        boolean container1Stopped = false;\n        boolean container2Stopped = false;\n        try {\n            final RemoteCounter remoteCounter = (RemoteCounter) context.lookup(jndiName);\n            final DestructionCounterRemote destructionCounter = (DestructionCounterRemote) context.lookup(destructionCounterJndiName);\n            // invoke on the bean a few times\n            final int NUM_TIMES = 25;\n            for (int i = 0; i < NUM_TIMES; i++) {\n                final CounterResult result = remoteCounter.increment();\n                logger.info(\"Counter incremented to \" + result.getCount() + \" on node \" + result.getNodeName());\n            }\n            final CounterResult result = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter was null\", result);\n            Assert.assertEquals(\"Unexpected count from remote counter\", NUM_TIMES, result.getCount());\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getCDIDestructionCount());\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getSFSBDestructionCount());\n\n            // shutdown the node on which the previous invocation happened\n            final int totalCountBeforeShuttingDownANode = result.getCount();\n            final String previousInvocationNodeName = result.getNodeName();\n            // the value is configured in arquillian.xml of the project\n            if (previousInvocationNodeName.equals(\"node-udp-0\")) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n                container1Stopped = true;\n            } else {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n                container2Stopped = true;\n            }\n            // invoke again\n            CounterResult resultAfterShuttingDownANode = remoteCounter.increment();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", totalCountBeforeShuttingDownANode + 1, resultAfterShuttingDownANode.getCount());\n            Assert.assertFalse(\"Result was received from an unexpected node, after shutting down a node\", previousInvocationNodeName.equals(resultAfterShuttingDownANode.getNodeName()));\n\n            // repeat invocations\n            final int countBeforeDecrementing = resultAfterShuttingDownANode.getCount();\n            final String aliveNode = resultAfterShuttingDownANode.getNodeName();\n            for (int i = NUM_TIMES; i > 0; i--) {\n                resultAfterShuttingDownANode = remoteCounter.decrement();\n                Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n                Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, resultAfterShuttingDownANode.getNodeName());\n                logger.info(\"Counter decremented to \" + resultAfterShuttingDownANode.getCount() + \" on node \" + resultAfterShuttingDownANode.getNodeName());\n            }\n            final CounterResult finalResult = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", finalResult);\n            final int finalCount = finalResult.getCount();\n            final String finalNodeName = finalResult.getNodeName();\n            Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, finalNodeName);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", countBeforeDecrementing - NUM_TIMES, finalCount);\n\n\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getCDIDestructionCount());\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getSFSBDestructionCount());\n            remoteCounter.remove();\n            Assert.assertEquals(\"CDI bean was not destroyed\", 1, destructionCounter.getCDIDestructionCount());\n            Assert.assertEquals(\"SFSB was not destroyed\", 1, destructionCounter.getSFSBDestructionCount());\n\n\n        } finally {\n            // reset the selector\n            if (previousSelector != null) {\n                EJBClientContext.setSelector(previousSelector);\n            }\n            // shutdown the containers\n            if (!container1Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n            }\n\n            if (!container2Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n            }\n        }\n    }","id":80646,"modified_method":"/**\n     * Starts 2 nodes with the clustered beans deployed on each node. Invokes a clustered SFSB a few times.\n     * Then stops a node from among the cluster (the one which received the last invocation) and continues invoking\n     * on the same SFSB. These subsequent invocations are expected to failover to the other node and also have the\n     * correct state of the SFSB.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testFailoverFromRemoteClientWhenOneNodeGoesDown() throws Exception {\n        // Container is unmanaged, so start it ourselves\n        this.container.start(CONTAINER_1);\n        // deploy to container1\n        this.deployer.deploy(DEPLOYMENT_1);\n\n        // start the other container too\n        this.container.start(CONTAINER_2);\n        this.deployer.deploy(DEPLOYMENT_2);\n\n        final ContextSelector<EJBClientContext> previousSelector = EJBClientContextSelector.setup(\"cluster/ejb3/stateful/failover/sfsb-failover-jboss-ejb-client.properties\");\n        boolean container1Stopped = false;\n        boolean container2Stopped = false;\n        try {\n            final RemoteCounter remoteCounter = context.lookupStateful(CounterBean.class, RemoteCounter.class);\n            final DestructionCounterRemote destructionCounter = context.lookupSingleton(DestructionCounterSingleton.class, DestructionCounterRemote.class);\n            // invoke on the bean a few times\n            final int NUM_TIMES = 25;\n            for (int i = 0; i < NUM_TIMES; i++) {\n                final CounterResult result = remoteCounter.increment();\n                logger.info(\"Counter incremented to \" + result.getCount() + \" on node \" + result.getNodeName());\n            }\n            final CounterResult result = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter was null\", result);\n            Assert.assertEquals(\"Unexpected count from remote counter\", NUM_TIMES, result.getCount());\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getCDIDestructionCount());\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getSFSBDestructionCount());\n\n            // shutdown the node on which the previous invocation happened\n            final int totalCountBeforeShuttingDownANode = result.getCount();\n            final String previousInvocationNodeName = result.getNodeName();\n            // the value is configured in arquillian.xml of the project\n            if (previousInvocationNodeName.equals(\"node-udp-0\")) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n                container1Stopped = true;\n            } else {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n                container2Stopped = true;\n            }\n            // invoke again\n            CounterResult resultAfterShuttingDownANode = remoteCounter.increment();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", totalCountBeforeShuttingDownANode + 1, resultAfterShuttingDownANode.getCount());\n            Assert.assertFalse(\"Result was received from an unexpected node, after shutting down a node\", previousInvocationNodeName.equals(resultAfterShuttingDownANode.getNodeName()));\n\n            // repeat invocations\n            final int countBeforeDecrementing = resultAfterShuttingDownANode.getCount();\n            final String aliveNode = resultAfterShuttingDownANode.getNodeName();\n            for (int i = NUM_TIMES; i > 0; i--) {\n                resultAfterShuttingDownANode = remoteCounter.decrement();\n                Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", resultAfterShuttingDownANode);\n                Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, resultAfterShuttingDownANode.getNodeName());\n                logger.info(\"Counter decremented to \" + resultAfterShuttingDownANode.getCount() + \" on node \" + resultAfterShuttingDownANode.getNodeName());\n            }\n            final CounterResult finalResult = remoteCounter.getCount();\n            Assert.assertNotNull(\"Result from remote stateful counter, after shutting down a node was null\", finalResult);\n            final int finalCount = finalResult.getCount();\n            final String finalNodeName = finalResult.getNodeName();\n            Assert.assertEquals(\"Result was received from an unexpected node, after shutting down a node\", aliveNode, finalNodeName);\n            Assert.assertEquals(\"Unexpected count from remote counter, after shutting down a node\", countBeforeDecrementing - NUM_TIMES, finalCount);\n\n\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getCDIDestructionCount());\n            Assert.assertEquals(\"Nothing should have been destroyed yet\", 0, destructionCounter.getSFSBDestructionCount());\n            remoteCounter.remove();\n            Assert.assertEquals(\"CDI bean was not destroyed\", 1, destructionCounter.getCDIDestructionCount());\n            Assert.assertEquals(\"SFSB was not destroyed\", 1, destructionCounter.getSFSBDestructionCount());\n\n\n        } finally {\n            // reset the selector\n            if (previousSelector != null) {\n                EJBClientContext.setSelector(previousSelector);\n            }\n            // shutdown the containers\n            if (!container1Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_1);\n                this.container.stop(CONTAINER_1);\n            }\n\n            if (!container2Stopped) {\n                this.deployer.undeploy(DEPLOYMENT_2);\n                this.container.stop(CONTAINER_2);\n            }\n        }\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@BeforeClass\n    public static void beforeClass() throws Exception {\n        final Hashtable props = new Hashtable();\n        props.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        context = new InitialContext(props);\n\n    }","id":80647,"modified_method":"@BeforeClass\n    public static void beforeClass() throws Exception {\n        context = new RemoteEJBDirectory(MODULE_NAME);\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static WebArchive createDeployment() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"stateful.war\");\n        war.addPackage(StatefulBean.class.getPackage());\n        war.setWebXML(StatefulBean.class.getPackage(), \"web.xml\");\n        war.addAsWebInfResource(new StringAsset(\"<beans>\" +\n                \"<interceptors><class>\" + StatefulCDIInterceptor.class.getName() + \"<\/class><\/interceptors>\" +\n                \"<decorators><class>\" + CounterDecorator.class.getName() + \"<\/class><\/decorators>\" +\n                \"<\/beans>\"), \"beans.xml\");\n        System.out.println(war.toString(true));\n        return war;\n    }","id":80648,"modified_method":"private static WebArchive createDeployment() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"stateful.war\");\n        war.addPackage(StatefulBean.class.getPackage());\n        war.addPackage(EJBDirectory.class.getPackage());\n        war.setWebXML(StatefulBean.class.getPackage(), \"web.xml\");\n        war.addAsWebInfResource(new StringAsset(\"<beans>\" +\n                \"<interceptors><class>\" + StatefulCDIInterceptor.class.getName() + \"<\/class><\/interceptors>\" +\n                \"<decorators><class>\" + CounterDecorator.class.getName() + \"<\/class><\/decorators>\" +\n                \"<\/beans>\"), \"beans.xml\");\n        System.out.println(war.toString(true));\n        return war;\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment1() {\n        WebArchive war = createDeployment();\n        return war;\n    }","id":80649,"modified_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment1() {\n        return createDeployment();\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment0() {\n        WebArchive war = createDeployment();\n        return war;\n    }","id":80650,"modified_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment0() {\n        return createDeployment();\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        HttpSession session = req.getSession(true);\n        Stateful bean = (Stateful)session.getAttribute(\"bean\");\n        if (bean == null) {\n            try {\n                bean =  (Stateful)new InitialContext().lookup(\"java:app/stateful/StatefulBean!\" +\n                    Stateful.class.getName());\n            } catch (NamingException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        String command = req.getParameter(\"command\");\n\n        if(\"createEmployee\".equals(command)) {\n            bean.createEmployee(\"Tom Brady\",\"New England Patriots\", 1);\n            resp.setHeader(\"employee\", bean.getEmployee(1).getName());\n        }\n        else if(\"getEmployee\".equals(command)) {\n            Employee employee = bean.getEmployee(1);\n            resp.setHeader(\"employee\", employee.getName());\n        }\n        else if(\"getSecondBeanEmployee\".equals(command)) {\n            Employee employee = bean.getSecondBeanEmployee(1);\n            resp.setHeader(\"employee\", employee.getName());\n        }\n        else if(\"destroy\".equals(command)) {\n            bean.destroy();\n            resp.setHeader(\"employee\", command);\n        }\n\n\n        resp.getWriter().write(\"Success\");\n        session.setAttribute(\"bean\", bean);\n    }","id":80651,"modified_method":"@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        HttpSession session = req.getSession(true);\n        Stateful bean = (Stateful)session.getAttribute(\"bean\");\n        if (bean == null) {\n            try {\n                bean = new LocalEJBDirectory(\"stateful\").lookupStateful(StatefulBean.class, Stateful.class);\n            } catch (NamingException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        String command = req.getParameter(\"command\");\n\n        if(\"createEmployee\".equals(command)) {\n            bean.createEmployee(\"Tom Brady\",\"New England Patriots\", 1);\n            resp.setHeader(\"employee\", bean.getEmployee(1).getName());\n        }\n        else if(\"getEmployee\".equals(command)) {\n            Employee employee = bean.getEmployee(1);\n            resp.setHeader(\"employee\", employee.getName());\n        }\n        else if(\"getSecondBeanEmployee\".equals(command)) {\n            Employee employee = bean.getSecondBeanEmployee(1);\n            resp.setHeader(\"employee\", employee.getName());\n        }\n        else if(\"destroy\".equals(command)) {\n            bean.destroy();\n            resp.setHeader(\"employee\", command);\n        }\n\n\n        resp.getWriter().write(\"Success\");\n        session.setAttribute(\"bean\", bean);\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        HttpSession session = req.getSession(true);\n        Stateful bean = (Stateful) session.getAttribute(\"bean\");\n        if (bean == null) {\n            try {\n                bean = (Stateful) new InitialContext().lookup(\"java:app/stateful/StatefulBean!\" + Stateful.class.getCanonicalName());\n            } catch (NamingException e) {\n                throw new ServletException(e);\n            }\n        }\n        resp.setHeader(\"count\", String.valueOf(bean.increment()));\n        resp.getWriter().write(\"Success\");\n        session.setAttribute(\"bean\", bean);\n    }","id":80652,"modified_method":"@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        HttpSession session = req.getSession(true);\n        Stateful bean = (Stateful) session.getAttribute(\"bean\");\n        if (bean == null) {\n            try {\n                bean = new LocalEJBDirectory(\"stateful\").lookupStateful(StatefulBean.class, Stateful.class);\n            } catch (NamingException e) {\n                throw new ServletException(e);\n            }\n        }\n        resp.setHeader(\"count\", String.valueOf(bean.increment()));\n        resp.getWriter().write(\"Success\");\n        session.setAttribute(\"bean\", bean);\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment1() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"stateful.war\");\n        war.addPackage(StatefulBean.class.getPackage());\n        war.setWebXML(StatefulBean.class.getPackage(), \"web.xml\");\n        war.addAsResource(new StringAsset(persistence_xml), \"META-INF/persistence.xml\");\n        System.out.println(war.toString(true));\n        return war;\n    }","id":80653,"modified_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment1() {\n        return createDeployment();\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment0() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"stateful.war\");\n        war.addPackage(StatefulBean.class.getPackage());\n        war.setWebXML(StatefulBean.class.getPackage(), \"web.xml\");\n        war.addAsResource(new StringAsset(persistence_xml), \"META-INF/persistence.xml\");\n        System.out.println(war.toString(true));\n        return war;\n    }","id":80654,"modified_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment0() {\n        return createDeployment();\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public BasicComponentCreateService constructService(ComponentConfiguration configuration) {\n        if (this.ejbJarConfiguration == null) {\n            throw MESSAGES.ejbJarConfigNotBeenSet(this,configuration.getComponentName());\n        }\n        return new StatelessSessionComponentCreateService(configuration, this.ejbJarConfiguration);\n    }","id":80655,"modified_method":"@Override\n    public BasicComponentCreateService constructService(ComponentConfiguration configuration) {\n        if (this.ejbJarConfiguration == null) {\n            throw MESSAGES.ejbJarConfigNotBeenSet(this,configuration.getComponentName());\n        }\n        configuration.getCreateDependencies().add(new DependencyConfigurator<StatelessSessionComponentCreateService>() {\n            @Override\n            public void configureDependency(ServiceBuilder<?> builder, StatelessSessionComponentCreateService service) throws DeploymentUnitProcessingException {\n                if (service.getClustering() != null) {\n                    // This ensures that the client mappings cache is started\n                    builder.addDependency(CacheFactoryService.DEFAULT_CLUSTERED_SFSB_CACHE_SERVICE_NAME);\n                }\n            }\n        });\n        return new StatelessSessionComponentCreateService(configuration, this.ejbJarConfiguration);\n    }","commit_id":"d64c97921ae9507a97b7f5aa4795bc8400d1c3ce","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment1() {\n        Archive<?> archive = createDeployment();\n        return archive;\n    }","id":80656,"modified_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment1() {\n        return createDeployment();\n    }","commit_id":"c9ca688e25c71a061e15523077944ca1b889e19b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment0() {\n        Archive<?> archive = createDeployment();\n        return archive;\n    }","id":80657,"modified_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment0() {\n        return createDeployment();\n    }","commit_id":"c9ca688e25c71a061e15523077944ca1b889e19b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Nullable\n  private Rectangle getLineRendererRectangle(RangeHighlighter highlighter) {\n    LineMarkerRenderer renderer = highlighter.getLineMarkerRenderer();\n    if (renderer == null) return null;\n\n    int startOffset = highlighter.getStartOffset();\n    int endOffset = highlighter.getEndOffset();\n    if (myEditor.getFoldingModel().isOffsetCollapsed(startOffset) &&\n        myEditor.getFoldingModel().isOffsetCollapsed(endOffset)) {\n      return null;\n    }\n\n    int startY = myEditor.visualPositionToXY(myEditor.offsetToVisualPosition(startOffset)).y;\n\n    // top edge of the last line of the highlighted area\n    int endY = myEditor.visualPositionToXY(myEditor.offsetToVisualPosition(endOffset)).y;\n    // => add one line height to make height correct (bottom edge of the highlighted area)\n    DocumentEx document = myEditor.getDocument();\n    if (document.getLineStartOffset(document.getLineNumber(endOffset)) != endOffset) {\n      // but if the highlighter ends with the end of line, its line number is the next line, but that line should not be highlighted\n      endY += myEditor.getLineHeight();\n    }\n\n    int height = endY - startY;\n    int w = FREE_PAINTERS_AREA_WIDTH;\n    int x = getLineMarkerAreaOffset() + myIconsAreaWidth - 1;\n    return new Rectangle(x, startY, w, height);\n  }","id":80658,"modified_method":"@Nullable\n  private Rectangle getLineRendererRectangle(RangeHighlighter highlighter) {\n    LineMarkerRenderer renderer = highlighter.getLineMarkerRenderer();\n    if (renderer == null) return null;\n\n    int startOffset = highlighter.getStartOffset();\n    int endOffset = highlighter.getEndOffset();\n\n    FoldRegion startFoldRegion = myEditor.getFoldingModel().getCollapsedRegionAtOffset(startOffset);\n    FoldRegion endFoldRegion = myEditor.getFoldingModel().getCollapsedRegionAtOffset(endOffset);\n    if (startFoldRegion != null && endFoldRegion != null && startFoldRegion.equals(endFoldRegion)) {\n      return null;\n    }\n\n    int startY = myEditor.visualPositionToXY(myEditor.offsetToVisualPosition(startOffset)).y;\n\n    // top edge of the last line of the highlighted area\n    int endY = myEditor.visualPositionToXY(myEditor.offsetToVisualPosition(endOffset)).y;\n    // => add one line height to make height correct (bottom edge of the highlighted area)\n    DocumentEx document = myEditor.getDocument();\n    if (document.getLineStartOffset(document.getLineNumber(endOffset)) != endOffset) {\n      // but if the highlighter ends with the end of line, its line number is the next line, but that line should not be highlighted\n      endY += myEditor.getLineHeight();\n    }\n\n    int height = endY - startY;\n    int w = FREE_PAINTERS_AREA_WIDTH;\n    int x = getLineMarkerAreaOffset() + myIconsAreaWidth - 1;\n    return new Rectangle(x, startY, w, height);\n  }","commit_id":"15903abecd46bf010d26075a2179e3d05c010e34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void populateMessageContext(MessageContext msgContext,\n                                        UMOEventContext context,\n                                        UMOEndpointURI endpointUri) throws AxisFault, ConfigurationException\n    {\n        UMOMessage msg = context.getMessage();\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"MessageContext:\" + msgContext);\n            logger.debug(\"HEADER_CONTENT_TYPE:\"\n                            + msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null));\n            logger.debug(\"HEADER_CONTENT_LOCATION:\"\n                            + msg.getStringProperty(HttpConstants.HEADER_CONTENT_LOCATION, null));\n            logger.debug(\"Constants.MC_HOME_DIR:\" + String.valueOf(getHomeDir()));\n            logger.debug(\"Constants.MC_RELATIVE_PATH:\" + endpointUri.getPath());\n            logger.debug(\"HTTPConstants.HEADER_AUTHORIZATION:\" + msg.getStringProperty(\"Authorization\", null));\n            logger.debug(\"Constants.MC_REMOTE_ADDR:\" + endpointUri.getHost());\n        }\n\n        msgContext.setTransportName(transportName);\n        msgContext.setProperty(\"home.dir\", getHomeDir());\n        msgContext.setProperty(\"path\", endpointUri.getPath());\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLET, this);\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETLOCATION, endpointUri.getPath());\n        // determine service name\n        String serviceName = getServiceName(context, endpointUri);\n        // Validate Service path against request path\n        SOAPService service = msgContext.getAxisEngine().getConfig().getService(\n            new QName(serviceName.substring(1)));\n\n        // Component Name is set by Mule so if its null we can skip this check\n        if (service.getOption(AxisConnector.SERVICE_PROPERTY_COMPONENT_NAME) != null)\n        {\n            String servicePath = (String)service.getOption(\"servicePath\");\n            if (StringUtils.isEmpty(endpointUri.getPath()))\n            {\n                if (!(\"/\" + endpointUri.getAddress()).startsWith(servicePath + serviceName))\n                {\n                    throw new AxisFault(\"Failed to find service: \" + \"/\" + endpointUri.getAddress());\n                }\n            }\n            else if (!endpointUri.getPath().startsWith(servicePath + serviceName))\n            {\n                throw new AxisFault(\"Failed to find service: \" + endpointUri.getPath());\n            }\n        }\n\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETPATHINFO, serviceName);\n        msgContext.setProperty(\"serviceName\", serviceName);\n\n        msgContext.setProperty(\"Authorization\", msg.getStringProperty(\"Authorization\", null));\n        msgContext.setProperty(\"remoteaddr\", endpointUri.getHost());\n        ServletEndpointContextImpl sec = new ServletEndpointContextImpl();\n        msgContext.setProperty(\"servletEndpointContext\", sec);\n    }","id":80659,"modified_method":"private void populateMessageContext(MessageContext msgContext,\n                                        UMOEventContext context,\n                                        UMOEndpointURI endpointUri) throws AxisFault, ConfigurationException\n    {\n        UMOMessage msg = context.getMessage();\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"MessageContext:\" + msgContext);\n            logger.debug(\"HEADER_CONTENT_TYPE:\"\n                            + msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null));\n            logger.debug(\"HEADER_CONTENT_LOCATION:\"\n                            + msg.getStringProperty(HttpConstants.HEADER_CONTENT_LOCATION, null));\n            logger.debug(\"Constants.MC_HOME_DIR:\" + String.valueOf(getHomeDir()));\n            logger.debug(\"Constants.MC_RELATIVE_PATH:\" + endpointUri.getPath());\n            logger.debug(\"HTTPConstants.HEADER_AUTHORIZATION:\" + msg.getStringProperty(\"Authorization\", null));\n            logger.debug(\"Constants.MC_REMOTE_ADDR:\" + endpointUri.getHost());\n        }\n\n        msgContext.setTransportName(transportName);\n        msgContext.setProperty(\"home.dir\", getHomeDir());\n        msgContext.setProperty(\"path\", endpointUri.getPath());\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLET, this);\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETLOCATION, endpointUri.getPath());\n        // determine service name\n        String serviceName = getServiceName(context, endpointUri);\n        // Validate Service path against request path\n        SOAPService service = msgContext.getAxisEngine().getConfig().getService(\n            new QName(serviceName.substring(1)));\n\n        // if using jms or vm we can skip this\n        if (!(\"vm\".equalsIgnoreCase(endpointUri.getScheme()) || \"jms\".equalsIgnoreCase(endpointUri.getScheme())))\n        {            \n            // Component Name is set by Mule so if its null we can skip this check\n            if (service.getOption(AxisConnector.SERVICE_PROPERTY_COMPONENT_NAME) != null)\n            {\n                String servicePath = (String)service.getOption(\"servicePath\");\n                if (StringUtils.isEmpty(endpointUri.getPath()))\n                {\n                    if (!(\"/\" + endpointUri.getAddress()).startsWith(servicePath + serviceName))\n                    {\n                        throw new AxisFault(\"Failed to find service: \" + \"/\" + endpointUri.getAddress());\n                    }\n                }\n                else if (!endpointUri.getPath().startsWith(servicePath + serviceName))\n                {\n                    throw new AxisFault(\"Failed to find service: \" + endpointUri.getPath());\n                }\n            }\n        }\n\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETPATHINFO, serviceName);\n        msgContext.setProperty(\"serviceName\", serviceName);\n\n        msgContext.setProperty(\"Authorization\", msg.getStringProperty(\"Authorization\", null));\n        msgContext.setProperty(\"remoteaddr\", endpointUri.getHost());\n        ServletEndpointContextImpl sec = new ServletEndpointContextImpl();\n        msgContext.setProperty(\"servletEndpointContext\", sec);\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSendComplexType() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        UMOMessage result = client.send(\"vm://inbound\", new MuleMessage(new Person(\"Jane\", \"Doe\")));\n        assertNotNull(result.getPayload());\n        assertTrue(result.getPayload() instanceof Boolean);\n        assertTrue(((Boolean) result.getPayload()).booleanValue());\n    }","id":80660,"modified_method":"public void testSendComplexType() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        UMOMessage result = client.send(\"xfireEndpoint\", new MuleMessage(new Person(\"Jane\", \"Doe\")));\n        assertNotNull(result.getPayload());\n        assertTrue(result.getPayload() instanceof PersonResponse);\n        assertTrue(((PersonResponse)result.getPayload()).getPerson().getFirstName().equalsIgnoreCase(\"Jane\"));\n        // call this just to be sure it doesn't throw an exception\n        ((PersonResponse)result.getPayload()).getTime();\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void invoke(MessageContext msgContext) throws AxisFault\n    {\n        boolean sync = true;\n        Call call = (Call)msgContext.getProperty(\"call_object\");\n        if (call == null)\n        {\n            throw new IllegalStateException(\n                \"The call_object property must be set on the message context to the client Call object\");\n        }\n        if (Boolean.TRUE.equals(call.getProperty(\"axis.one.way\")))\n        {\n            sync = false;\n        }\n        // Get the event stored in call\n        // If a receive call is made there will be no event\n        // UMOEvent event =\n        // (UMOEvent)call.getProperty(MuleProperties.MULE_EVENT_PROPERTY);\n        // Get the dispatch endpoint\n        String uri = msgContext.getStrProp(MessageContext.TRANS_URL);\n        UMOImmutableEndpoint requestEndpoint = (UMOImmutableEndpoint)call\n            .getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY);\n        UMOManagementContext context = requestEndpoint.getManagementContext();\n        if (context == null)\n        {\n            throw new IllegalArgumentException(\"management context is null\");\n        }\n        \n        UMOImmutableEndpoint endpoint;\n\n        // put username and password in URI if they are set on the current event\n        if (msgContext.getUsername() != null)\n        {\n            String[] tempEndpoint = uri.split(\"//\");\n            String credentialString = msgContext.getUsername() + \":\"\n                                      + msgContext.getPassword();\n            uri = tempEndpoint[0] + \"//\" + credentialString + \"@\" + tempEndpoint[1];\n            try\n            {\n                endpoint = lookupEndpoint(uri);\n            }\n            catch (UMOException e)\n            {\n                requestEndpoint.getConnector().handleException(e);\n                return;\n            }\n        }\n        else\n        {\n            try\n            {\n                endpoint = lookupEndpoint(uri);\n            }\n            catch (UMOException e)\n            {\n                requestEndpoint.getConnector().handleException(e);\n                return;\n            }\n        }\n\n        try\n        {\n            if (requestEndpoint.getConnector() instanceof AxisConnector)\n            {\n                msgContext.setTypeMappingRegistry(((AxisConnector)requestEndpoint.getConnector())\n                    .getAxisServer().getTypeMappingRegistry());\n            }\n            Object payload = null;\n            int contentLength = 0;\n            if (msgContext.getRequestMessage().countAttachments() > 0)\n            {\n                File temp = File.createTempFile(\"soap\", \".tmp\");\n                temp.deleteOnExit(); // TODO cleanup files earlier (IOUtils has a\n                // file tracker)\n                FileOutputStream fos = new FileOutputStream(temp);\n                msgContext.getRequestMessage().writeTo(fos);\n                fos.close();\n                contentLength = (int)temp.length();\n                payload = new FileInputStream(temp);\n            }\n            else\n            {\n                ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);\n                msgContext.getRequestMessage().writeTo(baos);\n                baos.close();\n                payload = baos.toByteArray();\n            }\n\n            Map props = new HashMap();\n            // props.putAll(event.getProperties());\n            for (Iterator iterator = msgContext.getPropertyNames(); iterator.hasNext();)\n            {\n                String name = (String)iterator.next();\n                if (!name.equals(\"call_object\") && !name.equals(\"wsdl.service\"))\n                {\n                    props.put(name, msgContext.getProperty(name));\n                }\n            }\n\n            // add all custom headers, filter out all mule headers (such as\n            // MULE_SESSION) except\n            // for MULE_USER header. Filter out other headers like \"soapMethods\" and\n            // MuleProperties.MULE_METHOD_PROPERTY and \"soapAction\"\n            // and also filter out any http related header\n            if ((RequestContext.getEvent() != null)\n                && (RequestContext.getEvent().getMessage() != null))\n            {\n                props = AxisCleanAndAddProperties.cleanAndAdd(RequestContext.getEventContext());\n            }\n\n            if (call.useSOAPAction())\n            {\n                uri = call.getSOAPActionURI();\n            }\n            props.put(\"SOAPAction\", uri);\n            if (contentLength > 0)\n            {\n                props.put(HttpConstants.HEADER_CONTENT_LENGTH, Integer.toString(contentLength)); // necessary\n                // for\n                // supporting\n                // httpclient\n            }\n\n            if (props.get(HttpConstants.HEADER_CONTENT_TYPE) == null)\n            {\n                props.put(HttpConstants.HEADER_CONTENT_TYPE, \"text/xml\");\n            }\n            UMOMessage message = new MuleMessage(payload, props);\n            UMOSession session = RequestContext.getEventContext().getSession();\n\n            logger.info(\"Making Axis soap request on: \" + uri);\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Soap request is:\\n\" + payload.toString());\n            }\n\n            if (sync)\n            {\n\n                // We need to rewrite the endpoint on the event to set the\n                // reomoteSync property\n//                MuleEndpoint syncEndpoint = new MuleEndpoint(dispatchEvent.getEndpoint());\n//                syncEndpoint.setRemoteSync(true);\n//                dispatchEvent = new MuleEvent(dispatchEvent.getMessage(), syncEndpoint,\n//                    dispatchEvent.getSession(), dispatchEvent.isSynchronous());\n//                UMOMessage result = session.sendEvent(dispatchEvent);\n                endpoint = new MuleEndpoint(endpoint);\n                UMOEvent dispatchEvent = new MuleEvent(message, endpoint, session, sync);\n                UMOMessage result = endpoint.send(dispatchEvent);\n\n                if (result != null)\n                {\n                    byte[] response = result.getPayloadAsBytes();\n                    Message responseMessage = new Message(response);\n                    msgContext.setResponseMessage(responseMessage);\n\n                }\n                else\n                {\n                    logger\n                        .warn(\"No response message was returned from synchronous call to: \" + uri);\n                }\n                // remove temp file created for streaming\n                if (payload instanceof File)\n                {\n                    ((File)payload).delete();\n                }\n            }\n            else\n            {\n                UMOEvent dispatchEvent = new MuleEvent(message, endpoint, session, sync);\n                endpoint.dispatch(dispatchEvent);\n            }\n        }\n        catch (AxisFault axisFault)\n        {\n            throw axisFault;\n        }\n        catch (Exception e)\n        {\n            throw new AxisFault(e.getMessage(), new Throwable(e));\n        }\n\n    }","id":80661,"modified_method":"public void invoke(MessageContext msgContext) throws AxisFault\n    {\n        boolean sync = true;\n        Call call = (Call)msgContext.getProperty(\"call_object\");\n        if (call == null)\n        {\n            throw new IllegalStateException(\n                \"The call_object property must be set on the message context to the client Call object\");\n        }\n        if (Boolean.TRUE.equals(call.getProperty(\"axis.one.way\")))\n        {\n            sync = false;\n        }\n        // Get the event stored in call\n        // If a receive call is made there will be no event\n        // UMOEvent event =\n        // (UMOEvent)call.getProperty(MuleProperties.MULE_EVENT_PROPERTY);\n        // Get the dispatch endpoint\n        String uri = msgContext.getStrProp(MessageContext.TRANS_URL);\n        UMOImmutableEndpoint requestEndpoint = (UMOImmutableEndpoint)call\n            .getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY);\n        UMOManagementContext context = requestEndpoint.getManagementContext();\n        if (context == null)\n        {\n            throw new IllegalArgumentException(\"management context is null\");\n        }\n        \n        UMOImmutableEndpoint endpoint;\n\n        // put username and password in URI if they are set on the current event\n        if (msgContext.getUsername() != null)\n        {\n            String[] tempEndpoint = uri.split(\"//\");\n            String credentialString = msgContext.getUsername() + \":\"\n                                      + msgContext.getPassword();\n            uri = tempEndpoint[0] + \"//\" + credentialString + \"@\" + tempEndpoint[1];\n            try\n            {\n                endpoint = lookupEndpoint(uri);\n            }\n            catch (UMOException e)\n            {\n                requestEndpoint.getConnector().handleException(e);\n                return;\n            }\n        }\n        else\n        {\n            try\n            {\n                endpoint = lookupEndpoint(uri);\n            }\n            catch (UMOException e)\n            {\n                requestEndpoint.getConnector().handleException(e);\n                return;\n            }\n        }\n\n        try\n        {\n            if (requestEndpoint.getConnector() instanceof AxisConnector)\n            {\n                msgContext.setTypeMappingRegistry(((AxisConnector)requestEndpoint.getConnector())\n                    .getAxisServer().getTypeMappingRegistry());\n            }\n            Object payload = null;\n            int contentLength = 0;\n            if (msgContext.getRequestMessage().countAttachments() > 0)\n            {\n                File temp = File.createTempFile(\"soap\", \".tmp\");\n                temp.deleteOnExit(); // TODO cleanup files earlier (IOUtils has a\n                // file tracker)\n                FileOutputStream fos = new FileOutputStream(temp);\n                msgContext.getRequestMessage().writeTo(fos);\n                fos.close();\n                contentLength = (int)temp.length();\n                payload = new FileInputStream(temp);\n            }\n            else\n            {\n                ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);\n                msgContext.getRequestMessage().writeTo(baos);\n                baos.close();\n                payload = baos.toByteArray();\n            }\n\n            Map props = new HashMap();\n            // props.putAll(event.getProperties());\n            for (Iterator iterator = msgContext.getPropertyNames(); iterator.hasNext();)\n            {\n                String name = (String)iterator.next();\n                if (!name.equals(\"call_object\") && !name.equals(\"wsdl.service\"))\n                {\n                    props.put(name, msgContext.getProperty(name));\n                }\n            }\n\n            // add all custom headers, filter out all mule headers (such as\n            // MULE_SESSION) except\n            // for MULE_USER header. Filter out other headers like \"soapMethods\" and\n            // MuleProperties.MULE_METHOD_PROPERTY and \"soapAction\"\n            // and also filter out any http related header\n            if ((RequestContext.getEvent() != null)\n                && (RequestContext.getEvent().getMessage() != null))\n            {\n                props = AxisCleanAndAddProperties.cleanAndAdd(RequestContext.getEventContext());\n            }\n            \n            // with jms and vm the default SOAPAction will result in the name of the endpoint, which we may not necessarily want. This should be set manually on the endpoint\n            String scheme = requestEndpoint.getEndpointURI().getScheme(); \n            if (!(\"vm\".equalsIgnoreCase(scheme) || \"jms\".equalsIgnoreCase(scheme)))\n            {\n                if (call.useSOAPAction())\n                {\n                    uri = call.getSOAPActionURI();\n                }\n                props.put(\"SOAPAction\", uri);\n            }\n            if (contentLength > 0)\n            {\n                props.put(HttpConstants.HEADER_CONTENT_LENGTH, Integer.toString(contentLength)); // necessary\n                // for\n                // supporting\n                // httpclient\n            }\n\n            if (props.get(HttpConstants.HEADER_CONTENT_TYPE) == null)\n            {\n                props.put(HttpConstants.HEADER_CONTENT_TYPE, \"text/xml\");\n            }\n            UMOMessage message = new MuleMessage(payload, props);\n            UMOSession session = RequestContext.getEventContext().getSession();\n\n            logger.info(\"Making Axis soap request on: \" + uri);\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Soap request is:\\n\" + payload.toString());\n            }\n\n            if (sync)\n            {\n\n                // We need to rewrite the endpoint on the event to set the\n                // reomoteSync property\n//                MuleEndpoint syncEndpoint = new MuleEndpoint(dispatchEvent.getEndpoint());\n//                syncEndpoint.setRemoteSync(true);\n//                dispatchEvent = new MuleEvent(dispatchEvent.getMessage(), syncEndpoint,\n//                    dispatchEvent.getSession(), dispatchEvent.isSynchronous());\n//                UMOMessage result = session.sendEvent(dispatchEvent);\n                endpoint = new MuleEndpoint(endpoint);\n                UMOEvent dispatchEvent = new MuleEvent(message, endpoint, session, sync);\n                UMOMessage result = endpoint.send(dispatchEvent);\n\n                if (result != null)\n                {\n                    byte[] response = result.getPayloadAsBytes();\n                    Message responseMessage = new Message(response);\n                    msgContext.setResponseMessage(responseMessage);\n\n                }\n                else\n                {\n                    logger\n                        .warn(\"No response message was returned from synchronous call to: \" + uri);\n                }\n                // remove temp file created for streaming\n                if (payload instanceof File)\n                {\n                    ((File)payload).delete();\n                }\n            }\n            else\n            {\n                UMOEvent dispatchEvent = new MuleEvent(message, endpoint, session, sync);\n                endpoint.dispatch(dispatchEvent);\n            }\n        }\n        catch (AxisFault axisFault)\n        {\n            throw axisFault;\n        }\n        catch (Exception e)\n        {\n            throw new AxisFault(e.getMessage(), new Throwable(e));\n        }\n\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public ExceptionCollectingThreadGroup()\n    {\n        super(\"asyncGroup\");\n    }","id":80662,"modified_method":"public ExceptionCollectingThreadGroup()\n    {\n        super(\"ExceptionCollectingThreadGroup\");\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public SleepyTask(String name, long sleepTime)\n    {\n        if (StringUtils.isEmpty(name))\n        {\n            throw new IllegalArgumentException(\"SleepyTask needs a name!\");\n        }\n\n        _name = name;\n        _sleepTime = sleepTime;\n    }","id":80663,"modified_method":"public SleepyTask(String name, long sleepTime)\n    {\n        if (StringUtils.isEmpty(name))\n        {\n            throw new IllegalArgumentException(\"SleepyTask needs a name!\");\n        }\n\n        this.name = name;\n        this.sleepTime = sleepTime;\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public String toString()\n    {\n        return ClassUtils.getClassName(this.getClass()) + \"{\" + _name + \", \" + _sleepTime + \"}\";\n    }","id":80664,"modified_method":"public String toString()\n    {\n        return this.getClass().getName() + '{' + name + \", \" + sleepTime + '}';\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public Runnable lastRejectedRunnable()\n    {\n        return _lastRejected;\n    }","id":80665,"modified_method":"public Runnable lastRejectedRunnable()\n    {\n        return _rejected;\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testWaitPolicyForever() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // wait forever\n        LastRejectedWaitPolicy policy = new LastRejectedWaitPolicy(-1, TimeUnit.SECONDS);\n        _executor.setRejectedExecutionHandler(policy);\n\n        // task 1 runs immediately\n        this.execute(new SleepyTask(\"hans\", 1000));\n\n        // task 2 is queued\n        this.execute(new SleepyTask(\"franz\", 1000));\n\n        // task 3 is initially rejected but waits forever\n        Runnable s3 = new SleepyTask(\"beavis\", 0);\n        this.execute(s3);\n\n        // at least one task should have been queued\n        assertFalse(_executor.awaitTermination(5000, TimeUnit.MILLISECONDS));\n        assertEquals(s3, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // shutdown & try again\n        _executor.shutdown();\n        assertTrue(_executor.awaitTermination(3000, TimeUnit.MILLISECONDS));\n        assertEquals(s3, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","id":80666,"modified_method":"public void testWaitPolicyForever() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // tasks wait forever\n        LastRejectedWaitPolicy policy = new LastRejectedWaitPolicy(-1, TimeUnit.SECONDS);\n        executor.setRejectedExecutionHandler(policy);\n\n        // create tasks\n        List tasks = new ArrayList();\n        // task 1 runs immediately\n        tasks.add(new SleepyTask(\"hans\", 1000));\n        // task 2 is queued\n        tasks.add(new SleepyTask(\"franz\", 1000));\n        // task 3 is initially rejected but waits forever\n        Runnable t3 = new SleepyTask(\"beavis\", 1000);\n        tasks.add(t3);\n\n        // submit tasks\n        LinkedList submitters = this.execute(tasks);\n        assertFalse(submitters.isEmpty());\n\n        // the last task should have been queued\n        assertFalse(executor.awaitTermination(4000, TimeUnit.MILLISECONDS));\n        assertSame(t3, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void uncaughtException(Thread t, Throwable e)\n    {\n        _exceptions.add(new DefaultMapEntry(t, e));\n    }","id":80667,"modified_method":"public void uncaughtException(Thread t, Throwable e)\n    {\n        synchronized (exceptions)\n        {\n            exceptions.add(Collections.singletonMap(t, e));\n        }\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run()\n    {\n        activeTasks.incrementAndGet();\n\n        try\n        {\n            Thread.sleep(_sleepTime);\n        }\n        catch (InterruptedException iex)\n        {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(iex);\n        }\n\n        activeTasks.decrementAndGet();\n    }","id":80668,"modified_method":"public void run()\n    {\n        activeTasks.incrementAndGet();\n\n        try\n        {\n            Thread.sleep(sleepTime);\n        }\n        catch (InterruptedException iex)\n        {\n            Thread.currentThread().interrupt();\n        }\n        finally\n        {\n            activeTasks.decrementAndGet();\n        }\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testWaitPolicyWithShutdownExecutor() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // wants to wait forever, but will fail immediately\n        _executor.setRejectedExecutionHandler(new LastRejectedWaitPolicy());\n        _executor.shutdown();\n\n        // must fail immediately\n        Thread failedThread = this.execute(new SleepyTask(\"boo\", 1000));\n        Thread.sleep(500);\n\n        List exceptions = _asyncGroup.collectedExceptions();\n        assertEquals(1, exceptions.size());\n\n        Map.Entry threadFailure = (Map.Entry)exceptions.iterator().next();\n        assertNotNull(threadFailure);\n        assertEquals(failedThread, threadFailure.getKey());\n        assertEquals(RejectedExecutionException.class, threadFailure.getValue().getClass());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","id":80669,"modified_method":"public void testWaitPolicyWithShutdownExecutor() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // wants to wait forever, but will fail immediately\n        executor.setRejectedExecutionHandler(new LastRejectedWaitPolicy());\n        executor.shutdown();\n\n        // create a task\n        List tasks = new ArrayList();\n        tasks.add(new SleepyTask(\"rejected\", 1000));\n\n        // should fail and return immediately\n        LinkedList submitters = this.execute(tasks);\n        assertFalse(submitters.isEmpty());\n\n        // let submitted tasks run\n        Thread.sleep(1000);\n\n        LinkedList exceptions = threadGroup.collectedExceptions();\n        assertEquals(1, exceptions.size());\n\n        Map.Entry threadFailure = (Map.Entry)((Map)(exceptions.getFirst())).entrySet().iterator().next();\n        assertEquals(submitters.getFirst(), threadFailure.getKey());\n        assertEquals(RejectedExecutionException.class, threadFailure.getValue().getClass());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testWaitPolicyWithTimeout() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // set a reasonable retry interval\n        LastRejectedWaitPolicy policy = new LastRejectedWaitPolicy(2500, TimeUnit.MILLISECONDS);\n        _executor.setRejectedExecutionHandler(policy);\n\n        // task 1 runs immediately\n        this.execute(new SleepyTask(\"hans\", 1000));\n\n        // 2 is queued\n        this.execute(new SleepyTask(\"franz\", 1000));\n\n        // 3 is initially rejected but will eventually succeed\n        Runnable s3 = new SleepyTask(\"tweety\", 1000);\n        this.execute(s3);\n\n        assertFalse(_executor.awaitTermination(5000, TimeUnit.MILLISECONDS));\n        assertEquals(s3, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","id":80670,"modified_method":"public void testWaitPolicyWithTimeout() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // set a reasonable retry interval\n        LastRejectedWaitPolicy policy = new LastRejectedWaitPolicy(2500, TimeUnit.MILLISECONDS);\n        executor.setRejectedExecutionHandler(policy);\n\n        // create tasks\n        List tasks = new ArrayList();\n        // task 1 runs immediately\n        tasks.add(new SleepyTask(\"hans\", 1000));\n        // task 2 is queued\n        tasks.add(new SleepyTask(\"franz\", 1000));\n        // task 3 is initially rejected but will eventually succeed\n        Runnable t3 = new SleepyTask(\"tweety\", 1000);\n        tasks.add(t3);\n\n        // submit tasks\n        LinkedList submitters = this.execute(tasks);\n        assertFalse(submitters.isEmpty());\n\n        assertFalse(executor.awaitTermination(5000, TimeUnit.MILLISECONDS));\n        assertSame(t3, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void rejectedExecution(Runnable r, ThreadPoolExecutor e)\n    {\n        _lastRejected = r;\n        super.rejectedExecution(r, e);\n    }","id":80671,"modified_method":"public void rejectedExecution(Runnable r, ThreadPoolExecutor e)\n    {\n        _rejected = r;\n        super.rejectedExecution(r, e);\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void _testWaitPolicyWithTimeoutFailure() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // set a really short wait interval\n        long failureInterval = 100;\n        LastRejectedWaitPolicy policy = new LastRejectedWaitPolicy(failureInterval, TimeUnit.MILLISECONDS);\n        _executor.setRejectedExecutionHandler(policy);\n\n        // task 1 runs immediately\n        this.execute(new SleepyTask(\"hans\", 1000));\n\n        // 2 is queued\n        this.execute(new SleepyTask(\"franz\", 1000));\n\n        // 3 is initially rejected & will retry but should fail quickly\n        Runnable s3 = new SleepyTask(\"butthead\", 1000);\n        Thread failedThread = this.execute(s3);\n        // give failure a chance\n        Thread.sleep(failureInterval * 2);\n\n        List exceptions = _asyncGroup.collectedExceptions();\n        assertEquals(1, exceptions.size());\n\n        Map.Entry threadFailure = (Map.Entry)exceptions.iterator().next();\n        assertNotNull(threadFailure);\n        assertEquals(failedThread, threadFailure.getKey());\n        assertEquals(RejectedExecutionException.class, threadFailure.getValue().getClass());\n\n        _executor.shutdown();\n        assertTrue(_executor.awaitTermination(2500, TimeUnit.MILLISECONDS));\n        assertEquals(s3, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","id":80672,"modified_method":"public void testWaitPolicyWithTimeoutFailure() throws Exception\n    {\n        assertEquals(0, SleepyTask.activeTasks.get());\n\n        // set a really short wait interval\n        long failureInterval = 100L;\n        LastRejectedWaitPolicy policy = new LastRejectedWaitPolicy(failureInterval, TimeUnit.MILLISECONDS);\n        executor.setRejectedExecutionHandler(policy);\n\n        // create tasks\n        List tasks = new ArrayList();\n        // task 1 runs immediately\n        tasks.add(new SleepyTask(\"hans\", 1000));\n        // task 2 is queued\n        tasks.add(new SleepyTask(\"franz\", 1000));\n        // task 3 is initially rejected & will retry but should fail quickly\n        Runnable failedTask = new SleepyTask(\"tweety\", 1000);\n        tasks.add(failedTask);\n\n        // submit tasks\n        LinkedList submitters = this.execute(tasks);\n        assertFalse(submitters.isEmpty());\n\n        // give failure a chance\n        Thread.sleep(failureInterval * 2);\n\n        LinkedList exceptions = threadGroup.collectedExceptions();\n        assertEquals(1, exceptions.size());\n\n        Map.Entry threadFailure = (Map.Entry)((Map)(exceptions.getFirst())).entrySet().iterator().next();\n        assertEquals(submitters.getLast(), threadFailure.getKey());\n        assertEquals(RejectedExecutionException.class, threadFailure.getValue().getClass());\n\n        executor.shutdown();\n        assertTrue(executor.awaitTermination(2500, TimeUnit.MILLISECONDS));\n        assertSame(failedTask, policy.lastRejectedRunnable());\n        assertEquals(0, SleepyTask.activeTasks.get());\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doTearDown() throws Exception\n    {\n        _executor.shutdown();\n        _asyncGroup.destroy();\n        super.doTearDown();\n    }","id":80673,"modified_method":"protected void doTearDown() throws Exception\n    {\n        executor.shutdown();\n        threadGroup.destroy();\n        super.doTearDown();\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"public List collectedExceptions()\n    {\n        return _exceptions;\n    }","id":80674,"modified_method":"public LinkedList collectedExceptions()\n    {\n        return exceptions;\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n\n        // allow 1 active & 1 queued Thread\n        _executor = new ThreadPoolExecutor(1, 1, 10000L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(1));\n        _executor.prestartAllCoreThreads();\n        // the lock must be fair to guarantee FIFO access to the executor;\n        // 'synchronized' on a monitor is not good enough.\n        _executorLock = new ReentrantLock(true);\n        _asyncGroup = new ExceptionCollectingThreadGroup();\n        SleepyTask.activeTasks = new AtomicInteger(0);\n    }","id":80675,"modified_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n\n        // allow 1 active & 1 queued Thread\n        executor = new ThreadPoolExecutor(1, 1, 10000L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(1));\n        executor.prestartAllCoreThreads();\n\n        // the lock must be fair to guarantee FIFO access to the executor;\n        // 'synchronized' on a monitor is not good enough.\n        executorLock = new ReentrantLock(true);\n\n        // this is a Threadgroup that collects uncaught exceptions. Necessary for JDK\n        // 1.4.x only.\n        threadGroup = new ExceptionCollectingThreadGroup();\n\n        // reset counter of active SleepyTasks\n        SleepyTask.activeTasks.set(0);\n    }","commit_id":"50baaf2636100fbda37ca9e2597cc780eb0991c0","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Map<String, Object> getCamelContextInformation(String camelContextName) throws Exception {\n        if (jolokia == null) {\n            throw new IllegalStateException(\"Need to connect to remote jolokia first\");\n        }\n\n        Map<String, Object> answer = new LinkedHashMap<String, Object>();\n\n        ObjectName found = lookupCamelContext(camelContextName);\n        if (found != null) {\n            J4pReadResponse rr = jolokia.execute(new J4pReadRequest(found));\n            if (rr != null) {\n                for (String key : rr.getAttributes()) {\n                    answer.put(asKey(key), rr.getValue(key));\n                }\n            }\n\n            // store some data using special names as that is what the core-commands expects\n            answer.put(\"name\", answer.get(\"camelId\"));\n            answer.put(\"status\", answer.get(\"state\"));\n            answer.put(\"version\", answer.get(\"camelVersion\"));\n            answer.put(\"suspended\", \"Suspended\".equals(answer.get(\"state\")));\n            TimeUnit unit = TimeUnit.valueOf((String) answer.get(\"timeUnit\"));\n            long timeout = (Long) answer.get(\"timeout\");\n            answer.put(\"shutdownTimeout\", \"\" + unit.toSeconds(timeout));\n            answer.put(\"applicationContextClassLoader\", answer.get(\"applicationContextClassName\"));\n        }\n\n        return answer;\n    }","id":80676,"modified_method":"@Override\n    public Map<String, Object> getCamelContextInformation(String camelContextName) throws Exception {\n        if (jolokia == null) {\n            throw new IllegalStateException(\"Need to connect to remote jolokia first\");\n        }\n\n        // org.apache.camel:context=camel-1,type=services,name=DefaultTypeConverter\n\n        Map<String, Object> answer = new LinkedHashMap<String, Object>();\n\n        ObjectName found = lookupCamelContext(camelContextName);\n        if (found != null) {\n\n            String pattern = String.format(\"%s:context=%s,type=services,name=DefaultTypeConverter\", found.getDomain(), found.getKeyProperty(\"context\"));\n            ObjectName tc = ObjectName.getInstance(pattern);\n\n            List<J4pReadRequest> list = new ArrayList<>();\n            list.add(new J4pReadRequest(found));\n            list.add(new J4pReadRequest(tc));\n\n            List<J4pReadResponse> rr = jolokia.execute(list);\n            if (rr != null && rr.size() > 0) {\n                // camel context attributes\n                J4pReadResponse first = rr.get(0);\n                for (String key : first.getAttributes()) {\n                    answer.put(asKey(key), first.getValue(key));\n                }\n\n                // type converter attributes\n                if (rr.size() == 2) {\n                    J4pReadResponse second = rr.get(1);\n                    for (String key : second.getAttributes()) {\n\n                        answer.put(\"typeConverter.\" + asKey(key), second.getValue(key));\n                    }\n                }\n\n                // store some data using special names as that is what the core-commands expects\n                answer.put(\"name\", answer.get(\"camelId\"));\n                answer.put(\"status\", answer.get(\"state\"));\n                answer.put(\"version\", answer.get(\"camelVersion\"));\n                answer.put(\"suspended\", \"Suspended\".equals(answer.get(\"state\")));\n                TimeUnit unit = TimeUnit.valueOf((String) answer.get(\"timeUnit\"));\n                long timeout = (Long) answer.get(\"timeout\");\n                answer.put(\"shutdownTimeout\", \"\" + unit.toSeconds(timeout));\n                answer.put(\"applicationContextClassLoader\", answer.get(\"applicationContextClassName\"));\n            }\n        }\n\n        return answer;\n    }","commit_id":"9544da824cee97e9190b1847055d55c7533a80f6","url":"https://github.com/apache/camel"},{"original_method":"public static CountsSnapshot deserialize( ReadableLogChannel channel ) throws UnknownKey, IOException\n    {\n        long txid = channel.getLong();\n        int size = channel.getInt();\n\n        Map<CountsKey,long[]> map = new ConcurrentHashMap<>( size );\n        CountsKey key;\n        long[] value;\n        for ( int i = 0; i < size; i++ )\n        {\n            CountsKeyType type = value( channel.get() );\n            switch ( type )\n            {\n\n            case ENTITY_NODE:\n                key = nodeKey( channel.getInt() );\n                value = new long[]{channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case ENTITY_RELATIONSHIP:\n                int startLabelId = channel.getInt();\n                int typeId = channel.getInt();\n                int endLabelId = channel.getInt();\n                key = relationshipKey( startLabelId, typeId, endLabelId );\n                value = new long[]{channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case INDEX_SAMPLE:\n                key = indexSampleKey( channel.getInt(), channel.getInt() );\n                value = new long[]{channel.getLong(), channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case INDEX_STATISTICS:\n                key = indexStatisticsKey( channel.getInt(), channel.getInt() );\n                value = new long[]{channel.getLong(), channel.getLong()};\n                map.put( key, value );\n                break;\n            }\n        }\n        return new CountsSnapshot( txid, map );\n    }","id":80677,"modified_method":"public static CountsSnapshot deserialize( ReadableLogChannel channel ) throws IOException, UnknownKey\n    {\n        long txid = channel.getLong();\n        int size = channel.getInt();\n\n        Map<CountsKey,long[]> map = new ConcurrentHashMap<>( size );\n        CountsKey key;\n        long[] value;\n        for ( int i = 0; i < size; i++ )\n        {\n            CountsKeyType type = value( channel.get() );\n            switch ( type )\n            {\n            case ENTITY_NODE:\n                key = nodeKey( channel.getInt() );\n                value = new long[]{channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case ENTITY_RELATIONSHIP:\n                int startLabelId = channel.getInt();\n                int typeId = channel.getInt();\n                int endLabelId = channel.getInt();\n                key = relationshipKey( startLabelId, typeId, endLabelId );\n                value = new long[]{channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case INDEX_SAMPLE:\n                key = indexSampleKey( channel.getInt(), channel.getInt() );\n                value = new long[]{channel.getLong(), channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case INDEX_STATISTICS:\n                key = indexStatisticsKey( channel.getInt(), channel.getInt() );\n                value = new long[]{channel.getLong(), channel.getLong()};\n                map.put( key, value );\n                break;\n\n            case EMPTY:\n                throw new IllegalArgumentException( \"CountsKey of type EMPTY cannot be deserialized.\" );\n\n            default:\n                throw new IllegalArgumentException( \"The read CountsKey has an unknown type.\" );\n            }\n        }\n        return new CountsSnapshot( txid, map );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void serialize( WritableLogChannel channel, CountsSnapshot countsSnapshot )\n            throws UnknownKey, IOException\n    {\n        channel.putLong( countsSnapshot.getTxId() );\n        channel.putInt( countsSnapshot.getMap().size() );\n\n        for ( Map.Entry<CountsKey,long[]> pair : countsSnapshot.getMap().entrySet() )\n        {\n            CountsKey key = pair.getKey();\n            long[] value = pair.getValue();\n\n            switch ( key.recordType() )\n            {\n\n            case ENTITY_NODE:\n                assert value.length == 1;\n                NodeKey nodeKey = (NodeKey) key;\n                channel.put( ENTITY_NODE.code );\n                channel.putInt( nodeKey.getLabelId() );\n                channel.putLong( value[0] );\n                break;\n\n            case ENTITY_RELATIONSHIP:\n                assert value.length == 1;\n                RelationshipKey relationshipKey = (RelationshipKey) key;\n                channel.put( ENTITY_RELATIONSHIP.code );\n                channel.putInt( relationshipKey.getStartLabelId() );\n                channel.putInt( relationshipKey.getTypeId() );\n                channel.putInt( relationshipKey.getEndLabelId() );\n                channel.putLong( value[0] );\n                break;\n\n            case INDEX_SAMPLE:\n                assert value.length == 2;\n                IndexSampleKey indexSampleKey = (IndexSampleKey) key;\n                channel.put( INDEX_SAMPLE.code );\n                channel.putInt( indexSampleKey.labelId() );\n                channel.putInt( indexSampleKey.propertyKeyId() );\n                channel.putLong( value[0] );\n                channel.putLong( value[1] );\n                break;\n\n            case INDEX_STATISTICS:\n                assert value.length == 2;\n                IndexStatisticsKey indexStatisticsKey = (IndexStatisticsKey) key;\n                channel.put( INDEX_STATISTICS.code );\n                channel.putInt( indexStatisticsKey.labelId() );\n                channel.putInt( indexStatisticsKey.propertyKeyId() );\n                channel.putLong( value[0] );\n                channel.putLong( value[1] );\n                break;\n\n            }\n        }\n    }","id":80678,"modified_method":"public static void serialize( WritableLogChannel channel, CountsSnapshot countsSnapshot )\n            throws UnknownKey, IOException\n    {\n        channel.putLong( countsSnapshot.getTxId() );\n        channel.putInt( countsSnapshot.getMap().size() );\n\n        for ( Map.Entry<CountsKey,long[]> pair : countsSnapshot.getMap().entrySet() )\n        {\n            CountsKey key = pair.getKey();\n            long[] value = pair.getValue();\n\n            switch ( key.recordType() )\n            {\n\n            case ENTITY_NODE:\n                if ( value.length != 1 )\n                {\n                    throw new IllegalArgumentException(\n                            \"CountsKey of type \" + key.recordType() + \" has an unexpected value.\" );\n                }\n                NodeKey nodeKey = (NodeKey) key;\n                channel.put( ENTITY_NODE.code );\n                channel.putInt( nodeKey.getLabelId() );\n                channel.putLong( value[0] );\n                break;\n\n            case ENTITY_RELATIONSHIP:\n                if ( value.length != 1 )\n                {\n                    throw new IllegalArgumentException(\n                            \"CountsKey of type \" + key.recordType() + \" has an unexpected value.\" );\n                }\n                RelationshipKey relationshipKey = (RelationshipKey) key;\n                channel.put( ENTITY_RELATIONSHIP.code );\n                channel.putInt( relationshipKey.getStartLabelId() );\n                channel.putInt( relationshipKey.getTypeId() );\n                channel.putInt( relationshipKey.getEndLabelId() );\n                channel.putLong( value[0] );\n                break;\n\n            case INDEX_SAMPLE:\n                if ( value.length != 2 )\n                {\n                    throw new IllegalArgumentException(\n                            \"CountsKey of type \" + key.recordType() + \" has an unexpected value.\" );\n                }\n                IndexSampleKey indexSampleKey = (IndexSampleKey) key;\n                channel.put( INDEX_SAMPLE.code );\n                channel.putInt( indexSampleKey.labelId() );\n                channel.putInt( indexSampleKey.propertyKeyId() );\n                channel.putLong( value[0] );\n                channel.putLong( value[1] );\n                break;\n\n            case INDEX_STATISTICS:\n                if ( value.length != 2 )\n                {\n                    throw new IllegalArgumentException(\n                            \"CountsKey of type \" + key.recordType() + \" has an unexpected value.\" );\n                }\n                IndexStatisticsKey indexStatisticsKey = (IndexStatisticsKey) key;\n                channel.put( INDEX_STATISTICS.code );\n                channel.putInt( indexStatisticsKey.labelId() );\n                channel.putInt( indexStatisticsKey.propertyKeyId() );\n                channel.putLong( value[0] );\n                channel.putLong( value[1] );\n                break;\n\n            case EMPTY:\n                throw new IllegalArgumentException( \"CountsKey of type EMPTY cannot be serialized.\" );\n\n            default:\n                throw new IllegalArgumentException( \"The read CountsKey has an unknown type.\" );\n            }\n        }\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static HashMap<CountsKey,long[]> copyOfMap( Map<CountsKey,long[]> nextMap )\n    {\n        HashMap<CountsKey,long[]> newMap = new HashMap<>();\n        nextMap.forEach( ( key, value ) -> newMap.put( key, Arrays.copyOf( value, value.length ) ) );\n        return newMap;\n    }","id":80679,"modified_method":"/**\n     * This is essentially a deep copy of a map, necessary since our values in the map are long arrays. The crucial\n     * part is the Arrays.copyOf() for the value.\n     */\n    private static Map<CountsKey,long[]> copyOfMap( Map<CountsKey,long[]> mapToCopy )\n    {\n        ConcurrentHashMap<CountsKey,long[]> newMap = new ConcurrentHashMap<>();\n        mapToCopy.forEach( ( key, value ) -> newMap.put( key, Arrays.copyOf( value, value.length ) ) );\n        return newMap;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InMemoryCountsStore()\n    {\n        this( new CountsSnapshot( 0, new ConcurrentHashMap<>() ) );\n    }","id":80680,"modified_method":"public InMemoryCountsStore()\n    {\n        map = new ConcurrentHashMap<>();\n        lastTxId.set( 0, EMPTY_METADATA );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void applyUpdates( Map<CountsKey,long[]> updates, Map<CountsKey,long[]> map )\n    {\n        updates.forEach(\n                ( key, value ) -> map.compute( key, ( k, v ) -> v == null ? value : updateEachValue( v, value ) ) );\n    }","id":80681,"modified_method":"/**\n     *  For each key in the updates param, applies it's value as a diff to the cooresponding value in the given map.\n     * @param updates A map containing the diffs to apply to the corresponding values in the map.\n     * @param map The map to be updated.\n     */\n    private void applyUpdates( Map<CountsKey,long[]> updates, Map<CountsKey,long[]> map )\n    {\n        updates.forEach( ( key, value ) -> map.compute( key, ( k, v ) -> {\n            if ( v == null )\n            {\n                return Arrays.copyOf( value, value.length );\n            }\n            else\n            {\n                return updateEachValue( v, value );\n            }\n        } ) );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * This method is thread safe w.r.t updates to the countstore, but not for performing concurrent snapshots.\n     */\n    @Override\n    public CountsSnapshot snapshot( long txId )\n    {\n        if ( snapshot != null )\n        {\n            throw new IllegalStateException( \"Cannot perform snapshot while another snapshot is processing.\" );\n        }\n\n        lock.writeLock().lock();\n        try\n        {\n            snapshot = new CountsSnapshot( Math.max( txId, lastTxId.highestEverSeen() ),\n                    InMemoryCountsStore.copyOfMap( this.map ) );\n        }\n        finally\n        {\n            lock.writeLock().unlock();\n        }\n\n        try\n        {\n            Predicates\n                    .awaitForever( () -> lastTxId.getHighestGapFreeNumber() >= snapshot.getTxId(), 100, MILLISECONDS );\n            return snapshot;\n        }\n        catch ( InterruptedException ex )\n        {\n            throw Exceptions\n                    .withCause( new UnderlyingStorageException( \"Construction of snapshot was interrupted.\" ), ex );\n        }\n        finally\n        {\n            snapshot = null;\n        }\n    }","id":80682,"modified_method":"/**\n     * This method is thread safe w.r.t updates to the countstore, but not for performing concurrent snapshots.\n     */\n    @Override\n    public CountsSnapshot snapshot( long txId )\n    {\n        if ( snapshot != null )\n        {\n            throw new IllegalStateException( \"Cannot perform snapshot while another snapshot is processing.\" );\n        }\n\n        lock.writeLock().lock();\n        try\n        {\n            long snapshotTxId = Math.max( txId, lastTxId.highestEverSeen() );\n            snapshot = new CountsSnapshot( snapshotTxId, copyOfMap( this.map ) );\n        }\n        finally\n        {\n            lock.writeLock().unlock();\n        }\n\n        try\n        {\n            //TODO We should NOT blindly wait forever. We also shouldn't have a timeout. The proposed solution is to\n            // wait forever unless the database has failed in the background. In that case we want to fail as well.\n            // This will allow us to not timeout prematurely but also not hang when the database is broken.\n            awaitForever( () -> lastTxId.getHighestGapFreeNumber() >= snapshot.getTxId(), 100, MILLISECONDS );\n            return snapshot;\n        }\n        catch ( InterruptedException ex )\n        {\n            Thread.currentThread().interrupt();\n            throw Exceptions\n                    .withCause( new UnderlyingStorageException( \"Construction of snapshot was interrupted.\" ), ex );\n        }\n        finally\n        {\n            snapshot = null;\n        }\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InMemoryCountsStore( CountsSnapshot snapshot )\n    {\n        map = new ConcurrentHashMap<>( snapshot.getMap() );\n        lastTxId = new ArrayQueueOutOfOrderSequence( 0L, 100, EMPTY_METADATA );\n        lastTxId.set( snapshot.getTxId(), EMPTY_METADATA );\n        lock = new ReentrantReadWriteLock();\n    }","id":80683,"modified_method":"public InMemoryCountsStore( CountsSnapshot snapshot )\n    {\n        map = new ConcurrentHashMap<>( snapshot.getMap() );\n        lastTxId.set( snapshot.getTxId(), EMPTY_METADATA );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private long[] updateEachValue( long[] v, long[] value )\n    {\n        for ( int i = 0; i < v.length; i++ )\n        {\n            v[i] = v[i] + value[i];\n        }\n        return v;\n    }","id":80684,"modified_method":"/**\n     * Because IndexSampleKey and IndexStatisticsKey have 2 values and NodeKey and RelationshipKey have only 1 value,\n     * these keys are stored in the same map by making the value an array of longs. Therefore, when applying the diff\n     * to the keys values, this loop works for keys of both types. In the future, we should separate the values in\n     * IndexSample and IndexStatistics into multiple keys each with one value.\n     */\n    private long[] updateEachValue( long[] v, long[] value )\n    {\n        for ( int i = 0; i < v.length; i++ )\n        {\n            v[i] = v[i] + value[i];\n        }\n        return v;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void smallWorkloadOnInMemoryLogTest() throws IOException, UnknownKey\n    {\n        //GIVEN\n        InMemoryLogChannel tempChannel = new InMemoryLogChannel();\n        Map<CountsKey,long[]> map = CountsStoreMapGenerator.simpleCountStoreMap( 1 );\n        CountsSnapshot countsSnapshot = new CountsSnapshot( 1, map );\n\n        //WHEN\n        serialize( tempChannel, countsSnapshot );\n        CountsSnapshot recovered = deserialize( tempChannel );\n\n        //THEN\n        Assert.assertEquals( countsSnapshot.getTxId(), recovered.getTxId() );\n        for ( Map.Entry<CountsKey,long[]> pair : countsSnapshot.getMap().entrySet() )\n        {\n            long[] value = recovered.getMap().get( pair.getKey() );\n            Assert.assertNotNull( value );\n            Assert.assertTrue( Arrays.equals( value, pair.getValue() ) );\n        }\n\n        for ( Map.Entry<CountsKey,long[]> pair : recovered.getMap().entrySet() )\n        {\n            long[] value = countsSnapshot.getMap().get( pair.getKey() );\n            Assert.assertNotNull( value );\n            Assert.assertTrue( Arrays.equals( value, pair.getValue() ) );\n        }\n    }","id":80685,"modified_method":"@Test\n    public void smallWorkloadOnInMemoryLogTest() throws IOException, UnknownKey\n    {\n        //GIVEN\n        InMemoryLogChannel tempChannel = new InMemoryLogChannel();\n        Map<CountsKey,long[]> map = CountsStoreMapGenerator.simpleCountStoreMap( 1 );\n        CountsSnapshot countsSnapshot = new CountsSnapshot( 1, map );\n\n        //WHEN\n        serialize( tempChannel, countsSnapshot );\n        CountsSnapshot recovered = deserialize( tempChannel );\n\n        //THEN\n        Assert.assertEquals( countsSnapshot.getTxId(), recovered.getTxId() );\n        for ( Map.Entry<CountsKey,long[]> pair : countsSnapshot.getMap().entrySet() )\n        {\n            long[] value = recovered.getMap().get( pair.getKey() );\n            Assert.assertNotNull( value );\n            Assert.assertArrayEquals( value, pair.getValue() );\n        }\n\n        for ( Map.Entry<CountsKey,long[]> pair : recovered.getMap().entrySet() )\n        {\n            long[] value = countsSnapshot.getMap().get( pair.getKey() );\n            Assert.assertNotNull( value );\n            Assert.assertTrue( Arrays.equals( value, pair.getValue() ) );\n        }\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void writeAndSerializeEntityRelationship( int startId, int type, int endId, long count )\n            throws IOException, UnknownKey\n    {\n        countsSnapshot.getMap().put( CountsKeyFactory.relationshipKey( startId, type, endId ), new long[]{count} );\n        serialize( logChannel, countsSnapshot );\n    }","id":80686,"modified_method":"private void writeAndSerializeEntityRelationship( int startId, int type, int endId, long count )\n            throws IOException, UnknownKey\n    {\n        countsSnapshot.getMap().put( relationshipKey( startId, type, endId ), new long[]{count} );\n        serialize( logChannel, countsSnapshot );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void writeAndSerializeEntityNode( int labelId, long count ) throws IOException, UnknownKey\n    {\n        countsSnapshot.getMap().put( CountsKeyFactory.nodeKey( labelId ), new long[]{count} );\n        serialize( logChannel, countsSnapshot );\n    }","id":80687,"modified_method":"private void writeAndSerializeEntityNode( int labelId, long count ) throws IOException, UnknownKey\n    {\n        countsSnapshot.getMap().put( nodeKey( labelId ), new long[]{count} );\n        serialize( logChannel, countsSnapshot );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized static Map<CountsKey,long[]> updateMapByDiff( Map<CountsKey,long[]> map,\n            Map<CountsKey,long[]> diff, long txId )\n    {\n        diff.entrySet().forEach( ( pair ) -> map.compute( pair.getKey(),\n                ( k, v ) -> v == null ? pair.getValue() : updateEachValue( v, pair.getValue() ) ) );\n        return map;\n    }","id":80688,"modified_method":"private synchronized static Map<CountsKey,long[]> updateMapByDiff( Map<CountsKey,long[]> map,\n            Map<CountsKey,long[]> diff )\n    {\n        diff.entrySet().forEach( ( pair ) -> map.compute( pair.getKey(),\n                ( k, v ) -> v == null ? pair.getValue() : updateEachValue( v, pair.getValue() ) ) );\n        return map;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public SnapshotWorker( int txId, IntermediateStateTestManager intermediateStateTestManager,\n                InMemoryCountsStore countStore )\n        {\n            this.txId = txId;\n            this.intermediateStateTestManager = intermediateStateTestManager;\n            this.countStore = countStore;\n        }","id":80689,"modified_method":"public SnapshotWorker( int repeatTimes, AtomicBoolean stop,\n                IntermediateStateTestManager intermediateStateTestManager, InMemoryCountsStore countStore )\n        {\n            this.stop = stop;\n            this.intermediateStateTestManager = intermediateStateTestManager;\n            this.countStore = countStore;\n            this.repeatTimes = repeatTimes;\n        }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void run()\n        {\n            CountsSnapshot countsSnapshot = countStore.snapshot( txId );\n\n            Map<CountsKey,long[]> snapshotMap = countsSnapshot.getMap();\n            Map<CountsKey,long[]> expectedMap =\n                    intermediateStateTestManager.getIntermediateMap( (int) countsSnapshot.getTxId() );\n\n            //THEN\n            Assert.assertTrue( \"Counts store snapshot was recorded with transaction ID less than the requested value.\",\n                    countsSnapshot.getTxId() >= txId );\n            Assert.assertEquals( \"Counts store snapshot has an incorrect number of k/v pairs.\", snapshotMap.size(),\n                    expectedMap.size() );\n\n            compareMaps( expectedMap, snapshotMap );\n        }","id":80690,"modified_method":"@Override\n        public void run()\n        {\n            for ( int i = 0; i < repeatTimes; i++ )\n            {\n                int id = intermediateStateTestManager.getId();\n                long txId = id + ThreadLocalRandom.current().nextLong( 0, 5 );\n                CountsSnapshot countsSnapshot = countStore.snapshot( txId );\n                long snapshotTxId = countsSnapshot.getTxId();\n\n                Map<CountsKey,long[]> snapshotMap = countsSnapshot.getMap();\n                Map<CountsKey,long[]> expectedMap =\n                        intermediateStateTestManager.getIntermediateMap( (int) snapshotTxId );\n\n                //THEN\n                assertThat( \"Counts store snapshot was recorded with transaction ID less than the requested value.\",\n                        snapshotTxId, greaterThanOrEqualTo( txId ) );\n\n                assertMapEquals( expectedMap, snapshotMap );\n            }\n\n            stop.set( true );\n        }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void run()\n        {\n            //Lets mix up the order the updates are applied.\n            if ( ThreadLocalRandom.current().nextInt( 5 ) == 3 ) // 3/5 = 60% of the time. Just a guess.\n            {\n                Thread.yield();\n            }\n            countStore.updateAll( txId, map );\n        }","id":80691,"modified_method":"@Override\n        public void run()\n        {\n            while ( !stop.get() )\n            {\n                Map<CountsKey,long[]> map = new HashMap<>();\n                int txId = manager.getNextUpdateMap( map );\n                //Lets mix up the order the updates are applied.\n                if ( ThreadLocalRandom.current().nextInt( 0, 5 ) == 3 ) // 3/5 = 60% of the time. Just a guess.\n                {\n                    Thread.yield();\n                }\n                countStore.updateAll( txId, map );\n            }\n        }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void compareMaps( Map<CountsKey,long[]> expected, Map<CountsKey,long[]> actual )\n    {\n        actual.forEach( ( key, value ) -> {\n            Assert.assertTrue( \"Example counts store snapshot has null where key was expected.\",\n                    expected.get( key ) != null );\n            Assert.assertTrue( \"Example counts store snapshot has different value for a key than expected.\",\n                    Arrays.equals( expected.get( key ), value ) );\n        } );\n\n        expected.forEach( ( key, value ) -> {\n            Assert.assertTrue( \"Counts store snapshot has null where key was expected.\", actual.get( key ) != null );\n            Assert.assertTrue( \"Counts store snapshot has different value for a key than expected.\",\n                    Arrays.equals( actual.get( key ), value ) );\n        } );\n    }","id":80692,"modified_method":"private static void assertMapEquals( Map<CountsKey,long[]> expected, Map<CountsKey,long[]> actual )\n    {\n        try\n        {\n            assertEquals( expected.size(), actual.size() );\n            actual.forEach( ( key, value ) -> {\n                assertNotNull( \"Example counts store snapshot has null where key was expected.\", expected.get( key ) );\n                assertArrayEquals( \"Example counts store snapshot has different value for a key than expected.\",\n                        expected.get( key ), value );\n            } );\n        }\n        catch ( Throwable t )\n        {\n            actual.forEach( ( key, value ) -> System.out.printf( \"(%s) -> (%s)\\n\", key, Arrays.toString( value ) ) );\n            System.out.println();\n            expected.forEach( ( key, value ) -> System.out.printf( \"(%s) -> (%s)\\n\", key, Arrays.toString( value ) ) );\n            System.out.println();\n\n            throw t;\n        }\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void concurrentWorkload() throws InterruptedException\n    {\n        //GIVEN\n        int numberOfUpdates = 900;\n        InMemoryCountsStore countStore = new InMemoryCountsStore();\n        IntermediateStateTestManager intermediateStateTestManager = new IntermediateStateTestManager( numberOfUpdates );\n        ExecutorService workerExecutorService = Executors.newFixedThreadPool( 10 );\n\n        //There should only ever be one snapshot worker.\n        ExecutorService snapshotExecutorService = Executors.newSingleThreadExecutor();\n\n        for ( int i = 0; i < numberOfUpdates; i++ )\n        {\n            ConcurrentHashMap<CountsKey,long[]> map = new ConcurrentHashMap<>();\n            long txid = intermediateStateTestManager.getNextUpdateMap( map );\n            Runnable workerA = new UpdateWorker( txid, map, countStore );\n\n            //WHEN\n            workerExecutorService.execute( workerA );\n            if ( i > 1 && ThreadLocalRandom.current().nextInt( 50 ) == 3 )\n            {\n                //THEN\n                snapshotExecutorService.execute( new SnapshotWorker( i, intermediateStateTestManager, countStore ) );\n            }\n        }\n        workerExecutorService.shutdown();\n        snapshotExecutorService.shutdown();\n        workerExecutorService.awaitTermination( 100, TimeUnit.SECONDS );\n        snapshotExecutorService.awaitTermination( 100, TimeUnit.SECONDS );\n    }","id":80693,"modified_method":"@Test\n    public void concurrentWorkload() throws Exception\n    {\n        //GIVEN\n        InMemoryCountsStore countStore = new InMemoryCountsStore();\n        IntermediateStateTestManager intermediateStateTestManager = new IntermediateStateTestManager();\n        ExecutorService executor = Executors.newFixedThreadPool( 10 );\n        ExecutorCompletionService<Void> ecs = new ExecutorCompletionService<>( executor );\n\n        List<Runnable> workers = new ArrayList<>( 10 );\n        AtomicBoolean stop = new AtomicBoolean();\n        for ( int i = 0; i < 9; i++ )\n        {\n            workers.add( new UpdateWorker( stop, intermediateStateTestManager, countStore ) );\n        }\n        workers.add( new SnapshotWorker( 10, stop, intermediateStateTestManager, countStore ) );\n\n        //WHEN\n        for ( Runnable worker : workers )\n        {\n            ecs.submit( worker, null );\n        }\n\n        // THEN\n        for ( int i = 0; i < workers.size(); i++ )\n        {\n            ecs.take().get();\n        }\n\n        executor.shutdown();\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void singleWriteTest()\n    {\n        //GIVEN\n        InMemoryCountsStore countStore = new InMemoryCountsStore();\n        IntermediateStateTestManager intermediateStateTestManager = new IntermediateStateTestManager( 5 );\n        Map<CountsKey,long[]> snapshotMap;\n\n        //WHEN\n        ConcurrentHashMap<CountsKey,long[]> updateMap = new ConcurrentHashMap<>();\n        Map<CountsKey,long[]> map = new ConcurrentHashMap<>();\n        long txId = intermediateStateTestManager.getNextUpdateMap( updateMap );\n        updateMapByDiff( map, updateMap, txId );\n        countStore.updateAll( txId, updateMap );\n        CountsSnapshot countsSnapshot = countStore.snapshot( txId );\n        snapshotMap = countsSnapshot.getMap();\n\n        //THEN\n        compareMaps( map, snapshotMap );\n    }","id":80694,"modified_method":"@Test\n    public void singleWriteTest()\n    {\n        //GIVEN\n        InMemoryCountsStore countStore = new InMemoryCountsStore();\n        IntermediateStateTestManager intermediateStateTestManager = new IntermediateStateTestManager();\n        Map<CountsKey,long[]> snapshotMap;\n\n        //WHEN\n        ConcurrentHashMap<CountsKey,long[]> updateMap = new ConcurrentHashMap<>();\n        Map<CountsKey,long[]> map = new ConcurrentHashMap<>();\n        long txId = intermediateStateTestManager.getNextUpdateMap( updateMap );\n        updateMapByDiff( map, updateMap );\n        countStore.updateAll( txId, updateMap );\n        CountsSnapshot countsSnapshot = countStore.snapshot( txId );\n        snapshotMap = countsSnapshot.getMap();\n\n        //THEN\n        assertMapEquals( map, snapshotMap );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void sequentialWorkload()\n    {\n        //GIVEN\n        int numberOfUpdates = 1000;\n        CountsSnapshot countsSnapshot;\n        Map<CountsKey,long[]> snapshotMap;\n        Map<CountsKey,long[]> map = new ConcurrentHashMap<>();\n        ConcurrentHashMap<CountsKey,long[]> updateMap = new ConcurrentHashMap<>();\n        IntermediateStateTestManager intermediateStateTestManager = new IntermediateStateTestManager( numberOfUpdates );\n        InMemoryCountsStore countStore = new InMemoryCountsStore();\n\n        for ( int i = 0; i < numberOfUpdates; i++ )\n        {\n            //WHEN\n            long txId = intermediateStateTestManager.getNextUpdateMap( updateMap );\n            updateMapByDiff( map, updateMap, txId );\n            countStore.updateAll( txId, updateMap );\n            countsSnapshot = countStore.snapshot( txId );\n            snapshotMap = countsSnapshot.getMap();\n\n            //THEN\n            compareMaps( map, snapshotMap );\n        }\n    }","id":80695,"modified_method":"@Test\n    public void sequentialWorkload()\n    {\n        //GIVEN\n        CountsSnapshot countsSnapshot;\n        Map<CountsKey,long[]> snapshotMap;\n        Map<CountsKey,long[]> map = new ConcurrentHashMap<>();\n        ConcurrentHashMap<CountsKey,long[]> updateMap = new ConcurrentHashMap<>();\n        IntermediateStateTestManager intermediateStateTestManager = new IntermediateStateTestManager();\n        InMemoryCountsStore countStore = new InMemoryCountsStore();\n\n        for ( int i = 0; i < 1000; i++ )\n        {\n            //WHEN\n            long txId = intermediateStateTestManager.getNextUpdateMap( updateMap );\n            updateMapByDiff( map, updateMap );\n            countStore.updateAll( txId, updateMap );\n            countsSnapshot = countStore.snapshot( txId );\n            snapshotMap = countsSnapshot.getMap();\n\n            //THEN\n            assertMapEquals( map, snapshotMap );\n        }\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ConcurrentHashMap<CountsKey,long[]> randomMap()\n    {\n        int largestDiff = 100;\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < largestKey; i++ )\n        {\n            pairs.put( nodeKey( ThreadLocalRandom.current().nextInt( 0, largestKey ) ),\n                    new long[]{ThreadLocalRandom.current().nextLong( -1 * largestDiff, largestDiff )} );\n        }\n        return pairs;\n\n    }","id":80696,"modified_method":"private ConcurrentHashMap<CountsKey,long[]> randomMap()\n    {\n        int largestDiff = 100;\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < LARGEST_KEY; i++ )\n        {\n            pairs.put( nodeKey( ThreadLocalRandom.current().nextInt( 0, LARGEST_KEY ) ),\n                    new long[]{ThreadLocalRandom.current().nextLong( -1 * largestDiff, largestDiff )} );\n        }\n        return pairs;\n\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ConcurrentHashMap<CountsKey,long[]> getIntermediateMap( int txId )\n    {\n        return intermediateStateMaps[txId];\n    }","id":80697,"modified_method":"public synchronized ConcurrentHashMap<CountsKey,long[]> getIntermediateMap( int txId )\n    {\n        return intermediateStateMaps.get( txId );\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized static ConcurrentHashMap<CountsKey,long[]> applyDiffToMap(\n            ConcurrentHashMap<CountsKey,long[]> map, ConcurrentHashMap<CountsKey,long[]> diff )\n    {\n        diff.forEach( ( key, value ) -> map.compute( key,\n                ( k, v ) -> v == null ? Arrays.copyOf( value, value.length ) : updateEachValue( v, value ) ) );\n        return map;\n    }","id":80698,"modified_method":"private static ConcurrentHashMap<CountsKey,long[]> applyDiffToMap( ConcurrentHashMap<CountsKey,long[]> map,\n            ConcurrentHashMap<CountsKey,long[]> diff )\n    {\n        diff.forEach( ( key, value ) -> map.compute( key,\n                ( k, v ) -> v == null ? Arrays.copyOf( value, value.length ) : updateEachValue( v, value ) ) );\n        return map;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ConcurrentHashMap<CountsKey,long[]> randomPositiveMap()\n    {\n        int largestDiff = 100;\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < largestKey; i++ )\n        {\n            pairs.put( nodeKey( ThreadLocalRandom.current().nextInt( 0, largestKey ) ),\n                    new long[]{ThreadLocalRandom.current().nextLong( 1, largestDiff )} );\n        }\n        return pairs;\n    }","id":80699,"modified_method":"private ConcurrentHashMap<CountsKey,long[]> randomPositiveMap()\n    {\n        int largestDiff = 100;\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < LARGEST_KEY; i++ )\n        {\n            pairs.put( nodeKey( ThreadLocalRandom.current().nextInt( 0, LARGEST_KEY ) ),\n                    new long[]{ThreadLocalRandom.current().nextLong( 1, largestDiff )} );\n        }\n        return pairs;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ConcurrentHashMap<CountsKey,long[]> allOnesMap()\n    {\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < largestKey; i++ )\n        {\n            pairs.put( nodeKey( i ), new long[]{1L} );\n        }\n        return pairs;\n    }","id":80700,"modified_method":"private ConcurrentHashMap<CountsKey,long[]> allOnesMap()\n    {\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < LARGEST_KEY; i++ )\n        {\n            pairs.put( nodeKey( i ), new long[]{1L} );\n        }\n        return pairs;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ConcurrentHashMap<CountsKey,long[]> allZerosMap()\n    {\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < largestKey; i++ )\n        {\n            pairs.put( nodeKey( i ), new long[]{0L} );\n        }\n        return pairs;\n    }","id":80701,"modified_method":"private ConcurrentHashMap<CountsKey,long[]> allZerosMap()\n    {\n        ConcurrentHashMap<CountsKey,long[]> pairs = new ConcurrentHashMap<>();\n        for ( int i = 0; i < LARGEST_KEY; i++ )\n        {\n            pairs.put( nodeKey( i ), new long[]{0L} );\n        }\n        return pairs;\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getNextUpdateMap( ConcurrentHashMap<CountsKey,long[]> map )\n    {\n        if ( id < numberOfUpdates )\n        {\n            map.clear();\n            map.putAll( maps[id] );\n            return id++;\n        }\n        else\n        {\n            return -1;\n        }\n    }","id":80702,"modified_method":"public synchronized int getNextUpdateMap( Map<CountsKey,long[]> map )\n    {\n        if ( maps.hasNext() )\n        {\n            map.clear();\n            map.putAll( maps.next() );\n            return id++;\n        }\n        else\n        {\n            return -1;\n        }\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IntermediateStateTestManager( int numberOfUpdates )\n    {\n        this.numberOfUpdates = numberOfUpdates + 1;\n        this.maps = new ConcurrentHashMap[this.numberOfUpdates];\n        IntStream.range( 0, this.numberOfUpdates ).forEach( ( i ) -> this.maps[i] = allOnesMap() );\n        this.intermediateStateMaps = computeAllUpdates();\n    }","id":80703,"modified_method":"public IntermediateStateTestManager()\n    {\n        intermediateStateMaps.add( new ConcurrentHashMap<>() );\n        this.maps = new Iterator<ConcurrentHashMap<CountsKey,long[]>>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return true;\n            }\n\n            @Override\n            public ConcurrentHashMap<CountsKey,long[]> next()\n            {\n                ConcurrentHashMap<CountsKey,long[]> map = allOnesMap();\n                ConcurrentHashMap<CountsKey,long[]> nextMap =\n                        copyOfMap( intermediateStateMaps.get( intermediateStateMaps.size() - 1 ) );\n                applyDiffToMap( nextMap, map );\n                intermediateStateMaps.add( nextMap );\n                return map;\n            }\n        };\n    }","commit_id":"bde2d91cd9d5f1b03f78b162a484b563dcf9a59e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void visitRootEvent(SModelRootEvent event) {\n      if (!event.isRemoved()) return;\n\n      VirtualFile vf = myVirtualFiles.get(new SNodePointer(event.getRoot()));\n      if (vf == null) return;\n\n      fireBeforeFileDeletion(this, vf);\n      fireFileDeleted(this, vf, vf.getName(), null);\n      myVirtualFiles.remove(new SNodePointer(event.getRoot()));\n    }","id":80704,"modified_method":"public void visitRootEvent(SModelRootEvent event) {\n      if (!event.isRemoved()) return;\n\n      VirtualFile vf = myVirtualFiles.get(new SNodePointer(event.getRoot()));\n      if (vf == null) return;\n\n      if (vf.isValid()) {\n        fireBeforeFileDeletion(this, vf);\n      }\n      fireFileDeleted(this, vf, vf.getName(), null);\n      myVirtualFiles.remove(new SNodePointer(event.getRoot()));\n    }","commit_id":"d13ede73db761a1a2925b579bbf6c269e6fda19d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void beforeModelRemoved(SModelDescriptor modelDescriptor) {\n      if (modelDescriptor.getLoadingState() == ModelLoadingState.NOT_LOADED) return;\n\n      for (final SNode root : modelDescriptor.getSModel().roots()) {\n        final SNodePointer pointer = new SNodePointer(root);\n        final VirtualFile vf = myVirtualFiles.get(pointer);\n        if (vf == null) continue;\n        ModelAccess.instance().runWriteInEDT(new Runnable() {\n          public void run() {\n            fireBeforeFileDeletion(this, vf);\n            fireFileDeleted(this, vf, vf.getName(), null);\n            myVirtualFiles.remove(pointer);\n          }\n        });\n      }\n    }","id":80705,"modified_method":"public void beforeModelRemoved(SModelDescriptor modelDescriptor) {\n      if (modelDescriptor.getLoadingState() == ModelLoadingState.NOT_LOADED) return;\n\n      for (final SNode root : modelDescriptor.getSModel().roots()) {\n        final SNodePointer pointer = new SNodePointer(root);\n        final VirtualFile vf = myVirtualFiles.get(pointer);\n        if (vf == null) continue;\n        ModelAccess.instance().runWriteInEDT(new Runnable() {\n          public void run() {\n            if (vf.isValid()) {\n              fireBeforeFileDeletion(this, vf);\n            }\n            fireFileDeleted(this, vf, vf.getName(), null);\n            myVirtualFiles.remove(pointer);\n          }\n        });\n      }\n    }","commit_id":"d13ede73db761a1a2925b579bbf6c269e6fda19d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void onModelReplaced(SModelDescriptor sm) {\n      for (Entry<SNodePointer, MPSNodeVirtualFile> entry : myVirtualFiles.entrySet()) {\n        if (entry.getKey().getModel() != sm) continue;\n\n        SNode node = entry.getKey().getNode();\n        MPSNodeVirtualFile file = entry.getValue();\n        if (node == null) {\n          fireBeforeFileDeletion(this, file);\n          fireFileDeleted(this, file, file.getName(), null);\n        } else {\n          String oldName = file.getName();\n          String newName = node.getName();\n          if (!oldName.equals(newName)) {\n            fireBeforePropertyChange(this, file, VirtualFile.PROP_NAME, oldName, newName);\n            file.updateFields();\n            firePropertyChanged(this, file, VirtualFile.PROP_NAME, oldName, newName);\n          }\n        }\n      }\n    }","id":80706,"modified_method":"private void onModelReplaced(SModelDescriptor sm) {\n      for (Entry<SNodePointer, MPSNodeVirtualFile> entry : myVirtualFiles.entrySet()) {\n        if (entry.getKey().getModel() != sm) continue;\n\n        SNode node = entry.getKey().getNode();\n        MPSNodeVirtualFile file = entry.getValue();\n        if (node == null) {\n          if (file.isValid()) {\n            fireBeforeFileDeletion(this, file);\n          }\n          fireFileDeleted(this, file, file.getName(), null);\n        } else {\n          String oldName = file.getName();\n          String newName = node.getName();\n          if (!oldName.equals(newName)) {\n            fireBeforePropertyChange(this, file, VirtualFile.PROP_NAME, oldName, newName);\n            file.updateFields();\n            firePropertyChanged(this, file, VirtualFile.PROP_NAME, oldName, newName);\n          }\n        }\n      }\n    }","commit_id":"d13ede73db761a1a2925b579bbf6c269e6fda19d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void beforeModelRemoved(SModelDescriptor modelDescriptor) {\n      if (modelDescriptor.getLoadingState() == ModelLoadingState.NOT_LOADED) return;\n\n      for (final SNode root : modelDescriptor.getSModel().roots()) {\n        final SNodePointer pointer = new SNodePointer(root);\n        final VirtualFile vf = myVirtualFiles.get(pointer);\n        if (vf == null) continue;\n        ModelAccess.instance().runWriteInEDT(new Runnable() {\n          public void run() {\n            if (vf.isValid()) {\n              fireBeforeFileDeletion(this, vf);\n              fireFileDeleted(this, vf, vf.getName(), null);\n            }\n            myVirtualFiles.remove(pointer);\n          }\n        });\n      }\n    }","id":80707,"modified_method":"public void beforeModelRemoved(SModelDescriptor modelDescriptor) {\n      if (modelDescriptor.getLoadingState() == ModelLoadingState.NOT_LOADED) return;\n\n      for (final SNode root : modelDescriptor.getSModel().roots()) {\n        final SNodePointer pointer = new SNodePointer(root);\n        final VirtualFile vf = myVirtualFiles.get(pointer);\n        if (vf == null) continue;\n        ModelAccess.instance().runWriteInEDT(new Runnable() {\n          public void run() {\n            if (vf.isValid()) {\n              fireBeforeFileDeletion(this, vf);\n            }\n            fireFileDeleted(this, vf, vf.getName(), null);\n            myVirtualFiles.remove(pointer);\n          }\n        });\n      }\n    }","commit_id":"c9841a37746d259d859cabff3eb30d8486d682ef","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void onModelReplaced(SModelDescriptor sm) {\n      for (Entry<SNodePointer, MPSNodeVirtualFile> entry : myVirtualFiles.entrySet()) {\n        if (entry.getKey().getModel() != sm) continue;\n\n        SNode node = entry.getKey().getNode();\n        MPSNodeVirtualFile file = entry.getValue();\n        if (node == null) {\n          fireBeforeFileDeletion(this, file);\n          fireFileDeleted(this, file, file.getName(), null);\n        } else {\n          String oldName = file.getName();\n          String newName = node.getName();\n          if (!oldName.equals(newName)) {\n            fireBeforePropertyChange(this, file, VirtualFile.PROP_NAME, oldName, newName);\n            file.updateFields();\n            firePropertyChanged(this, file, VirtualFile.PROP_NAME, oldName, newName);\n          }\n        }\n      }\n    }","id":80708,"modified_method":"private void onModelReplaced(SModelDescriptor sm) {\n      for (Entry<SNodePointer, MPSNodeVirtualFile> entry : myVirtualFiles.entrySet()) {\n        if (entry.getKey().getModel() != sm) continue;\n\n        SNode node = entry.getKey().getNode();\n        MPSNodeVirtualFile file = entry.getValue();\n        if (node == null) {\n          if (file.isValid()) {\n            fireBeforeFileDeletion(this, file);\n          }\n          fireFileDeleted(this, file, file.getName(), null);\n        } else {\n          String oldName = file.getName();\n          String newName = node.getName();\n          if (!oldName.equals(newName)) {\n            fireBeforePropertyChange(this, file, VirtualFile.PROP_NAME, oldName, newName);\n            file.updateFields();\n            firePropertyChanged(this, file, VirtualFile.PROP_NAME, oldName, newName);\n          }\n        }\n      }\n    }","commit_id":"c9841a37746d259d859cabff3eb30d8486d682ef","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void visitRootEvent(SModelRootEvent event) {\n      if (!event.isRemoved()) return;\n\n      VirtualFile vf = myVirtualFiles.get(new SNodePointer(event.getRoot()));\n      if (vf == null) return;\n\n      fireBeforeFileDeletion(this, vf);\n      fireFileDeleted(this, vf, vf.getName(), null);\n      myVirtualFiles.remove(new SNodePointer(event.getRoot()));\n    }","id":80709,"modified_method":"public void visitRootEvent(SModelRootEvent event) {\n      if (!event.isRemoved()) return;\n\n      VirtualFile vf = myVirtualFiles.get(new SNodePointer(event.getRoot()));\n      if (vf == null) return;\n\n      if (vf.isValid()) {\n        fireBeforeFileDeletion(this, vf);\n      }\n      fireFileDeleted(this, vf, vf.getName(), null);\n      myVirtualFiles.remove(new SNodePointer(event.getRoot()));\n    }","commit_id":"c9841a37746d259d859cabff3eb30d8486d682ef","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n\tpublic void testBuildTemplate() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(null, \"hello-world-portlet\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/hello/world/portlet/portlet/HelloWorldPortlet.java\",\n\t\t\t\"public class HelloWorldPortlet extends MVCPortlet {\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/hello.world.portlet-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/hello.world.portlet-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"mvcportlet\", \"hello-world-portlet\",\n\t\t\t\"-Dpackage=hello.world.portlet\", \"-DclassName=HelloWorld\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/hello-world-portlet-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/hello-world-portlet-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80710,"modified_method":"@Test\n\tpublic void testBuildTemplate() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\tnull, \"hello-world-portlet\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"mvcportlet\", \"hello-world-portlet\",\n\t\t\t\t\"-Dpackage=hello.world.portlet\", \"-DclassName=HelloWorld\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/hello/world/portlet/portlet/HelloWorldPortlet.java\",\n\t\t\t\"public class HelloWorldPortlet extends MVCPortlet {\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/hello.world.portlet-1.0.0.jar\",\n\t\t\t\t\"target/hello-world-portlet-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateMVCPortletWithPortletSuffix()\n\t\tthrows Exception {\n\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"mvcportlet\", \"portlet-portlet\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/portlet/portlet/portlet/PortletPortlet.java\",\n\t\t\t\"public class PortletPortlet extends MVCPortlet {\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/portlet.portlet-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/portlet.portlet-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"mvcportlet\", \"portlet-portlet\", \"-Dpackage=portlet.portlet\",\n\t\t\t\"-DclassName=Portlet\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/portlet-portlet-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/portlet-portlet-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80711,"modified_method":"@Test\n\tpublic void testBuildTemplateMVCPortletWithPortletSuffix()\n\t\tthrows Exception {\n\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"mvcportlet\", \"portlet-portlet\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"mvcportlet\", \"portlet-portlet\", \"-Dpackage=portlet.portlet\",\n\t\t\t\t\"-DclassName=Portlet\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/portlet/portlet/portlet/PortletPortlet.java\",\n\t\t\t\"public class PortletPortlet extends MVCPortlet {\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/portlet.portlet-1.0.0.jar\",\n\t\t\t\t\"target/portlet-portlet-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateServiceWrapper() throws Exception {\n\t\tString serviceWrapperClassName =\n\t\t\t\"com.liferay.portal.kernel.service.UserLocalServiceWrapper\";\n\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"servicewrapper\", \"serviceoverride\", \"--service\",\n\t\t\tserviceWrapperClassName);\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\tString serviceOverrideFilePath =\n\t\t\t\"src/main/java/serviceoverride/Serviceoverride.java\";\n\t\tString packageServiceOverride = \"package serviceoverride;\";\n\t\tString importStatement = \"import \" + serviceWrapperClassName + \";\";\n\t\tString service = \"service = ServiceWrapper.class\";\n\t\tString classDecl =\n\t\t\t\"public class Serviceoverride extends UserLocalServiceWrapper {\";\n\t\tString constructorDecl = \"public Serviceoverride() {\";\n\n\t\t_testContains(\n\t\t\tprojectDir, serviceOverrideFilePath, packageServiceOverride,\n\t\t\timportStatement, service, classDecl, constructorDecl);\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/serviceoverride-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/serviceoverride-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"servicewrapper\", \"serviceoverride\", \"-Dpackage=serviceoverride\",\n\t\t\t\"-DclassName=Serviceoverride\",\n\t\t\t\"-DserviceWrapperClass=\" + serviceWrapperClassName);\n\n\t\t_testContains(\n\t\t\t\tmavenProjectDir, serviceOverrideFilePath,\n\t\t\t\tpackageServiceOverride, importStatement, service, classDecl,\n\t\t\t\tconstructorDecl);\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/serviceoverride-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/serviceoverride-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80712,"modified_method":"@Test\n\tpublic void testBuildTemplateServiceWrapper() throws Exception {\n\t\tString serviceWrapperClassName =\n\t\t\t\"com.liferay.portal.kernel.service.UserLocalServiceWrapper\";\n\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"servicewrapper\", \"serviceoverride\", \"--service\",\n\t\t\tserviceWrapperClassName);\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"servicewrapper\", \"serviceoverride\",\n\t\t\t\t\"-Dpackage=serviceoverride\", \"-DclassName=Serviceoverride\",\n\t\t\t\t\"-DserviceWrapperClass=\" + serviceWrapperClassName);\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\tString serviceOverrideFilePath =\n\t\t\t\"src/main/java/serviceoverride/Serviceoverride.java\";\n\t\tString packageServiceOverride = \"package serviceoverride;\";\n\t\tString importStatement = \"import \" + serviceWrapperClassName + \";\";\n\t\tString service = \"service = ServiceWrapper.class\";\n\t\tString classDecl =\n\t\t\t\"public class Serviceoverride extends UserLocalServiceWrapper {\";\n\t\tString constructorDecl = \"public Serviceoverride() {\";\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, serviceOverrideFilePath, packageServiceOverride,\n\t\t\timportStatement, service, classDecl, constructorDecl);\n\n\t\t_executeGradle(gradleProjectDir, _GRADLE_BUILD_ARGS);\n\n\t\tFile gradleBundleFile = _testExists(\n\t\t\tgradleProjectDir, \"build/libs/serviceoverride-1.0.0.jar\");\n\n\t\t_testContains(\n\t\t\t\tmavenProjectDir, serviceOverrideFilePath,\n\t\t\t\tpackageServiceOverride, importStatement, service, classDecl,\n\t\t\t\tconstructorDecl);\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\tFile mavenBundleFile = _testExists(\n\t\t\tmavenProjectDir, \"target/serviceoverride-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateSimulationPanelEntry() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"simulationpanelentry\", \"simulator\", \"--package-name\",\n\t\t\t\"test.simulator\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/test/simulator/application/list/\" +\n\t\t\t\"SimulatorSimulationPanelApp.java\",\n\t\t\t\"public class SimulatorSimulationPanelApp\",\n\t\t\t\"extends BaseJSPPanelApp\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/test.simulator-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/test.simulator-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"simulationpanelentry\", \"simulator\", \"-Dpackage=test.simulator\",\n\t\t\t\"-DclassName=Simulator\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/simulator-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/simulator-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80713,"modified_method":"@Test\n\tpublic void testBuildTemplateSimulationPanelEntry() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"simulationpanelentry\", \"simulator\", \"--package-name\",\n\t\t\t\"test.simulator\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"simulationpanelentry\", \"simulator\", \"-Dpackage=test.simulator\",\n\t\t\t\t\"-DclassName=Simulator\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/test/simulator/application/list/\" +\n\t\t\t\"SimulatorSimulationPanelApp.java\",\n\t\t\t\"public class SimulatorSimulationPanelApp\",\n\t\t\t\"extends BaseJSPPanelApp\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/test.simulator-1.0.0.jar\",\n\t\t\t\t\"target/simulator-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _executeMaven(File projectDir, String[] args)\n\t\tthrows Exception {\n\n\t\tFile deps = new File(\"build/mavenEmbedderDeps.txt\");\n\n\t\tString[] lines = FileTestUtil.readLines(deps);\n\n\t\tURL[] urls = new URL[lines.length];\n\n\t\tfor (int i = 0; i < lines.length; i++) {\n\t\t\tFile file = new File(lines[i]);\n\n\t\t\tURI uri = file.toURI();\n\n\t\t\turls[i] = uri.toURL();\n\t\t}\n\n\t\ttry (URLClassLoader classLoader = new URLClassLoader(urls, null)) {\n\t\t\tClass<?> mavenCLIClazz = classLoader.loadClass(\n\t\t\t\t\"org.apache.maven.cli.MavenCli\");\n\n\t\t\tObject mavenCli = mavenCLIClazz.newInstance();\n\n\t\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\t\tByteArrayOutputStream errorOutput = new ByteArrayOutputStream();\n\n\t\t\tMethod doMain = mavenCLIClazz.getMethod(\n\t\t\t\t\"doMain\", String[].class, String.class, PrintStream.class,\n\t\t\t\tPrintStream.class);\n\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tClassLoader contextClassLoader =\n\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\tcurrentThread.setContextClassLoader(classLoader);\n\n\t\t\ttry {\n\t\t\t\tPrintStream out = new PrintStream(output);\n\t\t\t\tPrintStream err = new PrintStream(errorOutput);\n\n\t\t\t\tInteger retcode = (Integer)doMain.invoke(\n\t\t\t\t\tmavenCli, args, projectDir.getAbsolutePath(), out, err);\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tnew String(errorOutput.toByteArray()), 0,\n\t\t\t\t\tretcode.intValue());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t\t}\n\t\t}\n\t}","id":80714,"modified_method":"private void _executeMaven(File gradleProjectDir, String[] args)\n\t\tthrows Exception {\n\n\t\tFile deps = new File(\"build/mavenEmbedderDeps.txt\");\n\n\t\tString[] lines = FileTestUtil.readLines(deps);\n\n\t\tURL[] urls = new URL[lines.length];\n\n\t\tfor (int i = 0; i < lines.length; i++) {\n\t\t\tFile file = new File(lines[i]);\n\n\t\t\tURI uri = file.toURI();\n\n\t\t\turls[i] = uri.toURL();\n\t\t}\n\n\t\ttry (URLClassLoader classLoader = new URLClassLoader(urls, null)) {\n\t\t\tClass<?> mavenCLIClazz = classLoader.loadClass(\n\t\t\t\t\"org.apache.maven.cli.MavenCli\");\n\n\t\t\tObject mavenCli = mavenCLIClazz.newInstance();\n\n\t\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\t\tByteArrayOutputStream errorOutput = new ByteArrayOutputStream();\n\n\t\t\tMethod doMain = mavenCLIClazz.getMethod(\n\t\t\t\t\"doMain\", String[].class, String.class, PrintStream.class,\n\t\t\t\tPrintStream.class);\n\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tClassLoader contextClassLoader =\n\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\tcurrentThread.setContextClassLoader(classLoader);\n\n\t\t\ttry {\n\t\t\t\tPrintStream out = new PrintStream(output);\n\t\t\t\tPrintStream err = new PrintStream(errorOutput);\n\n\t\t\t\tInteger retcode = (Integer)doMain.invoke(\n\t\t\t\t\tmavenCli, args, gradleProjectDir.getAbsolutePath(), out,\n\t\t\t\t\terr);\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tnew String(errorOutput.toByteArray()), 0,\n\t\t\t\t\tretcode.intValue());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateTemplateContextContributor() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"templatecontextcontributor\", \"blade-test\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/blade/test/theme/contributor/\" +\n\t\t\t\"BladeTestTemplateContextContributor.java\",\n\t\t\t\"public class BladeTestTemplateContextContributor\",\n\t\t\t\"implements TemplateContextContributor\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/blade.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/blade.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"templatecontextcontributor\", \"blade-test\", \"-Dpackage=blade.test\",\n\t\t\t\"-DclassName=BladeTest\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/blade-test-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/blade-test-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80715,"modified_method":"@Test\n\tpublic void testBuildTemplateTemplateContextContributor() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"templatecontextcontributor\", \"blade-test\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"templatecontextcontributor\", \"blade-test\",\n\t\t\t\t\"-Dpackage=blade.test\", \"-DclassName=BladeTest\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/blade/test/theme/contributor/\" +\n\t\t\t\"BladeTestTemplateContextContributor.java\",\n\t\t\t\"public class BladeTestTemplateContextContributor\",\n\t\t\t\"implements TemplateContextContributor\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/blade.test-1.0.0.jar\",\n\t\t\t\t\"target/blade-test-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateService() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"service\", \"servicepreaction\", \"--class-name\", \"FooAction\",\n\t\t\t\"--service\", \"com.liferay.portal.kernel.events.LifecycleAction\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_writeServiceClass(projectDir);\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/servicepreaction-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/servicepreaction-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"service\", \"servicepreaction\", \"-Dpackage=servicepreaction\",\n\t\t\t\"-DclassName=FooAction\",\n\t\t\t\"-DserviceClass=com.liferay.portal.kernel.events.LifecycleAction\");\n\n\t\t_writeServiceClass(mavenProjectDir);\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/servicepreaction-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/servicepreaction-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80716,"modified_method":"@Test\n\tpublic void testBuildTemplateService() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"service\", \"servicepreaction\", \"--class-name\", \"FooAction\",\n\t\t\t\"--service\", \"com.liferay.portal.kernel.events.LifecycleAction\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"service\", \"servicepreaction\", \"-Dpackage=servicepreaction\",\n\t\t\t\t\"-DclassName=FooAction\", \"-DserviceClass=\" +\n\t\t\t\t\"com.liferay.portal.kernel.events.LifecycleAction\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_writeServiceClass(gradleProjectDir);\n\n\t\t_executeGradle(gradleProjectDir, _GRADLE_BUILD_ARGS);\n\n\t\tFile gradleBundleFile = _testExists(\n\t\t\tgradleProjectDir, \"build/libs/servicepreaction-1.0.0.jar\");\n\n\t\t_writeServiceClass(mavenProjectDir);\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\tFile mavenBundleFile = _testExists(\n\t\t\tmavenProjectDir, \"target/servicepreaction-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private File _buildTemplateWithGradle(\n\t\t\tString template, String name, String... args)\n\t\tthrows Exception {\n\n\t\tFile destinationDir = new File(temporaryFolder.getRoot(), \"gradle\");\n\n\t\tList<String> completeArgs = new ArrayList<>(args.length + 6);\n\n\t\tcompleteArgs.add(\"--destination\");\n\t\tcompleteArgs.add(destinationDir.getPath());\n\t\tcompleteArgs.add(\"--name\");\n\t\tcompleteArgs.add(name);\n\n\t\tif (Validator.isNotNull(template)) {\n\t\t\tcompleteArgs.add(\"--template\");\n\t\t\tcompleteArgs.add(template);\n\t\t}\n\n\t\tfor (String arg : args) {\n\t\t\tcompleteArgs.add(arg);\n\t\t}\n\n\t\tProjectTemplates.main(\n\t\t\tcompleteArgs.toArray(new String[completeArgs.size()]));\n\n\t\tFile projectDir = new File(destinationDir, name);\n\n\t\t_testExists(projectDir, \".gitignore\");\n\t\t_testExists(projectDir, \"build.gradle\");\n\t\t_testExists(projectDir, \"gradlew\");\n\t\t_testExists(projectDir, \"gradlew.bat\");\n\t\t_testExists(projectDir, \"gradle/wrapper/gradle-wrapper.jar\");\n\t\t_testExists(projectDir, \"gradle/wrapper/gradle-wrapper.properties\");\n\t\t_testNotExists(projectDir, \"pom.xml\");\n\n\t\treturn projectDir;\n\t}","id":80717,"modified_method":"private File _buildTemplateWithGradle(\n\t\t\tString template, String name, String... args)\n\t\tthrows Exception {\n\n\t\tFile destinationDir = new File(temporaryFolder.getRoot(), \"gradle\");\n\n\t\tList<String> completeArgs = new ArrayList<>(args.length + 6);\n\n\t\tcompleteArgs.add(\"--destination\");\n\t\tcompleteArgs.add(destinationDir.getPath());\n\t\tcompleteArgs.add(\"--name\");\n\t\tcompleteArgs.add(name);\n\n\t\tif (Validator.isNotNull(template)) {\n\t\t\tcompleteArgs.add(\"--template\");\n\t\t\tcompleteArgs.add(template);\n\t\t}\n\n\t\tfor (String arg : args) {\n\t\t\tcompleteArgs.add(arg);\n\t\t}\n\n\t\tProjectTemplates.main(\n\t\t\tcompleteArgs.toArray(new String[completeArgs.size()]));\n\n\t\tFile gradleProjectDir = new File(destinationDir, name);\n\n\t\t_testExists(gradleProjectDir, \".gitignore\");\n\t\t_testExists(gradleProjectDir, \"build.gradle\");\n\t\t_testExists(gradleProjectDir, \"gradlew\");\n\t\t_testExists(gradleProjectDir, \"gradlew.bat\");\n\t\t_testExists(gradleProjectDir, \"gradle/wrapper/gradle-wrapper.jar\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"gradle/wrapper/gradle-wrapper.properties\");\n\t\t_testNotExists(gradleProjectDir, \"pom.xml\");\n\n\t\treturn gradleProjectDir;\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateActivator() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"activator\", \"bar-activator\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/bar/activator/BarActivator.java\",\n\t\t\t\"public class BarActivator implements BundleActivator {\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/bar.activator-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/bar.activator-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"activator\", \"bar-activator\", \"-Dpackage=bar.activator\",\n\t\t\t\"-DclassName=BarActivator\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/bar-activator-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/bar-activator-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80718,"modified_method":"@Test\n\tpublic void testBuildTemplateActivator() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"activator\", \"bar-activator\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"activator\", \"bar-activator\", \"-Dpackage=bar.activator\",\n\t\t\t\t\"-DclassName=BarActivator\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/bar/activator/BarActivator.java\",\n\t\t\t\"public class BarActivator implements BundleActivator {\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/bar.activator-1.0.0.jar\",\n\t\t\t\t\"target/bar-activator-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateMVCPortletWithPackage() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"mvcportlet\", \"foo\", \"--package-name\", \"com.liferay.test\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/com/liferay/test/portlet/FooPortlet.java\",\n\t\t\t\"public class FooPortlet extends MVCPortlet {\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/com.liferay.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/com.liferay.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"mvcportlet\", \"foo\", \"-Dpackage=com.liferay.test\",\n\t\t\t\"-DclassName=Foo\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80719,"modified_method":"@Test\n\tpublic void testBuildTemplateMVCPortletWithPackage() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"mvcportlet\", \"foo\", \"--package-name\", \"com.liferay.test\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"mvcportlet\", \"foo\", \"-Dpackage=com.liferay.test\",\n\t\t\t\t\"-DclassName=Foo\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/com/liferay/test/portlet/FooPortlet.java\",\n\t\t\t\"public class FooPortlet extends MVCPortlet {\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/com.liferay.test-1.0.0.jar\",\n\t\t\t\t\"target/foo-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _executeGradle(\n\t\t\tFile projectDir, String[] taskPath, String... testTaskPaths)\n\t\tthrows IOException {\n\n\t\tif (Validator.isNotNull(_repositoryUrl)) {\n\t\t\tFile buildGradleFile = new File(projectDir, \"build.gradle\");\n\n\t\t\tPath buildGradlePath = buildGradleFile.toPath();\n\n\t\t\tString buildGradle = FileTestUtil.read(buildGradlePath);\n\n\t\t\tbuildGradle = buildGradle.replace(\n\t\t\t\t\"\\\"\" + _REPOSITORY_CDN_URL + \"\\\"\",\n\t\t\t\t\"\\\"\" + _repositoryUrl + \"\\\"\");\n\n\t\t\tFiles.write(\n\t\t\t\tbuildGradlePath, buildGradle.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\n\t\tGradleRunner gradleRunner = GradleRunner.create();\n\n\t\tif (Validator.isNotNull(_httpProxyHost) &&\n\t\t\tValidator.isNotNull(_httpProxyPort)) {\n\n\t\t\tString[] arguments = new String[taskPath.length + 2];\n\t\t\targuments[0] = \"-Dhttp.proxyHost=\" + _httpProxyHost;\n\t\t\targuments[0] = \"-Dhttp.proxyPort=\" + _httpProxyPort;\n\n\t\t\tSystem.arraycopy(taskPath, 0, arguments, 2, taskPath.length);\n\n\t\t\tgradleRunner.withArguments(arguments);\n\t\t}\n\t\telse {\n\t\t\tgradleRunner.withArguments(taskPath);\n\t\t}\n\n\t\tgradleRunner.withGradleDistribution(_gradleDistribution);\n\t\tgradleRunner.withProjectDir(projectDir);\n\n\t\tBuildResult buildResult = gradleRunner.build();\n\n\t\tif (testTaskPaths.length == 0) {\n\t\t\ttestTaskPaths = taskPath;\n\t\t}\n\n\t\tfor (String testTaskPath : testTaskPaths) {\n\t\t\tBuildTask buildTask = buildResult.task(testTaskPath);\n\n\t\t\tAssert.assertNotNull(\n\t\t\t\t\"Build task \\\"\" + testTaskPath + \"\\\" not found\", buildTask);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unexpected outcome for task \\\"\" + buildTask.getPath() + \"\\\"\",\n\t\t\t\tTaskOutcome.SUCCESS, buildTask.getOutcome());\n\t\t}\n\t}","id":80720,"modified_method":"private void _executeGradle(\n\t\t\tFile gradleProjectDir, String[] taskPath, String... testTaskPaths)\n\t\tthrows IOException {\n\n\t\tif (Validator.isNotNull(_repositoryUrl)) {\n\t\t\tFile buildGradleFile = new File(gradleProjectDir, \"build.gradle\");\n\n\t\t\tPath buildGradlePath = buildGradleFile.toPath();\n\n\t\t\tString buildGradle = FileTestUtil.read(buildGradlePath);\n\n\t\t\tbuildGradle = buildGradle.replace(\n\t\t\t\t\"\\\"\" + _REPOSITORY_CDN_URL + \"\\\"\",\n\t\t\t\t\"\\\"\" + _repositoryUrl + \"\\\"\");\n\n\t\t\tFiles.write(\n\t\t\t\tbuildGradlePath, buildGradle.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\n\t\tGradleRunner gradleRunner = GradleRunner.create();\n\n\t\tif (Validator.isNotNull(_httpProxyHost) &&\n\t\t\tValidator.isNotNull(_httpProxyPort)) {\n\n\t\t\tString[] arguments = new String[taskPath.length + 2];\n\t\t\targuments[0] = \"-Dhttp.proxyHost=\" + _httpProxyHost;\n\t\t\targuments[0] = \"-Dhttp.proxyPort=\" + _httpProxyPort;\n\n\t\t\tSystem.arraycopy(taskPath, 0, arguments, 2, taskPath.length);\n\n\t\t\tgradleRunner.withArguments(arguments);\n\t\t}\n\t\telse {\n\t\t\tgradleRunner.withArguments(taskPath);\n\t\t}\n\n\t\tgradleRunner.withGradleDistribution(_gradleDistribution);\n\t\tgradleRunner.withProjectDir(gradleProjectDir);\n\n\t\tBuildResult buildResult = gradleRunner.build();\n\n\t\tif (testTaskPaths.length == 0) {\n\t\t\ttestTaskPaths = taskPath;\n\t\t}\n\n\t\tfor (String testTaskPath : testTaskPaths) {\n\t\t\tBuildTask buildTask = buildResult.task(testTaskPath);\n\n\t\t\tAssert.assertNotNull(\n\t\t\t\t\"Build task \\\"\" + testTaskPath + \"\\\" not found\", buildTask);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unexpected outcome for task \\\"\" + buildTask.getPath() + \"\\\"\",\n\t\t\t\tTaskOutcome.SUCCESS, buildTask.getOutcome());\n\t\t}\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateMVCPortlet() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\"mvcportlet\", \"foo\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/foo/portlet/FooPortlet.java\",\n\t\t\t\"public class FooPortlet extends MVCPortlet {\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"mvcportlet\", \"foo\", \"-Dpackage=foo\", \"-DclassName=Foo\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80721,"modified_method":"@Test\n\tpublic void testBuildTemplateMVCPortlet() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\"mvcportlet\", \"foo\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"mvcportlet\", \"foo\", \"-Dpackage=foo\", \"-DclassName=Foo\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/foo/portlet/FooPortlet.java\",\n\t\t\t\"public class FooPortlet extends MVCPortlet {\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir, \"build/libs/foo-1.0.0.jar\",\n\t\t\t\t\"target/foo-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplatePortletConfigurationIcon() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"portletconfigurationicon\", \"icontest\", \"--package-name\",\n\t\t\t\"blade.test\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/blade/test/portlet/configuration/icon/\" +\n\t\t\t\"IcontestPortletConfigurationIcon.java\",\n\t\t\t\"public class IcontestPortletConfigurationIcon\",\n\t\t\t\"extends BasePortletConfigurationIcon\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/blade.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/blade.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"portletconfigurationicon\", \"icontest\", \"-Dpackage=blade.test\",\n\t\t\t\"-DclassName=Icontest\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/icontest-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/icontest-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80722,"modified_method":"@Test\n\tpublic void testBuildTemplatePortletConfigurationIcon() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"portletconfigurationicon\", \"icontest\", \"--package-name\",\n\t\t\t\"blade.test\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"portletconfigurationicon\", \"icontest\", \"-Dpackage=blade.test\",\n\t\t\t\t\"-DclassName=Icontest\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/blade/test/portlet/configuration/icon/\" +\n\t\t\t\"IcontestPortletConfigurationIcon.java\",\n\t\t\t\"public class IcontestPortletConfigurationIcon\",\n\t\t\t\"extends BasePortletConfigurationIcon\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/blade.test-1.0.0.jar\", \"target/icontest-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateContentTargetingReport() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"contenttargetingreport\", \"foo-bar\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/foo/bar/content/targeting/report/FooBarReport.java\",\n\t\t\t\"public class FooBarReport extends BaseJSPReport\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"contenttargetingreport\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\"-DclassName=FooBar\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80723,"modified_method":"@Test\n\tpublic void testBuildTemplateContentTargetingReport() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"contenttargetingreport\", \"foo-bar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"contenttargetingreport\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\t\"-DclassName=FooBar\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/foo/bar/content/targeting/report/FooBarReport.java\",\n\t\t\t\"public class FooBarReport extends BaseJSPReport\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/foo.bar-1.0.0.jar\", \"target/foo-bar-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateWithPackageName() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\tnull, \"barfoo\", \"--package-name\", \"foo.bar\");\n\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tprojectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(projectDir, \"bnd.bnd\", \"Bundle-SymbolicName: foo.bar\");\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"mvcportlet\", \"barfoo\", \"-Dpackage=foo.bar\", \"-DclassName=Barfoo\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/barfoo-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/barfoo-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80724,"modified_method":"@Test\n\tpublic void testBuildTemplateWithPackageName() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\tnull, \"barfoo\", \"--package-name\", \"foo.bar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"mvcportlet\", \"barfoo\", \"-Dpackage=foo.bar\",\n\t\t\t\t\"-DclassName=Barfoo\");\n\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/init.jsp\");\n\t\t_testExists(\n\t\t\tgradleProjectDir, \"src/main/resources/META-INF/resources/view.jsp\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"bnd.bnd\", \"Bundle-SymbolicName: foo.bar\");\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/foo.bar-1.0.0.jar\", \"target/barfoo-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _writeServiceClass(File projectDir) throws IOException {\n\t\tString importLine =\n\t\t\t\"import com.liferay.portal.kernel.events.LifecycleAction;\";\n\t\t\tString classLine =\n\t\t\t\t\"public class FooAction implements LifecycleAction {\";\n\n\t\t\tFile actionJavaFile = _testContains(\n\t\t\t\tprojectDir, \"src/main/java/servicepreaction/FooAction.java\",\n\t\t\t\t\"package servicepreaction;\", importLine,\n\t\t\t\t\"service = LifecycleAction.class\", classLine);\n\n\t\t\tPath actionJavaPath = actionJavaFile.toPath();\n\n\t\t\tList<String> lines = Files.readAllLines(\n\t\t\t\tactionJavaPath, StandardCharsets.UTF_8);\n\n\t\t\ttry (BufferedWriter bufferedWriter = Files.newBufferedWriter(\n\t\t\t\t\tactionJavaPath, StandardCharsets.UTF_8)) {\n\n\t\t\t\tfor (String line : lines) {\n\t\t\t\t\t_write(bufferedWriter, line);\n\n\t\t\t\t\tif (line.equals(classLine)) {\n\t\t\t\t\t\t_write(\n\t\t\t\t\t\t\tbufferedWriter, \"@Override\",\n\t\t\t\t\t\t\t\"public void processLifecycleEvent(\",\n\t\t\t\t\t\t\t\"LifecycleEvent lifecycleEvent)\",\n\t\t\t\t\t\t\t\"throws ActionException {\", \"System.out.println(\",\n\t\t\t\t\t\t\t\"\\\"login.event.pre=\\\" + lifecycleEvent);\", \"}\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (line.equals(importLine)) {\n\t\t\t\t\t\t_write(\n\t\t\t\t\t\t\tbufferedWriter,\n\t\t\t\t\t\t\t\"import com.liferay.portal.kernel.events.\" +\n\t\t\t\t\t\t\t\t\"LifecycleEvent;\",\n\t\t\t\t\t\t\t\"import com.liferay.portal.kernel.events.\" +\n\t\t\t\t\t\t\t\t\"ActionException;\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}","id":80725,"modified_method":"private void _writeServiceClass(File gradleProjectDir) throws IOException {\n\t\tString importLine =\n\t\t\t\"import com.liferay.portal.kernel.events.LifecycleAction;\";\n\t\t\tString classLine =\n\t\t\t\t\"public class FooAction implements LifecycleAction {\";\n\n\t\t\tFile actionJavaFile = _testContains(\n\t\t\t\tgradleProjectDir,\n\t\t\t\t\"src/main/java/servicepreaction/FooAction.java\",\n\t\t\t\t\"package servicepreaction;\", importLine,\n\t\t\t\t\"service = LifecycleAction.class\", classLine);\n\n\t\t\tPath actionJavaPath = actionJavaFile.toPath();\n\n\t\t\tList<String> lines = Files.readAllLines(\n\t\t\t\tactionJavaPath, StandardCharsets.UTF_8);\n\n\t\t\ttry (BufferedWriter bufferedWriter = Files.newBufferedWriter(\n\t\t\t\t\tactionJavaPath, StandardCharsets.UTF_8)) {\n\n\t\t\t\tfor (String line : lines) {\n\t\t\t\t\t_write(bufferedWriter, line);\n\n\t\t\t\t\tif (line.equals(classLine)) {\n\t\t\t\t\t\t_write(\n\t\t\t\t\t\t\tbufferedWriter, \"@Override\",\n\t\t\t\t\t\t\t\"public void processLifecycleEvent(\",\n\t\t\t\t\t\t\t\"LifecycleEvent lifecycleEvent)\",\n\t\t\t\t\t\t\t\"throws ActionException {\", \"System.out.println(\",\n\t\t\t\t\t\t\t\"\\\"login.event.pre=\\\" + lifecycleEvent);\", \"}\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (line.equals(importLine)) {\n\t\t\t\t\t\t_write(\n\t\t\t\t\t\t\tbufferedWriter,\n\t\t\t\t\t\t\t\"import com.liferay.portal.kernel.events.\" +\n\t\t\t\t\t\t\t\t\"LifecycleEvent;\",\n\t\t\t\t\t\t\t\"import com.liferay.portal.kernel.events.\" +\n\t\t\t\t\t\t\t\t\"ActionException;\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _testBuildTemplateServiceBuilder(\n\t\t\tString name, String packageName)\n\t\tthrows Exception {\n\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"servicebuilder\", name, \"--package-name\", packageName);\n\n\t\tString apiProjectName = name + \"-api\";\n\t\tString serviceProjectName = name + \"-service\";\n\n\t\t_testContains(\n\t\t\tprojectDir, \"settings.gradle\",\n\t\t\t\"include \\\"\" + apiProjectName + \"\\\", \\\"\" + serviceProjectName +\n\t\t\t\t\"\\\"\");\n\n\t\t_testContains(\n\t\t\tprojectDir, apiProjectName + \"/bnd.bnd\", \"Export-Package:\\\\\",\n\t\t\tpackageName + \".exception,\\\\\", packageName + \".model,\\\\\",\n\t\t\tpackageName + \".service,\\\\\", packageName + \".service.persistence\");\n\n\t\t_testContains(\n\t\t\tprojectDir, serviceProjectName + \"/bnd.bnd\",\n\t\t\t\"Liferay-Service: true\");\n\n\t\t_testContains(\n\t\t\tprojectDir, serviceProjectName + \"/build.gradle\",\n\t\t\t\"compileOnly project(\\\":\" + apiProjectName + \"\\\")\");\n\n\t\tString[] tasks =\n\t\t\tnew String[] {\":\" + serviceProjectName + \":buildService\"};\n\n\t\t_executeGradle(projectDir, tasks);\n\n\t\ttasks =\n\t\t\tnew String[] {\":\" + apiProjectName + \":build\",\n\t\t\t\":\" + serviceProjectName +\n\t\t\t\t\":build\"\n\t\t\t};\n\n\t\t_executeGradle(projectDir, tasks);\n\n\t\t_testExists(\n\t\t\tprojectDir,\n\t\t\tapiProjectName + \"/build/libs/\" + packageName + \".api-1.0.0.jar\");\n\n\t\t_testExists(\n\t\t\tprojectDir,\n\t\t\tserviceProjectName + \"/build/libs/\" + packageName +\n\t\t\t\t\".service-1.0.0.jar\");\n\n\t\tFile gradleBundleApiFile = new File(\n\t\t\t\tprojectDir,\n\t\t\t\tapiProjectName + \"/build/libs/\" + packageName +\n\t\t\t\t\t\".api-1.0.0.jar\");\n\n\t\tFile gradleBundleServiceFile = new File(\n\t\t\t\tprojectDir, serviceProjectName + \"/build/libs/\" + packageName +\n\t\t\t\t\".service-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"servicebuilder\", name, \"-Dpackage=\" + packageName);\n\n\t\t_testContains(\n\t\t\tprojectDir, \"settings.gradle\",\n\t\t\t\"include \\\"\" + apiProjectName + \"\\\", \\\"\" + serviceProjectName +\n\t\t\t\t\"\\\"\");\n\n\t\t_testContains(\n\t\t\tprojectDir, apiProjectName + \"/bnd.bnd\", \"Export-Package:\\\\\",\n\t\t\tpackageName + \".exception,\\\\\", packageName + \".model,\\\\\",\n\t\t\tpackageName + \".service,\\\\\", packageName + \".service.persistence\");\n\n\t\t_testContains(\n\t\t\tprojectDir, serviceProjectName + \"/bnd.bnd\",\n\t\t\t\"Liferay-Service: true\");\n\n\t\t_testContains(\n\t\t\tprojectDir, serviceProjectName + \"/build.gradle\",\n\t\t\t\"compileOnly project(\\\":\" + apiProjectName + \"\\\")\");\n\n\t\t_executeMaven(\n\t\t\tnew File(mavenProjectDir, serviceProjectName),\n\t\t\tnew String[] {\"-U\", \"liferay:build-service\"});\n\t\t\t\t\n\t\tFile gradleServiceProps = new File(\n\t\t\t\tprojectDir,\n\t\t\t\tserviceProjectName + \"/src/main/resources/service.properties\");\n\t\tFile mavenServiceProps = new File(\n\t\t\t\tmavenProjectDir,\n\t\t\t\tserviceProjectName + \"/src/main/resources/service.properties\");\n\t\t\n\t\tFiles.copy(gradleServiceProps.toPath(), mavenServiceProps.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\t\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(\n\t\t\t\tmavenProjectDir,\n\t\t\t\tapiProjectName + \"/target/\" + name + \"-api-1.0.0.jar\");\n\n\t\t_testExists(\n\t\t\t\tmavenProjectDir,\n\t\t\t\tserviceProjectName + \"/target/\" + name + \"-service-1.0.0.jar\");\n\n\t\tFile mavenBundleApiFile = new File(\n\t\t\tmavenProjectDir,\n\t\t\tapiProjectName + \"/target/\" + name + \"-api-1.0.0.jar\");\n\n\t\tFile mavenBundleServiceFile = new File(\n\t\t\t\tmavenProjectDir,\n\t\t\t\tserviceProjectName + \"/target/\" + name + \"-service-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleApiFile, mavenBundleApiFile);\n\t\t_executeBndDiff(gradleBundleServiceFile, mavenBundleServiceFile);\n\t}","id":80726,"modified_method":"private void _testBuildTemplateServiceBuilder(\n\t\t\tString name, String packageName)\n\t\tthrows Exception {\n\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"servicebuilder\", name, \"--package-name\", packageName);\n\n\t\tString apiProjectName = name + \"-api\";\n\t\tString serviceProjectName = name + \"-service\";\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"settings.gradle\",\n\t\t\t\"include \\\"\" + apiProjectName + \"\\\", \\\"\" + serviceProjectName +\n\t\t\t\t\"\\\"\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, apiProjectName + \"/bnd.bnd\", \"Export-Package:\\\\\",\n\t\t\tpackageName + \".exception,\\\\\", packageName + \".model,\\\\\",\n\t\t\tpackageName + \".service,\\\\\", packageName + \".service.persistence\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, serviceProjectName + \"/bnd.bnd\",\n\t\t\t\"Liferay-Service: true\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, serviceProjectName + \"/build.gradle\",\n\t\t\t\"compileOnly project(\\\":\" + apiProjectName + \"\\\")\");\n\n\t\tString[] tasks =\n\t\t\tnew String[] {\":\" + serviceProjectName + \":buildService\"};\n\n\t\t_executeGradle(gradleProjectDir, tasks);\n\n\t\ttasks =\n\t\t\tnew String[] {\":\" + apiProjectName + \":build\",\n\t\t\t\":\" + serviceProjectName +\n\t\t\t\t\":build\"\n\t\t\t};\n\n\t\t_executeGradle(gradleProjectDir, tasks);\n\n\t\tFile gradleBundleApiFile = _testExists(\n\t\t\t\t\t\t\t\t\t\tgradleProjectDir, apiProjectName +\n\t\t\t\t\t\t\t\t\t\t\"/build/libs/\" +\n\t\t\t\t\t\t\t\t\t\tpackageName +\n\t\t\t\t\t\t\t\t\t\t\".api-1.0.0.jar\");\n\n\t\tFile gradleBundleServiceFile = _testExists(\n\t\t\t\t\t\t\t\t\t\t\tgradleProjectDir,\n\t\t\t\t\t\t\t\t\t\t\tserviceProjectName +\n\t\t\t\t\t\t\t\t\t\t\t\"/build/libs/\" +\n\t\t\t\t\t\t\t\t\t\t\tpackageName +\n\t\t\t\t\t\t\t\t\t\t\t\".service-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"servicebuilder\", name, \"-Dpackage=\" + packageName);\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"settings.gradle\",\n\t\t\t\"include \\\"\" + apiProjectName + \"\\\", \\\"\" + serviceProjectName +\n\t\t\t\t\"\\\"\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, apiProjectName + \"/bnd.bnd\", \"Export-Package:\\\\\",\n\t\t\tpackageName + \".exception,\\\\\", packageName + \".model,\\\\\",\n\t\t\tpackageName + \".service,\\\\\", packageName + \".service.persistence\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, serviceProjectName + \"/bnd.bnd\",\n\t\t\t\"Liferay-Service: true\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, serviceProjectName + \"/build.gradle\",\n\t\t\t\"compileOnly project(\\\":\" + apiProjectName + \"\\\")\");\n\n\t\t_executeMaven(\n\t\t\tnew File(mavenProjectDir, serviceProjectName),\n\t\t\tnew String[] {\"-U\", \"liferay:build-service\"});\n\n\t\tFile gradleServiceProps = new File(\n\t\t\t\tgradleProjectDir,\n\t\t\t\tserviceProjectName + \"/src/main/resources/service.properties\");\n\n\t\tFile mavenServiceProps = new File(\n\t\t\t\tmavenProjectDir,\n\t\t\t\tserviceProjectName + \"/src/main/resources/service.properties\");\n\n\t\tFiles.copy(\n\t\t\tgradleServiceProps.toPath(), mavenServiceProps.toPath(),\n\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\tFile mavenBundleApiFile = _testExists(\n\t\t\t\t\t\t\t\t\tmavenProjectDir,\n\t\t\t\t\t\t\t\t\tapiProjectName + \"/target/\" + name +\n\t\t\t\t\t\t\t\t\t\t\"-api-1.0.0.jar\");\n\t\tFile mavenBundleServiceFile = _testExists(\n\t\t\t\t\t\t\t\t\t\tmavenProjectDir,\n\t\t\t\t\t\t\t\t\t\tserviceProjectName + \"/target/\" + name +\n\t\t\t\t\t\t\t\t\t\t\t\"-service-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleApiFile, mavenBundleApiFile);\n\t\t_executeBndDiff(gradleBundleServiceFile, mavenBundleServiceFile);\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateControlMenuEntry() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"controlmenuentry\", \"foo-bar\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/foo/bar/control/menu/\" +\n\t\t\t\"FooBarProductNavigationControlMenuEntry.java\",\n\t\t\t\"public class FooBarProductNavigationControlMenuEntry\",\n\t\t\t\"extends BaseProductNavigationControlMenuEntry\",\n\t\t\t\"implements ProductNavigationControlMenuEntry\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"controlmenuentry\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\"-DclassName=FooBar\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80727,"modified_method":"@Test\n\tpublic void testBuildTemplateControlMenuEntry() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"controlmenuentry\", \"foo-bar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"controlmenuentry\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\t\"-DclassName=FooBar\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/foo/bar/control/menu/\" +\n\t\t\t\"FooBarProductNavigationControlMenuEntry.java\",\n\t\t\t\"public class FooBarProductNavigationControlMenuEntry\",\n\t\t\t\"extends BaseProductNavigationControlMenuEntry\",\n\t\t\t\"implements ProductNavigationControlMenuEntry\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/foo.bar-1.0.0.jar\", \"target/foo-bar-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplatePortletToolbarContributor() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"portlettoolbarcontributor\", \"toolbartest\", \"--package-name\",\n\t\t\t\"blade.test\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/blade/test/portlet/toolbar/contributor/\" +\n\t\t\t\"ToolbartestPortletToolbarContributor.java\",\n\t\t\t\"public class ToolbartestPortletToolbarContributor\",\n\t\t\t\"implements PortletToolbarContributor\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/blade.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/blade.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"portlettoolbarcontributor\", \"toolbartest\", \"-Dpackage=blade.test\",\n\t\t\t\"-DclassName=Toolbartest\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/toolbartest-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/toolbartest-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80728,"modified_method":"@Test\n\tpublic void testBuildTemplatePortletToolbarContributor() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"portlettoolbarcontributor\", \"toolbartest\", \"--package-name\",\n\t\t\t\"blade.test\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"portlettoolbarcontributor\", \"toolbartest\",\n\t\t\t\t\"-Dpackage=blade.test\", \"-DclassName=Toolbartest\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/blade/test/portlet/toolbar/contributor/\" +\n\t\t\t\"ToolbartestPortletToolbarContributor.java\",\n\t\t\t\"public class ToolbartestPortletToolbarContributor\",\n\t\t\t\"implements PortletToolbarContributor\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/blade.test-1.0.0.jar\",\n\t\t\t\t\"target/toolbartest-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateFragment() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"fragment\", \"loginHook\", \"--host-bundle-symbolic-name\",\n\t\t\t\"com.liferay.login.web\", \"--host-bundle-version\", \"1.0.0\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"bnd.bnd\", \"Bundle-SymbolicName: loginhook\",\n\t\t\t\"Fragment-Host: com.liferay.login.web;bundle-version=\\\"1.0.0\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/loginhook-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/loginhook-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"fragment\", \"loginHook\", \"-Dpackage=loginhook\",\n\t\t\t\"-DhostBundleSymbolicName=com.liferay.login.web\",\n\t\t\t\"-DhostBundleVersion=1.0.0\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/loginhook-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/loginhook-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80729,"modified_method":"@Test\n\tpublic void testBuildTemplateFragment() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"fragment\", \"loginHook\", \"--host-bundle-symbolic-name\",\n\t\t\t\"com.liferay.login.web\", \"--host-bundle-version\", \"1.0.0\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"fragment\", \"loginHook\", \"-Dpackage=loginhook\",\n\t\t\t\t\"-DhostBundleSymbolicName=com.liferay.login.web\",\n\t\t\t\t\"-DhostBundleVersion=1.0.0\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"bnd.bnd\", \"Bundle-SymbolicName: loginhook\",\n\t\t\t\"Fragment-Host: com.liferay.login.web;bundle-version=\\\"1.0.0\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/loginhook-1.0.0.jar\", \"target/loginhook-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private File _buildTemplateWithMaven(\n\t\t\tString template, String name, String... args)\n\t\tthrows Exception {\n\n\t\tFile destinationDir = new File(temporaryFolder.getRoot(), \"maven\");\n\n\t\tList<String> completeArgs = new ArrayList<>();\n\n\t\tcompleteArgs.add(\"archetype:generate\");\n\t\tcompleteArgs.add(\"-B\");\n\n\t\tif (Validator.isNotNull(template)) {\n\t\t\tcompleteArgs.add(\n\t\t\t\t\t\"-DarchetypeArtifactId=com.liferay.project.templates.\" +\n\t\t\t\t\t\ttemplate);\n\t\t}\n\n\t\tcompleteArgs.add(\"-DarchetypeGroupId=com.liferay\");\n\t\tcompleteArgs.add(\"-DarchetypeVersion=1.0.0\");\n\t\tcompleteArgs.add(\"-DgroupId=com.test\");\n\t\tcompleteArgs.add(\"-DartifactId=\" + name);\n\t\tcompleteArgs.add(\"-Dversion=1.0.0\");\n\t\tcompleteArgs.add(\"-DprojectType=standalone\");\n\n\t\tfor (String arg : args) {\n\t\t\tcompleteArgs.add(arg);\n\t\t}\n\n\t\t_executeMaven(destinationDir, completeArgs.toArray(new String[0]));\n\n\t\tFile projectDir = new File(destinationDir, name);\n\n\t\t_testExists(projectDir, \"pom.xml\");\n\t\t_testNotExists(projectDir, \"gradlew\");\n\t\t_testNotExists(projectDir, \"gradlew.bat\");\n\t\t_testNotExists(projectDir, \"gradle/wrapper/gradle-wrapper.jar\");\n\t\t_testNotExists(projectDir, \"gradle/wrapper/gradle-wrapper.properties\");\n\n\t\treturn projectDir;\n\t}","id":80730,"modified_method":"private File _buildTemplateWithMaven(\n\t\t\tString template, String name, String... args)\n\t\tthrows Exception {\n\n\t\tFile destinationDir = new File(temporaryFolder.getRoot(), \"maven\");\n\n\t\tList<String> completeArgs = new ArrayList<>();\n\n\t\tcompleteArgs.add(\"archetype:generate\");\n\t\tcompleteArgs.add(\"-B\");\n\n\t\tif (Validator.isNotNull(template)) {\n\t\t\tcompleteArgs.add(\n\t\t\t\t\t\"-DarchetypeArtifactId=com.liferay.project.templates.\" +\n\t\t\t\t\t\ttemplate);\n\t\t}\n\n\t\tcompleteArgs.add(\"-DarchetypeGroupId=com.liferay\");\n\t\tcompleteArgs.add(\"-DarchetypeVersion=1.0.0\");\n\t\tcompleteArgs.add(\"-DgroupId=com.test\");\n\t\tcompleteArgs.add(\"-DartifactId=\" + name);\n\t\tcompleteArgs.add(\"-Dversion=1.0.0\");\n\t\tcompleteArgs.add(\"-DprojectType=standalone\");\n\n\t\tfor (String arg : args) {\n\t\t\tcompleteArgs.add(arg);\n\t\t}\n\n\t\t_executeMaven(destinationDir, completeArgs.toArray(new String[0]));\n\n\t\tFile gradleProjectDir = new File(destinationDir, name);\n\n\t\t_testExists(gradleProjectDir, \"pom.xml\");\n\t\t_testNotExists(gradleProjectDir, \"gradlew\");\n\t\t_testNotExists(gradleProjectDir, \"gradlew.bat\");\n\t\t_testNotExists(gradleProjectDir, \"gradle/wrapper/gradle-wrapper.jar\");\n\t\t_testNotExists(\n\t\t\tgradleProjectDir, \"gradle/wrapper/gradle-wrapper.properties\");\n\n\t\treturn gradleProjectDir;\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateApi() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\"api\", \"foo\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/foo/api/Foo.java\",\n\t\t\t\"public interface Foo\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"api\", \"foo\", \"-Dpackage=foo\", \"-DclassName=Foo\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80731,"modified_method":"@Test\n\tpublic void testBuildTemplateApi() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\"api\", \"foo\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"api\", \"foo\", \"-Dpackage=foo\", \"-DclassName=Foo\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/foo/api/Foo.java\",\n\t\t\t\"public interface Foo\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir, \"build/libs/foo-1.0.0.jar\",\n\t\t\t\t\"target/foo-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateContentTargetingTrackingAction()\n\t\tthrows Exception {\n\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"contenttargetingtrackingaction\", \"foo-bar\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/foo/bar/content/targeting/tracking/action/\" +\n\t\t\t\"FooBarTrackingAction.java\",\n\t\t\t\"public class FooBarTrackingAction extends BaseJSPTrackingAction\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"contenttargetingtrackingaction\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\"-DclassName=FooBar\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80732,"modified_method":"@Test\n\tpublic void testBuildTemplateContentTargetingTrackingAction()\n\t\tthrows Exception {\n\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"contenttargetingtrackingaction\", \"foo-bar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"contenttargetingtrackingaction\", \"foo-bar\",\n\t\t\t\t\"-Dpackage=foo.bar\", \"-DclassName=FooBar\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/foo/bar/content/targeting/tracking/action/\" +\n\t\t\t\"FooBarTrackingAction.java\",\n\t\t\t\"public class FooBarTrackingAction extends BaseJSPTrackingAction\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/foo.bar-1.0.0.jar\", \"target/foo-bar-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplatePanelApp() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"panelapp\", \"gradle.test\", \"--class-name\", \"Foo\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\t\t_testExists(projectDir, \"build.gradle\");\n\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/gradle/test/application/list/FooPanelApp.java\",\n\t\t\t\"public class FooPanelApp extends BasePanelApp\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/gradle.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/gradle.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"panelapp\", \"gradle.test\", \"-Dpackage=gradle.test\",\n\t\t\t\"-DclassName=Foo\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/gradle.test-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/gradle.test-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80733,"modified_method":"@Test\n\tpublic void testBuildTemplatePanelApp() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"panelapp\", \"gradle.test\", \"--class-name\", \"Foo\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"panelapp\", \"gradle.test\", \"-Dpackage=gradle.test\",\n\t\t\t\t\"-DclassName=Foo\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\t\t_testExists(gradleProjectDir, \"build.gradle\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/gradle/test/application/list/FooPanelApp.java\",\n\t\t\t\"public class FooPanelApp extends BasePanelApp\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/gradle.test-1.0.0.jar\",\n\t\t\t\t\"target/gradle.test-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplatePortletProvider() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"portletprovider\", \"provider.test\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\t\t_testExists(projectDir, \"build.gradle\");\n\n\t\tString filePath = \"src/main/java/provider/test/constants/\";\n\t\tString fileName = filePath + \"ProviderTestPortletKeys.java\";\n\n\t\t_testContains(\n\t\t\tprojectDir, fileName, \"package provider.test.constants;\",\n\t\t\t\"public class ProviderTestPortletKeys\",\n\t\t\t\"public static final String ProviderTest = \\\"ProviderTest\\\";\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/provider.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/provider.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"portletprovider\", \"provider.test\", \"-Dpackage=provider.test\",\n\t\t\t\"-DclassName=ProviderTest\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/provider.test-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/provider.test-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80734,"modified_method":"@Test\n\tpublic void testBuildTemplatePortletProvider() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"portletprovider\", \"provider.test\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"portletprovider\", \"provider.test\", \"-Dpackage=provider.test\",\n\t\t\t\t\"-DclassName=ProviderTest\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\t\t_testExists(gradleProjectDir, \"build.gradle\");\n\n\t\tString filePath = \"src/main/java/provider/test/constants/\";\n\t\tString fileName = filePath + \"ProviderTestPortletKeys.java\";\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, fileName, \"package provider.test.constants;\",\n\t\t\t\"public class ProviderTestPortletKeys\",\n\t\t\t\"public static final String ProviderTest = \\\"ProviderTest\\\";\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/provider.test-1.0.0.jar\",\n\t\t\t\t\"target/provider.test-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplateContentTargetingRule() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"contenttargetingrule\", \"foo-bar\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir,\n\t\t\t\"src/main/java/foo/bar/content/targeting/rule/FooBarRule.java\",\n\t\t\t\"public class FooBarRule extends BaseJSPRule\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo.bar-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"contenttargetingrule\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\"-DclassName=FooBar\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo-bar-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80735,"modified_method":"@Test\n\tpublic void testBuildTemplateContentTargetingRule() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"contenttargetingrule\", \"foo-bar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\t\"contenttargetingrule\", \"foo-bar\", \"-Dpackage=foo.bar\",\n\t\t\t\t\"-DclassName=FooBar\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir,\n\t\t\t\"src/main/java/foo/bar/content/targeting/rule/FooBarRule.java\",\n\t\t\t\"public class FooBarRule extends BaseJSPRule\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/foo.bar-1.0.0.jar\", \"target/foo-bar-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBuildTemplatePortlet() throws Exception {\n\t\tFile projectDir = _buildTemplateWithGradle(\n\t\t\t\"portlet\", \"foo.test\", \"--class-name\", \"Foo\");\n\n\t\t_testExists(projectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tprojectDir, \"build.gradle\", \"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tprojectDir, \"src/main/java/foo/test/portlet/FooPortlet.java\",\n\t\t\t\"package foo.test.portlet;\", \"javax.portlet.display-name=foo.test\",\n\t\t\t\"public class FooPortlet extends GenericPortlet {\",\n\t\t\t\"printWriter.print(\\\"foo.test Portlet\");\n\n\t\t_executeGradle(projectDir, _GRADLE_BUILD_ARGS);\n\n\t\t_testExists(projectDir, \"build/libs/foo.test-1.0.0.jar\");\n\n\t\tFile gradleBundleFile = new File(\n\t\t\tprojectDir, \"build/libs/foo.test-1.0.0.jar\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"portlet\", \"foo.test\", \"-Dpackage=foo.test\", \"-DclassName=Foo\");\n\n\t\t_executeMaven(mavenProjectDir, _MAVEN_BUILD_ARGS);\n\n\t\t_testExists(mavenProjectDir, \"target/foo.test-1.0.0.jar\");\n\n\t\tFile mavenBundleFile = new File(\n\t\t\tmavenProjectDir, \"target/foo.test-1.0.0.jar\");\n\n\t\t_executeBndDiff(gradleBundleFile, mavenBundleFile);\n\t}","id":80736,"modified_method":"@Test\n\tpublic void testBuildTemplatePortlet() throws Exception {\n\t\tFile gradleProjectDir = _buildTemplateWithGradle(\n\t\t\t\"portlet\", \"foo.test\", \"--class-name\", \"Foo\");\n\n\t\tFile mavenProjectDir = _buildTemplateWithMaven(\n\t\t\t\"portlet\", \"foo.test\", \"-Dpackage=foo.test\", \"-DclassName=Foo\");\n\n\t\t_testExists(gradleProjectDir, \"bnd.bnd\");\n\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"build.gradle\",\n\t\t\t\"apply plugin: \\\"com.liferay.plugin\\\"\");\n\t\t_testContains(\n\t\t\tgradleProjectDir, \"src/main/java/foo/test/portlet/FooPortlet.java\",\n\t\t\t\"package foo.test.portlet;\", \"javax.portlet.display-name=foo.test\",\n\t\t\t\"public class FooPortlet extends GenericPortlet {\",\n\t\t\t\"printWriter.print(\\\"foo.test Portlet\");\n\n\t\t_buildProjects(\n\t\t\t\tgradleProjectDir, mavenProjectDir,\n\t\t\t\t\"build/libs/foo.test-1.0.0.jar\", \"target/foo.test-1.0.0.jar\");\n\t}","commit_id":"e47571efa965435f59f9e517166b1e0eb16e82ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static UserVmResponse createUserVmResponse (UserVm userVm) {\n       UserVmResponse userVmResponse = new UserVmResponse();\n       \n       Account acct = ApiDBUtils.findAccountById(Long.valueOf(userVm.getAccountId()));\n       //FIXME - this check should be done in searchForUserVm method in ManagementServerImpl; \n       //otherwise the number of vms returned is not going to match pageSize request parameter\n       if ((acct != null) && (acct.getRemoved() == null)) {\n           userVmResponse.setAccountName(acct.getAccountName());\n           userVmResponse.setDomainId(acct.getDomainId());\n           userVmResponse.setDomainName(ApiDBUtils.findDomainById(acct.getDomainId()).getName());\n       } else {\n           return null; // the account has been deleted, skip this VM in the response\n       }\n\n       userVmResponse.setId(userVm.getId());\n       AsyncJobVO asyncJob = ApiDBUtils.findInstancePendingAsyncJob(\"vm_instance\", userVm.getId());\n       if (asyncJob != null) {\n           userVmResponse.setJobId(asyncJob.getId());\n           userVmResponse.setJobStatus(asyncJob.getStatus());\n       } \n\n       userVmResponse.setName(userVm.getHostName());\n       userVmResponse.setCreated(userVm.getCreated());\n       userVmResponse.setIpAddress(userVm.getPrivateIpAddress());\n       if (userVm.getState() != null) {\n           userVmResponse.setState(userVm.getState().toString());\n       }\n\n\n       userVmResponse.setHaEnable(userVm.isHaEnabled());\n       \n       if (userVm.getDisplayName() != null) {\n           userVmResponse.setDisplayName(userVm.getDisplayName());\n       } else {\n           userVmResponse.setDisplayName(userVm.getHostName());\n       }\n\n       InstanceGroupVO group = ApiDBUtils.findInstanceGroupForVM(userVm.getId());\n       if (group != null) {\n           userVmResponse.setGroup(group.getName());\n           userVmResponse.setGroupId(group.getId());\n       }\n\n       // Data Center Info\n       userVmResponse.setZoneId(userVm.getDataCenterId());\n       userVmResponse.setZoneName(ApiDBUtils.findZoneById(userVm.getDataCenterId()).getName());\n\n       Account account = UserContext.current().getAccount();\n       //if user is an admin, display host id\n       if (((account == null) || (account.getType() == Account.ACCOUNT_TYPE_ADMIN)) && (userVm.getHostId() != null)) {\n           userVmResponse.setHostId(userVm.getHostId());\n           userVmResponse.setHostName(ApiDBUtils.findHostById(userVm.getHostId()).getName());\n       }\n       \n       // Template Info\n       VMTemplateVO template = ApiDBUtils.findTemplateById(userVm.getTemplateId());\n       if (template != null) {\n           userVmResponse.setTemplateId(userVm.getTemplateId());\n           userVmResponse.setTemplateName(template.getName());\n           userVmResponse.setTemplateDisplayText(template.getDisplayText());\n           userVmResponse.setPasswordEnabled(template.getEnablePassword());\n       } else {\n           userVmResponse.setTemplateId(-1L);\n           userVmResponse.setTemplateName(\"ISO Boot\");\n           userVmResponse.setTemplateDisplayText(\"ISO Boot\");\n           userVmResponse.setPasswordEnabled(false);\n       }\n\n       // ISO Info\n       if (userVm.getIsoId() != null) {\n           VMTemplateVO iso = ApiDBUtils.findTemplateById(userVm.getIsoId().longValue());\n           if (iso != null) {\n               userVmResponse.setIsoId(userVm.getIsoId());\n               userVmResponse.setIsoName(iso.getName());\n           }\n       }\n\n       // Service Offering Info\n       ServiceOffering offering = ApiDBUtils.findServiceOfferingById(userVm.getServiceOfferingId());\n       userVmResponse.setServiceOfferingId(userVm.getServiceOfferingId());\n       userVmResponse.setServiceOfferingName(offering.getName());\n       userVmResponse.setCpuNumber(offering.getCpu());\n       userVmResponse.setCpuSpeed(offering.getSpeed());\n       userVmResponse.setMemory(offering.getRamSize());\n\n       VolumeVO rootVolume = ApiDBUtils.findRootVolume(userVm.getId());\n       if (rootVolume != null) {\n           userVmResponse.setRootDeviceId(rootVolume.getDeviceId());\n           StoragePoolVO storagePool = ApiDBUtils.findStoragePoolById(rootVolume.getPoolId());\n           userVmResponse.setRootDeviceType(storagePool.getPoolType().toString());\n       }\n\n       //stats calculation\n       DecimalFormat decimalFormat = new DecimalFormat(\"#.##\");\n       String cpuUsed = null;\n       VmStats vmStats = ApiDBUtils.getVmStatistics(userVm.getId());\n       if (vmStats != null) {\n           float cpuUtil = (float) vmStats.getCPUUtilization();\n           cpuUsed = decimalFormat.format(cpuUtil) + \"%\";\n           userVmResponse.setCpuUsed(cpuUsed);\n\n           long networkKbRead = (long)vmStats.getNetworkReadKBs();\n           userVmResponse.setNetworkKbsRead(networkKbRead);\n           \n           long networkKbWrite = (long)vmStats.getNetworkWriteKBs();\n           userVmResponse.setNetworkKbsWrite(networkKbWrite);\n       }\n       \n       userVmResponse.setGuestOsId(userVm.getGuestOSId());\n       //network groups\n       userVmResponse.setNetworkGroupList(ApiDBUtils.getNetworkGroupsNamesForVm(userVm.getId()));\n       \n       return userVmResponse;\n   }","id":80737,"modified_method":"public static UserVmResponse createUserVmResponse (UserVm userVm) {\n       UserVmResponse userVmResponse = new UserVmResponse();\n       \n       Account acct = ApiDBUtils.findAccountById(Long.valueOf(userVm.getAccountId()));\n       //FIXME - this check should be done in searchForUserVm method in ManagementServerImpl; \n       //otherwise the number of vms returned is not going to match pageSize request parameter\n       if ((acct != null) && (acct.getRemoved() == null)) {\n           userVmResponse.setAccountName(acct.getAccountName());\n           userVmResponse.setDomainId(acct.getDomainId());\n           userVmResponse.setDomainName(ApiDBUtils.findDomainById(acct.getDomainId()).getName());\n       } else {\n           return null; // the account has been deleted, skip this VM in the response\n       }\n\n       userVmResponse.setId(userVm.getId());\n       AsyncJobVO asyncJob = ApiDBUtils.findInstancePendingAsyncJob(\"vm_instance\", userVm.getId());\n       if (asyncJob != null) {\n           userVmResponse.setJobId(asyncJob.getId());\n           userVmResponse.setJobStatus(asyncJob.getStatus());\n       } \n\n       userVmResponse.setName(userVm.getHostName());\n       userVmResponse.setCreated(userVm.getCreated());\n       userVmResponse.setIpAddress(userVm.getPrivateIpAddress());\n       if (userVm.getState() != null) {\n           userVmResponse.setState(userVm.getState().toString());\n       }\n\n\n       userVmResponse.setHaEnable(userVm.isHaEnabled());\n       \n       if (userVm.getDisplayName() != null) {\n           userVmResponse.setDisplayName(userVm.getDisplayName());\n       } else {\n           userVmResponse.setDisplayName(userVm.getHostName());\n       }\n\n       InstanceGroupVO group = ApiDBUtils.findInstanceGroupForVM(userVm.getId());\n       if (group != null) {\n           userVmResponse.setGroup(group.getName());\n           userVmResponse.setGroupId(group.getId());\n       }\n\n       // Data Center Info\n       userVmResponse.setZoneId(userVm.getDataCenterId());\n       userVmResponse.setZoneName(ApiDBUtils.findZoneById(userVm.getDataCenterId()).getName());\n\n       Account account = UserContext.current().getAccount();\n       //if user is an admin, display host id\n       if (((account == null) || (account.getType() == Account.ACCOUNT_TYPE_ADMIN)) && (userVm.getHostId() != null)) {\n           userVmResponse.setHostId(userVm.getHostId());\n           userVmResponse.setHostName(ApiDBUtils.findHostById(userVm.getHostId()).getName());\n       }\n       \n       // Template Info\n       VMTemplateVO template = ApiDBUtils.findTemplateById(userVm.getTemplateId());\n       if (template != null) {\n           userVmResponse.setTemplateId(userVm.getTemplateId());\n           userVmResponse.setTemplateName(template.getName());\n           userVmResponse.setTemplateDisplayText(template.getDisplayText());\n           userVmResponse.setPasswordEnabled(template.getEnablePassword());\n       } else {\n           userVmResponse.setTemplateId(-1L);\n           userVmResponse.setTemplateName(\"ISO Boot\");\n           userVmResponse.setTemplateDisplayText(\"ISO Boot\");\n           userVmResponse.setPasswordEnabled(false);\n       }\n\n       // ISO Info\n       if (userVm.getIsoId() != null) {\n           VMTemplateVO iso = ApiDBUtils.findTemplateById(userVm.getIsoId().longValue());\n           if (iso != null) {\n               userVmResponse.setIsoId(userVm.getIsoId());\n               userVmResponse.setIsoName(iso.getName());\n           }\n       }\n\n       // Service Offering Info\n       ServiceOffering offering = ApiDBUtils.findServiceOfferingById(userVm.getServiceOfferingId());\n       userVmResponse.setServiceOfferingId(userVm.getServiceOfferingId());\n       userVmResponse.setServiceOfferingName(offering.getName());\n       userVmResponse.setCpuNumber(offering.getCpu());\n       userVmResponse.setCpuSpeed(offering.getSpeed());\n       userVmResponse.setMemory(offering.getRamSize());\n\n       VolumeVO rootVolume = ApiDBUtils.findRootVolume(userVm.getId());\n       if (rootVolume != null) {\n           userVmResponse.setRootDeviceId(rootVolume.getDeviceId());\n           String rootDeviceType = \"Not created\";\n           if (rootVolume.getPoolId() != null){\n               StoragePoolVO storagePool = ApiDBUtils.findStoragePoolById(rootVolume.getPoolId());\n               rootDeviceType = storagePool.getPoolType().toString();\n           }\n           userVmResponse.setRootDeviceType(rootDeviceType);\n       }\n\n       //stats calculation\n       DecimalFormat decimalFormat = new DecimalFormat(\"#.##\");\n       String cpuUsed = null;\n       VmStats vmStats = ApiDBUtils.getVmStatistics(userVm.getId());\n       if (vmStats != null) {\n           float cpuUtil = (float) vmStats.getCPUUtilization();\n           cpuUsed = decimalFormat.format(cpuUtil) + \"%\";\n           userVmResponse.setCpuUsed(cpuUsed);\n\n           long networkKbRead = (long)vmStats.getNetworkReadKBs();\n           userVmResponse.setNetworkKbsRead(networkKbRead);\n           \n           long networkKbWrite = (long)vmStats.getNetworkWriteKBs();\n           userVmResponse.setNetworkKbsWrite(networkKbWrite);\n       }\n       \n       userVmResponse.setGuestOsId(userVm.getGuestOSId());\n       //network groups\n       userVmResponse.setNetworkGroupList(ApiDBUtils.getNetworkGroupsNamesForVm(userVm.getId()));\n       \n       return userVmResponse;\n   }","commit_id":"e2aa4738ecf99aebf8b9bba3b96a0f803326ec81","url":"https://github.com/apache/cloudstack"},{"original_method":"private static long time(String time) {\n        return ISODateTimeFormat.dateOptionalTimeParser().parseMillis(time);\n    }","id":80738,"modified_method":"private static long time(String time) {\n        return time(time, DateTimeZone.UTC);\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test DayIntervalTimeZoneRounding, (interval &gt;= 12h) with time zone shift\n     */\n    public void testDayIntervalTimeZoneRounding() {\n        Rounding tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(12)).timeZone(DateTimeZone.forOffsetHours(-8)).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T00:01:01\")), equalTo(utc(\"2009-02-02T20:00:00.000Z\")));\n        long roundKey = tzRounding.roundKey(utc(\"2009-02-03T00:01:01\"));\n        assertThat(roundKey, equalTo(tzRounding.roundKey(utc(\"2009-02-02T20:00:00.000Z\"))));\n        assertThat(tzRounding.valueForKey(roundKey), equalTo(utc(\"2009-02-02T20:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-02T20:00:00.000Z\")), equalTo(utc(\"2009-02-03T08:00:00.000Z\")));\n\n        assertThat(tzRounding.round(utc(\"2009-02-03T13:01:01\")), equalTo(utc(\"2009-02-03T08:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T08:00:00.000Z\")), equalTo(utc(\"2009-02-03T20:00:00.000Z\")));\n    }","id":80739,"modified_method":"/**\n     * test DayIntervalTimeZoneRounding, (interval &gt;= 12h) with time zone shift\n     */\n    public void testDayIntervalTimeZoneRounding() {\n        DateTimeZone tz = DateTimeZone.forOffsetHours(-8);\n        Rounding tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(12)).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2009-02-03T00:01:01\")), isDate(time(\"2009-02-02T20:00:00.000Z\"), tz));\n        long roundKey = tzRounding.roundKey(time(\"2009-02-03T00:01:01\"));\n        assertThat(roundKey, isDate(tzRounding.roundKey(time(\"2009-02-02T20:00:00.000Z\")), tz));\n        assertThat(tzRounding.valueForKey(roundKey), isDate(time(\"2009-02-02T20:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-02T20:00:00.000Z\")), isDate(time(\"2009-02-03T08:00:00.000Z\"), tz));\n\n        assertThat(tzRounding.round(time(\"2009-02-03T13:01:01\")), isDate(time(\"2009-02-03T08:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T08:00:00.000Z\")), isDate(time(\"2009-02-03T20:00:00.000Z\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Special test for intervals that don't fit evenly into rounding interval.\n     * In this case, when interval crosses DST transition point, rounding in local\n     * time can land in a DST gap which results in wrong UTC rounding values.\n     */\n    public void testIntervalRounding_NotDivisibleInteval() {\n        DateTimeZone tz = DateTimeZone.forID(\"CET\");\n        long interval = TimeUnit.MINUTES.toMillis(14);\n        TimeZoneRounding rounding = new TimeZoneRounding.TimeIntervalRounding(interval, tz);\n\n        assertThat(rounding.round(time(\"2016-03-27T01:41:00+01:00\")), equalTo(time(\"2016-03-27T01:30:00+01:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T01:51:00+01:00\")), equalTo(time(\"2016-03-27T01:44:00+01:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T01:59:00+01:00\")), equalTo(time(\"2016-03-27T01:58:00+01:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T03:05:00+02:00\")), equalTo(time(\"2016-03-27T03:00:00+02:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T03:12:00+02:00\")), equalTo(time(\"2016-03-27T03:08:00+02:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T03:25:00+02:00\")), equalTo(time(\"2016-03-27T03:22:00+02:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T03:39:00+02:00\")), equalTo(time(\"2016-03-27T03:36:00+02:00\")));\n    }","id":80740,"modified_method":"/**\n     * Special test for intervals that don't fit evenly into rounding interval.\n     * In this case, when interval crosses DST transition point, rounding in local\n     * time can land in a DST gap which results in wrong UTC rounding values.\n     */\n    public void testIntervalRounding_NotDivisibleInteval() {\n        DateTimeZone tz = DateTimeZone.forID(\"CET\");\n        long interval = TimeUnit.MINUTES.toMillis(14);\n        TimeZoneRounding rounding = new TimeZoneRounding.TimeIntervalRounding(interval, tz);\n\n        assertThat(rounding.round(time(\"2016-03-27T01:41:00+01:00\")), isDate(time(\"2016-03-27T01:30:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T01:51:00+01:00\")), isDate(time(\"2016-03-27T01:44:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T01:59:00+01:00\")), isDate(time(\"2016-03-27T01:58:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T03:05:00+02:00\")), isDate(time(\"2016-03-27T03:00:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T03:12:00+02:00\")), isDate(time(\"2016-03-27T03:08:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T03:25:00+02:00\")), isDate(time(\"2016-03-27T03:22:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T03:39:00+02:00\")), isDate(time(\"2016-03-27T03:36:00+02:00\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testTimeTimeZoneRounding() {\n        // hour unit\n        Rounding tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forOffsetHours(-2)).build();\n        assertThat(tzRounding.round(0), equalTo(0L));\n        assertThat(tzRounding.nextRoundingValue(0L), equalTo(TimeValue.timeValueHours(1L).getMillis()));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forOffsetHours(-2)).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T01:01:01\")), equalTo(utc(\"2009-02-03T01:00:00\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T01:00:00\")), equalTo(utc(\"2009-02-03T02:00:00\")));\n    }","id":80741,"modified_method":"public void testTimeTimeZoneRounding() {\n        // hour unit\n        DateTimeZone tz = DateTimeZone.forOffsetHours(-2);\n        Rounding tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(tz).build();\n        assertThat(tzRounding.round(0), equalTo(0L));\n        assertThat(tzRounding.nextRoundingValue(0L), equalTo(TimeValue.timeValueHours(1L).getMillis()));\n\n        assertThat(tzRounding.round(time(\"2009-02-03T01:01:01\")), isDate(time(\"2009-02-03T01:00:00\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T01:00:00\")), isDate(time(\"2009-02-03T02:00:00\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testUTCIntervalRounding() {\n        Rounding tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(12)).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T01:01:01\")), equalTo(utc(\"2009-02-03T00:00:00.000Z\")));\n        long roundKey = tzRounding.roundKey(utc(\"2009-02-03T01:01:01\"));\n        assertThat(roundKey, equalTo(tzRounding.roundKey(utc(\"2009-02-03T00:00:00.000Z\"))));\n        assertThat(tzRounding.valueForKey(roundKey), equalTo(utc(\"2009-02-03T00:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T00:00:00.000Z\")), equalTo(utc(\"2009-02-03T12:00:00.000Z\")));\n        assertThat(tzRounding.round(utc(\"2009-02-03T13:01:01\")), equalTo(utc(\"2009-02-03T12:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T12:00:00.000Z\")), equalTo(utc(\"2009-02-04T00:00:00.000Z\")));\n\n        tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(48)).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T01:01:01\")), equalTo(utc(\"2009-02-03T00:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T00:00:00.000Z\")), equalTo(utc(\"2009-02-05T00:00:00.000Z\")));\n        assertThat(tzRounding.round(utc(\"2009-02-05T13:01:01\")), equalTo(utc(\"2009-02-05T00:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-05T00:00:00.000Z\")), equalTo(utc(\"2009-02-07T00:00:00.000Z\")));\n    }","id":80742,"modified_method":"public void testUTCIntervalRounding() {\n        Rounding tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(12)).build();\n        DateTimeZone tz = DateTimeZone.UTC;\n        assertThat(tzRounding.round(time(\"2009-02-03T01:01:01\")), isDate(time(\"2009-02-03T00:00:00.000Z\"), tz));\n        long roundKey = tzRounding.roundKey(time(\"2009-02-03T01:01:01\"));\n        assertThat(roundKey, isDate(tzRounding.roundKey(time(\"2009-02-03T00:00:00.000Z\")), tz));\n        assertThat(tzRounding.valueForKey(roundKey), isDate(time(\"2009-02-03T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T00:00:00.000Z\")), isDate(time(\"2009-02-03T12:00:00.000Z\"), tz));\n        assertThat(tzRounding.round(time(\"2009-02-03T13:01:01\")), isDate(time(\"2009-02-03T12:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T12:00:00.000Z\")), isDate(time(\"2009-02-04T00:00:00.000Z\"), tz));\n\n        tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(48)).build();\n        assertThat(tzRounding.round(time(\"2009-02-03T01:01:01\")), isDate(time(\"2009-02-03T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T00:00:00.000Z\")), isDate(time(\"2009-02-05T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.round(time(\"2009-02-05T13:01:01\")), isDate(time(\"2009-02-05T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-05T00:00:00.000Z\")), isDate(time(\"2009-02-07T00:00:00.000Z\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void assertInterval(long rounded, long nextRoundingValue, TimeZoneRounding rounding, int minutes) {\n        assertInterval(rounded, dateBetween(rounded, nextRoundingValue), nextRoundingValue, rounding);\n        assertEquals(DateTimeConstants.MILLIS_PER_MINUTE * minutes, nextRoundingValue - rounded);\n    }","id":80743,"modified_method":"private static void assertInterval(long rounded, long nextRoundingValue, TimeZoneRounding rounding, int minutes,\n            DateTimeZone tz) {\n        assertInterval(rounded, dateBetween(rounded, nextRoundingValue), nextRoundingValue, rounding, tz);\n        assertEquals(DateTimeConstants.MILLIS_PER_MINUTE * minutes, nextRoundingValue - rounded);\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDayTimeZoneRounding() {\n        int timezoneOffset = -2;\n        Rounding tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(DateTimeZone.forOffsetHours(timezoneOffset))\n                .build();\n        assertThat(tzRounding.round(0), equalTo(0L - TimeValue.timeValueHours(24 + timezoneOffset).millis()));\n        assertThat(tzRounding.nextRoundingValue(0L - TimeValue.timeValueHours(24 + timezoneOffset).millis()), equalTo(0L - TimeValue\n                .timeValueHours(timezoneOffset).millis()));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(DateTimeZone.forID(\"-08:00\")).build();\n        assertThat(tzRounding.round(utc(\"2012-04-01T04:15:30Z\")), equalTo(utc(\"2012-03-31T08:00:00Z\")));\n        assertThat(toUTCDateString(tzRounding.nextRoundingValue(utc(\"2012-03-31T08:00:00Z\"))),\n                equalTo(toUTCDateString(utc(\"2012-04-01T08:0:00Z\"))));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.MONTH_OF_YEAR).timeZone(DateTimeZone.forID(\"-08:00\")).build();\n        assertThat(tzRounding.round(utc(\"2012-04-01T04:15:30Z\")), equalTo(utc(\"2012-03-01T08:00:00Z\")));\n        assertThat(toUTCDateString(tzRounding.nextRoundingValue(utc(\"2012-03-01T08:00:00Z\"))),\n                equalTo(toUTCDateString(utc(\"2012-04-01T08:0:00Z\"))));\n\n        // date in Feb-3rd, but still in Feb-2nd in -02:00 timezone\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(DateTimeZone.forID(\"-02:00\")).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T01:01:01\")), equalTo(utc(\"2009-02-02T02:00:00\")));\n        long roundKey = tzRounding.roundKey(utc(\"2009-02-03T01:01:01\"));\n        assertThat(roundKey, equalTo(tzRounding.roundKey(utc(\"2009-02-02T02:00:00.000Z\"))));\n        assertThat(tzRounding.valueForKey(roundKey), equalTo(utc(\"2009-02-02T02:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-02T02:00:00\")), equalTo(utc(\"2009-02-03T02:00:00\")));\n\n        // date in Feb-3rd, also in -02:00 timezone\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(DateTimeZone.forID(\"-02:00\")).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T02:01:01\")), equalTo(utc(\"2009-02-03T02:00:00\")));\n        roundKey = tzRounding.roundKey(utc(\"2009-02-03T02:01:01\"));\n        assertThat(roundKey, equalTo(tzRounding.roundKey(utc(\"2009-02-03T02:00:00.000Z\"))));\n        assertThat(tzRounding.valueForKey(roundKey), equalTo(utc(\"2009-02-03T02:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T02:00:00\")), equalTo(utc(\"2009-02-04T02:00:00\")));\n    }","id":80744,"modified_method":"public void testDayTimeZoneRounding() {\n        int timezoneOffset = -2;\n        Rounding tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(DateTimeZone.forOffsetHours(timezoneOffset))\n                .build();\n        assertThat(tzRounding.round(0), equalTo(0L - TimeValue.timeValueHours(24 + timezoneOffset).millis()));\n        assertThat(tzRounding.nextRoundingValue(0L - TimeValue.timeValueHours(24 + timezoneOffset).millis()), equalTo(0L - TimeValue\n                .timeValueHours(timezoneOffset).millis()));\n\n        DateTimeZone tz = DateTimeZone.forID(\"-08:00\");\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2012-04-01T04:15:30Z\")), isDate(time(\"2012-03-31T08:00:00Z\"), tz));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.MONTH_OF_YEAR).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2012-04-01T04:15:30Z\")), equalTo(time(\"2012-03-01T08:00:00Z\")));\n\n        // date in Feb-3rd, but still in Feb-2nd in -02:00 timezone\n        tz = DateTimeZone.forID(\"-02:00\");\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2009-02-03T01:01:01\")), isDate(time(\"2009-02-02T02:00:00\"), tz));\n        long roundKey = tzRounding.roundKey(time(\"2009-02-03T01:01:01\"));\n        assertThat(roundKey, isDate(tzRounding.roundKey(time(\"2009-02-02T02:00:00.000Z\")), tz));\n        assertThat(tzRounding.valueForKey(roundKey), isDate(time(\"2009-02-02T02:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-02T02:00:00\")), isDate(time(\"2009-02-03T02:00:00\"), tz));\n\n        // date in Feb-3rd, also in -02:00 timezone\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2009-02-03T02:01:01\")), isDate(time(\"2009-02-03T02:00:00\"), tz));\n        roundKey = tzRounding.roundKey(time(\"2009-02-03T02:01:01\"));\n        assertThat(roundKey, isDate(tzRounding.roundKey(time(\"2009-02-03T02:00:00.000Z\")), tz));\n        assertThat(tzRounding.valueForKey(roundKey), isDate(time(\"2009-02-03T02:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T02:00:00\")), isDate(time(\"2009-02-04T02:00:00\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testUTCTimeUnitRounding() {\n        Rounding tzRounding = TimeZoneRounding.builder(DateTimeUnit.MONTH_OF_YEAR).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T01:01:01\")), equalTo(utc(\"2009-02-01T00:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-01T00:00:00.000Z\")), equalTo(utc(\"2009-03-01T00:00:00.000Z\")));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.WEEK_OF_WEEKYEAR).build();\n        assertThat(tzRounding.round(utc(\"2012-01-10T01:01:01\")), equalTo(utc(\"2012-01-09T00:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2012-01-09T00:00:00.000Z\")), equalTo(utc(\"2012-01-16T00:00:00.000Z\")));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.WEEK_OF_WEEKYEAR).offset(-TimeValue.timeValueHours(24).millis()).build();\n        assertThat(tzRounding.round(utc(\"2012-01-10T01:01:01\")), equalTo(utc(\"2012-01-08T00:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2012-01-08T00:00:00.000Z\")), equalTo(utc(\"2012-01-15T00:00:00.000Z\")));\n    }","id":80745,"modified_method":"public void testUTCTimeUnitRounding() {\n        Rounding tzRounding = TimeZoneRounding.builder(DateTimeUnit.MONTH_OF_YEAR).build();\n        DateTimeZone tz = DateTimeZone.UTC;\n        assertThat(tzRounding.round(time(\"2009-02-03T01:01:01\")), isDate(time(\"2009-02-01T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-01T00:00:00.000Z\")), isDate(time(\"2009-03-01T00:00:00.000Z\"), tz));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.WEEK_OF_WEEKYEAR).build();\n        assertThat(tzRounding.round(time(\"2012-01-10T01:01:01\")), isDate(time(\"2012-01-09T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2012-01-09T00:00:00.000Z\")), isDate(time(\"2012-01-16T00:00:00.000Z\"), tz));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.WEEK_OF_WEEKYEAR).offset(-TimeValue.timeValueHours(24).millis()).build();\n        assertThat(tzRounding.round(time(\"2012-01-10T01:01:01\")), isDate(time(\"2012-01-08T00:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2012-01-08T00:00:00.000Z\")), isDate(time(\"2012-01-15T00:00:00.000Z\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Randomized test on TimeUnitRounding.\n     * Test uses random {@link DateTimeUnit} and {@link DateTimeZone} and often (50% of the time) chooses\n     * test dates that are exactly on or close to offset changes (e.g. DST) in the chosen time zone.\n     *\n     * It rounds the test date down and up and performs various checks on the rounding unit interval that is\n     * defined by this. Assumptions tested are described in {@link #assertInterval(long, long, long, TimeZoneRounding)}\n     */\n    public void testTimeZoneRoundingRandom() {\n        for (int i = 0; i < 1000; ++i) {\n            DateTimeUnit timeUnit = randomTimeUnit();\n            DateTimeZone timezone = randomDateTimeZone();\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, timezone);\n            long date = Math.abs(randomLong() % (2 * (long) 10e11)); // 1970-01-01T00:00:00Z - 2033-05-18T05:33:20.000+02:00\n            long unitMillis = timeUnit.field(timezone).getDurationField().getUnitMillis();\n            if (randomBoolean()) {\n                nastyDate(date, timezone, unitMillis);\n            }\n            final long roundedDate = rounding.round(date);\n            final long nextRoundingValue = rounding.nextRoundingValue(roundedDate);\n\n            assertInterval(roundedDate, date, nextRoundingValue, rounding);\n\n            // check correct unit interval width for units smaller than a day, they should be fixed size except for transitions\n            if (unitMillis <= DateTimeConstants.MILLIS_PER_DAY) {\n                // if the interval defined didn't cross timezone offset transition, it should cover unitMillis width\n                if (timezone.getOffset(roundedDate - 1) == timezone.getOffset(nextRoundingValue + 1)) {\n                    assertThat(\"unit interval width not as expected for [\" + timeUnit + \"], [\" + timezone + \"] at \"\n                            + new DateTime(roundedDate), nextRoundingValue - roundedDate, equalTo(unitMillis));\n                }\n            }\n        }\n    }","id":80746,"modified_method":"/**\n     * Randomized test on TimeUnitRounding.\n     * Test uses random {@link DateTimeUnit} and {@link DateTimeZone} and often (50% of the time) chooses\n     * test dates that are exactly on or close to offset changes (e.g. DST) in the chosen time zone.\n     *\n     * It rounds the test date down and up and performs various checks on the rounding unit interval that is\n     * defined by this. Assumptions tested are described in {@link #assertInterval(long, long, long, TimeZoneRounding, DateTimeZone)}\n     */\n    public void testTimeZoneRoundingRandom() {\n        for (int i = 0; i < 1000; ++i) {\n            DateTimeUnit timeUnit = randomTimeUnit();\n            DateTimeZone tz = randomDateTimeZone();\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, tz);\n            long date = Math.abs(randomLong() % (2 * (long) 10e11)); // 1970-01-01T00:00:00Z - 2033-05-18T05:33:20.000+02:00\n            long unitMillis = timeUnit.field(tz).getDurationField().getUnitMillis();\n            if (randomBoolean()) {\n                nastyDate(date, tz, unitMillis);\n            }\n            final long roundedDate = rounding.round(date);\n            final long nextRoundingValue = rounding.nextRoundingValue(roundedDate);\n\n            assertInterval(roundedDate, date, nextRoundingValue, rounding, tz);\n\n            // check correct unit interval width for units smaller than a day, they should be fixed size except for transitions\n            if (unitMillis <= DateTimeConstants.MILLIS_PER_DAY) {\n                // if the interval defined didn't cross timezone offset transition, it should cover unitMillis width\n                if (tz.getOffset(roundedDate - 1) == tz.getOffset(nextRoundingValue + 1)) {\n                    assertThat(\"unit interval width not as expected for [\" + timeUnit + \"], [\" + tz + \"] at \"\n                            + new DateTime(roundedDate), nextRoundingValue - roundedDate, equalTo(unitMillis));\n                }\n            }\n        }\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testEdgeCasesTransition() {\n        {\n            // standard +/-1 hour DST transition, CET\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone timezone = DateTimeZone.forID(\"CET\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, timezone);\n\n            // 29 Mar 2015 - Daylight Saving Time Started\n            // at 02:00:00 clocks were turned forward 1 hour to 03:00:00\n            assertInterval(time(\"2015-03-29T00:00:00.000+01:00\"), time(\"2015-03-29T01:00:00.000+01:00\"), rounding, 60);\n            assertInterval(time(\"2015-03-29T01:00:00.000+01:00\"), time(\"2015-03-29T03:00:00.000+02:00\"), rounding, 60);\n            assertInterval(time(\"2015-03-29T03:00:00.000+02:00\"), time(\"2015-03-29T04:00:00.000+02:00\"), rounding, 60);\n\n            // 25 Oct 2015 - Daylight Saving Time Ended\n            // at 03:00:00 clocks were turned backward 1 hour to 02:00:00\n            assertInterval(time(\"2015-10-25T01:00:00.000+02:00\"), time(\"2015-10-25T02:00:00.000+02:00\"), rounding, 60);\n            assertInterval(time(\"2015-10-25T02:00:00.000+02:00\"), time(\"2015-10-25T02:00:00.000+01:00\"), rounding, 60);\n            assertInterval(time(\"2015-10-25T02:00:00.000+01:00\"), time(\"2015-10-25T03:00:00.000+01:00\"), rounding, 60);\n        }\n\n        {\n            // time zone \"Asia/Kathmandu\"\n            // 1 Jan 1986 - Time Zone Change (IST  NPT), at 00:00:00 clocks were turned forward 00:15 minutes\n            //\n            // hour rounding is stable before 1985-12-31T23:00:00.000 and after 1986-01-01T01:00:00.000+05:45\n            // the interval between is 105 minutes long because the hour after transition starts at 00:15\n            // which is not a round value for hourly rounding\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone timezone = DateTimeZone.forID(\"Asia/Kathmandu\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, timezone);\n\n            assertInterval(time(\"1985-12-31T22:00:00.000+05:30\"), time(\"1985-12-31T23:00:00.000+05:30\"), rounding, 60);\n            assertInterval(time(\"1985-12-31T23:00:00.000+05:30\"), time(\"1986-01-01T01:00:00.000+05:45\"), rounding, 105);\n            assertInterval(time(\"1986-01-01T01:00:00.000+05:45\"), time(\"1986-01-01T02:00:00.000+05:45\"), rounding, 60);\n        }\n\n        {\n            // time zone \"Australia/Lord_Howe\"\n            // 3 Mar 1991 - Daylight Saving Time Ended\n            // at 02:00:00 clocks were turned backward 0:30 hours to Sunday, 3 March 1991, 01:30:00\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone timezone = DateTimeZone.forID(\"Australia/Lord_Howe\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, timezone);\n\n            assertInterval(time(\"1991-03-03T00:00:00.000+11:00\"), time(\"1991-03-03T01:00:00.000+11:00\"), rounding, 60);\n            assertInterval(time(\"1991-03-03T01:00:00.000+11:00\"), time(\"1991-03-03T02:00:00.000+10:30\"), rounding, 90);\n            assertInterval(time(\"1991-03-03T02:00:00.000+10:30\"), time(\"1991-03-03T03:00:00.000+10:30\"), rounding, 60);\n\n            // 27 Oct 1991 - Daylight Saving Time Started\n            // at 02:00:00 clocks were turned forward 0:30 hours to 02:30:00\n            assertInterval(time(\"1991-10-27T00:00:00.000+10:30\"), time(\"1991-10-27T01:00:00.000+10:30\"), rounding, 60);\n            // the interval containing the switch time is 90 minutes long\n            assertInterval(time(\"1991-10-27T01:00:00.000+10:30\"), time(\"1991-10-27T03:00:00.000+11:00\"), rounding, 90);\n            assertInterval(time(\"1991-10-27T03:00:00.000+11:00\"), time(\"1991-10-27T04:00:00.000+11:00\"), rounding, 60);\n        }\n\n        {\n            // time zone \"Pacific/Chatham\"\n            // 5 Apr 2015 - Daylight Saving Time Ended\n            // at 03:45:00 clocks were turned backward 1 hour to 02:45:00\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone timezone = DateTimeZone.forID(\"Pacific/Chatham\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, timezone);\n\n            assertInterval(time(\"2015-04-05T02:00:00.000+13:45\"), time(\"2015-04-05T03:00:00.000+13:45\"), rounding, 60);\n            assertInterval(time(\"2015-04-05T03:00:00.000+13:45\"), time(\"2015-04-05T03:00:00.000+12:45\"), rounding, 60);\n            assertInterval(time(\"2015-04-05T03:00:00.000+12:45\"), time(\"2015-04-05T04:00:00.000+12:45\"), rounding, 60);\n\n            // 27 Sep 2015 - Daylight Saving Time Started\n            // at 02:45:00 clocks were turned forward 1 hour to 03:45:00\n\n            assertInterval(time(\"2015-09-27T01:00:00.000+12:45\"), time(\"2015-09-27T02:00:00.000+12:45\"), rounding, 60);\n            assertInterval(time(\"2015-09-27T02:00:00.000+12:45\"), time(\"2015-09-27T04:00:00.000+13:45\"), rounding, 60);\n            assertInterval(time(\"2015-09-27T04:00:00.000+13:45\"), time(\"2015-09-27T05:00:00.000+13:45\"), rounding, 60);\n        }\n    }","id":80747,"modified_method":"public void testEdgeCasesTransition() {\n        {\n            // standard +/-1 hour DST transition, CET\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone tz = DateTimeZone.forID(\"CET\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, tz);\n\n            // 29 Mar 2015 - Daylight Saving Time Started\n            // at 02:00:00 clocks were turned forward 1 hour to 03:00:00\n            assertInterval(time(\"2015-03-29T00:00:00.000+01:00\"), time(\"2015-03-29T01:00:00.000+01:00\"), rounding, 60, tz);\n            assertInterval(time(\"2015-03-29T01:00:00.000+01:00\"), time(\"2015-03-29T03:00:00.000+02:00\"), rounding, 60, tz);\n            assertInterval(time(\"2015-03-29T03:00:00.000+02:00\"), time(\"2015-03-29T04:00:00.000+02:00\"), rounding, 60, tz);\n\n            // 25 Oct 2015 - Daylight Saving Time Ended\n            // at 03:00:00 clocks were turned backward 1 hour to 02:00:00\n            assertInterval(time(\"2015-10-25T01:00:00.000+02:00\"), time(\"2015-10-25T02:00:00.000+02:00\"), rounding, 60, tz);\n            assertInterval(time(\"2015-10-25T02:00:00.000+02:00\"), time(\"2015-10-25T02:00:00.000+01:00\"), rounding, 60, tz);\n            assertInterval(time(\"2015-10-25T02:00:00.000+01:00\"), time(\"2015-10-25T03:00:00.000+01:00\"), rounding, 60, tz);\n        }\n\n        {\n            // time zone \"Asia/Kathmandu\"\n            // 1 Jan 1986 - Time Zone Change (IST  NPT), at 00:00:00 clocks were turned forward 00:15 minutes\n            //\n            // hour rounding is stable before 1985-12-31T23:00:00.000 and after 1986-01-01T01:00:00.000+05:45\n            // the interval between is 105 minutes long because the hour after transition starts at 00:15\n            // which is not a round value for hourly rounding\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone tz = DateTimeZone.forID(\"Asia/Kathmandu\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, tz);\n\n            assertInterval(time(\"1985-12-31T22:00:00.000+05:30\"), time(\"1985-12-31T23:00:00.000+05:30\"), rounding, 60, tz);\n            assertInterval(time(\"1985-12-31T23:00:00.000+05:30\"), time(\"1986-01-01T01:00:00.000+05:45\"), rounding, 105, tz);\n            assertInterval(time(\"1986-01-01T01:00:00.000+05:45\"), time(\"1986-01-01T02:00:00.000+05:45\"), rounding, 60, tz);\n        }\n\n        {\n            // time zone \"Australia/Lord_Howe\"\n            // 3 Mar 1991 - Daylight Saving Time Ended\n            // at 02:00:00 clocks were turned backward 0:30 hours to Sunday, 3 March 1991, 01:30:00\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone tz = DateTimeZone.forID(\"Australia/Lord_Howe\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, tz);\n\n            assertInterval(time(\"1991-03-03T00:00:00.000+11:00\"), time(\"1991-03-03T01:00:00.000+11:00\"), rounding, 60, tz);\n            assertInterval(time(\"1991-03-03T01:00:00.000+11:00\"), time(\"1991-03-03T02:00:00.000+10:30\"), rounding, 90, tz);\n            assertInterval(time(\"1991-03-03T02:00:00.000+10:30\"), time(\"1991-03-03T03:00:00.000+10:30\"), rounding, 60, tz);\n\n            // 27 Oct 1991 - Daylight Saving Time Started\n            // at 02:00:00 clocks were turned forward 0:30 hours to 02:30:00\n            assertInterval(time(\"1991-10-27T00:00:00.000+10:30\"), time(\"1991-10-27T01:00:00.000+10:30\"), rounding, 60, tz);\n            // the interval containing the switch time is 90 minutes long\n            assertInterval(time(\"1991-10-27T01:00:00.000+10:30\"), time(\"1991-10-27T03:00:00.000+11:00\"), rounding, 90, tz);\n            assertInterval(time(\"1991-10-27T03:00:00.000+11:00\"), time(\"1991-10-27T04:00:00.000+11:00\"), rounding, 60, tz);\n        }\n\n        {\n            // time zone \"Pacific/Chatham\"\n            // 5 Apr 2015 - Daylight Saving Time Ended\n            // at 03:45:00 clocks were turned backward 1 hour to 02:45:00\n            DateTimeUnit timeUnit = DateTimeUnit.HOUR_OF_DAY;\n            DateTimeZone tz = DateTimeZone.forID(\"Pacific/Chatham\");\n            TimeZoneRounding rounding = new TimeZoneRounding.TimeUnitRounding(timeUnit, tz);\n\n            assertInterval(time(\"2015-04-05T02:00:00.000+13:45\"), time(\"2015-04-05T03:00:00.000+13:45\"), rounding, 60, tz);\n            assertInterval(time(\"2015-04-05T03:00:00.000+13:45\"), time(\"2015-04-05T03:00:00.000+12:45\"), rounding, 60, tz);\n            assertInterval(time(\"2015-04-05T03:00:00.000+12:45\"), time(\"2015-04-05T04:00:00.000+12:45\"), rounding, 60, tz);\n\n            // 27 Sep 2015 - Daylight Saving Time Started\n            // at 02:45:00 clocks were turned forward 1 hour to 03:45:00\n\n            assertInterval(time(\"2015-09-27T01:00:00.000+12:45\"), time(\"2015-09-27T02:00:00.000+12:45\"), rounding, 60, tz);\n            assertInterval(time(\"2015-09-27T02:00:00.000+12:45\"), time(\"2015-09-27T04:00:00.000+13:45\"), rounding, 60, tz);\n            assertInterval(time(\"2015-09-27T04:00:00.000+13:45\"), time(\"2015-09-27T05:00:00.000+13:45\"), rounding, 60, tz);\n        }\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test DST start with interval rounding\n     * CET: 27 March 2016, 02:00:00 clocks were turned forward 1 hour to 27 March 2016, 03:00:00 local daylight time\n     */\n    public void testTimeIntervalCET_DST_Start() {\n        long interval = TimeUnit.MINUTES.toMillis(20);\n        TimeZoneRounding rounding = new TimeIntervalRounding(interval, DateTimeZone.forID(\"CET\"));\n        // test DST start\n        assertThat(rounding.round(time(\"2016-03-27T01:55:00+01:00\")), equalTo(time(\"2016-03-27T01:40:00+01:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T02:00:00+01:00\")), equalTo(time(\"2016-03-27T03:00:00+02:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T03:15:00+02:00\")), equalTo(time(\"2016-03-27T03:00:00+02:00\")));\n        assertThat(rounding.round(time(\"2016-03-27T03:35:00+02:00\")), equalTo(time(\"2016-03-27T03:20:00+02:00\")));\n    }","id":80748,"modified_method":"/**\n     * test DST start with interval rounding\n     * CET: 27 March 2016, 02:00:00 clocks were turned forward 1 hour to 27 March 2016, 03:00:00 local daylight time\n     */\n    public void testTimeIntervalCET_DST_Start() {\n        long interval = TimeUnit.MINUTES.toMillis(20);\n        DateTimeZone tz = DateTimeZone.forID(\"CET\");\n        TimeZoneRounding rounding = new TimeIntervalRounding(interval, tz);\n        // test DST start\n        assertThat(rounding.round(time(\"2016-03-27T01:55:00+01:00\")), isDate(time(\"2016-03-27T01:40:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T02:00:00+01:00\")), isDate(time(\"2016-03-27T03:00:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T03:15:00+02:00\")), isDate(time(\"2016-03-27T03:00:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2016-03-27T03:35:00+02:00\")), isDate(time(\"2016-03-27T03:20:00+02:00\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test DST start with offset not fitting interval, e.g. Asia/Kathmandu\n     * adding 15min on 1986-01-01T00:00:00 the interval from\n     * 1986-01-01T00:15:00+05:45 to 1986-01-01T00:20:00+05:45 to only be 5min\n     * long\n     */\n    public void testTimeInterval_Kathmandu_DST_Start() {\n        long interval = TimeUnit.MINUTES.toMillis(20);\n        TimeZoneRounding rounding = new TimeIntervalRounding(interval, DateTimeZone.forID(\"Asia/Kathmandu\"));\n        assertThat(rounding.round(time(\"1985-12-31T23:55:00+05:30\")), equalTo(time(\"1985-12-31T23:40:00+05:30\")));\n        assertThat(rounding.round(time(\"1986-01-01T00:16:00+05:45\")), equalTo(time(\"1986-01-01T00:15:00+05:45\")));\n        assertThat(time(\"1986-01-01T00:15:00+05:45\") - time(\"1985-12-31T23:40:00+05:30\"), equalTo(TimeUnit.MINUTES.toMillis(20)));\n        assertThat(rounding.round(time(\"1986-01-01T00:26:00+05:45\")), equalTo(time(\"1986-01-01T00:20:00+05:45\")));\n        assertThat(time(\"1986-01-01T00:20:00+05:45\") - time(\"1986-01-01T00:15:00+05:45\"), equalTo(TimeUnit.MINUTES.toMillis(5)));\n        assertThat(rounding.round(time(\"1986-01-01T00:46:00+05:45\")), equalTo(time(\"1986-01-01T00:40:00+05:45\")));\n        assertThat(time(\"1986-01-01T00:40:00+05:45\") - time(\"1986-01-01T00:20:00+05:45\"), equalTo(TimeUnit.MINUTES.toMillis(20)));\n    }","id":80749,"modified_method":"/**\n     * test DST start with offset not fitting interval, e.g. Asia/Kathmandu\n     * adding 15min on 1986-01-01T00:00:00 the interval from\n     * 1986-01-01T00:15:00+05:45 to 1986-01-01T00:20:00+05:45 to only be 5min\n     * long\n     */\n    public void testTimeInterval_Kathmandu_DST_Start() {\n        long interval = TimeUnit.MINUTES.toMillis(20);\n        DateTimeZone tz = DateTimeZone.forID(\"Asia/Kathmandu\");\n        TimeZoneRounding rounding = new TimeIntervalRounding(interval, tz);\n        assertThat(rounding.round(time(\"1985-12-31T23:55:00+05:30\")), isDate(time(\"1985-12-31T23:40:00+05:30\"), tz));\n        assertThat(rounding.round(time(\"1986-01-01T00:16:00+05:45\")), isDate(time(\"1986-01-01T00:15:00+05:45\"), tz));\n        assertThat(time(\"1986-01-01T00:15:00+05:45\") - time(\"1985-12-31T23:40:00+05:30\"), equalTo(TimeUnit.MINUTES.toMillis(20)));\n        assertThat(rounding.round(time(\"1986-01-01T00:26:00+05:45\")), isDate(time(\"1986-01-01T00:20:00+05:45\"), tz));\n        assertThat(time(\"1986-01-01T00:20:00+05:45\") - time(\"1986-01-01T00:15:00+05:45\"), equalTo(TimeUnit.MINUTES.toMillis(5)));\n        assertThat(rounding.round(time(\"1986-01-01T00:46:00+05:45\")), isDate(time(\"1986-01-01T00:40:00+05:45\"), tz));\n        assertThat(time(\"1986-01-01T00:40:00+05:45\") - time(\"1986-01-01T00:20:00+05:45\"), equalTo(TimeUnit.MINUTES.toMillis(20)));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * special test for DST switch from #9491\n     */\n    public void testAmbiguousHoursAfterDSTSwitch() {\n        Rounding tzRounding;\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(JERUSALEM_TIMEZONE).build();\n        // Both timestamps \"2014-10-25T22:30:00Z\" and \"2014-10-25T23:30:00Z\" are \"2014-10-26T01:30:00\" in local time because\n        // of DST switch between them. This test checks that they are both returned to their correct UTC time after rounding.\n        assertThat(tzRounding.round(time(\"2014-10-25T22:30:00\", DateTimeZone.UTC)), equalTo(time(\"2014-10-25T22:00:00\", DateTimeZone.UTC)));\n        assertThat(tzRounding.round(time(\"2014-10-25T23:30:00\", DateTimeZone.UTC)), equalTo(time(\"2014-10-25T23:00:00\", DateTimeZone.UTC)));\n\n        // Day interval\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(JERUSALEM_TIMEZONE).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2014-11-11T00:00:00\", JERUSALEM_TIMEZONE)));\n        // DST on\n        assertThat(tzRounding.round(time(\"2014-08-11T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2014-08-11T00:00:00\", JERUSALEM_TIMEZONE)));\n        // Day of switching DST on -> off\n        assertThat(tzRounding.round(time(\"2014-10-26T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2014-10-26T00:00:00\", JERUSALEM_TIMEZONE)));\n        // Day of switching DST off -> on\n        assertThat(tzRounding.round(time(\"2015-03-27T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2015-03-27T00:00:00\", JERUSALEM_TIMEZONE)));\n\n        // Month interval\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.MONTH_OF_YEAR).timeZone(JERUSALEM_TIMEZONE).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2014-11-01T00:00:00\", JERUSALEM_TIMEZONE)));\n        // DST on\n        assertThat(tzRounding.round(time(\"2014-10-10T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2014-10-01T00:00:00\", JERUSALEM_TIMEZONE)));\n\n        // Year interval\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.YEAR_OF_CENTURY).timeZone(JERUSALEM_TIMEZONE).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", JERUSALEM_TIMEZONE)), equalTo(time(\"2014-01-01T00:00:00\", JERUSALEM_TIMEZONE)));\n\n        // Two timestamps in same year and different timezone offset (\"Double buckets\" issue - #9491)\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.YEAR_OF_CENTURY).timeZone(JERUSALEM_TIMEZONE).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", JERUSALEM_TIMEZONE)),\n                equalTo(tzRounding.round(time(\"2014-08-11T17:00:00\", JERUSALEM_TIMEZONE))));\n    }","id":80750,"modified_method":"/**\n     * special test for DST switch from #9491\n     */\n    public void testAmbiguousHoursAfterDSTSwitch() {\n        Rounding tzRounding;\n        final DateTimeZone tz = DateTimeZone.forID(\"Asia/Jerusalem\");\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2014-10-26T00:30:00+03:00\")), isDate(time(\"2014-10-26T00:00:00+03:00\"), tz));\n        assertThat(tzRounding.round(time(\"2014-10-26T01:30:00+03:00\")), isDate(time(\"2014-10-26T01:00:00+03:00\"), tz));\n        // the utc date for \"2014-10-25T03:00:00+03:00\" and \"2014-10-25T03:00:00+02:00\" is the same, local time turns back 1h here\n        assertThat(time(\"2014-10-26T03:00:00+03:00\"), isDate(time(\"2014-10-26T02:00:00+02:00\"), tz));\n        assertThat(tzRounding.round(time(\"2014-10-26T01:30:00+02:00\")), isDate(time(\"2014-10-26T01:00:00+02:00\"), tz));\n        assertThat(tzRounding.round(time(\"2014-10-26T02:30:00+02:00\")), isDate(time(\"2014-10-26T02:00:00+02:00\"), tz));\n\n        // Day interval\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.DAY_OF_MONTH).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", tz)), isDate(time(\"2014-11-11T00:00:00\", tz), tz));\n        // DST on\n        assertThat(tzRounding.round(time(\"2014-08-11T17:00:00\", tz)), isDate(time(\"2014-08-11T00:00:00\", tz), tz));\n        // Day of switching DST on -> off\n        assertThat(tzRounding.round(time(\"2014-10-26T17:00:00\", tz)), isDate(time(\"2014-10-26T00:00:00\", tz), tz));\n        // Day of switching DST off -> on\n        assertThat(tzRounding.round(time(\"2015-03-27T17:00:00\", tz)), isDate(time(\"2015-03-27T00:00:00\", tz), tz));\n\n        // Month interval\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.MONTH_OF_YEAR).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", tz)), isDate(time(\"2014-11-01T00:00:00\", tz), tz));\n        // DST on\n        assertThat(tzRounding.round(time(\"2014-10-10T17:00:00\", tz)), isDate(time(\"2014-10-01T00:00:00\", tz), tz));\n\n        // Year interval\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.YEAR_OF_CENTURY).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", tz)), isDate(time(\"2014-01-01T00:00:00\", tz), tz));\n\n        // Two timestamps in same year and different timezone offset (\"Double buckets\" issue - #9491)\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.YEAR_OF_CENTURY).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2014-11-11T17:00:00\", tz)),\n                isDate(tzRounding.round(time(\"2014-08-11T17:00:00\", tz)), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test TimeIntervalTimeZoneRounding, (interval &lt; 12h) with time zone shift\n     */\n    public void testTimeIntervalTimeZoneRounding() {\n        Rounding tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(6)).timeZone(DateTimeZone.forOffsetHours(-1)).build();\n        assertThat(tzRounding.round(utc(\"2009-02-03T00:01:01\")), equalTo(utc(\"2009-02-02T19:00:00.000Z\")));\n        long roundKey = tzRounding.roundKey(utc(\"2009-02-03T00:01:01\"));\n        assertThat(roundKey, equalTo(tzRounding.roundKey(utc(\"2009-02-02T19:00:00.000Z\"))));\n        assertThat(tzRounding.valueForKey(roundKey), equalTo(utc(\"2009-02-02T19:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-02T19:00:00.000Z\")), equalTo(utc(\"2009-02-03T01:00:00.000Z\")));\n\n        assertThat(tzRounding.round(utc(\"2009-02-03T13:01:01\")), equalTo(utc(\"2009-02-03T13:00:00.000Z\")));\n        assertThat(tzRounding.nextRoundingValue(utc(\"2009-02-03T13:00:00.000Z\")), equalTo(utc(\"2009-02-03T19:00:00.000Z\")));\n    }","id":80751,"modified_method":"/**\n     * test TimeIntervalTimeZoneRounding, (interval &lt; 12h) with time zone shift\n     */\n    public void testTimeIntervalTimeZoneRounding() {\n        DateTimeZone tz = DateTimeZone.forOffsetHours(-1);\n        Rounding tzRounding = TimeZoneRounding.builder(TimeValue.timeValueHours(6)).timeZone(tz).build();\n        assertThat(tzRounding.round(time(\"2009-02-03T00:01:01\")), isDate(time(\"2009-02-02T19:00:00.000Z\"), tz));\n        long roundKey = tzRounding.roundKey(time(\"2009-02-03T00:01:01\"));\n        assertThat(roundKey, equalTo(tzRounding.roundKey(time(\"2009-02-02T19:00:00.000Z\"))));\n        assertThat(tzRounding.valueForKey(roundKey), isDate(time(\"2009-02-02T19:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-02T19:00:00.000Z\")), isDate(time(\"2009-02-03T01:00:00.000Z\"), tz));\n\n        assertThat(tzRounding.round(time(\"2009-02-03T13:01:01\")), isDate(time(\"2009-02-03T13:00:00.000Z\"), tz));\n        assertThat(tzRounding.nextRoundingValue(time(\"2009-02-03T13:00:00.000Z\")), isDate(time(\"2009-02-03T19:00:00.000Z\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testTimeUnitRoundingDST() {\n        Rounding tzRounding;\n        // testing savings to non savings switch\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"UTC\")).build();\n        assertThat(tzRounding.round(time(\"2014-10-26T01:01:01\", DateTimeZone.forOffsetHours(2))),  // CEST = UTC+2\n                equalTo(time(\"2014-10-26T01:00:00\", DateTimeZone.forOffsetHours(2))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-10-26T01:00:00\", DateTimeZone.forOffsetHours(2))),\n                equalTo(time(\"2014-10-26T02:00:00\", DateTimeZone.forOffsetHours(2))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-10-26T02:00:00\", DateTimeZone.forOffsetHours(2))),\n                equalTo(time(\"2014-10-26T03:00:00\", DateTimeZone.forOffsetHours(2))));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"CET\")).build();\n        assertThat(tzRounding.round(time(\"2014-10-26T01:01:01\", DateTimeZone.forOffsetHours(2))),  // CEST = UTC+2\n                equalTo(time(\"2014-10-26T01:00:00\", DateTimeZone.forOffsetHours(2))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-10-26T01:00:00\", DateTimeZone.forOffsetHours(2))),\n                equalTo(time(\"2014-10-26T02:00:00\", DateTimeZone.forOffsetHours(2))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-10-26T02:00:00\", DateTimeZone.forOffsetHours(2))),\n                equalTo(time(\"2014-10-26T03:00:00\", DateTimeZone.forOffsetHours(2))));\n\n        // testing non savings to savings switch\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"UTC\")).build();\n        assertThat(tzRounding.round(time(\"2014-03-30T01:01:01\", DateTimeZone.forOffsetHours(1))),  // CET = UTC+1\n                equalTo(time(\"2014-03-30T01:00:00\", DateTimeZone.forOffsetHours(1))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-03-30T01:00:00\", DateTimeZone.forOffsetHours(1))),\n                equalTo(time(\"2014-03-30T02:00:00\", DateTimeZone.forOffsetHours(1))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-03-30T02:00:00\", DateTimeZone.forOffsetHours(1))),\n                equalTo(time(\"2014-03-30T03:00:00\", DateTimeZone.forOffsetHours(1))));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"CET\")).build();\n        assertThat(tzRounding.round(time(\"2014-03-30T01:01:01\", DateTimeZone.forOffsetHours(1))),  // CET = UTC+1\n                equalTo(time(\"2014-03-30T01:00:00\", DateTimeZone.forOffsetHours(1))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-03-30T01:00:00\", DateTimeZone.forOffsetHours(1))),\n                equalTo(time(\"2014-03-30T02:00:00\", DateTimeZone.forOffsetHours(1))));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-03-30T02:00:00\", DateTimeZone.forOffsetHours(1))),\n                equalTo(time(\"2014-03-30T03:00:00\", DateTimeZone.forOffsetHours(1))));\n\n        // testing non savings to savings switch (America/Chicago)\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"UTC\")).build();\n        assertThat(tzRounding.round(time(\"2014-03-09T03:01:01\", DateTimeZone.forID(\"America/Chicago\"))),\n                equalTo(time(\"2014-03-09T03:00:00\", DateTimeZone.forID(\"America/Chicago\"))));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"America/Chicago\")).build();\n        assertThat(tzRounding.round(time(\"2014-03-09T03:01:01\", DateTimeZone.forID(\"America/Chicago\"))),\n                equalTo(time(\"2014-03-09T03:00:00\", DateTimeZone.forID(\"America/Chicago\"))));\n\n        // testing savings to non savings switch 2013 (America/Chicago)\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"UTC\")).build();\n        assertThat(tzRounding.round(time(\"2013-11-03T06:01:01\", DateTimeZone.forID(\"America/Chicago\"))),\n                equalTo(time(\"2013-11-03T06:00:00\", DateTimeZone.forID(\"America/Chicago\"))));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"America/Chicago\")).build();\n        assertThat(tzRounding.round(time(\"2013-11-03T06:01:01\", DateTimeZone.forID(\"America/Chicago\"))),\n                equalTo(time(\"2013-11-03T06:00:00\", DateTimeZone.forID(\"America/Chicago\"))));\n\n        // testing savings to non savings switch 2014 (America/Chicago)\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"UTC\")).build();\n        assertThat(tzRounding.round(time(\"2014-11-02T06:01:01\", DateTimeZone.forID(\"America/Chicago\"))),\n                equalTo(time(\"2014-11-02T06:00:00\", DateTimeZone.forID(\"America/Chicago\"))));\n\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.forID(\"America/Chicago\")).build();\n        assertThat(tzRounding.round(time(\"2014-11-02T06:01:01\", DateTimeZone.forID(\"America/Chicago\"))),\n                equalTo(time(\"2014-11-02T06:00:00\", DateTimeZone.forID(\"America/Chicago\"))));\n    }","id":80752,"modified_method":"public void testTimeUnitRoundingDST() {\n        Rounding tzRounding;\n        // testing savings to non savings switch\n        DateTimeZone cet = DateTimeZone.forID(\"CET\");\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(cet).build();\n        assertThat(tzRounding.round(time(\"2014-10-26T01:01:01\", cet)), isDate(time(\"2014-10-26T01:00:00+02:00\"), cet));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-10-26T01:00:00\", cet)),isDate(time(\"2014-10-26T02:00:00+02:00\"), cet));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-10-26T02:00:00\", cet)), isDate(time(\"2014-10-26T02:00:00+01:00\"), cet));\n\n        // testing non savings to savings switch\n        tzRounding = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(cet).build();\n        assertThat(tzRounding.round(time(\"2014-03-30T01:01:01\", cet)), isDate(time(\"2014-03-30T01:00:00+01:00\"), cet));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-03-30T01:00:00\", cet)), isDate(time(\"2014-03-30T03:00:00\", cet), cet));\n        assertThat(tzRounding.nextRoundingValue(time(\"2014-03-30T03:00:00\", cet)), isDate(time(\"2014-03-30T04:00:00\", cet), cet));\n\n        // testing non savings to savings switch (America/Chicago)\n        DateTimeZone chg = DateTimeZone.forID(\"America/Chicago\");\n        Rounding tzRounding_utc = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(DateTimeZone.UTC).build();\n        assertThat(tzRounding.round(time(\"2014-03-09T03:01:01\", chg)), isDate(time(\"2014-03-09T03:00:00\", chg), chg));\n\n        Rounding tzRounding_chg = TimeZoneRounding.builder(DateTimeUnit.HOUR_OF_DAY).timeZone(chg).build();\n        assertThat(tzRounding_chg.round(time(\"2014-03-09T03:01:01\", chg)), isDate(time(\"2014-03-09T03:00:00\", chg), chg));\n\n        // testing savings to non savings switch 2013 (America/Chicago)\n        assertThat(tzRounding_utc.round(time(\"2013-11-03T06:01:01\", chg)), isDate(time(\"2013-11-03T06:00:00\", chg), chg));\n        assertThat(tzRounding_chg.round(time(\"2013-11-03T06:01:01\", chg)), isDate(time(\"2013-11-03T06:00:00\", chg), chg));\n\n        // testing savings to non savings switch 2014 (America/Chicago)\n        assertThat(tzRounding_utc.round(time(\"2014-11-02T06:01:01\", chg)), isDate(time(\"2014-11-02T06:00:00\", chg), chg));\n        assertThat(tzRounding_chg.round(time(\"2014-11-02T06:01:01\", chg)), isDate(time(\"2014-11-02T06:00:00\", chg), chg));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test DST end with interval rounding\n     * CET: 25 October 2015, 03:00:00 clocks were turned backward 1 hour to 25 October 2015, 02:00:00 local standard time\n     */\n    public void testTimeIntervalCET_DST_End() {\n        long interval = TimeUnit.MINUTES.toMillis(20);\n        TimeZoneRounding rounding = new TimeIntervalRounding(interval, DateTimeZone.forID(\"CET\"));\n\n        assertThat(rounding.round(time(\"2015-10-25T01:55:00+02:00\")), equalTo(time(\"2015-10-25T01:40:00+02:00\")));\n        assertThat(rounding.round(time(\"2015-10-25T02:15:00+02:00\")), equalTo(time(\"2015-10-25T02:00:00+02:00\")));\n        assertThat(rounding.round(time(\"2015-10-25T02:35:00+02:00\")), equalTo(time(\"2015-10-25T02:20:00+02:00\")));\n        assertThat(rounding.round(time(\"2015-10-25T02:55:00+02:00\")), equalTo(time(\"2015-10-25T02:40:00+02:00\")));\n        // after DST shift\n        assertThat(rounding.round(time(\"2015-10-25T02:15:00+01:00\")), equalTo(time(\"2015-10-25T02:00:00+01:00\")));\n        assertThat(rounding.round(time(\"2015-10-25T02:35:00+01:00\")), equalTo(time(\"2015-10-25T02:20:00+01:00\")));\n        assertThat(rounding.round(time(\"2015-10-25T02:55:00+01:00\")), equalTo(time(\"2015-10-25T02:40:00+01:00\")));\n        assertThat(rounding.round(time(\"2015-10-25T03:15:00+01:00\")), equalTo(time(\"2015-10-25T03:00:00+01:00\")));\n    }","id":80753,"modified_method":"/**\n     * test DST end with interval rounding\n     * CET: 25 October 2015, 03:00:00 clocks were turned backward 1 hour to 25 October 2015, 02:00:00 local standard time\n     */\n    public void testTimeIntervalCET_DST_End() {\n        long interval = TimeUnit.MINUTES.toMillis(20);\n        DateTimeZone tz = DateTimeZone.forID(\"CET\");\n        TimeZoneRounding rounding = new TimeIntervalRounding(interval, tz);\n\n        assertThat(rounding.round(time(\"2015-10-25T01:55:00+02:00\")), isDate(time(\"2015-10-25T01:40:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2015-10-25T02:15:00+02:00\")), isDate(time(\"2015-10-25T02:00:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2015-10-25T02:35:00+02:00\")), isDate(time(\"2015-10-25T02:20:00+02:00\"), tz));\n        assertThat(rounding.round(time(\"2015-10-25T02:55:00+02:00\")), isDate(time(\"2015-10-25T02:40:00+02:00\"), tz));\n        // after DST shift\n        assertThat(rounding.round(time(\"2015-10-25T02:15:00+01:00\")), isDate(time(\"2015-10-25T02:00:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2015-10-25T02:35:00+01:00\")), isDate(time(\"2015-10-25T02:20:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2015-10-25T02:55:00+01:00\")), isDate(time(\"2015-10-25T02:40:00+01:00\"), tz));\n        assertThat(rounding.round(time(\"2015-10-25T03:15:00+01:00\")), isDate(time(\"2015-10-25T03:00:00+01:00\"), tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * perform a number on assertions and checks on {@link TimeUnitRounding} intervals\n     * @param rounded the expected low end of the rounding interval\n     * @param unrounded a date in the interval to be checked for rounding\n     * @param nextRoundingValue the expected upper end of the rounding interval\n     * @param rounding the rounding instance\n     */\n    private static void assertInterval(long rounded, long unrounded, long nextRoundingValue, TimeZoneRounding rounding) {\n        assert rounded <= unrounded && unrounded <= nextRoundingValue;\n        assertThat(\"rounding should be idempotent \" + rounding, rounded, equalTo(rounding.round(rounded)));\n        assertThat(\"rounded value smaller or equal than unrounded\" + rounding, rounded, lessThanOrEqualTo(unrounded));\n        assertThat(\"values less than rounded should round further down\" + rounding, rounding.round(rounded - 1), lessThan(rounded));\n        assertThat(\"nextRounding value should be greater than date\" + rounding, nextRoundingValue, greaterThan(unrounded));\n        assertThat(\"nextRounding value should be a rounded date\" + rounding, nextRoundingValue, equalTo(rounding.round(nextRoundingValue)));\n        assertThat(\"values above nextRounding should round down there\" + rounding, rounding.round(nextRoundingValue + 1),\n                equalTo(nextRoundingValue));\n\n        long dateBetween = dateBetween(rounded, nextRoundingValue);\n        assertThat(\"dateBetween should round down to roundedDate\" + rounding, rounding.round(dateBetween), equalTo(rounded));\n        assertThat(\"dateBetween should round up to nextRoundingValue\" + rounding, rounding.nextRoundingValue(dateBetween),\n                equalTo(nextRoundingValue));\n    }","id":80754,"modified_method":"/**\n     * perform a number on assertions and checks on {@link TimeUnitRounding} intervals\n     * @param rounded the expected low end of the rounding interval\n     * @param unrounded a date in the interval to be checked for rounding\n     * @param nextRoundingValue the expected upper end of the rounding interval\n     * @param rounding the rounding instance\n     */\n    private static void assertInterval(long rounded, long unrounded, long nextRoundingValue, TimeZoneRounding rounding,\n            DateTimeZone tz) {\n        assert rounded <= unrounded && unrounded <= nextRoundingValue;\n        assertThat(\"rounding should be idempotent \", rounding.round(rounded), isDate(rounded, tz));\n        assertThat(\"rounded value smaller or equal than unrounded\" + rounding, rounded, lessThanOrEqualTo(unrounded));\n        assertThat(\"values less than rounded should round further down\" + rounding, rounding.round(rounded - 1), lessThan(rounded));\n        assertThat(\"nextRounding value should be greater than date\" + rounding, nextRoundingValue, greaterThan(unrounded));\n        assertThat(\"nextRounding value should be a rounded date\", rounding.round(nextRoundingValue), isDate(nextRoundingValue, tz));\n        assertThat(\"values above nextRounding should round down there\", rounding.round(nextRoundingValue + 1),\n                isDate(nextRoundingValue, tz));\n\n        long dateBetween = dateBetween(rounded, nextRoundingValue);\n        assertThat(\"dateBetween should round down to roundedDate\", rounding.round(dateBetween), isDate(rounded, tz));\n        assertThat(\"dateBetween should round up to nextRoundingValue\", rounding.nextRoundingValue(dateBetween),\n                isDate(nextRoundingValue, tz));\n    }","commit_id":"01004c72ba306ac104cdd74ed20934dfb59222e9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Set the groups to have selected by default\n     */\n    protected void setReportFormGroups(final F report) {\n        final Set<AggregatedGroupMapping> groups = this.getGroups();\n        if (!groups.isEmpty()) {\n            report.getGroups().add(groups.iterator().next().getId());\n        }\n    }","id":80755,"modified_method":"/**\n     * Set the groups to have selected by default if not already set\n     */\n    protected void setReportFormGroups(final F report) {\n        if (!report.getGroups().isEmpty()) {\n            return;\n        }\n        \n        final Set<AggregatedGroupMapping> groups = this.getGroups();\n        if (!groups.isEmpty()) {\n            report.getGroups().add(groups.iterator().next().getId());\n        }\n    }","commit_id":"9695453ec6c4b8c1be0f162bf017fc7ae1a0f426","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Set the start/end date and the interval to have selected by default\n     */\n    protected void setReportFormDateRangeAndInterval(final F report) {\n        //Determine default interval based on the intervals available for this aggregation\n        report.setInterval(AggregationInterval.DAY);\n        final Set<AggregationInterval> intervals = this.getIntervals();\n        for (final AggregationInterval preferredInterval : PREFERRED_INTERVAL_ORDER) {\n            if (intervals.contains(preferredInterval)) {\n                report.setInterval(preferredInterval);\n                break;\n            }\n        }\n        \n        //Set the report end date as today\n        final DateMidnight today = new DateMidnight();\n        report.setEnd(today);\n        \n        //Determine the best start date based on the selected interval\n        final DateMidnight start;\n        switch (report.getInterval()) {\n            case MINUTE: {\n                start = today.minusDays(1);\n                break;\n            }\n            case FIVE_MINUTE: {\n                start = today.minusDays(2);\n                break;\n            }\n            case HOUR: {\n                start = today.minusWeeks(1);\n                break;\n            }\n            case DAY: {\n                start = today.minusMonths(1);\n                break;\n            }\n            case WEEK: {\n                start = today.minusMonths(3);\n                break;\n            }\n            case MONTH: {\n                start = today.minusYears(1);\n                break;\n            }\n            case ACADEMIC_TERM: {\n                start = today.minusYears(2);\n                break;\n            }\n            case CALENDAR_QUARTER: {\n                start = today.minusYears(2);\n                break;\n            }\n            case YEAR: {\n                start = today.minusYears(10);\n                break;\n            }\n            default: {\n                start = today.minusWeeks(1);\n            }\n        }\n        \n        report.setStart(start);\n    }","id":80756,"modified_method":"/**\n     * Set the start/end date and the interval to have selected by default if they\n     * are not already set\n     */\n    protected void setReportFormDateRangeAndInterval(final F report) {\n        //Determine default interval based on the intervals available for this aggregation\n        if (report.getInterval() == null) {\n            report.setInterval(AggregationInterval.DAY);\n            final Set<AggregationInterval> intervals = this.getIntervals();\n            for (final AggregationInterval preferredInterval : PREFERRED_INTERVAL_ORDER) {\n                if (intervals.contains(preferredInterval)) {\n                    report.setInterval(preferredInterval);\n                    break;\n                }\n            }\n        }\n        \n        //Set the report end date as today\n        final DateMidnight reportEnd;\n        if (report.getEnd() == null) {\n            reportEnd = new DateMidnight();\n            report.setEnd(reportEnd);\n        }\n        else {\n            reportEnd = report.getEnd();\n        }\n        \n        //Determine the best start date based on the selected interval\n        if (report.getStart() == null) {\n            final DateMidnight start;\n            switch (report.getInterval()) {\n                case MINUTE: {\n                    start = reportEnd.minusDays(1);\n                    break;\n                }\n                case FIVE_MINUTE: {\n                    start = reportEnd.minusDays(2);\n                    break;\n                }\n                case HOUR: {\n                    start = reportEnd.minusWeeks(1);\n                    break;\n                }\n                case DAY: {\n                    start = reportEnd.minusMonths(1);\n                    break;\n                }\n                case WEEK: {\n                    start = reportEnd.minusMonths(3);\n                    break;\n                }\n                case MONTH: {\n                    start = reportEnd.minusYears(1);\n                    break;\n                }\n                case ACADEMIC_TERM: {\n                    start = reportEnd.minusYears(2);\n                    break;\n                }\n                case CALENDAR_QUARTER: {\n                    start = reportEnd.minusYears(2);\n                    break;\n                }\n                case YEAR: {\n                    start = reportEnd.minusYears(10);\n                    break;\n                }\n                default: {\n                    start = reportEnd.minusWeeks(1);\n                }\n            }\n            \n            report.setStart(start);\n        }\n    }","commit_id":"9695453ec6c4b8c1be0f162bf017fc7ae1a0f426","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @return The default report request form to use, populates the initial form view\n     */\n    @ModelAttribute(\"reportRequest\")\n    public final F getReportForm() {\n        final F report = createReportFormRequest();\n        \n        setReportFormDateRangeAndInterval(report);\n        \n        setReportFormGroups(report);\n\n        return report;\n    }","id":80757,"modified_method":"/**\n     * @return The default report request form to use, populates the initial form view\n     */\n    @ModelAttribute(\"reportRequest\")\n    public final F getReportForm(F report) {\n        setReportFormDateRangeAndInterval(report);\n        \n        setReportFormGroups(report);\n\n        return report;\n    }","commit_id":"9695453ec6c4b8c1be0f162bf017fc7ae1a0f426","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected Object[] filterQuery(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tThreadLocalCache<Object[]> threadLocalCache =\n\t\t\tThreadLocalCacheManager.getThreadLocalCache(\n\t\t\t\tLifecycle.REQUEST, AssetEntryServiceImpl.class.getName());\n\n\t\tString key = entryQuery.toString();\n\n\t\tObject[] results = threadLocalCache.get(key);\n\n\t\tif (results != null) {\n\t\t\treturn results;\n\t\t}\n\n\t\tint end = entryQuery.getEnd();\n\t\tint start = entryQuery.getStart();\n\n\t\tentryQuery.setEnd(end + PropsValues.ASSET_FILTER_SEARCH_LIMIT);\n\t\tentryQuery.setStart(0);\n\n\t\tList<AssetEntry> entries = assetEntryLocalService.getEntries(\n\t\t\tentryQuery);\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tList<AssetEntry> filteredEntries = new ArrayList<AssetEntry>();\n\n\t\tfor (AssetEntry entry : entries) {\n\t\t\tString className = entry.getClassName();\n\t\t\tlong classPK = entry.getClassPK();\n\n\t\t\tAssetRendererFactory assetRendererFactory =\n\t\t\t\tAssetRendererFactoryRegistryUtil.\n\t\t\t\t\tgetAssetRendererFactoryByClassName(className);\n\n\t\t\ttry {\n\t\t\t\tif (assetRendererFactory.hasPermission(\n\t\t\t\t\t\tpermissionChecker, classPK, ActionKeys.VIEW)) {\n\n\t\t\t\t\tfilteredEntries.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\n\t\tint length = filteredEntries.size();\n\n\t\tif ((end != QueryUtil.ALL_POS) && (start != QueryUtil.ALL_POS)) {\n\t\t\tif (end > length) {\n\t\t\t\tend = length;\n\t\t\t}\n\n\t\t\tif (start > length) {\n\t\t\t\tstart = length;\n\t\t\t}\n\n\t\t\tfilteredEntries = filteredEntries.subList(start, end);\n\t\t}\n\n\t\tentryQuery.setEnd(end);\n\t\tentryQuery.setStart(start);\n\n\t\tresults = new Object[] {filteredEntries, length};\n\n\t\tthreadLocalCache.put(key, results);\n\n\t\treturn results;\n\t}","id":80758,"modified_method":"protected Object[] filterQuery(AssetEntryQuery entryQuery)\n\t\tthrows PortalException, SystemException {\n\n\t\tThreadLocalCache<Object[]> threadLocalCache =\n\t\t\tThreadLocalCacheManager.getThreadLocalCache(\n\t\t\t\tLifecycle.REQUEST, AssetEntryServiceImpl.class.getName());\n\n\t\tString key = entryQuery.toString();\n\n\t\tObject[] results = threadLocalCache.get(key);\n\n\t\tif (results != null) {\n\t\t\treturn results;\n\t\t}\n\n\t\tint end = entryQuery.getEnd();\n\t\tint start = entryQuery.getStart();\n\n\t\tif (entryQuery.isEnablePermissions()) {\n\t\t\tentryQuery.setEnd(end + PropsValues.ASSET_FILTER_SEARCH_LIMIT);\n\t\t\tentryQuery.setStart(0);\n\t\t}\n\n\t\tList<AssetEntry> entries = assetEntryLocalService.getEntries(\n\t\t\tentryQuery);\n\n\t\tList<AssetEntry> filteredEntries = null;\n\t\tint length = 0;\n\n\t\tif (entryQuery.isEnablePermissions()) {\n\t\t\t\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\t\tfilteredEntries = new ArrayList<AssetEntry>();\n\n\t\t\tfor (AssetEntry entry : entries) {\n\t\t\t\tString className = entry.getClassName();\n\t\t\t\tlong classPK = entry.getClassPK();\n\n\t\t\t\tAssetRendererFactory assetRendererFactory =\n\t\t\t\t\tAssetRendererFactoryRegistryUtil.\n\t\t\t\t\t\tgetAssetRendererFactoryByClassName(className);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (assetRendererFactory.hasPermission(\n\t\t\t\t\t\t\tpermissionChecker, classPK, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\tfilteredEntries.add(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\n\t\t\t\tif (filteredEntries.size() > end) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlength = filteredEntries.size();\n\n\t\t\tif ((end != QueryUtil.ALL_POS) && (start != QueryUtil.ALL_POS)) {\n\t\t\t\tif (end > length) {\n\t\t\t\t\tend = length;\n\t\t\t\t}\n\n\t\t\t\tif (start > length) {\n\t\t\t\t\tstart = length;\n\t\t\t\t}\n\n\t\t\t\tfilteredEntries = filteredEntries.subList(start, end);\n\t\t\t}\n\n\t\t\tentryQuery.setEnd(end);\n\t\t\tentryQuery.setStart(start);\n\t\t}\n\t\telse {\n\t\t\tfilteredEntries = entries;\n\t\t\tlength = entries.size();\n\t\t}\n\n\t\tresults = new Object[] {filteredEntries, length};\n\n\t\tthreadLocalCache.put(key, results);\n\n\t\treturn results;\n\t}","commit_id":"2811918a9d05e0dfbe7dfde7cbef61b4c714a3fa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public RequestSecurityTokenResponseType cancel(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n        \n        KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        \n        ReceivedToken cancelTarget = tokenRequirements.getCancelTarget();\n        if (cancelTarget == null || cancelTarget.getToken() == null) {\n            throw new STSException(\"No element presented for cancellation\", STSException.INVALID_REQUEST);\n        }\n        if (tokenRequirements.getTokenType() == null) {\n            tokenRequirements.setTokenType(STSConstants.STATUS);\n            LOG.fine(\n                \"Received TokenType is null, falling back to default token type: \" + STSConstants.STATUS\n            );\n        }\n        \n        TokenCancellerParameters cancellerParameters = new TokenCancellerParameters();\n        cancellerParameters.setStsProperties(stsProperties);\n        cancellerParameters.setPrincipal(context.getUserPrincipal());\n        cancellerParameters.setWebServiceContext(context);\n        cancellerParameters.setTokenStore(getTokenStore());\n        \n        cancellerParameters.setKeyRequirements(keyRequirements);\n        cancellerParameters.setTokenRequirements(tokenRequirements);   \n        cancellerParameters.setToken(cancelTarget);\n        \n        //\n        // Cancel token\n        //\n        TokenCancellerResponse tokenResponse = null;\n        for (TokenCanceller tokenCanceller : tokencancellers) {\n            if (tokenCanceller.canHandleToken(cancelTarget)) {\n                try {\n                    tokenResponse = tokenCanceller.cancelToken(cancellerParameters);\n                } catch (RuntimeException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw new STSException(\n                        \"Error while cancelling a token\", ex, STSException.REQUEST_FAILED\n                    );\n                }\n                break;\n            }\n        }\n        if (tokenResponse == null || tokenResponse.getToken() == null) {\n            LOG.fine(\"No Token Canceller has been found that can handle this token\");\n            throw new STSException(\n                \"No token canceller found for requested token type: \" \n                + tokenRequirements.getTokenType(), \n                STSException.REQUEST_FAILED\n            );\n        }\n        \n        if (tokenResponse.getToken().getState() != STATE.CANCELLED) {\n            LOG.log(Level.WARNING, \"Token cancellation failed.\");\n            throw new STSException(\"Token cancellation failed.\");\n        }\n        \n        // prepare response\n        try {\n            return createResponse(tokenRequirements);\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80759,"modified_method":"public RequestSecurityTokenResponseType cancel(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenCancellerParameters cancellerParameters = new TokenCancellerParameters();\n        \n        try {\n            RequestParser requestParser = parseRequest(request, context);\n            \n            KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            \n            cancellerParameters.setStsProperties(stsProperties);\n            cancellerParameters.setPrincipal(context.getUserPrincipal());\n            cancellerParameters.setWebServiceContext(context);\n            cancellerParameters.setTokenStore(getTokenStore());\n            \n            cancellerParameters.setKeyRequirements(keyRequirements);\n            cancellerParameters.setTokenRequirements(tokenRequirements);  \n            \n            ReceivedToken cancelTarget = tokenRequirements.getCancelTarget();\n            if (cancelTarget == null || cancelTarget.getToken() == null) {\n                throw new STSException(\"No element presented for cancellation\", STSException.INVALID_REQUEST);\n            }\n            cancellerParameters.setToken(cancelTarget);\n            \n            if (tokenRequirements.getTokenType() == null) {\n                tokenRequirements.setTokenType(STSConstants.STATUS);\n                LOG.fine(\n                    \"Received TokenType is null, falling back to default token type: \" + STSConstants.STATUS\n                );\n            }\n            \n            //\n            // Cancel token\n            //\n            TokenCancellerResponse tokenResponse = null;\n            for (TokenCanceller tokenCanceller : tokencancellers) {\n                if (tokenCanceller.canHandleToken(cancelTarget)) {\n                    try {\n                        tokenResponse = tokenCanceller.cancelToken(cancellerParameters);\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\n                            \"Error while cancelling a token\", ex, STSException.REQUEST_FAILED\n                        );\n                    }\n                    break;\n                }\n            }\n            if (tokenResponse == null || tokenResponse.getToken() == null) {\n                LOG.fine(\"No Token Canceller has been found that can handle this token\");\n                throw new STSException(\n                    \"No token canceller found for requested token type: \" \n                    + tokenRequirements.getTokenType(), \n                    STSException.REQUEST_FAILED\n                );\n            }\n            \n            if (tokenResponse.getToken().getState() != STATE.CANCELLED) {\n                LOG.log(Level.WARNING, \"Token cancellation failed.\");\n                throw new STSException(\"Token cancellation failed.\");\n            }\n            \n            // prepare response\n            try {\n                RequestSecurityTokenResponseType response = createResponse(tokenRequirements);\n                ApplicationEvent event = new STSCancelSuccessEvent(cancellerParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n        \n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSCancelFailureEvent(cancellerParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }\n    }","commit_id":"82cde9eefdf806ca1df735f350b4ae452ef84ca0","url":"https://github.com/apache/cxf"},{"original_method":"public RequestSecurityTokenResponseType issueSingle(\n            RequestSecurityTokenType request,\n            WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n\n        TokenProviderParameters providerParameters = createTokenProviderParameters(requestParser, context);\n\n        // Check if the requested claims can be handled by the configured claim handlers\n        RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n        checkClaimsSupport(requestedClaims);\n        requestedClaims = providerParameters.getRequestedSecondaryClaims();\n        checkClaimsSupport(requestedClaims);\n        providerParameters.setClaimsManager(claimsManager);\n        \n        String realm = providerParameters.getRealm();\n\n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        String tokenType = tokenRequirements.getTokenType();\n\n\n        // Validate OnBehalfOf token if present\n        if (providerParameters.getTokenRequirements().getOnBehalfOf() != null) {\n            ReceivedToken validateTarget = providerParameters.getTokenRequirements().getOnBehalfOf();\n            TokenValidatorResponse tokenResponse = validateReceivedToken(\n                    context, realm, tokenRequirements, validateTarget);\n\n            if (tokenResponse == null) {\n                LOG.fine(\"No Token Validator has been found that can handle this token\");\n            } else if (validateTarget.getState().equals(STATE.INVALID)) {\n                throw new STSException(\"Incoming token is invalid\", STSException.REQUEST_FAILED);\n            } else if (validateTarget.getState().equals(STATE.VALID)) {\n                processValidToken(providerParameters, validateTarget, tokenResponse); \n            } else {\n                //[TODO] Add plugin for validation out-of-band\n                // Example:\n                // If the requestor is in the possession of a certificate (mutual ssl handshake)\n                // the STS trusts the token sent in OnBehalfOf element\n            }\n            if (tokenResponse != null) {\n                Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n                if (additionalProperties != null) {\n                    providerParameters.setAdditionalProperties(additionalProperties);\n                }\n            }\n        }\n\n        // create token\n        TokenProviderResponse tokenResponse = null;\n        for (TokenProvider tokenProvider : tokenProviders) {\n            boolean canHandle = false;\n            if (realm == null) {\n                canHandle = tokenProvider.canHandleToken(tokenType);\n            } else {\n                canHandle = tokenProvider.canHandleToken(tokenType, realm);\n            }\n            if (canHandle) {\n                try {\n                    tokenResponse = tokenProvider.createToken(providerParameters);\n                } catch (STSException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw ex;\n                } catch (RuntimeException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw new STSException(\"Error in providing a token\", ex, STSException.REQUEST_FAILED);\n                }\n                break;\n            }\n        }\n        if (tokenResponse == null || tokenResponse.getToken() == null) {\n            LOG.log(Level.WARNING, \"No token provider found for requested token type: \" + tokenType);\n            throw new STSException(\n                    \"No token provider found for requested token type: \" + tokenType, \n                    STSException.REQUEST_FAILED\n            );\n        }\n        // prepare response\n        try {\n            KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n            EncryptionProperties encryptionProperties = providerParameters.getEncryptionProperties();\n            RequestSecurityTokenResponseType response = \n                createResponse(\n                        encryptionProperties, tokenResponse, tokenRequirements, keyRequirements, context\n                );\n            return response;\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80760,"modified_method":"public RequestSecurityTokenResponseType issueSingle(\n            RequestSecurityTokenType request,\n            WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenProviderParameters providerParameters = new TokenProviderParameters();\n        try {\n            RequestParser requestParser = parseRequest(request, context);\n    \n            providerParameters = createTokenProviderParameters(requestParser, context);\n    \n            // Check if the requested claims can be handled by the configured claim handlers\n            RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n            checkClaimsSupport(requestedClaims);\n            requestedClaims = providerParameters.getRequestedSecondaryClaims();\n            checkClaimsSupport(requestedClaims);\n            providerParameters.setClaimsManager(claimsManager);\n            \n            String realm = providerParameters.getRealm();\n    \n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            String tokenType = tokenRequirements.getTokenType();\n    \n    \n            // Validate OnBehalfOf token if present\n            if (providerParameters.getTokenRequirements().getOnBehalfOf() != null) {\n                ReceivedToken validateTarget = providerParameters.getTokenRequirements().getOnBehalfOf();\n                TokenValidatorResponse tokenResponse = validateReceivedToken(\n                        context, realm, tokenRequirements, validateTarget);\n    \n                if (tokenResponse == null) {\n                    LOG.fine(\"No Token Validator has been found that can handle this token\");\n                } else if (validateTarget.getState().equals(STATE.INVALID)) {\n                    throw new STSException(\"Incoming token is invalid\", STSException.REQUEST_FAILED);\n                } else if (validateTarget.getState().equals(STATE.VALID)) {\n                    processValidToken(providerParameters, validateTarget, tokenResponse); \n                } else {\n                    //[TODO] Add plugin for validation out-of-band\n                    // Example:\n                    // If the requestor is in the possession of a certificate (mutual ssl handshake)\n                    // the STS trusts the token sent in OnBehalfOf element\n                }\n                if (tokenResponse != null) {\n                    Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n                    if (additionalProperties != null) {\n                        providerParameters.setAdditionalProperties(additionalProperties);\n                    }\n                }\n            }\n    \n            // create token\n            TokenProviderResponse tokenResponse = null;\n            for (TokenProvider tokenProvider : tokenProviders) {\n                boolean canHandle = false;\n                if (realm == null) {\n                    canHandle = tokenProvider.canHandleToken(tokenType);\n                } else {\n                    canHandle = tokenProvider.canHandleToken(tokenType, realm);\n                }\n                if (canHandle) {\n                    try {\n                        tokenResponse = tokenProvider.createToken(providerParameters);\n                    } catch (STSException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw ex;\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\"Error in providing a token\", ex, STSException.REQUEST_FAILED);\n                    }\n                    break;\n                }\n            }\n            if (tokenResponse == null || tokenResponse.getToken() == null) {\n                LOG.log(Level.WARNING, \"No token provider found for requested token type: \" + tokenType);\n                throw new STSException(\n                        \"No token provider found for requested token type: \" + tokenType, \n                        STSException.REQUEST_FAILED\n                );\n            }\n            // prepare response\n            try {\n                KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n                EncryptionProperties encryptionProperties = providerParameters.getEncryptionProperties();\n                RequestSecurityTokenResponseType response = \n                    createResponse(\n                            encryptionProperties, tokenResponse, tokenRequirements, keyRequirements, context\n                    );\n                ApplicationEvent event = new STSIssueSuccessEvent(providerParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n        \n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSIssueFailureEvent(providerParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }\n    }","commit_id":"82cde9eefdf806ca1df735f350b4ae452ef84ca0","url":"https://github.com/apache/cxf"},{"original_method":"public RequestSecurityTokenResponseType renew(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n\n        KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        \n        ReceivedToken renewTarget = tokenRequirements.getRenewTarget();\n        if (renewTarget == null || renewTarget.getToken() == null) {\n            throw new STSException(\"No element presented for renewal\", STSException.INVALID_REQUEST);\n        }\n        if (tokenRequirements.getTokenType() == null) {\n            LOG.fine(\"Received TokenType is null\");\n        }\n        \n        // Get the realm of the request\n        String realm = null;\n        if (stsProperties.getRealmParser() != null) {\n            RealmParser realmParser = stsProperties.getRealmParser();\n            realm = realmParser.parseRealm(context);\n        }\n        \n        // Validate the request\n        TokenValidatorResponse tokenResponse = validateReceivedToken(\n                context, realm, tokenRequirements, renewTarget);\n        \n        if (tokenResponse == null) {\n            LOG.fine(\"No Token Validator has been found that can handle this token\");\n            renewTarget.setState(STATE.INVALID);\n            throw new STSException(\n                \"No Token Validator has been found that can handle this token\" \n                + tokenRequirements.getTokenType(), \n                STSException.REQUEST_FAILED\n            );\n        }\n        \n        // Reject an invalid token\n        if (tokenResponse.getToken().getState() != STATE.EXPIRED\n            && tokenResponse.getToken().getState() != STATE.VALID) {\n            LOG.fine(\"The token is not valid or expired, and so it cannot be renewed\");\n            throw new STSException(\n                \"No Token Validator has been found that can handle this token\" \n                + tokenRequirements.getTokenType(), \n                STSException.REQUEST_FAILED\n            );\n        }\n        \n        //\n        // Renew the token\n        //\n        TokenRenewerResponse tokenRenewerResponse = null;\n        TokenRenewerParameters renewerParameters = createTokenRenewerParameters(requestParser, context);\n        Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n        if (additionalProperties != null) {\n            renewerParameters.setAdditionalProperties(additionalProperties);\n        }\n        renewerParameters.setRealm(tokenResponse.getTokenRealm());\n        renewerParameters.setToken(tokenResponse.getToken());\n\n        realm = tokenResponse.getTokenRealm();\n        for (TokenRenewer tokenRenewer : tokenRenewers) {\n            boolean canHandle = false;\n            if (realm == null) {\n                canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken());\n            } else {\n                canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken(), realm);\n            }\n            if (canHandle) {\n                try {\n                    tokenRenewerResponse = tokenRenewer.renewToken(renewerParameters);\n                } catch (STSException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw ex;\n                } catch (RuntimeException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw new STSException(\n                        \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                    );\n                }\n                break;\n            }\n        }\n        if (tokenRenewerResponse == null || tokenRenewerResponse.getToken() == null) {\n            LOG.fine(\"No Token Renewer has been found that can handle this token\");\n            throw new STSException(\n                \"No token renewer found for requested token type\", STSException.REQUEST_FAILED\n            );\n        }\n\n        // prepare response\n        try {\n            EncryptionProperties encryptionProperties = renewerParameters.getEncryptionProperties();\n            RequestSecurityTokenResponseType response = \n                createResponse(\n                    encryptionProperties, tokenRenewerResponse, tokenRequirements, keyRequirements, context\n                );\n            return response;\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80761,"modified_method":"public RequestSecurityTokenResponseType renew(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenRenewerParameters renewerParameters = new TokenRenewerParameters();\n        \n        try {\n            RequestParser requestParser = parseRequest(request, context);\n    \n            KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            \n            renewerParameters.setStsProperties(stsProperties);\n            renewerParameters.setPrincipal(context.getUserPrincipal());\n            renewerParameters.setWebServiceContext(context);\n            renewerParameters.setTokenStore(getTokenStore());\n            \n            renewerParameters.setKeyRequirements(keyRequirements);\n            renewerParameters.setTokenRequirements(tokenRequirements);  \n            \n            ReceivedToken renewTarget = tokenRequirements.getRenewTarget();\n            if (renewTarget == null || renewTarget.getToken() == null) {\n                throw new STSException(\"No element presented for renewal\", STSException.INVALID_REQUEST);\n            }\n            renewerParameters.setToken(renewTarget);\n            \n            if (tokenRequirements.getTokenType() == null) {\n                LOG.fine(\"Received TokenType is null\");\n            }\n            \n            // Get the realm of the request\n            String realm = null;\n            if (stsProperties.getRealmParser() != null) {\n                RealmParser realmParser = stsProperties.getRealmParser();\n                realm = realmParser.parseRealm(context);\n            }\n            renewerParameters.setRealm(realm);\n            \n            // Validate the request\n            TokenValidatorResponse tokenResponse = validateReceivedToken(\n                    context, realm, tokenRequirements, renewTarget);\n            \n            if (tokenResponse == null) {\n                LOG.fine(\"No Token Validator has been found that can handle this token\");\n                renewTarget.setState(STATE.INVALID);\n                throw new STSException(\n                    \"No Token Validator has been found that can handle this token\" \n                    + tokenRequirements.getTokenType(), \n                    STSException.REQUEST_FAILED\n                );\n            }\n            \n            // Reject an invalid token\n            if (tokenResponse.getToken().getState() != STATE.EXPIRED\n                && tokenResponse.getToken().getState() != STATE.VALID) {\n                LOG.fine(\"The token is not valid or expired, and so it cannot be renewed\");\n                throw new STSException(\n                    \"No Token Validator has been found that can handle this token\" \n                    + tokenRequirements.getTokenType(), \n                    STSException.REQUEST_FAILED\n                );\n            }\n            \n            //\n            // Renew the token\n            //\n            TokenRenewerResponse tokenRenewerResponse = null;\n            renewerParameters = createTokenRenewerParameters(requestParser, context);\n            Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n            if (additionalProperties != null) {\n                renewerParameters.setAdditionalProperties(additionalProperties);\n            }\n            renewerParameters.setRealm(tokenResponse.getTokenRealm());\n            renewerParameters.setToken(tokenResponse.getToken());\n    \n            realm = tokenResponse.getTokenRealm();\n            for (TokenRenewer tokenRenewer : tokenRenewers) {\n                boolean canHandle = false;\n                if (realm == null) {\n                    canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken());\n                } else {\n                    canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken(), realm);\n                }\n                if (canHandle) {\n                    try {\n                        tokenRenewerResponse = tokenRenewer.renewToken(renewerParameters);\n                    } catch (STSException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw ex;\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\n                            \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                        );\n                    }\n                    break;\n                }\n            }\n            if (tokenRenewerResponse == null || tokenRenewerResponse.getToken() == null) {\n                LOG.fine(\"No Token Renewer has been found that can handle this token\");\n                throw new STSException(\n                    \"No token renewer found for requested token type\", STSException.REQUEST_FAILED\n                );\n            }\n    \n            // prepare response\n            try {\n                EncryptionProperties encryptionProperties = renewerParameters.getEncryptionProperties();\n                RequestSecurityTokenResponseType response = \n                    createResponse(\n                        encryptionProperties, tokenRenewerResponse, tokenRequirements, keyRequirements, context\n                    );\n                ApplicationEvent event = new STSRenewSuccessEvent(renewerParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSRenewFailureEvent(renewerParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }            \n    }","commit_id":"82cde9eefdf806ca1df735f350b4ae452ef84ca0","url":"https://github.com/apache/cxf"},{"original_method":"public RequestSecurityTokenResponseType validate(\n        RequestSecurityTokenType request, \n        WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n        \n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        \n        ReceivedToken validateTarget = tokenRequirements.getValidateTarget();\n        if (validateTarget == null || validateTarget.getToken() == null) {\n            throw new STSException(\"No element presented for validation\", STSException.INVALID_REQUEST);\n        }\n        if (tokenRequirements.getTokenType() == null) {\n            tokenRequirements.setTokenType(STSConstants.STATUS);\n            LOG.fine(\n                \"Received TokenType is null, falling back to default token type: \" \n                + STSConstants.STATUS\n            );\n        }\n        \n        // Get the realm of the request\n        String realm = null;\n        if (stsProperties.getRealmParser() != null) {\n            RealmParser realmParser = stsProperties.getRealmParser();\n            realm = realmParser.parseRealm(context);\n        }\n        \n        TokenValidatorResponse tokenResponse = validateReceivedToken(\n                context, realm, tokenRequirements, validateTarget);\n        \n        if (tokenResponse == null) {\n            LOG.fine(\"No Token Validator has been found that can handle this token\");\n            tokenResponse = new TokenValidatorResponse();\n            validateTarget.setState(STATE.INVALID);\n            tokenResponse.setToken(validateTarget);\n        }\n        \n        //\n        // Create a new token (if requested)\n        //\n        TokenProviderResponse tokenProviderResponse = null;\n        String tokenType = tokenRequirements.getTokenType();\n        if (tokenResponse.getToken().getState() == STATE.VALID \n            && !STSConstants.STATUS.equals(tokenType)) {\n            TokenProviderParameters providerParameters = \n                 createTokenProviderParameters(requestParser, context);\n            \n            processValidToken(providerParameters, validateTarget, tokenResponse);\n            \n            // Check if the requested claims can be handled by the configured claim handlers\n            RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n            checkClaimsSupport(requestedClaims);\n            requestedClaims = providerParameters.getRequestedSecondaryClaims();\n            checkClaimsSupport(requestedClaims);\n            providerParameters.setClaimsManager(claimsManager);\n            \n            Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n            if (additionalProperties != null) {\n                providerParameters.setAdditionalProperties(additionalProperties);\n            }\n            realm = providerParameters.getRealm();\n            for (TokenProvider tokenProvider : tokenProviders) {\n                boolean canHandle = false;\n                if (realm == null) {\n                    canHandle = tokenProvider.canHandleToken(tokenType);\n                } else {\n                    canHandle = tokenProvider.canHandleToken(tokenType, realm);\n                }\n                if (canHandle) {\n                    try {\n                        tokenProviderResponse = tokenProvider.createToken(providerParameters);\n                    } catch (STSException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw ex;\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\n                            \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                        );\n                    }\n                    break;\n                }\n            }\n            if (tokenProviderResponse == null || tokenProviderResponse.getToken() == null) {\n                LOG.fine(\"No Token Provider has been found that can handle this token\");\n                throw new STSException(\n                    \"No token provider found for requested token type: \" + tokenType, \n                    STSException.REQUEST_FAILED\n                );\n            }\n        }\n        \n        // prepare response\n        try {\n            return createResponse(tokenResponse, tokenProviderResponse, tokenRequirements);\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80762,"modified_method":"public RequestSecurityTokenResponseType validate(\n        RequestSecurityTokenType request, \n        WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenValidatorParameters validatorParameters = new TokenValidatorParameters();\n        \n        try {\n            RequestParser requestParser = parseRequest(request, context);\n            \n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            \n            validatorParameters.setStsProperties(stsProperties);\n            validatorParameters.setPrincipal(context.getUserPrincipal());\n            validatorParameters.setWebServiceContext(context);\n            validatorParameters.setTokenStore(getTokenStore());\n            \n            //validatorParameters.setKeyRequirements(keyRequirements);\n            validatorParameters.setTokenRequirements(tokenRequirements);\n            \n            ReceivedToken validateTarget = tokenRequirements.getValidateTarget();\n            if (validateTarget == null || validateTarget.getToken() == null) {\n                throw new STSException(\"No element presented for validation\", STSException.INVALID_REQUEST);\n            }\n            validatorParameters.setToken(validateTarget);\n            \n            if (tokenRequirements.getTokenType() == null) {\n                tokenRequirements.setTokenType(STSConstants.STATUS);\n                LOG.fine(\n                    \"Received TokenType is null, falling back to default token type: \" \n                    + STSConstants.STATUS\n                );\n            }\n            \n            // Get the realm of the request\n            String realm = null;\n            if (stsProperties.getRealmParser() != null) {\n                RealmParser realmParser = stsProperties.getRealmParser();\n                realm = realmParser.parseRealm(context);\n            }\n            validatorParameters.setRealm(realm);\n            \n            TokenValidatorResponse tokenResponse = validateReceivedToken(\n                    context, realm, tokenRequirements, validateTarget);\n            \n            if (tokenResponse == null) {\n                LOG.fine(\"No Token Validator has been found that can handle this token\");\n                tokenResponse = new TokenValidatorResponse();\n                validateTarget.setState(STATE.INVALID);\n                tokenResponse.setToken(validateTarget);\n            }\n            \n            //\n            // Create a new token (if requested)\n            //\n            TokenProviderResponse tokenProviderResponse = null;\n            String tokenType = tokenRequirements.getTokenType();\n            if (tokenResponse.getToken().getState() == STATE.VALID \n                && !STSConstants.STATUS.equals(tokenType)) {\n                TokenProviderParameters providerParameters = \n                     createTokenProviderParameters(requestParser, context);\n                \n                processValidToken(providerParameters, validateTarget, tokenResponse);\n                \n                // Check if the requested claims can be handled by the configured claim handlers\n                RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n                checkClaimsSupport(requestedClaims);\n                requestedClaims = providerParameters.getRequestedSecondaryClaims();\n                checkClaimsSupport(requestedClaims);\n                providerParameters.setClaimsManager(claimsManager);\n                \n                Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n                if (additionalProperties != null) {\n                    providerParameters.setAdditionalProperties(additionalProperties);\n                }\n                realm = providerParameters.getRealm();\n                for (TokenProvider tokenProvider : tokenProviders) {\n                    boolean canHandle = false;\n                    if (realm == null) {\n                        canHandle = tokenProvider.canHandleToken(tokenType);\n                    } else {\n                        canHandle = tokenProvider.canHandleToken(tokenType, realm);\n                    }\n                    if (canHandle) {\n                        try {\n                            tokenProviderResponse = tokenProvider.createToken(providerParameters);\n                        } catch (STSException ex) {\n                            LOG.log(Level.WARNING, \"\", ex);\n                            throw ex;\n                        } catch (RuntimeException ex) {\n                            LOG.log(Level.WARNING, \"\", ex);\n                            throw new STSException(\n                                \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                            );\n                        }\n                        break;\n                    }\n                }\n                if (tokenProviderResponse == null || tokenProviderResponse.getToken() == null) {\n                    LOG.fine(\"No Token Provider has been found that can handle this token\");\n                    throw new STSException(\n                        \"No token provider found for requested token type: \" + tokenType, \n                        STSException.REQUEST_FAILED\n                    );\n                }\n            }\n            \n            // prepare response\n            try {\n                RequestSecurityTokenResponseType response =\n                    createResponse(tokenResponse, tokenProviderResponse, tokenRequirements);\n                ApplicationEvent event = new STSValidateSuccessEvent(validatorParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n            \n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSValidateFailureEvent(validatorParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }            \n    }","commit_id":"82cde9eefdf806ca1df735f350b4ae452ef84ca0","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Gets resource from the server.\n     *\n     * @param uri the resource uri.\n     * @return the server response.\n     * @throws XCapException if there is error during reading the resource's\n     *                       content.\n     */\n    protected XCapHttpResponse get(URI uri)\n            throws XCapException\n    {\n        DefaultHttpClient httpClient = createHttpClient();\n        try\n        {\n            HttpGet getMethod = new HttpGet(uri);\n            getMethod.setHeader(\"Connection\", \"close\");\n            Credentials credentials =\n                    new UsernamePasswordCredentials(getUserName(), password);\n            httpClient.getCredentialsProvider().\n                    setCredentials(AuthScope.ANY, credentials);\n            if (logger.isDebugEnabled())\n            {\n                String logMessage = String.format(\n                        \"Getting resource %1s from the server\",\n                        uri.toString()\n                );\n                logger.debug(logMessage);\n            }\n            HttpResponse response = httpClient.execute(getMethod);\n            return createResponse(response);\n        }\n        catch (IOException e)\n        {\n            String errorMessage = String.format(\n                    \"%1s resource cannot be read\",\n                    uri.toString());\n            throw new XCapException(errorMessage, e);\n        }\n        finally\n        {\n            httpClient.getConnectionManager().shutdown();\n        }\n    }","id":80763,"modified_method":"/**\n     * Gets resource from the server.\n     *\n     * @param uri the resource uri.\n     * @return the server response.\n     * @throws XCapException if there is error during reading the resource's\n     *                       content.\n     */\n    protected XCapHttpResponse get(URI uri)\n            throws XCapException\n    {\n        DefaultHttpClient httpClient = createHttpClient();\n        try\n        {\n            HttpGet getMethod = new HttpGet(uri);\n            getMethod.setHeader(\"Connection\", \"close\");\n            Credentials credentials =\n                    new UsernamePasswordCredentials(getUserName(), password);\n            httpClient.getCredentialsProvider().\n                    setCredentials(AuthScope.ANY, credentials);\n\n            HttpResponse response = httpClient.execute(getMethod);\n            XCapHttpResponse result = createResponse(response);\n            if (logger.isDebugEnabled())\n            {\n                byte[] contentBytes = result.getContent();\n                String contenString;\n                // for debug purposes print only xmls\n                // skip the icon queries\n                if(contentBytes != null && result.getContentType() != null\n                        && !result.getContentType().equalsIgnoreCase\n                        (PresContentClient.CONTENT_TYPE))\n                    contenString = new String(contentBytes);\n                else\n                    contenString = \"\";\n\n                String logMessage = String.format(\n                        \"Getting resource %1s from the server content:%2s\",\n                        uri.toString(),\n                        contenString\n                );\n                logger.debug(logMessage);\n            }\n            return result; \n        }\n        catch (IOException e)\n        {\n            String errorMessage = String.format(\n                    \"%1s resource cannot be read\",\n                    uri.toString());\n            throw new XCapException(errorMessage, e);\n        }\n        finally\n        {\n            httpClient.getConnectionManager().shutdown();\n        }\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates XCAP response from HTTP response.\n     * If HTTP code is 200, 201 or 409 the HTTP content would be readed.\n     *\n     * @param response the HTTP response.\n     * @return the XCAP response.\n     * @throws IOException if there is error during reading the HTTP content.\n     */\n    private XCapHttpResponse createResponse(HttpResponse response)\n            throws IOException\n    {\n        XCapHttpResponse XCapHttpResponse = new XCapHttpResponse();\n        int statusCode = response.getStatusLine().getStatusCode();\n        if (statusCode == HttpStatus.SC_OK ||\n                statusCode == HttpStatus.SC_CREATED ||\n                statusCode == HttpStatus.SC_CONFLICT)\n        {\n            String contentType = getSingleHeaderValue(response,\n                    HEADER_CONTENT_TYPE);\n            byte[] content = StreamUtils.read(\n                    response.getEntity().getContent());\n            String eTag = getSingleHeaderValue(response, HEADER_ETAG);\n            XCapHttpResponse.setContentType(contentType);\n            XCapHttpResponse.setContent(content);\n            XCapHttpResponse.setETag(eTag);\n        }\n        XCapHttpResponse.setHttpCode(statusCode);\n        return XCapHttpResponse;\n    }","id":80764,"modified_method":"/**\n     * Creates XCAP response from HTTP response.\n     * If HTTP code is 200, 201 or 409 the HTTP content would be readed.\n     *\n     * @param response the HTTP response.\n     * @return the XCAP response.\n     * @throws IOException if there is error during reading the HTTP content.\n     */\n    private XCapHttpResponse createResponse(HttpResponse response)\n            throws IOException\n    {\n        XCapHttpResponse xcapHttpResponse = new XCapHttpResponse();\n        int statusCode = response.getStatusLine().getStatusCode();\n        if (statusCode == HttpStatus.SC_OK ||\n                statusCode == HttpStatus.SC_CREATED ||\n                statusCode == HttpStatus.SC_CONFLICT)\n        {\n            String contentType = getSingleHeaderValue(response,\n                    HEADER_CONTENT_TYPE);\n            byte[] content = StreamUtils.read(\n                    response.getEntity().getContent());\n            String eTag = getSingleHeaderValue(response, HEADER_ETAG);\n            xcapHttpResponse.setContentType(contentType);\n            xcapHttpResponse.setContent(content);\n            xcapHttpResponse.setETag(eTag);\n        }\n        xcapHttpResponse.setHttpCode(statusCode);\n        return xcapHttpResponse;\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the image corresponding to the given presence status.\n     * @param status The presence status.\n     * @return the image corresponding to the given presence status.\n     */\n    public static BufferedImage getStatusIcon(PresenceStatus status)\n    {\n        if(status != null)\n        {\n            int connectivity = status.getStatus();\n\n            if(connectivity < PresenceStatus.ONLINE_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_OFFLINE_ICON);\n            }\n            else if(connectivity < PresenceStatus.AVAILABLE_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_AWAY_ICON);\n            }\n            else if(connectivity\n                        < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_ONLINE_ICON);\n            }\n            else if(connectivity < PresenceStatus.MAX_STATUS_VALUE)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_FFC_ICON);\n            }\n            else\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_OFFLINE_ICON);\n            }\n        }\n        else\n        {\n            return ImageLoader\n                .getImage(ImageLoader.USER_OFFLINE_ICON);\n        }\n    }","id":80765,"modified_method":"/**\n     * Returns the image corresponding to the given presence status.\n     * @param status The presence status.\n     * @return the image corresponding to the given presence status.\n     */\n    public static BufferedImage getStatusIcon(PresenceStatus status)\n    {\n        if(status != null)\n        {\n            int connectivity = status.getStatus();\n\n            if(connectivity < PresenceStatus.ONLINE_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_OFFLINE_ICON);\n            }\n            else if(connectivity < PresenceStatus.AWAY_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_DND_ICON);\n            }\n            else if(connectivity == PresenceStatus.AWAY_THRESHOLD)\n            {\n                // the special status On The Phone is state\n                // between DND and AWAY states.\n                return ImageLoader\n                    .getImage(ImageLoader.USER_USER_ON_THE_PHONE_ICON);\n            }\n            else if(connectivity < PresenceStatus.AVAILABLE_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_AWAY_ICON);\n            }\n            else if(connectivity\n                        < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_ONLINE_ICON);\n            }\n            else if(connectivity < PresenceStatus.MAX_STATUS_VALUE)\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_FFC_ICON);\n            }\n            else\n            {\n                return ImageLoader\n                    .getImage(ImageLoader.USER_OFFLINE_ICON);\n            }\n        }\n        else\n        {\n            return ImageLoader\n                .getImage(ImageLoader.USER_OFFLINE_ICON);\n        }\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> triggered when one of the items\n     * in the list is selected.\n     * @param e the <tt>ActionEvent<\/tt> that notified us\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n\n        Iterator<ProtocolProviderService> pProviders\n            = mainFrame.getProtocolProviders();\n\n        while (pProviders.hasNext())\n        {\n            ProtocolProviderService protocolProvider\n                = pProviders.next();\n\n            if(itemName.equals(Constants.ONLINE_STATUS))\n            {\n                if(!protocolProvider.isRegistered())\n                {\n                    saveStatusInformation(  protocolProvider,\n                        onlineItem.getName());\n\n                    GuiActivator.getUIService().getLoginManager()\n                        .login(protocolProvider);\n                }\n                else\n                {\n                    OperationSetPresence presence\n                        = protocolProvider\n                            .getOperationSet(OperationSetPresence.class);\n\n                    if (presence == null)\n                    {\n                        saveStatusInformation(  protocolProvider,\n                                                onlineItem.getName());\n\n                        continue;\n                    }\n\n                    Iterator<PresenceStatus> statusSet\n                        = presence.getSupportedStatusSet();\n\n                    while (statusSet.hasNext())\n                    {\n                        PresenceStatus status = statusSet.next();\n\n                        if( status.getStatus()\n                                < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD\n                            && status.getStatus()\n                                >= PresenceStatus.AVAILABLE_THRESHOLD)\n                        {\n                            new PublishPresenceStatusThread(presence, status)\n                                .start();\n\n                            this.saveStatusInformation( protocolProvider,\n                                                        status.getStatusName());\n\n                            break;\n                        }\n                    }\n                }\n            }\n            else if (itemName.equals(Constants.OFFLINE_STATUS))\n            {\n                if(    !protocolProvider.getRegistrationState()\n                                .equals(RegistrationState.UNREGISTERED)\n                    && !protocolProvider.getRegistrationState()\n                                .equals(RegistrationState.UNREGISTERING))\n                {\n                    OperationSetPresence presence\n                        = protocolProvider\n                            .getOperationSet(OperationSetPresence.class);\n\n                    if (presence == null)\n                    {\n                        saveStatusInformation(  protocolProvider,\n                                                offlineItem.getName());\n\n                        GuiActivator.getUIService().getLoginManager()\n                            .logoff(protocolProvider);\n\n                        continue;\n                    }\n\n                    Iterator<PresenceStatus> statusSet\n                        = presence.getSupportedStatusSet();\n\n                    while (statusSet.hasNext())\n                    {\n                        PresenceStatus status = statusSet.next();\n\n                        if(status.getStatus()\n                            < PresenceStatus.ONLINE_THRESHOLD)\n                        {\n                            this.saveStatusInformation( protocolProvider,\n                                status.getStatusName());\n\n                            break;\n                        }\n                    }\n\n                    try \n                    {\n                        GuiActivator.getUIService().getLoginManager()\n                            .setManuallyDisconnected(true);\n\n                        protocolProvider.unregister();\n                    }\n                    catch (OperationFailedException e1)\n                    {\n                        logger.error(\n                            \"Unable to unregister the protocol provider: \"\n                            + protocolProvider\n                            + \" due to the following exception: \" + e1);\n                    }\n                }\n            }\n            else if (itemName.equals(Constants.FREE_FOR_CHAT_STATUS))\n            {\n                if (!protocolProvider.isRegistered())\n                    continue;\n\n                OperationSetPresence presence\n                    = protocolProvider\n                        .getOperationSet(OperationSetPresence.class);\n\n                if (presence == null)\n                    continue;\n\n                Iterator<PresenceStatus> statusSet\n                    = presence.getSupportedStatusSet();\n\n                PresenceStatus status = null;\n\n                while (statusSet.hasNext())\n                {\n                    PresenceStatus currentStatus = statusSet.next();\n\n                    if (status == null)\n                        status = currentStatus; \n\n                    if(status.getStatus() < currentStatus.getStatus())\n                    {\n                        status = currentStatus;\n                    }\n                }\n\n                if (status != null)\n                {\n                    new PublishPresenceStatusThread(presence, status)\n                        .start();\n\n                    this.saveStatusInformation( protocolProvider,\n                        status.getStatusName());\n                }\n            }\n            else if (itemName.equals(Constants.AWAY_STATUS))\n            {\n                if (!protocolProvider.isRegistered())\n                    continue;\n\n                OperationSetPresence presence\n                    = protocolProvider\n                        .getOperationSet(OperationSetPresence.class);\n\n                if (presence == null)\n                    continue;\n\n                Iterator<PresenceStatus> statusSet\n                    = presence.getSupportedStatusSet();\n\n                PresenceStatus status = null;\n\n                while (statusSet.hasNext())\n                {\n                    PresenceStatus currentStatus = statusSet.next();\n\n                    if (status == null\n                        && currentStatus.getStatus()\n                            < PresenceStatus.AVAILABLE_THRESHOLD\n                        && currentStatus.getStatus()\n                            >= PresenceStatus.ONLINE_THRESHOLD)\n                    {\n                        status = currentStatus;\n                    }\n\n                    if (status != null) \n                    {\n                        if (currentStatus.getStatus()\n                                < PresenceStatus.AVAILABLE_THRESHOLD\n                                && currentStatus.getStatus()\n                                    >= PresenceStatus.ONLINE_THRESHOLD\n                                && currentStatus.getStatus()\n                                    > status.getStatus()) \n                        {\n                            status = currentStatus;\n                        }\n                    }\n                }\n\n                if (status != null)\n                {\n                    new PublishPresenceStatusThread(presence, status)\n                        .start();\n\n                    this.saveStatusInformation( protocolProvider,\n                        status.getStatusName());\n                }\n            }\n        }\n    }","id":80766,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> triggered when one of the items\n     * in the list is selected.\n     * @param e the <tt>ActionEvent<\/tt> that notified us\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n\n        Iterator<ProtocolProviderService> pProviders\n            = mainFrame.getProtocolProviders();\n\n        while (pProviders.hasNext())\n        {\n            ProtocolProviderService protocolProvider\n                = pProviders.next();\n\n            if(itemName.equals(Constants.ONLINE_STATUS))\n            {\n                if(!protocolProvider.isRegistered())\n                {\n                    saveStatusInformation(  protocolProvider,\n                        onlineItem.getName());\n\n                    GuiActivator.getUIService().getLoginManager()\n                        .login(protocolProvider);\n                }\n                else\n                {\n                    OperationSetPresence presence\n                        = protocolProvider\n                            .getOperationSet(OperationSetPresence.class);\n\n                    if (presence == null)\n                    {\n                        saveStatusInformation(  protocolProvider,\n                                                onlineItem.getName());\n\n                        continue;\n                    }\n\n                    Iterator<PresenceStatus> statusSet\n                        = presence.getSupportedStatusSet();\n\n                    while (statusSet.hasNext())\n                    {\n                        PresenceStatus status = statusSet.next();\n\n                        if( status.getStatus()\n                                < PresenceStatus.EAGER_TO_COMMUNICATE_THRESHOLD\n                            && status.getStatus()\n                                >= PresenceStatus.AVAILABLE_THRESHOLD)\n                        {\n                            new PublishPresenceStatusThread(presence, status)\n                                .start();\n\n                            this.saveStatusInformation( protocolProvider,\n                                                        status.getStatusName());\n\n                            break;\n                        }\n                    }\n                }\n            }\n            else if (itemName.equals(Constants.OFFLINE_STATUS))\n            {\n                if(    !protocolProvider.getRegistrationState()\n                                .equals(RegistrationState.UNREGISTERED)\n                    && !protocolProvider.getRegistrationState()\n                                .equals(RegistrationState.UNREGISTERING))\n                {\n                    OperationSetPresence presence\n                        = protocolProvider\n                            .getOperationSet(OperationSetPresence.class);\n\n                    if (presence == null)\n                    {\n                        saveStatusInformation(  protocolProvider,\n                                                offlineItem.getName());\n\n                        GuiActivator.getUIService().getLoginManager()\n                            .logoff(protocolProvider);\n\n                        continue;\n                    }\n\n                    Iterator<PresenceStatus> statusSet\n                        = presence.getSupportedStatusSet();\n\n                    while (statusSet.hasNext())\n                    {\n                        PresenceStatus status = statusSet.next();\n\n                        if(status.getStatus()\n                            < PresenceStatus.ONLINE_THRESHOLD)\n                        {\n                            this.saveStatusInformation( protocolProvider,\n                                status.getStatusName());\n\n                            break;\n                        }\n                    }\n\n                    try \n                    {\n                        GuiActivator.getUIService().getLoginManager()\n                            .setManuallyDisconnected(true);\n\n                        protocolProvider.unregister();\n                    }\n                    catch (OperationFailedException e1)\n                    {\n                        logger.error(\n                            \"Unable to unregister the protocol provider: \"\n                            + protocolProvider\n                            + \" due to the following exception: \" + e1);\n                    }\n                }\n            }\n            else if (itemName.equals(Constants.FREE_FOR_CHAT_STATUS))\n            {\n                // we search for highest available status here\n                publishStatus(\n                        protocolProvider,\n                        PresenceStatus.AVAILABLE_THRESHOLD,\n                        PresenceStatus.MAX_STATUS_VALUE);\n            }\n            else if (itemName.equals(Constants.DO_NOT_DISTURB_STATUS))\n            {\n                // status between online and away is DND\n                publishStatus(\n                        protocolProvider,\n                        PresenceStatus.ONLINE_THRESHOLD,\n                        PresenceStatus.AWAY_THRESHOLD);\n            }\n            else if (itemName.equals(Constants.AWAY_STATUS))\n            {\n                // a status in the away interval\n                publishStatus(\n                        protocolProvider,\n                        PresenceStatus.AWAY_THRESHOLD,\n                        PresenceStatus.AVAILABLE_THRESHOLD);\n            }\n        }\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>SimpleStatusSelectorBox<\/tt>.\n     *\n     * @param mainFrame The main application window.\n     */\n    public GlobalStatusSelectorBox(MainFrame mainFrame)\n    {\n        super();\n\n        this.mainFrame = mainFrame;\n\n        JLabel titleLabel = new JLabel(GuiActivator.getResources()\n                        .getI18NString(\"service.gui.SET_GLOBAL_STATUS\"));\n        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n\n        this.add(titleLabel);\n        this.addSeparator();\n\n        onlineItem\n            = createMenuItem(\n                \"service.gui.ONLINE\",\n                ImageLoader.USER_ONLINE_ICON,\n                Constants.ONLINE_STATUS);\n        ffcItem\n            = createMenuItem(\n                \"service.gui.FFC_STATUS\",\n                ImageLoader.USER_FFC_ICON,\n                Constants.FREE_FOR_CHAT_STATUS);\n        awayItem\n            = createMenuItem(\n                \"service.gui.AWAY_STATUS\",\n                ImageLoader.USER_AWAY_ICON,\n                Constants.AWAY_STATUS);\n        offlineItem\n            = createMenuItem(\n                \"service.gui.OFFLINE\",\n                ImageLoader.USER_OFFLINE_ICON,\n                Constants.OFFLINE_STATUS);\n\n        this.addSeparator();\n\n        this.setIcon(offlineItem.getIcon());\n        this.setIconTextGap(2);\n        this.setOpaque(false);\n        this.setText(\"Offline\");\n        this.setToolTipText(\"<html><b>\" + GuiActivator.getResources()\n                        .getI18NString(\"service.gui.SET_GLOBAL_STATUS\")\n                        + \"<\/b><\/html>\");\n        this.setUI(new SIPCommStatusMenuUI());\n\n        fitSizeToText();\n    }","id":80767,"modified_method":"/**\n     * Creates an instance of <tt>SimpleStatusSelectorBox<\/tt>.\n     *\n     * @param mainFrame The main application window.\n     */\n    public GlobalStatusSelectorBox(MainFrame mainFrame)\n    {\n        super();\n\n        this.mainFrame = mainFrame;\n\n        JLabel titleLabel = new JLabel(GuiActivator.getResources()\n                        .getI18NString(\"service.gui.SET_GLOBAL_STATUS\"));\n        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n\n        this.add(titleLabel);\n        this.addSeparator();\n\n        onlineItem\n            = createMenuItem(\n                \"service.gui.ONLINE\",\n                ImageLoader.USER_ONLINE_ICON,\n                Constants.ONLINE_STATUS);\n        ffcItem\n            = createMenuItem(\n                \"service.gui.FFC_STATUS\",\n                ImageLoader.USER_FFC_ICON,\n                Constants.FREE_FOR_CHAT_STATUS);\n        awayItem\n            = createMenuItem(\n                \"service.gui.AWAY_STATUS\",\n                ImageLoader.USER_AWAY_ICON,\n                Constants.AWAY_STATUS);\n        dndItem\n            = createMenuItem(\n                \"service.gui.DND_STATUS\",\n                ImageLoader.USER_DND_ICON,\n                Constants.DO_NOT_DISTURB_STATUS);\n        offlineItem\n            = createMenuItem(\n                \"service.gui.OFFLINE\",\n                ImageLoader.USER_OFFLINE_ICON,\n                Constants.OFFLINE_STATUS);\n\n        this.addSeparator();\n\n        this.setIcon(offlineItem.getIcon());\n        this.setIconTextGap(2);\n        this.setOpaque(false);\n        this.setText(\"Offline\");\n        this.setToolTipText(\"<html><b>\" + GuiActivator.getResources()\n                        .getI18NString(\"service.gui.SET_GLOBAL_STATUS\")\n                        + \"<\/b><\/html>\");\n        this.setUI(new SIPCommStatusMenuUI());\n\n        fitSizeToText();\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Init visible components.\n     */\n    private void init()\n    {\n        TransparentPanel panel = new TransparentPanel(new BorderLayout());\n\n        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n        // Title label\n        JLabel titleLabel = new JLabel(GuiActivator.getResources()\n                .getI18NString(\"service.gui.avatar.RECENT_ICONS\"));\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n        panel.add(titleLabel, BorderLayout.NORTH);\n\n\n        // Init recent images grid\n        TransparentPanel recentImagesGrid = new TransparentPanel();\n        recentImagesGrid.setLayout(new GridLayout(0, IMAGES_PER_COLUMN));\n\n        Dimension thumbsize = new Dimension(THUMB_WIDTH, THUMB_HEIGHT);\n        for (int i=0; i < MAX_STORED_IMAGES; i++)\n        {\n            this.recentImagesButtons[i] = new SIPCommButton(null);\n            this.recentImagesButtons[i].setBorder(BorderFactory.createEtchedBorder());\n            this.recentImagesButtons[i].setMaximumSize(thumbsize);\n            this.recentImagesButtons[i].setMinimumSize(thumbsize);\n            this.recentImagesButtons[i].setPreferredSize(thumbsize);\n            this.recentImagesButtons[i].addActionListener(this);\n            this.recentImagesButtons[i].setName(\"\" + i);\n            recentImagesGrid.add(this.recentImagesButtons[i]);\n        }\n\n        panel.add(recentImagesGrid, BorderLayout.CENTER);\n\n        // Action buttons\n        TransparentPanel buttonsPanel = new TransparentPanel();\n        buttonsPanel.setLayout(new GridLayout(0, 1));\n\n        // we use this menu item just to get its foreground color. \n        Color linkColor = new JMenuItem().getForeground();\n\n        addActionButton(buttonsPanel, this,\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.avatar.CHOOSE_ICON\"),\n                CHOSE_BUTTON_NAME,\n                linkColor);\n        addActionButton(buttonsPanel, this,\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.avatar.CLEAR_RECENT\"),\n                CLEAR_BUTTON_NAME,\n                linkColor);\n\n        panel.add(buttonsPanel, BorderLayout.SOUTH);\n\n        this.setLayout(new BorderLayout());\n        this.add(panel, BorderLayout.CENTER);\n    }","id":80768,"modified_method":"/**\n     * Init visible components.\n     */\n    private void init()\n    {\n        TransparentPanel panel = new TransparentPanel(new BorderLayout());\n\n        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n        // Title label\n        JLabel titleLabel = new JLabel(GuiActivator.getResources()\n                .getI18NString(\"service.gui.avatar.RECENT_ICONS\"));\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n\n        // fix for displaying text in menu\n        // when using a dark OS theme (as default one in ubuntu)\n        titleLabel.setForeground(new JMenuItem().getForeground());\n\n        panel.add(titleLabel, BorderLayout.NORTH);\n\n\n        // Init recent images grid\n        TransparentPanel recentImagesGrid = new TransparentPanel();\n        recentImagesGrid.setLayout(new GridLayout(0, IMAGES_PER_COLUMN));\n\n        Dimension thumbsize = new Dimension(THUMB_WIDTH, THUMB_HEIGHT);\n        for (int i=0; i < MAX_STORED_IMAGES; i++)\n        {\n            this.recentImagesButtons[i] = new SIPCommButton(null);\n            this.recentImagesButtons[i].setBorder(BorderFactory.createEtchedBorder());\n            this.recentImagesButtons[i].setMaximumSize(thumbsize);\n            this.recentImagesButtons[i].setMinimumSize(thumbsize);\n            this.recentImagesButtons[i].setPreferredSize(thumbsize);\n            this.recentImagesButtons[i].addActionListener(this);\n            this.recentImagesButtons[i].setName(\"\" + i);\n            recentImagesGrid.add(this.recentImagesButtons[i]);\n        }\n\n        panel.add(recentImagesGrid, BorderLayout.CENTER);\n\n        // Action buttons\n        TransparentPanel buttonsPanel = new TransparentPanel();\n        buttonsPanel.setLayout(new GridLayout(0, 1));\n\n        // we use this menu item just to get its foreground color. \n        Color linkColor = new JMenuItem().getForeground();\n\n        addActionButton(buttonsPanel, this,\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.avatar.CHOOSE_ICON\"),\n                CHOSE_BUTTON_NAME,\n                linkColor);\n        addActionButton(buttonsPanel, this,\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.avatar.CLEAR_RECENT\"),\n                CLEAR_BUTTON_NAME,\n                linkColor);\n\n        panel.add(buttonsPanel, BorderLayout.SOUTH);\n\n        this.setLayout(new BorderLayout());\n        this.add(panel, BorderLayout.CENTER);\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SipStatusEnum(String iconPath)\n    {\n        this.offlineStatus = new SipPresenceStatus(\n            0,\n            OFFLINE, \n            loadIcon(iconPath + \"/sip16x16-offline.png\"));\n\n        this.busyStatus = new SipPresenceStatus(\n            30,\n            BUSY,\n            loadIcon(iconPath + \"/sip16x16-busy.png\"));\n\n        this.onThePhoneStatus = new SipPresenceStatus(\n            37,\n            ON_THE_PHONE,\n            loadIcon(iconPath + \"/sip16x16-phone.png\"));\n\n        this.awayStatus = new SipPresenceStatus(\n            40,\n            AWAY,\n            loadIcon(iconPath + \"/sip16x16-away.png\"));\n\n        this.onlineStatus = new SipPresenceStatus(\n            65,\n            ONLINE,\n            loadIcon(iconPath + \"/sip16x16-online.png\"));\n\n        this.unknownStatus = new SipPresenceStatus(\n            1,\n            UNKNOWN,\n            loadIcon(iconPath + \"/sip16x16-offline.png\"));\n\n        // Initialize the list of supported status states.\n        supportedStatusSet.add(onlineStatus);\n        supportedStatusSet.add(awayStatus);\n        supportedStatusSet.add(onThePhoneStatus);\n        supportedStatusSet.add(busyStatus);\n        supportedStatusSet.add(offlineStatus);\n    }","id":80769,"modified_method":"public SipStatusEnum(String iconPath)\n    {\n        this.offlineStatus = new SipPresenceStatus(\n            0,\n            OFFLINE, \n            loadIcon(iconPath + \"/sip16x16-offline.png\"));\n\n        this.busyStatus = new SipPresenceStatus(\n            30,\n            BUSY,\n            loadIcon(iconPath + \"/sip16x16-busy.png\"));\n\n        this.onThePhoneStatus = new SipPresenceStatus(\n            31,\n            ON_THE_PHONE,\n            loadIcon(iconPath + \"/sip16x16-phone.png\"));\n\n        this.awayStatus = new SipPresenceStatus(\n            40,\n            AWAY,\n            loadIcon(iconPath + \"/sip16x16-away.png\"));\n\n        this.onlineStatus = new SipPresenceStatus(\n            65,\n            ONLINE,\n            loadIcon(iconPath + \"/sip16x16-online.png\"));\n\n        this.unknownStatus = new SipPresenceStatus(\n            1,\n            UNKNOWN,\n            loadIcon(iconPath + \"/sip16x16-offline.png\"));\n\n        // Initialize the list of supported status states.\n        supportedStatusSet.add(onlineStatus);\n        supportedStatusSet.add(awayStatus);\n        supportedStatusSet.add(onThePhoneStatus);\n        supportedStatusSet.add(busyStatus);\n        supportedStatusSet.add(offlineStatus);\n    }","commit_id":"aa4069067d4d4314904e3dadade9fa3478d853a9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public RequestSecurityTokenResponseType cancel(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n        \n        KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        \n        ReceivedToken cancelTarget = tokenRequirements.getCancelTarget();\n        if (cancelTarget == null || cancelTarget.getToken() == null) {\n            throw new STSException(\"No element presented for cancellation\", STSException.INVALID_REQUEST);\n        }\n        if (tokenRequirements.getTokenType() == null) {\n            tokenRequirements.setTokenType(STSConstants.STATUS);\n            LOG.fine(\n                \"Received TokenType is null, falling back to default token type: \" + STSConstants.STATUS\n            );\n        }\n        \n        TokenCancellerParameters cancellerParameters = new TokenCancellerParameters();\n        cancellerParameters.setStsProperties(stsProperties);\n        cancellerParameters.setPrincipal(context.getUserPrincipal());\n        cancellerParameters.setWebServiceContext(context);\n        cancellerParameters.setTokenStore(getTokenStore());\n        \n        cancellerParameters.setKeyRequirements(keyRequirements);\n        cancellerParameters.setTokenRequirements(tokenRequirements);   \n        cancellerParameters.setToken(cancelTarget);\n        \n        //\n        // Cancel token\n        //\n        TokenCancellerResponse tokenResponse = null;\n        for (TokenCanceller tokenCanceller : tokencancellers) {\n            if (tokenCanceller.canHandleToken(cancelTarget)) {\n                try {\n                    tokenResponse = tokenCanceller.cancelToken(cancellerParameters);\n                } catch (RuntimeException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw new STSException(\n                        \"Error while cancelling a token\", ex, STSException.REQUEST_FAILED\n                    );\n                }\n                break;\n            }\n        }\n        if (tokenResponse == null || tokenResponse.getToken() == null) {\n            LOG.fine(\"No Token Canceller has been found that can handle this token\");\n            throw new STSException(\n                \"No token canceller found for requested token type: \" \n                + tokenRequirements.getTokenType(), \n                STSException.REQUEST_FAILED\n            );\n        }\n        \n        if (tokenResponse.getToken().getState() != STATE.CANCELLED) {\n            LOG.log(Level.WARNING, \"Token cancellation failed.\");\n            throw new STSException(\"Token cancellation failed.\");\n        }\n        \n        // prepare response\n        try {\n            return createResponse(tokenRequirements);\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80770,"modified_method":"public RequestSecurityTokenResponseType cancel(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenCancellerParameters cancellerParameters = new TokenCancellerParameters();\n        \n        try {\n            RequestParser requestParser = parseRequest(request, context);\n            \n            KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            \n            cancellerParameters.setStsProperties(stsProperties);\n            cancellerParameters.setPrincipal(context.getUserPrincipal());\n            cancellerParameters.setWebServiceContext(context);\n            cancellerParameters.setTokenStore(getTokenStore());\n            \n            cancellerParameters.setKeyRequirements(keyRequirements);\n            cancellerParameters.setTokenRequirements(tokenRequirements);  \n            \n            ReceivedToken cancelTarget = tokenRequirements.getCancelTarget();\n            if (cancelTarget == null || cancelTarget.getToken() == null) {\n                throw new STSException(\"No element presented for cancellation\", STSException.INVALID_REQUEST);\n            }\n            cancellerParameters.setToken(cancelTarget);\n            \n            if (tokenRequirements.getTokenType() == null) {\n                tokenRequirements.setTokenType(STSConstants.STATUS);\n                LOG.fine(\n                    \"Received TokenType is null, falling back to default token type: \" + STSConstants.STATUS\n                );\n            }\n            \n            //\n            // Cancel token\n            //\n            TokenCancellerResponse tokenResponse = null;\n            for (TokenCanceller tokenCanceller : tokencancellers) {\n                if (tokenCanceller.canHandleToken(cancelTarget)) {\n                    try {\n                        tokenResponse = tokenCanceller.cancelToken(cancellerParameters);\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\n                            \"Error while cancelling a token\", ex, STSException.REQUEST_FAILED\n                        );\n                    }\n                    break;\n                }\n            }\n            if (tokenResponse == null || tokenResponse.getToken() == null) {\n                LOG.fine(\"No Token Canceller has been found that can handle this token\");\n                throw new STSException(\n                    \"No token canceller found for requested token type: \" \n                    + tokenRequirements.getTokenType(), \n                    STSException.REQUEST_FAILED\n                );\n            }\n            \n            if (tokenResponse.getToken().getState() != STATE.CANCELLED) {\n                LOG.log(Level.WARNING, \"Token cancellation failed.\");\n                throw new STSException(\"Token cancellation failed.\");\n            }\n            \n            // prepare response\n            try {\n                RequestSecurityTokenResponseType response = createResponse(tokenRequirements);\n                ApplicationEvent event = new STSCancelSuccessEvent(cancellerParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n        \n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSCancelFailureEvent(cancellerParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }\n    }","commit_id":"6cac783caab8741da93236de2223ac4dbe51fa8e","url":"https://github.com/apache/cxf"},{"original_method":"public RequestSecurityTokenResponseType issueSingle(\n            RequestSecurityTokenType request,\n            WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n\n        TokenProviderParameters providerParameters = createTokenProviderParameters(requestParser, context);\n\n        // Check if the requested claims can be handled by the configured claim handlers\n        RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n        checkClaimsSupport(requestedClaims);\n        requestedClaims = providerParameters.getRequestedSecondaryClaims();\n        checkClaimsSupport(requestedClaims);\n        providerParameters.setClaimsManager(claimsManager);\n        \n        String realm = providerParameters.getRealm();\n\n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        String tokenType = tokenRequirements.getTokenType();\n\n\n        // Validate OnBehalfOf token if present\n        if (providerParameters.getTokenRequirements().getOnBehalfOf() != null) {\n            ReceivedToken validateTarget = providerParameters.getTokenRequirements().getOnBehalfOf();\n            TokenValidatorResponse tokenResponse = validateReceivedToken(\n                    context, realm, tokenRequirements, validateTarget);\n\n            if (tokenResponse == null) {\n                LOG.fine(\"No Token Validator has been found that can handle this token\");\n            } else if (validateTarget.getState().equals(STATE.INVALID)) {\n                throw new STSException(\"Incoming token is invalid\", STSException.REQUEST_FAILED);\n            } else if (validateTarget.getState().equals(STATE.VALID)) {\n                processValidToken(providerParameters, validateTarget, tokenResponse); \n            } else {\n                //[TODO] Add plugin for validation out-of-band\n                // Example:\n                // If the requestor is in the possession of a certificate (mutual ssl handshake)\n                // the STS trusts the token sent in OnBehalfOf element\n            }\n            if (tokenResponse != null) {\n                Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n                if (additionalProperties != null) {\n                    providerParameters.setAdditionalProperties(additionalProperties);\n                }\n            }\n        }\n\n        // create token\n        TokenProviderResponse tokenResponse = null;\n        for (TokenProvider tokenProvider : tokenProviders) {\n            boolean canHandle = false;\n            if (realm == null) {\n                canHandle = tokenProvider.canHandleToken(tokenType);\n            } else {\n                canHandle = tokenProvider.canHandleToken(tokenType, realm);\n            }\n            if (canHandle) {\n                try {\n                    tokenResponse = tokenProvider.createToken(providerParameters);\n                } catch (STSException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw ex;\n                } catch (RuntimeException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw new STSException(\"Error in providing a token\", ex, STSException.REQUEST_FAILED);\n                }\n                break;\n            }\n        }\n        if (tokenResponse == null || tokenResponse.getToken() == null) {\n            LOG.log(Level.WARNING, \"No token provider found for requested token type: \" + tokenType);\n            throw new STSException(\n                    \"No token provider found for requested token type: \" + tokenType, \n                    STSException.REQUEST_FAILED\n            );\n        }\n        // prepare response\n        try {\n            KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n            EncryptionProperties encryptionProperties = providerParameters.getEncryptionProperties();\n            RequestSecurityTokenResponseType response = \n                createResponse(\n                        encryptionProperties, tokenResponse, tokenRequirements, keyRequirements, context\n                );\n            return response;\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80771,"modified_method":"public RequestSecurityTokenResponseType issueSingle(\n            RequestSecurityTokenType request,\n            WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenProviderParameters providerParameters = new TokenProviderParameters();\n        try {\n            RequestParser requestParser = parseRequest(request, context);\n    \n            providerParameters = createTokenProviderParameters(requestParser, context);\n    \n            // Check if the requested claims can be handled by the configured claim handlers\n            RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n            checkClaimsSupport(requestedClaims);\n            requestedClaims = providerParameters.getRequestedSecondaryClaims();\n            checkClaimsSupport(requestedClaims);\n            providerParameters.setClaimsManager(claimsManager);\n            \n            String realm = providerParameters.getRealm();\n    \n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            String tokenType = tokenRequirements.getTokenType();\n    \n    \n            // Validate OnBehalfOf token if present\n            if (providerParameters.getTokenRequirements().getOnBehalfOf() != null) {\n                ReceivedToken validateTarget = providerParameters.getTokenRequirements().getOnBehalfOf();\n                TokenValidatorResponse tokenResponse = validateReceivedToken(\n                        context, realm, tokenRequirements, validateTarget);\n    \n                if (tokenResponse == null) {\n                    LOG.fine(\"No Token Validator has been found that can handle this token\");\n                } else if (validateTarget.getState().equals(STATE.INVALID)) {\n                    throw new STSException(\"Incoming token is invalid\", STSException.REQUEST_FAILED);\n                } else if (validateTarget.getState().equals(STATE.VALID)) {\n                    processValidToken(providerParameters, validateTarget, tokenResponse); \n                } else {\n                    //[TODO] Add plugin for validation out-of-band\n                    // Example:\n                    // If the requestor is in the possession of a certificate (mutual ssl handshake)\n                    // the STS trusts the token sent in OnBehalfOf element\n                }\n                if (tokenResponse != null) {\n                    Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n                    if (additionalProperties != null) {\n                        providerParameters.setAdditionalProperties(additionalProperties);\n                    }\n                }\n            }\n    \n            // create token\n            TokenProviderResponse tokenResponse = null;\n            for (TokenProvider tokenProvider : tokenProviders) {\n                boolean canHandle = false;\n                if (realm == null) {\n                    canHandle = tokenProvider.canHandleToken(tokenType);\n                } else {\n                    canHandle = tokenProvider.canHandleToken(tokenType, realm);\n                }\n                if (canHandle) {\n                    try {\n                        tokenResponse = tokenProvider.createToken(providerParameters);\n                    } catch (STSException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw ex;\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\"Error in providing a token\", ex, STSException.REQUEST_FAILED);\n                    }\n                    break;\n                }\n            }\n            if (tokenResponse == null || tokenResponse.getToken() == null) {\n                LOG.log(Level.WARNING, \"No token provider found for requested token type: \" + tokenType);\n                throw new STSException(\n                        \"No token provider found for requested token type: \" + tokenType, \n                        STSException.REQUEST_FAILED\n                );\n            }\n            // prepare response\n            try {\n                KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n                EncryptionProperties encryptionProperties = providerParameters.getEncryptionProperties();\n                RequestSecurityTokenResponseType response = \n                    createResponse(\n                            encryptionProperties, tokenResponse, tokenRequirements, keyRequirements, context\n                    );\n                ApplicationEvent event = new STSIssueSuccessEvent(providerParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n        \n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSIssueFailureEvent(providerParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }\n    }","commit_id":"6cac783caab8741da93236de2223ac4dbe51fa8e","url":"https://github.com/apache/cxf"},{"original_method":"public RequestSecurityTokenResponseType renew(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n\n        KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        \n        ReceivedToken renewTarget = tokenRequirements.getRenewTarget();\n        if (renewTarget == null || renewTarget.getToken() == null) {\n            throw new STSException(\"No element presented for renewal\", STSException.INVALID_REQUEST);\n        }\n        if (tokenRequirements.getTokenType() == null) {\n            LOG.fine(\"Received TokenType is null\");\n        }\n        \n        // Get the realm of the request\n        String realm = null;\n        if (stsProperties.getRealmParser() != null) {\n            RealmParser realmParser = stsProperties.getRealmParser();\n            realm = realmParser.parseRealm(context);\n        }\n        \n        // Validate the request\n        TokenValidatorResponse tokenResponse = validateReceivedToken(\n                context, realm, tokenRequirements, renewTarget);\n        \n        if (tokenResponse == null) {\n            LOG.fine(\"No Token Validator has been found that can handle this token\");\n            renewTarget.setState(STATE.INVALID);\n            throw new STSException(\n                \"No Token Validator has been found that can handle this token\" \n                + tokenRequirements.getTokenType(), \n                STSException.REQUEST_FAILED\n            );\n        }\n        \n        // Reject an invalid token\n        if (tokenResponse.getToken().getState() != STATE.EXPIRED\n            && tokenResponse.getToken().getState() != STATE.VALID) {\n            LOG.fine(\"The token is not valid or expired, and so it cannot be renewed\");\n            throw new STSException(\n                \"No Token Validator has been found that can handle this token\" \n                + tokenRequirements.getTokenType(), \n                STSException.REQUEST_FAILED\n            );\n        }\n        \n        //\n        // Renew the token\n        //\n        TokenRenewerResponse tokenRenewerResponse = null;\n        TokenRenewerParameters renewerParameters = createTokenRenewerParameters(requestParser, context);\n        Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n        if (additionalProperties != null) {\n            renewerParameters.setAdditionalProperties(additionalProperties);\n        }\n        renewerParameters.setRealm(tokenResponse.getTokenRealm());\n        renewerParameters.setToken(tokenResponse.getToken());\n\n        realm = tokenResponse.getTokenRealm();\n        for (TokenRenewer tokenRenewer : tokenRenewers) {\n            boolean canHandle = false;\n            if (realm == null) {\n                canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken());\n            } else {\n                canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken(), realm);\n            }\n            if (canHandle) {\n                try {\n                    tokenRenewerResponse = tokenRenewer.renewToken(renewerParameters);\n                } catch (STSException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw ex;\n                } catch (RuntimeException ex) {\n                    LOG.log(Level.WARNING, \"\", ex);\n                    throw new STSException(\n                        \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                    );\n                }\n                break;\n            }\n        }\n        if (tokenRenewerResponse == null || tokenRenewerResponse.getToken() == null) {\n            LOG.fine(\"No Token Renewer has been found that can handle this token\");\n            throw new STSException(\n                \"No token renewer found for requested token type\", STSException.REQUEST_FAILED\n            );\n        }\n\n        // prepare response\n        try {\n            EncryptionProperties encryptionProperties = renewerParameters.getEncryptionProperties();\n            RequestSecurityTokenResponseType response = \n                createResponse(\n                    encryptionProperties, tokenRenewerResponse, tokenRequirements, keyRequirements, context\n                );\n            return response;\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80772,"modified_method":"public RequestSecurityTokenResponseType renew(\n        RequestSecurityTokenType request, WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenRenewerParameters renewerParameters = new TokenRenewerParameters();\n        \n        try {\n            RequestParser requestParser = parseRequest(request, context);\n    \n            KeyRequirements keyRequirements = requestParser.getKeyRequirements();\n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            \n            renewerParameters.setStsProperties(stsProperties);\n            renewerParameters.setPrincipal(context.getUserPrincipal());\n            renewerParameters.setWebServiceContext(context);\n            renewerParameters.setTokenStore(getTokenStore());\n            \n            renewerParameters.setKeyRequirements(keyRequirements);\n            renewerParameters.setTokenRequirements(tokenRequirements);  \n            \n            ReceivedToken renewTarget = tokenRequirements.getRenewTarget();\n            if (renewTarget == null || renewTarget.getToken() == null) {\n                throw new STSException(\"No element presented for renewal\", STSException.INVALID_REQUEST);\n            }\n            renewerParameters.setToken(renewTarget);\n            \n            if (tokenRequirements.getTokenType() == null) {\n                LOG.fine(\"Received TokenType is null\");\n            }\n            \n            // Get the realm of the request\n            String realm = null;\n            if (stsProperties.getRealmParser() != null) {\n                RealmParser realmParser = stsProperties.getRealmParser();\n                realm = realmParser.parseRealm(context);\n            }\n            renewerParameters.setRealm(realm);\n            \n            // Validate the request\n            TokenValidatorResponse tokenResponse = validateReceivedToken(\n                    context, realm, tokenRequirements, renewTarget);\n            \n            if (tokenResponse == null) {\n                LOG.fine(\"No Token Validator has been found that can handle this token\");\n                renewTarget.setState(STATE.INVALID);\n                throw new STSException(\n                    \"No Token Validator has been found that can handle this token\" \n                    + tokenRequirements.getTokenType(), \n                    STSException.REQUEST_FAILED\n                );\n            }\n            \n            // Reject an invalid token\n            if (tokenResponse.getToken().getState() != STATE.EXPIRED\n                && tokenResponse.getToken().getState() != STATE.VALID) {\n                LOG.fine(\"The token is not valid or expired, and so it cannot be renewed\");\n                throw new STSException(\n                    \"No Token Validator has been found that can handle this token\" \n                    + tokenRequirements.getTokenType(), \n                    STSException.REQUEST_FAILED\n                );\n            }\n            \n            //\n            // Renew the token\n            //\n            TokenRenewerResponse tokenRenewerResponse = null;\n            renewerParameters = createTokenRenewerParameters(requestParser, context);\n            Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n            if (additionalProperties != null) {\n                renewerParameters.setAdditionalProperties(additionalProperties);\n            }\n            renewerParameters.setRealm(tokenResponse.getTokenRealm());\n            renewerParameters.setToken(tokenResponse.getToken());\n    \n            realm = tokenResponse.getTokenRealm();\n            for (TokenRenewer tokenRenewer : tokenRenewers) {\n                boolean canHandle = false;\n                if (realm == null) {\n                    canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken());\n                } else {\n                    canHandle = tokenRenewer.canHandleToken(tokenResponse.getToken(), realm);\n                }\n                if (canHandle) {\n                    try {\n                        tokenRenewerResponse = tokenRenewer.renewToken(renewerParameters);\n                    } catch (STSException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw ex;\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\n                            \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                        );\n                    }\n                    break;\n                }\n            }\n            if (tokenRenewerResponse == null || tokenRenewerResponse.getToken() == null) {\n                LOG.fine(\"No Token Renewer has been found that can handle this token\");\n                throw new STSException(\n                    \"No token renewer found for requested token type\", STSException.REQUEST_FAILED\n                );\n            }\n    \n            // prepare response\n            try {\n                EncryptionProperties encryptionProperties = renewerParameters.getEncryptionProperties();\n                RequestSecurityTokenResponseType response = \n                    createResponse(\n                        encryptionProperties, tokenRenewerResponse, tokenRequirements, keyRequirements, context\n                    );\n                ApplicationEvent event = new STSRenewSuccessEvent(renewerParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSRenewFailureEvent(renewerParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }            \n    }","commit_id":"6cac783caab8741da93236de2223ac4dbe51fa8e","url":"https://github.com/apache/cxf"},{"original_method":"public RequestSecurityTokenResponseType validate(\n        RequestSecurityTokenType request, \n        WebServiceContext context\n    ) {\n        RequestParser requestParser = parseRequest(request, context);\n        \n        TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n        \n        ReceivedToken validateTarget = tokenRequirements.getValidateTarget();\n        if (validateTarget == null || validateTarget.getToken() == null) {\n            throw new STSException(\"No element presented for validation\", STSException.INVALID_REQUEST);\n        }\n        if (tokenRequirements.getTokenType() == null) {\n            tokenRequirements.setTokenType(STSConstants.STATUS);\n            LOG.fine(\n                \"Received TokenType is null, falling back to default token type: \" \n                + STSConstants.STATUS\n            );\n        }\n        \n        // Get the realm of the request\n        String realm = null;\n        if (stsProperties.getRealmParser() != null) {\n            RealmParser realmParser = stsProperties.getRealmParser();\n            realm = realmParser.parseRealm(context);\n        }\n        \n        TokenValidatorResponse tokenResponse = validateReceivedToken(\n                context, realm, tokenRequirements, validateTarget);\n        \n        if (tokenResponse == null) {\n            LOG.fine(\"No Token Validator has been found that can handle this token\");\n            tokenResponse = new TokenValidatorResponse();\n            validateTarget.setState(STATE.INVALID);\n            tokenResponse.setToken(validateTarget);\n        }\n        \n        //\n        // Create a new token (if requested)\n        //\n        TokenProviderResponse tokenProviderResponse = null;\n        String tokenType = tokenRequirements.getTokenType();\n        if (tokenResponse.getToken().getState() == STATE.VALID \n            && !STSConstants.STATUS.equals(tokenType)) {\n            TokenProviderParameters providerParameters = \n                 createTokenProviderParameters(requestParser, context);\n            \n            processValidToken(providerParameters, validateTarget, tokenResponse);\n            \n            // Check if the requested claims can be handled by the configured claim handlers\n            RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n            checkClaimsSupport(requestedClaims);\n            requestedClaims = providerParameters.getRequestedSecondaryClaims();\n            checkClaimsSupport(requestedClaims);\n            providerParameters.setClaimsManager(claimsManager);\n            \n            Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n            if (additionalProperties != null) {\n                providerParameters.setAdditionalProperties(additionalProperties);\n            }\n            realm = providerParameters.getRealm();\n            for (TokenProvider tokenProvider : tokenProviders) {\n                boolean canHandle = false;\n                if (realm == null) {\n                    canHandle = tokenProvider.canHandleToken(tokenType);\n                } else {\n                    canHandle = tokenProvider.canHandleToken(tokenType, realm);\n                }\n                if (canHandle) {\n                    try {\n                        tokenProviderResponse = tokenProvider.createToken(providerParameters);\n                    } catch (STSException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw ex;\n                    } catch (RuntimeException ex) {\n                        LOG.log(Level.WARNING, \"\", ex);\n                        throw new STSException(\n                            \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                        );\n                    }\n                    break;\n                }\n            }\n            if (tokenProviderResponse == null || tokenProviderResponse.getToken() == null) {\n                LOG.fine(\"No Token Provider has been found that can handle this token\");\n                throw new STSException(\n                    \"No token provider found for requested token type: \" + tokenType, \n                    STSException.REQUEST_FAILED\n                );\n            }\n        }\n        \n        // prepare response\n        try {\n            return createResponse(tokenResponse, tokenProviderResponse, tokenRequirements);\n        } catch (Throwable ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n            throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n        }\n    }","id":80773,"modified_method":"public RequestSecurityTokenResponseType validate(\n        RequestSecurityTokenType request, \n        WebServiceContext context\n    ) {\n        long start = System.currentTimeMillis();\n        TokenValidatorParameters validatorParameters = new TokenValidatorParameters();\n        \n        try {\n            RequestParser requestParser = parseRequest(request, context);\n            \n            TokenRequirements tokenRequirements = requestParser.getTokenRequirements();\n            \n            validatorParameters.setStsProperties(stsProperties);\n            validatorParameters.setPrincipal(context.getUserPrincipal());\n            validatorParameters.setWebServiceContext(context);\n            validatorParameters.setTokenStore(getTokenStore());\n            \n            //validatorParameters.setKeyRequirements(keyRequirements);\n            validatorParameters.setTokenRequirements(tokenRequirements);\n            \n            ReceivedToken validateTarget = tokenRequirements.getValidateTarget();\n            if (validateTarget == null || validateTarget.getToken() == null) {\n                throw new STSException(\"No element presented for validation\", STSException.INVALID_REQUEST);\n            }\n            validatorParameters.setToken(validateTarget);\n            \n            if (tokenRequirements.getTokenType() == null) {\n                tokenRequirements.setTokenType(STSConstants.STATUS);\n                LOG.fine(\n                    \"Received TokenType is null, falling back to default token type: \" \n                    + STSConstants.STATUS\n                );\n            }\n            \n            // Get the realm of the request\n            String realm = null;\n            if (stsProperties.getRealmParser() != null) {\n                RealmParser realmParser = stsProperties.getRealmParser();\n                realm = realmParser.parseRealm(context);\n            }\n            validatorParameters.setRealm(realm);\n            \n            TokenValidatorResponse tokenResponse = validateReceivedToken(\n                    context, realm, tokenRequirements, validateTarget);\n            \n            if (tokenResponse == null) {\n                LOG.fine(\"No Token Validator has been found that can handle this token\");\n                tokenResponse = new TokenValidatorResponse();\n                validateTarget.setState(STATE.INVALID);\n                tokenResponse.setToken(validateTarget);\n            }\n            \n            //\n            // Create a new token (if requested)\n            //\n            TokenProviderResponse tokenProviderResponse = null;\n            String tokenType = tokenRequirements.getTokenType();\n            if (tokenResponse.getToken().getState() == STATE.VALID \n                && !STSConstants.STATUS.equals(tokenType)) {\n                TokenProviderParameters providerParameters = \n                     createTokenProviderParameters(requestParser, context);\n                \n                processValidToken(providerParameters, validateTarget, tokenResponse);\n                \n                // Check if the requested claims can be handled by the configured claim handlers\n                RequestClaimCollection requestedClaims = providerParameters.getRequestedPrimaryClaims();\n                checkClaimsSupport(requestedClaims);\n                requestedClaims = providerParameters.getRequestedSecondaryClaims();\n                checkClaimsSupport(requestedClaims);\n                providerParameters.setClaimsManager(claimsManager);\n                \n                Map<String, Object> additionalProperties = tokenResponse.getAdditionalProperties();\n                if (additionalProperties != null) {\n                    providerParameters.setAdditionalProperties(additionalProperties);\n                }\n                realm = providerParameters.getRealm();\n                for (TokenProvider tokenProvider : tokenProviders) {\n                    boolean canHandle = false;\n                    if (realm == null) {\n                        canHandle = tokenProvider.canHandleToken(tokenType);\n                    } else {\n                        canHandle = tokenProvider.canHandleToken(tokenType, realm);\n                    }\n                    if (canHandle) {\n                        try {\n                            tokenProviderResponse = tokenProvider.createToken(providerParameters);\n                        } catch (STSException ex) {\n                            LOG.log(Level.WARNING, \"\", ex);\n                            throw ex;\n                        } catch (RuntimeException ex) {\n                            LOG.log(Level.WARNING, \"\", ex);\n                            throw new STSException(\n                                \"Error in providing a token\", ex, STSException.REQUEST_FAILED\n                            );\n                        }\n                        break;\n                    }\n                }\n                if (tokenProviderResponse == null || tokenProviderResponse.getToken() == null) {\n                    LOG.fine(\"No Token Provider has been found that can handle this token\");\n                    throw new STSException(\n                        \"No token provider found for requested token type: \" + tokenType, \n                        STSException.REQUEST_FAILED\n                    );\n                }\n            }\n            \n            // prepare response\n            try {\n                RequestSecurityTokenResponseType response =\n                    createResponse(tokenResponse, tokenProviderResponse, tokenRequirements);\n                ApplicationEvent event = new STSValidateSuccessEvent(validatorParameters,\n                        System.currentTimeMillis() - start);\n                publishEvent(event);\n                return response;\n            } catch (Throwable ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in creating the response\", ex, STSException.REQUEST_FAILED);\n            }\n            \n        } catch (RuntimeException ex) {\n            ApplicationEvent event = new STSValidateFailureEvent(validatorParameters,\n                                                              System.currentTimeMillis() - start, ex);\n            publishEvent(event);\n            throw ex;\n        }            \n    }","commit_id":"6cac783caab8741da93236de2223ac4dbe51fa8e","url":"https://github.com/apache/cxf"},{"original_method":"protected abstract ClientHttpResponse validateRequestInternal(ClientHttpRequest request)\n\t\t\tthrows IOException;","id":80774,"modified_method":"/**\n\t * Sub-classes must implement the actual validation of the request\n\t * matching it to a declared expectation.\n\t */\n\tprotected abstract ClientHttpResponse validateRequestInternal(ClientHttpRequest request)\n\t\t\tthrows IOException;","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic ClientHttpResponse validateRequest(ClientHttpRequest request) throws IOException {\n\t\tClientHttpResponse response = validateRequestInternal(request);\n\t\tgetRequests().add(request);\n\t\treturn response;\n\t}","id":80775,"modified_method":"@Override\n\tpublic ClientHttpResponse validateRequest(ClientHttpRequest request) throws IOException {\n\t\tif (getRequests().isEmpty()) {\n\t\t\tafterExpectationsDeclared();\n\t\t}\n\t\tClientHttpResponse response = validateRequestInternal(request);\n\t\tgetRequests().add(request);\n\t\treturn response;\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic ResponseActions expectRequest(RequestMatcher requestMatcher) {\n\t\tAssert.state(getRequests().isEmpty(), \"Cannot add more expectations after actual requests are made.\");\n\t\tRequestExpectation expectation = createExpectation(requestMatcher);\n\t\tgetExpectations().add(expectation);\n\t\treturn expectation;\n\t}","id":80776,"modified_method":"@Override\n\tpublic ResponseActions expectRequest(ExpectedCount count, RequestMatcher matcher) {\n\t\tAssert.state(getRequests().isEmpty(), \"Cannot add more expectations after actual requests are made.\");\n\t\tRequestExpectation expectation = new DefaultRequestExpectation(count, matcher);\n\t\tgetExpectations().add(expectation);\n\t\treturn expectation;\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void match(ClientHttpRequest request) throws IOException {\n\t\tfor (RequestMatcher matcher : this.requestMatchers) {\n\t\t\tmatcher.match(request);\n\t\t}\n\t}","id":80777,"modified_method":"@Override\n\tpublic void match(ClientHttpRequest request) throws IOException {\n\t\tfor (RequestMatcher matcher : getRequestMatchers()) {\n\t\t\tmatcher.match(request);\n\t\t}\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic ClientHttpResponse createResponse(ClientHttpRequest request) throws IOException {\n\t\tif (this.responseCreator == null) {\n\t\t\tthrow new IllegalStateException(\"createResponse called before ResponseCreator was set.\");\n\t\t}\n\t\treturn this.responseCreator.createResponse(request);\n\t}","id":80778,"modified_method":"@Override\n\tpublic ClientHttpResponse createResponse(ClientHttpRequest request) throws IOException {\n\t\tif (getResponseCreator() == null) {\n\t\t\tthrow new IllegalStateException(\"createResponse called before ResponseCreator was set.\");\n\t\t}\n\t\tgetRequestCount().incrementAndValidate();\n\t\treturn getResponseCreator().createResponse(request);\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public DefaultRequestExpectation(RequestMatcher requestMatcher) {\n\t\tAssert.notNull(requestMatcher, \"RequestMatcher is required\");\n\t\tthis.requestMatchers.add(requestMatcher);\n\t}","id":80779,"modified_method":"/**\n\t * Create a new request expectation that should be called a number of times\n\t * as indicated by {@code RequestCount}.\n\t * @param expectedCount the expected request expectedCount\n\t */\n\tpublic DefaultRequestExpectation(ExpectedCount expectedCount, RequestMatcher requestMatcher) {\n\t\tAssert.notNull(expectedCount, \"'expectedCount' is required\");\n\t\tAssert.notNull(requestMatcher, \"'requestMatcher' is required\");\n\t\tthis.requestCount = new RequestCount(expectedCount);\n\t\tthis.requestMatchers.add(requestMatcher);\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set up a new HTTP request expectation. The returned {@link ResponseActions}\n\t * is used to set up further expectations and to define the response.\n\t * <p>This method may be invoked multiple times before starting the test, i.e. before\n\t * using the {@code RestTemplate}, to set up expectations for multiple requests.\n\t * @param matcher a request expectation, see {@link MockRestRequestMatchers}\n\t * @return used to set up further expectations or to define a response\n\t */\n\tpublic ResponseActions expect(RequestMatcher matcher) {\n\t\treturn this.expectationManager.expectRequest(matcher);\n\t}","id":80780,"modified_method":"/**\n\t * Set up an expectation for a single HTTP request. The returned\n\t * {@link ResponseActions} can be used to set up further expectations as\n\t * well as to define the response.\n\t *\n\t * <p>This method may be invoked any number times before starting to make\n\t * request through the underlying {@code RestTemplate} in order to set up\n\t * all expected requests.\n\t *\n\t * @param matcher request matcher\n\t * @return a representation of the expectation\n\t */\n\tpublic ResponseActions expect(RequestMatcher matcher) {\n\t\treturn expect(ExpectedCount.once(), matcher);\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void verify() {\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"1\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"2\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"4\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"8\", MediaType.TEXT_PLAIN));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tListenableFuture<ResponseEntity<String>> result = this.restTemplate.getForEntity(\"/number\", String.class);\n\t\t// result == \"1\"\n\n\t\tresult = this.restTemplate.getForEntity(\"/number\", String.class);\n\t\t// result == \"2\"\n\n\t\ttry {\n\t\t\tthis.mockServer.verify();\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\tassertTrue(error.getMessage(), error.getMessage().contains(\"2 out of 4 were executed\"));\n\t\t}\n\t}","id":80781,"modified_method":"@Test\n\tpublic void verify() {\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"1\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"2\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"4\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"8\", MediaType.TEXT_PLAIN));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tListenableFuture<ResponseEntity<String>> result = this.restTemplate.getForEntity(\"/number\", String.class);\n\t\t// result == \"1\"\n\n\t\tresult = this.restTemplate.getForEntity(\"/number\", String.class);\n\t\t// result == \"2\"\n\n\t\ttry {\n\t\t\tthis.mockServer.verify();\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\tassertTrue(error.getMessage(), error.getMessage().contains(\"2 unsatisfied expectation(s)\"));\n\t\t}\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void performGetWithResponseBodyFromFile() throws Exception {\n\n\t\tResource responseBody = new ClassPathResource(\"ludwig.json\", this.getClass());\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tListenableFuture<ResponseEntity<Person>> ludwig = restTemplate.getForEntity(\"/composers/{id}\", Person.class, 42);\n\n\t\t// hotel.getId() == 42\n\t\t// hotel.getName().equals(\"Holiday Inn\")\n\n\t\tthis.mockServer.verify();\n\t}","id":80782,"modified_method":"@Test\n\tpublic void performGetWithResponseBodyFromFile() throws Exception {\n\n\t\tResource responseBody = new ClassPathResource(\"ludwig.json\", this.getClass());\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tListenableFuture<ResponseEntity<Person>> ludwig =\n\t\t\t\tthis.restTemplate.getForEntity(\"/composers/{id}\", Person.class, 42);\n\n\t\t// hotel.getId() == 42\n\t\t// hotel.getName().equals(\"Holiday Inn\")\n\n\t\tthis.mockServer.verify();\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void performGet() throws Exception {\n\n\t\tString responseBody = \"{\\\"name\\\" : \\\"Ludwig van Beethoven\\\", \\\"someDouble\\\" : \\\"1.6035\\\"}\";\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tListenableFuture<ResponseEntity<Person>> ludwig = restTemplate.getForEntity(\"/composers/{id}\", Person.class, 42);\n\n\t\t// We are only validating the request. The response is mocked out.\n\t\t// person.getName().equals(\"Ludwig van Beethoven\")\n\t\t// person.getDouble().equals(1.6035)\n\n\t\tthis.mockServer.verify();\n\t}","id":80783,"modified_method":"@Test\n\tpublic void performGet() throws Exception {\n\n\t\tString responseBody = \"{\\\"name\\\" : \\\"Ludwig van Beethoven\\\", \\\"someDouble\\\" : \\\"1.6035\\\"}\";\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tListenableFuture<ResponseEntity<Person>> ludwig =\n\t\t\t\tthis.restTemplate.getForEntity(\"/composers/{id}\", Person.class, 42);\n\n\t\t// We are only validating the request. The response is mocked out.\n\t\t// person.getName().equals(\"Ludwig van Beethoven\")\n\t\t// person.getDouble().equals(1.6035)\n\n\t\tthis.mockServer.verify();\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void verify() {\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"1\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"2\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"4\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"8\", MediaType.TEXT_PLAIN));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tString result = this.restTemplate.getForObject(\"/number\", String.class);\n\t\t// result == \"1\"\n\n\t\tresult = this.restTemplate.getForObject(\"/number\", String.class);\n\t\t// result == \"2\"\n\n\t\ttry {\n\t\t\tthis.mockServer.verify();\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\tassertTrue(error.getMessage(), error.getMessage().contains(\"2 out of 4 were executed\"));\n\t\t}\n\t}","id":80784,"modified_method":"@Test\n\tpublic void verify() {\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"1\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"2\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"4\", MediaType.TEXT_PLAIN));\n\n\t\tthis.mockServer.expect(requestTo(\"/number\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(\"8\", MediaType.TEXT_PLAIN));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tString result = this.restTemplate.getForObject(\"/number\", String.class);\n\t\t// result == \"1\"\n\n\t\tresult = this.restTemplate.getForObject(\"/number\", String.class);\n\t\t// result == \"2\"\n\n\t\ttry {\n\t\t\tthis.mockServer.verify();\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\tassertTrue(error.getMessage(), error.getMessage().contains(\"2 unsatisfied expectation(s)\"));\n\t\t}\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void performGetWithResponseBodyFromFile() throws Exception {\n\n\t\tResource responseBody = new ClassPathResource(\"ludwig.json\", this.getClass());\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tPerson ludwig = restTemplate.getForObject(\"/composers/{id}\", Person.class, 42);\n\n\t\t// hotel.getId() == 42\n\t\t// hotel.getName().equals(\"Holiday Inn\")\n\n\t\tthis.mockServer.verify();\n\t}","id":80785,"modified_method":"@Test\n\tpublic void performGetWithResponseBodyFromFile() throws Exception {\n\n\t\tResource responseBody = new ClassPathResource(\"ludwig.json\", this.getClass());\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tPerson ludwig = this.restTemplate.getForObject(\"/composers/{id}\", Person.class, 42);\n\n\t\t// hotel.getId() == 42\n\t\t// hotel.getName().equals(\"Holiday Inn\")\n\n\t\tthis.mockServer.verify();\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void performGet() throws Exception {\n\n\t\tString responseBody = \"{\\\"name\\\" : \\\"Ludwig van Beethoven\\\", \\\"someDouble\\\" : \\\"1.6035\\\"}\";\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tPerson ludwig = restTemplate.getForObject(\"/composers/{id}\", Person.class, 42);\n\n\t\t// We are only validating the request. The response is mocked out.\n\t\t// hotel.getId() == 42\n\t\t// hotel.getName().equals(\"Holiday Inn\")\n\n\t\tthis.mockServer.verify();\n\t}","id":80786,"modified_method":"@Test\n\tpublic void performGet() throws Exception {\n\n\t\tString responseBody = \"{\\\"name\\\" : \\\"Ludwig van Beethoven\\\", \\\"someDouble\\\" : \\\"1.6035\\\"}\";\n\n\t\tthis.mockServer.expect(requestTo(\"/composers/42\")).andExpect(method(HttpMethod.GET))\n\t\t\t.andRespond(withSuccess(responseBody, MediaType.APPLICATION_JSON));\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tPerson ludwig = this.restTemplate.getForObject(\"/composers/{id}\", Person.class, 42);\n\n\t\t// We are only validating the request. The response is mocked out.\n\t\t// hotel.getId() == 42\n\t\t// hotel.getName().equals(\"Holiday Inn\")\n\n\t\tthis.mockServer.verify();\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic ClientHttpResponse validateRequestInternal(ClientHttpRequest request) throws IOException {\n\t\tif (this.iterator == null) {\n\t\t\tthis.iterator = getExpectations().iterator();\n\t\t}\n\t\tif (!this.iterator.hasNext()) {\n\t\t\tHttpMethod method = request.getMethod();\n\t\t\tURI uri = request.getURI();\n\t\t\tString firstLine = \"No further requests expected: HTTP \" + method + \" \" + uri + \"\\n\";\n\t\t\tthrow new AssertionError(createErrorMessage(firstLine));\n\t\t}\n\t\tRequestExpectation expectation = this.iterator.next();\n\t\texpectation.match(request);\n\t\treturn expectation.createResponse(request);\n\t}","id":80787,"modified_method":"@Override\n\tpublic ClientHttpResponse validateRequestInternal(ClientHttpRequest request) throws IOException {\n\t\tRequestExpectation expectation;\n\t\ttry {\n\t\t\texpectation = next(request);\n\t\t\texpectation.match(request);\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\texpectation = this.repeatExpectations.findExpectation(request);\n\t\t\tif (expectation == null) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\tClientHttpResponse response = expectation.createResponse(request);\n\t\tthis.repeatExpectations.update(expectation);\n\t\treturn response;\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private ClientHttpRequest request(HttpMethod method, String url) {\n\t\ttry {\n\t\t\treturn new MockAsyncClientHttpRequest(method,  new URI(url));\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}","id":80788,"modified_method":"private ClientHttpRequest createRequest(HttpMethod method, String url) {\n\t\ttry {\n\t\t\treturn new MockAsyncClientHttpRequest(method,  new URI(url));\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void validateWithUnexpectedRequest() throws Exception {\n\t\ttry {\n\t\t\tthis.manager.validateRequest(request(HttpMethod.GET, \"/foo\"));\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\tassertEquals(\"No further requests expected: HTTP GET /foo\\n\" +\n\t\t\t\t\t\"0 out of 0 were executed\", error.getMessage());\n\t\t}\n\t}","id":80789,"modified_method":"@Test\n\tpublic void unexpectedRequest() throws Exception {\n\t\ttry {\n\t\t\tthis.manager.validateRequest(createRequest(GET, \"/foo\"));\n\t\t}\n\t\tcatch (AssertionError error) {\n\t\t\tassertEquals(\"No further requests expected: HTTP GET /foo\\n\" +\n\t\t\t\t\t\"0 request(s) executed.\\n\", error.getMessage());\n\t\t}\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic ClientHttpResponse validateRequestInternal(ClientHttpRequest request) throws IOException {\n\t\tif (getRequests().isEmpty()) {\n\t\t\tgetRemainingExpectations().addAll(getExpectations());\n\t\t}\n\t\tfor (RequestExpectation expectation : getExpectations()) {\n\t\t\ttry {\n\t\t\t\texpectation.match(request);\n\t\t\t\tgetRemainingExpectations().remove(expectation);\n\t\t\t\treturn expectation.createResponse(request);\n\t\t\t}\n\t\t\tcatch (AssertionError error) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t\tHttpMethod method = request.getMethod();\n\t\tURI uri = request.getURI();\n\t\tthrow new AssertionError(\"Unexpected request: HTTP \" + method + \" \" + uri);\n\t}","id":80790,"modified_method":"@Override\n\tpublic ClientHttpResponse validateRequestInternal(ClientHttpRequest request) throws IOException {\n\t\tRequestExpectation expectation = this.remainingExpectations.findExpectation(request);\n\t\tif (expectation != null) {\n\t\t\tClientHttpResponse response = expectation.createResponse(request);\n\t\t\tthis.remainingExpectations.update(expectation);\n\t\t\treturn response;\n\t\t}\n\t\tthrow createUnexpectedRequestError(request);\n\t}","commit_id":"91872b0d7469a96699181cb37727643450b12a05","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Postprocesses the diff result read and parsed from the server.\n     *\n     * Uploaded objects are assigned their new id (if they got assigned a new\n     * id by the server), their new version (if the version was incremented),\n     * and the id of the changeset to which they were uploaded.\n     *\n     * @param cs the current changeset. Ignored if null.\n     * @param monitor the progress monitor. Set to {@link NullProgressMonitor#INSTANCE} if null\n     * @return the collection of processed primitives\n     */\n    protected Set<OsmPrimitive> postProcess(Changeset cs, ProgressMonitor monitor) {\n        if (monitor == null) {\n            monitor = NullProgressMonitor.INSTANCE;\n        }\n        DataSet ds = primitives.iterator().next().getDataSet();\n        ds.beginUpdate();\n        try {\n            monitor.beginTask(\"Postprocessing uploaded data ...\");\n            monitor.setTicksCount(primitives.size());\n            monitor.setTicks(0);\n            for (OsmPrimitive p : primitives) {\n                monitor.worked(1);\n                DiffResultEntry entry = diffResults.get(p.getPrimitiveId());\n                if (entry == null) {\n                    continue;\n                }\n                processed.add(p);\n                if (!p.isDeleted()) {\n                    p.setOsmId(entry.new_id, entry.new_version);\n                    p.setVisible(true);\n                } else {\n                    p.setVisible(false);\n                }\n                if (cs != null && !cs.isNew()) {\n                    p.setChangesetId(cs.getId());\n                }\n            }\n            return processed;\n        } finally {\n            ds.endUpdate();\n            monitor.finishTask();\n        }\n    }","id":80791,"modified_method":"/**\n     * Postprocesses the diff result read and parsed from the server.\n     *\n     * Uploaded objects are assigned their new id (if they got assigned a new\n     * id by the server), their new version (if the version was incremented),\n     * and the id of the changeset to which they were uploaded.\n     *\n     * @param cs the current changeset. Ignored if null.\n     * @param monitor the progress monitor. Set to {@link NullProgressMonitor#INSTANCE} if null\n     * @return the collection of processed primitives\n     */\n    protected Set<OsmPrimitive> postProcess(Changeset cs, ProgressMonitor monitor) {\n        if (monitor == null) {\n            monitor = NullProgressMonitor.INSTANCE;\n        }\n        DataSet ds = null;\n        if (!primitives.isEmpty()) {\n            ds = primitives.iterator().next().getDataSet();\n        }\n        if (ds != null) {\n            ds.beginUpdate();\n        }\n        try {\n            monitor.beginTask(\"Postprocessing uploaded data ...\");\n            monitor.setTicksCount(primitives.size());\n            monitor.setTicks(0);\n            for (OsmPrimitive p : primitives) {\n                monitor.worked(1);\n                DiffResultEntry entry = diffResults.get(p.getPrimitiveId());\n                if (entry == null) {\n                    continue;\n                }\n                processed.add(p);\n                if (!p.isDeleted()) {\n                    p.setOsmId(entry.new_id, entry.new_version);\n                    p.setVisible(true);\n                } else {\n                    p.setVisible(false);\n                }\n                if (cs != null && !cs.isNew()) {\n                    p.setChangesetId(cs.getId());\n                }\n            }\n            return processed;\n        } finally {\n            if (ds != null) {\n                ds.endUpdate();\n            }\n            monitor.finishTask();\n        }\n    }","commit_id":"bec5b71d6fb5eae08ad522a327e98073ece29761","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n     * Formats a name for a relation\r\n     * \r\n     * @param relation the relation\r\n     * @return the name\r\n     */\r\n    public String format(Relation relation) {\r\n        String name;\r\n        if (relation.incomplete) {\r\n            name = tr(\"incomplete\");\r\n        } else {\r\n            name = relation.get(\"type\");\r\n            if (name == null) {\r\n                name = tr(\"relation\");\r\n            }\r\n\r\n            name += \" (\";\r\n            String nameTag = null;\r\n            Set<String> namingTags = new HashSet<String>(getNamingtagsForRelations());\r\n            for (String n : relation.keySet()) {\r\n                // #3328: \"note \" and \" note\" are name tags too\r\n                if (namingTags.contains(n.trim())) {\r\n                    if (Main.pref.getBoolean(\"osm-primitives.localize-name\", true)) {\r\n                        nameTag = relation.getLocalName();\r\n                    } else {\r\n                        nameTag = relation.getName();\r\n                    }\r\n                    if (nameTag == null) {\r\n                        nameTag = relation.get(n);\r\n                    }\r\n                }\r\n                if (nameTag != null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (nameTag == null) {\r\n                name += Long.toString(relation.getId()) + \", \";\r\n            } else {\r\n                name += \"\\\"\" + nameTag + \"\\\", \";\r\n            }\r\n\r\n            int mbno = relation.getMembersCount();\r\n            name += trn(\"{0} member\", \"{0} members\", mbno, mbno) + \")\";\r\n            if(relation.getDataSet().getErrors(relation) != null) {\r\n                name = \"*\"+name;\r\n            }\r\n        }\r\n        name = decorateNameWithId(name, relation);\r\n        return name;\r\n    }","id":80792,"modified_method":"/**\r\n     * Formats a name for a relation\r\n     * \r\n     * @param relation the relation\r\n     * @return the name\r\n     */\r\n    public String format(Relation relation) {\r\n        String name;\r\n        if (relation.incomplete) {\r\n            name = tr(\"incomplete\");\r\n        } else {\r\n            name = relation.get(\"type\");\r\n            if (name == null) {\r\n                name = tr(\"relation\");\r\n            }\r\n\r\n            name += \" (\";\r\n            String nameTag = null;\r\n            Set<String> namingTags = new HashSet<String>(getNamingtagsForRelations());\r\n            for (String n : relation.keySet()) {\r\n                // #3328: \"note \" and \" note\" are name tags too\r\n                if (namingTags.contains(n.trim())) {\r\n                    if (Main.pref.getBoolean(\"osm-primitives.localize-name\", true)) {\r\n                        nameTag = relation.getLocalName();\r\n                    } else {\r\n                        nameTag = relation.getName();\r\n                    }\r\n                    if (nameTag == null) {\r\n                        nameTag = relation.get(n);\r\n                    }\r\n                }\r\n                if (nameTag != null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (nameTag == null) {\r\n                name += Long.toString(relation.getId()) + \", \";\r\n            } else {\r\n                name += \"\\\"\" + nameTag + \"\\\", \";\r\n            }\r\n\r\n            int mbno = relation.getMembersCount();\r\n            name += trn(\"{0} member\", \"{0} members\", mbno, mbno) + \")\";\r\n            DataSet data = relation.getDataSet();\r\n            if(data != null && data.getErrors(relation) != null) {\r\n                name = \"*\"+name;\r\n            }\r\n        }\r\n        name = decorateNameWithId(name, relation);\r\n        return name;\r\n    }","commit_id":"4e737e8b23cec8c9901dd84f36a6b5e46d5dcee4","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n     * Formats a name for a way\r\n     * \r\n     * @param way the way\r\n     * @return the name\r\n     */\r\n    public String format(Way way) {\r\n        String name = \"\";\r\n        if (way.incomplete) {\r\n            name = tr(\"incomplete\");\r\n        } else {\r\n            if (Main.pref.getBoolean(\"osm-primitives.localize-name\", true)) {\r\n                name = way.getLocalName();\r\n            } else {\r\n                name = way.getName();\r\n            }\r\n            if (name == null) {\r\n                name = way.get(\"ref\");\r\n            }\r\n            if (name == null) {\r\n                name =\r\n                    (way.get(\"highway\") != null) ? tr(\"highway\") :\r\n                        (way.get(\"railway\") != null) ? tr(\"railway\") :\r\n                            (way.get(\"waterway\") != null) ? tr(\"waterway\") :\r\n                                (way.get(\"landuse\") != null) ? tr(\"landuse\") : \"\";\r\n            }\r\n\r\n            int nodesNo = way.getNodesCount();\r\n            if (nodesNo > 1 && way.isClosed()) {\r\n                nodesNo--;\r\n            }\r\n            String nodes = trn(\"{0} node\", \"{0} nodes\", nodesNo, nodesNo);\r\n            name += (name.length() > 0) ? \" (\"+nodes+\")\" : nodes;\r\n            if(way.getDataSet().getErrors(way) != null) {\r\n                name = \"*\"+name;\r\n            }\r\n        }\r\n        name = decorateNameWithId(name, way);\r\n        return name;\r\n    }","id":80793,"modified_method":"/**\r\n     * Formats a name for a way\r\n     * \r\n     * @param way the way\r\n     * @return the name\r\n     */\r\n    public String format(Way way) {\r\n        String name = \"\";\r\n        if (way.incomplete) {\r\n            name = tr(\"incomplete\");\r\n        } else {\r\n            if (Main.pref.getBoolean(\"osm-primitives.localize-name\", true)) {\r\n                name = way.getLocalName();\r\n            } else {\r\n                name = way.getName();\r\n            }\r\n            if (name == null) {\r\n                name = way.get(\"ref\");\r\n            }\r\n            if (name == null) {\r\n                name =\r\n                    (way.get(\"highway\") != null) ? tr(\"highway\") :\r\n                        (way.get(\"railway\") != null) ? tr(\"railway\") :\r\n                            (way.get(\"waterway\") != null) ? tr(\"waterway\") :\r\n                                (way.get(\"landuse\") != null) ? tr(\"landuse\") : \"\";\r\n            }\r\n\r\n            int nodesNo = way.getNodesCount();\r\n            if (nodesNo > 1 && way.isClosed()) {\r\n                nodesNo--;\r\n            }\r\n            String nodes = trn(\"{0} node\", \"{0} nodes\", nodesNo, nodesNo);\r\n            name += (name.length() > 0) ? \" (\"+nodes+\")\" : nodes;\r\n            DataSet data = way.getDataSet();\r\n            if (data != null && data.getErrors(way) != null) {\r\n                name = \"*\"+name;\r\n            }\r\n        }\r\n        name = decorateNameWithId(name, way);\r\n        return name;\r\n    }","commit_id":"d1dbe913fd0207083e840da8961d256b4851ce1e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public UMOMessage onMessage(UMOMessage message, UMOTransaction trans,\n                                    boolean synchronous, OutputStream outputStream) throws UMOException {\n\n            UMOMessage resultMessage = null;\n            ResponseOutputStream ros = null;\n            if (outputStream != null) {\n                if (outputStream instanceof ResponseOutputStream) {\n                    ros = (ResponseOutputStream) outputStream;\n                } else {\n                    ros = new ResponseOutputStream(outputStream);\n                }\n            }\n            UMOSession session = new MuleSession(component, trans);\n            UMOEvent muleEvent = new MuleEvent(message, endpoint, session, synchronous, ros);\n            RequestContext.setEvent(muleEvent);\n\n            // Apply Security filter if one is set\n            boolean authorised = false;\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(muleEvent);\n                    authorised=true;\n                } catch (SecurityException e) {\n                    logger.warn(\"Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    handleException(e);\n                    resultMessage = message;\n                }\n            } else {\n                authorised=true;\n            }\n\n            if (authorised) {\n                // the security filter may update the payload so we need to get the\n                // latest event again\n                muleEvent = RequestContext.getEvent();\n\n                // This is a replyTo event for a current request\n                if (UMOEndpoint.ENDPOINT_TYPE_RESPONSE.equals(endpoint.getType())) {\n                    component.getDescriptor().getResponseRouter().route(muleEvent);\n                    return null;\n                } else {\n                    resultMessage = component.getDescriptor().getInboundRouter().route(muleEvent);\n                }\n            }\n            RequestContext.rewriteEvent(resultMessage);\n            return applyResponseTransformer(resultMessage);\n        }","id":80794,"modified_method":"public UMOMessage onMessage(UMOMessage message, UMOTransaction trans,\n                                    boolean synchronous, OutputStream outputStream) throws UMOException {\n\n            UMOMessage resultMessage = null;\n            ResponseOutputStream ros = null;\n            if (outputStream != null) {\n                if (outputStream instanceof ResponseOutputStream) {\n                    ros = (ResponseOutputStream) outputStream;\n                } else {\n                    ros = new ResponseOutputStream(outputStream);\n                }\n            }\n            UMOSession session = new MuleSession(component, trans);\n            UMOEvent muleEvent = new MuleEvent(message, endpoint, session, synchronous, ros);\n            RequestContext.setEvent(muleEvent);\n\n            // Apply Security filter if one is set\n            boolean authorised = false;\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(muleEvent);\n                    authorised=true;\n                } catch (SecurityException e) {\n                    logger.warn(\"Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    handleException(e);\n                    resultMessage = message;\n                }\n            } else {\n                authorised=true;\n            }\n\n            if (authorised) {\n                // the security filter may update the payload so we need to get the\n                // latest event again\n                muleEvent = RequestContext.getEvent();\n\n                // This is a replyTo event for a current request\n                if (UMOEndpoint.ENDPOINT_TYPE_RESPONSE.equals(endpoint.getType())) {\n                    component.getDescriptor().getResponseRouter().route(muleEvent);\n                    return null;\n                } else {\n                    resultMessage = component.getDescriptor().getInboundRouter().route(muleEvent);\n                }\n            }\n            if(resultMessage!=null) RequestContext.rewriteEvent(resultMessage);\n            return applyResponseTransformer(resultMessage);\n        }","commit_id":"17040049eafc69addec4948e38ac68f9f2f125f2","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage onMessage(UMOMessage message, UMOTransaction trans,\n                                    boolean synchronous, OutputStream outputStream) throws UMOException {\n\n            UMOMessage resultMessage = null;\n            ResponseOutputStream ros = null;\n            if (outputStream != null) {\n                if (outputStream instanceof ResponseOutputStream) {\n                    ros = (ResponseOutputStream) outputStream;\n                } else {\n                    ros = new ResponseOutputStream(outputStream);\n                }\n            }\n            UMOSession session = new MuleSession(component, trans);\n            UMOEvent muleEvent = new MuleEvent(message, endpoint, session, synchronous, ros);\n            RequestContext.setEvent(muleEvent);\n\n            // Apply Security filter if one is set\n            boolean authorised = false;\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(muleEvent);\n                    authorised=true;\n                } catch (SecurityException e) {\n                    logger.warn(\"Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    handleException(e);\n                    resultMessage = message;\n                }\n            } else {\n                authorised=true;\n            }\n\n            if (authorised) {\n                // the security filter may update the payload so we need to get the\n                // latest event again\n                muleEvent = RequestContext.getEvent();\n\n                // This is a replyTo event for a current request\n                if (UMOEndpoint.ENDPOINT_TYPE_RESPONSE.equals(endpoint.getType())) {\n                    component.getDescriptor().getResponseRouter().route(muleEvent);\n                    return null;\n                } else {\n                    resultMessage = component.getDescriptor().getInboundRouter().route(muleEvent);\n                }\n            }\n            RequestContext.rewriteEvent(resultMessage);\n            return applyResponseTransformer(resultMessage);\n        }","id":80795,"modified_method":"public UMOMessage onMessage(UMOMessage message, UMOTransaction trans,\n                                    boolean synchronous, OutputStream outputStream) throws UMOException {\n\n            UMOMessage resultMessage = null;\n            ResponseOutputStream ros = null;\n            if (outputStream != null) {\n                if (outputStream instanceof ResponseOutputStream) {\n                    ros = (ResponseOutputStream) outputStream;\n                } else {\n                    ros = new ResponseOutputStream(outputStream);\n                }\n            }\n            UMOSession session = new MuleSession(component, trans);\n            UMOEvent muleEvent = new MuleEvent(message, endpoint, session, synchronous, ros);\n            RequestContext.setEvent(muleEvent);\n\n            // Apply Security filter if one is set\n            boolean authorised = false;\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(muleEvent);\n                    authorised=true;\n                } catch (SecurityException e) {\n                    logger.warn(\"Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    handleException(e);\n                    resultMessage = message;\n                }\n            } else {\n                authorised=true;\n            }\n\n            if (authorised) {\n                // the security filter may update the payload so we need to get the\n                // latest event again\n                muleEvent = RequestContext.getEvent();\n\n                // This is a replyTo event for a current request\n                if (UMOEndpoint.ENDPOINT_TYPE_RESPONSE.equals(endpoint.getType())) {\n                    component.getDescriptor().getResponseRouter().route(muleEvent);\n                    return null;\n                } else {\n                    resultMessage = component.getDescriptor().getInboundRouter().route(muleEvent);\n                }\n            }\n            if(resultMessage!=null) RequestContext.rewriteEvent(resultMessage);\n            return applyResponseTransformer(resultMessage);\n        }","commit_id":"2b45ab87304bd1db07b313b143bbb22d68ddab48","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void accept(final PsiElementVisitor visitor, final boolean needReadAction) {\n    if (myType == VIRTUAL_FILES) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final FileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n      for (final VirtualFile file : myFilesSet) {\n        if (!myIncludeTestSource && index.isInTestSourceContent(file)) continue;\n        if (!processFile(file, visitor, psiManager, needReadAction)) return;\n      }\n    }\n    else if (myScope instanceof GlobalSearchScope) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final FileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n      final ContentIterator contentIterator = new ContentIterator() {\n        public boolean processFile(final VirtualFile fileOrDir) {\n          final boolean isInScope = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n            public Boolean compute() {\n              if (!myIncludeTestSource && projectFileIndex.isInTestSourceContent(fileOrDir)) return false;\n              return ((GlobalSearchScope)myScope).contains(fileOrDir);\n            }\n          }).booleanValue();\n          return !isInScope || AnalysisScope.this.processFile(fileOrDir, visitor, psiManager, needReadAction);\n        }\n      };\n      projectFileIndex.iterateContent(contentIterator);\n      if (mySearchInLibraries) {\n        final VirtualFile[] libraryRoots = LibraryUtil.getLibraryRoots(myProject, false, false);\n        for (VirtualFile libraryRoot : libraryRoots) {\n          FileIndexImplUtil.iterateRecursively(libraryRoot, VirtualFileFilter.ALL, contentIterator);\n        }\n      }\n    }\n    else if (myScope instanceof LocalSearchScope) {\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          final PsiElement[] psiElements = ((LocalSearchScope)myScope).getScope();\n          for (PsiElement element : psiElements) {\n            element.accept(visitor);\n          }\n        }\n      });\n    }\n    else if (myModule != null) {\n      final FileIndex moduleFileIndex = ModuleRootManager.getInstance(myModule).getFileIndex();\n      final PsiManager psiManager = PsiManager.getInstance(myModule.getProject());\n      moduleFileIndex.iterateContent(new ContentIterator() {\n        public boolean processFile(VirtualFile fileOrDir) {\n          return AnalysisScope.this.processFile(fileOrDir, visitor, moduleFileIndex, psiManager, needReadAction);\n        }\n      });\n    }\n    else if (myModules != null) {\n      for (final Module module : myModules) {\n        final PsiManager psiManager = PsiManager.getInstance(module.getProject());\n        final FileIndex moduleFileIndex = ModuleRootManager.getInstance(module).getFileIndex();\n        moduleFileIndex.iterateContent(new ContentIterator() {\n          public boolean processFile(VirtualFile fileOrDir) {\n            return AnalysisScope.this.processFile(fileOrDir, visitor, moduleFileIndex, psiManager, needReadAction);\n          }\n        });\n      }\n    }\n    else if (myElement instanceof PsiDirectory) {\n      accept((PsiDirectory)myElement, visitor, needReadAction);\n    }\n    else if (myElement != null) {\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          myElement.accept(visitor);\n        }\n      });\n    }\n    else if (myProject != null) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final FileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n      projectFileIndex.iterateContent(new ContentIterator() {\n        public boolean processFile(final VirtualFile fileOrDir) {\n          return AnalysisScope.this.processFile(fileOrDir, visitor, projectFileIndex, psiManager, needReadAction);\n        }\n      });\n    }\n  }","id":80796,"modified_method":"protected void accept(@NotNull final PsiElementVisitor visitor, final boolean needReadAction) {\n    if (myType == VIRTUAL_FILES) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final FileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n      for (final VirtualFile file : myFilesSet) {\n        if (!myIncludeTestSource && index.isInTestSourceContent(file)) continue;\n        if (!processFile(file, visitor, psiManager, needReadAction)) return;\n      }\n    }\n    else if (myScope instanceof GlobalSearchScope) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final FileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n      final ContentIterator contentIterator = new ContentIterator() {\n        @Override\n        public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n          final boolean isInScope = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n            @Override\n            public Boolean compute() {\n              if (!myIncludeTestSource && projectFileIndex.isInTestSourceContent(fileOrDir)) return false;\n              return ((GlobalSearchScope)myScope).contains(fileOrDir);\n            }\n          }).booleanValue();\n          return !isInScope || AnalysisScope.this.processFile(fileOrDir, visitor, psiManager, needReadAction);\n        }\n      };\n      projectFileIndex.iterateContent(contentIterator);\n      if (mySearchInLibraries) {\n        final VirtualFile[] libraryRoots = LibraryUtil.getLibraryRoots(myProject, false, false);\n        for (VirtualFile libraryRoot : libraryRoots) {\n          FileIndexImplUtil.iterateRecursively(libraryRoot, VirtualFileFilter.ALL, contentIterator);\n        }\n      }\n    }\n    else if (myScope instanceof LocalSearchScope) {\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          final PsiElement[] psiElements = ((LocalSearchScope)myScope).getScope();\n          for (PsiElement element : psiElements) {\n            element.accept(visitor);\n          }\n        }\n      });\n    }\n    else if (myModule != null) {\n      final FileIndex moduleFileIndex = ModuleRootManager.getInstance(myModule).getFileIndex();\n      final PsiManager psiManager = PsiManager.getInstance(myModule.getProject());\n      moduleFileIndex.iterateContent(new ContentIterator() {\n        @Override\n        public boolean processFile(@NotNull VirtualFile fileOrDir) {\n          return AnalysisScope.this.processFile(fileOrDir, visitor, moduleFileIndex, psiManager, needReadAction);\n        }\n      });\n    }\n    else if (myModules != null) {\n      for (final Module module : myModules) {\n        final PsiManager psiManager = PsiManager.getInstance(module.getProject());\n        final FileIndex moduleFileIndex = ModuleRootManager.getInstance(module).getFileIndex();\n        moduleFileIndex.iterateContent(new ContentIterator() {\n          @Override\n          public boolean processFile(@NotNull VirtualFile fileOrDir) {\n            return AnalysisScope.this.processFile(fileOrDir, visitor, moduleFileIndex, psiManager, needReadAction);\n          }\n        });\n      }\n    }\n    else if (myElement instanceof PsiDirectory) {\n      accept((PsiDirectory)myElement, visitor, needReadAction);\n    }\n    else if (myElement != null) {\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          myElement.accept(visitor);\n        }\n      });\n    }\n    else if (myProject != null) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final FileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n      projectFileIndex.iterateContent(new ContentIterator() {\n        @Override\n        public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n          return AnalysisScope.this.processFile(fileOrDir, visitor, projectFileIndex, psiManager, needReadAction);\n        }\n      });\n    }\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String pathToName(String path) {\n    String name = path;\n    if (path != null) {\n      File file = new File(path);\n      name = FileUtil.getNameWithoutExtension(file);\n    }\n    return name;\n  }","id":80797,"modified_method":"@NotNull\n  private static String pathToName(@NotNull String path) {\n    File file = new File(path);\n    return FileUtil.getNameWithoutExtension(file);\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getShortenName(){\n    switch (myType) {\n      case CUSTOM:\n        return myScope.getDisplayName();\n\n      case MODULE:\n        return AnalysisScopeBundle.message(\"scope.option.module\", myModule.getName());\n\n      case MODULES:\n        String modules = StringUtil.join(myModules, new Function<Module, String>() {\n          public String fun(final Module module) {\n            return module.getName();\n          }\n        }, \", \");\n        return AnalysisScopeBundle.message(\"scope.module.list\", modules, Integer.valueOf(myModules.size()));\n\n      case PROJECT:\n        return AnalysisScopeBundle.message(\"scope.project\", myProject.getName());\n\n      case FILE:\n        final String relativePath = getRelativePath();\n        return relativePath != null ? AnalysisScopeBundle.message(\"scope.file\", relativePath) : \"Current File\";\n\n      case DIRECTORY:\n        final String relativeDirPath = getRelativePath();\n        return relativeDirPath != null ? AnalysisScopeBundle.message(\"scope.directory\", relativeDirPath) : \"Current Directory\";\n\n\n      case VIRTUAL_FILES:\n        return AnalysisScopeBundle.message(\"scope.selected.files\");\n    }\n\n    return \"\";\n  }","id":80798,"modified_method":"public String getShortenName(){\n    switch (myType) {\n      case CUSTOM:\n        return myScope.getDisplayName();\n\n      case MODULE:\n        return AnalysisScopeBundle.message(\"scope.option.module\", myModule.getName());\n\n      case MODULES:\n        String modules = StringUtil.join(myModules, new Function<Module, String>() {\n          @Override\n          @NotNull\n          public String fun(@NotNull final Module module) {\n            return module.getName();\n          }\n        }, \", \");\n        return AnalysisScopeBundle.message(\"scope.module.list\", modules, Integer.valueOf(myModules.size()));\n\n      case PROJECT:\n        return AnalysisScopeBundle.message(\"scope.project\", myProject.getName());\n\n      case FILE:\n        final String relativePath = getRelativePath();\n        return relativePath != null ? AnalysisScopeBundle.message(\"scope.file\", relativePath) : \"Current File\";\n\n      case DIRECTORY:\n        final String relativeDirPath = getRelativePath();\n        return relativeDirPath != null ? AnalysisScopeBundle.message(\"scope.directory\", relativeDirPath) : \"Current Directory\";\n\n\n      case VIRTUAL_FILES:\n        return AnalysisScopeBundle.message(\"scope.selected.files\");\n    }\n\n    return \"\";\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiFile getPsiFileInReadAction(final PsiManager psiManager, final VirtualFile file) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n      @Nullable\n      public PsiFile compute() {\n        final PsiFile psiFile = psiManager.findFile(file);\n        return psiFile != null && psiFile.isValid() ? psiFile : null;\n      }\n    });\n  }","id":80799,"modified_method":"private static PsiFile getPsiFileInReadAction(@NotNull final PsiManager psiManager, @NotNull final VirtualFile file) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n      @Override\n      @Nullable\n      public PsiFile compute() {\n        final PsiFile psiFile = psiManager.findFile(file);\n        return psiFile != null && psiFile.isValid() ? psiFile : null;\n      }\n    });\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void processDirectories(final PsiDirectory[] psiDirectories,\n                                         final Set<String> result,\n                                         final ProjectProfileManager profileManager) {\n    for (final PsiDirectory directory : psiDirectories) {\n      final PsiFile[] psiFiles = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n        public PsiFile[] compute() {\n          return directory.getFiles();\n        }\n      });\n      for (PsiFile file : psiFiles) {\n        result.add(profileManager.getProfileName());\n      }\n      processDirectories(ApplicationManager.getApplication().runReadAction(new Computable<PsiDirectory[]>() {\n        public PsiDirectory[] compute() {\n          return directory.getSubdirectories();\n        }\n      }), result, profileManager);\n    }\n  }","id":80800,"modified_method":"protected static void processDirectories(@NotNull final PsiDirectory[] psiDirectories,\n                                           @NotNull final Set<String> result,\n                                           @NotNull final ProjectProfileManager profileManager) {\n    for (final PsiDirectory directory : psiDirectories) {\n      final PsiFile[] psiFiles = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n        @Override\n        @NotNull\n        public PsiFile[] compute() {\n          return directory.getFiles();\n        }\n      });\n      for (PsiFile file : psiFiles) {\n        result.add(profileManager.getProfileName());\n      }\n      processDirectories(ApplicationManager.getApplication().runReadAction(new Computable<PsiDirectory[]>() {\n        @Override\n        @NotNull\n        public PsiDirectory[] compute() {\n          return directory.getSubdirectories();\n        }\n      }), result, profileManager);\n    }\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiElementVisitor createFileSearcher() {\n    final FileIndex fileIndex;\n    if (myModule != null) {\n      fileIndex = ModuleRootManager.getInstance(myModule).getFileIndex();\n    }\n    else if (myModules != null && !myModules.isEmpty()) {\n      fileIndex = ProjectRootManager.getInstance(myModules.get(0).getProject()).getFileIndex();\n    }\n    else if (myElement != null) {\n      fileIndex = ProjectRootManager.getInstance(myElement.getProject()).getFileIndex();\n    }\n    else if (myProject != null) {\n      fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    }\n    else {\n      //can't be\n      fileIndex = null;\n    }\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n\n    return new PsiRecursiveElementVisitor() {\n      @Override\n      public void visitFile(PsiFile file) {\n        if (/*file instanceof PsiJavaFile && */mySearchInLibraries || !(file instanceof PsiCompiledElement)) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile == null) return;\n          if (!myIncludeTestSource) {\n            if (fileIndex == null || fileIndex.isInTestSourceContent(virtualFile)) {\n              return;\n            }\n          }\n          if (!shouldHighlightFile(file)) return;\n          myFilesSet.add(virtualFile);\n          if (indicator != null) {\n            indicator.setText(AnalysisScopeBundle.message(\"scanning.scope.progress.title\"));\n            indicator.setText2(ProjectUtil.calcRelativeToProjectPath(virtualFile, file.getProject()));\n          }\n        }\n      }\n    };\n  }","id":80801,"modified_method":"@NotNull\n  protected PsiElementVisitor createFileSearcher() {\n    final FileIndex fileIndex;\n    if (myModule != null) {\n      fileIndex = ModuleRootManager.getInstance(myModule).getFileIndex();\n    }\n    else if (myModules != null && !myModules.isEmpty()) {\n      fileIndex = ProjectRootManager.getInstance(myModules.get(0).getProject()).getFileIndex();\n    }\n    else if (myElement != null) {\n      fileIndex = ProjectRootManager.getInstance(myElement.getProject()).getFileIndex();\n    }\n    else if (myProject != null) {\n      fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    }\n    else {\n      //can't be\n      fileIndex = null;\n    }\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n\n    return new PsiRecursiveElementVisitor() {\n      @Override\n      public void visitFile(@NotNull PsiFile file) {\n        if (/*file instanceof PsiJavaFile && */mySearchInLibraries || !(file instanceof PsiCompiledElement)) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile == null) return;\n          if (!myIncludeTestSource) {\n            if (fileIndex == null || fileIndex.isInTestSourceContent(virtualFile)) {\n              return;\n            }\n          }\n          if (!shouldHighlightFile(file)) return;\n          myFilesSet.add(virtualFile);\n          if (indicator != null) {\n            indicator.setText(AnalysisScopeBundle.message(\"scanning.scope.progress.title\"));\n            indicator.setText2(ProjectUtil.calcRelativeToProjectPath(virtualFile, file.getProject()));\n          }\n        }\n      }\n    };\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getDisplayName() {\n    switch (myType) {\n      case CUSTOM:\n        return myScope.getDisplayName();\n\n      case MODULE:\n        return AnalysisScopeBundle.message(\"scope.option.module\", pathToName(myModule.getModuleFilePath()));\n\n      case MODULES:\n        String modules = StringUtil.join(myModules, new Function<Module, String>() {\n          public String fun(final Module module) {\n            return pathToName(module.getModuleFilePath());\n          }\n        }, \", \");\n\n        return AnalysisScopeBundle.message(\"scope.module.list\", modules, Integer.valueOf(myModules.size()));\n\n      case PROJECT:\n        return AnalysisScopeBundle.message(\"scope.project\", myProject.getName());\n\n      case FILE:\n        return AnalysisScopeBundle.message(\"scope.file\", getPresentableUrl((PsiFileSystemItem)myElement));\n\n      case DIRECTORY:\n        return AnalysisScopeBundle.message(\"scope.directory\", getPresentableUrl((PsiFileSystemItem)myElement));\n\n      case VIRTUAL_FILES:\n        return AnalysisScopeBundle.message(\"scope.virtual.files\");\n    }\n\n    return \"\";\n  }","id":80802,"modified_method":"public String getDisplayName() {\n    switch (myType) {\n      case CUSTOM:\n        return myScope.getDisplayName();\n\n      case MODULE:\n        return AnalysisScopeBundle.message(\"scope.option.module\", pathToName(myModule.getModuleFilePath()));\n\n      case MODULES:\n        String modules = StringUtil.join(myModules, new Function<Module, String>() {\n          @Override\n          public String fun(@NotNull final Module module) {\n            return pathToName(module.getModuleFilePath());\n          }\n        }, \", \");\n\n        return AnalysisScopeBundle.message(\"scope.module.list\", modules, Integer.valueOf(myModules.size()));\n\n      case PROJECT:\n        return AnalysisScopeBundle.message(\"scope.project\", myProject.getName());\n\n      case FILE:\n        return AnalysisScopeBundle.message(\"scope.file\", getPresentableUrl((PsiFileSystemItem)myElement));\n\n      case DIRECTORY:\n        return AnalysisScopeBundle.message(\"scope.directory\", getPresentableUrl((PsiFileSystemItem)myElement));\n\n      case VIRTUAL_FILES:\n        return AnalysisScopeBundle.message(\"scope.virtual.files\");\n    }\n\n    return \"\";\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processFile(final VirtualFile fileOrDir, final PsiElementVisitor visitor, final PsiManager psiManager,\n                                     final boolean needReadAction) {\n    if (!fileOrDir.isValid()) return false;\n    final PsiFile file = getPsiFileInReadAction(psiManager, fileOrDir);\n    if (file == null){\n      //skip .class files under src directory\n      return true;\n    }\n    if (!shouldHighlightFile(file)) return true;\n    if (needReadAction) {\n      PsiDocumentManager.getInstance(psiManager.getProject()).commitAndRunReadAction(new Runnable(){\n        public void run() {\n          doProcessFile(visitor, psiManager, file);\n        }\n      });\n    }\n    else {\n      doProcessFile(visitor, psiManager, file);\n    }\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    return indicator == null || !indicator.isCanceled();\n  }","id":80803,"modified_method":"private boolean processFile(@NotNull final VirtualFile fileOrDir,\n                              @NotNull final PsiElementVisitor visitor,\n                              @NotNull final PsiManager psiManager,\n                              final boolean needReadAction) {\n    if (!fileOrDir.isValid()) return false;\n    final PsiFile file = getPsiFileInReadAction(psiManager, fileOrDir);\n    if (file == null){\n      //skip .class files under src directory\n      return true;\n    }\n    if (!shouldHighlightFile(file)) return true;\n    if (needReadAction) {\n      PsiDocumentManager.getInstance(psiManager.getProject()).commitAndRunReadAction(new Runnable(){\n        @Override\n        public void run() {\n          doProcessFile(visitor, psiManager, file);\n        }\n      });\n    }\n    else {\n      doProcessFile(visitor, psiManager, file);\n    }\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    return indicator == null || !indicator.isCanceled();\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void accept(@NotNull final PsiDirectory dir, @NotNull final PsiElementVisitor visitor, final boolean needReadAction) {\n    final Project project = dir.getProject();\n    final PsiManager psiManager = PsiManager.getInstance(project);\n    final ProjectFileIndex index = ProjectRootManager.getInstance(project).getFileIndex();\n    FileIndexImplUtil.iterateRecursively(dir.getVirtualFile(), VirtualFileFilter.ALL, new ContentIterator() {\n      @SuppressWarnings({\"SimplifiableIfStatement\"})\n      public boolean processFile(final VirtualFile fileOrDir) {\n        if (!myIncludeTestSource && index.isInTestSourceContent(fileOrDir)) return true;\n        if (!fileOrDir.isDirectory()) {\n          return AnalysisScope.this.processFile(fileOrDir, visitor, psiManager, needReadAction);\n        }\n        return true;\n      }\n    });\n  }","id":80804,"modified_method":"protected void accept(@NotNull final PsiDirectory dir, @NotNull final PsiElementVisitor visitor, final boolean needReadAction) {\n    final Project project = dir.getProject();\n    final PsiManager psiManager = PsiManager.getInstance(project);\n    final ProjectFileIndex index = ProjectRootManager.getInstance(project).getFileIndex();\n    FileIndexImplUtil.iterateRecursively(dir.getVirtualFile(), VirtualFileFilter.ALL, new ContentIterator() {\n      @Override\n      @SuppressWarnings({\"SimplifiableIfStatement\"})\n      public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n        if (!myIncludeTestSource && index.isInTestSourceContent(fileOrDir)) return true;\n        if (!fileOrDir.isDirectory()) {\n          return AnalysisScope.this.processFile(fileOrDir, visitor, psiManager, needReadAction);\n        }\n        return true;\n      }\n    });\n  }","commit_id":"8f9e61fe45f4d58916e2dd431bee831bf5de63e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getDefaultBaseName(@NotNull final VirtualFile file) {\n    final String name = file.getName();\n\n    if (!StringUtil.containsChar(name, '_')) {\n      return FileUtil.getNameWithoutExtension(name);\n    }\n\n    final Matcher matcher = LOCALE_PATTERN.matcher(name);\n    final String baseNameWithExtension;\n\n    int matchIndex = 0;\n    while (matcher.find(matchIndex)) {\n      final MatchResult matchResult = matcher.toMatchResult();\n      final String[] splitted = matchResult.group(1).split(\"_\");\n      if (splitted.length > 1) {\n        final String langCode = splitted[1];\n        if (!LOCALES_LANGUAGE_CODES.getValue().contains(langCode)) {\n          matchIndex = matchResult.start(1) + 1;\n          continue;\n        }\n        baseNameWithExtension = name.substring(0, matchResult.start(1)) + name.substring(matchResult.end(1));\n        return FileUtil.getNameWithoutExtension(baseNameWithExtension);\n      }\n    }\n    baseNameWithExtension = name;\n    return FileUtil.getNameWithoutExtension(baseNameWithExtension);\n  }","id":80805,"modified_method":"@NotNull\n  public static String getDefaultBaseName(@NotNull final VirtualFile file) {\n    final String lastBaseNameCalculationFileName = file.getUserData(LAST_CALCULATION_FILE_NAME);\n    final String name = file.getName();\n    if (name.equals(lastBaseNameCalculationFileName)) {\n      final String baseName = file.getUserData(BASE_NAME);\n      LOG.assertTrue(baseName != null);\n      return baseName;\n    }\n\n    final String calculatedBaseName;\n    if (!StringUtil.containsChar(name, '_')) {\n      calculatedBaseName = FileUtil.getNameWithoutExtension(name);\n    } else {\n      final Matcher matcher = LOCALE_PATTERN.matcher(name);\n      final String baseNameWithExtension;\n\n      int matchIndex = 0;\n      while (matcher.find(matchIndex)) {\n        final MatchResult matchResult = matcher.toMatchResult();\n        final String[] split = matchResult.group(1).split(\"_\");\n        if (split.length > 1) {\n          final String langCode = split[1];\n          if (!LOCALES_LANGUAGE_CODES.getValue().contains(langCode)) {\n            matchIndex = matchResult.start(1) + 1;\n            continue;\n          }\n          baseNameWithExtension = name.substring(0, matchResult.start(1)) + name.substring(matchResult.end(1));\n          return FileUtil.getNameWithoutExtension(baseNameWithExtension);\n        }\n      }\n      baseNameWithExtension = name;\n      calculatedBaseName = FileUtil.getNameWithoutExtension(baseNameWithExtension);\n    }\n\n    file.putUserData(LAST_CALCULATION_FILE_NAME, name);\n    file.putUserData(BASE_NAME, calculatedBaseName);\n    return calculatedBaseName;\n  }","commit_id":"54fbcf396e9b3675e6a0379290a7ec5541b63bec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getDefaultBaseName(@NotNull final VirtualFile file) {\n    final String lastBaseNameCalculationFileName = file.getUserData(LAST_CALCULATION_FILE_NAME);\n    final String name = file.getName();\n    if (name.equals(lastBaseNameCalculationFileName)) {\n      final String baseName = file.getUserData(BASE_NAME);\n      LOG.assertTrue(baseName != null);\n      return baseName;\n    }\n\n    final String calculatedBaseName;\n    if (!StringUtil.containsChar(name, '_')) {\n      calculatedBaseName = FileUtil.getNameWithoutExtension(name);\n    } else {\n      final Matcher matcher = LOCALE_PATTERN.matcher(name);\n      final String baseNameWithExtension;\n\n      int matchIndex = 0;\n      while (matcher.find(matchIndex)) {\n        final MatchResult matchResult = matcher.toMatchResult();\n        final String[] split = matchResult.group(1).split(\"_\");\n        if (split.length > 1) {\n          final String langCode = split[1];\n          if (!LOCALES_LANGUAGE_CODES.getValue().contains(langCode)) {\n            matchIndex = matchResult.start(1) + 1;\n            continue;\n          }\n          baseNameWithExtension = name.substring(0, matchResult.start(1)) + name.substring(matchResult.end(1));\n          return FileUtil.getNameWithoutExtension(baseNameWithExtension);\n        }\n      }\n      baseNameWithExtension = name;\n      calculatedBaseName = FileUtil.getNameWithoutExtension(baseNameWithExtension);\n    }\n\n    file.putUserData(LAST_CALCULATION_FILE_NAME, name);\n    file.putUserData(BASE_NAME, calculatedBaseName);\n    return calculatedBaseName;\n  }","id":80806,"modified_method":"@NotNull\n  public static String getDefaultBaseName(@NotNull final VirtualFile file) {\n    final String name = file.getName();\n\n    if (!StringUtil.containsChar(name, '_')) {\n      return FileUtil.getNameWithoutExtension(name);\n    }\n\n    final Matcher matcher = LOCALE_PATTERN.matcher(name);\n    final String baseNameWithExtension;\n\n    int matchIndex = 0;\n    while (matcher.find(matchIndex)) {\n      final MatchResult matchResult = matcher.toMatchResult();\n      final String[] splitted = matchResult.group(1).split(\"_\");\n      if (splitted.length > 1) {\n        final String langCode = splitted[1];\n        if (!LOCALES_LANGUAGE_CODES.getValue().contains(langCode)) {\n          matchIndex = matchResult.start(1) + 1;\n          continue;\n        }\n        baseNameWithExtension = name.substring(0, matchResult.start(1)) + name.substring(matchResult.end(1));\n        return FileUtil.getNameWithoutExtension(baseNameWithExtension);\n      }\n    }\n    baseNameWithExtension = name;\n    return FileUtil.getNameWithoutExtension(baseNameWithExtension);\n  }","commit_id":"81835d42540d29f2492030e73f28b0bcfc0fac0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StreamCache getStreamCache() throws IOException {\n        flush();\n        if (inMemory) {\n            if (currentStream instanceof ByteArrayOutputStream) {\n                return new InputStreamCache(((ByteArrayOutputStream) currentStream).toByteArray());\n            } else {\n                return null;\n            }\n        } else {\n            try {\n                return new FileInputStreamCache(tempFile, this);\n            } catch (FileNotFoundException e) {\n                throw IOHelper.createIOException(\"Cached file was already deleted\", e);\n            }\n        }\n    }","id":80807,"modified_method":"public StreamCache getStreamCache() throws IOException {\n        if (inMemory) {\n            if (currentStream instanceof ByteArrayOutputStream) {\n                return new InputStreamCache(((ByteArrayOutputStream) currentStream).toByteArray());\n            } else {\n                throw new IllegalStateException(\"CurrentStream should be an instance of ByteArrayOutputStream but is: \" + currentStream.getClass().getName());\n            }\n        } else {\n            try {\n                return new FileInputStreamCache(tempFile, this);\n            } catch (FileNotFoundException e) {\n                throw IOHelper.createIOException(\"Cached file \" + tempFile + \" not found\", e);\n            }\n        }\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public String toString() {\n        StringBuilder builder = new StringBuilder().append(\"[\")\n            .append(CachedOutputStream.class.getName())\n            .append(\" Content: \");\n        try {\n            writeCacheTo(builder);\n        } catch (IOException e) {\n            //ignore\n        }\n        return builder.append(\"]\").toString();\n    }","id":80808,"modified_method":"public String toString() {\n        return \"CachedOutputStream[size: \" + totalLength + \"]\";\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void flush() throws IOException {\n        currentStream.flush();       \n        doFlush();\n    }","id":80809,"modified_method":"public void flush() throws IOException {\n        currentStream.flush();       \n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void write(byte[] b) throws IOException {\n        if (!outputLocked) {\n            onWrite();\n            this.totalLength += b.length;\n            if (inMemory && totalLength > threshold && currentStream instanceof ByteArrayOutputStream) {\n                createFileOutputStream();\n            }\n            currentStream.write(b);\n        }\n    }","id":80810,"modified_method":"public void write(byte[] b) throws IOException {\n        this.totalLength += b.length;\n        if (inMemory && totalLength > threshold && currentStream instanceof ByteArrayOutputStream) {\n            pageToFileStream();\n        }\n        currentStream.write(b);\n        flush();\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void close() throws IOException {\n        currentStream.flush();        \n        doClose();\n        currentStream.close();\n        maybeDeleteTempFile(currentStream);\n        postClose();\n    }","id":80811,"modified_method":"public void close() throws IOException {\n        currentStream.close();\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void write(byte[] b, int off, int len) throws IOException {\n        if (!outputLocked) {\n            onWrite();\n            this.totalLength += len;\n            if (inMemory && totalLength > threshold && currentStream instanceof ByteArrayOutputStream) {\n                createFileOutputStream();\n            }\n            currentStream.write(b, off, len);\n        }\n    }","id":80812,"modified_method":"public void write(byte[] b, int off, int len) throws IOException {\n        this.totalLength += len;\n        if (inMemory && totalLength > threshold && currentStream instanceof ByteArrayOutputStream) {\n            pageToFileStream();\n        }\n        currentStream.write(b, off, len);\n        flush();\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public CachedOutputStream() {\n        currentStream = new ByteArrayOutputStream(2048);\n        inMemory = true;\n    }","id":80813,"modified_method":"public CachedOutputStream(Exchange exchange) {\n        String hold = exchange.getContext().getProperties().get(THRESHOLD);\n        String dir = exchange.getContext().getProperties().get(TEMP_DIR);\n        if (hold != null) {\n            this.threshold = exchange.getContext().getTypeConverter().convertTo(Long.class, hold);\n        }\n        if (dir != null) {\n            this.outputDir = exchange.getContext().getTypeConverter().convertTo(File.class, dir);\n        }\n\n        // add on completion so we can cleanup after the exchange is done such as deleting temporary files\n        exchange.addOnCompletion(new SynchronizationAdapter() {\n            @Override\n            public void onDone(Exchange exchange) {\n                try {\n                    // cleanup temporary file\n                    if (tempFile != null) {\n                        boolean deleted = tempFile.delete();\n                        if (!deleted) {\n                            LOG.warn(\"Cannot delete temporary cache file: \" + tempFile);\n                        } else if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Deleted temporary cache file: \" + tempFile);\n                        }\n                        tempFile = null;\n                    }\n                } catch (Exception e) {\n                    LOG.warn(\"Error deleting temporary cache file: \" + tempFile, e);\n                }\n            }\n\n            @Override\n            public String toString() {\n                return \"OnCompletion[CachedOutputStream]\";\n            }\n        });\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public InputStream getInputStream() throws IOException {\n        flush();\n        if (inMemory) {\n            if (currentStream instanceof ByteArrayOutputStream) {\n                return new ByteArrayInputStream(((ByteArrayOutputStream) currentStream).toByteArray());\n            } else {\n                return null;\n            }\n        } else {\n            try {\n                FileInputStream fileInputStream = new FileInputStream(tempFile) {\n                    public void close() throws IOException {\n                        super.close();\n                        maybeDeleteTempFile(this);\n                    }\n                };\n                streamList.add(fileInputStream);\n                return fileInputStream;\n            } catch (FileNotFoundException e) {\n                throw IOHelper.createIOException(\"Cached file was already deleted\", e);\n            }\n        }\n    }","id":80814,"modified_method":"public InputStream getInputStream() throws IOException {\n        if (inMemory) {\n            if (currentStream instanceof ByteArrayOutputStream) {\n                return new ByteArrayInputStream(((ByteArrayOutputStream) currentStream).toByteArray());\n            } else {\n                throw new IllegalStateException(\"CurrentStream should be an instance of ByteArrayOutputStream but is: \" + currentStream.getClass().getName());\n            }\n        } else {\n            try {\n                return new FileInputStreamCache(tempFile, this);\n            } catch (FileNotFoundException e) {\n                throw IOHelper.createIOException(\"Cached file \" + tempFile + \" not found\", e);\n            }\n        }\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void write(int b) throws IOException {\n        if (!outputLocked) {\n            onWrite();\n            this.totalLength++;\n            if (inMemory && totalLength > threshold && currentStream instanceof ByteArrayOutputStream) {\n                createFileOutputStream();\n            }\n            currentStream.write(b);\n        }\n    }","id":80815,"modified_method":"public void write(int b) throws IOException {\n        this.totalLength++;\n        if (inMemory && totalLength > threshold && currentStream instanceof ByteArrayOutputStream) {\n            pageToFileStream();\n        }\n        currentStream.write(b);\n        flush();\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void testCacheStreamToFileAndNotCloseStream() throws IOException {       \n        CachedOutputStream cos = new CachedOutputStream(16);\n        cos.setOutputDir(file);\n        cos.write(TEST_STRING.getBytes(\"UTF-8\"));        \n        String[] files = file.list();\n        assertEquals(\"we should have a temp file\", files.length, 1);\n        assertTrue(\"The file name should start with cos\" , files[0].startsWith(\"cos\"));\n        \n        StreamCache cache = cos.getStreamCache();\n        assertTrue(\"Should get the FileInputStreamCache\", cache instanceof FileInputStreamCache);\n        String temp = toString((InputStream)cache);\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n        cache.reset();\n        temp = toString((InputStream)cache);\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n        \n        ((InputStream)cache).close();\n        files = file.list();\n        assertEquals(\"we should have no temp file\", files.length, 0);       \n    }","id":80816,"modified_method":"public void testCacheStreamToFileAndNotCloseStream() throws IOException {\n        CachedOutputStream cos = new CachedOutputStream(exchange);\n        cos.write(TEST_STRING.getBytes(\"UTF-8\"));\n\n        File file = new File(\"./target/cachedir\");\n        String[] files = file.list();\n        assertEquals(\"we should have a temp file\", files.length, 1);\n        assertTrue(\"The file name should start with cos\" , files[0].startsWith(\"cos\"));\n        \n        StreamCache cache = cos.getStreamCache();\n        assertTrue(\"Should get the FileInputStreamCache\", cache instanceof FileInputStreamCache);\n        String temp = toString((InputStream)cache);\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n        cache.reset();\n        temp = toString((InputStream)cache);\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n        \n        exchange.getUnitOfWork().done(exchange);\n\n        ((InputStream)cache).close();\n        files = file.list();\n        assertEquals(\"we should have no temp file\", files.length, 0);       \n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void testCacheStreamToFileAndCloseStream() throws IOException {       \n        CachedOutputStream cos = new CachedOutputStream(16);\n        cos.setOutputDir(file);\n        cos.write(TEST_STRING.getBytes(\"UTF-8\"));        \n        String[] files = file.list();\n        assertEquals(\"we should have a temp file\", files.length, 1);\n        assertTrue(\"The file name should start with cos\" , files[0].startsWith(\"cos\"));\n        \n        StreamCache cache = cos.getStreamCache();\n        assertTrue(\"Should get the FileInputStreamCache\", cache instanceof FileInputStreamCache);\n        String temp = toString((InputStream)cache);\n        ((InputStream)cache).close();\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n        try {\n            cache.reset();\n            // The stream is closed, so the temp file is gone.\n            fail(\"we expect the exception here\");\n        } catch (Exception exception) {\n            // do nothing\n        }\n        files = file.list();\n        assertEquals(\"we should have no temp file\", files.length, 0);\n    }","id":80817,"modified_method":"public void testCacheStreamToFileAndCloseStream() throws IOException {       \n        CachedOutputStream cos = new CachedOutputStream(exchange);\n        cos.write(TEST_STRING.getBytes(\"UTF-8\"));\n\n        File file = new File(\"./target/cachedir\");\n        String[] files = file.list();\n        assertEquals(\"we should have a temp file\", files.length, 1);\n        assertTrue(\"The file name should start with cos\" , files[0].startsWith(\"cos\"));\n        \n        StreamCache cache = cos.getStreamCache();\n        assertTrue(\"Should get the FileInputStreamCache\", cache instanceof FileInputStreamCache);\n        String temp = toString((InputStream)cache);\n\n        ((InputStream)cache).close();\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n\n        exchange.getUnitOfWork().done(exchange);\n\n        try {\n            cache.reset();\n            // The stream is closed, so the temp file is gone.\n            fail(\"we expect the exception here\");\n        } catch (Exception exception) {\n            // do nothing\n        }\n\n\n        files = file.list();\n        assertEquals(\"we should have no temp file\", files.length, 0);\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"protected void setUp() throws Exception {        \n        if (file.exists()) {\n            deleteDirectory(file);\n        }\n        file.mkdirs();\n    }","id":80818,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        \n        context.getProperties().put(CachedOutputStream.TEMP_DIR, \"./target/cachedir\");\n        context.getProperties().put(CachedOutputStream.THRESHOLD, \"16\");\n        deleteDirectory(\"./target/cachedir\");\n        createDirectory(\"./target/cachedir\");\n\n        exchange = new DefaultExchange(context);\n        UnitOfWork uow = new DefaultUnitOfWork(exchange);\n        exchange.setUnitOfWork(uow);\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void testCacheStreamToMemory() throws IOException {\n        CachedOutputStream cos = new CachedOutputStream();\n        cos.setOutputDir(file);\n        cos.write(TEST_STRING.getBytes(\"UTF-8\"));        \n        String[] files = file.list();\n        assertEquals(\"we should have no temp file\", files.length, 0);\n        StreamCache cache = cos.getStreamCache();\n        assertTrue(\"Should get the InputStreamCache\", cache instanceof InputStreamCache);\n        String temp = IOConverter.toString((InputStream)cache);\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n    }","id":80819,"modified_method":"public void testCacheStreamToMemory() throws IOException {\n        context.getProperties().put(CachedOutputStream.THRESHOLD, \"1024\");\n\n        CachedOutputStream cos = new CachedOutputStream(exchange);\n        cos.write(TEST_STRING.getBytes(\"UTF-8\"));\n\n        File file = new File(\"./target/cachedir\");\n        String[] files = file.list();\n\n        assertEquals(\"we should have no temp file\", files.length, 0);\n        StreamCache cache = cos.getStreamCache();\n        assertTrue(\"Should get the InputStreamCache\", cache instanceof InputStreamCache);\n        String temp = IOConverter.toString((InputStream)cache);\n        assertEquals(\"Cached a wrong file\", temp, TEST_STRING);\n\n        exchange.getUnitOfWork().done(exchange);\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public static File createTempFile(String prefix, String suffix) throws IOException {\n        return createTempFile(prefix, suffix, null, false);\n    }","id":80820,"modified_method":"public static File createTempFile(String prefix, String suffix) throws IOException {\n        return createTempFile(prefix, suffix, null);\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"private static synchronized File getDefaultTempDir() {\n        if (defaultTempDir != null\n            && defaultTempDir.exists()) {\n            return defaultTempDir;\n        }\n        \n        String s = null;\n        try {\n            s = System.getProperty(FileUtil.class.getName() + \".TempDirectory\");\n        } catch (SecurityException e) {\n            //Ignorable, we'll use the default\n        }\n        if (s == null) {\n            int x = (int)(Math.random() * 1000000);\n            s = System.getProperty(\"java.io.tmpdir\");\n            File checkExists = new File(s);\n            if (!checkExists.exists()) {\n                throw new RuntimeException(\"The directory \" \n                                       + checkExists.getAbsolutePath() \n                                       + \" does not exist, please set java.io.tempdir\"\n                                       + \" to an existing directory\");\n            }\n            File f = new File(s, \"camel-tmp-\" + x);\n            while (!f.mkdir()) {\n                x = (int)(Math.random() * 1000000);\n                f = new File(s, \"camel-tmp-\" + x);\n            }\n            defaultTempDir = f;\n            Thread hook = new Thread() {\n                @Override\n                public void run() {\n                    removeDir(defaultTempDir);\n                }\n            };\n            Runtime.getRuntime().addShutdownHook(hook);            \n        } else {\n            //assume someone outside of us will manage the directory\n            File f = new File(s);\n            f.mkdirs();\n            defaultTempDir = f;\n        }\n        return defaultTempDir;\n    }","id":80821,"modified_method":"private static synchronized File getDefaultTempDir() {\n        if (defaultTempDir != null && defaultTempDir.exists()) {\n            return defaultTempDir;\n        }\n\n        String s = System.getProperty(\"java.io.tmpdir\");\n        File checkExists = new File(s);\n        if (!checkExists.exists()) {\n            throw new RuntimeException(\"The directory \"\n                                   + checkExists.getAbsolutePath()\n                                   + \" does not exist, please set java.io.tempdir\"\n                                   + \" to an existing directory\");\n        }\n\n        // why do we create another tmp folder\n        Random ran = new Random();\n        int x = ran.nextInt(1000000);\n\n        File f = new File(s, \"camel-tmp-\" + x);\n        while (!f.mkdir()) {\n            x = ran.nextInt(1000000);\n            f = new File(s, \"camel-tmp-\" + x);\n        }\n\n        defaultTempDir = f;\n\n        // create shutdown hook to remove the temp dir\n        Thread hook = new Thread() {\n            @Override\n            public void run() {\n                removeDir(defaultTempDir);\n            }\n        };\n        Runtime.getRuntime().addShutdownHook(hook);\n\n        return defaultTempDir;\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public static File createTempFile(String prefix, String suffix, File parentDir,\n                               boolean deleteOnExit) throws IOException {\n        File result = null;\n        File parent = (parentDir == null)\n            ? getDefaultTempDir()\n            : parentDir;\n            \n        if (suffix == null) {\n            suffix = \".tmp\";\n        }\n        if (prefix == null) {\n            prefix = \"camel\";\n        } else if (prefix.length() < 3) {\n            prefix = prefix + \"camel\";\n        }\n        result = File.createTempFile(prefix, suffix, parent);\n\n        //if parentDir is null, we're in our default dir\n        //which will get completely wiped on exit from our exit\n        //hook.  No need to set deleteOnExit() which leaks memory.\n        if (deleteOnExit && parentDir != null) {\n            result.deleteOnExit();\n        }\n        return result;\n    }","id":80822,"modified_method":"public static File createTempFile(String prefix, String suffix, File parentDir) throws IOException {\n        File parent = (parentDir == null) ? getDefaultTempDir() : parentDir;\n            \n        if (suffix == null) {\n            suffix = \".tmp\";\n        }\n        if (prefix == null) {\n            prefix = \"camel\";\n        } else if (prefix.length() < 3) {\n            prefix = prefix + \"camel\";\n        }\n\n        // create parent folder\n        parent.mkdirs();\n\n        return File.createTempFile(prefix, suffix, parent);\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public static void mkDir(File dir) {\n        if (dir == null) {\n            throw new RuntimeException(\"dir attribute is required\");\n        }\n\n        if (dir.isFile()) {\n            throw new RuntimeException(\"Unable to create directory as a file \"\n                                    + \"already exists with that name: \" + dir.getAbsolutePath());\n        }\n\n        if (!dir.exists()) {\n            boolean result = doMkDirs(dir);\n            if (!result) {\n                String msg = \"Directory \" + dir.getAbsolutePath()\n                             + \" creation was not successful for an unknown reason\";\n                throw new RuntimeException(msg);\n            }\n        }\n    }","id":80823,"modified_method":"public static void mkDir(File dir) {\n        if (dir == null) {\n            throw new IllegalArgumentException(\"dir attribute is required\");\n        }\n\n        if (dir.isFile()) {\n            throw new RuntimeException(\"Unable to create directory as a file \"\n                                    + \"already exists with that name: \" + dir.getAbsolutePath());\n        }\n\n        if (!dir.exists()) {\n            boolean result = doMkDirs(dir);\n            if (!result) {\n                String msg = \"Directory \" + dir.getAbsolutePath()\n                             + \" creation was not successful for an unknown reason\";\n                throw new RuntimeException(msg);\n            }\n        }\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public static void removeDir(File d) {\n        String[] list = d.list();\n        if (list == null) {\n            list = new String[0];\n        }\n        for (int i = 0; i < list.length; i++) {\n            String s = list[i];\n            File f = new File(d, s);\n            if (f.isDirectory()) {\n                removeDir(f);\n            } else {\n                delete(f);\n            }\n        }\n        delete(d);\n    }","id":80824,"modified_method":"public static void removeDir(File d) {\n        String[] list = d.list();\n        if (list == null) {\n            list = new String[0];\n        }\n        for (String s : list) {\n            File f = new File(d, s);\n            if (f.isDirectory()) {\n                removeDir(f);\n            } else {\n                delete(f);\n            }\n        }\n        delete(d);\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"protected HttpOperationFailedException populateHttpOperationFailedException(Exchange exchange, HttpMethod method, int responseCode) throws IOException {\n        HttpOperationFailedException exception;\n        Header[] headers = method.getResponseHeaders();\n        InputStream is = extractResponseBody(method, exchange);\n        if (responseCode >= 300 && responseCode < 400) {\n            String redirectLocation;\n            Header locationHeader = method.getResponseHeader(\"location\");\n            if (locationHeader != null) {\n                redirectLocation = locationHeader.getValue();\n                exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), redirectLocation, headers, is);\n            } else {\n                // no redirect location\n                exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), headers, is);\n            }\n        } else {\n            // internal server error (error code 500)\n            exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), headers, is);\n        }\n        return exception;\n    }","id":80825,"modified_method":"protected HttpOperationFailedException populateHttpOperationFailedException(Exchange exchange, HttpMethod method, int responseCode) throws IOException {\n        HttpOperationFailedException exception;\n        Header[] headers = method.getResponseHeaders();\n        InputStream is = extractResponseBody(method, exchange);\n        // make a defensive copy of the response body in the exception so its detached from the cache\n        InputStream copy = null;\n        if (is != null) {\n            copy = new ByteArrayInputStream(exchange.getContext().getTypeConverter().convertTo(byte[].class, is));\n        }\n\n        if (responseCode >= 300 && responseCode < 400) {\n            String redirectLocation;\n            Header locationHeader = method.getResponseHeader(\"location\");\n            if (locationHeader != null) {\n                redirectLocation = locationHeader.getValue();\n                exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), redirectLocation, headers, copy);\n            } else {\n                // no redirect location\n                exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), headers, copy);\n            }\n        } else {\n            // internal server error (error code 500)\n            exception = new HttpOperationFailedException(responseCode, method.getStatusLine(), headers, copy);\n        }\n\n        return exception;\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"private static InputStream doExtractResponseBody(InputStream is, Exchange exchange) throws IOException {\n        try {\n            CachedOutputStream cos = new CachedOutputStream(exchange.getContext().getProperties());\n            IOHelper.copy(is, cos);\n            return cos.getInputStream();\n        } finally {\n            ObjectHelper.close(is, \"Extracting response body\", LOG);            \n        }\n    }","id":80826,"modified_method":"private static InputStream doExtractResponseBody(InputStream is, Exchange exchange) throws IOException {\n        try {\n            CachedOutputStream cos = new CachedOutputStream(exchange);\n            IOHelper.copy(is, cos);\n            return cos.getInputStream();\n        } finally {\n            ObjectHelper.close(is, \"Extracting response body\", LOG);            \n        }\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"@Converter\n    public StreamCache convertToStreamCache(InputStream stream, Exchange exchange) throws IOException {\n        // set up CachedOutputStream with the properties\n        CachedOutputStream cos = new CachedOutputStream(exchange.getContext().getProperties());\n        IOHelper.copyAndCloseInput(stream, cos);\n        return cos.getStreamCache();\n    }","id":80827,"modified_method":"@Converter\n    public StreamCache convertToStreamCache(InputStream stream, Exchange exchange) throws IOException {\n        CachedOutputStream cos = new CachedOutputStream(exchange);\n        IOHelper.copyAndCloseInput(stream, cos);\n        return cos.getStreamCache();\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public void testConvertToStreamCacheInpuStreamWithFileCache() throws Exception {\n        // set up the properties\n        Map<String, String> properties = new HashMap<String, String>();\n        properties.put(CachedOutputStream.THRESHOLD, \"1\");\n        exchange.getContext().setProperties(properties);\n        InputStream is = getTestFileStream();\n        InputStream cache = (InputStream)converter.convertToStreamCache(is, exchange);\n        assertNotNull(IOConverter.toString(cache));\n        try {\n            // since the stream is closed you delete the temp file\n            // reset will not work any more\n            cache.reset();\n            fail(\"except the exception here\");\n        } catch (Exception exception) {\n            // do nothing\n        }\n    }","id":80828,"modified_method":"public void testConvertToStreamCacheInpuStreamWithFileCache() throws Exception {\n        // set up the properties\n        Map<String, String> properties = new HashMap<String, String>();\n        properties.put(CachedOutputStream.THRESHOLD, \"1\");\n        exchange.getContext().setProperties(properties);\n        InputStream is = getTestFileStream();\n        InputStream cache = (InputStream)converter.convertToStreamCache(is, exchange);\n        assertNotNull(IOConverter.toString(cache));\n        try {\n            // since the stream is closed you delete the temp file\n            // reset will not work any more\n            cache.reset();\n            exchange.getUnitOfWork().done(exchange);\n            fail(\"except the exception here\");\n        } catch (Exception exception) {\n            // do nothing\n        }\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"public StreamSourceCache(StreamSource source, Exchange exchange) throws IOException {\n        if (source.getInputStream() != null) {\n            // set up CachedOutputStream with the properties\n            CachedOutputStream cos = new CachedOutputStream(exchange.getContext().getProperties());\n            IOHelper.copyAndCloseInput(source.getInputStream(), cos);\n            streamCache = cos.getStreamCache();\n            readCache = null;\n            setSystemId(source.getSystemId());\n            stream = (InputStream) streamCache;\n        } else if (source.getReader() != null) {\n            String data = exchange.getContext().getTypeConverter().convertTo(String.class, source.getReader());\n            readCache = new ReaderCache(data);\n            streamCache = null;\n            setReader(readCache);\n            stream = new ByteArrayInputStream(data.getBytes());\n        } else {\n            streamCache = null;\n            readCache = null;\n            stream = null;\n        }\n    }","id":80829,"modified_method":"public StreamSourceCache(StreamSource source, Exchange exchange) throws IOException {\n        if (source.getInputStream() != null) {\n            // set up CachedOutputStream with the properties\n            CachedOutputStream cos = new CachedOutputStream(exchange);\n            IOHelper.copyAndCloseInput(source.getInputStream(), cos);\n            streamCache = cos.getStreamCache();\n            readCache = null;\n            setSystemId(source.getSystemId());\n            stream = (InputStream) streamCache;\n        } else if (source.getReader() != null) {\n            String data = exchange.getContext().getTypeConverter().convertTo(String.class, source.getReader());\n            readCache = new ReaderCache(data);\n            streamCache = null;\n            setReader(readCache);\n            stream = new ByteArrayInputStream(data.getBytes());\n        } else {\n            streamCache = null;\n            readCache = null;\n            stream = null;\n        }\n    }","commit_id":"dfe65a73b0f7c07578aaee275b525349726f2c48","url":"https://github.com/apache/camel"},{"original_method":"/**\n    * Returns an {@link NSArray} containing the objects from the resulting rows starting\n     * at start and stopping at end using a custom SQL, derived from the SQL\n     * which the {@link EOFetchSpecification} would use normally {@link EOFetchSpecification.setHints}\n     *\n     * @param start \n     * @param end\n     *\n     * @return\n     */\n    public NSArray objectsInRange(int start, int end) {\n        //uses the original fetch specification and adds a top(start,(end - start)) to the query sql\n        EOFetchSpecification spec = databaseDataSource().fetchSpecificationForFetch();\n        //sortOrderings from the WODisplayGroup is only used in Memory: painful slow...\n        spec.setSortOrderings(sortOrderings());\n\n        EOEditingContext ec = databaseDataSource().editingContext();\n        String sql = ERXEOAccessUtilities.sqlForFetchSpecificationAndEditingContext(spec, ec);\n        \n        //add TOP(start, (end - start)) after the SELECT word\n        int index = sql.indexOf(\"select\");\n        if (index == -1) {\n            index = sql.indexOf(\"SELECT\");\n        }\n        index += 6;\n\n        //FIXME: this works for frontbase, might need to be adjusted for other db servers!\n        StringBuffer buf = new StringBuffer();\n        buf.append(sql.substring(0, index)).append(\" TOP(\").append(start).append(\",\").append(end - start).append(\") \").append(sql.substring(index + 1, sql.length()));\n        sql = buf.toString();\n\n        NSDictionary hints = new NSDictionary(sql, \"EOCustomQueryExpressionHintKey\");\n        spec.setHints(hints);\n        \n        return ec.objectsWithFetchSpecification(spec);\n    }","id":80830,"modified_method":"/**\n     * Returns an {@link NSArray} containing the objects from the resulting rows starting\n     * at start and stopping at end using a custom SQL, derived from the SQL\n     * which the {@link EOFetchSpecification} would use normally {@link EOFetchSpecification.setHints}\n     *\n     * @param start \n     * @param end\n     *\n     * @return\n     */\n    public NSArray objectsInRange(int start, int end) {\n        //uses the original fetch specification and adds a top(start,(end - start)) to the query sql\n        EOFetchSpecification spec = databaseDataSource().fetchSpecificationForFetch();\n        //sortOrderings from the WODisplayGroup is only used in Memory: painful slow...\n        spec.setSortOrderings(sortOrderings());\n\n        EOEditingContext ec = databaseDataSource().editingContext();\n        String sql = ERXEOAccessUtilities.sqlForFetchSpecificationAndEditingContext(spec, ec, start, end);\n        \n        NSDictionary hints = new NSDictionary(sql, \"EOCustomQueryExpressionHintKey\");\n        spec.setHints(hints);\n        \n        return ec.objectsWithFetchSpecification(spec);\n    }","commit_id":"7baa021ac9328a5fc4e3add562699805d25558b0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n    * Returns the number of rows from the {@link EODatabaseDataSource}.\n     *\n     * @return the number of rows from the {@link EODatabaseDataSource}\n     */\n    public int rowCount() {\n        EOFetchSpecification spec = databaseDataSource().fetchSpecificationForFetch();\n        EOEditingContext ec = databaseDataSource().editingContext();\n        EOModel model = ERXEOAccessUtilities.modelForFetchSpecificationAndEditingContext(spec, ec);\n        String sql = ERXEOAccessUtilities.sqlForFetchSpecificationAndEditingContext(spec, ec);\n        int index = sql.indexOf(\"from\");\n        if (index == -1) {\n            index = sql.indexOf(\"FROM\");\n        }\n        sql = \"select count(*) \" + sql.substring(index, sql.length());\n        NSArray result = EOUtilities.rawRowsForSQL(ec, model.name(), sql);\n\n        if (result.count() > 0) {\n            NSDictionary dict = (NSDictionary)result.objectAtIndex(0);\n            NSArray values = dict.allValues();\n            if (values.count() > 0) {\n                Object value = values.objectAtIndex(0);\n                if (value instanceof Number) {\n                    return ((Number)value).intValue();\n                } else {\n                    try {\n                        int c = Integer.parseInt(value.toString());\n                        setObjectArray(new ERFakeNSArray(c));\n                        return c;\n                    } catch (NumberFormatException e) {\n                        throw new IllegalStateException(\"sql \"+sql+\" returned a wrong result, could not convert \"+value+\" into an int!\");\n                    }\n                }\n            } else {\n                throw new IllegalStateException(\"sql \"+sql+\" returned no result!\");\n            }\n        } else {\n            throw new IllegalStateException(\"sql \"+sql+\" returned no result!\");\n        }\n    }","id":80831,"modified_method":"/**\n     * Returns the number of rows from the {@link EODatabaseDataSource}.\n     *\n     * @return the number of rows from the {@link EODatabaseDataSource}\n     */\n    public int rowCount() {\n        if(_rowCount == -1) {\n            EOFetchSpecification spec = databaseDataSource().fetchSpecificationForFetch();\n            EOEditingContext ec = databaseDataSource().editingContext();\n            EOModel model = ERXEOAccessUtilities.modelForFetchSpecificationAndEditingContext(spec, ec);\n            String sql = ERXEOAccessUtilities.sqlForFetchSpecificationAndEditingContext(spec, ec);\n            int index = sql.indexOf(\"from\");\n            if (index == -1) {\n                index = sql.indexOf(\"FROM\");\n            }\n            sql = \"select count(*) \" + sql.substring(index, sql.length());\n            NSArray result = EOUtilities.rawRowsForSQL(ec, model.name(), sql);\n\n            if (result.count() > 0) {\n                NSDictionary dict = (NSDictionary)result.objectAtIndex(0);\n                NSArray values = dict.allValues();\n                if (values.count() > 0) {\n                    Object value = values.objectAtIndex(0);\n                    if (value instanceof Number) {\n                        return ((Number)value).intValue();\n                    } else {\n                        try {\n                            int c = Integer.parseInt(value.toString());\n                            setObjectArray(new FakeArray(c));\n                            _rowCount = c;\n                        } catch (NumberFormatException e) {\n                            throw new IllegalStateException(\"sql \"+sql+\" returned a wrong result, could not convert \"+value+\" into an int!\");\n                        }\n                    }\n                } else {\n                    throw new IllegalStateException(\"sql \"+sql+\" returned no result!\");\n                }\n            } else {\n                throw new IllegalStateException(\"sql \"+sql+\" returned no result!\");\n            }\n        }\n        return _rowCount;\n    }","commit_id":"7baa021ac9328a5fc4e3add562699805d25558b0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n    * Determines if batching is possible. \n     *\n     * @return true if dataSource is an instance of EODatabaseDataSource\n     */\n    public boolean isBatching() {\n        return dataSource() instanceof EODatabaseDataSource;\n    }","id":80832,"modified_method":"/**\n     * Determines if batching is possible. \n     *\n     * @return true if dataSource is an instance of EODatabaseDataSource\n     */\n    public boolean isBatching() {\n        if(_isBatching == null) {\n            _isBatching = dataSource() instanceof EODatabaseDataSource ? Boolean.TRUE : Boolean.FALSE;\n        }\n        return _isBatching.booleanValue();\n    }","commit_id":"7baa021ac9328a5fc4e3add562699805d25558b0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n    * Overridden in order to use a custom method which determines the number of Objects / rows\n     * for the existing EODatabaseDataSource.\n     *\n     * @return the number of rows from the EODatabaseDataSource\n     */\n    public int batchCount() {\n        if(numberOfObjectsPerBatch() == 0) {\n            return 0;\n        }\n        if(rowCount() == 0) {\n            return 1;\n        } else {\n            return (rowCount() - 1) / numberOfObjectsPerBatch() + 1;\n        }\n    }","id":80833,"modified_method":"/**\n      * Overridden in order to use a custom method which determines the number of Objects / rows\n     * for the existing EODatabaseDataSource.\n     *\n     * @return the number of rows from the EODatabaseDataSource\n     */\n    public int batchCount() {\n        if(isBatching()) {\n            if(numberOfObjectsPerBatch() == 0) {\n                return 0;\n            }\n            if(rowCount() == 0) {\n                return 1;\n            } else {\n                return (rowCount() - 1) / numberOfObjectsPerBatch() + 1;\n            }\n        }\n        return super.batchCount();\n    }","commit_id":"7baa021ac9328a5fc4e3add562699805d25558b0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n    * Overridden method in order to fetch -only- the rows that are needed. This is\n     * different to the editors methods because a {@link WODisplayGroup} would always fetch\n     * from the start until the end of the objects from the fetch limit.\n     *\n     * @return the objects that should be diplayed.\n     */\n    public NSArray displayedObjects() {\n        if (!isBatching()) return super.displayedObjects();\n\n        //check the start and end based on currentBatchIndex and numberOfObjectsPerBatch()\n        int count = rowCount();\n        int start = currentBatchIndex() * numberOfObjectsPerBatch();\n        int end = start + numberOfObjectsPerBatch();\n\n        if (numberOfObjectsPerBatch() == 0) {\n            start = 0;\n            end = rowCount();\n        }\n\n        NSMutableArray objects = objectsInRange(start, end).mutableClone();\n\n        return objects;\n    }","id":80834,"modified_method":"/**\n    * Overridden method in order to fetch -only- the rows that are needed. This is\n     * different to the editors methods because a {@link WODisplayGroup} would always fetch\n     * from the start until the end of the objects from the fetch limit.\n     *\n     * @return the objects that should be diplayed.\n     */\n    public NSArray displayedObjects() {\n        if (!isBatching()) {\n            return super.displayedObjects();\n        } else {\n            if(_displayedObjects == null) {\n                //check the start and end based on currentBatchIndex and numberOfObjectsPerBatch()\n                int count = rowCount();\n                int start = (currentBatchIndex()-1) * numberOfObjectsPerBatch();\n                int end = start + numberOfObjectsPerBatch();\n\n                if (numberOfObjectsPerBatch() == 0) {\n                    start = 0;\n                    end = rowCount();\n                }\n\n                _displayedObjects = objectsInRange(start, end).mutableClone();\n            }\n        }\n        return _displayedObjects;\n    }","commit_id":"7baa021ac9328a5fc4e3add562699805d25558b0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** creates the SQL which is used by the provides EOFetchSpecification. The EOEditingContext is needed\n    * because it -could- be possible to have multiple EOF stacks, each having its own EOModelGroup and\n    * each EOModel in this group could connect to different databases, Oracle, FrontBase, ...\n    *\n     * @param spec the EOFetchSpecification in question\n     * @param ec the EOEditingContext\n     *\n     * @return the SQL which the EOFetchSpecification would use\n     */\n    public static String sqlForFetchSpecificationAndEditingContext(EOFetchSpecification spec, EOEditingContext ec) {\n        EOModel model = modelForFetchSpecificationAndEditingContext(spec, ec);\n        EOEntity entity = model.entityNamed(spec.entityName());\n        EOAdaptor adaptor = EOAdaptor.adaptorWithModel(model);\n        EODatabase db = new EODatabase(adaptor);\n        EOSQLExpressionFactory sqlFactory = adaptor.expressionFactory();\n\n        //NSArray attributes = spec.rawRowKeyPaths();\n        NSArray attributesFromEntity = entity.attributesToFetch();\n\n        EOSQLExpression sqlExpr = sqlFactory.selectStatementForAttributes(attributesFromEntity, false, spec, entity);\n        sqlExpr.setUseBindVariables(false);\n        String sql = sqlExpr.statement();\n\n        return sql;\n    }","id":80835,"modified_method":"/** creates the SQL which is used by the provides EOFetchSpecification. The EOEditingContext is needed\n    * because it -could- be possible to have multiple EOF stacks, each having its own EOModelGroup and\n    * each EOModel in this group could connect to different databases, Oracle, FrontBase, ...\n    *\n     * @param spec the EOFetchSpecification in question\n     * @param ec the EOEditingContext\n     *\n     * @return the SQL which the EOFetchSpecification would use\n     */\n    public static String sqlForFetchSpecificationAndEditingContext(EOFetchSpecification spec, EOEditingContext ec) {\n       return sqlForFetchSpecificationAndEditingContext(spec,ec,0,-1);\n    }","commit_id":"7baa021ac9328a5fc4e3add562699805d25558b0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * \n   * Turns a valid XHTML document string and renders it as a PDF document.\n   * \n   * @param html\n   *          a string containing valid XHTML markup\n   * @param encoding\n   *          the encoding type used by the html string\n   * @param urlPrefix\n   *          the URL prefix to prepend to unqualified URLs in the html\n   * @param config\n   *          a dictionary of binding values used to configure the rending\n   *          engine specified in the \"engine\" key. See the chosen rendering\n   *          engine's documentation for available config options.\n   * @return an NSData object containing raw PDF data.\n   */\n  public static NSData htmlAsPdf(String html, String encoding, String urlPrefix, NSDictionary<String, Object> config) {\n    NSMutableDictionary<String, Object> _config = config.mutableClone();\n\n    if (_config == null)\n      _config = new NSMutableDictionary<String, Object>();\n\n    PDFBuilder builder = PDFBuilderFactory.newBuilder((String) _config.removeObjectForKey(\"engine\"));\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    try {\n      builder.setSource(html, encoding, urlPrefix, _config);\n      builder.createDocument(os);\n      os.close();\n      return new NSData(os.toByteArray());\n    } catch (Exception e) {\n      throw NSForwardException._runtimeExceptionForThrowable(e);\n    }\n  }","id":80836,"modified_method":"/**\n   * \n   * Turns a valid XHTML document string and renders it as a PDF document.\n   * \n   * @param html\n   *          a string containing valid XHTML markup\n   * @param encoding\n   *          the encoding type used by the html string\n   * @param urlPrefix\n   *          the URL prefix to prepend to unqualified URLs in the html\n   * @param config\n   *          a dictionary of binding values used to configure the rending\n   *          engine specified in the \"engine\" key. See the chosen rendering\n   *          engine's documentation for available config options.\n   * @return an NSData object containing raw PDF data.\n   */\n  public static NSData htmlAsPdf(String html, String encoding, String urlPrefix, NSDictionary<String, Object> config) {\n    NSMutableDictionary<String, Object> _config = config == null ? new NSMutableDictionary<String, Object>() : config.mutableClone();\n    PDFBuilder builder = PDFBuilderFactory.newBuilder((String) _config.removeObjectForKey(\"engine\"));\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    try {\n      builder.setSource(html, encoding, urlPrefix, _config);\n      builder.createDocument(os);\n      os.close();\n      return new NSData(os.toByteArray());\n    } catch (Exception e) {\n      throw NSForwardException._runtimeExceptionForThrowable(e);\n    }\n  }","commit_id":"8cb0495328fe7174a70f3be2c8211af732ef95c9","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n  public boolean isModified(MPSConfigurationBean data) {\n    return isModified(getDependency());\n  }","id":80837,"modified_method":"@Override\n  public boolean isModified(MPSConfigurationBean data) {\n    return false;\n  }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void onTabEntering() {\n    List<Dependency> dependency = getDependency();\n    if (isModified(dependency)) {\n      setElements(dependency);\n    }\n  }","id":80838,"modified_method":"@Override\n  public void onTabEntering() {\n    List<Dependency> dependency = getDependency();\n    if (needsUpdate(dependency)) {\n      setElements(dependency);\n    }\n  }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void createCentralComponent() {\n    TabbedPaneWrapper tabbedPane = new TabbedPaneWrapper(myParentDisposable);\n    MPSFacetSourcesTab mpsFacetSourcesTab = new MPSFacetSourcesTab(myContext, myParentDisposable);\n    MPSFacetPathsTab mpsFacetPathsTab = new MPSFacetPathsTab(myContext);\n    UsedLanguagesTable usedLanguagesTable = new UsedLanguagesTable() {\n      @Override\n      protected void doAddElements(final Set<ModuleReference> elementsToAdd) {\n        super.doAddElements(elementsToAdd);\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            new ModuleRuntimeLibrariesImporter(myContext, elementsToAdd).addMissingLibraries();\n          }\n        });\n      }\n    };\n    ImportedSolutionsTable importedSolutionsTable = new ImportedSolutionsTable(myContext) {\n      @Override\n      protected void doAddElements(Set<Dependency> elementsToAdd) {\n        super.doAddElements(elementsToAdd);\n        final Collection<ModuleReference> referencesToAdd = new ArrayList<ModuleReference>();\n        for (Dependency dependency : elementsToAdd) {\n          referencesToAdd.add(dependency.getModuleRef());\n        }\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            new ModuleRuntimeLibrariesImporter(myContext, referencesToAdd).addMissingLibraries();\n          }\n        });\n      }\n\n      @Override\n      protected void check(Dependency element, boolean value) {\n        super.check(element, value);\n        // If we reexport mps module then we should reexport its lib as well.\n//        Library moduleLibrary = SolutionLibrariesIndex.getInstance(myContext.getProject()).getLibraries(element.getModuleRef());\n//        if (moduleLibrary != null) {\n//          LibraryOrderEntry libraryOrderEntry = myContext.getModifiableRootModel().findLibraryOrderEntry(moduleLibrary);\n//          if (libraryOrderEntry != null) {\n//            libraryOrderEntry.setExported(value);\n//          }\n//        }\n      }\n    };\n\n    // can not make it final and init in declaration since idea forms generator does not like it and put $$$setupUI$$$ call before setting the field\n    myTabs = new ArrayList<IModuleConfigurationTab>();\n    myTabs.add(mpsFacetSourcesTab);\n    myTabs.add(mpsFacetPathsTab);\n    myTabs.add(usedLanguagesTable);\n    myTabs.add(importedSolutionsTable);\n\n    tabbedPane.addTab(MPSBundle.message(\"facet.sources.tab.name\"), MPSIcons.SOURCES_TAB_ICON, mpsFacetSourcesTab.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.paths.tab.name\"), MPSIcons.PATHS_TAB_ICON, mpsFacetPathsTab.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.languages.tab.name\"), MPSIcons.LANGUAGES_TAB_ICON, usedLanguagesTable.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.solutions.tab.name\"), MPSIcons.SOLUTION_ICON, importedSolutionsTable.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.devkits.tab.name\"), MPSIcons.DEVKITS_TAB_ICON, new JPanel(), null);\n\n    myCentralComponent = tabbedPane.getComponent();\n  }","id":80839,"modified_method":"private void createCentralComponent() {\n    TabbedPaneWrapper tabbedPane = new TabbedPaneWrapper(myParentDisposable);\n    MPSFacetSourcesTab mpsFacetSourcesTab = new MPSFacetSourcesTab(myContext, myParentDisposable);\n    MPSFacetPathsTab mpsFacetPathsTab = new MPSFacetPathsTab(myContext);\n    UsedLanguagesTable usedLanguagesTable = new UsedLanguagesTable() {\n      @Override\n      protected void doAddElements(final Set<ModuleReference> elementsToAdd) {\n        super.doAddElements(elementsToAdd);\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            new ModuleRuntimeLibrariesImporter(myContext, elementsToAdd).addMissingLibraries();\n          }\n        });\n      }\n    };\n    ImportedSolutionsTable importedSolutionsTable = new ImportedSolutionsTable(myContext);\n\n    // can not make it final and init in declaration since idea forms generator does not like it and put $$$setupUI$$$ call before setting the field\n    myTabs = new ArrayList<IModuleConfigurationTab>();\n    myTabs.add(mpsFacetSourcesTab);\n    myTabs.add(mpsFacetPathsTab);\n    myTabs.add(usedLanguagesTable);\n    myTabs.add(importedSolutionsTable);\n\n    tabbedPane.addTab(MPSBundle.message(\"facet.sources.tab.name\"), MPSIcons.SOURCES_TAB_ICON, mpsFacetSourcesTab.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.paths.tab.name\"), MPSIcons.PATHS_TAB_ICON, mpsFacetPathsTab.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.languages.tab.name\"), MPSIcons.LANGUAGES_TAB_ICON, usedLanguagesTable.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.solutions.tab.name\"), MPSIcons.SOLUTION_ICON, importedSolutionsTable.getRootPanel(), null);\n    tabbedPane.addTab(MPSBundle.message(\"facet.devkits.tab.name\"), MPSIcons.DEVKITS_TAB_ICON, new JPanel(), null);\n\n    myCentralComponent = tabbedPane.getComponent();\n  }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JComponent createComponent() {\n    myElementsTableModel = new CheckboxTableModel();\n\n    myElementsTable = new JBTable(myElementsTableModel);\n    myElementsTable.setShowGrid(false);\n    myElementsTable.setDragEnabled(false);\n    myElementsTable.setShowHorizontalLines(false);\n    myElementsTable.setShowVerticalLines(false);\n    myElementsTable.setIntercellSpacing(new Dimension(0, 0));\n\n    myElementsTable.setDefaultRenderer(getElementClass(), createDefaultRenderer());\n    myElementsTable.setDefaultRenderer(Boolean.class, new BooleanTableCellRenderer());\n\n    myElementsTable.setBorder(new LineBorder(UIUtil.getBorderColor()));\n\n    myElementsTable.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    myElementsTable.setColumnSelectionAllowed(false);\n    myElementsTable.setRowSelectionAllowed(true);\n    if (myElementsTable.getRowCount() > 0) {\n      myElementsTable.getSelectionModel().setSelectionInterval(0, 0);\n    }\n\n    TableColumn firstColumn = myElementsTable.getColumnModel().getColumn(0);\n    firstColumn.setCellEditor(new BooleanTableCellEditor());\n    firstColumn.setResizable(false);\n    TableColumn headerColumn = myElementsTable.getTableHeader().getColumnModel().getColumn(0);\n    headerColumn.setMaxWidth(headerColumn.getPreferredWidth());\n\n    myElementsTable.registerKeyboardAction(\n      new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          int[] selectedRows = myElementsTable.getSelectedRows();\n          boolean currentlyMarked = true;\n          List<E> elements = myElementsTableModel.getElements();\n          for (int selectedRow : selectedRows) {\n            E element = elements.get(selectedRow);\n            if (selectedRow < 0) {\n              return;\n            }\n            currentlyMarked &= isChecked(element);\n          }\n          for (final int selectedRow : selectedRows) {\n            check(elements.get(selectedRow), !currentlyMarked);\n          }\n          myElementsTableModel.fireTableDataChanged();\n          TableUtil.selectRows(myElementsTable, selectedRows);\n        }\n      },\n      KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0),\n      JComponent.WHEN_FOCUSED\n    );\n\n    new SpeedSearchBase<JBTable>(myElementsTable) {\n      public int getSelectedIndex() {\n        return myElementsTable.getSelectedRow();\n      }\n\n      @Override\n      protected int convertIndexToModel(int viewIndex) {\n        return myElementsTable.convertRowIndexToModel(viewIndex);\n      }\n\n      public Object[] getAllElements() {\n        List<E> elements = myElementsTableModel.getElements();\n        return elements.toArray(new Object[elements.size()]);\n      }\n\n      public String getElementText(Object element) {\n        return getElementText(getElement((E) element));\n      }\n\n      public void selectElement(Object element, String selectedText) {\n        final int count = myElementsTableModel.getRowCount();\n        for (int row = 0; row < count; row++) {\n          if (element.equals(myElementsTableModel.getValueAt(0, row))) {\n            final int viewRow = myElementsTable.convertRowIndexToView(row);\n            myElementsTable.getSelectionModel().setSelectionInterval(viewRow, viewRow);\n            TableUtil.scrollSelectionToVisible(myElementsTable);\n            break;\n          }\n        }\n      }\n    };\n\n    ToolbarDecorator decorator = ToolbarDecorator.createDecorator(myElementsTable);\n    decorator.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton anActionButton) {\n        ModelAccess.instance().runReadInEDT(new Runnable() {\n          @Override\n          public void run() {\n            final List<E> allElements = getAllVisibleElements();\n            Set<S> addedElements = getAddedElements();\n\n            Iterator<E> it = allElements.iterator();\n            while (it.hasNext()) {\n              if (addedElements.contains(getElement(it.next()))){\n                it.remove();\n              }\n            }\n            Collections.sort(allElements, getComparator());\n\n            SwingUtilities.invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                ChooseElementsDialog<E> chooseElementsDialog = new ChooseElementsDialog<E>(myElementsTable, allElements, getChooserTitle()) {\n                  @Override\n                  protected String getItemText(E item) {\n                    return getText(getElement(item));\n                  }\n\n                  @Override\n                  protected Icon getItemIcon(E item) {\n                    return getIcon();\n                  }\n                };\n                chooseElementsDialog.show();\n                Set<E> elementsToAdd = new HashSet<E>(chooseElementsDialog.getChosenElements());\n                doAddElements(elementsToAdd);\n              }\n            });\n          }\n        });\n      }\n    }).setRemoveAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton anActionButton) {\n        TableUtil.removeSelectedItems(myElementsTable);\n        myElementsTableModel.fireTableDataChanged();\n      }\n    });\n    return postDecoratePanel(decorator.createPanel());\n  }","id":80840,"modified_method":"public JComponent createComponent() {\n    myElementsTableModel = new CheckboxTableModel();\n\n    myElementsTable = new JBTable(myElementsTableModel);\n    myElementsTable.setShowGrid(false);\n    myElementsTable.setDragEnabled(false);\n    myElementsTable.setShowHorizontalLines(false);\n    myElementsTable.setShowVerticalLines(false);\n    myElementsTable.setIntercellSpacing(new Dimension(0, 0));\n\n    myElementsTable.setDefaultRenderer(getElementClass(), createDefaultRenderer());\n    myElementsTable.setDefaultRenderer(Boolean.class, new BooleanTableCellRenderer());\n\n    myElementsTable.setBorder(new LineBorder(UIUtil.getBorderColor()));\n\n    myElementsTable.setColumnSelectionAllowed(false);\n    myElementsTable.setRowSelectionAllowed(false);\n\n    TableColumn firstColumn = myElementsTable.getColumnModel().getColumn(0);\n    firstColumn.setResizable(false);\n    TableColumn headerColumn = myElementsTable.getTableHeader().getColumnModel().getColumn(0);\n    headerColumn.setMaxWidth(headerColumn.getPreferredWidth());\n\n    new SpeedSearchBase<JBTable>(myElementsTable) {\n      public int getSelectedIndex() {\n        return myElementsTable.getSelectedRow();\n      }\n\n      @Override\n      protected int convertIndexToModel(int viewIndex) {\n        return myElementsTable.convertRowIndexToModel(viewIndex);\n      }\n\n      public Object[] getAllElements() {\n        List<E> elements = myElementsTableModel.getElements();\n        return elements.toArray(new Object[elements.size()]);\n      }\n\n      public String getElementText(Object element) {\n        return getElementText(getElement((E) element));\n      }\n\n      public void selectElement(Object element, String selectedText) {\n        final int count = myElementsTableModel.getRowCount();\n        for (int row = 0; row < count; row++) {\n          if (element.equals(myElementsTableModel.getValueAt(0, row))) {\n            final int viewRow = myElementsTable.convertRowIndexToView(row);\n            myElementsTable.getSelectionModel().setSelectionInterval(viewRow, viewRow);\n            TableUtil.scrollSelectionToVisible(myElementsTable);\n            break;\n          }\n        }\n      }\n    };\n\n    ToolbarDecorator decorator = ToolbarDecorator.createDecorator(myElementsTable);\n    JPanel panel = decorator.createPanel();\n    panel.setBorder(null);\n    return panel;\n  }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n      return columnIndex == 0;\n    }","id":80841,"modified_method":"@Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n      return false;\n    }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isModified(List<E> elements) {\n    List<E> sortedLanguagesList = new ArrayList<E>(elements);\n    Collections.sort(sortedLanguagesList, getComparator());\n    return !getElements().equals(sortedLanguagesList);\n  }","id":80842,"modified_method":"protected boolean isModified(List<E> elements) {\n    List<E> sortedLanguagesList = new ArrayList<E>(elements);\n    Collections.sort(sortedLanguagesList, getComparator());\n    return !getElements().equals(sortedLanguagesList);\n  }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n      if (columnIndex == 0) {\n        check(getElements().get(rowIndex), (Boolean) aValue);\n      }\n      fireTableDataChanged();\n    }","id":80843,"modified_method":"@Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n    }","commit_id":"cbf3ec9ccf4a72981d8970fe55b5c250f2a2e46c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static JPanel createAddRemoveTreeClassChooserPanel(final ListTable table, final String chooserTitle,\n                                                            @NonNls String... ancestorClasses) {\n    final ClassFilter filter;\n    if (ancestorClasses.length == 0) {\n      filter = ClassFilter.ALL;\n    }\n    else {\n      filter = new SubclassFilter(ancestorClasses);\n    }\n    return ToolbarDecorator.createDecorator(table)\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final DataContext dataContext = DataManager.getInstance().getDataContext(table);\n          final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n          final int rowIndex;\n          final ListWrappingTableModel tableModel = table.getModel();\n          if (project == null) {\n            tableModel.addRow();\n            rowIndex = tableModel.getRowCount() - 1;\n          }\n          else {\n            final TreeClassChooserFactory chooserFactory = TreeClassChooserFactory.getInstance(project);\n            final TreeClassChooser classChooser =\n              chooserFactory.createWithInnerClassesScopeChooser(chooserTitle, GlobalSearchScope.allScope(project), filter, null);\n            classChooser.showDialog();\n            final PsiClass selectedClass = classChooser.getSelected();\n            if (selectedClass == null) {\n              return;\n            }\n            final String qualifiedName = selectedClass.getQualifiedName();\n            final int index = tableModel.indexOf(qualifiedName, 0);\n            if (index < 0) {\n              tableModel.addRow(qualifiedName);\n              rowIndex = tableModel.getRowCount() - 1;\n            }\n            else {\n              rowIndex = index;\n            }\n          }\n          editTableCell(table, rowIndex, table.getColumnCount() > 1 && project != null ? 1 : 0);\n        }\n      }).setRemoveAction(new RemoveAction(table))\n      .disableUpDownActions().createPanel();\n  }","id":80844,"modified_method":"public static JPanel createAddRemoveTreeClassChooserPanel(final ListTable table, final String chooserTitle,\n                                                            @NonNls String... ancestorClasses) {\n    final ClassFilter filter;\n    if (ancestorClasses.length == 0) {\n      filter = ClassFilter.ALL;\n    }\n    else {\n      filter = new SubclassFilter(ancestorClasses);\n    }\n    final JPanel panel = ToolbarDecorator.createDecorator(table)\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final DataContext dataContext = DataManager.getInstance().getDataContext(table);\n          final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n          final int rowIndex;\n          final ListWrappingTableModel tableModel = table.getModel();\n          if (project == null) {\n            tableModel.addRow();\n            rowIndex = tableModel.getRowCount() - 1;\n          }\n          else {\n            final TreeClassChooserFactory chooserFactory = TreeClassChooserFactory.getInstance(project);\n            final TreeClassChooser classChooser =\n              chooserFactory.createWithInnerClassesScopeChooser(chooserTitle, GlobalSearchScope.allScope(project), filter, null);\n            classChooser.showDialog();\n            final PsiClass selectedClass = classChooser.getSelected();\n            if (selectedClass == null) {\n              return;\n            }\n            final String qualifiedName = selectedClass.getQualifiedName();\n            final int index = tableModel.indexOf(qualifiedName, 0);\n            if (index < 0) {\n              tableModel.addRow(qualifiedName);\n              rowIndex = tableModel.getRowCount() - 1;\n            }\n            else {\n              rowIndex = index;\n            }\n          }\n          editTableCell(table, rowIndex, table.getColumnCount() > 1 && project != null ? 1 : 0);\n        }\n      }).setRemoveAction(new RemoveAction(table))\n      .disableUpDownActions().createPanel();\n    panel.setPreferredSize(new Dimension(150, 100));\n    return panel;\n  }","commit_id":"7186a71ec5a07278551cbcb282bd8c09b7a3ba01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static JPanel createAddRemovePanel(final ListTable table) {\n    return ToolbarDecorator.createDecorator(table)\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final ListWrappingTableModel tableModel = table.getModel();\n          tableModel.addRow();\n          EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              final int lastRowIndex = tableModel.getRowCount() - 1;\n              editTableCell(table, lastRowIndex, 0);\n            }\n          });\n        }\n      }).setRemoveAction(new RemoveAction(table))\n      .disableUpDownActions().createPanel();\n  }","id":80845,"modified_method":"public static JPanel createAddRemovePanel(final ListTable table) {\n    final JPanel panel = ToolbarDecorator.createDecorator(table)\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final ListWrappingTableModel tableModel = table.getModel();\n          tableModel.addRow();\n          EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              final int lastRowIndex = tableModel.getRowCount() - 1;\n              editTableCell(table, lastRowIndex, 0);\n            }\n          });\n        }\n      }).setRemoveAction(new RemoveAction(table))\n      .disableUpDownActions().createPanel();\n    panel.setPreferredSize(new Dimension(150, 100));\n    return panel;\n  }","commit_id":"7186a71ec5a07278551cbcb282bd8c09b7a3ba01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static JPanel createTreeClassChooserList(final Collection<String> collection,\n                                                  String borderTitle,\n                                                  final String chooserTitle,\n                                                  String... ancestorClasses) {\n    final ClassFilter filter;\n    if (ancestorClasses.length == 0) {\n      filter = ClassFilter.ALL;\n    }\n    else {\n      filter = new SubclassFilter(ancestorClasses);\n    }\n    final JPanel optionsPanel = new JPanel(new BorderLayout());\n    final JBList list = new JBList(collection);\n\n    final JPanel panel = ToolbarDecorator.createDecorator(list)\n      .disableUpDownActions()\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton anActionButton) {\n          final DataContext dataContext = DataManager.getInstance().getDataContext(list);\n          final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n          if (project == null) {\n            return;\n          }\n          final TreeClassChooser chooser = TreeClassChooserFactory.getInstance(project)\n            .createNoInnerClassesScopeChooser(chooserTitle, GlobalSearchScope.allScope(project), filter, null);\n          chooser.showDialog();\n          final PsiClass selected = chooser.getSelected();\n          if (selected == null) {\n            return;\n          }\n          final String qualifiedName = selected.getQualifiedName();\n          final DefaultListModel model = (DefaultListModel)list.getModel();\n          final int index = model.indexOf(qualifiedName);\n          if (index < 0) {\n            model.addElement(qualifiedName);\n            collection.add(qualifiedName);\n          }\n          else {\n            list.setSelectedIndex(index);\n          }\n        }\n      })\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton anActionButton) {\n          collection.remove(list.getSelectedValue());\n          ListUtil.removeSelectedItems(list);\n        }\n      }).createPanel();\n    optionsPanel.setBorder(IdeBorderFactory.createTitledBorder(borderTitle,\n                                                               false, new Insets(10, 0, 0, 0)));\n    optionsPanel.add(panel);\n    return optionsPanel;\n  }","id":80846,"modified_method":"public static JPanel createTreeClassChooserList(final Collection<String> collection,\n                                                  String borderTitle,\n                                                  final String chooserTitle,\n                                                  String... ancestorClasses) {\n    final ClassFilter filter;\n    if (ancestorClasses.length == 0) {\n      filter = ClassFilter.ALL;\n    }\n    else {\n      filter = new SubclassFilter(ancestorClasses);\n    }\n    final JPanel optionsPanel = new JPanel(new BorderLayout());\n    final JBList list = new JBList(collection);\n\n    final JPanel panel = ToolbarDecorator.createDecorator(list)\n      .disableUpDownActions()\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton anActionButton) {\n          final DataContext dataContext = DataManager.getInstance().getDataContext(list);\n          final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n          if (project == null) {\n            return;\n          }\n          final TreeClassChooser chooser = TreeClassChooserFactory.getInstance(project)\n            .createNoInnerClassesScopeChooser(chooserTitle, GlobalSearchScope.allScope(project), filter, null);\n          chooser.showDialog();\n          final PsiClass selected = chooser.getSelected();\n          if (selected == null) {\n            return;\n          }\n          final String qualifiedName = selected.getQualifiedName();\n          final DefaultListModel model = (DefaultListModel)list.getModel();\n          final int index = model.indexOf(qualifiedName);\n          if (index < 0) {\n            model.addElement(qualifiedName);\n            collection.add(qualifiedName);\n          }\n          else {\n            list.setSelectedIndex(index);\n          }\n        }\n      })\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton anActionButton) {\n          collection.remove(list.getSelectedValue());\n          ListUtil.removeSelectedItems(list);\n        }\n      }).createPanel();\n    panel.setPreferredSize(new Dimension(150, 100));\n    optionsPanel.setBorder(IdeBorderFactory.createTitledBorder(borderTitle,\n                                                               false, new Insets(10, 0, 0, 0)));\n    optionsPanel.add(panel);\n    return optionsPanel;\n  }","commit_id":"7186a71ec5a07278551cbcb282bd8c09b7a3ba01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<PropertyDefinition> getPropertyDefinitions() {\n    return ImmutableList.of(\n      PropertyDefinition.builder(Constants.PATTERNS_MULTICRITERIA_KEY)\n        .category(CoreProperties.CATEGORY_EXCLUSIONS)\n        .subCategory(Constants.SUB_CATEGORY_IGNORE_ISSUES)\n        .deprecatedKey(Constants.DEPRECATED_MULTICRITERIA_KEY)\n        .name(\"Resource Key Pattern\")\n        .description(\"Patterns used to identify which violations to switch off.<br/>\" +\n          \"More information on the <a href=\\\"http://docs.codehaus.org/display/SONAR/Project+Administration#ProjectAdministration-IgnoringIssues\\\">Project Administration page<\/a>.<br/>\")\n        .onQualifiers(Qualifiers.PROJECT)\n        .fields(\n          PropertyFieldDefinition.build(Constants.RESOURCE_KEY)\n            .name(\"Resource Key Pattern\")\n            .description(\"Pattern used to match resources which should be ignored\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build(),\n          PropertyFieldDefinition.build(Constants.RULE_KEY)\n            .name(\"Rule Key Pattern\")\n            .description(\"Pattern used to match rules which should be ignored\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build(),\n          PropertyFieldDefinition.build(Constants.LINE_RANGE_KEY)\n            .name(\"Line Range\")\n            .description(\"Range of lines that should be ignored.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(SMALL_SIZE)\n            .build())\n        .build(),\n        PropertyDefinition.builder(Constants.PATTERNS_BLOCK_KEY)\n        .category(CoreProperties.CATEGORY_EXCLUSIONS)\n        .subCategory(Constants.SUB_CATEGORY_IGNORE_ISSUES)\n        .deprecatedKey(Constants.DEPRECATED_BLOCK_KEY)\n        .name(\"Block exclusion patterns\")\n        .description(\"Patterns used to identify blocks in which violations are switched off.<br/>\" +\n          \"More information on the <a href=\\\"http://docs.codehaus.org/display/SONAR/Project+Administration#ProjectAdministration-IgnoringIssues\\\">Project Administration page<\/a>.<br/>\")\n        .onQualifiers(Qualifiers.PROJECT)\n        .fields(\n          PropertyFieldDefinition.build(Constants.BEGIN_BLOCK_REGEXP)\n            .name(\"Regular expression for start of block\")\n            .description(\"If this regular expression is found in a resource, then following lines are ignored until end of block.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build(),\n          PropertyFieldDefinition.build(Constants.END_BLOCK_REGEXP)\n            .name(\"Regular expression for end of block\")\n            .description(\"If specified, this regular expression is used to determine the end of code blocks to ignore. If not, then block ends at the end of file.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build())\n        .build(),\n        PropertyDefinition.builder(Constants.PATTERNS_ALLFILE_KEY)\n        .category(CoreProperties.CATEGORY_EXCLUSIONS)\n        .subCategory(Constants.SUB_CATEGORY_IGNORE_ISSUES)\n        .deprecatedKey(Constants.DEPRECATED_ALLFILE_KEY)\n        .name(\"File exclusion patterns\")\n        .description(\"Patterns used to identify files in which violations are switched off.<br/>\" +\n          \"More information on the <a href=\\\"http://docs.codehaus.org/display/SONAR/Project+Administration#ProjectAdministration-IgnoringIssues\\\">Project Administration page<\/a>.<br/>\")\n        .onQualifiers(Qualifiers.PROJECT)\n        .fields(\n          PropertyFieldDefinition.build(Constants.FILE_REGEXP)\n            .name(\"Regular expression\")\n            .description(\"If this regular expression is found in a resource, then following lines are ignored.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build())\n        .build());\n  }","id":80847,"modified_method":"public static List<PropertyDefinition> getPropertyDefinitions() {\n    return ImmutableList.of(\n      PropertyDefinition.builder(Constants.PATTERNS_MULTICRITERIA_KEY)\n        .category(CoreProperties.CATEGORY_EXCLUSIONS)\n        .subCategory(Constants.SUB_CATEGORY_IGNORE_ISSUES)\n        .name(\"Resource Key Pattern\")\n        .description(\"Patterns used to identify which violations to switch off.<br/>\" +\n          \"More information on the <a href=\\\"http://docs.codehaus.org/display/SONAR/Project+Administration#ProjectAdministration-IgnoringIssues\\\">Project Administration page<\/a>.<br/>\")\n        .onQualifiers(Qualifiers.PROJECT)\n        .fields(\n          PropertyFieldDefinition.build(Constants.RESOURCE_KEY)\n            .name(\"Resource Key Pattern\")\n            .description(\"Pattern used to match resources which should be ignored\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build(),\n          PropertyFieldDefinition.build(Constants.RULE_KEY)\n            .name(\"Rule Key Pattern\")\n            .description(\"Pattern used to match rules which should be ignored\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build(),\n          PropertyFieldDefinition.build(Constants.LINE_RANGE_KEY)\n            .name(\"Line Range\")\n            .description(\"Range of lines that should be ignored.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(SMALL_SIZE)\n            .build())\n        .build(),\n        PropertyDefinition.builder(Constants.PATTERNS_BLOCK_KEY)\n        .category(CoreProperties.CATEGORY_EXCLUSIONS)\n        .subCategory(Constants.SUB_CATEGORY_IGNORE_ISSUES)\n        .name(\"Block exclusion patterns\")\n        .description(\"Patterns used to identify blocks in which violations are switched off.<br/>\" +\n          \"More information on the <a href=\\\"http://docs.codehaus.org/display/SONAR/Project+Administration#ProjectAdministration-IgnoringIssues\\\">Project Administration page<\/a>.<br/>\")\n        .onQualifiers(Qualifiers.PROJECT)\n        .fields(\n          PropertyFieldDefinition.build(Constants.BEGIN_BLOCK_REGEXP)\n            .name(\"Regular expression for start of block\")\n            .description(\"If this regular expression is found in a resource, then following lines are ignored until end of block.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build(),\n          PropertyFieldDefinition.build(Constants.END_BLOCK_REGEXP)\n            .name(\"Regular expression for end of block\")\n            .description(\"If specified, this regular expression is used to determine the end of code blocks to ignore. If not, then block ends at the end of file.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build())\n        .build(),\n        PropertyDefinition.builder(Constants.PATTERNS_ALLFILE_KEY)\n        .category(CoreProperties.CATEGORY_EXCLUSIONS)\n        .subCategory(Constants.SUB_CATEGORY_IGNORE_ISSUES)\n        .name(\"File exclusion patterns\")\n        .description(\"Patterns used to identify files in which violations are switched off.<br/>\" +\n          \"More information on the <a href=\\\"http://docs.codehaus.org/display/SONAR/Project+Administration#ProjectAdministration-IgnoringIssues\\\">Project Administration page<\/a>.<br/>\")\n        .onQualifiers(Qualifiers.PROJECT)\n        .fields(\n          PropertyFieldDefinition.build(Constants.FILE_REGEXP)\n            .name(\"Regular expression\")\n            .description(\"If this regular expression is found in a resource, then following lines are ignored.\")\n            .type(PropertyType.STRING)\n            .indicativeSize(LARGE_SIZE)\n            .build())\n        .build());\n  }","commit_id":"738118ab440cf584e023ea8992d85d1315c0f257","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n    @Graph( value = { \"Peter knows Ian\", \"Ian knows Peter\", \"Marie likes Peter\" }, autoIndexNodes = true, autoIndexRelationships=true )\n    public void test_Gremlin_load()\n    {\n        data.get();\n        String script = \"nodeIndex = g.idx('node_auto_index');\"\n                        + \"edgeIndex = g.idx('relationship_auto_index');\"\n                        + \"\"\n                        + \"node = { uri, properties -> \"\n                        + \"existing = nodeIndex.get('uri', uri);\"\n                        + \"properties['uri'] = uri;\"\n                        + \"if (existing) {    \"\n                        + \"return existing[0];  \"\n                        + \"}  else {\"\n                        + \"    return g.addVertex(properties);\"\n                        + \"};\"\n                        + \"};\"\n                        + \"Object.metaClass.makeNode = node;\"\n                        + \"edge = { type, source_uri, target_uri, properties ->\"\n                        + \"  source = nodeIndex.get('uri', source_uri) >> 1;\"\n                        + \"  target = nodeIndex.get('uri', target_uri) >> 1;\"\n                        + \"  nodeKey = source.id + '-' + target.id;\"\n                        + \"  existing = edgeIndex.get('nodes', nodeKey);\"\n                        + \"  if (existing) {\" + \"    return existing;\" + \"  };\"\n                        + \"  properties['nodes'] = nodeKey;\"\n                        + \"  g.addEdge(source, target, type, properties);\"\n                        + \"};\" + \"Object.metaClass.makeEdge = edge;\";\n        String payload = \"{\\\"script\\\":\\\"\" + script + \"\\\"}\";\n        description( formatGroovy( script ) );\n        gen.get().expectedStatus( Status.OK.getStatusCode() ).payload(\n                JSONPrettifier.parse( payload ) );\n        String response = gen.get().post( ENDPOINT ).entity();\n        payload = \"{\\\"script\\\":\\\"n = Object.metaClass.makeNode('uri',[:]\\\"}\";\n        gen.get().expectedStatus( Status.OK.getStatusCode() ).payload(\n                JSONPrettifier.parse( payload ) );\n        response = gen.get().post( ENDPOINT ).entity();\n        assertTrue( response.contains( \"uri\" ) );\n    }","id":80848,"modified_method":"@Test\n    @Graph( value = { \"Peter knows Ian\", \"Ian knows Peter\", \"Marie likes Peter\" }, autoIndexNodes = true, autoIndexRelationships=true )\n    public void test_Gremlin_load()\n    {\n        data.get();\n        String script = \"nodeIndex = g.idx('node_auto_index');\"\n                        + \"edgeIndex = g.idx('relationship_auto_index');\"\n                        + \"\"\n                        + \"node = { uri, properties -> \"\n                        + \"existing = nodeIndex.get('uri', uri);\"\n                        + \"properties['uri'] = uri;\"\n                        + \"if (existing) {    \"\n                        + \"return existing[0];  \"\n                        + \"}  else {\"\n                        + \"    return g.addVertex(properties);\"\n                        + \"};\"\n                        + \"};\"\n                        + \"Object.metaClass.makeNode = node;\"\n                        + \"edge = { type, source_uri, target_uri, properties ->\"\n                        + \"  source = nodeIndex.get('uri', source_uri) >> 1;\"\n                        + \"  target = nodeIndex.get('uri', target_uri) >> 1;\"\n                        + \"  nodeKey = source.id + '-' + target.id;\"\n                        + \"  existing = edgeIndex.get('nodes', nodeKey);\"\n                        + \"  if (existing) {\" + \"    return existing;\" + \"  };\"\n                        + \"  properties['nodes'] = nodeKey;\"\n                        + \"  g.addEdge(source, target, type, properties);\"\n                        + \"};\" + \"Object.metaClass.makeEdge = edge;\";\n        String payload = \"{\\\"script\\\":\\\"\" + script + \"\\\"}\";\n        description( formatGroovy( script ) );\n        gen.get().expectedStatus( Status.OK.getStatusCode() ).payload(\n                JSONPrettifier.parse( payload ) );\n        String response = gen.get().post( ENDPOINT ).entity();\n        for (int i = 0; i<1000;i++) {\n            String uri = \"uri\"+i;\n            payload = \"{\\\"script\\\":\\\"n = Object.metaClass.makeNode('\"+uri+\"',[:]\\\"}\";\n            gen.get().expectedStatus( Status.OK.getStatusCode() ).payload(\n                    JSONPrettifier.parse( payload ) );\n            response = gen.get().post( ENDPOINT ).entity();\n            assertTrue( response.contains( uri ) );\n        }\n        for (int i = 0; i<999;i++) {\n            String uri = \"uri\";\n            payload = \"{\\\"script\\\":\\\"n = Object.metaClass.makeEdge('knows','\"+uri+i+\"','\"+uri+(i+1)+\"'[:]\\\"}\";\n            gen.get().expectedStatus( Status.OK.getStatusCode() ).payload(\n                    JSONPrettifier.parse( payload ) );\n            response = gen.get().post( ENDPOINT ).entity();\n            assertTrue( response.contains( uri ) );\n        }\n    }","commit_id":"1f654542e0a47b1751c5f71b9f299ebb1fc88898","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * This example demonstrates basic\n     * collaborative filtering - ordering a traversal after occurence counts and\n     * substracting objects that are not interesting in the final result.\n     * \n     * Here, we are finding Friends-of-Friends that are not Joes friends already.\n     * The same can be applied to graphs of users that +LIKE+ things and others.\n     */\n    @Documented\n    @Test\n    @Graph( value = { \"Joe knows Bill\", \"Joe knows Sara\", \"Sara knows Bill\", \"Sara knows Ian\", \"Bill knows Derrick\",\n            \"Bill knows Ian\", \"Sara knows Jill\" }, autoIndexNodes = true )\n    public void collaborative_filtering() throws UnsupportedEncodingException\n    {\n        String script = \"x=[];fof=[:];\" +\n        \t\t\"g.v(\" + data.get().get( \"Joe\" ).getId()\n                        + \").out('knows').aggregate(x).out('knows').except(x).groupCount(fof)>>-1;fof.sort{a,b -> b.value <=> a.value}\";\n        gen().expectedStatus( Status.OK.getStatusCode() ).description(\n                formatGroovy( script ) );\n        String response = gen().payload(\n                \"script=\" + URLEncoder.encode( script, \"UTF-8\" ) ).payloadType(\n                MediaType.APPLICATION_FORM_URLENCODED_TYPE ).post( ENDPOINT ).entity();\n        assertFalse( response.contains( \"v[\"+ data.get().get( \"Bill\").getId() ) );\n        assertFalse( response.contains( \"v[\"+ data.get().get( \"Sara\").getId() ) );\n        assertTrue( response.contains( \"v[\"+ data.get().get( \"Ian\").getId() ) );\n        assertTrue( response.contains( \"v[\"+ data.get().get( \"Jill\").getId() ) );\n        assertTrue( response.contains( \"v[\"+ data.get().get( \"Derrick\").getId() ) );\n    }","id":80849,"modified_method":"/**\n     * This example demonstrates basic\n     * collaborative filtering - ordering a traversal after occurence counts and\n     * substracting objects that are not interesting in the final result.\n     * \n     * Here, we are finding Friends-of-Friends that are not Joes friends already.\n     * The same can be applied to graphs of users that +LIKE+ things and others.\n     */\n    @Documented\n    @Test\n    @Graph( value = { \"Joe knows Bill\", \"Joe knows Sara\", \"Sara knows Bill\", \"Sara knows Ian\", \"Bill knows Derrick\",\n            \"Bill knows Ian\", \"Sara knows Jill\" }, autoIndexNodes = true )\n    public void collaborative_filtering() throws UnsupportedEncodingException\n    {\n        String script = \"x=[];fof=[:];\" +\n        \t\t\"g.v(\" + data.get().get( \"Joe\" ).getId()\n                        + \").out('knows').aggregate(x).out('knows').except(x).groupCount(fof)>>-1;fof.sort{a,b -> b.value <=> a.value}\";\n        String payload = \"{\\\"script\\\":\\\"\" + script + \"\\\"}\";\n        gen().expectedStatus( Status.OK.getStatusCode() ).description(\n                formatGroovy( script ) );\n        String response = gen().payload(\n                JSONPrettifier.parse( payload ) ).post( ENDPOINT ).entity();\n        assertFalse( response.contains( \"v[\"+ data.get().get( \"Bill\").getId() ) );\n        assertFalse( response.contains( \"v[\"+ data.get().get( \"Sara\").getId() ) );\n        assertTrue( response.contains( \"v[\"+ data.get().get( \"Ian\").getId() ) );\n        assertTrue( response.contains( \"v[\"+ data.get().get( \"Jill\").getId() ) );\n        assertTrue( response.contains( \"v[\"+ data.get().get( \"Derrick\").getId() ) );\n    }","commit_id":"8c7417343252622a4e73c3633c1bba5047c05e5d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Send a Query.\n     * \n     * A simple query returning all nodes connected to node 1,\n     * returning the node and the name property, if it exists,\n     * otherwise `null`:\n     */\n    @Test\n    @Documented\n    @Graph( value = { \"I know you\", \"I know him\" } )\n    public void testPropertyColumn() throws UnsupportedEncodingException\n    {\n        String response = gen.get()\n        .expectedStatus( Status.OK.getStatusCode() )\n        .payload( \"{\\\"query\\\": \\\"start x  = (\"+data.get().get( \"I\" ).getId() +\") match (x) --> (n) return n.name?, n.age?\\\"}\")\n        .post( ENDPOINT )\n        .entity();\n        System.out.println(response);\n        assertTrue(response.contains( \"you\" ));\n        assertTrue(response.contains( \"him\" ));\n        assertTrue(!response.contains( \"\\\"x\\\"\" ));\n    }","id":80850,"modified_method":"/**\n     * A simple query returning all nodes connected to node 1,\n     * returning the node and the name property, if it exists,\n     * otherwise `null`:\n     */\n    @Test\n    @Documented\n    @Title(\"Send a Query\")\n    @Graph( value = { \"I know you\", \"I know him\" } )\n    public void testPropertyColumn() throws UnsupportedEncodingException\n    {\n        String script = \"start x  = (\"+data.get().get( \"I\" ).getId() +\") match (x) --> (n) return n.name?, n.age?\";\n        String response = gen.get()\n        .expectedStatus( Status.OK.getStatusCode() )\n        .payload( \"{\\\"query\\\": \\\"\"+script +\"\\\"}\")\n        .description( formatCypher( script ) )\n        .post( ENDPOINT )\n        .entity();\n        assertTrue(response.contains( \"you\" ));\n        assertTrue(response.contains( \"him\" ));\n        assertTrue(!response.contains( \"\\\"x\\\"\" ));\n    }","commit_id":"7c00218ee4fe14bfa7b3218553cd223392daf7ff","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void startServer() {\n        server = new WrappingNeoServerBootstrapper(\n                graphdb );\n        server.start();\n    }","id":80851,"modified_method":"@Before\n    public void startServer() {\n        server = new WrappingNeoServerBootstrapper(\n                graphdb );\n        server.start();\n        gen.get().setGraph( graphdb );\n    }","commit_id":"7c00218ee4fe14bfa7b3218553cd223392daf7ff","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected static void navigate(Project project, Editor editor, int offset, @Nullable VirtualFile vfile) {\n    if (ApplicationManager.getApplication().isHeadlessEnvironment()) {\n      editor.getCaretModel().moveToOffset(offset);\n    }\n    else if (vfile != null) {\n      new OpenFileDescriptor(project, vfile, offset).navigate(true); // properly contributes to editing history\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    }\n  }","id":80852,"modified_method":"@Nullable\n  protected static Editor navigate(Project project, int offset, @Nullable VirtualFile vfile) {\n    if (vfile == null) {\n      return null;\n    }\n    new OpenFileDescriptor(project, vfile, offset).navigate(true); // properly contributes to editing history\n    FileEditor fileEditor = FileEditorManager.getInstance(project).getSelectedEditor(vfile);\n    if (fileEditor instanceof TextEditor) {\n      final Editor editor = ((TextEditor)fileEditor).getEditor();\n      editor.getCaretModel().moveToOffset(offset);\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      return editor;\n    }\n    return null;\n  }","commit_id":"6c4af3c1e286892be4554f5dad9518d6bb55475f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    PsiElement anchor = findAnchor(psiElement);\n    if (anchor == null) {\n      return;\n    }\n\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    template.addTextSegment(\"class \");\n    template.addVariable(DartPresentableUtil.getExpression(myClassName), false);\n    template.addTextSegment(\"{\\n\");\n    template.addEndVariable();\n    template.addTextSegment(\"\\n}\\n\");\n\n    navigate(project, editor, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n\n    templateManager.startTemplate(editor, template);\n  }","id":80853,"modified_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    PsiElement anchor = findAnchor(psiElement);\n    if (anchor == null) {\n      return;\n    }\n\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    template.addTextSegment(\"class \");\n    template.addVariable(DartPresentableUtil.getExpression(myClassName), false);\n    template.addTextSegment(\"{\\n\");\n    template.addEndVariable();\n    template.addTextSegment(\"\\n}\\n\");\n\n    final Editor openedEditor = navigate(project, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","commit_id":"6c4af3c1e286892be4554f5dad9518d6bb55475f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    if (!buildTemplate(template, psiElement)) {\n      return;\n    }\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    navigate(project, editor, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n\n    templateManager.startTemplate(editor, template);\n  }","id":80854,"modified_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    if (!buildTemplate(template, psiElement)) {\n      return;\n    }\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    final Editor openedEditor = navigate(project, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","commit_id":"6c4af3c1e286892be4554f5dad9518d6bb55475f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    buildTemplate(template, psiElement);\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    navigate(project, editor, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n\n    templateManager.startTemplate(editor, template);\n  }","id":80855,"modified_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    buildTemplate(template, psiElement);\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    final Editor openedEditor = navigate(project, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","commit_id":"6c4af3c1e286892be4554f5dad9518d6bb55475f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"void doTest(String message, String... additionalFiles) throws IOException {\n    final String fullTestName = getTestName(true);\n    final int dollarIndex = fullTestName.lastIndexOf('$');\n    final String fixSimpleClassName = dollarIndex > 0 ? fullTestName.substring(dollarIndex + 1) : null;\n    final String testName = dollarIndex > 0 ? fullTestName.substring(0, dollarIndex) : fullTestName;\n\n    String[] files = ArrayUtil.append(additionalFiles, testName + \".dart\");\n    files = ArrayUtil.reverseArray(files);\n\n    myFixture.configureByFiles(files);\n\n    final Annotation annotation = doHighlightingAndFindIntention(message);\n    assertNotNull(\"Can't find intention for message: \" + message, annotation);\n\n    final List<Annotation.QuickFixInfo> quickFixes = annotation.getQuickFixes();\n    assertNotNull(\"Can't find fixes\", quickFixes);\n    assertFalse(quickFixes.isEmpty());\n\n    final Annotation.QuickFixInfo quickFixInfo = ContainerUtil.find(quickFixes, new Condition<Annotation.QuickFixInfo>() {\n      @Override\n      public boolean value(Annotation.QuickFixInfo info) {\n        return fixSimpleClassName == null || info.quickFix.getClass().getSimpleName().equals(fixSimpleClassName);\n      }\n    });\n    assertNotNull(\"Can't find fixes\", quickFixInfo);\n    assertTrue(\"Fix not available\", quickFixInfo.quickFix.isAvailable(myFixture.getProject(), myFixture.getEditor(), myFixture.getFile()));\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        quickFixInfo.quickFix.invoke(myFixture.getProject(), myFixture.getEditor(), myFixture.getFile());\n      }\n    });\n    myFixture.checkResultByFile(fullTestName + \".after.dart\");\n  }","id":80856,"modified_method":"void doTest(String message, String... additionalFiles) throws IOException {\n    doTestWithoutCheck(message, additionalFiles);\n    myFixture.checkResultByFile(getTestName(true) + \".after.dart\");\n  }","commit_id":"6c4af3c1e286892be4554f5dad9518d6bb55475f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Captures a screenshot of the browser window.\n     * \n     * @param description the description of the failing test\n     */\n    private void takeScreenshot(Description description)\n    {\n        if (!(driver instanceof TakesScreenshot)) {\n            LOGGER.warn(\"The WebDriver that is currently used doesn't support taking screenshots.\");\n            return;\n        }\n\n        String testName = getTestName(description);\n        try {\n            File sourceFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);\n            File screenshotFile;\n            if (SCREENSHOT_DIR != null) {\n                File screenshotDir = new File(SCREENSHOT_DIR);\n                screenshotDir.mkdirs();\n                screenshotFile = new File(screenshotDir, testName + \".png\");\n            } else {\n                screenshotFile = new File(new File(System.getProperty(\"java.io.tmpdir\")), testName + \".png\");\n            }\n            FileUtils.copyFile(sourceFile, screenshotFile);\n            LOGGER.info(\"Screenshot for failing test [{}] saved at [{}].\", testName, screenshotFile.getAbsolutePath());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to take screenshot for failing test [{}].\", testName, e);\n        }\n    }","id":80857,"modified_method":"/**\n     * Captures a screenshot of the browser window.\n     * \n     * @param description the description of the failing test\n     */\n    private void takeScreenshot(Description description)\n    {\n        takeScreenshot(getTestName(description));\n    }","commit_id":"9276fe22a32039d0fd78cb17107665d3536e0074","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void visit(final int version,\n                    final int access,\n                    final String name,\n                    final String signature,\n                    final String superName,\n                    final String[] interfaces) {\n    super.visit(version, access, name, signature, superName, interfaces);\n    myClassName = name;\n    mySuperName = superName;\n  }","id":80858,"modified_method":"public void visit(final int version,\n                    final int access,\n                    final String name,\n                    final String signature,\n                    final String superName,\n                    final String[] interfaces) {\n    super.visit(version, access, name, signature, superName, interfaces);\n    myClassName = name;\n  }","commit_id":"6a8fa26b865037257e879120f80bbe3734b1bd00","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodVisitor visitMethod(\n    final int access,\n    final String name,\n    final String desc,\n    final String signature,\n    final String[] exceptions) {\n    final Type[] args = Type.getArgumentTypes(desc);\n    final Type returnType = Type.getReturnType(desc);\n    final int startParameter = getStartParameterIndex(name);\n    MethodVisitor v = cv.visitMethod(access,\n                                     name,\n                                     desc,\n                                     signature,\n                                     exceptions);\n    return new MethodAdapter(v) {\n\n      private final ArrayList myNotNullParams = new ArrayList();\n      private int mySyntheticCount = 0;\n      private boolean myIsNotNull = false;\n      //private boolean myIsUnmodifiable = false;\n      public Label myThrowLabel;\n      //public Label myWrapLabel;\n      private Label myStartGeneratedCodeLabel;\n\n      public AnnotationVisitor visitParameterAnnotation(\n        final int parameter,\n        final String anno,\n        final boolean visible) {\n        AnnotationVisitor av;\n        av = mv.visitParameterAnnotation(parameter,\n                                         anno,\n                                         visible);\n        if (isReferenceType(args[parameter]) && anno.equals(NOT_NULL_ANNO)) {\n          myNotNullParams.add(new Integer(parameter));\n        }\n        else if (anno.equals(\"Ljava/lang/Synthetic;\")) {\n          // See asm r1278 for what we do this,\n          // http://forge.objectweb.org/tracker/index.php?func=detail&aid=307392&group_id=23&atid=100023\n          mySyntheticCount++;\n        }\n        return av;\n      }\n\n      public AnnotationVisitor visitAnnotation(String anno,\n                                               boolean isRuntime) {\n        final AnnotationVisitor av = mv.visitAnnotation(anno, isRuntime);\n        if (isReferenceType(returnType) &&\n            anno.equals(NOT_NULL_ANNO)) {\n          myIsNotNull = true;\n        }\n\n        return av;\n      }\n\n      public void visitCode() {\n        if (myNotNullParams.size() > 0) {\n          myStartGeneratedCodeLabel = new Label();\n          mv.visitLabel(myStartGeneratedCodeLabel);\n        }\n        for (int p = 0; p < myNotNullParams.size(); ++p) {\n          int var = ((access & ACC_STATIC) == 0) ? 1 : 0;\n          int param = ((Integer)myNotNullParams.get(p)).intValue();\n          for (int i = 0; i < startParameter + param; ++i) {\n            var += args[i].getSize();\n          }\n          mv.visitVarInsn(ALOAD, var);\n\n          Label end = new Label();\n          mv.visitJumpInsn(IFNONNULL, end);\n\n          generateThrow(IAE_CLASS_NAME,\n                        \"Argument \" + (param - mySyntheticCount) + \" for @NotNull parameter of \" + myClassName + \".\" + name + \" must not be null\", end);\n        }\n      }\n\n      public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end,\n                                     final int index) {\n        final boolean isStatic = (access & ACC_STATIC) != 0;\n        final boolean isParameter = isStatic ? index < args.length : index <= args.length;\n        mv.visitLocalVariable(name, desc, signature, (isParameter && myStartGeneratedCodeLabel != null) ? myStartGeneratedCodeLabel : start, end, index);\n      }\n\n      public void visitInsn(int opcode) {\n        if (opcode == ARETURN) {\n          if (myIsNotNull) {\n            mv.visitInsn(DUP);\n            /*generateConditionalThrow(\"@NotNull method \" + myClassName + \".\" + name + \" must not return null\",\n              \"java/lang/IllegalStateException\");*/\n            if (myThrowLabel == null) {\n              Label skipLabel = new Label();\n              mv.visitJumpInsn(IFNONNULL, skipLabel);\n              myThrowLabel = new Label();\n              mv.visitLabel(myThrowLabel);\n              generateThrow(ISE_CLASS_NAME, \"@NotNull method \" + myClassName + \".\" + name + \" must not return null\",\n                            skipLabel);\n            }\n            else {\n              mv.visitJumpInsn(IFNULL, myThrowLabel);\n            }\n          }\n        }\n\n        mv.visitInsn(opcode);\n      }\n\n      private void generateThrow(final String exceptionClass, final String descr, final Label end) {\n        String exceptionParamClass = \"(Ljava/lang/String;)V\";\n        mv.visitTypeInsn(NEW, exceptionClass);\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(descr);\n        mv.visitMethodInsn(INVOKESPECIAL,\n                           exceptionClass,\n                           CONSTRUCTOR_NAME,\n                           exceptionParamClass);\n        mv.visitInsn(ATHROW);\n        mv.visitLabel(end);\n\n        myIsModification = true;\n      }\n\n      public void visitMaxs(final int maxStack, final int maxLocals) {\n        try {\n          super.visitMaxs(maxStack, maxLocals);\n        }\n        catch (ArrayIndexOutOfBoundsException e) {\n          throw new ArrayIndexOutOfBoundsException(\"maxs processing failed for method \" + name + \": \" + e.getMessage());\n        }\n      }\n    };\n  }","id":80859,"modified_method":"public MethodVisitor visitMethod(\n    final int access,\n    final String name,\n    final String desc,\n    final String signature,\n    final String[] exceptions) {\n    final Type[] args = Type.getArgumentTypes(desc);\n    final Type returnType = Type.getReturnType(desc);\n    MethodVisitor v = cv.visitMethod(access,\n                                     name,\n                                     desc,\n                                     signature,\n                                     exceptions);\n    return new MethodAdapter(v) {\n\n      private final ArrayList myNotNullParams = new ArrayList();\n      private int mySyntheticCount = 0;\n      private boolean myIsNotNull = false;\n      //private boolean myIsUnmodifiable = false;\n      public Label myThrowLabel;\n      //public Label myWrapLabel;\n      private Label myStartGeneratedCodeLabel;\n\n      public AnnotationVisitor visitParameterAnnotation(\n        final int parameter,\n        final String anno,\n        final boolean visible) {\n        AnnotationVisitor av;\n        av = mv.visitParameterAnnotation(parameter,\n                                         anno,\n                                         visible);\n        if (isReferenceType(args[parameter]) && anno.equals(NOT_NULL_ANNO)) {\n          myNotNullParams.add(new Integer(parameter));\n        }\n        else if (anno.equals(\"Ljava/lang/Synthetic;\")) {\n          // See asm r1278 for what we do this,\n          // http://forge.objectweb.org/tracker/index.php?func=detail&aid=307392&group_id=23&atid=100023\n          mySyntheticCount++;\n        }\n        return av;\n      }\n\n      public AnnotationVisitor visitAnnotation(String anno,\n                                               boolean isRuntime) {\n        final AnnotationVisitor av = mv.visitAnnotation(anno, isRuntime);\n        if (isReferenceType(returnType) &&\n            anno.equals(NOT_NULL_ANNO)) {\n          myIsNotNull = true;\n        }\n\n        return av;\n      }\n\n      public void visitCode() {\n        if (myNotNullParams.size() > 0) {\n          myStartGeneratedCodeLabel = new Label();\n          mv.visitLabel(myStartGeneratedCodeLabel);\n        }\n        for (int p = 0; p < myNotNullParams.size(); ++p) {\n          int var = ((access & ACC_STATIC) == 0) ? 1 : 0;\n          int param = ((Integer)myNotNullParams.get(p)).intValue();\n          for (int i = 0; i < param; ++i) {\n            var += args[i].getSize();\n          }\n          mv.visitVarInsn(ALOAD, var);\n\n          Label end = new Label();\n          mv.visitJumpInsn(IFNONNULL, end);\n\n          generateThrow(IAE_CLASS_NAME,\n                        \"Argument \" + (param - mySyntheticCount) + \" for @NotNull parameter of \" + myClassName + \".\" + name + \" must not be null\", end);\n        }\n      }\n\n      public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end,\n                                     final int index) {\n        final boolean isStatic = (access & ACC_STATIC) != 0;\n        final boolean isParameter = isStatic ? index < args.length : index <= args.length;\n        mv.visitLocalVariable(name, desc, signature, (isParameter && myStartGeneratedCodeLabel != null) ? myStartGeneratedCodeLabel : start, end, index);\n      }\n\n      public void visitInsn(int opcode) {\n        if (opcode == ARETURN) {\n          if (myIsNotNull) {\n            mv.visitInsn(DUP);\n            /*generateConditionalThrow(\"@NotNull method \" + myClassName + \".\" + name + \" must not return null\",\n              \"java/lang/IllegalStateException\");*/\n            if (myThrowLabel == null) {\n              Label skipLabel = new Label();\n              mv.visitJumpInsn(IFNONNULL, skipLabel);\n              myThrowLabel = new Label();\n              mv.visitLabel(myThrowLabel);\n              generateThrow(ISE_CLASS_NAME, \"@NotNull method \" + myClassName + \".\" + name + \" must not return null\",\n                            skipLabel);\n            }\n            else {\n              mv.visitJumpInsn(IFNULL, myThrowLabel);\n            }\n          }\n        }\n\n        mv.visitInsn(opcode);\n      }\n\n      private void generateThrow(final String exceptionClass, final String descr, final Label end) {\n        String exceptionParamClass = \"(Ljava/lang/String;)V\";\n        mv.visitTypeInsn(NEW, exceptionClass);\n        mv.visitInsn(DUP);\n        mv.visitLdcInsn(descr);\n        mv.visitMethodInsn(INVOKESPECIAL,\n                           exceptionClass,\n                           CONSTRUCTOR_NAME,\n                           exceptionParamClass);\n        mv.visitInsn(ATHROW);\n        mv.visitLabel(end);\n\n        myIsModification = true;\n      }\n\n      public void visitMaxs(final int maxStack, final int maxLocals) {\n        try {\n          super.visitMaxs(maxStack, maxLocals);\n        }\n        catch (ArrayIndexOutOfBoundsException e) {\n          throw new ArrayIndexOutOfBoundsException(\"maxs processing failed for method \" + name + \": \" + e.getMessage());\n        }\n      }\n    };\n  }","commit_id":"6a8fa26b865037257e879120f80bbe3734b1bd00","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Class prepareTest() throws IOException {\n    String base = JavaTestUtil.getJavaTestDataPath() + \"/compiler/notNullVerification/\";\n    String path = base + getTestName(false);\n    String javaPath = path + \".java\";\n    String classPath = path + \".class\";\n    try {\n      com.sun.tools.javac.Main.compile(new String[] { \"-classpath\", base+\"annotations.jar\", javaPath } );\n      FileInputStream stream = new FileInputStream(classPath);\n      byte[] content = FileUtil.adaptiveLoadBytes(stream);\n      stream.close();\n\n      ClassReader reader = new ClassReader(content, 0, content.length);\n      ClassWriter writer = new PsiClassWriter(myFixture.getProject(), false);\n      final NotNullVerifyingInstrumenter instrumenter = new NotNullVerifyingInstrumenter(writer);\n      reader.accept(instrumenter, 0);\n      assertTrue(instrumenter.isModification());\n\n      MyClassLoader classLoader = new MyClassLoader(getClass().getClassLoader());\n      byte[] instrumented = writer.toByteArray();\n      return classLoader.doDefineClass(getTestName(false), instrumented);\n    }\n    finally {\n      FileUtil.delete(new File(classPath));\n    }\n  }","id":80860,"modified_method":"private Class prepareTest() throws IOException {\n    String base = JavaTestUtil.getJavaTestDataPath() + \"/compiler/notNullVerification/\";\n    final String baseClassName = getTestName(false);\n    String path = base + baseClassName;\n    String javaPath = path + \".java\";\n    File classesDir = FileUtil.createTempDirectory(baseClassName, \"output\");\n\n    try {\n      com.sun.tools.javac.Main.compile(new String[] { \"-classpath\", base+\"annotations.jar\", \"-d\", classesDir.getAbsolutePath(), javaPath } );\n\n      Class mainClass = null;\n      final File[] files = classesDir.listFiles();\n      boolean modified = false;\n      MyClassLoader classLoader = new MyClassLoader(getClass().getClassLoader());\n      for (File file : files) {\n        final String fileName = file.getName();\n        FileInputStream stream = new FileInputStream(file);\n        byte[] content;\n        try {\n          content = FileUtil.adaptiveLoadBytes(stream);\n        }\n        finally {\n          stream.close();\n        }\n\n        ClassReader reader = new ClassReader(content, 0, content.length);\n        ClassWriter writer = new PsiClassWriter(myFixture.getProject(), false);\n        final NotNullVerifyingInstrumenter instrumenter = new NotNullVerifyingInstrumenter(writer);\n        reader.accept(instrumenter, 0);\n        modified |= instrumenter.isModification();\n\n        byte[] instrumented = writer.toByteArray();\n        final String className = FileUtil.getNameWithoutExtension(fileName);\n        final Class aClass = classLoader.doDefineClass(className, instrumented);\n        if (className.equals(baseClassName)) {\n          mainClass = aClass;\n        }\n      }\n      assertTrue(modified);\n      assertNotNull(\"Class \" + baseClassName + \" not found!\", mainClass);\n      return mainClass;\n    }\n    finally {\n      FileUtil.delete(classesDir);\n    }\n  }","commit_id":"6a8fa26b865037257e879120f80bbe3734b1bd00","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processIntention(@NotNull PsiElement element)\n    throws IncorrectOperationException {\n    final PsiIfStatement statement = (PsiIfStatement)element.getParent();\n    if (SimplifyIfElsePredicate.isSimplifiableAssignment(statement)) {\n      replaceSimplifiableAssignment(statement);\n    }\n    else if (SimplifyIfElsePredicate.isSimplifiableReturn(statement)) {\n      replaceSimplifiableReturn(statement);\n    }\n    else if (SimplifyIfElsePredicate.isSimplifiableImplicitReturn(\n      statement)) {\n      replaceSimplifiableImplicitReturn(statement);\n    }\n    else if (SimplifyIfElsePredicate.isSimplifiableAssignmentNegated(\n      statement)) {\n      replaceSimplifiableAssignmentNegated(statement);\n    }\n    else if (SimplifyIfElsePredicate.isSimplifiableReturnNegated(\n      statement)) {\n      replaceSimplifiableReturnNegated(statement);\n    }\n    else if (SimplifyIfElsePredicate.isSimplifiableImplicitReturnNegated(\n      statement)) {\n      replaceSimplifiableImplicitReturnNegated(statement);\n    }\n    else if (SimplifyIfElsePredicate.isSimplifiableImplicitAssignment(\n      statement)) {\n      replaceSimplifiableImplicitAssignment(statement);\n    }\n    else if (\n      SimplifyIfElsePredicate.isSimplifiableImplicitAssignmentNegated(\n        statement)) {\n      replaceSimplifiableImplicitAssignmentNegated(statement);\n    }\n  }","id":80861,"modified_method":"public void processIntention(@NotNull PsiElement element) {\n    TrivialIfInspection.simplify((PsiIfStatement)element.getParent());\n  }","commit_id":"62ff98332c45627dbd1753feee75e17299a1ae61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiElementPredicate getElementPredicate() {\n    return new SimplifyIfElsePredicate();\n  }","id":80862,"modified_method":"@NotNull\n  public PsiElementPredicate getElementPredicate() {\n    return new PsiElementPredicate() {\n      public boolean satisfiedBy(PsiElement element) {\n        if (!(element instanceof PsiJavaToken)) {\n          return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken)element;\n        final PsiElement parent = token.getParent();\n        if (!(parent instanceof PsiIfStatement)) {\n          return false;\n        }\n        return TrivialIfInspection.isTrivial((PsiIfStatement)parent);\n      }\n    };\n  }","commit_id":"62ff98332c45627dbd1753feee75e17299a1ae61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testComments() {\n    final String testName = getTestName(false);\n    myFixture.configureByFile(getRelativePath() + \"/\" + testName + \".java\");\n    final String message = InspectionGadgetsBundle.message(\"constant.conditional.expression.simplify.quickfix\");\n    final List<IntentionAction> actions =\n      myFixture.filterAvailableIntentions(message);\n    assertFalse(\"No actions available\", actions.isEmpty());\n    for (IntentionAction action : actions) {\n      if (action.getText().equals(message)) {\n        myFixture.launchAction(action);\n        myFixture.checkResultByFile(getRelativePath() + \"/\" + testName + \".after.java\");\n        break;\n      }\n    }\n  }","id":80863,"modified_method":"public void testComments() {\n    doTestByName(getTestName(false));\n  }","commit_id":"62ff98332c45627dbd1753feee75e17299a1ae61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitIfStatement(@NotNull PsiIfStatement ifStatement) {\n      super.visitIfStatement(ifStatement);\n      final PsiExpression condition = ifStatement.getCondition();\n      if (condition == null) {\n        return;\n      }\n      if (PsiUtilCore.hasErrorElementChild(ifStatement)) {\n        return;\n      }\n      if (isSimplifiableAssignment(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableReturn(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableImplicitReturn(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableAssignmentNegated(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableReturnNegated(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableImplicitReturnNegated(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableImplicitAssignment(ifStatement)) {\n        registerStatementError(ifStatement);\n        return;\n      }\n      if (isSimplifiableImplicitAssignmentNegated(ifStatement)) {\n        registerStatementError(ifStatement);\n      }\n    }","id":80864,"modified_method":"@Override\n    public void visitIfStatement(@NotNull PsiIfStatement ifStatement) {\n      super.visitIfStatement(ifStatement);\n      final PsiExpression condition = ifStatement.getCondition();\n      if (condition == null) {\n        return;\n      }\n      if (isTrivial(ifStatement)) {\n        registerStatementError(ifStatement);\n      }\n    }","commit_id":"62ff98332c45627dbd1753feee75e17299a1ae61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doFix(Project project, ProblemDescriptor descriptor)\n      throws IncorrectOperationException {\n      final PsiElement ifKeywordElement = descriptor.getPsiElement();\n      final PsiIfStatement statement = (PsiIfStatement)ifKeywordElement.getParent();\n      if (isSimplifiableAssignment(statement)) {\n        replaceSimplifiableAssignment(statement);\n      }\n      else if (isSimplifiableReturn(statement)) {\n        repaceSimplifiableReturn(statement);\n      }\n      else if (isSimplifiableImplicitReturn(statement)) {\n        replaceSimplifiableImplicitReturn(statement);\n      }\n      else if (isSimplifiableAssignmentNegated(statement)) {\n        replaceSimplifiableAssignmentNegated(statement);\n      }\n      else if (isSimplifiableReturnNegated(statement)) {\n        repaceSimplifiableReturnNegated(statement);\n      }\n      else if (isSimplifiableImplicitReturnNegated(statement)) {\n        replaceSimplifiableImplicitReturnNegated(statement);\n      }\n      else if (isSimplifiableImplicitAssignment(statement)) {\n        replaceSimplifiableImplicitAssignment(statement);\n      }\n      else if (isSimplifiableImplicitAssignmentNegated(statement)) {\n        replaceSimplifiableImplicitAssignmentNegated(statement);\n      }\n    }","id":80865,"modified_method":"@Override\n    public void doFix(Project project, ProblemDescriptor descriptor) {\n      final PsiElement ifKeywordElement = descriptor.getPsiElement();\n      final PsiIfStatement statement = (PsiIfStatement)ifKeywordElement.getParent();\n      simplify(statement);\n    }","commit_id":"62ff98332c45627dbd1753feee75e17299a1ae61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setupProject(VirtualFile rootDir) {\n    final ModifiableRootModel rootModel = ModuleRootManager.getInstance(myModule).getModifiableModel();\n    final ContentEntry contentEntry = rootModel.addContentEntry(rootDir);\n    final VirtualFile[] children = rootDir.getChildren();\n    for (VirtualFile child : children) {\n      if (child.getName().startsWith(\"src\")) {\n        contentEntry.addSourceFolder(child, false);\n      }\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        rootModel.commit();\n      }\n    });\n  }","id":80866,"modified_method":"@Override\n  protected void prepareProject(VirtualFile rootDir) {\n    final ModifiableRootModel rootModel = ModuleRootManager.getInstance(myModule).getModifiableModel();\n    final ContentEntry contentEntry = rootModel.addContentEntry(rootDir);\n    final VirtualFile[] children = rootDir.getChildren();\n    for (VirtualFile child : children) {\n      if (child.getName().startsWith(\"src\")) {\n        contentEntry.addSourceFolder(child, false);\n      }\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        rootModel.commit();\n      }\n    });\n  }","commit_id":"2a6452e0fd3c5bfe739b6bea10c6b2e527b47e96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setupProject(VirtualFile rootDir) {\n    final ModifiableRootModel rootModel = ModuleRootManager.getInstance(myModule).getModifiableModel();\n    final ContentEntry contentEntry = rootModel.addContentEntry(rootDir);\n    final VirtualFile[] children = rootDir.getChildren();\n    for (int i = 0; i < children.length; i++) {\n      VirtualFile child = children[i];\n      if (child.getName().startsWith(\"src\")) {\n        contentEntry.addSourceFolder(child, false);\n      }\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        rootModel.commit();\n      }\n    });\n  }","id":80867,"modified_method":"@Override\n  protected void prepareProject(VirtualFile rootDir) {\n    final ModifiableRootModel rootModel = ModuleRootManager.getInstance(myModule).getModifiableModel();\n    final ContentEntry contentEntry = rootModel.addContentEntry(rootDir);\n    final VirtualFile[] children = rootDir.getChildren();\n    for (int i = 0; i < children.length; i++) {\n      VirtualFile child = children[i];\n      if (child.getName().startsWith(\"src\")) {\n        contentEntry.addSourceFolder(child, false);\n      }\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        rootModel.commit();\n      }\n    });\n  }","commit_id":"2a6452e0fd3c5bfe739b6bea10c6b2e527b47e96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doTest(PerformAction performAction, final boolean lowercaseFirstLetter) throws Exception {\n    String testName = getTestName(lowercaseFirstLetter);\n    String root = getTestDataPath() + getTestRoot() + testName;\n\n    String rootBefore = root + \"/before\";\n    VirtualFile rootDir = PsiTestUtil.createTestProjectStructure(myProject, myModule, rootBefore, myFilesToDelete, false);\n    setupProject(rootDir);\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    String rootAfter = root + \"/after\";\n    VirtualFile rootDir2 = LocalFileSystem.getInstance().findFileByPath(rootAfter.replace(File.separatorChar, '/'));\n\n    performAction.performAction(rootDir, rootDir2);\n    myProject.getComponent(PostprocessReformattingAspect.class).doPostponedFormatting();\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    if (myDoCompare) {\n      PlatformTestUtil.assertDirectoriesEqual(rootDir2, rootDir, PlatformTestUtil.CVS_FILE_FILTER);\n    }\n  }","id":80868,"modified_method":"protected void doTest(final PerformAction performAction, final boolean lowercaseFirstLetter) throws Exception {\n    doTest(performAction, getTestName(lowercaseFirstLetter));\n  }","commit_id":"2a6452e0fd3c5bfe739b6bea10c6b2e527b47e96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doTest(PerformAction performAction) throws Exception {\n    doTest(performAction, true);\n  }","id":80869,"modified_method":"protected void doTest(final PerformAction performAction) throws Exception {\n    doTest(performAction, getTestName(true));\n  }","commit_id":"2a6452e0fd3c5bfe739b6bea10c6b2e527b47e96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setupProject(VirtualFile rootDir) {\n    LanguageLevelProjectExtension.getInstance(myJavaFacade.getProject()).setLanguageLevel(LanguageLevel.JDK_1_5);\n    super.setupProject(rootDir);\n  }","id":80870,"modified_method":"@Override\n  protected void prepareProject(VirtualFile rootDir) {\n    LanguageLevelProjectExtension.getInstance(myJavaFacade.getProject()).setLanguageLevel(LanguageLevel.JDK_1_5);\n    super.prepareProject(rootDir);\n  }","commit_id":"2a6452e0fd3c5bfe739b6bea10c6b2e527b47e96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void doTest(Location loc) throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class));\n        app.start(ImmutableList.of(loc));\n        \n        EntityTestUtils.assertAttributeEqualsEventually(entity, MongoDbServer.SERVICE_UP, true);\n\n        String id = insert(entity, \"hello\", \"world!\");\n        DBObject docOut = getById(entity, id);\n        assertEquals(docOut.get(\"hello\"), \"world!\");\n    }","id":80871,"modified_method":"@Override\n    protected void doTest(Location loc) throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class)\n                .configure(\"mongodbConfTemplateUrl\", \"classpath:///test-mongodb.conf\"));\n        app.start(ImmutableList.of(loc));\n\n        EntityTestUtils.assertAttributeEqualsEventually(entity, MongoDbServer.SERVICE_UP, true);\n\n        String id = insert(entity, \"hello\", \"world!\");\n        DBObject docOut = getById(entity, id);\n        assertEquals(docOut.get(\"hello\"), \"world!\");\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected String getDataDir() {\n        return getRunDir() + \"/data/\";\n    }","id":80872,"modified_method":"@Override\n    public String getDataDirectory() {\n        return entity.getConfig(MongoDbServer.DATA_DIRECTORY, getRunDir() + \"/data\");\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n        List<String> commands = new LinkedList<String>();\n        Integer port = entity.getAttribute(MongoDbServer.PORT);\n        String args = Joiner.on(\" \").join(ImmutableList.of(\n                \"--config\", getConfFile(),\n                \"--pidfilepath\", getPidFile(),\n                \"--dbpath\", getDataDir(),\n                \"--logpath\", getLogFile(),\n                \"--port\", port,\n                \"--fork\"));\n        String command = String.format(\"%s/bin/mongod %s > out.log 2> err.log < /dev/null\", getExpandedInstallDir(), args);\n        commands.add(command);\n        log.info(command);\n        newScript(LAUNCHING)\n                .updateTaskAndFailOnNonZeroResultCode()\n                .body.append(commands).execute();\n\n    }","id":80873,"modified_method":"@Override\n    public void launch() {\n        List<String> commands = new LinkedList<String>();\n        Integer port = entity.getAttribute(MongoDbServer.PORT);\n        String args = Joiner.on(\" \").join(ImmutableList.of(\n                \"--config\", getConfFile(),\n                \"--pidfilepath\", getPidFile(),\n                \"--logpath\", getLogFile(),\n                \"--dbpath\", getDataDirectory(),\n                \"--port\", port,\n                \"--fork\"));\n        String command = String.format(\"%s/bin/mongod %s > out.log 2> err.log < /dev/null\", getExpandedInstallDir(), args);\n        commands.add(command);\n        log.info(command);\n        newScript(LAUNCHING)\n                .updateTaskAndFailOnNonZeroResultCode()\n                .body.append(commands).execute();\n\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void customize() {\n        Map ports = ImmutableMap.of(\"port\", getServerPort());\n        NetworkUtils.checkPortsValid(ports);\n        String hostname = entity.getAttribute(SoftwareProcess.HOSTNAME);\n        String command = String.format(\"mkdir -p %s/data\", getRunDir());\n        newScript(CUSTOMIZING)\n                .updateTaskAndFailOnNonZeroResultCode()\n                .body.append(command).execute();\n\n        String url = entity.getConfig(MongoDbServer.CONFIG_URL);\n        Reader configFile;\n        if (!Strings.isNullOrEmpty(url))\n            configFile = new InputStreamReader(new ResourceUtils(entity).getResourceFromUrl(url));\n        else\n            configFile = new StringReader(\"\");\n        getMachine().copyTo(configFile, getConfFile());\n    }","id":80874,"modified_method":"@Override\n    public void customize() {\n        Map ports = ImmutableMap.of(\"port\", getServerPort());\n        NetworkUtils.checkPortsValid(ports);\n        String command = String.format(\"mkdir -p %s\", getDataDirectory());\n        newScript(CUSTOMIZING)\n                .updateTaskAndFailOnNonZeroResultCode()\n                .body.append(command).execute();\n\n        String templateUrl = entity.getConfig(MongoDbServer.MONGODB_CONF_TEMPLATE_URL);\n        if (!Strings.isNullOrEmpty(templateUrl)) copyTemplate(templateUrl, getConfFile());\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\")\n    public void testCanReadAndWrite() throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class));\n        app.start(ImmutableList.of(localhostProvisioningLocation));\n\n        String id = insert(entity, \"hello\", \"world!\");\n        DBObject docOut = getById(entity, id);\n        assertEquals(docOut.get(\"hello\"), \"world!\");\n    }","id":80875,"modified_method":"@Test(groups = \"Integration\")\n    public void testCanReadAndWrite() throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class)\n                .configure(\"mongodbConfTemplateUrl\", \"classpath:///test-mongodb.conf\"));\n        app.start(ImmutableList.of(localhostProvisioningLocation));\n\n        String id = insert(entity, \"hello\", \"world!\");\n        DBObject docOut = getById(entity, id);\n        assertEquals(docOut.get(\"hello\"), \"world!\");\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\")\n    public void testCanStartAndStop() throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class));\n        app.start(ImmutableList.of(localhostProvisioningLocation));\n\n        EntityTestUtils.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, true);\n        entity.stop();\n        assertFalse(entity.getAttribute(Startable.SERVICE_UP));\n    }","id":80876,"modified_method":"@Test(groups = \"Integration\")\n    public void testCanStartAndStop() throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class)\n                .configure(\"mongodbConfTemplateUrl\", \"classpath:///test-mongodb.conf\"));\n        app.start(ImmutableList.of(localhostProvisioningLocation));\n\n        EntityTestUtils.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, true);\n        entity.stop();\n        assertFalse(entity.getAttribute(Startable.SERVICE_UP));\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\")\n    public void testPollInsertCountSensor() throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class));\n        app.start(ImmutableList.of(localhostProvisioningLocation));\n        EntityTestUtils.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, true);\n\n        EntityTestUtils.assertAttributeEqualsEventually(entity, MongoDbServer.OPCOUNTERS_INSERTS, new Long(0));\n        insert(entity, \"a\", Boolean.TRUE);\n        insert(entity, \"b\", Boolean.FALSE);\n        EntityTestUtils.assertAttributeEqualsEventually(entity, MongoDbServer.OPCOUNTERS_INSERTS, new Long(2));\n    }","id":80877,"modified_method":"@Test(groups = \"Integration\")\n    public void testPollInsertCountSensor() throws Exception {\n        MongoDbServer entity = app.createAndManageChild(EntitySpecs.spec(MongoDbServer.class)\n                .configure(\"mongodbConfTemplateUrl\", \"classpath:///test-mongodb.conf\"));\n        app.start(ImmutableList.of(localhostProvisioningLocation));\n        EntityTestUtils.assertAttributeEqualsEventually(entity, Startable.SERVICE_UP, true);\n\n        EntityTestUtils.assertAttributeEqualsEventually(entity, MongoDbServer.OPCOUNTERS_INSERTS, new Long(0));\n        insert(entity, \"a\", Boolean.TRUE);\n        insert(entity, \"b\", Boolean.FALSE);\n        EntityTestUtils.assertAttributeEqualsEventually(entity, MongoDbServer.OPCOUNTERS_INSERTS, new Long(2));\n    }","commit_id":"6a93a5f33655c3e7569639d52d3e7c83e9262a23","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void hideGame() {\n\t\tthis.chatPanel.disconnect();\n\t\tthis.players.clear();\n\t\tlogger.log(Level.FINE, \"players clear.\");\n\t\tthis.pnlBattlefield.removeAll();\n\t\tMageFrame.getCombatDialog().hideDialog();\n\t\tthis.setVisible(false);\n\t}","id":80878,"modified_method":"public void hideGame() {\n\t\tthis.chatPanel.disconnect();\n\t\tthis.players.clear();\n\t\tlogger.log(Level.FINE, \"players clear.\");\n\t\tthis.pnlBattlefield.removeAll();\n\t\tMageFrame.getCombatDialog().hideDialog();\n\t\tComponent c = this.getParent();\n\t\twhile (c != null && !(c instanceof GamePane)) {\n\t\t\tc = c.getParent();\n\t\t}\n\t\tif (c != null)\n\t\t\tc.setVisible(false);\n\t}","commit_id":"fcf1cd3d8db0d06b9593264627fc52d97706519a","url":"https://github.com/magefree/mage"},{"original_method":"private static void buildApplicationInterface() {\n\n        //-------------------------------------------------------\n        // Create the tabbed panes for the viewers\n        //-------------------------------------------------------\n        \n        mMapTabsLeft = new MapTabbedPane(\"*left\");\n        mMapTabsRight = new MapTabbedPane(\"right\");\n        \n        //-------------------------------------------------------\n        // Create the split pane\n        //-------------------------------------------------------\n\n        mViewerSplit = buildSplitPane(mMapTabsLeft, mMapTabsRight);\n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        if (DEBUG.INIT) out(\"creating VueFrame...\");\n\n        VUE.ApplicationFrame = new VueFrame();\n\n        if (DEBUG.INIT) out(\"created VueFrame\");\n        \n        //-----------------------------------------------------------------------------\n        // Man VUE Toolbar (map editing tool)\n        //-----------------------------------------------------------------------------\n        \n        // The real tool palette window withtools and contextual tools\n        VueToolbarController tbc = VueToolbarController.getController();\n        ModelSelection.addListener(tbc);\n\n        DockWindow toolbarDock = null;\n        \n        if (true) {\n            //toolbarDock = GUI.createToolbar(VueResources.getString(\"tbWindowName\"), tbc.getToolbar());\n            if (VueToolPanel.IS_CONTEXTUAL_TOOLBAR_ENABLED)\n                toolbarDock = GUI.createToolbar(\"Toolbar\", tbc.getToolbar());\n            else\n                toolbarDock = GUI.createToolbar(\"Toolbar\", tbc.getToolbar().getMainToolbar());\n        } else {\n            ApplicationFrame.addComp(tbc.getToolbar(), BorderLayout.NORTH);\n            // buildToolbar()\n        }\n        \n        if (DEBUG.INIT) out(\"created ToolBar\");\n\n        \n        //=============================================================================\n        //\n        // Create all the DockWindow's\n        //\n        //=============================================================================\n\n        //-----------------------------------------------------------------------------\n        // Panner\n        //-----------------------------------------------------------------------------\n\n        final DockWindow pannerDock = GUI.createDockWindow(\"Panner\", new MapPanner());\n        //pannerDock.getWidgetPanel().setBorder(new javax.swing.border.MatteBorder(5,5,5,5, Color.green));\n        pannerDock.getContentPanel().setBorder(new EmptyBorder(1,2,2,2));\n        //pannerDock.setSize(120,120);\n        //pannerDock.setSize(112,120);\n        pannerDock.setUpperRightCorner(GUI.GScreenWidth, 150);\n        pannerDock.setMenuActions(new Action[] {\n                Actions.ZoomFit,\n                Actions.ZoomActual\n            });\n\n\n        //-----------------------------------------------------------------------------\n        // Resources Stack (Libraries / DRBrowser)\n        // DRBrowser class initializes the DockWindow itself.\n        //-----------------------------------------------------------------------------\n        \n        DR_BROWSER_DOCK = GUI.createDockWindow(\"Libraries\");\n        DR_BROWSER = new DRBrowser(true, DR_BROWSER_DOCK);\n\t\t\n        //-----------------------------------------------------------------------------\n        // Map Inspector\n        //-----------------------------------------------------------------------------\n\n        MapInspector = GUI.createDockWindow(VueResources.getString(\"mapInspectorTitle\"));\n        MapInspector.setContent(new MapInspectorPanel());\n        \n        //-----------------------------------------------------------------------------\n        // Object Inspector / Resource Inspector\n        //-----------------------------------------------------------------------------\n\n        //final DockWindow resourceDock = GUI.createDockWindow(\"Resource Inspector\", new ResourcePanel());\n        ObjectInspector = GUI.createDockWindow(\"Inspector\", new ResourcePanel());\n        \n        //-----------------------------------------------------------------------------\n        // Object Inspector\n        //-----------------------------------------------------------------------------\n\n        //GUI.createDockWindow(\"Test OI\", new ObjectInspectorPanel()).setVisible(true);\n        /*\n        ObjectInspector = GUI.createDockWindow(VueResources.getString(\"objectInspectorTitle\"));\n        ObjectInspectorPanel = new ObjectInspectorPanel();\n        ModelSelection.addListener(ObjectInspectorPanel);\n        ObjectInspector.setContent(ObjectInspectorPanel);\n        */\n        \n        //-----------------------------------------------------------------------------\n        // Pathway Panel\n        //-----------------------------------------------------------------------------\n\n        // todo\n        \n        //-----------------------------------------------------------------------------\n        // Outline View\n        //-----------------------------------------------------------------------------\n\n        OutlineViewTree outlineTree = new OutlineViewTree();\n        JScrollPane outlineScroller = new JScrollPane(outlineTree);\n        VUE.getSelection().addListener(outlineTree);\n        VUE.addActiveMapListener(outlineTree);\n        outlineScroller.setPreferredSize(new Dimension(500, 300));\n        //outlineScroller.setBorder(null); // so DockWindow will add 1 pixel to bottom\n        DockWindow outlineDock =  GUI.createDockWindow(\"Outline\", outlineScroller);\n        \n        //-----------------------------------------------------------------------------\n\n\n        // GUI.createDockWindow(\"Font\").add(new FontEditorPanel()); // just add automatically?\n\n        //final DockWindow fontDock = GUI.createToolbar(\"Font\", new FontPropertyPanel());\n        //final DockWindow linkDock = GUI.createToolbar(\"Link\", new LinkPropertyPanel());\n        //final DockWindow actionDock = GUI.createToolbar(\"Actions\", new VueActionBar());\n        final DockWindow fontDock = null;\n        final DockWindow linkDock = null;\n        final DockWindow actionDock = null;\n\n        //fontDock.setResizeEnabled(false);\n        //linkDock.setResizeEnabled(false);\n        \n        //pannerDock.setChild(linkDock);\n        \n        //fontDock.setChild(linkDock);\n\n        //fontDock.setLowerRightCorner(GUI.GScreenWidth, GUI.GScreenHeight);\n        \n        //=============================================================================\n        //\n        // Now that we have all the DockWindow's created the VueMenuBar, which needs the\n        // list of Windows for the Window's menu.  The order they appear in this list is\n        // the order they appear in the Window's menu.\n        //\n        //=============================================================================\n        \n        VUE.ToolWindows = new Object[] {\n            DR_BROWSER_DOCK,\n            MapInspector,\n            ObjectInspector,\n            //resourceDock,\n            toolbarDock,\n            pannerDock,\n            //htWindow,\n            outlineDock,\n            actionDock,\n            fontDock,\n            linkDock,\n        };\n\n        // adding the menus and toolbars\n        if (DEBUG.INIT) out(\"setting JMenuBar...\");\n        ApplicationFrame.setJMenuBar(VueMenuBar.RootMenuBar = new VueMenuBar(VUE.ToolWindows));\n        if (DEBUG.INIT) out(\"VueMenuBar installed.\");;\n\n        if (true)\n            ApplicationFrame.addComp(mViewerSplit, BorderLayout.CENTER);\n        else\n            ApplicationFrame.addComp(mMapTabsLeft, BorderLayout.CENTER);\n        \n        try {\n            ApplicationFrame.pack();\n        } catch (ArrayIndexOutOfBoundsException e) {\n            Log.error(\"OSX TIGER JAVA BUG at frame.pack()\", e);\n        }\n        \n        /*\n        if (SKIP_DR) {\n            ApplicationFrame.setSize(750,450);\n        } else {\n            ApplicationFrame.setSize(800,600);\n            // todo: make % of screen, make sure tool windows below don't go off screen!\n        }\n        */\n        \n        //if (DEBUG.INIT) out(\"validating frame...\");\n        ApplicationFrame.validate();\n        //if (DEBUG.INIT) out(\"frame validated\");\n\n        ApplicationFrame.setSize((int) (GUI.GScreenWidth * 0.75),\n                                 (int) (GUI.GScreenHeight * 0.75));\n\n        ApplicationFrame.setLocation(GUI.GInsets.left + 30,\n                                     GUI.GInsets.top\n                                     + DockWindow.ToolbarHeight);\n\n        // MAC NOTE WITH MAXIMIZING: if Frame's current location y value\n        // is less than whatever's it's maximized value is set to, maximizing\n        // it will use the y value, not the max value.  True even if set\n        // y value after setting to maximized but before it's put on screen.\n        \n        //GUI.centerOnScreen(ApplicationFrame);\n\n        final boolean loadTopDock = false;\n\n        if (loadTopDock && DockWindow.getMainDock() != null) {\n            // leave room for dock at top\n            Rectangle maxBounds = GUI.getMaximumWindowBounds();\n            int adj = DockWindow.getCollapsedHeight();\n            maxBounds.y += adj;\n            maxBounds.height -= adj;\n            ApplicationFrame.setMaximizedBounds(maxBounds);\n        }\n            \n        if (false)\n            ApplicationFrame.setExtendedState(Frame.MAXIMIZED_BOTH);\n\n        if (!SKIP_DR) {\n            LWMap startupMap = null;\n            try {\n                final java.net.URL startupURL;\n                startupURL = VueResources.getURL(\"resource.startmap\");\n                startupMap = OpenAction.loadMap(startupURL);\n                startupMap.setFile(null); // dissassociate startup map from it's file so we don't write over it\n                startupMap.setLabel(\"Welcome\");\n                startupMap.markAsSaved();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                VueUtil.alert(null, \"Cannot load the Start-up map\", \"Start Up Map Error\");\n            }\n\n            try {\n                if (startupMap != null)\n                    displayMap(startupMap);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                VueUtil.alert(null, \"Failed to display Start-up Map\", \"Internal Error\");\n            }\n            \n        } else {\n            //pannerTool.setVisible(true);\n        }\n\n\n        // Generally, we need to wait until java 1.5 JSplitPane's have been validated to\n        // use the % set divider location.  Unfortunately there's a bug in at MacOS java\n        // 1.5 BasicSplitPaneUI (it's not in the 1.4 version), where setKeepHidden isn't\n        // be called when the divider goes to the wall via setDividerLocation, only when\n        // the one-touch buttons are manually clicked.  So, for example, if the user\n        // de-maximizes the frame, suddenly a hidden split-pane will pop out!  So, we've\n        // hacked into the UI code, grabbed the damn right-one-touch button, grabbed\n        // it's action listener, and here just call it directly...\n        // \n        // See javax.swing.plaf.basic.BasicSplitPaneDivider.OneTouchActionHandler.\n        //\n        // It appears on Windows we need to actually wait till the frame is shown also...\n\n        // show before split adjust on pc\n        if (!Util.isMacPlatform())\n            ApplicationFrame.setVisible(true);\n        \n        if (SplitPaneRightButtonOneTouchActionHandler != null) {\n            if (DEBUG.INIT) Util.printStackTrace(\"\\\"pressing\\\": \" + SplitPaneRightButtonOneTouchActionHandler);\n\n            // Not reliable on PC unless we invokeLater\n            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                SplitPaneRightButtonOneTouchActionHandler.actionPerformed(null);                  \n            }});\n        \n            // this is also eventually getting eaten in java 1.5: no matter where\n            // we put this call during init: will have to patch w/more hacking\n            // or live with it.  Actually, it get's eaten eventually in java 1.4.2\n            // also.\n\n            // Maybe because we maximized the frame before it was shown?\n            // [ not making a difference]\n\n            // Well. this is working at least the first time now by\n            // doing it BEFORE the peers are created.\n            //mViewerSplit.setResizeWeight(0.5d);\n            \n        } else {\n            // for java 1.4.2\n            mViewerSplit.setDividerLocation(1.0);\n        }\n\n        // can show after split adjust on mac\n        if (Util.isMacPlatform())\n            ApplicationFrame.setVisible(true);\n\n        toolbarDock.suggestLocation(0,0);\n        toolbarDock.setWidth(GUI.GScreenWidth);\n        toolbarDock.setVisible(true);\n\n        //-----------------------------------------------------------------------------\n        //\n        // Set locations for the inspector windows and make some of them visible\n        //\n        //-----------------------------------------------------------------------------\n\n\n        // order the windows left to right for the top dock\n        final DockWindow[] acrossTop = new DockWindow[] {\n            DR_BROWSER_DOCK,\n            GUI.isSmallScreen() ? null : fontDock,\n            MapInspector,\n            ObjectInspector,\n            //resourceDock,\n        };\n            \n        outlineDock.setLowerLeftCorner(0, GUI.GScreenHeight - GUI.GInsets.bottom);\n        if (DockWindow.getTopDock() != null)\n            prepareForTopDockDisplay(acrossTop);\n        \n        // Run after AWT to ensure all peers to have been created & shown\n        GUI.invokeAfterAWT(new Runnable() { public void run() {\n            positionForDocking(acrossTop);\n        }});\n        \n        \n        if (false) {\n            // old positioning code\n            int inspectorx = ApplicationFrame.getX() + ApplicationFrame.getWidth();\n            MapInspector.suggestLocation(inspectorx, ApplicationFrame.getY());\n            ObjectInspector.suggestLocation(inspectorx, ApplicationFrame.getY() + MapInspector.getHeight() );\n            pannerDock.suggestLocation(ApplicationFrame.getX() - pannerDock.getWidth(), ApplicationFrame.getY());\n        }\n        \n        if (!SKIP_DR)\n            DR_BROWSER_DOCK.setVisible(true);\n\n\n        /*\n        GUI.invokeAfterAWT(new Runnable() { public void run() {\n            //pannerDock.setVisible(true);\n            if (DEBUG.Enabled) linkDock.setVisible(true);\n            if (DEBUG.Enabled) fontDock.setVisible(true);\n        }});\n        */\n\n\n    }","id":80879,"modified_method":"private static void buildApplicationInterface() {\n\n        //-------------------------------------------------------\n        // Create the tabbed panes for the viewers\n        //-------------------------------------------------------\n        \n        mMapTabsLeft = new MapTabbedPane(\"*left\");\n        mMapTabsRight = new MapTabbedPane(\"right\");\n        \n        //-------------------------------------------------------\n        // Create the split pane\n        //-------------------------------------------------------\n\n        mViewerSplit = buildSplitPane(mMapTabsLeft, mMapTabsRight);\n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        if (DEBUG.INIT) out(\"creating VueFrame...\");\n\n        VUE.ApplicationFrame = new VueFrame();\n\n        if (DEBUG.INIT) out(\"created VueFrame\");\n        \n        //-----------------------------------------------------------------------------\n        // Man VUE Toolbar (map editing tool)\n        //-----------------------------------------------------------------------------\n        \n        // The real tool palette window withtools and contextual tools\n        VueToolbarController tbc = VueToolbarController.getController();\n        ModelSelection.addListener(tbc);\n\n        DockWindow toolbarDock = null;\n\n        final JComponent toolbar;\n        \n        if (VueToolPanel.IS_CONTEXTUAL_TOOLBAR_ENABLED)\n            toolbar = tbc.getToolbar();\n        else\n            toolbar = tbc.getToolbar().getMainToolbar();\n\n        if (VueUtil.isMacPlatform()) {\n            toolbarDock = GUI.createToolbar(\"Toolbar\", toolbar);\n        } else {\n            ApplicationFrame.addComp(toolbar, BorderLayout.NORTH);\n        }\n        \n        if (DEBUG.INIT) out(\"created ToolBar\");\n\n        \n        //=============================================================================\n        //\n        // Create all the DockWindow's\n        //\n        //=============================================================================\n\n        //-----------------------------------------------------------------------------\n        // Panner\n        //-----------------------------------------------------------------------------\n\n        final DockWindow pannerDock = GUI.createDockWindow(\"Panner\", new MapPanner());\n        //pannerDock.getWidgetPanel().setBorder(new javax.swing.border.MatteBorder(5,5,5,5, Color.green));\n        pannerDock.getContentPanel().setBorder(new EmptyBorder(1,2,2,2));\n        //pannerDock.setSize(120,120);\n        //pannerDock.setSize(112,120);\n        pannerDock.setUpperRightCorner(GUI.GScreenWidth, 150);\n        pannerDock.setMenuActions(new Action[] {\n                Actions.ZoomFit,\n                Actions.ZoomActual\n            });\n\n\n        //-----------------------------------------------------------------------------\n        // Resources Stack (Libraries / DRBrowser)\n        // DRBrowser class initializes the DockWindow itself.\n        //-----------------------------------------------------------------------------\n        \n        DR_BROWSER_DOCK = GUI.createDockWindow(\"Libraries\");\n        DR_BROWSER = new DRBrowser(true, DR_BROWSER_DOCK);\n\t\t\n        //-----------------------------------------------------------------------------\n        // Map Inspector\n        //-----------------------------------------------------------------------------\n\n        MapInspector = GUI.createDockWindow(VueResources.getString(\"mapInspectorTitle\"));\n        MapInspector.setContent(new MapInspectorPanel());\n        \n        //-----------------------------------------------------------------------------\n        // Object Inspector / Resource Inspector\n        //-----------------------------------------------------------------------------\n\n        //final DockWindow resourceDock = GUI.createDockWindow(\"Resource Inspector\", new ResourcePanel());\n        ObjectInspector = GUI.createDockWindow(\"Inspector\", new ResourcePanel());\n        \n        //-----------------------------------------------------------------------------\n        // Object Inspector\n        //-----------------------------------------------------------------------------\n\n        //GUI.createDockWindow(\"Test OI\", new ObjectInspectorPanel()).setVisible(true);\n        /*\n        ObjectInspector = GUI.createDockWindow(VueResources.getString(\"objectInspectorTitle\"));\n        ObjectInspectorPanel = new ObjectInspectorPanel();\n        ModelSelection.addListener(ObjectInspectorPanel);\n        ObjectInspector.setContent(ObjectInspectorPanel);\n        */\n        \n        //-----------------------------------------------------------------------------\n        // Pathway Panel\n        //-----------------------------------------------------------------------------\n\n        // todo\n        \n        //-----------------------------------------------------------------------------\n        // Outline View\n        //-----------------------------------------------------------------------------\n\n        OutlineViewTree outlineTree = new OutlineViewTree();\n        JScrollPane outlineScroller = new JScrollPane(outlineTree);\n        VUE.getSelection().addListener(outlineTree);\n        VUE.addActiveMapListener(outlineTree);\n        outlineScroller.setPreferredSize(new Dimension(500, 300));\n        //outlineScroller.setBorder(null); // so DockWindow will add 1 pixel to bottom\n        DockWindow outlineDock =  GUI.createDockWindow(\"Outline\", outlineScroller);\n        \n        //-----------------------------------------------------------------------------\n\n\n        // GUI.createDockWindow(\"Font\").add(new FontEditorPanel()); // just add automatically?\n\n        //final DockWindow fontDock = GUI.createToolbar(\"Font\", new FontPropertyPanel());\n        //final DockWindow linkDock = GUI.createToolbar(\"Link\", new LinkPropertyPanel());\n        //final DockWindow actionDock = GUI.createToolbar(\"Actions\", new VueActionBar());\n        final DockWindow fontDock = null;\n        final DockWindow linkDock = null;\n        final DockWindow actionDock = null;\n\n        //fontDock.setResizeEnabled(false);\n        //linkDock.setResizeEnabled(false);\n        \n        //pannerDock.setChild(linkDock);\n        \n        //fontDock.setChild(linkDock);\n\n        //fontDock.setLowerRightCorner(GUI.GScreenWidth, GUI.GScreenHeight);\n        \n        //=============================================================================\n        //\n        // Now that we have all the DockWindow's created the VueMenuBar, which needs the\n        // list of Windows for the Window's menu.  The order they appear in this list is\n        // the order they appear in the Window's menu.\n        //\n        //=============================================================================\n        \n        VUE.ToolWindows = new Object[] {\n            DR_BROWSER_DOCK,\n            MapInspector,\n            ObjectInspector,\n            //resourceDock,\n            toolbarDock,\n            pannerDock,\n            //htWindow,\n            outlineDock,\n            actionDock,\n            fontDock,\n            linkDock,\n        };\n\n        // adding the menus and toolbars\n        if (DEBUG.INIT) out(\"setting JMenuBar...\");\n        ApplicationFrame.setJMenuBar(VueMenuBar.RootMenuBar = new VueMenuBar(VUE.ToolWindows));\n        if (DEBUG.INIT) out(\"VueMenuBar installed.\");;\n\n        if (true)\n            ApplicationFrame.addComp(mViewerSplit, BorderLayout.CENTER);\n        else\n            ApplicationFrame.addComp(mMapTabsLeft, BorderLayout.CENTER);\n        \n        try {\n            ApplicationFrame.pack();\n        } catch (ArrayIndexOutOfBoundsException e) {\n            Log.error(\"OSX TIGER JAVA BUG at frame.pack()\", e);\n        }\n        \n        /*\n        if (SKIP_DR) {\n            ApplicationFrame.setSize(750,450);\n        } else {\n            ApplicationFrame.setSize(800,600);\n            // todo: make % of screen, make sure tool windows below don't go off screen!\n        }\n        */\n        \n        //if (DEBUG.INIT) out(\"validating frame...\");\n        ApplicationFrame.validate();\n        //if (DEBUG.INIT) out(\"frame validated\");\n\n        ApplicationFrame.setSize((int) (GUI.GScreenWidth * 0.75),\n                                 (int) (GUI.GScreenHeight * 0.75));\n\n        ApplicationFrame.setLocation(GUI.GInsets.left + 30,\n                                     GUI.GInsets.top\n                                     + (toolbarDock == null ? 0 : DockWindow.ToolbarHeight));\n\n        // MAC NOTE WITH MAXIMIZING: if Frame's current location y value\n        // is less than whatever's it's maximized value is set to, maximizing\n        // it will use the y value, not the max value.  True even if set\n        // y value after setting to maximized but before it's put on screen.\n        \n        //GUI.centerOnScreen(ApplicationFrame);\n\n        final boolean loadTopDock = false;\n\n        if (loadTopDock && DockWindow.getMainDock() != null) {\n            // leave room for dock at top\n            Rectangle maxBounds = GUI.getMaximumWindowBounds();\n            int adj = DockWindow.getCollapsedHeight();\n            maxBounds.y += adj;\n            maxBounds.height -= adj;\n            ApplicationFrame.setMaximizedBounds(maxBounds);\n        }\n            \n        if (false)\n            ApplicationFrame.setExtendedState(Frame.MAXIMIZED_BOTH);\n\n        if (!SKIP_DR) {\n            LWMap startupMap = null;\n            try {\n                final java.net.URL startupURL;\n                startupURL = VueResources.getURL(\"resource.startmap\");\n                startupMap = OpenAction.loadMap(startupURL);\n                startupMap.setFile(null); // dissassociate startup map from it's file so we don't write over it\n                startupMap.setLabel(\"Welcome\");\n                startupMap.markAsSaved();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                VueUtil.alert(null, \"Cannot load the Start-up map\", \"Start Up Map Error\");\n            }\n\n            try {\n                if (startupMap != null)\n                    displayMap(startupMap);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                VueUtil.alert(null, \"Failed to display Start-up Map\", \"Internal Error\");\n            }\n            \n        } else {\n            //pannerTool.setVisible(true);\n        }\n\n\n        // Generally, we need to wait until java 1.5 JSplitPane's have been validated to\n        // use the % set divider location.  Unfortunately there's a bug in at MacOS java\n        // 1.5 BasicSplitPaneUI (it's not in the 1.4 version), where setKeepHidden isn't\n        // be called when the divider goes to the wall via setDividerLocation, only when\n        // the one-touch buttons are manually clicked.  So, for example, if the user\n        // de-maximizes the frame, suddenly a hidden split-pane will pop out!  So, we've\n        // hacked into the UI code, grabbed the damn right-one-touch button, grabbed\n        // it's action listener, and here just call it directly...\n        // \n        // See javax.swing.plaf.basic.BasicSplitPaneDivider.OneTouchActionHandler.\n        //\n        // It appears on Windows we need to actually wait till the frame is shown also...\n\n        // show before split adjust on pc\n        if (!Util.isMacPlatform())\n            ApplicationFrame.setVisible(true);\n        \n        if (SplitPaneRightButtonOneTouchActionHandler != null) {\n            if (DEBUG.INIT) Util.printStackTrace(\"\\\"pressing\\\": \" + SplitPaneRightButtonOneTouchActionHandler);\n\n            // Not reliable on PC unless we invokeLater\n            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                SplitPaneRightButtonOneTouchActionHandler.actionPerformed(null);                  \n            }});\n        \n            // this is also eventually getting eaten in java 1.5: no matter where\n            // we put this call during init: will have to patch w/more hacking\n            // or live with it.  Actually, it get's eaten eventually in java 1.4.2\n            // also.\n\n            // Maybe because we maximized the frame before it was shown?\n            // [ not making a difference]\n\n            // Well. this is working at least the first time now by\n            // doing it BEFORE the peers are created.\n            //mViewerSplit.setResizeWeight(0.5d);\n            \n        } else {\n            // for java 1.4.2\n            mViewerSplit.setDividerLocation(1.0);\n        }\n\n        // can show after split adjust on mac\n        if (Util.isMacPlatform())\n            ApplicationFrame.setVisible(true);\n\n        if (toolbarDock != null) {\n            toolbarDock.suggestLocation(0,0);\n            toolbarDock.setWidth(GUI.GScreenWidth);\n            toolbarDock.setVisible(true);\n        }\n\n        //-----------------------------------------------------------------------------\n        //\n        // Set locations for the inspector windows and make some of them visible\n        //\n        //-----------------------------------------------------------------------------\n\n\n        // order the windows left to right for the top dock\n        final DockWindow[] acrossTop = new DockWindow[] {\n            DR_BROWSER_DOCK,\n            GUI.isSmallScreen() ? null : fontDock,\n            MapInspector,\n            ObjectInspector,\n            //resourceDock,\n        };\n            \n        outlineDock.setLowerLeftCorner(0, GUI.GScreenHeight - GUI.GInsets.bottom);\n        if (DockWindow.getTopDock() != null)\n            prepareForTopDockDisplay(acrossTop);\n        \n        // Run after AWT to ensure all peers to have been created & shown\n        GUI.invokeAfterAWT(new Runnable() { public void run() {\n            positionForDocking(acrossTop);\n        }});\n        \n        \n        if (false) {\n            // old positioning code\n            int inspectorx = ApplicationFrame.getX() + ApplicationFrame.getWidth();\n            MapInspector.suggestLocation(inspectorx, ApplicationFrame.getY());\n            ObjectInspector.suggestLocation(inspectorx, ApplicationFrame.getY() + MapInspector.getHeight() );\n            pannerDock.suggestLocation(ApplicationFrame.getX() - pannerDock.getWidth(), ApplicationFrame.getY());\n        }\n        \n        if (!SKIP_DR)\n            DR_BROWSER_DOCK.setVisible(true);\n\n\n        /*\n        GUI.invokeAfterAWT(new Runnable() { public void run() {\n            //pannerDock.setVisible(true);\n            if (DEBUG.Enabled) linkDock.setVisible(true);\n            if (DEBUG.Enabled) fontDock.setVisible(true);\n        }});\n        */\n\n\n    }","commit_id":"8a1cef7ad8448b293b5c2dd04f9e73d899234d84","url":"https://github.com/VUE/VUE"},{"original_method":"/**\r\n\t * Returns true if the given url starts with specified segments. Segments that contain\r\n\t * placelhoders are not compared.\r\n\t * \r\n\t * @param url\r\n\t * @param segments\r\n\t * @return <code>true<\/code> if the URL starts with the specified segments, <code>false<\/code>\r\n\t *         otherwise\r\n\t */\r\n\tprotected boolean urlStartsWith(final Url url, final String... segments)\r\n\t{\r\n\t\tif (url == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (url.getSegments().size() < segments.length)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < segments.length; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif ((segments[i].equals(url.getSegments().get(i)) == false) &&\r\n\t\t\t\t\t\t(getPlaceholder(segments[i]) == null))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}","id":80880,"modified_method":"/**\r\n\t * Returns true if the given url starts with specified segments. Segments that contain\r\n\t * placelhoders are not compared.\r\n\t * \r\n\t * @param url\r\n\t * @param segments\r\n\t * @return <code>true<\/code> if the URL starts with the specified segments, <code>false<\/code>\r\n\t *         otherwise\r\n\t */\r\n\tprotected boolean urlStartsWith(final Url url, final String... segments)\r\n\t{\r\n\t\tif (url == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tList<String> urlSegments = url.getSegments();\r\n\t\t\tif (urlSegments.size() < segments.length)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < segments.length; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif ((segments[i].equals(urlSegments.get(i)) == false) &&\r\n\t\t\t\t\t\t(getPlaceholder(segments[i]) == null))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}","commit_id":"bfffed1260a37cd6c338c2495a03377c76fe99d8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Checks whether the passed Url can be handled by this mapper\n\t *\n\t * @param url\n\t *      the Url to check\n\t * @return {@code true} - if the Url can be handled, {@code false} - otherwise\n\t */\n\tprotected boolean canBeHandled(final Url url)\n\t{\n\t\treturn (url.getSegments().size() >= 4 &&\n\t\t\t\turlStartsWith(url, getContext().getNamespace(), getContext().getResourceIdentifier()));\n\n\t}","id":80881,"modified_method":"/**\n\t * Checks whether the passed Url can be handled by this mapper\n\t *\n\t * @param url\n\t *      the Url to check\n\t * @return {@code true} - if the Url can be handled, {@code false} - otherwise\n\t */\n\tprotected boolean canBeHandled(final Url url)\n\t{\n\t\tList<String> segments = url.getSegments();\n\t\treturn (segments.size() >= 4 &&\n\t\t\t\turlStartsWith(url, getContext().getNamespace(), getContext().getResourceIdentifier()) &&\n\t\t\t\tStrings.isEmpty(segments.get(3)) == false\n\t\t);\n\n\t}","commit_id":"bfffed1260a37cd6c338c2495a03377c76fe99d8","url":"https://github.com/apache/wicket"},{"original_method":"private boolean matches(final Request request)\n\t{\n\t\tboolean matches = false;\n\t\tUrl url = request.getUrl();\n\t\tUrl baseUrl = request.getClientUrl();\n\t\tString namespace = getContext().getNamespace();\n\t\tString bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n\t\tString pageIdentifier = getContext().getPageIdentifier();\n\n\t\tif (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t\t// baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n\t\telse if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t\t// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'\n\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier) && url.getSegments().size() == 2 && urlStartsWith(url, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\n\t\treturn matches;\n\t}","id":80882,"modified_method":"private boolean matches(final Request request)\n\t{\n\t\tboolean matches = false;\n\t\tUrl url = request.getUrl();\n\t\tUrl baseUrl = request.getClientUrl();\n\t\tString namespace = getContext().getNamespace();\n\t\tString bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n\t\tString pageIdentifier = getContext().getPageIdentifier();\n\n\t\tList<String> segments = url.getSegments();\n\t\tint segmentsSize = segments.size();\n\n\t\tif (segmentsSize >= 3 && urlStartsWithAndHasPageClass(url, namespace, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t\t// baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n\t\telse if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier)\n\t\t\t\t&& segmentsSize >= 2 && urlStartsWithAndHasPageClass(url, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t\t// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'\n\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier)\n\t\t\t\t&& segmentsSize == 2 && urlStartsWithAndHasPageClass(url, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier)\n\t\t\t\t&& segmentsSize >= 2 && urlStartsWithAndHasPageClass(url, bookmarkableIdentifier))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\n\t\treturn matches;\n\t}","commit_id":"bfffed1260a37cd6c338c2495a03377c76fe99d8","url":"https://github.com/apache/wicket"},{"original_method":"private SnmpCollection populateSnmpCollection(SnmpCollection coll, Package pkg,String sysoid) {\n   \t\t\n    \tcoll.setPackageName(pkg.getName());\n\t\t\n   \t\tcoll.setInitialSleepTime(getInitialSleepTime());\n    \t\t\n   \t\tif (pkg.hasSnmp_poll_interval()) coll.setPollInterval(pkg.getSnmp_poll_interval());\n   \t\telse coll.setPollInterval(getSnmpPollInterval());\n\n   \t\t\n       if (hasIpRouteClassName(sysoid)) {\n                coll.setIpRouteClass(getIpRouteClassName(sysoid));\n                if (log().isDebugEnabled())\n                        log().debug(\n                                     \"populateSnmpCollection: found class to get ipRoute: \"\n                                                                               + coll.getIpRouteClass());\n       } else {\n                coll.setIpRouteClass(\"org.opennms.netmgt.linkd.snmp.IpRouteTable\");\n                if (log().isDebugEnabled())\n                        log().debug(\n                                     \"populateSnmpCollection: Using default class to get ipRoute: \"\n                                                                                + coll.getIpRouteClass());\n       }\n   \t\t\n   \t\tif ( pkg.hasEnableVlanDiscovery() && pkg.getEnableVlanDiscovery() && hasClassName(sysoid)) {\n\t\t\tcoll.setVlanClass(getVlanClassName(sysoid));\n\t\t\tif (log().isDebugEnabled())\n\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\"populateSnmpCollection: found class to get Vlans: \"\n\t\t\t\t\t\t\t\t\t+ coll.getVlanClass());\n\t\t} else if (!pkg.hasEnableVlanDiscovery() && enableVlanDiscovery() && hasClassName(sysoid)) {\n   \t\t\t\tcoll.setVlanClass(getVlanClassName(sysoid));\n\t\t\t\tif (log().isDebugEnabled())\n\t\t\t\t\tlog().debug(\n\t\t\t\t\t\t\t\"populateSnmpCollection: found class to get Vlans: \"\n\t\t\t\t\t\t\t\t\t+ coll.getVlanClass());\n\t\t} else {\n\t\t\t\tif (log().isDebugEnabled())\n\t\t\t\t\tlog()\n\t\t\t\t\t\t\t.debug(\n\t\t\t\t\t\t\t\t\t\"populateSnmpCollection: no class found to get Vlans or VlanDiscoveryDisabled for Package: \" + pkg.getName());\n\t\t}\n\t\t\t\n\t\tif (pkg.hasUseCdpDiscovery()) coll.collectCdpTable(pkg.getUseCdpDiscovery());\n\t\telse coll.collectCdpTable(useCdpDiscovery());\n\t\t\n\t\tboolean condition1 = false;\n\t\tboolean condition2 = false;\n\n\t\tif (pkg.hasUseIpRouteDiscovery()) condition1 = pkg.getUseIpRouteDiscovery();\n\t\telse condition1 = useIpRouteDiscovery();\n\t\t\n\t\tif (pkg.hasSaveRouteTable()) condition2 = pkg.getSaveRouteTable();\n\t\telse condition2 = saveRouteTable();\n\n\t\tcoll.SaveIpRouteTable(condition2);\n\t\tcoll.collectIpRouteTable(condition1 || condition2);\n\n\t\tif (pkg.hasUseBridgeDiscovery()) condition1 = pkg.getUseBridgeDiscovery();\n\t\telse condition1 = useBridgeDiscovery();\n\n\t\tcoll.collectBridgeForwardingTable(condition1);\n\n\t\tif (pkg.hasSaveStpNodeTable()) condition2 = pkg.getSaveStpNodeTable();\n\t\telse condition2 = saveStpNodeTable();\n\n\t\tcoll.saveStpNodeTable(condition2);\n\t\tcoll.collectStpNode(condition1 || condition2);\n\t\t\n\t\tif (pkg.hasSaveStpInterfaceTable()) condition2 = pkg.getSaveStpInterfaceTable();\n\t\telse condition2 = saveStpInterfaceTable();\n\t\t\n\t\tcoll.saveStpInterfaceTable(condition2);\n\t\tcoll.collectStpTable(condition1 || condition2);\n\n\t\treturn coll;\n    }","id":80883,"modified_method":"private void populateSnmpCollection(final SnmpCollection coll, final Package pkg, final String sysoid) {\n        coll.setPackageName(pkg.getName());\n   \t\tcoll.setInitialSleepTime(getInitialSleepTime());\n   \t\tcoll.setPollInterval(pkg.hasSnmp_poll_interval()? pkg.getSnmp_poll_interval() : getSnmpPollInterval());\n        \n   \t\tif (hasIpRouteClassName(sysoid)) {\n   \t\t    coll.setIpRouteClass(getIpRouteClassName(sysoid));\n   \t\t    LogUtils.debugf(this, \"populateSnmpCollection: found class to get ipRoute: %s\", coll.getIpRouteClass());\n   \t\t} else {\n   \t\t    coll.setIpRouteClass(DEFAULT_IP_ROUTE_CLASS_NAME);\n   \t\t    LogUtils.debugf(this, \"populateSnmpCollection: Using default class to get ipRoute: %s\", coll.getIpRouteClass());\n   \t\t}\n   \t\t\n   \t\tif (pkg.hasEnableVlanDiscovery() && pkg.getEnableVlanDiscovery() && hasClassName(sysoid)) {\n   \t\t    coll.setVlanClass(getVlanClassName(sysoid));\n\t\t\tLogUtils.debugf(this, \"populateSnmpCollection: found class to get Vlans: %s\", coll.getVlanClass());\n\t\t} else if (!pkg.hasEnableVlanDiscovery() && enableVlanDiscovery() && hasClassName(sysoid)) {\n\t\t    coll.setVlanClass(getVlanClassName(sysoid));\n\t\t    LogUtils.debugf(this, \"populateSnmpCollection: found class to get Vlans: %s\", coll.getVlanClass());\n\t\t} else {\n\t\t    LogUtils.debugf(this, \"populateSnmpCollection: no class found to get Vlans or VlanDiscoveryDisabled for Package: %s\", pkg.getName());\n\t\t}\n\n        coll.collectCdpTable(pkg.hasUseCdpDiscovery()? pkg.getUseCdpDiscovery() : useCdpDiscovery());\n\n        final boolean useIpRouteDiscovery = (pkg.hasUseIpRouteDiscovery()? pkg.getUseIpRouteDiscovery() : useIpRouteDiscovery());\n\t\tfinal boolean saveRouteTable = (pkg.hasSaveRouteTable()? pkg.getSaveRouteTable() : saveRouteTable());\n\n\t\tcoll.SaveIpRouteTable(saveRouteTable);\n\t\tcoll.collectIpRouteTable(useIpRouteDiscovery || saveRouteTable);\n\n\t\tfinal boolean useBridgeDiscovery = (pkg.hasUseBridgeDiscovery()? pkg.getUseBridgeDiscovery() : useBridgeDiscovery());\n\t\tcoll.collectBridgeForwardingTable(useBridgeDiscovery);\n\n\t\tfinal boolean saveStpNodeTable = (pkg.hasSaveStpNodeTable()? pkg.getSaveStpNodeTable() : saveStpNodeTable());\n\n\t\tcoll.saveStpNodeTable(saveStpNodeTable);\n\t\tcoll.collectStpNode(useBridgeDiscovery || saveStpNodeTable);\n\n\t\tfinal boolean saveStpInterfaceTable = (pkg.hasSaveStpInterfaceTable()? pkg.getSaveStpInterfaceTable() : saveStpInterfaceTable());\n\t\t\n\t\tcoll.saveStpInterfaceTable(saveStpInterfaceTable);\n\t\tcoll.collectStpTable(useBridgeDiscovery || saveStpInterfaceTable);\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getVlanClassNames() throws IOException, MarshalException,\n\t\t\tValidationException {\n\n\t\tm_oidMask2VlanclassName = new HashMap<String,String>();\n\n\t\tList<String> excludedOids = new ArrayList<String>();\n\n\t\tVendor[] vendors = m_config.getVlans().getVendor();\n\t\tfor (int i = 0; i < vendors.length; i++) {\n\t\t\tSnmpObjectId curRootSysOid = new SnmpObjectId(vendors[i]\n\t\t\t\t\t.getSysoidRootMask());\n\t\t\tString curClassName = vendors[i].getClassName();\n\n\t\t\tString[] specifics = vendors[i].getSpecific();\n\t\t\tfor (int js = 0; js < specifics.length; js++) {\n\t\t\t\tSnmpObjectId oidMask = new SnmpObjectId(specifics[js]);\n\t\t\t\toidMask.prepend(curRootSysOid);\n\t\t\t\tm_oidMask2VlanclassName.put(oidMask.toString(), curClassName);\n\t\t\t\tif (log().isDebugEnabled())\n\t\t\t\t\tlog().debug(\"getClassNames:  adding class \" + curClassName\n\t\t\t\t\t\t\t+ \" for oid \" + oidMask.toString());\n\n\t\t\t}\n\n\t\t\tExcludeRange[] excludeds = vendors[i].getExcludeRange();\n\t\t\tfor (int je = 0; je < excludeds.length; je++) {\n\t\t\t\tSnmpObjectId snmpBeginOid = new SnmpObjectId(excludeds[je]\n\t\t\t\t\t\t.getBegin());\n\t\t\t\tSnmpObjectId snmpEndOid = new SnmpObjectId(excludeds[je]\n\t\t\t\t\t\t.getEnd());\n\t\t\t\tSnmpObjectId snmpRootOid = getRootOid(snmpBeginOid);\n\t\t\t\tif (snmpBeginOid.getLength() == snmpEndOid.getLength()\n\t\t\t\t\t\t&& snmpRootOid.isRootOf(snmpEndOid)) {\n\t\t\t\t\tSnmpObjectId snmpCurOid = new SnmpObjectId(snmpBeginOid);\n\t\t\t\t\twhile (snmpCurOid.compare(snmpEndOid) <= 0) {\n\t\t\t\t\t\texcludedOids.add(snmpCurOid.toString());\n\t\t\t\t\t\tif (log().isDebugEnabled())\n\t\t\t\t\t\t\tlog().debug(\"getClassNames:  signing excluded class \"\n\t\t\t\t\t\t\t\t\t+ curClassName\n\t\t\t\t\t\t\t\t\t+ \" for oid \"\n\t\t\t\t\t\t\t\t\t+ curRootSysOid.toString().concat(\n\t\t\t\t\t\t\t\t\t\t\tsnmpCurOid.toString()));\n\t\t\t\t\t\tint lastCurCipher = snmpCurOid.getLastIdentifier();\n\t\t\t\t\t\tlastCurCipher++;\n\t\t\t\t\t\tint[] identifiers = snmpCurOid.getIdentifiers();\n\t\t\t\t\t\tidentifiers[identifiers.length - 1] = lastCurCipher;\n\t\t\t\t\t\tsnmpCurOid.setIdentifiers(identifiers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIncludeRange[] includeds = vendors[i].getIncludeRange();\n\t\t\tfor (int ji = 0; ji < includeds.length; ji++) {\n\t\t\t\tSnmpObjectId snmpBeginOid = new SnmpObjectId(includeds[ji]\n\t\t\t\t\t\t.getBegin());\n\t\t\t\tSnmpObjectId snmpEndOid = new SnmpObjectId(includeds[ji]\n\t\t\t\t\t\t.getEnd());\n\t\t\t\tSnmpObjectId rootOid = getRootOid(snmpBeginOid);\n\t\t\t\tif (snmpBeginOid.getLength() == snmpEndOid.getLength()\n\t\t\t\t\t\t&& rootOid.isRootOf(snmpEndOid)) {\n\t\t\t\t\tSnmpObjectId snmpCurOid = new SnmpObjectId(snmpBeginOid);\n\t\t\t\t\twhile (snmpCurOid.compare(snmpEndOid) <= 0) {\n\t\t\t\t\t\tif (!excludedOids.contains(snmpBeginOid.toString())) {\n\t\t\t\t\t\t\tSnmpObjectId oidMask = new SnmpObjectId(\n\t\t\t\t\t\t\t\t\tsnmpBeginOid);\n\t\t\t\t\t\t\toidMask.prepend(curRootSysOid);\n\t\t\t\t\t\t\tm_oidMask2VlanclassName.put(oidMask.toString(),\n\t\t\t\t\t\t\t\t\tcurClassName);\n\t\t\t\t\t\t\tif (log().isDebugEnabled())\n\t\t\t\t\t\t\t\tlog().debug(\"getClassNames:  adding class \"\n\t\t\t\t\t\t\t\t\t\t+ curClassName + \" for oid \"\n\t\t\t\t\t\t\t\t\t\t+ oidMask.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint lastCipher = snmpBeginOid.getLastIdentifier();\n\t\t\t\t\t\tlastCipher++;\n\t\t\t\t\t\tint[] identifiers = snmpBeginOid.getIdentifiers();\n\t\t\t\t\t\tidentifiers[identifiers.length - 1] = lastCipher;\n\t\t\t\t\t\tsnmpCurOid.setIdentifiers(identifiers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":80884,"modified_method":"private void initializeVlanClassNames() throws IOException, MarshalException, ValidationException {\n\t\tfinal Vlans vlans = m_config.getVlans();\n\t\tif (vlans == null) {\n\t\t    LogUtils.infof(this, \"no vlans found in config\");\n\t\t}\n\n        final List<String> excludedOids = new ArrayList<String>();\n\t\tfor (final Vendor vendor : vlans.getVendorCollection()) {\n\t\t    final SnmpObjectId curRootSysOid = new SnmpObjectId(vendor.getSysoidRootMask());\n\t\t    final String curClassName = vendor.getClassName();\n\n\t\t\tfor (final String specific : vendor.getSpecific()) {\n\t\t\t    final SnmpObjectId oidMask = new SnmpObjectId(specific);\n\t\t\t\toidMask.prepend(curRootSysOid);\n\t\t\t\tm_oidMask2VlanclassName.put(oidMask.toString(), curClassName);\n\t\t\t\tLogUtils.debugf(this, \"getClassNames:  adding class %s for oid %s\", curClassName, oidMask.toString());\n\t\t\t}\n\n\t\t\tfor (final ExcludeRange excludeRange : vendor.getExcludeRangeCollection()) {\n\t\t\t    final SnmpObjectId snmpBeginOid = new SnmpObjectId(excludeRange.getBegin());\n\t\t\t    final SnmpObjectId snmpEndOid = new SnmpObjectId(excludeRange.getEnd());\n\t\t\t\tfinal SnmpObjectId snmpRootOid = getRootOid(snmpBeginOid);\n\t\t\t\tif (snmpBeginOid.getLength() == snmpEndOid.getLength() && snmpRootOid.isRootOf(snmpEndOid)) {\n\t\t\t\t    final SnmpObjectId snmpCurOid = new SnmpObjectId(snmpBeginOid);\n\t\t\t\t\twhile (snmpCurOid.compare(snmpEndOid) <= 0) {\n\t\t\t\t\t\texcludedOids.add(snmpCurOid.toString());\n\t\t\t\t\t\tLogUtils.debugf(this, \"getClassNames:  signing excluded class %s for oid %s\", curClassName, curRootSysOid.toString().concat(snmpCurOid.toString()));\n\t\t\t\t\t\tint lastCurCipher = snmpCurOid.getLastIdentifier();\n\t\t\t\t\t\tlastCurCipher++;\n\t\t\t\t\t\tint[] identifiers = snmpCurOid.getIdentifiers();\n\t\t\t\t\t\tidentifiers[identifiers.length - 1] = lastCurCipher;\n\t\t\t\t\t\tsnmpCurOid.setIdentifiers(identifiers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (final IncludeRange includeRange : vendor.getIncludeRangeCollection()) {\n\t\t\t    final SnmpObjectId snmpBeginOid = new SnmpObjectId(includeRange.getBegin());\n\t\t\t\tfinal SnmpObjectId snmpEndOid = new SnmpObjectId(includeRange.getEnd());\n\t\t\t\tfinal SnmpObjectId rootOid = getRootOid(snmpBeginOid);\n\t\t\t\tif (snmpBeginOid.getLength() == snmpEndOid.getLength() && rootOid.isRootOf(snmpEndOid)) {\n\t\t\t\t\tfinal SnmpObjectId snmpCurOid = new SnmpObjectId(snmpBeginOid);\n\t\t\t\t\twhile (snmpCurOid.compare(snmpEndOid) <= 0) {\n\t\t\t\t\t\tif (!excludedOids.contains(snmpBeginOid.toString())) {\n\t\t\t\t\t\t\tfinal SnmpObjectId oidMask = new SnmpObjectId(snmpBeginOid);\n\t\t\t\t\t\t\toidMask.prepend(curRootSysOid);\n\t\t\t\t\t\t\tm_oidMask2VlanclassName.put(oidMask.toString(), curClassName);\n\t\t\t\t\t\t\tLogUtils.debugf(this, \"getClassNames:  adding class %s for oid %s\", curClassName, oidMask.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint lastCipher = snmpBeginOid.getLastIdentifier();\n\t\t\t\t\t\tlastCipher++;\n\t\t\t\t\t\tint[] identifiers = snmpBeginOid.getIdentifiers();\n\t\t\t\t\t\tidentifiers[identifiers.length - 1] = lastCipher;\n\t\t\t\t\t\tsnmpCurOid.setIdentifiers(identifiers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public String getIpRouteClassName(String sysoid) {\n\n            String defaultIpRouteClassName = \"org.opennms.netmgt.linkd.snmp.IpRouteTable\";\n\n            for (String oidMask : m_oidMask2IpRouteclassName.keySet()) {\n                    if (sysoid.startsWith(oidMask)) {\n                            return m_oidMask2IpRouteclassName.get(oidMask);\n                    }\n            }\n\n           return defaultIpRouteClassName;\n    }","id":80885,"modified_method":"/** {@inheritDoc} */\n    public String getIpRouteClassName(final String sysoid) {\n        for (final String oidMask : m_oidMask2IpRouteclassName.keySet()) {\n            if (sysoid.startsWith(oidMask)) {\n                return m_oidMask2IpRouteclassName.get(oidMask);\n            }\n        }\n        return DEFAULT_IP_ROUTE_CLASS_NAME;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpObjectId getRootOid(SnmpObjectId snmpObj) {\n\t\tint[] identifiers = snmpObj.getIdentifiers();\n\t\tint[] rootIdentifiers = new int[identifiers.length - 1];\n\t\tfor (int i = 0; i < identifiers.length - 1; i++) {\n\t\t\trootIdentifiers[i] = identifiers[i];\n\t\t}\n\t\treturn new SnmpObjectId(rootIdentifiers);\n\n\t}","id":80886,"modified_method":"private SnmpObjectId getRootOid(final SnmpObjectId snmpObj) {\n\t    final int[] identifiers = snmpObj.getIdentifiers();\n\t\tfinal int[] rootIdentifiers = new int[identifiers.length - 1];\n\t\tfor (int i = 0; i < identifiers.length - 1; i++) {\n\t\t\trootIdentifiers[i] = identifiers[i];\n\t\t}\n\t\treturn new SnmpObjectId(rootIdentifiers);\n\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getIpRouteClassNames() throws IOException, MarshalException,\n                    ValidationException {\n\n        m_oidMask2IpRouteclassName = new HashMap<String,String>();\n\n        Vendor[] vendors = m_config.getIproutes().getVendor();\n        for (int i = 0; i < vendors.length; i++) {\n                SnmpObjectId oidMask = new SnmpObjectId(vendors[i].getSysoidRootMask());\n                String curClassName = vendors[i].getClassName();\n                m_oidMask2IpRouteclassName.put(oidMask.toString(), curClassName);\n                if (log().isDebugEnabled())\n                       log().debug(\"getIpRouteClassNames:  adding class \" + curClassName\n                              + \" for oid \" + oidMask.toString());\n        }\n    }","id":80887,"modified_method":"private void initializeIpRouteClassNames() throws IOException, MarshalException, ValidationException {\n        final Iproutes iproutes = m_config.getIproutes();\n        if (iproutes == null) {\n            LogUtils.infof(this, \"no iproutes found in config\");\n            return;\n        }\n\n        for (final Vendor vendor : iproutes.getVendorCollection()) {\n            final SnmpObjectId oidMask = new SnmpObjectId(vendor.getSysoidRootMask());\n            final String curClassName = vendor.getClassName();\n            m_oidMask2IpRouteclassName.put(oidMask.toString(), curClassName);\n            LogUtils.debugf(this, \"getIpRouteClassNames:  adding class %s for oid %s\", curClassName, oidMask.toString());\n        }\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>saveStpNodeTable<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean saveStpNodeTable() {\n\n\t\tboolean download = true;\n\t\t\n\t\tif (m_config.hasSaveStpNodeTable()) {\n\t\t\tdownload = m_config.getSaveStpNodeTable();\n\t\t}\n\t\t\n\t\treturn download;\n\t}","id":80888,"modified_method":"/**\n\t * <p>saveStpNodeTable<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean saveStpNodeTable() {\n\t\tif (m_config.hasSaveStpNodeTable()) return m_config.getSaveStpNodeTable();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to determine if the named interface is included in\n     * the passed package definition. If the interface belongs to the package\n     * then a value of true is returned. If the interface does not belong to the\n     * package a false value is returned.\n     *\n     * <strong>Note: <\/strong>Evaluation of the interface against a package\n     * filter will only work if the IP is already in the database.\n     *\n     * @param iface\n     *            The interface to test against the package.\n     * @param pkg\n     *            The package to check for the inclusion of the interface.\n     * @return True if the interface is included in the package, false\n     *         otherwise.\n     */\n    public synchronized boolean interfaceInPackage(String iface, org.opennms.netmgt.config.linkd.Package pkg) {\n        ThreadCategory log = log();\n    \n        boolean filterPassed = false;\n    \n        // get list of IPs in this package\n        java.util.List<String> ipList = m_pkgIpMap.get(pkg);\n        if (ipList != null && ipList.size() > 0) {\n            filterPassed = ipList.contains(iface);\n        }\n    \n        if (log.isDebugEnabled())\n            log.debug(\"interfaceInPackage: Interface \" + iface + \" passed filter for package \" + pkg.getName() + \"?: \" + filterPassed);\n    \n        if (!filterPassed)\n            return false;\n        return interfaceInPackageRange(iface, pkg);\n    }","id":80889,"modified_method":"/**\n     * This method is used to determine if the named interface is included in\n     * the passed package definition. If the interface belongs to the package\n     * then a value of true is returned. If the interface does not belong to the\n     * package a false value is returned.\n     *\n     * <strong>Note: <\/strong>Evaluation of the interface against a package\n     * filter will only work if the IP is already in the database.\n     *\n     * @param iface\n     *            The interface to test against the package.\n     * @param pkg\n     *            The package to check for the inclusion of the interface.\n     * @return True if the interface is included in the package, false\n     *         otherwise.\n     */\n    public synchronized boolean interfaceInPackage(final String iface, final org.opennms.netmgt.config.linkd.Package pkg) {\n        boolean filterPassed = false;\n    \n        // get list of IPs in this package\n        final List<String> ipList = m_pkgIpMap.get(pkg);\n        if (ipList != null && ipList.size() > 0) {\n            filterPassed = ipList.contains(iface);\n        }\n    \n        LogUtils.debugf(this, \"interfaceInPackage: Interface %s passed filter for package %s?: %s\", iface, pkg.getName(), (filterPassed? \"True\":\"False\"));\n    \n        if (!filterPassed) return false;\n\n        return interfaceInPackageRange(iface, pkg);\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n\tpublic synchronized org.opennms.netmgt.config.linkd.Package getPackage(String name) {\n        for (org.opennms.netmgt.config.linkd.Package thisPackage : m_config.getPackageCollection()) {\n            if (thisPackage.getName().equals(name)) {\n                return thisPackage;\n            }\n        }\n        return null;\n    }","id":80890,"modified_method":"/** {@inheritDoc} */\n\tpublic synchronized org.opennms.netmgt.config.linkd.Package getPackage(final String name) {\n        for (final org.opennms.netmgt.config.linkd.Package thisPackage : m_config.getPackageCollection()) {\n            final String n = thisPackage.getName();\n            if (n != null && n.equals(name)) {\n                return thisPackage;\n            }\n        }\n        return null;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>reloadXML<\/p>\n     *\n     * @param reader a {@link java.io.Reader} object.\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     * @throws java.io.IOException if any.\n     */\n    @Deprecated\n    protected synchronized void reloadXML(Reader reader) throws MarshalException, ValidationException, IOException {\n        m_config = CastorUtils.unmarshal(LinkdConfiguration.class, reader);\n        createUrlIpMap();\n        createPackageIpListMap();\n        getVlanClassNames();\n        getIpRouteClassNames();\n    }","id":80891,"modified_method":"/**\n     * <p>reloadXML<\/p>\n     *\n     * @param reader a {@link java.io.Reader} object.\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     * @throws java.io.IOException if any.\n     */\n    @Deprecated\n    protected synchronized void reloadXML(final Reader reader) throws MarshalException, ValidationException, IOException {\n        m_config = CastorUtils.unmarshal(LinkdConfiguration.class, reader);\n        createUrlIpMap();\n        createPackageIpListMap();\n        initializeVlanClassNames();\n        initializeIpRouteClassNames();\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getInitialSleepTime<\/p>\n\t *\n\t * @return a long.\n\t */\n\tpublic long getInitialSleepTime() {\n\n\n\t\tlong initialSleepTime = 1800000;\n\n\t\tif (m_config.hasInitial_sleep_time()) {\n\t\t\tinitialSleepTime = m_config.getInitial_sleep_time();\n\t\t}\n\n\t\treturn initialSleepTime;\n\t}","id":80892,"modified_method":"public long getInitialSleepTime() {\n\t\tif (m_config.hasInitial_sleep_time()) return m_config.getInitial_sleep_time();\n\t\treturn 1800000;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>reloadXML<\/p>\n     *\n     * @param stream a {@link java.io.InputStream} object.\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     * @throws java.io.IOException if any.\n     */\n    protected synchronized void reloadXML(InputStream stream) throws MarshalException, ValidationException, IOException {\n        m_config = CastorUtils.unmarshal(LinkdConfiguration.class, stream);\n        createUrlIpMap();\n        createPackageIpListMap();\n        getVlanClassNames();\n        getIpRouteClassNames();        \n    }","id":80893,"modified_method":"/**\n     * <p>reloadXML<\/p>\n     *\n     * @param stream a {@link java.io.InputStream} object.\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     * @throws java.io.IOException if any.\n     */\n    protected synchronized void reloadXML(final InputStream stream) throws MarshalException, ValidationException, IOException {\n        m_config = CastorUtils.unmarshal(LinkdConfiguration.class, stream, CastorUtils.PRESERVE_WHITESPACE);\n        createUrlIpMap();\n        createPackageIpListMap();\n        initializeVlanClassNames();\n        initializeIpRouteClassNames();        \n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>saveRouteTable<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean saveRouteTable() {\n\n\t\tboolean downloadRoutes = true;\n\t\t\n\t\tif (m_config.hasSaveRouteTable()) {\n\t\t\tdownloadRoutes = m_config.getSaveRouteTable();\n\t\t}\n\t\t\n\t\treturn downloadRoutes;\n\t}","id":80894,"modified_method":"/**\n\t * <p>saveRouteTable<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean saveRouteTable() {\n\t\tif (m_config.hasSaveRouteTable()) return m_config.getSaveRouteTable();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>useCdpDiscovery<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean useCdpDiscovery() {\n\n\t\tboolean discoveryUsingCdp = true;\n\n\t\tif (m_config.hasUseCdpDiscovery()) {\n\t\t\tdiscoveryUsingCdp = m_config.getUseCdpDiscovery();\n\t\t}\n\n\t\treturn discoveryUsingCdp;\n\t}","id":80895,"modified_method":"/**\n\t * <p>useCdpDiscovery<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean useCdpDiscovery() {\n\t\tif (m_config.hasUseCdpDiscovery()) return m_config.getUseCdpDiscovery();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private boolean forceIpRouteDiscoveryOnEthernet() {\n\t\tboolean forceIpRouteDiscoveryOnEthernet = false;\n\n\t\tif (m_config.hasForceIpRouteDiscoveryOnEthernet()) {\n\t\t\tforceIpRouteDiscoveryOnEthernet = m_config.getForceIpRouteDiscoveryOnEthernet();\n\t\t}\n\n\t\treturn forceIpRouteDiscoveryOnEthernet;\n\t}","id":80896,"modified_method":"private boolean forceIpRouteDiscoveryOnEthernet() {\n\t\tif (m_config.hasForceIpRouteDiscoveryOnEthernet()) return m_config.getForceIpRouteDiscoveryOnEthernet();\n\t\treturn false;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * Returns a list of package names that the IP belongs to, null if none.\n     *\n     * <strong>Note: <\/strong>Evaluation of the interface against a package\n     * filter will only work if the IP is already in the database.\n     */\n    public synchronized List<String> getAllPackageMatches(String ipaddr) {\n        List<String> matchingPkgs = new ArrayList<String>();\n        \n        for (org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            String pkgName = pkg.getName();\n            boolean inPkg = interfaceInPackage(ipaddr, pkg);\n            if (inPkg) {\n                matchingPkgs.add(pkgName);\n            }\n        }\n    \n        return matchingPkgs;\n    }","id":80897,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * Returns a list of package names that the IP belongs to, null if none.\n     *\n     * <strong>Note: <\/strong>Evaluation of the interface against a package\n     * filter will only work if the IP is already in the database.\n     */\n    public synchronized List<String> getAllPackageMatches(final String ipaddr) {\n        final List<String> matchingPkgs = new ArrayList<String>();\n        \n        for (final org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            final String pkgName = pkg.getName();\n            if (interfaceInPackage(ipaddr, pkg)) {\n                matchingPkgs.add(pkgName);\n            }\n        }\n    \n        return matchingPkgs;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>saveStpInterfaceTable<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean saveStpInterfaceTable() {\n\n\t\tboolean download = true;\n\t\t\n\t\tif (m_config.hasSaveStpInterfaceTable()) {\n\t\t\tdownload = m_config.getSaveStpInterfaceTable();\n\t\t}\n\t\t\n\t\treturn download;\n\t}","id":80898,"modified_method":"/**\n\t * <p>saveStpInterfaceTable<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean saveStpInterfaceTable() {\n\t\tif (m_config.hasSaveStpInterfaceTable()) return m_config.getSaveStpInterfaceTable();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n\tpublic String getVlanClassName(String sysoid) {\n\n\t\tString defaultClassName = null;\n\t\tfor (String oidMask : m_oidMask2VlanclassName.keySet()) {\n\t\t\tif (sysoid.startsWith(oidMask)) {\n\t\t\t\treturn m_oidMask2VlanclassName.get(oidMask);\n\t\t\t}\n\t\t}\n\n\t\treturn defaultClassName;\n\n\t}","id":80899,"modified_method":"/** {@inheritDoc} */\n\tpublic String getVlanClassName(final String sysoid) {\n\t\tfor (final String oidMask : m_oidMask2VlanclassName.keySet()) {\n\t\t\tif (sysoid.startsWith(oidMask)) {\n\t\t\t\treturn m_oidMask2VlanclassName.get(oidMask);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpCollection createCollection(String ipaddr) {\n\t\tSnmpCollection coll = null;\n    \ttry {\n\t\t\tcoll = new SnmpCollection(SnmpPeerFactory\n\t\t\t\t\t.getInstance()\n\t\t\t\t\t.getAgentConfig(InetAddress.getByName(ipaddr)));\n\t\t} catch (Throwable t) {\n\t\t\tlog().error(\n\t\t\t\t\t\"getSnmpCollection: Failed to load snmpcollection parameter from snmp configuration file \"\n\t\t\t\t\t\t\t+ t);\n\t\t}\n\n\t\treturn coll;\n    }","id":80900,"modified_method":"private SnmpCollection createCollection(final String ipaddr) {\n\t\tSnmpCollection coll = null;\n    \ttry {\n\t\t\tcoll = new SnmpCollection(SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(ipaddr)));\n    \t} catch (final Throwable t) {\n\t\t    LogUtils.errorf(this, t, \"getSnmpCollection: Failed to load snmpcollection parameter from snmp configuration file\");\n\t\t}\n\n\t\treturn coll;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void createUrlIpMap() {\n\n        m_urlIPMap = new HashMap<String, List<String>>();\n\n        for (org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            for (String urlname : pkg.getIncludeUrlCollection()) {\n                java.util.List<String> iplist = IpListFromUrl.parse(urlname);\n                if (iplist.size() > 0) {\n                    m_urlIPMap.put(urlname, iplist);\n                }\n            }\n        }\n    }","id":80901,"modified_method":"private void createUrlIpMap() {\n        for (final org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            if (pkg == null) continue;\n            for (final String urlname : pkg.getIncludeUrlCollection()) {\n                final java.util.List<String> iplist = IpListFromUrl.parse(urlname);\n                if (iplist.size() > 0) {\n                    m_urlIPMap.put(urlname, iplist);\n                }\n            }\n        }\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public List<SnmpCollection> getSnmpCollections(String ipaddr, String sysoid) {\n\t\n    \tList<SnmpCollection> snmpcolls = new ArrayList<SnmpCollection>();\n\t\t\n    \tIterator<String> ite = getAllPackageMatches(ipaddr).iterator();\n    \t\n    \twhile (ite.hasNext()) {\n\t\t\tsnmpcolls.add(populateSnmpCollection(createCollection(ipaddr),getPackage(ite.next()),sysoid));\n    \t}\n\n    \treturn snmpcolls;\n    }","id":80902,"modified_method":"/** {@inheritDoc} */\n    public List<SnmpCollection> getSnmpCollections(final String ipaddr, final String sysoid) {\n    \tList<SnmpCollection> snmpcolls = new ArrayList<SnmpCollection>();\n\n    \tIterator<String> ite = getAllPackageMatches(ipaddr).iterator();\n    \t\n    \twhile (ite.hasNext()) {\n\t\t\tfinal String pkgName = ite.next();\n            snmpcolls.add(getSnmpCollection(ipaddr, sysoid, pkgName));\n    \t}\n\n    \treturn snmpcolls;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getThreads<\/p>\n\t *\n\t * @return a int.\n\t */\n\tpublic int getThreads() {\n\n\t\tint threads = 5;\n\n\t\tif (m_config.hasThreads()) {\n\t\t\tthreads = m_config.getThreads();\n\t\t}\n\n\t\treturn threads;\n\t}","id":80903,"modified_method":"/**\n\t * <p>getThreads<\/p>\n\t *\n\t * @return a int.\n\t */\n\tpublic int getThreads() {\n\t\tif (m_config.hasThreads()) return m_config.getThreads();\n\t\treturn 5;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to determine if the named interface is included in\n     * the passed package's URL includes. If the interface is found in any of\n     * the URL files, then a value of true is returned, else a false value is\n     * returned.\n     * \n     * <pre>\n     * \n     *  The file URL is read and each entry in this file checked. Each line\n     *   in the URL file can be one of -\n     *   &lt;IP&gt;&lt;space&gt;#&lt;comments&gt;\n     *   or\n     *   &lt;IP&gt;\n     *   or\n     *   #&lt;comments&gt;\n     *  \n     *   Lines starting with a '#' are ignored and so are characters after\n     *   a '&lt;space&gt;#' in a line.\n     *  \n     * <\/pre>\n     * \n     * @param addr\n     *            The interface to test against the package's URL\n     * @param url\n     *            The URL file to read\n     * \n     * @return True if the interface is included in the URL, false otherwise.\n     */\n    private boolean interfaceInUrl(String addr, String url) {\n        boolean bRet = false;\n    \n        // get list of IPs in this URL\n        java.util.List<String> iplist = m_urlIPMap.get(url);\n        if (iplist != null && iplist.size() > 0) {\n            bRet = iplist.contains(addr);\n        }\n    \n        return bRet;\n    }","id":80904,"modified_method":"/**\n     * This method is used to determine if the named interface is included in\n     * the passed package's URL includes. If the interface is found in any of\n     * the URL files, then a value of true is returned, else a false value is\n     * returned.\n     * \n     * <pre>\n     * \n     *  The file URL is read and each entry in this file checked. Each line\n     *   in the URL file can be one of -\n     *   &lt;IP&gt;&lt;space&gt;#&lt;comments&gt;\n     *   or\n     *   &lt;IP&gt;\n     *   or\n     *   #&lt;comments&gt;\n     *  \n     *   Lines starting with a '#' are ignored and so are characters after\n     *   a '&lt;space&gt;#' in a line.\n     *  \n     * <\/pre>\n     * \n     * @param addr\n     *            The interface to test against the package's URL\n     * @param url\n     *            The URL file to read\n     * \n     * @return True if the interface is included in the URL, false otherwise.\n     */\n    private boolean interfaceInUrl(final String addr, final String url) {\n        // get list of IPs in this URL\n        final List<String> iplist = m_urlIPMap.get(url);\n        if (iplist != null && iplist.size() > 0) {\n            return iplist.contains(addr);\n        }\n    \n        return false;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public boolean hasIpRouteClassName(String sysoid) {\n\n            for (String oidMask : m_oidMask2IpRouteclassName.keySet()) {\n                        if (sysoid.startsWith(oidMask)) {\n                                return true;\n                        }\n                }\n\n                return false;\n    }","id":80905,"modified_method":"/** {@inheritDoc} */\n    public boolean hasIpRouteClassName(final String sysoid) {\n        for (final String oidMask : m_oidMask2IpRouteclassName.keySet()) {\n            if (sysoid.startsWith(oidMask)) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>useIpRouteDiscovery<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean useIpRouteDiscovery() {\n\n\t\tboolean discoveryUsingRoutes = true;\n\n\t\tif (m_config.hasUseIpRouteDiscovery()) {\n\t\t\tdiscoveryUsingRoutes = m_config.getUseIpRouteDiscovery();\n\t\t}\n\n\t\treturn discoveryUsingRoutes;\n\t}","id":80906,"modified_method":"/**\n\t * <p>useIpRouteDiscovery<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean useIpRouteDiscovery() {\n\t\tif (m_config.hasUseIpRouteDiscovery()) return m_config.getUseIpRouteDiscovery();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>enableVlanDiscovery<\/p>\n\t *\n\t * @return boolean enable-vlan-discovery\n\t */\n\tpublic boolean enableVlanDiscovery() {\n\n\t\tboolean vlandiscovery = true; \n\t\tif (m_config.hasEnableVlanDiscovery()) {\n\t\t\tvlandiscovery = m_config.getEnableVlanDiscovery();\n\t\t}\n\n\t\treturn vlandiscovery;\n\t}","id":80907,"modified_method":"public boolean enableVlanDiscovery() {\n\t\tif (m_config.hasEnableVlanDiscovery()) return m_config.getEnableVlanDiscovery();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>useBridgeDiscovery<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean useBridgeDiscovery() {\n\n\t\tboolean discoveryUsingBridge = true;\n\n\t\tif (m_config.hasUseBridgeDiscovery()) {\n\t\t\tdiscoveryUsingBridge = m_config.getUseBridgeDiscovery();\n\t\t}\n\n\t\treturn discoveryUsingBridge;\n\t}","id":80908,"modified_method":"/**\n\t * <p>useBridgeDiscovery<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean useBridgeDiscovery() {\n\t\tif (m_config.hasUseBridgeDiscovery()) return m_config.getUseBridgeDiscovery();\n\t\treturn true;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>interfaceInPackageRange<\/p>\n     *\n     * @param iface a {@link java.lang.String} object.\n     * @param pkg a org$opennms$netmgt$config$linkd$Package object.\n     * @return a boolean.\n     */\n    public synchronized boolean interfaceInPackageRange(String iface, org.opennms.netmgt.config.linkd.Package pkg) {\n    \n        //\n        // Ensure that the interface is in the specific list or\n        // that it is in the include range and is not excluded\n        //\n        boolean has_specific = false;\n        boolean has_range_include = false;\n        boolean has_range_exclude = false;\n \n        // if there are NO include ranges then treat act as if the user include\n        // the range 0.0.0.0 - 255.255.255.255\n        has_range_include = pkg.getIncludeRangeCount() == 0 && pkg.getSpecificCount() == 0;\n        \n        long addr = IPSorter.convertToLong(iface);\n        Enumeration<IncludeRange> eincs = pkg.enumerateIncludeRange();\n        while (!has_range_include && eincs.hasMoreElements()) {\n            IncludeRange rng = eincs.nextElement();\n            long start = IPSorter.convertToLong(rng.getBegin());\n            if (addr > start) {\n                long end = IPSorter.convertToLong(rng.getEnd());\n                if (addr <= end) {\n                    has_range_include = true;\n                }\n            } else if (addr == start) {\n                has_range_include = true;\n            }\n        }\n    \n        Enumeration<String> espec = pkg.enumerateSpecific();\n        while (!has_specific && espec.hasMoreElements()) {\n            long speca = IPSorter.convertToLong(espec.nextElement());\n            if (speca == addr)\n                has_specific = true;\n        }\n    \n        Enumeration<String> eurl = pkg.enumerateIncludeUrl();\n        while (!has_specific && eurl.hasMoreElements()) {\n            has_specific = interfaceInUrl(iface, eurl.nextElement());\n        }\n    \n        Enumeration<ExcludeRange> eex = pkg.enumerateExcludeRange();\n        while (!has_range_exclude && !has_specific && eex.hasMoreElements()) {\n            ExcludeRange rng = eex.nextElement();\n            long start = IPSorter.convertToLong(rng.getBegin());\n            if (addr > start) {\n                long end = IPSorter.convertToLong(rng.getEnd());\n                if (addr <= end) {\n                    has_range_exclude = true;\n                }\n            } else if (addr == start) {\n                has_range_exclude = true;\n            }\n        }\n    \n        return has_specific || (has_range_include && !has_range_exclude);\n    }","id":80909,"modified_method":"/**\n     * <p>interfaceInPackageRange<\/p>\n     *\n     * @param iface a {@link java.lang.String} object.\n     * @param pkg a org$opennms$netmgt$config$linkd$Package object.\n     * @return a boolean.\n     */\n    public synchronized boolean interfaceInPackageRange(final String iface, final org.opennms.netmgt.config.linkd.Package pkg) {\n        if (pkg == null) return false;\n\n        //\n        // Ensure that the interface is in the specific list or\n        // that it is in the include range and is not excluded\n        //\n        boolean has_specific = false;\n        boolean has_range_include = false;\n        boolean has_range_exclude = false;\n \n        long addr = IPSorter.convertToLong(iface);\n\n        // if there are NO include ranges then treat act as if the user include\n        // the range 0.0.0.0 - 255.255.255.255\n        has_range_include = pkg.getIncludeRangeCount() == 0 && pkg.getSpecificCount() == 0;\n\n        // Specific wins; if we find one, return immediately.\n        for (final String spec : pkg.getSpecificCollection()) {\n            final long speca = IPSorter.convertToLong(spec);\n            if (speca == addr) {\n                has_specific = true;\n                break;\n            }\n        }\n        if (has_specific) return true;\n\n        for (final String url : pkg.getIncludeUrlCollection()) {\n            has_specific = interfaceInUrl(iface, url);\n            if (has_specific) break;\n        }\n        if (has_specific) return true;\n\n        if (!has_range_include) {\n            for (final IncludeRange rng : pkg.getIncludeRangeCollection()) {\n                final long start = IPSorter.convertToLong(rng.getBegin());\n                if (addr > start) {\n                    final long end = IPSorter.convertToLong(rng.getEnd());\n                    if (addr <= end) {\n                        has_range_include = true;\n                        break;\n                    }\n                } else if (addr == start) {\n                    has_range_include = true;\n                    break;\n                }\n            }\n        }\n\n        for (final ExcludeRange rng : pkg.getExcludeRangeCollection()) {\n            long start = IPSorter.convertToLong(rng.getBegin());\n            if (addr > start) {\n                long end = IPSorter.convertToLong(rng.getEnd());\n                if (addr <= end) {\n                    has_range_exclude = true;\n                    break;\n                }\n            } else if (addr == start) {\n                has_range_exclude = true;\n                break;\n            }\n        }\n\n        return has_range_include && !has_range_exclude;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to establish package against IP list mapping, with\n     * which, the IP list is selected per package via the configured filter rules\n     * from the database.\n     */\n    public void createPackageIpListMap() {\n        m_pkgIpMap = new HashMap<org.opennms.netmgt.config.linkd.Package, List<String>>();\n\n        for (org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            //\n            // Get a list of IP addresses per package against the filter rules from\n            // database and populate the package, IP list map.\n            //\n            try {\n                List<String> ipList = getIpList(pkg);\n                if (log().isDebugEnabled())\n                    log().debug(\"createPackageIpMap: package \" + pkg.getName() + \": ipList size =  \" + ipList.size());\n    \n                if (ipList.size() > 0) {\n                    m_pkgIpMap.put(pkg, ipList);\n                }\n            } catch (Throwable t) {\n                log().error(\"createPackageIpMap: failed to map package: \" + pkg.getName() + \" to an IP List: \" + t, t);\n            }\n        }\n    }","id":80910,"modified_method":"/**\n     * This method is used to establish package against IP list mapping, with\n     * which, the IP list is selected per package via the configured filter rules\n     * from the database.\n     */\n    public void createPackageIpListMap() {\n        for (final org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            //\n            // Get a list of IP addresses per package against the filter rules from\n            // database and populate the package, IP list map.\n            //\n            try {\n                final List<String> ipList = getIpList(pkg);\n                LogUtils.tracef(this, \"createPackageIpMap: package %s: ipList size = %d\", pkg.getName(), ipList.size());\n\n                if (ipList != null && ipList.size() > 0) {\n                    m_pkgIpMap.put(pkg, ipList);\n                }\n            } catch (final Throwable t) {\n                LogUtils.errorf(this, t, \"createPackageIpMap: failed to map package: %s to an IP list\", pkg.getName());\n            }\n        }\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getSnmpPollInterval<\/p>\n\t *\n\t * @return a long.\n\t */\n\tpublic long getSnmpPollInterval() {\n\n\t\tlong snmppollinterval = 900000;\n\n\t\tif (m_config.hasSnmp_poll_interval()) {\n\t\t\tsnmppollinterval = m_config.getSnmp_poll_interval();\n\t\t}\n\n\t\treturn snmppollinterval;\n\t}","id":80911,"modified_method":"public long getSnmpPollInterval() {\n\t\tif (m_config.hasSnmp_poll_interval()) return m_config.getSnmp_poll_interval();\n        return 900000;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public SnmpCollection getSnmpCollection(String ipaddr, String sysoid,String pkgName) {\n    \t\n    \tIterator<String> ite = getAllPackageMatches(ipaddr).iterator();\n    \twhile (ite.hasNext()) {\n    \t\tif (ite.next().equals(pkgName))\n    \t\t\t\treturn populateSnmpCollection(createCollection(ipaddr),getPackage(pkgName),sysoid);\n    \t}\n    \treturn null;\n    }","id":80912,"modified_method":"/** {@inheritDoc} */\n    public SnmpCollection getSnmpCollection(final String ipaddr, final String sysoid, final String pkgName) {\n        final Package pkg = getPackage(pkgName);\n        if (pkg != null) {\n            final SnmpCollection collection = createCollection(ipaddr);\n            populateSnmpCollection(collection, pkg, sysoid);\n            return collection;\n        }\n        return null;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public DiscoveryLink getDiscoveryLink(String pkgName) {\n\t\tDiscoveryLink discoveryLink = new DiscoveryLink();\n\n\t\tPackage pkg = getPackage(pkgName);\n\t\t\n\t\tdiscoveryLink.setPackageName(pkg.getName());\n\n\t\tif (pkg.hasSnmp_poll_interval()) discoveryLink.setSnmpPollInterval(pkg.getSnmp_poll_interval());\n\t\telse discoveryLink.setSnmpPollInterval(getSnmpPollInterval());\n\t\t\n\t\tif (pkg.hasDiscovery_link_interval()) discoveryLink.setDiscoveryInterval(pkg.getDiscovery_link_interval());\n\t\telse discoveryLink.setDiscoveryInterval(getDiscoveryLinkInterval());\n\t\t\n\t\tdiscoveryLink.setInitialSleepTime(getInitialSleepTime());\n\t\t\n\t\tif (pkg.hasUseBridgeDiscovery()) discoveryLink.setDiscoveryUsingBridge(pkg.getUseBridgeDiscovery());\n\t\telse discoveryLink.setDiscoveryUsingBridge(useBridgeDiscovery());\n\t\tif (pkg.hasUseCdpDiscovery()) discoveryLink.setDiscoveryUsingCdp(pkg.getUseCdpDiscovery());\n\t\telse discoveryLink.setDiscoveryUsingCdp(useCdpDiscovery());\n\t\tif (pkg.hasUseIpRouteDiscovery()) discoveryLink.setDiscoveryUsingCdp(pkg.getUseIpRouteDiscovery());\n\t\telse discoveryLink.setDiscoveryUsingRoutes(useIpRouteDiscovery());\n\t\tif (pkg.hasEnableDiscoveryDownload()) discoveryLink.setEnableDownloadDiscovery(pkg.getEnableDiscoveryDownload());\n\t\telse discoveryLink.setEnableDownloadDiscovery(enableDiscoveryDownload());\n\t\tif (pkg.hasForceIpRouteDiscoveryOnEthernet()) discoveryLink.setForceIpRouteDiscoveryOnEtherNet(pkg.getForceIpRouteDiscoveryOnEthernet());\n\t\telse discoveryLink.setForceIpRouteDiscoveryOnEtherNet(forceIpRouteDiscoveryOnEthernet());\n\t\treturn discoveryLink;\n    }","id":80913,"modified_method":"/** {@inheritDoc} */\n    public DiscoveryLink getDiscoveryLink(final String pkgName) {\n        final Package pkg = getPackage(pkgName);\n\n        if (pkg == null) return null;\n\n        final DiscoveryLink discoveryLink = new DiscoveryLink();\n        discoveryLink.setPackageName(pkg.getName());\n        discoveryLink.setInitialSleepTime(getInitialSleepTime());\n\n\t\tdiscoveryLink.setSnmpPollInterval(pkg.hasSnmp_poll_interval()? pkg.getSnmp_poll_interval() : getSnmpPollInterval());\n\t\tdiscoveryLink.setDiscoveryInterval(pkg.hasDiscovery_link_interval()? pkg.getDiscovery_link_interval() : getDiscoveryLinkInterval());\n\t\tdiscoveryLink.setDiscoveryUsingBridge(pkg.hasUseBridgeDiscovery()? pkg.getUseBridgeDiscovery() : useBridgeDiscovery());\n\t\tdiscoveryLink.setDiscoveryUsingCdp(pkg.hasUseCdpDiscovery()? pkg.getUseCdpDiscovery() : useCdpDiscovery());\n\t\tdiscoveryLink.setDiscoveryUsingRoutes(pkg.hasUseIpRouteDiscovery()? pkg.getUseIpRouteDiscovery() : useIpRouteDiscovery());\n\t\tdiscoveryLink.setEnableDownloadDiscovery(pkg.hasEnableDiscoveryDownload()? pkg.getEnableDiscoveryDownload() : enableDiscoveryDownload());\n\t\tdiscoveryLink.setForceIpRouteDiscoveryOnEtherNet(pkg.hasForceIpRouteDiscoveryOnEthernet()? pkg.getForceIpRouteDiscoveryOnEthernet() : forceIpRouteDiscoveryOnEthernet());\n\n\t\treturn discoveryLink;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getDiscoveryLinkInterval<\/p>\n\t *\n\t * @return a long.\n\t */\n\tpublic long getDiscoveryLinkInterval() {\n\n\t\tlong discoverylinkinterval = 3600000;\n\n\t\tif (m_config.hasSnmp_poll_interval()) {\n\t\t\tdiscoverylinkinterval = m_config\n\t\t\t\t\t.getDiscovery_link_interval();\n\t\t}\n\n\t\treturn discoverylinkinterval;\n\t}","id":80914,"modified_method":"public long getDiscoveryLinkInterval() {\n\t\tif (m_config.hasSnmp_poll_interval()) return m_config.getDiscovery_link_interval();\n\t\treturn 3600000;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>enableDiscoveryDownload<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean enableDiscoveryDownload() {\n\t\tboolean enable=false;\n\t\tif (m_config.hasEnableDiscoveryDownload()) \n\t\t\tenable = m_config.getEnableDiscoveryDownload();\n\t\treturn enable;\n\t}","id":80915,"modified_method":"/**\n\t * <p>enableDiscoveryDownload<\/p>\n\t *\n\t * @return a boolean.\n\t */\n\tpublic boolean enableDiscoveryDownload() {\n\t\tif (m_config.hasEnableDiscoveryDownload()) return m_config.getEnableDiscoveryDownload();\n\t\treturn false;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>autoDiscovery<\/p>\n\t *\n\t * @return boolean auto-discovery\n\t */\n\tpublic boolean autoDiscovery() {\n\n\t\tboolean autodiscovery = false; \n\t\tif (m_config.hasAutoDiscovery()) {\n\t\t\tautodiscovery = m_config.getAutoDiscovery();\n\t\t}\n\n\t\treturn autodiscovery;\n\t}","id":80916,"modified_method":"public boolean autoDiscovery() {\n\t\tif (m_config.hasAutoDiscovery()) return m_config.getAutoDiscovery();\n\t\treturn false;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public List<String> getIpList(Package pkg) {\n        StringBuffer filterRules = new StringBuffer(pkg.getFilter().getContent());\n        \n        if (log().isDebugEnabled())\n            log().debug(\"createPackageIpMap: package is \" + pkg.getName() + \". filer rules are  \" + filterRules.toString());\n        List<String> ipList = FilterDaoFactory.getInstance().getIPList(filterRules.toString());\n        return ipList;\n    }","id":80917,"modified_method":"/** {@inheritDoc} */\n    public List<String> getIpList(final Package pkg) {\n        if (pkg == null) return null;\n\n        final Filter filter = pkg.getFilter();\n        if (filter == null) return null;\n\n        final StringBuffer filterRules = new StringBuffer(filter.getContent());\n\n        LogUtils.debugf(this, \"createPackageIpMap: package is %s. filter rules are: %s\", pkg.getName(), filterRules.toString());\n        return FilterDaoFactory.getInstance().getIPList(filterRules.toString());\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n\tpublic boolean hasClassName(String sysoid) {\n\n\t    for (String oidMask : m_oidMask2VlanclassName.keySet()) {\n\t\t\tif (sysoid.startsWith(oidMask)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":80918,"modified_method":"/** {@inheritDoc} */\n\tpublic boolean hasClassName(final String sysoid) {\n\t    for (final String oidMask : m_oidMask2VlanclassName.keySet()) {\n\t\t\tif (sysoid.startsWith(oidMask)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves the current in-memory configuration to disk and reloads\n     *\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws java.io.IOException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     */\n    public synchronized void save() throws MarshalException, IOException, ValidationException {\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(m_config, stringWriter);\n        saveXml(stringWriter.toString());\n    \n        update();\n    }","id":80919,"modified_method":"/**\n     * Saves the current in-memory configuration to disk and reloads\n     *\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws java.io.IOException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     */\n    public synchronized void save() throws MarshalException, IOException, ValidationException {\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config isn't lost if the xml from the marshall is hosed.\n        final StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(m_config, stringWriter);\n        saveXml(stringWriter.toString());\n    \n        update();\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * Returns the first package that the IP belongs to, null if none.\n     *\n     * <strong>Note: <\/strong>Evaluation of the interface against a package\n     * filter will only work if the IP is already in the database.\n     */\n    public synchronized org.opennms.netmgt.config.linkd.Package getFirstPackageMatch(String ipaddr) {\n        for (org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            boolean inPkg = interfaceInPackage(ipaddr, pkg);\n            if (inPkg)\n                return pkg;\n        }\n    \n        return null;\n    }","id":80920,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * Returns the first package that the IP belongs to, null if none.\n     *\n     * <strong>Note: <\/strong>Evaluation of the interface against a package\n     * filter will only work if the IP is already in the database.\n     */\n    public synchronized org.opennms.netmgt.config.linkd.Package getFirstPackageMatch(final String ipaddr) {\n        for (final org.opennms.netmgt.config.linkd.Package pkg : m_config.getPackageCollection()) {\n            if (interfaceInPackage(ipaddr, pkg)) {\n                return pkg;\n            }\n        }\n    \n        return null;\n    }","commit_id":"0d7f44532b8c27d5e67102fba1dce15403b449a4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void updateFilterMappings(String filterName, Filter filter) {\n\t\tfor (int i = 0; i < _filterMappings.size(); i++) {\n\t\t\tFilterMapping filterMapping = _filterMappings.get(i);\n\n\t\t\tif (filterName.equals(filterMapping.getFilterName())) {\n\t\t\t\t_filterMappings.set(i, filterMapping.replaceFilter(filter));\n\t\t\t}\n\t\t}\n\t}","id":80921,"modified_method":"public void updateFilterMappings(String filterName, Filter filter) {\n\t\tList<FilterMapping> filterMappings = _filterMappings.get(filterName);\n\n\t\tif (filterMappings == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < filterMappings.size(); i++) {\n\t\t\tFilterMapping filterMapping = filterMappings.get(i);\n\n\t\t\tfilterMappings.set(i, filterMapping.replaceFilter(filter));\n\t\t}\n\t}","commit_id":"1c44e410a5a0ccfad8204a22ddef0c891b02f67a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void registerFilterMapping(\n\t\tFilterMapping filterMapping, String filterName, boolean after) {\n\n\t\tint x = 0;\n\t\tint y = 0;\n\n\t\tif (Validator.isNotNull(filterName)) {\n\t\t\tfor (; x < _filterMappings.size(); x++) {\n\t\t\t\tFilterMapping currentFilterMapping = _filterMappings.get(x);\n\n\t\t\t\tif (filterName.equals(currentFilterMapping.getFilterName())) {\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\ty = x;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (after) {\n\t\t\tx = ++y;\n\t\t}\n\n\t\t_filterMappings.add(x, filterMapping);\n\n\t\tfor (InvokerFilter invokerFilter : _invokerFilters) {\n\t\t\tinvokerFilter.clearFilterChainsCache();\n\t\t}\n\t}","id":80922,"modified_method":"public void registerFilterMapping(\n\t\tFilterMapping filterMapping, String filterName, boolean after) {\n\n\t\tList<FilterMapping> filterMappings = _filterMappings.get(filterName);\n\n\t\tif (filterMappings == null) {\n\t\t\tfilterMappings = new ArrayList<>();\n\n\t\t\t_filterMappings.put(filterName, filterMappings);\n\n\t\t\t_filterMappingNames.add(filterName);\n\t\t}\n\n\t\tif (after) {\n\t\t\tfilterMappings.add(filterMapping);\n\t\t}\n\t\telse {\n\t\t\tfilterMappings.add(0, filterMapping);\n\t\t}\n\n\t\tfor (InvokerFilter invokerFilter : _invokerFilters) {\n\t\t\tinvokerFilter.clearFilterChainsCache();\n\t\t}\n\t}","commit_id":"1c44e410a5a0ccfad8204a22ddef0c891b02f67a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected InvokerFilterChain createInvokerFilterChain(\n\t\tHttpServletRequest request, Dispatcher dispatcher, String uri,\n\t\tFilterChain filterChain) {\n\n\t\tInvokerFilterChain invokerFilterChain = new InvokerFilterChain(\n\t\t\tfilterChain);\n\n\t\tfor (FilterMapping filterMapping : _filterMappings) {\n\t\t\tif (filterMapping.isMatch(request, dispatcher, uri)) {\n\t\t\t\tFilter filter = filterMapping.getFilter();\n\n\t\t\t\tinvokerFilterChain.addFilter(filter);\n\t\t\t}\n\t\t}\n\n\t\treturn invokerFilterChain;\n\t}","id":80923,"modified_method":"protected InvokerFilterChain createInvokerFilterChain(\n\t\tHttpServletRequest request, Dispatcher dispatcher, String uri,\n\t\tFilterChain filterChain) {\n\n\t\tInvokerFilterChain invokerFilterChain = new InvokerFilterChain(\n\t\t\tfilterChain);\n\n\t\tfor (String filterName : _filterMappingNames) {\n\t\t\tList<FilterMapping> filterMappings = _filterMappings.get(\n\t\t\t\tfilterName);\n\n\t\t\tif (filterMappings == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (FilterMapping filterMapping : filterMappings) {\n\t\t\t\tif (filterMapping.isMatch(request, dispatcher, uri)) {\n\t\t\t\t\tFilter filter = filterMapping.getFilter();\n\n\t\t\t\t\tinvokerFilterChain.addFilter(filter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invokerFilterChain;\n\t}","commit_id":"1c44e410a5a0ccfad8204a22ddef0c891b02f67a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void unregisterFilter(String filterName) {\n\t\tFilter filter = null;\n\n\t\tfor (FilterMapping filterMapping : _filterMappings) {\n\t\t\tif (filterName.equals(filterMapping.getFilterName())) {\n\t\t\t\t_filterMappings.remove(filterMapping);\n\n\t\t\t\tif (filter == null) {\n\t\t\t\t\tfilter = filterMapping.getFilter();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfilter.destroy();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (InvokerFilter invokerFilter : _invokerFilters) {\n\t\t\tinvokerFilter.clearFilterChainsCache();\n\t\t}\n\t}","id":80924,"modified_method":"public void unregisterFilter(String filterName) {\n\t\tList<FilterMapping> filterMappings = _filterMappings.remove(filterName);\n\n\t\tif (filterMappings == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tFilterMapping filterMapping = filterMappings.get(0);\n\n\t\tFilter filter = filterMapping.getFilter();\n\n\t\tif (filter != null) {\n\t\t\ttry {\n\t\t\t\tfilter.destroy();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\t_filterMappingNames.remove(filterName);\n\n\t\tfor (InvokerFilter invokerFilter : _invokerFilters) {\n\t\t\tinvokerFilter.clearFilterChainsCache();\n\t\t}\n\t}","commit_id":"1c44e410a5a0ccfad8204a22ddef0c891b02f67a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readLiferayFilterWebXML(\n\t\t\tServletContext servletContext, String path)\n\t\tthrows Exception {\n\n\t\tInputStream inputStream = servletContext.getResourceAsStream(path);\n\n\t\tif (inputStream == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(inputStream, true);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tMap<String, ObjectValuePair<Filter, FilterConfig>>\n\t\t\tfilterObjectValuePairs = new HashMap<>();\n\n\t\tfor (Element filterElement : rootElement.elements(\"filter\")) {\n\t\t\tString filterName = filterElement.elementText(\"filter-name\");\n\t\t\tString filterClassName = filterElement.elementText(\"filter-class\");\n\n\t\t\tMap<String, String> initParameterMap = new HashMap<>();\n\n\t\t\tList<Element> initParamElements = filterElement.elements(\n\t\t\t\t\"init-param\");\n\n\t\t\tfor (Element initParamElement : initParamElements) {\n\t\t\t\tString name = initParamElement.elementText(\"param-name\");\n\t\t\t\tString value = initParamElement.elementText(\"param-value\");\n\n\t\t\t\tinitParameterMap.put(name, value);\n\t\t\t}\n\n\t\t\tFilterConfig filterConfig = new InvokerFilterConfig(\n\t\t\t\tservletContext, filterName, initParameterMap);\n\n\t\t\tFilter filter = initFilter(\n\t\t\t\tservletContext, filterClassName, filterName, filterConfig);\n\n\t\t\tif (filter != null) {\n\t\t\t\tfilterObjectValuePairs.put(\n\t\t\t\t\tfilterName, new ObjectValuePair<>(filter, filterConfig));\n\t\t\t}\n\t\t}\n\n\t\tList<Element> filterMappingElements = rootElement.elements(\n\t\t\t\"filter-mapping\");\n\n\t\tfor (Element filterMappingElement : filterMappingElements) {\n\t\t\tString filterName = filterMappingElement.elementText(\"filter-name\");\n\n\t\t\tList<String> urlPatterns = new ArrayList<>();\n\n\t\t\tList<Element> urlPatternElements = filterMappingElement.elements(\n\t\t\t\t\"url-pattern\");\n\n\t\t\tfor (Element urlPatternElement : urlPatternElements) {\n\t\t\t\turlPatterns.add(urlPatternElement.getTextTrim());\n\t\t\t}\n\n\t\t\tList<String> dispatchers = new ArrayList<>(4);\n\n\t\t\tList<Element> dispatcherElements = filterMappingElement.elements(\n\t\t\t\t\"dispatcher\");\n\n\t\t\tfor (Element dispatcherElement : dispatcherElements) {\n\t\t\t\tString dispatcher = StringUtil.toUpperCase(\n\t\t\t\t\tdispatcherElement.getTextTrim());\n\n\t\t\t\tdispatchers.add(dispatcher);\n\t\t\t}\n\n\t\t\tObjectValuePair<Filter, FilterConfig> filterObjectValuePair =\n\t\t\t\tfilterObjectValuePairs.get(filterName);\n\n\t\t\tif (filterObjectValuePair == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No filter and filter config exists with filter name \" +\n\t\t\t\t\t\t\tfilterName);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t_filterMappings.add(\n\t\t\t\tnew FilterMapping(\n\t\t\t\t\tfilterObjectValuePair.getKey(),\n\t\t\t\t\tfilterObjectValuePair.getValue(), urlPatterns, dispatchers,\n\t\t\t\t\tfilterName));\n\t\t}\n\t}","id":80925,"modified_method":"protected void readLiferayFilterWebXML(\n\t\t\tServletContext servletContext, String path)\n\t\tthrows Exception {\n\n\t\tInputStream inputStream = servletContext.getResourceAsStream(path);\n\n\t\tif (inputStream == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(inputStream, true);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tMap<String, ObjectValuePair<Filter, FilterConfig>>\n\t\t\tfilterObjectValuePairs = new HashMap<>();\n\n\t\tfor (Element filterElement : rootElement.elements(\"filter\")) {\n\t\t\tString filterName = filterElement.elementText(\"filter-name\");\n\t\t\tString filterClassName = filterElement.elementText(\"filter-class\");\n\n\t\t\tMap<String, String> initParameterMap = new HashMap<>();\n\n\t\t\tList<Element> initParamElements = filterElement.elements(\n\t\t\t\t\"init-param\");\n\n\t\t\tfor (Element initParamElement : initParamElements) {\n\t\t\t\tString name = initParamElement.elementText(\"param-name\");\n\t\t\t\tString value = initParamElement.elementText(\"param-value\");\n\n\t\t\t\tinitParameterMap.put(name, value);\n\t\t\t}\n\n\t\t\tFilterConfig filterConfig = new InvokerFilterConfig(\n\t\t\t\tservletContext, filterName, initParameterMap);\n\n\t\t\tFilter filter = initFilter(\n\t\t\t\tservletContext, filterClassName, filterName, filterConfig);\n\n\t\t\tif (filter != null) {\n\t\t\t\tfilterObjectValuePairs.put(\n\t\t\t\t\tfilterName, new ObjectValuePair<>(filter, filterConfig));\n\t\t\t}\n\t\t}\n\n\t\tList<Element> filterMappingElements = rootElement.elements(\n\t\t\t\"filter-mapping\");\n\n\t\tfor (Element filterMappingElement : filterMappingElements) {\n\t\t\tString filterName = filterMappingElement.elementText(\"filter-name\");\n\n\t\t\tList<String> urlPatterns = new ArrayList<>();\n\n\t\t\tList<Element> urlPatternElements = filterMappingElement.elements(\n\t\t\t\t\"url-pattern\");\n\n\t\t\tfor (Element urlPatternElement : urlPatternElements) {\n\t\t\t\turlPatterns.add(urlPatternElement.getTextTrim());\n\t\t\t}\n\n\t\t\tList<String> dispatchers = new ArrayList<>(4);\n\n\t\t\tList<Element> dispatcherElements = filterMappingElement.elements(\n\t\t\t\t\"dispatcher\");\n\n\t\t\tfor (Element dispatcherElement : dispatcherElements) {\n\t\t\t\tString dispatcher = StringUtil.toUpperCase(\n\t\t\t\t\tdispatcherElement.getTextTrim());\n\n\t\t\t\tdispatchers.add(dispatcher);\n\t\t\t}\n\n\t\t\tObjectValuePair<Filter, FilterConfig> filterObjectValuePair =\n\t\t\t\tfilterObjectValuePairs.get(filterName);\n\n\t\t\tif (filterObjectValuePair == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No filter and filter config exists with filter name \" +\n\t\t\t\t\t\t\tfilterName);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFilterMapping filterMapping = new FilterMapping(\n\t\t\t\t\tfilterObjectValuePair.getKey(),\n\t\t\t\t\tfilterObjectValuePair.getValue(), urlPatterns, dispatchers,\n\t\t\t\t\tfilterName);\n\n\t\t\tList<FilterMapping> filterMappings = _filterMappings.get(\n\t\t\t\tfilterName);\n\n\t\t\tif (filterMappings == null) {\n\t\t\t\tfilterMappings = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfilterMappings.add(filterMapping);\n\n\t\t\t_filterMappingNames.add(filterName);\n\t\t}\n\t}","commit_id":"1c44e410a5a0ccfad8204a22ddef0c891b02f67a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void destroy() {\n\t\t_serviceTracker.close();\n\n\t\tSet<Filter> filters = new HashSet<>();\n\n\t\tfor (FilterMapping filterMapping : _filterMappings) {\n\t\t\tFilter filter = filterMapping.getFilter();\n\n\t\t\tif (filters.add(filter)) {\n\t\t\t\ttry {\n\t\t\t\t\tfilter.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_filterMappings.clear();\n\n\t\tfor (InvokerFilter invokerFilter : _invokerFilters) {\n\t\t\tinvokerFilter.clearFilterChainsCache();\n\t\t}\n\t}","id":80926,"modified_method":"public void destroy() {\n\t\t_serviceTracker.close();\n\n\t\tfor (List<FilterMapping> filterMappings : _filterMappings.values()) {\n\t\t\tFilterMapping filterMapping = filterMappings.get(0);\n\n\t\t\tFilter filter = filterMapping.getFilter();\n\n\t\t\ttry {\n\t\t\t\tfilter.destroy();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\t_filterMappings.clear();\n\n\t\tfor (InvokerFilter invokerFilter : _invokerFilters) {\n\t\t\tinvokerFilter.clearFilterChainsCache();\n\t\t}\n\t}","commit_id":"1c44e410a5a0ccfad8204a22ddef0c891b02f67a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ServiceTrackerMapImpl(\n\t\tClass<S> clazz, String filterString,\n\t\tServiceReferenceMapper<K> serviceReferenceMapper,\n\t\tServiceTrackerBucketFactory<S, R> serviceTrackerMapBucketFactory) {\n\n\t\t_serviceReferenceMapper = serviceReferenceMapper;\n\t\t_serviceTrackerMapBucketFactory = serviceTrackerMapBucketFactory;\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tregistry.getFilter(\n\t\t\t\t\"(&(objectClass=\" + clazz.getName() + \")\" + filterString + \")\"),\n\t\t\tnew ServiceReferenceServiceTrackerCustomizer());\n\t}","id":80927,"modified_method":"public ServiceTrackerMapImpl(\n\t\tClass<S> clazz, String filterString,\n\t\tServiceReferenceMapper<K> serviceReferenceMapper,\n\t\tServiceTrackerBucketFactory<S, R> serviceTrackerMapBucketFactory) {\n\n\t\t_serviceReferenceMapper = serviceReferenceMapper;\n\t\t_serviceTrackerMapBucketFactory = serviceTrackerMapBucketFactory;\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tif (filterString != null) {\n\t\t\tFilter filter = registry.getFilter(\n\t\t\t\t\"(&(objectClass=\" + clazz.getName() + \")\" + filterString + \")\");\n\n\t\t\t_serviceTracker = registry.trackServices(\n\t\t\t\tfilter, new ServiceReferenceServiceTrackerCustomizer());\n\t\t}\n\t\telse {\n\t\t\t_serviceTracker = registry.trackServices(\n\t\t\t\tclazz, new ServiceReferenceServiceTrackerCustomizer());\n\t\t}\n\t}","commit_id":"76b6b6f6fe644efd3fde312fecc29e8cc2c9f84e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CantBeBlockedByOneAllEffect(int amount, FilterCreaturePermanent filter, Duration duration) {\r\n        super(duration, Outcome.Benefit);\r\n        this.amount = amount;\r\n        this.filter = filter;\r\n        StringBuilder sb = new StringBuilder(\"Each \").append(filter.getMessage()).append(\" can't be blocked \");\r\n        if (duration.equals(Duration.EndOfTurn)) {\r\n            sb.append(\"this turn \");\r\n        }\r\n        sb.append(\"except by \").append(CardUtil.numberToText(amount)).append(\" or more creatures\").toString();\r\n        staticText = sb.toString();\r\n    }","id":80928,"modified_method":"public CantBeBlockedByOneAllEffect(int amount, FilterCreaturePermanent filter, Duration duration) {\r\n        super(duration, Outcome.Benefit);\r\n        this.amount = amount;\r\n        this.filter = filter;\r\n        StringBuilder sb = new StringBuilder(\"each \").append(filter.getMessage()).append(\" can't be blocked \");\r\n        if (duration.equals(Duration.EndOfTurn)) {\r\n            sb.append(\"this turn \");\r\n        }\r\n        sb.append(\"except by \").append(CardUtil.numberToText(amount)).append(\" or more creatures\").toString();\r\n        staticText = sb.toString();\r\n    }","commit_id":"016737c73a5e0f1b0a43576a6c74cfef6869f5bd","url":"https://github.com/magefree/mage"},{"original_method":"public ExileFromGraveCost(TargetCardInYourGraveyard target) {\n        this.addTarget(target);\n        if (target.getMaxNumberOfTargets() > 1) {\n            this.text = \"Exile \" + \n                    (target.getNumberOfTargets() < target.getMaxNumberOfTargets() ? \"up to \":\"\") +\n                    CardUtil.numberToText(target.getMaxNumberOfTargets()) +\n                    \" \" +\n                    target.getTargetName();\n        }\n        else {\n            this.text = \"Exile \" + target.getTargetName();\n        }\n        if (!this.text.endsWith(\" from your graveyard\")) {\n            this.text = this.text + \" from your graveyard\";\n        }        \n    }","id":80929,"modified_method":"public ExileFromGraveCost(TargetCardInYourGraveyard target) {\n        this.addTarget(target);\n        if (target.getMaxNumberOfTargets() > 1) {\n            this.text = \"Exile \" +\n                    (target.getNumberOfTargets() == 1 && target.getMaxNumberOfTargets() == Integer.MAX_VALUE ? \"one or more\" :\n                        ((target.getNumberOfTargets() < target.getMaxNumberOfTargets() ? \"up to \":\"\")) +\n                            CardUtil.numberToText(target.getMaxNumberOfTargets())) +\n                    \" \" + target.getTargetName();\n        }\n        else {\n            this.text = \"Exile \" + target.getTargetName();\n        }\n        if (!this.text.endsWith(\" from your graveyard\")) {\n            this.text = this.text + \" from your graveyard\";\n        }        \n    }","commit_id":"016737c73a5e0f1b0a43576a6c74cfef6869f5bd","url":"https://github.com/magefree/mage"},{"original_method":"public HomicidalSeclusion(UUID ownerId) {\n        super(ownerId, 108, \"Homicidal Seclusion\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{4}{B}\");\n        this.expansionSetCode = \"AVR\";\n\n        this.color.setBlack(true);\n\n        // As long as you control exactly one creature, that creature gets +3/+1 and has lifelink.\n        ContinuousEffect boostEffect = new BoostControlledEffect(3, 1, Duration.WhileOnBattlefield);\n        Effect effect = new ConditionalContinuousEffect(boostEffect, new OneControlledCreatureCondition(), rule);\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\n        ContinuousEffect lifelinkEffect = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.WhileOnBattlefield);\n        effect = new ConditionalContinuousEffect(lifelinkEffect, new OneControlledCreatureCondition(), \"and has lifelink\");\n        ability.addEffect(effect);\n        this.addAbility(ability);\n\n        \n        \n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));\n    }","id":80930,"modified_method":"public HomicidalSeclusion(UUID ownerId) {\n        super(ownerId, 108, \"Homicidal Seclusion\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{4}{B}\");\n        this.expansionSetCode = \"AVR\";\n\n        // As long as you control exactly one creature, that creature gets +3/+1 and has lifelink.\n        ContinuousEffect boostEffect = new BoostControlledEffect(3, 1, Duration.WhileOnBattlefield);\n        Effect effect = new ConditionalContinuousEffect(boostEffect, new OneControlledCreatureCondition(), rule);\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\n        ContinuousEffect lifelinkEffect = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.WhileOnBattlefield);\n        effect = new ConditionalContinuousEffect(lifelinkEffect, new OneControlledCreatureCondition(), \"and has lifelink\");\n        ability.addEffect(effect);\n        this.addAbility(ability);\n    }","commit_id":"016737c73a5e0f1b0a43576a6c74cfef6869f5bd","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n     public String getText(Mode mode) {\r\n         if (staticText != null && !staticText.isEmpty()) {\r\n             return staticText;\r\n         }\r\n        StringBuilder sb = new StringBuilder(\"remove \");\r\n        sb.append(CardUtil.numberToText(counter.getCount(), \"a\"));\r\n        sb.append(\" \").append(counter.getName());\r\n        sb.append(counter.getCount() > 1 ?\" counters from \":\" counter from \");\r\n        sb.append(mode.getTargets().get(0).getTargetName());\r\n        return sb.toString();\r\n    }","id":80931,"modified_method":"@Override\r\n    public String getText(Mode mode) {\r\n        if (staticText != null && !staticText.isEmpty()) {\r\n            return staticText;\r\n        }\r\n\r\n        String text = \"remove \";\r\n        if(counter == null) {\r\n            text += \"a counter\";\r\n        }\r\n        else {\r\n           text += CardUtil.numberToText(counter.getCount(), \"a\") + \" \" + counter.getName();\r\n           text += counter.getCount() > 1 ? \" counters\" : \" counter\";\r\n        }\r\n        text += \" from target \" + mode.getTargets().get(0).getTargetName();\r\n        return text;\r\n    }","commit_id":"c33e7ad59b9c8e6e0c86c137b2bc234164e2d9d1","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent p = game.getPermanent(targetPointer.getFirst(game, source));\r\n        if (p != null && p.getCounters().getCount(counter.getName()) >= counter.getCount()) {\r\n            p.removeCounters(counter.getName(), counter.getCount(), game);\r\n            if (!game.isSimulation())\r\n                game.informPlayers(new StringBuilder(\"Removed \").append(counter.getCount()).append(\" \").append(counter.getName())\r\n                    .append(\" counter from \").append(p.getName()).toString());\r\n            return true;\r\n        }\r\n        Card c = game.getCard(targetPointer.getFirst(game, source));\r\n        if (c != null && c.getCounters(game).getCount(counter.getName()) >= counter.getCount()) {\r\n            c.removeCounters(counter.getName(), counter.getCount(), game);\r\n            if (!game.isSimulation())\r\n                game.informPlayers(new StringBuilder(\"Removed \").append(counter.getCount()).append(\" \").append(counter.getName())\r\n                    .append(\" counter from \").append(c.getName())\r\n                    .append(\" (\").append(c.getCounters(game).getCount(counter.getName())).append(\" left)\").toString());\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":80932,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent p = game.getPermanent(targetPointer.getFirst(game, source));\r\n        if(p != null) {\r\n            Counter toRemove = (counter == null ? selectCounterType(game, source, p) : counter);\r\n            if(toRemove != null && p.getCounters().getCount(toRemove.getName()) >= toRemove.getCount()) {\r\n                p.removeCounters(toRemove.getName(), toRemove.getCount(), game);\r\n                if(!game.isSimulation())\r\n                    game.informPlayers(\"Removed \" + toRemove.getCount() + \" \" + toRemove.getName()\r\n                        + \" counter from \" + p.getName());\r\n                return true;\r\n            }\r\n        }\r\n        Card c = game.getCard(targetPointer.getFirst(game, source));\r\n        if (c != null && counter != null && c.getCounters(game).getCount(counter.getName()) >= counter.getCount()) {\r\n            c.removeCounters(counter.getName(), counter.getCount(), game);\r\n            if (!game.isSimulation())\r\n                game.informPlayers(new StringBuilder(\"Removed \").append(counter.getCount()).append(\" \").append(counter.getName())\r\n                    .append(\" counter from \").append(c.getName())\r\n                    .append(\" (\").append(c.getCounters(game).getCount(counter.getName())).append(\" left)\").toString());\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"c33e7ad59b9c8e6e0c86c137b2bc234164e2d9d1","url":"https://github.com/magefree/mage"},{"original_method":"public RemoveCounterTargetEffect(RemoveCounterTargetEffect effect) {\r\n        super(effect);\r\n        this.counter = effect.counter.copy();\r\n    }","id":80933,"modified_method":"public RemoveCounterTargetEffect(RemoveCounterTargetEffect effect) {\r\n        super(effect);\r\n        this.counter = effect.counter == null ? null : effect.counter.copy();\r\n    }","commit_id":"c33e7ad59b9c8e6e0c86c137b2bc234164e2d9d1","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getRule() {\n        String superRule = super.getRule(true);\n        StringBuilder sb = new StringBuilder();\n        if (!superRule.isEmpty()) {\n            String ruleLow = superRule.toLowerCase();\n            if (isOptional()) {\n                if (ruleLow.startsWith(\"you \")) {\n                    if (!ruleLow.startsWith(\"you may\")) {\n                        StringBuilder newRule = new StringBuilder(superRule);\n                        newRule.insert(4, \"may \");\n                        superRule = newRule.toString();\n                    }\n                } else {\n                    if (this.getTargets().isEmpty()\n                            || ruleLow.startsWith(\"exile\")\n                            || ruleLow.startsWith(\"destroy\")\n                            || ruleLow.startsWith(\"return\")\n                            || ruleLow.startsWith(\"tap\")\n                            || ruleLow.startsWith(\"untap\")\n                            || ruleLow.startsWith(\"put\")) {\n                        sb.append(\"you may \");\n                    } else {\n                        if (!ruleLow.startsWith(\"its controller may\")) {\n                            sb.append(\"you may have \");\n                        }\n                    }\n                }\n\n            }\n            sb.append(superRule);\n        }\n\n        return sb.toString();\n    }","id":80934,"modified_method":"@Override\n    public String getRule() {\n        String superRule = super.getRule(true);\n        StringBuilder sb = new StringBuilder();\n        if (!superRule.isEmpty()) {\n            String ruleLow = superRule.toLowerCase();\n            if (isOptional()) {\n                if (ruleLow.startsWith(\"you \")) {\n                    if (!ruleLow.startsWith(\"you may\")) {\n                        StringBuilder newRule = new StringBuilder(superRule);\n                        newRule.insert(4, \"may \");\n                        superRule = newRule.toString();\n                    }\n                } else {\n                    if (this.getTargets().isEmpty()\n                            || ruleLow.startsWith(\"exile\")\n                            || ruleLow.startsWith(\"destroy\")\n                            || ruleLow.startsWith(\"return\")\n                            || ruleLow.startsWith(\"tap\")\n                            || ruleLow.startsWith(\"untap\")\n                            || ruleLow.startsWith(\"put\")\n                            || ruleLow.startsWith(\"remove\")) {\n                        sb.append(\"you may \");\n                    } else {\n                        if (!ruleLow.startsWith(\"its controller may\")) {\n                            sb.append(\"you may have \");\n                        }\n                    }\n                }\n\n            }\n            sb.append(superRule);\n        }\n\n        return sb.toString();\n    }","commit_id":"c33e7ad59b9c8e6e0c86c137b2bc234164e2d9d1","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event.getType().equals(EventType.BECOMES_MONSTROUS) && event.getSourceId().equals(this.getSourceId())) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":80935,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event.getType().equals(EventType.BECOMES_MONSTROUS) && event.getSourceId().equals(this.getSourceId())) {\r\n            this.monstrosityValue = event.getAmount();\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"4129838e364fc77d82d0ffb9015522fe1729e234","url":"https://github.com/magefree/mage"},{"original_method":"public BecomesMonstrousSourceTriggeredAbility(final BecomesMonstrousSourceTriggeredAbility ability) {\r\n        super(ability);\r\n    }","id":80936,"modified_method":"public BecomesMonstrousSourceTriggeredAbility(final BecomesMonstrousSourceTriggeredAbility ability) {\r\n        super(ability);\r\n        this.monstrosityValue = ability.monstrosityValue;\r\n    }","commit_id":"4129838e364fc77d82d0ffb9015522fe1729e234","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        DelayedTriggeredAbility delayedAbility = (DelayedTriggeredAbility) ability.copy();\r\n        delayedAbility.setSourceId(source.getSourceId());\r\n        delayedAbility.setControllerId(source.getControllerId());\r\n        if (this.copyTargets) {\r\n            delayedAbility.getTargets().addAll(source.getTargets());\r\n            for(Effect effect : delayedAbility.getEffects()) {\r\n                effect.setTargetPointer(targetPointer);\r\n                effect.getTargetPointer().init(game, source);\r\n            }\r\n        }\r\n        game.addDelayedTriggeredAbility(delayedAbility);\r\n        return true;\r\n    }","id":80937,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        DelayedTriggeredAbility delayedAbility = (DelayedTriggeredAbility) ability.copy();\r\n        delayedAbility.setSourceId(source.getSourceId());\r\n        delayedAbility.setControllerId(source.getControllerId());\r\n        if (this.copyTargets) {\r\n            delayedAbility.getTargets().addAll(source.getTargets());\r\n            for(Effect effect : delayedAbility.getEffects()) {\r\n                effect.getTargetPointer().init(game, source);\r\n            }\r\n        }\r\n        game.addDelayedTriggeredAbility(delayedAbility);\r\n        return true;\r\n    }","commit_id":"4129838e364fc77d82d0ffb9015522fe1729e234","url":"https://github.com/magefree/mage"},{"original_method":"public MonstrosityAbility(String manaString, int monstrosityValue) {\r\n        super(Zone.BATTLEFIELD, new ConditionalOneShotEffect(\r\n                new AddCountersSourceEffect(CounterType.P1P1.createInstance(monstrosityValue)),\r\n                new InvertCondition(MonstrousCondition.getInstance()),\r\n                \"\"), new ManaCostsImpl(manaString));\r\n        this.addEffect(new ConditionalOneShotEffect(\r\n                new BecomeMonstrousSourceEffect(),\r\n                new InvertCondition(MonstrousCondition.getInstance()),\"\"));\r\n\r\n        this.monstrosityValue = monstrosityValue;\r\n    }","id":80938,"modified_method":"/**\r\n     *\r\n     * @param manaString\r\n     * @param monstrosityValue use Integer.MAX_VALUE for monstrosity X.\r\n     */\r\n    public MonstrosityAbility(String manaString, int monstrosityValue) {\r\n        super(Zone.BATTLEFIELD, new BecomeMonstrousSourceEffect(),new ManaCostsImpl(manaString));\r\n        this.monstrosityValue = monstrosityValue;\r\n    }","commit_id":"4129838e364fc77d82d0ffb9015522fe1729e234","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public String getRule() {\r\n        return new StringBuilder(manaCosts.getText()).append(\": Monstrosity \").append(monstrosityValue)\r\n                .append(\".  <i>(If this creature isn't monstrous, put \").append(CardUtil.numberToText(monstrosityValue))\r\n                .append(\" +1/+1 counters on it and it becomes monstrous.)<\/i>\").toString();\r\n    }","id":80939,"modified_method":"@Override\r\n    public String getRule() {\r\n        return new StringBuilder(manaCosts.getText()).append(\": Monstrosity \")\r\n                .append(monstrosityValue == Integer.MAX_VALUE ? \"X\":monstrosityValue)\r\n                .append(\".  <i>(If this creature isn't monstrous, put \")\r\n                .append(monstrosityValue == Integer.MAX_VALUE ? \"X\":CardUtil.numberToText(monstrosityValue))\r\n                .append(\" +1/+1 counters on it and it becomes monstrous.)<\/i>\").toString();\r\n    }","commit_id":"4129838e364fc77d82d0ffb9015522fe1729e234","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (permanent != null) {\r\n            permanent.setMonstrous(true);\r\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.BECOMES_MONSTROUS, source.getSourceId(), source.getSourceId(), source.getControllerId()));\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":80940,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (permanent != null && !permanent.isMonstrous() && source instanceof MonstrosityAbility) {\r\n            int monstrosityValue = ((MonstrosityAbility) source).getMonstrosityValue();\r\n            // handle monstrosity = X\r\n            if (monstrosityValue == Integer.MAX_VALUE) {\r\n                monstrosityValue = source.getManaCostsToPay().getX();\r\n            }\r\n            new AddCountersSourceEffect(CounterType.P1P1.createInstance(monstrosityValue)).apply(game, source);\r\n            permanent.setMonstrous(true);\r\n            game.fireEvent(GameEvent.getEvent(GameEvent.EventType.BECOMES_MONSTROUS, source.getSourceId(), source.getSourceId(), source.getControllerId(), monstrosityValue));\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"4129838e364fc77d82d0ffb9015522fe1729e234","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * fills the data from the hashtable in the module.\n     * Creation date: (30.10.00 14:22:22)\n     * @return java.util.Hashtable\n     * @param param java.lang.String\n     */\n    private void updateTheModule(CmsObject cms, I_CmsRegistry reg, Hashtable table, String module) {\n        SimpleDateFormat dateFormat = new java.text.SimpleDateFormat(\"dd.MM.yyyy\");\n        String name = (String)table.get(C_MODULE_PACKETNAME);\n        String modulePath = \"/system/modules/\" + name + \"/\";\n        String version = (String)table.get(C_VERSION);\n        try {\n            int v = Integer.parseInt(version);\n            reg.setModuleVersion(name, v);\n        }\n        catch(Exception e) {\n            \n        }\n        try {\n            reg.setModuleNiceName(name, (String)table.get(C_MODULENAME));\n            reg.setModuleDescription(name, (String)table.get(C_DESCRIPTION));\n            \n            // the view\n            if(\"\".equals((String)table.get(C_VIEW))) {\n                if(!\"\".equals(getStringValue(reg.getModuleViewName(name)))) {\n                    try {\n                        cms.deleteFolder(modulePath + \"view/\");\n                    }\n                    catch(Exception e) {\n                        \n                    }\n                    reg.deleteModuleView(name);\n                }\n            }\n            else {\n                if(\"\".equals(getStringValue(reg.getModuleViewName(name)))) {\n                    reg.setModuleView(name, name.replace('.', '_'), modulePath + \"view/index.html\");\n                    tryToCreateFolder(cms, modulePath, \"view\");\n                }\n            }\n            \n            // the adminpoint\n            if(\"\".equals((String)table.get(C_ADMINPOINT))) {\n                try { // does not work when folder is not empty\n                    cms.deleteFolder(modulePath + \"administration/\");\n                }\n                catch(Exception e) {\n                    \n                }\n            }\n            else {\n                tryToCreateFolder(cms, modulePath, \"administration\");\n            }\n            \n            // the easy values\n            reg.setModuleMaintenanceEventClass(name, (String)table.get(C_MAINTENANCE));\n            reg.setModuleAuthor(name, (String)table.get(C_AUTHOR));\n            reg.setModuleAuthorEmail(name, (String)table.get(C_EMAIL));\n            \n            // set the date\n            String date = (String)table.get(C_DATE);\n            long dateLong = 0;\n            try {\n                dateLong = dateFormat.parse(date).getTime();\n            }\n            catch(Exception exc) {\n                dateLong = (new Date()).getTime();\n            }\n            reg.setModuleCreateDate(name, dateLong);\n            \n            // now the dependnecies\n            Vector depNames = new Vector();\n            Vector minVersion = new Vector();\n            Vector maxVersion = new Vector();\n            Vector stringDeps = (Vector)table.get(C_DEPENDENCY);\n            for(int i = 0;i < stringDeps.size();i++) {\n                String complString = (String)stringDeps.elementAt(i);\n                String max = complString.substring(complString.lastIndexOf(\"-\") + 2);\n                complString = complString.substring(0, complString.lastIndexOf(\"-\") - 1);\n                String min = complString.substring(complString.lastIndexOf(\":\") + 1);\n                depNames.addElement((complString.substring(0, complString.lastIndexOf(\"Version:\") - 1)).trim());\n                int minInt = 1;\n                int maxInt = -1;\n                try {\n                    minInt = Integer.parseInt(min);\n                }\n                catch(Exception e) {\n                    \n                }\n                try {\n                    if(!\"*\".equals(max)) {\n                        maxInt = Integer.parseInt(max);\n                    }\n                }\n                catch(Exception e) {\n                    \n                }\n                minVersion.addElement(new Integer(minInt));\n                maxVersion.addElement(new Integer(maxInt));\n            }\n            reg.setModuleDependencies(name, depNames, minVersion, maxVersion);\n            \n            // last not least: the properties\n            Vector paraNames = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_NAMES);\n            Vector paraDesc = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_DESCR);\n            Vector paraTyp = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_TYP);\n            Vector paraVal = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_VAL);\n            reg.setModuleParameterdef(name, paraNames, paraDesc, paraTyp, paraVal);\n        }\n        catch(CmsException e) {\n            System.err.println(\"Error while module administrating: \" + e.toString());\n        }\n    }","id":80941,"modified_method":"/**\n     * fills the data from the hashtable in the module.\n     * Creation date: (30.10.00 14:22:22)\n     * @return java.util.Hashtable\n     * @param param java.lang.String\n     */\n    private void updateTheModule(CmsObject cms, I_CmsRegistry reg, Hashtable table, String module) {\n        SimpleDateFormat dateFormat = new java.text.SimpleDateFormat(\"dd.MM.yyyy\");\n        String name = (String)table.get(C_MODULE_PACKETNAME);\n        String modulePath = \"/system/modules/\" + name + \"/\";\n        String version = (String)table.get(C_VERSION);\n        try {\n            int v = Integer.parseInt(version);\n            reg.setModuleVersion(name, v);\n        }\n        catch(Exception e) {\n\n        }\n        try {\n            reg.setModuleNiceName(name, (String)table.get(C_MODULENAME));\n            reg.setModuleDescription(name, (String)table.get(C_DESCRIPTION));\n\n            // the view\n            if(\"\".equals((String)table.get(C_VIEW))) {\n                if(!\"\".equals(getStringValue(reg.getModuleViewName(name)))) {\n                    try {\n                        cms.deleteFolder(modulePath + \"view/\");\n                    }\n                    catch(Exception e) {\n\n                    }\n                    reg.deleteModuleView(name);\n                }\n            }\n            else {\n                if(\"\".equals(getStringValue(reg.getModuleViewName(name)))) {\n                    reg.setModuleView(name, name.replace('.', '_'), modulePath + \"view/index.html\");\n                    tryToCreateFolder(cms, modulePath, \"view\");\n                }\n            }\n\n            // the adminpoint\n            if(\"\".equals((String)table.get(C_ADMINPOINT))) {\n                try { // does not work when folder is not empty\n                    cms.deleteFolder(modulePath + \"administration/\");\n                }\n                catch(Exception e) {\n\n                }\n            }\n            else {\n                tryToCreateFolder(cms, modulePath, \"administration\");\n            }\n\n            // the easy values\n            reg.setModuleMaintenanceEventClass(name, (String)table.get(C_MAINTENANCE));\n            reg.setModuleAuthor(name, (String)table.get(C_AUTHOR));\n            reg.setModuleAuthorEmail(name, (String)table.get(C_EMAIL));\n\n            // set the date\n            String date = (String)table.get(C_DATE);\n            long dateLong = 0;\n            try {\n                dateLong = dateFormat.parse(date).getTime();\n            }\n            catch(Exception exc) {\n                dateLong = (new Date()).getTime();\n            }\n            reg.setModuleCreateDate(name, dateLong);\n\n            // now the dependnecies\n            Vector depNames = new Vector();\n            Vector minVersion = new Vector();\n            Vector maxVersion = new Vector();\n            Vector stringDeps = (Vector)table.get(C_DEPENDENCY);\n            for(int i = 0;i < stringDeps.size();i++) {\n                String complString = (String)stringDeps.elementAt(i);\n                String max = complString.substring(complString.lastIndexOf(\"-\") + 2);\n                complString = complString.substring(0, complString.lastIndexOf(\"-\") - 1);\n                String min = complString.substring(complString.lastIndexOf(\":\") + 1);\n                depNames.addElement((complString.substring(0, complString.lastIndexOf(\"Version:\") - 1)).trim());\n                int minInt = 1;\n                int maxInt = -1;\n                try {\n                    minInt = Integer.parseInt(min);\n                }\n                catch(Exception e) {\n\n                }\n                try {\n                    if(!\"*\".equals(max)) {\n                        maxInt = Integer.parseInt(max);\n                    }\n                }\n                catch(Exception e) {\n\n                }\n                minVersion.addElement(new Integer(minInt));\n                maxVersion.addElement(new Integer(maxInt));\n            }\n            reg.setModuleDependencies(name, depNames, minVersion, maxVersion);\n\n            // last not least: the properties\n            Vector paraNames = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_NAMES);\n            Vector paraDesc = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_DESCR);\n            Vector paraTyp = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_TYP);\n            Vector paraVal = (Vector)table.get(C_SESSION_MODULE_ADMIN_PROP_VAL);\n            reg.setModuleParameterdef(name, paraNames, paraDesc, paraTyp, paraVal);\n        }\n        catch(CmsException e) {\n             if(A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING) {\n                 A_OpenCms.log(I_CmsLogChannels.C_MODULE_DEBUG,\n                    \"Error while module administrating: \" + e.toString());\n             }\n        }\n    }","commit_id":"94700deb5041655e193f62605bffeb438b021e0a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && (A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING)) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        CmsXmlTemplateFile templateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsRequestContext reqCont = cms.getRequestContext();\n        I_CmsRegistry reg = cms.getRegistry();\n        String step = (String)parameters.get(C_ACTION);\n        String moduleName = (String)parameters.get(C_MODULE);\n        if((step != null) && (\"ok\".equals(step))) {\n\n            // export\n            String exportName = (String)parameters.get(\"modulename\");\n            String[] resourcen = new String[4];\n            resourcen[0] = \"/system/modules/\" + exportName + \"/\";\n            resourcen[1] = \"/system/classes/\" + exportName.replace('.', '/') + \"/\";\n            resourcen[2] = \"/moduledemos/\" + exportName + \"/\";\n            resourcen[3] = \"/content/bodys/moduledemos/\" + exportName + \"/\";\n\n            // TODO: this is just a Hack\n            for(int i = 1;i < 4;i++) {\n                try {\n                    cms.readFileHeader(resourcen[i]);\n                }\n                catch(CmsException e) {\n                    System.err.println(\"error exporting module: couldn't add \" + resourcen[i] + \" to Module\\n\" + Utils.getStackTrace(e));\n                    resourcen[i] = resourcen[0];\n                }\n            }\n            try {\n                cms.readFileHeader(resourcen[0]);\n            }\n            catch(CmsException e) {\n                System.err.println(\"error exporting module: couldn't add \" + resourcen[0] + \" to Module\\n\" + \"You dont have this module in this project!\");\n                return startProcessing(cms, templateDocument, elementName, parameters, \"done\");\n            }\n\n            // end hack\n            reg.exportModule(exportName, resourcen, com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + exportName + \"_\" + reg.getModuleVersion(exportName));\n            templateSelector = \"done\";\n        }\n        else {\n\n            // first call\n            templateDocument.setData(\"modulename\", moduleName);\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, templateDocument, elementName, parameters, templateSelector);\n    }","id":80942,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && (A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING)) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        CmsXmlTemplateFile templateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsRequestContext reqCont = cms.getRequestContext();\n        I_CmsRegistry reg = cms.getRegistry();\n        String step = (String)parameters.get(C_ACTION);\n        String moduleName = (String)parameters.get(C_MODULE);\n        if((step != null) && (\"ok\".equals(step))) {\n\n            // export\n            String exportName = (String)parameters.get(\"modulename\");\n            String[] resourcen = new String[4];\n            resourcen[0] = \"/system/modules/\" + exportName + \"/\";\n            resourcen[1] = \"/system/classes/\" + exportName.replace('.', '/') + \"/\";\n            resourcen[2] = \"/moduledemos/\" + exportName + \"/\";\n            resourcen[3] = \"/content/bodys/moduledemos/\" + exportName + \"/\";\n\n            // TODO: this is just a Hack\n            for(int i = 1;i < 4;i++) {\n                try {\n                    cms.readFileHeader(resourcen[i]);\n                }\n                catch(CmsException e) {\n                     if(A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING) {\n                         A_OpenCms.log(I_CmsLogChannels.C_MODULE_DEBUG,\n                            \"error exporting module: couldn't add \" + resourcen[i] + \" to Module\\n\" + Utils.getStackTrace(e));\n                     }\n                    resourcen[i] = resourcen[0];\n                }\n            }\n            try {\n                cms.readFileHeader(resourcen[0]);\n            }\n            catch(CmsException e) {\n                 if(A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING) {\n                     A_OpenCms.log(I_CmsLogChannels.C_MODULE_DEBUG,\n                        \"error exporting module: couldn't add \" + resourcen[0]\n                        + \" to Module\\n\" + \"You dont have this module in this project!\");\n                 }\n                return startProcessing(cms, templateDocument, elementName, parameters, \"done\");\n            }\n\n            // end hack\n            reg.exportModule(exportName, resourcen, com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + exportName + \"_\" + reg.getModuleVersion(exportName));\n            templateSelector = \"done\";\n        }\n        else {\n\n            // first call\n            templateDocument.setData(\"modulename\", moduleName);\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, templateDocument, elementName, parameters, templateSelector);\n    }","commit_id":"94700deb5041655e193f62605bffeb438b021e0a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sorts a set of arrays containing navigation information depending on \n     * their navigation positions.\n     * @param filenames Array of filenames\n     * @param index Array of associate Strings\n     * @param positions Array of navpostions\n     */\n    \n    private void sort(String[] filenames, int[] index, String[] positions, int max) {\n        \n        // Sorting algorithm        \n        // This method uses an bubble sort, so replace this with something more        \n        // efficient\n        try {\n            for(int i = max - 1;i > 0;i--) {\n                for(int j = 0;j < i;j++) {\n                    float a = new Float(positions[j]).floatValue();\n                    float b = new Float(positions[j + 1]).floatValue();\n                    if(a > b) {\n                        String tempfilename = filenames[j];\n                        int tempindex = index[j];\n                        String tempposition = positions[j];\n                        filenames[j] = filenames[j + 1];\n                        index[j] = index[j + 1];\n                        positions[j] = positions[j + 1];\n                        filenames[j + 1] = tempfilename;\n                        index[j + 1] = tempindex;\n                        positions[j + 1] = tempposition;\n                    }\n                }\n            }\n        }\n        catch(Exception e) {\n            System.err.println(\"cmsAdministration.sort : adminpoints unsorted cause I cant get a valid floatvalue \\n\" + e.toString());\n        }\n    }","id":80943,"modified_method":"/**\n     * Sorts a set of arrays containing navigation information depending on\n     * their navigation positions.\n     * @param filenames Array of filenames\n     * @param index Array of associate Strings\n     * @param positions Array of navpostions\n     */\n\n    private void sort(String[] filenames, int[] index, String[] positions, int max) {\n\n        // Sorting algorithm\n        // This method uses an bubble sort, so replace this with something more\n        // efficient\n        try {\n            for(int i = max - 1;i > 0;i--) {\n                for(int j = 0;j < i;j++) {\n                    float a = new Float(positions[j]).floatValue();\n                    float b = new Float(positions[j + 1]).floatValue();\n                    if(a > b) {\n                        String tempfilename = filenames[j];\n                        int tempindex = index[j];\n                        String tempposition = positions[j];\n                        filenames[j] = filenames[j + 1];\n                        index[j] = index[j + 1];\n                        positions[j] = positions[j + 1];\n                        filenames[j + 1] = tempfilename;\n                        index[j + 1] = tempindex;\n                        positions[j + 1] = tempposition;\n                    }\n                }\n            }\n        }\n        catch(Exception e) {\n             if(A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING) {\n                 A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_DEBUG,\n                    \"cmsAdministration.sort : adminpoints unsorted cause I cant get a valid floatvalue \\n\" + e.toString());\n             }\n        }\n    }","commit_id":"94700deb5041655e193f62605bffeb438b021e0a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n   * Initialize the GroovyServlet.\n   *\n   * @throws ServletException\n   *  if this method encountered difficulties\n   */\n  public void init(ServletConfig config) throws ServletException {\n    super.init(config);\n\n    // Set up the scripting engine\n    gse = new GroovyScriptEngine(this);\n\n    servletContext.log(\"Groovy servlet initialized\");\n  }","id":80944,"modified_method":"/**\n     * Initialize the GroovyServlet.\n     *\n     * @throws ServletException\n     *  if this method encountered difficulties\n     */\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        // Set up the scripting engine\n        gse = new GroovyScriptEngine(this);\n\n        servletContext.log(\"Groovy servlet initialized on \" + gse + \".\");\n    }","commit_id":"486da8d7b41e72315cdeaddf2d06e859336eab4f","url":"https://github.com/apache/groovy"},{"original_method":"/**\n   * Handle web requests to the GroovyServlet\n   */\n  public void service(HttpServletRequest request,\n      HttpServletResponse response) throws IOException {\n\n    // Get the script path from the request - include aware (GROOVY-815)\n    final String scriptUri = getScriptUri(request);\n\n    // Set it to HTML by default\n    response.setContentType(\"text/html\");\n\n    // Set up the script context\n    final Binding binding = new ServletBinding(request, response, servletContext);\n\n    // Run the script\n    try {\n      Closure closure = new Closure(gse) {\n\n        public Object call() {\n          try {\n            return ((GroovyScriptEngine) getDelegate()).run(scriptUri, binding);\n          }\n          catch (ResourceException e) {\n            throw new RuntimeException(e);\n          }\n          catch (ScriptException e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n      };\n      GroovyCategorySupport.use(ServletCategory.class, closure);\n      // Set reponse code 200 and flush buffers\n      response.setStatus(HttpServletResponse.SC_OK);\n      response.flushBuffer();\n      // log(\"Flushed response buffer.\");\n    }\n    catch (RuntimeException re) {\n      StringBuffer error = new StringBuffer(\"GroovyServlet Error: \");\n      error.append(\" script: '\");\n      error.append(scriptUri);\n      error.append(\"': \");\n      Throwable e = re.getCause();\n      if (e instanceof ResourceException) {\n        error.append(\" Script not found, sending 404.\");\n        servletContext.log(error.toString());\n        System.out.println(error.toString());\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n      }\n      else {\n        // write the script errors (if any) to the servlet context's log\n        if (re.getMessage() != null)\n          error.append(re.getMessage());\n\n        if (e != null) {\n          servletContext.log(\"An error occurred processing the request\", e);\n        }\n        else {\n          servletContext.log(\"An error occurred processing the request\", re);\n        }\n        servletContext.log(error.toString());\n        System.out.println(error.toString());\n        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.toString());\n      }\n    }\n\n  }","id":80945,"modified_method":"/**\n     * Handle web requests to the GroovyServlet\n     */\n    public void service(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n        // Get the script path from the request - include aware (GROOVY-815)\n        final String scriptUri = getScriptUri(request);\n\n        // Set it to HTML by default\n        response.setContentType(\"text/html\");\n\n        // Set up the script context\n        final Binding binding = new ServletBinding(request, response, servletContext);\n\n        // Run the script\n        try {\n            Closure closure = new Closure(gse) {\n\n                public Object call() {\n                    try {\n                        return ((GroovyScriptEngine) getDelegate()).run(scriptUri, binding);\n                    } catch (ResourceException e) {\n                        throw new RuntimeException(e);\n                    } catch (ScriptException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n\n            };\n            GroovyCategorySupport.use(ServletCategory.class, closure);\n            /*\n             * Set reponse code 200.\n             */\n            response.setStatus(HttpServletResponse.SC_OK);\n        } catch (RuntimeException runtimeException) {\n            StringBuffer error = new StringBuffer(\"GroovyServlet Error: \");\n            error.append(\" script: '\");\n            error.append(scriptUri);\n            error.append(\"': \");\n            Throwable e = runtimeException.getCause();\n            /*\n             * Null cause?!\n             */\n            if (e == null) {\n                error.append(\" Script processing failed.\");\n                servletContext.log(error.toString());\n                System.err.println(error.toString());\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                return;\n            }\n            /*\n             * Resource not found.\n             */\n            if (e instanceof ResourceException) {\n                error.append(\" Script not found, sending 404.\");\n                servletContext.log(error.toString());\n                System.err.println(error.toString());\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n            /*\n             * Other internal error. Perhaps syntax?! \n             */\n            servletContext.log(\"An error occurred processing the request\", e);\n            servletContext.log(error.toString());\n            System.err.println(error.toString());\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.toString());\n        } finally {\n            /*\n             * Finally, flush the response buffer.\n             */\n            response.flushBuffer();\n            // servletContext.log(\"Flushed response buffer.\");\n        }\n    }","commit_id":"486da8d7b41e72315cdeaddf2d06e859336eab4f","url":"https://github.com/apache/groovy"},{"original_method":"BulkProcessor(Client client, Listener listener, @Nullable String name, int concurrentRequests, int bulkActions, ByteSizeValue bulkSize, @Nullable TimeValue flushInterval) {\n        this.client = client;\n        this.listener = listener;\n        this.name = name;\n        this.concurrentRequests = concurrentRequests;\n        this.bulkActions = bulkActions;\n        this.bulkSize = bulkSize.bytesAsInt();\n\n        this.semaphore = new Semaphore(concurrentRequests);\n        this.bulkRequest = new BulkRequest();\n\n        this.flushInterval = flushInterval;\n        if (flushInterval != null) {\n            this.scheduler = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1, EsExecutors.daemonThreadFactory(client.settings(), (name != null ? \"[\" + name + \"]\" : \"\") + \"bulk_processor\"));\n            this.scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n            this.scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n            this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(new Flush(), flushInterval.millis(), flushInterval.millis(), TimeUnit.MILLISECONDS);\n        } else {\n            this.scheduler = null;\n            this.scheduledFuture = null;\n        }\n    }","id":80946,"modified_method":"BulkProcessor(Client client, Listener listener, @Nullable String name, int concurrentRequests, int bulkActions, ByteSizeValue bulkSize, @Nullable TimeValue flushInterval) {\n        this.client = client;\n        this.listener = listener;\n        this.name = name;\n        this.concurrentRequests = concurrentRequests;\n        this.bulkActions = bulkActions;\n        this.bulkSize = bulkSize.bytes();\n\n        this.semaphore = new Semaphore(concurrentRequests);\n        this.bulkRequest = new BulkRequest();\n\n        this.flushInterval = flushInterval;\n        if (flushInterval != null) {\n            this.scheduler = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1, EsExecutors.daemonThreadFactory(client.settings(), (name != null ? \"[\" + name + \"]\" : \"\") + \"bulk_processor\"));\n            this.scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n            this.scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n            this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(new Flush(), flushInterval.millis(), flushInterval.millis(), TimeUnit.MILLISECONDS);\n        } else {\n            this.scheduler = null;\n            this.scheduledFuture = null;\n        }\n    }","commit_id":"2bec59ec3e221e4154671370421f77a5a406cbd5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.\n     *\n     * If concurrent requests are not enabled, returns {@code true} immediately.\n     * If concurrent requests are enabled, waits for up to the specified timeout for all bulk requests to complete then returns {@code true},\n     * If the specified waiting time elapses before all bulk requests complete, {@code false} is returned.\n     *\n     * @param timeout The maximum time to wait for the bulk requests to complete\n     * @param unit The time unit of the {@code timeout} argument\n     * @return {@code true} if all bulk requests completed and {@code false} if the waiting time elapsed before all the bulk requests completed\n     * @throws InterruptedException If the current thread is interrupted\n     */\n    public synchronized boolean awaitClose(long timeout, TimeUnit unit) throws InterruptedException {\n        if (closed) {\n            return true;\n        }\n        closed = true;\n        if (this.scheduledFuture != null) {\n            this.scheduledFuture.cancel(false);\n            this.scheduler.shutdown();\n        }\n        if (bulkRequest.numberOfActions() > 0) {\n            execute();\n        }\n        if (this.concurrentRequests < 1) {\n            return true;\n        }\n        return semaphore.tryAcquire(this.concurrentRequests, timeout, unit);\n    }","id":80947,"modified_method":"/**\n     * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.\n     *\n     * If concurrent requests are not enabled, returns {@code true} immediately.\n     * If concurrent requests are enabled, waits for up to the specified timeout for all bulk requests to complete then returns {@code true},\n     * If the specified waiting time elapses before all bulk requests complete, {@code false} is returned.\n     *\n     * @param timeout The maximum time to wait for the bulk requests to complete\n     * @param unit The time unit of the {@code timeout} argument\n     * @return {@code true} if all bulk requests completed and {@code false} if the waiting time elapsed before all the bulk requests completed\n     * @throws InterruptedException If the current thread is interrupted\n     */\n    public synchronized boolean awaitClose(long timeout, TimeUnit unit) throws InterruptedException {\n        if (closed) {\n            return true;\n        }\n        closed = true;\n        if (this.scheduledFuture != null) {\n            this.scheduledFuture.cancel(false);\n            this.scheduler.shutdown();\n        }\n        if (bulkRequest.numberOfActions() > 0) {\n            execute();\n        }\n        if (this.concurrentRequests < 1) {\n            return true;\n        }\n        if (semaphore.tryAcquire(this.concurrentRequests, timeout, unit)) {\n            semaphore.release(this.concurrentRequests);\n            return true;\n        }\n        return false;\n    }","commit_id":"2bec59ec3e221e4154671370421f77a5a406cbd5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void ensureOpen() {\n        if (closed) {\n            throw new ElasticsearchIllegalStateException(\"bulk process already closed\");\n        }\n    }","id":80948,"modified_method":"protected void ensureOpen() {\n        if (closed) {\n            throw new ElasticsearchIllegalStateException(\"bulk process already closed\");\n        }\n    }","commit_id":"2bec59ec3e221e4154671370421f77a5a406cbd5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public boolean waitFor(long timeout, TimeUnit unit) {\n    try {\n      if (!isDone()) {\n        mySemaphore.tryAcquire(timeout, unit);\n      }\n    }\n    catch (InterruptedException ignored) {\n    }\n    return isDone();\n  }","id":80949,"modified_method":"public boolean waitFor(long timeout, TimeUnit unit) {\n    try {\n      if (!isDone()) {\n        if (mySemaphore.tryAcquire(timeout, unit)) {\n          mySemaphore.release();\n        }\n      }\n    }\n    catch (InterruptedException ignored) {\n    }\n    return isDone();\n  }","commit_id":"377acad42d9398a922e7d6215b1dc3ee46151619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void waitFor() {\n    try {\n      while (!isDone()) {\n        mySemaphore.tryAcquire(100L, TimeUnit.MILLISECONDS);\n      }\n    }\n    catch (InterruptedException ignored) {\n    }\n  }","id":80950,"modified_method":"public void waitFor() {\n    try {\n      while (!isDone()) {\n        if (mySemaphore.tryAcquire(100L, TimeUnit.MILLISECONDS)) {\n          mySemaphore.release();\n        }\n      }\n    }\n    catch (InterruptedException ignored) {\n    }\n  }","commit_id":"377acad42d9398a922e7d6215b1dc3ee46151619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BasicFuture() {\n  }","id":80951,"modified_method":"public BasicFuture() {\n    mySemaphore.acquireUninterruptibly();\n  }","commit_id":"377acad42d9398a922e7d6215b1dc3ee46151619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RequestFuture(T handler, UUID requestID, @Nullable CancelAction<T> cancelAction) {\n    super();\n    myCancelAction = cancelAction;\n    myHandler = handler;\n    myRequestID = requestID;\n    mySemaphore.acquireUninterruptibly();\n  }","id":80952,"modified_method":"public RequestFuture(T handler, UUID requestID, @Nullable CancelAction<T> cancelAction) {\n    super();\n    myCancelAction = cancelAction;\n    myHandler = handler;\n    myRequestID = requestID;\n  }","commit_id":"377acad42d9398a922e7d6215b1dc3ee46151619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static LocalChangeList tryToMatchWithExistingChangelist(@NotNull ChangeListManager changeListManager,\n                                                                  @NotNull final String defaultName) {\n    return ContainerUtil.find(changeListManager.getChangeListsCopy(), new Condition<LocalChangeList>() {\n      @Override\n      public boolean value(LocalChangeList list) {\n        return defaultName.contains(list.getName());\n      }\n    });\n  }","id":80953,"modified_method":"@Nullable\n  private static LocalChangeList tryToMatchWithExistingChangelist(@NotNull ChangeListManager changeListManager,\n                                                                  @NotNull final String defaultName) {\n    List<LocalChangeList> matched = ContainerUtil.findAll(changeListManager.getChangeListsCopy(), new Condition<LocalChangeList>() {\n      @Override\n      public boolean value(LocalChangeList list) {\n        return defaultName.contains(list.getName().trim());\n      }\n    });\n    int maxLen = -1;\n    LocalChangeList bestMatch = null;\n    for (LocalChangeList changeList : matched) {\n      int len = changeList.getName().trim().length();\n      if (len > maxLen) {\n        maxLen = len;\n        bestMatch = changeList;\n      }\n    }\n    return bestMatch;\n  }","commit_id":"948ff3207bf3f22aae393c468fa2175c49baa860","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void sikuliClick(\n\t\t\tLiferaySelenium liferaySelenium, String image)\n\t\tthrows Exception {\n\n\t\tMouse mouse = new DesktopMouse();\n\n\t\tScreenRegion screenRegion = new DesktopScreenRegion();\n\n\t\tImageTarget imageTarget = getImageTarget(liferaySelenium, image);\n\n\t\tscreenRegion = screenRegion.find(imageTarget);\n\n\t\tmouse.click(screenRegion.getCenter());\n\t}","id":80954,"modified_method":"public static void sikuliClick(\n\t\t\tLiferaySelenium liferaySelenium, String image)\n\t\tthrows Exception {\n\n\t\tMouse mouse = new DesktopMouse();\n\n\t\tScreenRegion screenRegion = new DesktopScreenRegion();\n\n\t\tImageTarget imageTarget = getImageTarget(liferaySelenium, image);\n\n\t\tList<ScreenRegion> imageTargetScreenRegions = screenRegion.findAll(\n\t\t\timageTarget);\n\n\t\tfor (ScreenRegion imageTargetScreenRegion : imageTargetScreenRegions) {\n\t\t\tmouse.click(imageTargetScreenRegion.getCenter());\n\t\t}\n\t}","commit_id":"7e32dc9870c455f7e3ae952f3cd3ee66e81b8771","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public void annotate(@NotNull PsiElement element, @NotNull AnnotationHolder holder) {\n    if (element instanceof XmlTag || element instanceof XmlAttribute) {\n      SchemaPrefixReference reference =\n        (SchemaPrefixReference)ContainerUtil.find(element.getReferences(), FilteringIterator.instanceOf(SchemaPrefixReference.class));\n      if (reference != null) {\n        TextRange rangeInElement = reference.getRangeInElement();\n        if (!rangeInElement.isEmpty()) {\n          TextRange range = rangeInElement.shiftRight(element.getTextRange().getStartOffset());\n          holder.createInfoAnnotation(range, null).setTextAttributes(XmlHighlighterColors.XML_NS_PREFIX);\n        }\n      }\n    }\n  }","id":80955,"modified_method":"@Override\n  public void annotate(@NotNull PsiElement element, @NotNull AnnotationHolder holder) {\n    if (element instanceof XmlTag || element instanceof XmlAttribute) {\n      List<SchemaPrefixReference> references = ContainerUtil.findAll(element.getReferences(), SchemaPrefixReference.class);\n      for (SchemaPrefixReference reference : references) {\n        TextRange rangeInElement = reference.getRangeInElement();\n        if (!rangeInElement.isEmpty()) {\n          TextRange range = rangeInElement.shiftRight(element.getTextRange().getStartOffset());\n          holder.createInfoAnnotation(range, null).setTextAttributes(XmlHighlighterColors.XML_NS_PREFIX);\n        }\n      }\n    }\n  }","commit_id":"019a43e152f0562dcae1f22845aec122deb417d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run() {\n\t\t\tfor(ForwardPort port : portsToForwardNow) {\n\t\t\t\tString proto = protoToString(port.protocol);\n\t\t\t\tif (proto.length() <= 1) {\n\t\t\t\t\tHashMap<ForwardPort, ForwardPortStatus> map = new HashMap<ForwardPort, ForwardPortStatus>();\n\t\t\t\t\tmap.put(port, new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE, \"Protocol not supported\", port.portNumber));\n\t\t\t\t\tforwardCallback.portForwardStatus(map);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tryAddMapping(proto, port.portNumber, port.name, port)) {\n\t\t\t\t\tHashMap<ForwardPort, ForwardPortStatus> map = new HashMap<ForwardPort, ForwardPortStatus>();\n\t\t\t\t\tmap.put(port, new ForwardPortStatus(ForwardPortStatus.MAYBE_SUCCESS, \"Port apparently forwarded by UPnP\", port.portNumber));\n\t\t\t\t\tforwardCallback.portForwardStatus(map);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tHashMap<ForwardPort, ForwardPortStatus> map = new HashMap<ForwardPort, ForwardPortStatus>();\n\t\t\t\t\tmap.put(port, new ForwardPortStatus(ForwardPortStatus.PROBABLE_FAILURE, \"UPnP port forwarding apparently failed\", port.portNumber));\n\t\t\t\t\tforwardCallback.portForwardStatus(map);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":80956,"modified_method":"public void run() {\n\t\t\tHashMap<ForwardPort, ForwardPortStatus> map = new HashMap(1);\n\t\t\tfor(ForwardPort port : portsToForwardNow) {\n\t\t\t\tString proto = protoToString(port.protocol);\n\t\t\t\tmap.clear();\n\t\t\t\tForwardPortStatus fps;\n\t\t\t\tif (proto.length() <= 1) {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE, \"Protocol not supported\", port.portNumber);\n\t\t\t\t} else if(tryAddMapping(proto, port.portNumber, port.name, port)) {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.MAYBE_SUCCESS, \"Port apparently forwarded by UPnP\", port.portNumber);\n\t\t\t\t} else {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.PROBABLE_FAILURE, \"UPnP port forwarding apparently failed\", port.portNumber);\n\t\t\t\t}\n\t\t\t\tmap.put(port, fps);\n\t\t\t\tforwardCallback.portForwardStatus(map);\n\t\t\t}\n\t\t}","commit_id":"0133711c3b6ef223fc1b6bff7ff90eecd32882bc","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t *  DeviceChangeListener\n\t */\n\tpublic void deviceRemoved(Device dev ){\n                String udn = dev.getUDN();\n\t\tif (_log.shouldLog(Log.WARN))\n\t\t\t_log.warn(\"UP&P device removed : \" + dev.getFriendlyName() + \" UDN: \" + udn);\n\t\tsynchronized (lock) {\n\t\t\tif (udn != null)\n\t\t\t\t_otherUDNs.remove(udn);\n\t\t\telse\n\t\t\t\t_otherUDNs.remove(\"???\");\n\t\t\tif (_router == null) return;\n\t\t\t// I2P this wasn't working\n\t\t\t//if(_router.equals(dev)) {\n\t\t        if(ROUTER_DEVICE.equals(dev.getDeviceType()) &&\n\t\t\t   dev.isRootDevice() &&\n\t\t\t   stringEquals(_router.getFriendlyName(), dev.getFriendlyName()) &&\n\t\t\t   stringEquals(_router.getUDN(), udn)) {\n\t\t\t\tif (_log.shouldLog(Log.WARN))\n\t\t\t\t\t_log.warn(\"UP&P IGD device removed : \" + dev.getFriendlyName());\n\t\t\t\t// TODO promote an IGD from _otherUDNs ??\n\t\t\t\t_router = null;\n\t\t\t\t_service = null;\n\t\t\t\t_serviceLacksAPM = false;\n\t\t\t\tportsForwarded.clear();\n\t\t\t}\n\t\t}\n\t}","id":80957,"modified_method":"/**\n\t *  DeviceChangeListener\n\t */\n\tpublic void deviceRemoved(Device dev ){\n                String udn = dev.getUDN();\n\t\tif (_log.shouldLog(Log.WARN))\n\t\t\t_log.warn(\"UP&P device removed : \" + dev.getFriendlyName() + \" UDN: \" + udn);\n\t\tForwardPortCallback fpc = null;\n\t\tMap<ForwardPort, ForwardPortStatus> removeMap = null;\n\t\tsynchronized (lock) {\n\t\t\tif (udn != null)\n\t\t\t\t_otherUDNs.remove(udn);\n\t\t\telse\n\t\t\t\t_otherUDNs.remove(\"???\");\n\t\t\tif (_router == null) return;\n\t\t\t// I2P this wasn't working\n\t\t\t//if(_router.equals(dev)) {\n\t\t        if(ROUTER_DEVICE.equals(dev.getDeviceType()) &&\n\t\t\t   dev.isRootDevice() &&\n\t\t\t   stringEquals(_router.getFriendlyName(), dev.getFriendlyName()) &&\n\t\t\t   stringEquals(_router.getUDN(), udn)) {\n\t\t\t\tif (_log.shouldLog(Log.WARN))\n\t\t\t\t\t_log.warn(\"UP&P IGD device removed : \" + dev.getFriendlyName());\n\t\t\t\t// TODO promote an IGD from _otherUDNs ??\n\t\t\t\t// For now, just clear the others so they can be promoted later\n\t\t\t\t// after a rescan.\n\t\t\t\t_otherUDNs.clear();\n\t\t\t\t_router = null;\n\t\t\t\t_service = null;\n\t\t\t\t_serviceLacksAPM = false;\n\t\t\t\tif (!portsForwarded.isEmpty()) {\n\t\t\t\t\tfpc = forwardCallback;\n\t\t\t\t\tremoveMap = new HashMap<ForwardPort, ForwardPortStatus>(portsForwarded.size());\n\t\t\t\t\tfor (ForwardPort port : portsForwarded) {\n\t\t\t\t\t\tForwardPortStatus fps = new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE,\n                                                                      \"UPnP device removed\",\n                                                                      port.portNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tportsForwarded.clear();\n\t\t\t}\n\t\t}\n\t\tif (fpc != null) {\n\t\t\tfpc.portForwardStatus(removeMap);\n\t\t}\n\t}","commit_id":"33b58f5fab141463603984433987a9444be6198b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n\t\t\tfor(ForwardPort port : portsToForwardNow) {\n\t\t\t\tString proto = protoToString(port.protocol);\n\t\t\t\tForwardPortStatus fps;\n\t\t\t\tif (proto.length() <= 1) {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE, \"Protocol not supported\", port.portNumber);\n\t\t\t\t} else if(tryAddMapping(proto, port.portNumber, port.name, port)) {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.MAYBE_SUCCESS, \"Port apparently forwarded by UPnP\", port.portNumber);\n\t\t\t\t} else {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.PROBABLE_FAILURE, \"UPnP port forwarding apparently failed\", port.portNumber);\n\t\t\t\t}\n\t\t\t\tMap<ForwardPort, ForwardPortStatus> map = Collections.singletonMap(port, fps);\n\t\t\t\ttry {\n\t\t\t\t\tforwardCallback.portForwardStatus(map);\n\t\t\t\t} catch (Exception e) {\n                                    _log.error(\"UPnP RPT error\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":80958,"modified_method":"public void run() {\n\t\t\tMap<ForwardPort, ForwardPortStatus> map =\n\t\t\t\tnew HashMap<ForwardPort, ForwardPortStatus>(portsToForwardNow.size());\n\t\t\tfor(ForwardPort port : portsToForwardNow) {\n\t\t\t\tString proto = protoToString(port.protocol);\n\t\t\t\tForwardPortStatus fps;\n\t\t\t\tif (proto.length() <= 1) {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE, \"Protocol not supported\", port.portNumber);\n\t\t\t\t} else if(tryAddMapping(proto, port.portNumber, port.name, port)) {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.MAYBE_SUCCESS, \"Port apparently forwarded by UPnP\", port.portNumber);\n\t\t\t\t} else {\n\t\t\t\t\tfps = new ForwardPortStatus(ForwardPortStatus.PROBABLE_FAILURE, \"UPnP port forwarding apparently failed\", port.portNumber);\n\t\t\t\t}\n\t\t\t\tmap.put(port, fps);\n\t\t\t}\n\t\t\tforwardCallback.portForwardStatus(map);\n\t\t}","commit_id":"33b58f5fab141463603984433987a9444be6198b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t *  postControlAction() can take many seconds, especially if it's failing,\n         *  and onChangePublicPorts() may be called from threads we don't want to slow down,\n         *  so throw this in a thread.\n         */\n\tprivate void registerPorts(Set<ForwardPort> portsToForwardNow) {\n\t\tif (_serviceLacksAPM) {\n                    if (_log.shouldLog(Log.WARN))\n\t\t\t_log.warn(\"UPnP device does not support port forwarding\");\n\t\t    for (ForwardPort port : portsToForwardNow) {\n\t\t\tForwardPortStatus fps = new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE,\n                                                                      \"UPnP device does not support port forwarding\",\n                                                                      port.portNumber);\n\t\t\tMap<ForwardPort, ForwardPortStatus> map = Collections.singletonMap(port, fps);\n\t\t\tforwardCallback.portForwardStatus(map);\n\t\t    }\n\t\t    return;\n\t\t}\n\t\tif (_log.shouldLog(Log.INFO))\n\t\t\t_log.info(\"Starting thread to forward \" + portsToForwardNow.size() + \" ports\");\n\t        Thread t = new Thread(new RegisterPortsThread(portsToForwardNow));\n\t\tt.setName(\"UPnP Port Opener \" + __id.incrementAndGet());\n\t\tt.setDaemon(true);\n\t\tt.start();\n\t}","id":80959,"modified_method":"/**\n\t *  postControlAction() can take many seconds, especially if it's failing,\n         *  and onChangePublicPorts() may be called from threads we don't want to slow down,\n         *  so throw this in a thread.\n         */\n\tprivate void registerPorts(Set<ForwardPort> portsToForwardNow) {\n\t\tif (_serviceLacksAPM) {\n                    if (_log.shouldLog(Log.WARN))\n\t\t\t_log.warn(\"UPnP device does not support port forwarding\");\n\t\t    Map<ForwardPort, ForwardPortStatus> map =\n\t\t\tnew HashMap<ForwardPort, ForwardPortStatus>(portsToForwardNow.size());\n\t\t    for (ForwardPort port : portsToForwardNow) {\n\t\t\tForwardPortStatus fps = new ForwardPortStatus(ForwardPortStatus.DEFINITE_FAILURE,\n                                                                      \"UPnP device does not support port forwarding\",\n                                                                      port.portNumber);\n\t\t\tmap.put(port, fps);\n\t\t    }\n\t\t    forwardCallback.portForwardStatus(map);\n\t\t    return;\n\t\t}\n\t\tif (_log.shouldLog(Log.INFO))\n\t\t\t_log.info(\"Starting thread to forward \" + portsToForwardNow.size() + \" ports\");\n\t        Thread t = new Thread(new RegisterPortsThread(portsToForwardNow));\n\t\tt.setName(\"UPnP Port Opener \" + __id.incrementAndGet());\n\t\tt.setDaemon(true);\n\t\tt.start();\n\t}","commit_id":"33b58f5fab141463603984433987a9444be6198b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    final MigrationManagerImpl mc = ((MigrationManagerImpl) event.getData(CommonDataKeys.PROJECT).getComponent(MigrationManager.class));\n\n    final List<SModule>[] modules = new List[1];\n    event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        modules[0] = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(event.getData(MPSCommonDataKeys.MPS_PROJECT))).toListSequence();\n      }\n    });\n    ProgressManager.getInstance().run(new Task.Modal(event.getData(CommonDataKeys.PROJECT), \"Run Migrations\", true) {\n      public void run(@NotNull ProgressIndicator progressIndicator) {\n        ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);\n        int steps = modules[0].size();\n        progressMonitor.start(\"Running...\", steps);\n        for (final SModule module : ListSequence.fromList(modules[0])) {\n          progressMonitor.step(module.getModuleName());\n          WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {\n            public void run() {\n              event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository().getModelAccess().executeCommand(new Runnable() {\n                public void run() {\n                  Set<SLanguage> languages = new SLanguageHierarchy(module.getUsedLanguages()).getExtended();\n                  Iterable<MigrationScript> scripts = SetSequence.fromSet(languages).translate(new ITranslator2<SLanguage, MigrationScript>() {\n                    public Iterable<MigrationScript> translate(final SLanguage it) {\n                      return new Iterable<MigrationScript>() {\n                        public Iterator<MigrationScript> iterator() {\n                          return new YieldingIterator<MigrationScript>() {\n                            private int __CP__ = 0;\n                            protected boolean moveToNext() {\n__loop__:\n                              do {\n__switch__:\n                                switch (this.__CP__) {\n                                  case -1:\n                                    assert false : \"Internal error\";\n                                    return false;\n                                  case 2:\n                                    this._2_ver = 0;\n                                  case 3:\n                                    if (!(_2_ver < it.getLanguageVersion())) {\n                                      this.__CP__ = 1;\n                                      break;\n                                    }\n                                    this.__CP__ = 4;\n                                    break;\n                                  case 5:\n                                    _2_ver++;\n                                    this.__CP__ = 3;\n                                    break;\n                                  case 8:\n                                    if (_7_script != null && Sequence.fromIterable(_7_script.requiresData()).isEmpty() && _7_script.isRerunnable()) {\n                                      this.__CP__ = 9;\n                                      break;\n                                    }\n                                    this.__CP__ = 5;\n                                    break;\n                                  case 10:\n                                    this.__CP__ = 5;\n                                    this.yield(_7_script);\n                                    return true;\n                                  case 0:\n                                    this.__CP__ = 2;\n                                    break;\n                                  case 4:\n                                    this._7_script = mc.getMigrationComponent().fetchMigrationScript(new MigrationScriptReference(it, _2_ver), true);\n                                    this.__CP__ = 8;\n                                    break;\n                                  case 9:\n                                    this.__CP__ = 10;\n                                    break;\n                                  default:\n                                    break __loop__;\n                                }\n                              } while (true);\n                              return false;\n                            }\n                            private int _2_ver;\n                            private MigrationScript _7_script;\n                          };\n                        }\n                      };\n                    }\n                  });\n                  Sequence.fromIterable(scripts).visitAll(new IVisitor<MigrationScript>() {\n                    public void visit(MigrationScript it) {\n                      it.execute(module);\n                    }\n                  });\n                }\n              });\n            }\n          });\n          progressMonitor.advance(1);\n          if (progressMonitor.isCanceled()) {\n            break;\n          }\n        }\n      }\n    });\n  }","id":80960,"modified_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    final MigrationComponent mc = event.getData(CommonDataKeys.PROJECT).getComponent(MigrationComponent.class);\n\n    final List<SModule>[] modules = new List[1];\n    event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        modules[0] = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(event.getData(MPSCommonDataKeys.MPS_PROJECT))).toListSequence();\n      }\n    });\n    ProgressManager.getInstance().run(new Task.Modal(event.getData(CommonDataKeys.PROJECT), \"Run Migrations\", true) {\n      public void run(@NotNull ProgressIndicator progressIndicator) {\n        ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);\n        int steps = modules[0].size();\n        progressMonitor.start(\"Running...\", steps);\n        for (final SModule module : ListSequence.fromList(modules[0])) {\n          progressMonitor.step(module.getModuleName());\n          WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {\n            public void run() {\n              event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository().getModelAccess().executeCommand(new Runnable() {\n                public void run() {\n                  Set<SLanguage> languages = new SLanguageHierarchy(LanguageRegistry.getInstance(event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository()), module.getUsedLanguages()).getExtended();\n                  Iterable<MigrationScript> scripts = SetSequence.fromSet(languages).translate(new ITranslator2<SLanguage, MigrationScript>() {\n                    public Iterable<MigrationScript> translate(final SLanguage it) {\n                      return new Iterable<MigrationScript>() {\n                        public Iterator<MigrationScript> iterator() {\n                          return new YieldingIterator<MigrationScript>() {\n                            private int __CP__ = 0;\n                            protected boolean moveToNext() {\n__loop__:\n                              do {\n__switch__:\n                                switch (this.__CP__) {\n                                  case -1:\n                                    assert false : \"Internal error\";\n                                    return false;\n                                  case 2:\n                                    this._2_ver = 0;\n                                  case 3:\n                                    if (!(_2_ver < it.getLanguageVersion())) {\n                                      this.__CP__ = 1;\n                                      break;\n                                    }\n                                    this.__CP__ = 4;\n                                    break;\n                                  case 5:\n                                    _2_ver++;\n                                    this.__CP__ = 3;\n                                    break;\n                                  case 8:\n                                    if (_7_script != null && Sequence.fromIterable(_7_script.requiresData()).isEmpty() && _7_script.isRerunnable()) {\n                                      this.__CP__ = 9;\n                                      break;\n                                    }\n                                    this.__CP__ = 5;\n                                    break;\n                                  case 10:\n                                    this.__CP__ = 5;\n                                    this.yield(_7_script);\n                                    return true;\n                                  case 0:\n                                    this.__CP__ = 2;\n                                    break;\n                                  case 4:\n                                    this._7_script = mc.fetchMigrationScript(new MigrationScriptReference(it, _2_ver), true);\n                                    this.__CP__ = 8;\n                                    break;\n                                  case 9:\n                                    this.__CP__ = 10;\n                                    break;\n                                  default:\n                                    break __loop__;\n                                }\n                              } while (true);\n                              return false;\n                            }\n                            private int _2_ver;\n                            private MigrationScript _7_script;\n                          };\n                        }\n                      };\n                    }\n                  });\n                  Sequence.fromIterable(scripts).visitAll(new IVisitor<MigrationScript>() {\n                    public void visit(MigrationScript it) {\n                      it.execute(module);\n                    }\n                  });\n                }\n              });\n            }\n          });\n          progressMonitor.advance(1);\n          if (progressMonitor.isCanceled()) {\n            break;\n          }\n        }\n      }\n    });\n  }","commit_id":"d3298483c03ed804964137c1a75d60c7f427f580","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RunPreUpdateCheck_Action() {\n    super(\"Run Pre-Update Check\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(false);\n  }","id":80961,"modified_method":"public RunPreUpdateCheck_Action() {\n    super(\"Run Pre-Update Check\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"d3298483c03ed804964137c1a75d60c7f427f580","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    List<Problem> problems = ListSequence.fromList(new ArrayList<Problem>());\n\n    final MigrationManagerImpl mc = ((MigrationManagerImpl) event.getData(CommonDataKeys.PROJECT).getComponent(MigrationManager.class));\n    {\n      final SearchScope scope = CommandUtil.createScope(((jetbrains.mps.project.Project) event.getData(MPSCommonDataKeys.MPS_PROJECT)));\n      QueryExecutionContext context = new QueryExecutionContext() {\n        public SearchScope getDefaultSearchScope() {\n          return scope;\n        }\n      };\n      for (final SModule module : Sequence.fromIterable(CommandUtil.modules(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SModule>() {\n        public boolean accept(SModule it) {\n          return MigrationsUtil.isModuleMigrateable(it);\n        }\n      })) {\n        Set<SLanguage> languages = new SLanguageHierarchy(module.getUsedLanguages()).getExtended();\n        Iterable<MigrationScript> scripts = SetSequence.fromSet(languages).translate(new ITranslator2<SLanguage, MigrationScript>() {\n          public Iterable<MigrationScript> translate(final SLanguage it) {\n            return new Iterable<MigrationScript>() {\n              public Iterator<MigrationScript> iterator() {\n                return new YieldingIterator<MigrationScript>() {\n                  private int __CP__ = 0;\n                  protected boolean moveToNext() {\n__loop__:\n                    do {\n__switch__:\n                      switch (this.__CP__) {\n                        case -1:\n                          assert false : \"Internal error\";\n                          return false;\n                        case 2:\n                          this._2_ver = 0;\n                        case 3:\n                          if (!(_2_ver < it.getLanguageVersion())) {\n                            this.__CP__ = 1;\n                            break;\n                          }\n                          this.__CP__ = 4;\n                          break;\n                        case 5:\n                          _2_ver++;\n                          this.__CP__ = 3;\n                          break;\n                        case 8:\n                          if (_7_script != null) {\n                            this.__CP__ = 9;\n                            break;\n                          }\n                          this.__CP__ = 5;\n                          break;\n                        case 10:\n                          this.__CP__ = 5;\n                          this.yield(_7_script);\n                          return true;\n                        case 0:\n                          this.__CP__ = 2;\n                          break;\n                        case 4:\n                          this._7_script = mc.getMigrationComponent().fetchMigrationScript(new MigrationScriptReference(it, _2_ver), true);\n                          this.__CP__ = 8;\n                          break;\n                        case 9:\n                          this.__CP__ = 10;\n                          break;\n                        default:\n                          break __loop__;\n                      }\n                    } while (true);\n                    return false;\n                  }\n                  private int _2_ver;\n                  private MigrationScript _7_script;\n                };\n              }\n            };\n          }\n        });\n        ListSequence.fromList(problems).addSequence(Sequence.fromIterable(scripts).translate(new ITranslator2<MigrationScript, Problem>() {\n          public Iterable<Problem> translate(MigrationScript it) {\n            return it.check(module);\n          }\n        }));\n\n        if (ListSequence.fromList(problems).isEmpty()) {\n          Messages.showMessageDialog(event.getData(CommonDataKeys.PROJECT), \"No problems found.\\nProject can be migrated\", \"Migration\", null);\n          return;\n        }\n      }\n    }\n\n    MigrationOutputUtil.showProblems(event.getData(CommonDataKeys.PROJECT), problems);\n  }","id":80962,"modified_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    final List<Problem> problems = ListSequence.fromList(new ArrayList<Problem>());\n    final MigrationComponent mc = event.getData(CommonDataKeys.PROJECT).getComponent(MigrationComponent.class);\n    final List<SModule>[] modules = new List[1];\n    event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        modules[0] = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(event.getData(MPSCommonDataKeys.MPS_PROJECT))).toListSequence();\n      }\n    });\n\n    ProgressManager.getInstance().run(new Task.Modal(event.getData(CommonDataKeys.PROJECT), \"Pre-Update Check\", true) {\n      public void run(@NotNull ProgressIndicator progressIndicator) {\n        ProgressMonitorAdapter progressMonitor = new ProgressMonitorAdapter(progressIndicator);\n        int steps = modules[0].size();\n        progressMonitor.start(\"Running...\", steps);\n        for (final SModule module : ListSequence.fromList(modules[0])) {\n          progressMonitor.step(module.getModuleName());\n          WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {\n            public void run() {\n              event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository().getModelAccess().executeCommand(new Runnable() {\n                public void run() {\n                  Set<SLanguage> languages = new SLanguageHierarchy(LanguageRegistry.getInstance(event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository()), module.getUsedLanguages()).getExtended();\n                  Iterable<MigrationScript> scripts = SetSequence.fromSet(languages).translate(new ITranslator2<SLanguage, MigrationScript>() {\n                    public Iterable<MigrationScript> translate(final SLanguage it) {\n                      return new Iterable<MigrationScript>() {\n                        public Iterator<MigrationScript> iterator() {\n                          return new YieldingIterator<MigrationScript>() {\n                            private int __CP__ = 0;\n                            protected boolean moveToNext() {\n__loop__:\n                              do {\n__switch__:\n                                switch (this.__CP__) {\n                                  case -1:\n                                    assert false : \"Internal error\";\n                                    return false;\n                                  case 2:\n                                    this._2_ver = 0;\n                                  case 3:\n                                    if (!(_2_ver < it.getLanguageVersion())) {\n                                      this.__CP__ = 1;\n                                      break;\n                                    }\n                                    this.__CP__ = 4;\n                                    break;\n                                  case 5:\n                                    _2_ver++;\n                                    this.__CP__ = 3;\n                                    break;\n                                  case 8:\n                                    if (_7_script != null) {\n                                      this.__CP__ = 9;\n                                      break;\n                                    }\n                                    this.__CP__ = 5;\n                                    break;\n                                  case 10:\n                                    this.__CP__ = 5;\n                                    this.yield(_7_script);\n                                    return true;\n                                  case 0:\n                                    this.__CP__ = 2;\n                                    break;\n                                  case 4:\n                                    this._7_script = mc.fetchMigrationScript(new MigrationScriptReference(it, _2_ver), true);\n                                    this.__CP__ = 8;\n                                    break;\n                                  case 9:\n                                    this.__CP__ = 10;\n                                    break;\n                                  default:\n                                    break __loop__;\n                                }\n                              } while (true);\n                              return false;\n                            }\n                            private int _2_ver;\n                            private MigrationScript _7_script;\n                          };\n                        }\n                      };\n                    }\n                  });\n                  ListSequence.fromList(problems).addSequence(Sequence.fromIterable(scripts).translate(new ITranslator2<MigrationScript, Problem>() {\n                    public Iterable<Problem> translate(MigrationScript it) {\n                      return it.check(module);\n                    }\n                  }));\n                }\n              });\n            }\n          });\n          progressMonitor.advance(1);\n          if (progressMonitor.isCanceled()) {\n            break;\n          }\n        }\n      }\n    });\n\n    if (ListSequence.fromList(problems).isEmpty()) {\n      Messages.showMessageDialog(event.getData(CommonDataKeys.PROJECT), \"No problems found.\\nProject can be migrated\", \"Migration\", null);\n    } else {\n      MigrationOutputUtil.showProblems(event.getData(CommonDataKeys.PROJECT), problems);\n    }\n  }","commit_id":"d3298483c03ed804964137c1a75d60c7f427f580","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doubleClick() {\n    IDEProjectFrame ide = (IDEProjectFrame)this.getOperationContext().getComponent(AbstractProjectFrame.class);\n    ide.openNode(this.testCase, this.getOperationContext());\n  }","id":80963,"modified_method":"public void doubleClick() {\n    this.getOperationContext().getComponent(MPSEditorOpener.class).openNode(this.testCase);\n  }","commit_id":"20f2757b68980452aa196938f1382b74d0a4544b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doubleClick() {\n    IDEProjectFrame ide = (IDEProjectFrame)this.getOperationContext().getComponent(AbstractProjectFrame.class);\n    ide.openNode(this.testMethod, this.getOperationContext());\n  }","id":80964,"modified_method":"public void doubleClick() {\n    this.getOperationContext().getComponent(MPSEditorOpener.class).openNode(this.testMethod);\n  }","commit_id":"20f2757b68980452aa196938f1382b74d0a4544b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        managedObject.removeItemListener(registrationId);\n    }","id":80965,"modified_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        if (service.isRunning()){\n            managedObject.removeItemListener(registrationId);\n        }\n    }","commit_id":"052874f3d239759c3902b8e0c4ef4f4e3bc3143a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        managedObject.removeEntryListener(listenerId);\n    }","id":80966,"modified_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        if (service.isRunning()){\n            managedObject.removeEntryListener(listenerId);\n        }\n    }","commit_id":"052874f3d239759c3902b8e0c4ef4f4e3bc3143a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        managedObject.removeItemListener(registrationId);\n    }","id":80967,"modified_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        if (service.isRunning()){\n            managedObject.removeItemListener(registrationId);\n        }\n    }","commit_id":"052874f3d239759c3902b8e0c4ef4f4e3bc3143a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        managedObject.removeItemListener(registrationId);\n    }","id":80968,"modified_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        if (service.isRunning()){\n            managedObject.removeItemListener(registrationId);\n        }\n    }","commit_id":"052874f3d239759c3902b8e0c4ef4f4e3bc3143a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        managedObject.removeMessageListener(registrationId);\n    }","id":80969,"modified_method":"public void preDeregister() throws Exception {\n        super.preDeregister();\n        if (service.isRunning()){\n            managedObject.removeMessageListener(registrationId);\n        }\n    }","commit_id":"052874f3d239759c3902b8e0c4ef4f4e3bc3143a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    private void createSockets() throws Exception {\n        InetAddress tmp_addr;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n        if(tos > 0) {\n            try {\n                sock.setTrafficClass(tos);\n            }\n            catch(SocketException e) {\n                log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n            }\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            ((IpAddress)local_addr).setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n\n            if(receive_on_all_interfaces || (receive_interfaces != null && receive_interfaces.size() > 0)) {\n                List interfaces;\n                if(receive_interfaces != null)\n                    interfaces=receive_interfaces;\n                else\n                    interfaces=getAllAvailableInterfaces();\n                bindToInterfaces(interfaces, mcast_recv_sock, mcast_addr.getIpAddress());\n            }\n            else {\n                if(bind_addr != null)\n                    mcast_recv_sock.setInterface(bind_addr);\n                 mcast_recv_sock.joinGroup(tmp_addr);\n            }\n\n            // 3b. Create mcast sender socket\n            mcast_send_sock=new MulticastSocket();\n            mcast_send_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_send_sock.setInterface(bind_addr);\n\n            if(tos > 0) {\n                try {\n                    mcast_send_sock.setTrafficClass(tos); // high throughput\n                }\n                catch(SocketException e) {\n                    log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n                }\n            }\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","id":80970,"modified_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    private void createSockets() throws Exception {\n        InetAddress tmp_addr;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n        if(tos > 0) {\n            try {\n                sock.setTrafficClass(tos);\n            }\n            catch(SocketException e) {\n                log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n            }\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            ((IpAddress)local_addr).setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n\n            if(receive_on_all_interfaces || (receive_interfaces != null && receive_interfaces.size() > 0)) {\n                List interfaces;\n                if(receive_interfaces != null)\n                    interfaces=receive_interfaces;\n                else\n                    interfaces=getAllAvailableInterfaces();\n                bindToInterfaces(interfaces, mcast_recv_sock, mcast_addr.getIpAddress());\n            }\n            else {\n                if(bind_addr != null)\n                    mcast_recv_sock.setInterface(bind_addr);\n                 mcast_recv_sock.joinGroup(tmp_addr);\n            }\n\n            // 3b. Create mcast sender socket\n            if(send_on_all_interfaces || (send_interfaces != null && send_interfaces.size() > 0)) {\n                List interfaces;\n                NetworkInterface intf;\n                if(send_interfaces != null)\n                    interfaces=send_interfaces;\n                else\n                    interfaces=getAllAvailableInterfaces();\n                mcast_send_sockets=new MulticastSocket[interfaces.size()];\n                int index=0;\n                for(Iterator it=interfaces.iterator(); it.hasNext();) {\n                    intf=(NetworkInterface)it.next();\n                    mcast_send_sockets[index]=new MulticastSocket();\n                    mcast_send_sockets[index].setNetworkInterface(intf);\n                    mcast_send_sockets[index].setTimeToLive(ip_ttl);\n                    if(tos > 0) {\n                        try {\n                            mcast_send_sockets[index].setTrafficClass(tos);\n                        }\n                        catch(SocketException e) {\n                            log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n                        }\n                    }\n                    index++;\n                }\n            }\n            else {\n                mcast_send_sock=new MulticastSocket();\n                mcast_send_sock.setTimeToLive(ip_ttl);\n                if(bind_addr != null)\n                    mcast_send_sock.setInterface(bind_addr);\n\n                if(tos > 0) {\n                    try {\n                        mcast_send_sock.setTrafficClass(tos); // high throughput\n                    }\n                    catch(SocketException e) {\n                        log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n                    }\n                }\n            }\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","commit_id":"075a3e97b4b84eb858e1cfc836fc15d1eb075d24","url":"https://github.com/belaban/JGroups"},{"original_method":"private void _send(InetAddress dest, int port, boolean mcast, byte[] data, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(data, offset, length, dest, port);\n        try {\n            if(mcast && mcast_send_sock != null) { // mcast_recv_sock might be null if ip_mcast is false\n                mcast_send_sock.send(packet);\n            }\n            else {\n                if(sock != null)\n                    sock.send(packet);\n            }\n        }\n        catch(Exception ex) {\n            Exception new_ex=new Exception(\"dest=\" + dest + \":\" + port + \" (\" + length + \" bytes)\", ex);\n            throw new_ex;\n        }\n    }","id":80971,"modified_method":"private void _send(InetAddress dest, int port, boolean mcast, byte[] data, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(data, offset, length, dest, port);\n        try {\n            if(mcast) {\n                if(mcast_send_sock != null)\n                    mcast_send_sock.send(packet);\n                else {\n                    if(mcast_send_sockets != null) {\n                        MulticastSocket s;\n                        for(int i=0; i < mcast_send_sockets.length; i++) {\n                            s=mcast_send_sockets[i];\n                            try {\n                                s.send(packet);\n                            }\n                            catch(Exception e) {\n                                log.error(\"failed sending packet on socket \" + s);\n                            }\n                        }\n                    }\n                    else {\n                        throw new Exception(\"both mcast_send_sock and mcast_send_sockets are null\");\n                    }\n                }\n            }\n            else {\n                if(sock != null)\n                    sock.send(packet);\n            }\n        }\n        catch(Exception ex) {\n            Exception new_ex=new Exception(\"dest=\" + dest + \":\" + port + \" (\" + length + \" bytes)\", ex);\n            throw new_ex;\n        }\n    }","commit_id":"075a3e97b4b84eb858e1cfc836fc15d1eb075d24","url":"https://github.com/belaban/JGroups"},{"original_method":"void closeSocket() {\n        if(sock != null) {\n            sock.close();\n            sock=null;\n            if(log.isDebugEnabled()) log.debug(\"socket closed\");\n        }\n    }","id":80972,"modified_method":"private void closeSocket() {\n        if(sock != null) {\n            sock.close();\n            sock=null;\n            if(log.isDebugEnabled()) log.debug(\"socket closed\");\n        }\n    }","commit_id":"075a3e97b4b84eb858e1cfc836fc15d1eb075d24","url":"https://github.com/belaban/JGroups"},{"original_method":"void closeMulticastSocket() {\n        if(mcast_recv_sock != null) {\n            try {\n                if(mcast_addr != null) {\n                    mcast_recv_sock.leaveGroup(mcast_addr.getIpAddress());\n                }\n                mcast_recv_sock.close(); // this will cause the mcast receiver thread to break out of its loop\n                mcast_recv_sock=null;\n                if(log.isDebugEnabled()) log.debug(\"multicast receive socket closed\");\n            }\n            catch(IOException ex) {\n            }\n            mcast_addr=null;\n        }\n\n        if(mcast_send_sock != null) {\n            mcast_send_sock.close(); // this will cause the mcast sender thread to break out of its loop\n            mcast_send_sock=null;\n            if(log.isDebugEnabled()) log.debug(\"multicast send socket closed\");\n        }\n    }","id":80973,"modified_method":"void closeMulticastSocket() {\n        if(mcast_recv_sock != null) {\n            try {\n                if(mcast_addr != null) {\n                    mcast_recv_sock.leaveGroup(mcast_addr.getIpAddress());\n                }\n                mcast_recv_sock.close(); // this will cause the mcast receiver thread to break out of its loop\n                mcast_recv_sock=null;\n                if(log.isDebugEnabled()) log.debug(\"multicast receive socket closed\");\n            }\n            catch(IOException ex) {\n            }\n            mcast_addr=null;\n        }\n\n        if(mcast_send_sock != null) {\n            mcast_send_sock.close();\n            mcast_send_sock=null;\n            if(log.isDebugEnabled()) log.debug(\"multicast send socket closed\");\n        }\n        if(mcast_send_sockets != null) {\n            MulticastSocket s;\n            for(int i=0; i < mcast_send_sockets.length; i++) {\n                s=mcast_send_sockets[i];\n                s.close();\n                if(log.isDebugEnabled()) log.debug(\"multicast send socket \" + s + \" closed\");\n            }\n            mcast_send_sockets=null;\n        }\n    }","commit_id":"075a3e97b4b84eb858e1cfc836fc15d1eb075d24","url":"https://github.com/belaban/JGroups"},{"original_method":"void setBufferSizes() {\n        if(sock != null) {\n            try {\n                sock.setSendBufferSize(ucast_send_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting ucast_send_buf_size in sock: \" + ex);\n            }\n            try {\n                sock.setReceiveBufferSize(ucast_recv_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting ucast_recv_buf_size in sock: \" + ex);\n            }\n        }\n\n        if(mcast_recv_sock != null) {\n            try {\n                mcast_recv_sock.setSendBufferSize(mcast_send_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_send_buf_size in mcast_recv_sock: \" + ex);\n            }\n\n            try {\n                mcast_recv_sock.setReceiveBufferSize(mcast_recv_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_recv_buf_size in mcast_recv_sock: \" + ex);\n            }\n        }\n\n        if(mcast_send_sock != null) {\n            try {\n                mcast_send_sock.setSendBufferSize(mcast_send_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_send_buf_size in mcast_send_sock: \" + ex);\n            }\n\n            try {\n                mcast_send_sock.setReceiveBufferSize(mcast_recv_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_recv_buf_size in mcast_send_sock: \" + ex);\n            }\n        }\n\n    }","id":80974,"modified_method":"void setBufferSizes() {\n        if(sock != null)\n            setBufferSize(sock, ucast_send_buf_size, ucast_recv_buf_size);\n\n        if(mcast_recv_sock != null)\n            setBufferSize(mcast_recv_sock, mcast_send_buf_size, mcast_recv_buf_size);\n\n        if(mcast_send_sock != null)\n            setBufferSize(mcast_send_sock, mcast_send_buf_size, mcast_recv_buf_size);\n\n        if(mcast_send_sockets != null) {\n            for(int i=0; i < mcast_send_sockets.length; i++) {\n                setBufferSize(mcast_send_sockets[i], mcast_send_buf_size, mcast_recv_buf_size);\n            }\n        }\n    }","commit_id":"075a3e97b4b84eb858e1cfc836fc15d1eb075d24","url":"https://github.com/belaban/JGroups"},{"original_method":"private String dumpSocketInfo() throws Exception {\n        StringBuffer sb=new StringBuffer(128);\n        sb.append(\"local_addr=\").append(local_addr);\n        sb.append(\", mcast_addr=\").append(mcast_addr);\n        sb.append(\", bind_addr=\").append(bind_addr);\n        sb.append(\", ttl=\").append(ip_ttl);\n\n        if(sock != null) {\n            sb.append(\"\\nsock: bound to \");\n            sb.append(sock.getLocalAddress().getHostAddress()).append(':').append(sock.getLocalPort());\n            sb.append(\", receive buffer size=\").append(sock.getReceiveBufferSize());\n            sb.append(\", send buffer size=\").append(sock.getSendBufferSize());\n        }\n\n        if(mcast_recv_sock != null) {\n            sb.append(\"\\nmcast_recv_sock: bound to \");\n            sb.append(mcast_recv_sock.getInterface().getHostAddress()).append(':').append(mcast_recv_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_recv_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_recv_sock.getReceiveBufferSize());\n        }\n\n         if(mcast_send_sock != null) {\n            sb.append(\"\\nmcast_send_sock: bound to \");\n            sb.append(mcast_send_sock.getInterface().getHostAddress()).append(':').append(mcast_send_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_send_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_send_sock.getReceiveBufferSize());\n        }\n        return sb.toString();\n    }","id":80975,"modified_method":"private String dumpSocketInfo() throws Exception {\n        StringBuffer sb=new StringBuffer(128);\n        sb.append(\"local_addr=\").append(local_addr);\n        sb.append(\", mcast_addr=\").append(mcast_addr);\n        sb.append(\", bind_addr=\").append(bind_addr);\n        sb.append(\", ttl=\").append(ip_ttl);\n\n        if(sock != null) {\n            sb.append(\"\\nsock: bound to \");\n            sb.append(sock.getLocalAddress().getHostAddress()).append(':').append(sock.getLocalPort());\n            sb.append(\", receive buffer size=\").append(sock.getReceiveBufferSize());\n            sb.append(\", send buffer size=\").append(sock.getSendBufferSize());\n        }\n\n        if(mcast_recv_sock != null) {\n            sb.append(\"\\nmcast_recv_sock: bound to \");\n            sb.append(mcast_recv_sock.getInterface().getHostAddress()).append(':').append(mcast_recv_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_recv_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_recv_sock.getReceiveBufferSize());\n        }\n\n         if(mcast_send_sock != null) {\n            sb.append(\"\\nmcast_send_sock: bound to \");\n            sb.append(mcast_send_sock.getInterface().getHostAddress()).append(':').append(mcast_send_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_send_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_send_sock.getReceiveBufferSize());\n        }\n        if(mcast_send_sockets != null) {\n            sb.append(\"\\n\").append(mcast_send_sockets.length).append(\" mcast send sockets:\\n\");\n            MulticastSocket s;\n            for(int i=0; i < mcast_send_sockets.length; i++) {\n                s=mcast_send_sockets[i];\n                sb.append(s.getInterface().getHostAddress()).append(':').append(s.getLocalPort());\n                sb.append(\", send buffer size=\").append(s.getSendBufferSize());\n                sb.append(\", receive buffer size=\").append(s.getReceiveBufferSize()).append(\"\\n\");\n            }\n        }\n        return sb.toString();\n    }","commit_id":"075a3e97b4b84eb858e1cfc836fc15d1eb075d24","url":"https://github.com/belaban/JGroups"},{"original_method":"private void _send(InetAddress dest, int port, boolean mcast, byte[] data, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(data, offset, length, dest, port);\n        try {\n            if(mcast && mcast_send_sock != null) { // mcast_recv_sock might be null if ip_mcast is false\n                mcast_send_sock.send(packet);\n            }\n            else {\n                if(sock != null)\n                    sock.send(packet);\n            }\n        }\n        catch(Exception ex) {\n            Exception new_ex=new Exception(\"dest=\" + dest + \":\" + port + \" (\" + length + \" bytes)\", ex);\n            throw new_ex;\n        }\n    }","id":80976,"modified_method":"private void _send(InetAddress dest, int port, boolean mcast, byte[] data, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(data, offset, length, dest, port);\n        try {\n            if(mcast) {\n                if(mcast_send_sock != null)\n                    mcast_send_sock.send(packet);\n                else {\n                    if(mcast_send_sockets != null) {\n                        MulticastSocket s;\n                        for(int i=0; i < mcast_send_sockets.length; i++) {\n                            s=mcast_send_sockets[i];\n                            try {\n                                s.send(packet);\n                            }\n                            catch(Exception e) {\n                                log.error(\"failed sending packet on socket \" + s);\n                            }\n                        }\n                    }\n                    else {\n                        throw new Exception(\"both mcast_send_sock and mcast_send_sockets are null\");\n                    }\n                }\n            }\n            else {\n                if(sock != null)\n                    sock.send(packet);\n            }\n        }\n        catch(Exception ex) {\n            Exception new_ex=new Exception(\"dest=\" + dest + \":\" + port + \" (\" + length + \" bytes)\", ex);\n            throw new_ex;\n        }\n    }","commit_id":"15a3b3ca4baf0c6879061a1dcbb09bbeb6ff2405","url":"https://github.com/belaban/JGroups"},{"original_method":"void closeSocket() {\n        if(sock != null) {\n            sock.close();\n            sock=null;\n            if(log.isDebugEnabled()) log.debug(\"socket closed\");\n        }\n    }","id":80977,"modified_method":"private void closeSocket() {\n        if(sock != null) {\n            sock.close();\n            sock=null;\n            if(log.isDebugEnabled()) log.debug(\"socket closed\");\n        }\n    }","commit_id":"15a3b3ca4baf0c6879061a1dcbb09bbeb6ff2405","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    private void createSockets() throws Exception {\n        InetAddress tmp_addr;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n        if(tos > 0) {\n            try {\n                sock.setTrafficClass(tos);\n            }\n            catch(SocketException e) {\n                log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n            }\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            ((IpAddress)local_addr).setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n\n            if(receive_on_all_interfaces || (receive_interfaces != null && receive_interfaces.size() > 0)) {\n                List interfaces;\n                if(receive_interfaces != null)\n                    interfaces=receive_interfaces;\n                else\n                    interfaces=getAllAvailableInterfaces();\n                bindToInterfaces(interfaces, mcast_recv_sock, mcast_addr.getIpAddress());\n            }\n            else {\n                if(bind_addr != null)\n                    mcast_recv_sock.setInterface(bind_addr);\n                 mcast_recv_sock.joinGroup(tmp_addr);\n            }\n\n            // 3b. Create mcast sender socket\n            mcast_send_sock=new MulticastSocket();\n            mcast_send_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_send_sock.setInterface(bind_addr);\n\n            if(tos > 0) {\n                try {\n                    mcast_send_sock.setTrafficClass(tos); // high throughput\n                }\n                catch(SocketException e) {\n                    log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n                }\n            }\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","id":80978,"modified_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    private void createSockets() throws Exception {\n        InetAddress tmp_addr;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n        if(tos > 0) {\n            try {\n                sock.setTrafficClass(tos);\n            }\n            catch(SocketException e) {\n                log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n            }\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            ((IpAddress)local_addr).setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n\n            if(receive_on_all_interfaces || (receive_interfaces != null && receive_interfaces.size() > 0)) {\n                List interfaces;\n                if(receive_interfaces != null)\n                    interfaces=receive_interfaces;\n                else\n                    interfaces=getAllAvailableInterfaces();\n                bindToInterfaces(interfaces, mcast_recv_sock, mcast_addr.getIpAddress());\n            }\n            else {\n                if(bind_addr != null)\n                    mcast_recv_sock.setInterface(bind_addr);\n                 mcast_recv_sock.joinGroup(tmp_addr);\n            }\n\n            // 3b. Create mcast sender socket\n            if(send_on_all_interfaces || (send_interfaces != null && send_interfaces.size() > 0)) {\n                List interfaces;\n                NetworkInterface intf;\n                if(send_interfaces != null)\n                    interfaces=send_interfaces;\n                else\n                    interfaces=getAllAvailableInterfaces();\n                mcast_send_sockets=new MulticastSocket[interfaces.size()];\n                int index=0;\n                for(Iterator it=interfaces.iterator(); it.hasNext();) {\n                    intf=(NetworkInterface)it.next();\n                    mcast_send_sockets[index]=new MulticastSocket();\n                    mcast_send_sockets[index].setNetworkInterface(intf);\n                    mcast_send_sockets[index].setTimeToLive(ip_ttl);\n                    if(tos > 0) {\n                        try {\n                            mcast_send_sockets[index].setTrafficClass(tos);\n                        }\n                        catch(SocketException e) {\n                            log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n                        }\n                    }\n                    index++;\n                }\n            }\n            else {\n                mcast_send_sock=new MulticastSocket();\n                mcast_send_sock.setTimeToLive(ip_ttl);\n                if(bind_addr != null)\n                    mcast_send_sock.setInterface(bind_addr);\n\n                if(tos > 0) {\n                    try {\n                        mcast_send_sock.setTrafficClass(tos); // high throughput\n                    }\n                    catch(SocketException e) {\n                        log.warn(\"traffic class of \" + tos + \" could not be set, will be ignored\", e);\n                    }\n                }\n            }\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","commit_id":"15a3b3ca4baf0c6879061a1dcbb09bbeb6ff2405","url":"https://github.com/belaban/JGroups"},{"original_method":"private String dumpSocketInfo() throws Exception {\n        StringBuffer sb=new StringBuffer(128);\n        sb.append(\"local_addr=\").append(local_addr);\n        sb.append(\", mcast_addr=\").append(mcast_addr);\n        sb.append(\", bind_addr=\").append(bind_addr);\n        sb.append(\", ttl=\").append(ip_ttl);\n\n        if(sock != null) {\n            sb.append(\"\\nsock: bound to \");\n            sb.append(sock.getLocalAddress().getHostAddress()).append(':').append(sock.getLocalPort());\n            sb.append(\", receive buffer size=\").append(sock.getReceiveBufferSize());\n            sb.append(\", send buffer size=\").append(sock.getSendBufferSize());\n        }\n\n        if(mcast_recv_sock != null) {\n            sb.append(\"\\nmcast_recv_sock: bound to \");\n            sb.append(mcast_recv_sock.getInterface().getHostAddress()).append(':').append(mcast_recv_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_recv_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_recv_sock.getReceiveBufferSize());\n        }\n\n         if(mcast_send_sock != null) {\n            sb.append(\"\\nmcast_send_sock: bound to \");\n            sb.append(mcast_send_sock.getInterface().getHostAddress()).append(':').append(mcast_send_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_send_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_send_sock.getReceiveBufferSize());\n        }\n        return sb.toString();\n    }","id":80979,"modified_method":"private String dumpSocketInfo() throws Exception {\n        StringBuffer sb=new StringBuffer(128);\n        sb.append(\"local_addr=\").append(local_addr);\n        sb.append(\", mcast_addr=\").append(mcast_addr);\n        sb.append(\", bind_addr=\").append(bind_addr);\n        sb.append(\", ttl=\").append(ip_ttl);\n\n        if(sock != null) {\n            sb.append(\"\\nsock: bound to \");\n            sb.append(sock.getLocalAddress().getHostAddress()).append(':').append(sock.getLocalPort());\n            sb.append(\", receive buffer size=\").append(sock.getReceiveBufferSize());\n            sb.append(\", send buffer size=\").append(sock.getSendBufferSize());\n        }\n\n        if(mcast_recv_sock != null) {\n            sb.append(\"\\nmcast_recv_sock: bound to \");\n            sb.append(mcast_recv_sock.getInterface().getHostAddress()).append(':').append(mcast_recv_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_recv_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_recv_sock.getReceiveBufferSize());\n        }\n\n         if(mcast_send_sock != null) {\n            sb.append(\"\\nmcast_send_sock: bound to \");\n            sb.append(mcast_send_sock.getInterface().getHostAddress()).append(':').append(mcast_send_sock.getLocalPort());\n            sb.append(\", send buffer size=\").append(mcast_send_sock.getSendBufferSize());\n            sb.append(\", receive buffer size=\").append(mcast_send_sock.getReceiveBufferSize());\n        }\n        if(mcast_send_sockets != null) {\n            sb.append(\"\\n\").append(mcast_send_sockets.length).append(\" mcast send sockets:\\n\");\n            MulticastSocket s;\n            for(int i=0; i < mcast_send_sockets.length; i++) {\n                s=mcast_send_sockets[i];\n                sb.append(s.getInterface().getHostAddress()).append(':').append(s.getLocalPort());\n                sb.append(\", send buffer size=\").append(s.getSendBufferSize());\n                sb.append(\", receive buffer size=\").append(s.getReceiveBufferSize()).append(\"\\n\");\n            }\n        }\n        return sb.toString();\n    }","commit_id":"15a3b3ca4baf0c6879061a1dcbb09bbeb6ff2405","url":"https://github.com/belaban/JGroups"},{"original_method":"void closeMulticastSocket() {\n        if(mcast_recv_sock != null) {\n            try {\n                if(mcast_addr != null) {\n                    mcast_recv_sock.leaveGroup(mcast_addr.getIpAddress());\n                }\n                mcast_recv_sock.close(); // this will cause the mcast receiver thread to break out of its loop\n                mcast_recv_sock=null;\n                if(log.isDebugEnabled()) log.debug(\"multicast receive socket closed\");\n            }\n            catch(IOException ex) {\n            }\n            mcast_addr=null;\n        }\n\n        if(mcast_send_sock != null) {\n            mcast_send_sock.close(); // this will cause the mcast sender thread to break out of its loop\n            mcast_send_sock=null;\n            if(log.isDebugEnabled()) log.debug(\"multicast send socket closed\");\n        }\n    }","id":80980,"modified_method":"void closeMulticastSocket() {\n        if(mcast_recv_sock != null) {\n            try {\n                if(mcast_addr != null) {\n                    mcast_recv_sock.leaveGroup(mcast_addr.getIpAddress());\n                }\n                mcast_recv_sock.close(); // this will cause the mcast receiver thread to break out of its loop\n                mcast_recv_sock=null;\n                if(log.isDebugEnabled()) log.debug(\"multicast receive socket closed\");\n            }\n            catch(IOException ex) {\n            }\n            mcast_addr=null;\n        }\n\n        if(mcast_send_sock != null) {\n            mcast_send_sock.close();\n            mcast_send_sock=null;\n            if(log.isDebugEnabled()) log.debug(\"multicast send socket closed\");\n        }\n        if(mcast_send_sockets != null) {\n            MulticastSocket s;\n            for(int i=0; i < mcast_send_sockets.length; i++) {\n                s=mcast_send_sockets[i];\n                s.close();\n                if(log.isDebugEnabled()) log.debug(\"multicast send socket \" + s + \" closed\");\n            }\n            mcast_send_sockets=null;\n        }\n    }","commit_id":"15a3b3ca4baf0c6879061a1dcbb09bbeb6ff2405","url":"https://github.com/belaban/JGroups"},{"original_method":"void setBufferSizes() {\n        if(sock != null) {\n            try {\n                sock.setSendBufferSize(ucast_send_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting ucast_send_buf_size in sock: \" + ex);\n            }\n            try {\n                sock.setReceiveBufferSize(ucast_recv_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting ucast_recv_buf_size in sock: \" + ex);\n            }\n        }\n\n        if(mcast_recv_sock != null) {\n            try {\n                mcast_recv_sock.setSendBufferSize(mcast_send_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_send_buf_size in mcast_recv_sock: \" + ex);\n            }\n\n            try {\n                mcast_recv_sock.setReceiveBufferSize(mcast_recv_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_recv_buf_size in mcast_recv_sock: \" + ex);\n            }\n        }\n\n        if(mcast_send_sock != null) {\n            try {\n                mcast_send_sock.setSendBufferSize(mcast_send_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_send_buf_size in mcast_send_sock: \" + ex);\n            }\n\n            try {\n                mcast_send_sock.setReceiveBufferSize(mcast_recv_buf_size);\n            }\n            catch(Throwable ex) {\n                if(warn) log.warn(\"failed setting mcast_recv_buf_size in mcast_send_sock: \" + ex);\n            }\n        }\n\n    }","id":80981,"modified_method":"void setBufferSizes() {\n        if(sock != null)\n            setBufferSize(sock, ucast_send_buf_size, ucast_recv_buf_size);\n\n        if(mcast_recv_sock != null)\n            setBufferSize(mcast_recv_sock, mcast_send_buf_size, mcast_recv_buf_size);\n\n        if(mcast_send_sock != null)\n            setBufferSize(mcast_send_sock, mcast_send_buf_size, mcast_recv_buf_size);\n\n        if(mcast_send_sockets != null) {\n            for(int i=0; i < mcast_send_sockets.length; i++) {\n                setBufferSize(mcast_send_sockets[i], mcast_send_buf_size, mcast_recv_buf_size);\n            }\n        }\n    }","commit_id":"15a3b3ca4baf0c6879061a1dcbb09bbeb6ff2405","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setChmod(String chmod) {\n        this.chmod = chmod;\n    }","id":80982,"modified_method":"public void setChmod(String chmod) {\n        if (chmod.length() == 3) {\n            for (byte c : chmod.getBytes()) {\n                if (c < '0' || c > '7') {\n                    chmod = DEFAULT_MOD;\n                    break;\n                }\n            }\n        } else {\n            chmod = DEFAULT_MOD;\n        }\n        // May be interesting to log the fallback to DEFAULT_MOD for invalid configuration\n        this.chmod = chmod;\n    }","commit_id":"d8282b725637a59e918eb5f55b98f84991f848f8","url":"https://github.com/apache/camel"},{"original_method":"private void writeFile(String filename, InputStream data, OutputStream os, InputStream is) throws IOException {\n        int pos = filename.indexOf('/');\n        if (pos >= 0) {\n            // write to child directory\n            String dir = filename.substring(0, pos);\n            os.write((\"D0775 0 \" + dir + \"\\n\").getBytes());\n            os.flush();\n            is.read();\n\n            writeFile(filename.substring(pos + 1), data, os, is);\n\n            os.write(\"E\\n\".getBytes());\n            os.flush();\n            is.read();\n        } else {\n            int count = 0;\n            int read = 0;\n            int size = endpoint.getBufferSize();\n            byte[] bytes = new byte[size];\n\n            // figure out the stream size as we need to pass it in the header\n            BufferedInputStream buffer = new BufferedInputStream(data, size);\n            buffer.mark(Integer.MAX_VALUE);\n            while ((read = buffer.read(bytes)) != -1) {\n                count += read;\n            }\n\n            // send the header\n            os.write((\"C0775 \" + count + \" \" + filename + \"\\n\").getBytes());\n            os.flush();\n            is.read();\n\n            // now send the stream\n            buffer.reset();\n            while ((read = buffer.read(bytes)) != -1) {\n                os.write(bytes, 0, read);\n            }\n            os.flush();\n            is.read();\n        }\n        os.write(0);\n        os.flush();\n    }","id":80983,"modified_method":"private void writeFile(String filename, InputStream data, OutputStream os, InputStream is, ScpConfiguration cfg) throws IOException {\n        final int lineFeed = '\\n';\n        String bytes;\n        int pos = filename.indexOf('/');\n        if (pos >= 0) {\n            // write to child directory\n            String dir = filename.substring(0, pos);\n            bytes = \"D0775 0 \" + dir;\n            LOG.trace(\"[scp:sink] {}\", bytes);\n            os.write(bytes.getBytes());\n            os.write(lineFeed);\n            os.flush();\n            readAck(is, false);\n\n            writeFile(filename.substring(pos + 1), data, os, is, cfg);\n\n            bytes = \"E\";\n            LOG.trace(\"[scp:sink] {}\", bytes);\n            os.write(bytes.getBytes());\n            os.write(lineFeed);\n            os.flush();\n            readAck(is, false);\n        } else {\n            int count = 0;\n            int read = 0;\n            int size = endpoint.getBufferSize();\n            byte[] reply = new byte[size];\n\n            // figure out the stream size as we need to pass it in the header\n            BufferedInputStream buffer = new BufferedInputStream(data, size);\n            buffer.mark(Integer.MAX_VALUE);\n            while ((read = buffer.read(reply)) != -1) {\n                count += read;\n            }\n\n            // send the header\n            bytes = \"C0\" + cfg.getChmod() + \" \" + count + \" \" + filename;\n            LOG.trace(\"[scp:sink] {}\", bytes);\n            os.write(bytes.getBytes());\n            os.write(lineFeed);\n            os.flush();\n            readAck(is, false);\n\n            // now send the stream\n            buffer.reset();\n            while ((read = buffer.read(reply)) != -1) {\n                os.write(reply, 0, read);\n            }\n            writeAck(os);\n            readAck(is, false);\n        }\n    }","commit_id":"d8282b725637a59e918eb5f55b98f84991f848f8","url":"https://github.com/apache/camel"},{"original_method":"private void write(ChannelExec c, String name, InputStream data) throws IOException {\n        OutputStream os = c.getOutputStream();\n        InputStream is = c.getInputStream();\n\n        writeFile(name, data, os, is);\n\n        os.close();\n        is.close();\n    }","id":80984,"modified_method":"private void write(ChannelExec c, String name, InputStream data, ScpConfiguration cfg) throws IOException {\n        OutputStream os = c.getOutputStream();\n        InputStream is = c.getInputStream();\n\n        writeFile(name, data, os, is, cfg);\n\n        os.close();\n        is.close();\n    }","commit_id":"d8282b725637a59e918eb5f55b98f84991f848f8","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public boolean storeFile(String name, Exchange exchange) throws GenericFileOperationFailedException {\n        ObjectHelper.notNull(session, \"session\");\n        ScpConfiguration cfg = endpoint.getConfiguration();\n        \n        int timeout = cfg.getConnectTimeout();\n        LOG.trace(\"Opening channel to {} with {} timeout...\", cfg.remoteServerInformation(), \n            timeout > 0 ? (Integer.toString(timeout) + \" ms\") : \"no\");\n        String file = getRemoteFile(name, cfg);\n        try {\n            channel = (ChannelExec) session.openChannel(\"exec\");\n            channel.setCommand(getScpCommand(cfg, file));\n            channel.connect(timeout);\n            LOG.trace(\"Channel connected to {}\", cfg.remoteServerInformation());\n\n            try {\n                write(channel, file, ExchangeHelper.getMandatoryInBody(exchange, InputStream.class));\n            } catch (InvalidPayloadException e) {\n                throw new GenericFileOperationFailedException(\"Failed extract message body as InputStream\", e);\n            } catch (IOException e) {\n                throw new GenericFileOperationFailedException(\"Failed to write file \" + file, e);\n            }\n        } catch (JSchException e) {\n            LOG.warn(\"Failed to secure copy file \" + file, e);\n            return false;\n        } finally {\n            if (channel != null) {\n                LOG.trace(\"Disconnecting 'exec' scp channel\");\n                channel.disconnect();\n                channel = null;\n                LOG.trace(\"Channel disconnected from {}\", cfg.remoteServerInformation());\n            }\n        }\n        return true;\n    }","id":80985,"modified_method":"@Override\n    public boolean storeFile(String name, Exchange exchange) throws GenericFileOperationFailedException {\n        ObjectHelper.notNull(session, \"session\");\n        ScpConfiguration cfg = endpoint.getConfiguration();\n        \n        int timeout = cfg.getConnectTimeout();\n        LOG.trace(\"Opening channel to {} with {} timeout...\", cfg.remoteServerInformation(), \n            timeout > 0 ? (Integer.toString(timeout) + \" ms\") : \"no\");\n        String file = getRemoteFile(name, cfg);\n        try {\n            channel = (ChannelExec) session.openChannel(\"exec\");\n            channel.setCommand(getScpCommand(cfg, file));\n            channel.connect(timeout);\n            LOG.trace(\"Channel connected to {}\", cfg.remoteServerInformation());\n\n            try {\n                write(channel, file, ExchangeHelper.getMandatoryInBody(exchange, InputStream.class), cfg);\n            } catch (InvalidPayloadException e) {\n                throw new GenericFileOperationFailedException(\"Failed extract message body as InputStream\", e);\n            } catch (IOException e) {\n                throw new GenericFileOperationFailedException(\"Failed to write file \" + file, e);\n            }\n        } catch (JSchException e) {\n            LOG.warn(\"Failed to secure copy file \" + file, e);\n            return false;\n        } finally {\n            if (channel != null) {\n                LOG.trace(\"Disconnecting 'exec' scp channel\");\n                channel.disconnect();\n                channel = null;\n                LOG.trace(\"Channel disconnected from {}\", cfg.remoteServerInformation());\n            }\n        }\n        return true;\n    }","commit_id":"d8282b725637a59e918eb5f55b98f84991f848f8","url":"https://github.com/apache/camel"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        final JMSServerManager jmsManager = jmsServer.getValue();\n        try {\n            WritableServiceBasedNamingStore.pushOwner(context.getChildTarget());\n            try {\n                jmsManager.createConnectionFactory(false, configuration, configuration.getBindings());\n            } finally {\n                WritableServiceBasedNamingStore.popOwner();\n            }\n        } catch (Exception e) {\n            throw new StartException(MESSAGES.failedToCreate(\"connection-factory\"), e);\n        }\n    }","id":80986,"modified_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        final JMSServerManager jmsManager = jmsServer.getValue();\n        try {\n            WritableServiceBasedNamingStore.pushOwner(context.getChildTarget());\n            try {\n                jmsManager.createConnectionFactory(false, configuration, configuration.getBindings());\n            } finally {\n                WritableServiceBasedNamingStore.popOwner();\n            }\n        } catch (Exception e) {\n            throw MESSAGES.failedToCreate(e, \"connection-factory\");\n        }\n    }","commit_id":"bbc784c68020b847ce8efc7eb99f4c7c54790ada","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        final JMSServerManager jmsManager = jmsServer.getValue();\n        try {\n            jmsManager.createQueue(false, queueName, selectorString, durable, jndi);\n        } catch (Exception e) {\n            throw new StartException(MESSAGES.failedToCreate(\"queue\"), e);\n        }\n    }","id":80987,"modified_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        final JMSServerManager jmsManager = jmsServer.getValue();\n        try {\n            jmsManager.createQueue(false, queueName, selectorString, durable, jndi);\n        } catch (Exception e) {\n            throw MESSAGES.failedToCreate(e, \"queue\");\n        }\n    }","commit_id":"bbc784c68020b847ce8efc7eb99f4c7c54790ada","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        final JMSServerManager jmsManager = jmsServer.getValue();\n        try {\n            jmsManager.createTopic(false, name, jndi);\n        } catch (Exception e) {\n            throw new StartException(MESSAGES.failedToCreate(\"queue\"), e);\n        }\n    }","id":80988,"modified_method":"/** {@inheritDoc} */\n    public synchronized void start(StartContext context) throws StartException {\n        final JMSServerManager jmsManager = jmsServer.getValue();\n        try {\n            jmsManager.createTopic(false, name, jndi);\n        } catch (Exception e) {\n            throw MESSAGES.failedToCreate(e, \"queue\");\n        }\n    }","commit_id":"bbc784c68020b847ce8efc7eb99f4c7c54790ada","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void start(StartContext context) throws StartException {\n        ServiceTarget serviceTarget = context.getChildTarget();\n        try {\n            createService(serviceTarget, context.getController().getServiceContainer());\n        }\n        catch (Exception e) {\n            throw new StartException(MESSAGES.failedToCreate(\"resource adapter\"), e);\n        }\n\n    }","id":80989,"modified_method":"public void start(StartContext context) throws StartException {\n        ServiceTarget serviceTarget = context.getChildTarget();\n        try {\n            createService(serviceTarget, context.getController().getServiceContainer());\n        }\n        catch (Exception e) {\n            throw MESSAGES.failedToCreate(e, \"resource adapter\");\n        }\n\n    }","commit_id":"bbc784c68020b847ce8efc7eb99f4c7c54790ada","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void handleThrowsTag(TagElement tag) {\n\t\tList<? extends ASTNode> fragments = tag.fragments();\n\t\tint size = fragments.size();\n\t\tif (size > 0) {\n\t\t\thandleLink(fragments.subList(0, 1));\n\t\t\tif (size > 1) {\n\t\t\t\tbuffer.append(JavaElementLabels.CONCAT_STRING);\n\t\t\t\thandleContentElements(fragments.subList(1, size));\n\t\t\t}\n\t\t}\n\t}","id":80990,"modified_method":"protected void handleThrowsTag(TagElement tag) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<? extends ASTNode> fragments = tag.fragments();\n\t\tint size = fragments.size();\n\t\tif (size > 0) {\n\t\t\thandleLink(fragments.subList(0, 1));\n\t\t\tif (size > 1) {\n\t\t\t\tbuffer.append(JavaElementLabels.CONCAT_STRING);\n\t\t\t\thandleContentElements(fragments.subList(1, size));\n\t\t\t}\n\t\t}\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void handleReturnTag(TagElement tag) {\n\t\tif (tag == null)\n\t\t\treturn;\n\t\thandleBlockTagTitle(\"Returns:\");\n\t\tbuffer.append(BlOCK_TAG_ENTRY_START);\n\t\thandleContentElements(tag.fragments());\n\t\tbuffer.append(BlOCK_TAG_ENTRY_END);\n\t}","id":80991,"modified_method":"protected void handleReturnTag(TagElement tag) {\n\t\tif (tag == null)\n\t\t\treturn;\n\t\thandleBlockTagTitle(\"Returns:\");\n\t\tbuffer.append(BlOCK_TAG_ENTRY_START);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<ASTNode> fragments = tag.fragments();\n\t\thandleContentElements(fragments);\n\t\tbuffer.append(BlOCK_TAG_ENTRY_END);\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void handleBlockTags(List<TagElement> tags) {\n\t\tfor (Iterator<TagElement> iter = tags.iterator(); iter.hasNext();) {\n\t\t\tTagElement tag = iter.next();\n\t\t\thandleBlockTagTitle(tag.getTagName());\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_START);\n\t\t\thandleContentElements(tag.fragments());\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_END);\n\t\t}\n\t}","id":80992,"modified_method":"protected void handleBlockTags(List<TagElement> tags) {\n\t\tfor (Iterator<TagElement> iter = tags.iterator(); iter.hasNext();) {\n\t\t\tTagElement tag = iter.next();\n\t\t\thandleBlockTagTitle(tag.getTagName());\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_START);\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tList<ASTNode> fragments = tag.fragments();\n\t\t\thandleContentElements(fragments);\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_END);\n\t\t}\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"public Javadoc getJavaDoc() {\n\t\tASTParser parser = ASTParser.newParser(ASTProvider.SHARED_AST_LEVEL);\n\t\tIJavaProject javaProject = (IJavaProject) ((XtextResourceSet) context.eResource().getResourceSet())\n\t\t\t\t.getClasspathURIContext();\n\t\tparser.setProject(javaProject);\n\t\tMap<String, String> options = javaProject.getOptions(true);\n\t\toptions.put(JavaCore.COMPILER_DOC_COMMENT_SUPPORT, JavaCore.ENABLED); // workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=212207\n\t\tparser.setCompilerOptions(options);\n\t\tString source = rawJavaDoc + \"class C{}\"; //$NON-NLS-1$\n\t\tparser.setSource(source.toCharArray());\n\t\tCompilationUnit root = (CompilationUnit) parser.createAST(null);\n\t\tif (root == null)\n\t\t\treturn null;\n\t\tList<AbstractTypeDeclaration> types = root.types();\n\t\tif (types.size() != 1)\n\t\t\treturn null;\n\t\tAbstractTypeDeclaration type = types.get(0);\n\t\treturn type.getJavadoc();\n\t}","id":80993,"modified_method":"public Javadoc getJavaDoc() {\n\t\tASTParser parser = ASTParser.newParser(ASTProvider.SHARED_AST_LEVEL);\n\t\tIJavaProject javaProject = (IJavaProject) ((XtextResourceSet) context.eResource().getResourceSet())\n\t\t\t\t.getClasspathURIContext();\n\t\tparser.setProject(javaProject);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMap<String, String> options = javaProject.getOptions(true);\n\t\toptions.put(JavaCore.COMPILER_DOC_COMMENT_SUPPORT, JavaCore.ENABLED); // workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=212207\n\t\tparser.setCompilerOptions(options);\n\t\tString source = rawJavaDoc + \"class C{}\"; //$NON-NLS-1$\n\t\tparser.setSource(source.toCharArray());\n\t\tCompilationUnit root = (CompilationUnit) parser.createAST(null);\n\t\tif (root == null)\n\t\t\treturn null;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<AbstractTypeDeclaration> types = root.types();\n\t\tif (types.size() != 1)\n\t\t\treturn null;\n\t\tAbstractTypeDeclaration type = types.get(0);\n\t\treturn type.getJavadoc();\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void handleInlineTagElement(TagElement node) {\n\t\tString name = node.getTagName();\n\t\tif (TagElement.TAG_VALUE.equals(name) && handleValueTag(node))\n\t\t\treturn;\n\t\tboolean isLink = TagElement.TAG_LINK.equals(name);\n\t\tboolean isLinkplain = TagElement.TAG_LINKPLAIN.equals(name);\n\t\tboolean isCode = TagElement.TAG_CODE.equals(name);\n\t\tboolean isLiteral = TagElement.TAG_LITERAL.equals(name);\n\t\tif (isLiteral || isCode)\n\t\t\tfLiteralContent++;\n\t\tif (isLink || isCode)\n\t\t\tbuffer.append(\"<code>\"); //$NON-NLS-1$\n\t\tif (isLink || isLinkplain)\n\t\t\thandleLink(node.fragments());\n\t\telse if (isCode || isLiteral)\n\t\t\thandleContentElements(node.fragments(), true);\n\t\telse if (handleInheritDoc(node)) {\n\t\t\t// handled\n\t\t} else if (handleDocRoot(node)) {\n\t\t\t// handled\n\t\t} else {\n\t\t\t//print uninterpreted source {@tagname ...} for unknown tags\n\t\t\tint start = node.getStartPosition();\n\t\t\tString text = rawJavaDoc.substring(start, start + node.getLength());\n\t\t\tbuffer.append(removeDocLineIntros(text));\n\t\t}\n\t\tif (isLink || isCode)\n\t\t\tbuffer.append(\"<\/code>\"); //$NON-NLS-1$\n\t\tif (isLiteral || isCode)\n\t\t\tfLiteralContent--;\n\n\t}","id":80994,"modified_method":"protected void handleInlineTagElement(TagElement node) {\n\t\tString name = node.getTagName();\n\t\tif (TagElement.TAG_VALUE.equals(name) && handleValueTag(node))\n\t\t\treturn;\n\t\tboolean isLink = TagElement.TAG_LINK.equals(name);\n\t\tboolean isLinkplain = TagElement.TAG_LINKPLAIN.equals(name);\n\t\tboolean isCode = TagElement.TAG_CODE.equals(name);\n\t\tboolean isLiteral = TagElement.TAG_LITERAL.equals(name);\n\t\tif (isLiteral || isCode)\n\t\t\tfLiteralContent++;\n\t\tif (isLink || isCode)\n\t\t\tbuffer.append(\"<code>\"); //$NON-NLS-1$\n\t\tif (isLink || isLinkplain)\n\t\t\thandleLink(node.fragments());\n\t\telse if (isCode || isLiteral) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tList<ASTNode> fragments = node.fragments();\n\t\t\thandleContentElements(fragments, true);\n\t\t}\n\t\telse if (handleInheritDoc(node)) {\n\t\t\t// handled\n\t\t} else if (handleDocRoot(node)) {\n\t\t\t// handled\n\t\t} else {\n\t\t\t//print uninterpreted source {@tagname ...} for unknown tags\n\t\t\tint start = node.getStartPosition();\n\t\t\tString text = rawJavaDoc.substring(start, start + node.getLength());\n\t\t\tbuffer.append(removeDocLineIntros(text));\n\t\t}\n\t\tif (isLink || isCode)\n\t\t\tbuffer.append(\"<\/code>\"); //$NON-NLS-1$\n\t\tif (isLiteral || isCode)\n\t\t\tfLiteralContent--;\n\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"public String getDocumentation(EObject object) {\n\t\tbuffer = new StringBuffer();\n\t\tcontext = object;\n\t\taddAnnotations(object);\n\t\tgetDocumentationWithPrefix(object);\n\t\tJavadoc javadoc = getJavaDoc();\n\t\tif (javadoc == null)\n\t\t\treturn \"\";\n\t\tTagElement deprecatedTag = null;\n\t\tTagElement start = null;\n\t\tList<TagElement> parameters = new ArrayList<TagElement>();\n\t\tTagElement returnTag = null;\n\t\tList<TagElement> exceptions = new ArrayList<TagElement>();\n\t\tList<TagElement> versions = new ArrayList<TagElement>();\n\t\tList<TagElement> authors = new ArrayList<TagElement>();\n\t\tList<TagElement> sees = new ArrayList<TagElement>();\n\t\tList<TagElement> since = new ArrayList<TagElement>();\n\t\tList<TagElement> rest = new ArrayList<TagElement>();\n\n\t\tList<TagElement> tags = javadoc.tags();\n\t\tfor (Iterator<TagElement> iter = tags.iterator(); iter.hasNext();) {\n\t\t\tTagElement tag = iter.next();\n\t\t\tString tagName = tag.getTagName();\n\t\t\tif (tagName == null) {\n\t\t\t\tstart = tag;\n\t\t\t} else if (TagElement.TAG_PARAM.equals(tagName)) {\n\t\t\t\tparameters.add(tag);\n\t\t\t} else if (TagElement.TAG_RETURN.equals(tagName)) {\n\t\t\t\tif (returnTag == null)\n\t\t\t\t\treturnTag = tag; // the Javadoc tool only shows the first return tag\n\t\t\t} else if (TagElement.TAG_EXCEPTION.equals(tagName) || TagElement.TAG_THROWS.equals(tagName)) {\n\t\t\t\texceptions.add(tag);\n\t\t\t} else if (TagElement.TAG_SINCE.equals(tagName)) {\n\t\t\t\tsince.add(tag);\n\t\t\t} else if (TagElement.TAG_VERSION.equals(tagName)) {\n\t\t\t\tversions.add(tag);\n\t\t\t} else if (TagElement.TAG_AUTHOR.equals(tagName)) {\n\t\t\t\tauthors.add(tag);\n\t\t\t} else if (TagElement.TAG_SEE.equals(tagName)) {\n\t\t\t\tsees.add(tag);\n\t\t\t} else if (TagElement.TAG_DEPRECATED.equals(tagName)) {\n\t\t\t\tif (deprecatedTag == null)\n\t\t\t\t\tdeprecatedTag = tag; // the Javadoc tool only shows the first deprecated tag\n\t\t\t} else {\n\t\t\t\trest.add(tag);\n\t\t\t}\n\t\t}\n\t\tfLiteralContent = 0;\n\t\tboolean hasParameters = parameters.size() > 0;\n\t\tboolean hasReturnTag = returnTag != null;\n\t\tboolean hasExceptions = exceptions.size() > 0;\n\t\tif (deprecatedTag != null)\n\t\t\thandleDeprecatedTag(deprecatedTag);\n\t\tif (start != null)\n\t\t\thandleContentElements(start.fragments());\n\n\t\tif (hasParameters || hasReturnTag || hasExceptions || versions.size() > 0 || authors.size() > 0\n\t\t\t\t|| since.size() > 0 || sees.size() > 0 || rest.size() > 0 || (buffer.length() > 0)) {\n\t\t\thandleSuperMethodReferences(object);\n\t\t\tbuffer.append(BLOCK_TAG_START);\n\t\t\thandleParameters(object, parameters);\n\t\t\thandleReturnTag(returnTag);\n\t\t\thandleExceptionTags(exceptions);\n\t\t\thandleBlockTags(\"Since:\", since);\n\t\t\thandleBlockTags(\"Version:\", versions);\n\t\t\thandleBlockTags(\"Author:\", authors);\n\t\t\thandleBlockTags(\"See Also:\", sees);\n\t\t\thandleBlockTags(rest);\n\t\t\tbuffer.append(BLOCK_TAG_END);\n\t\t} else if (buffer.length() > 0) {\n\t\t\thandleSuperMethodReferences(object);\n\t\t}\n\t\tString result = buffer.toString();\n\t\tbuffer = null;\n\t\trawJavaDoc = null;\n\t\tcontext = null;\n\t\treturn result;\n\t}","id":80995,"modified_method":"public String getDocumentation(EObject object) {\n\t\tbuffer = new StringBuffer();\n\t\tcontext = object;\n\t\taddAnnotations(object);\n\t\tgetDocumentationWithPrefix(object);\n\t\tJavadoc javadoc = getJavaDoc();\n\t\tif (javadoc == null)\n\t\t\treturn \"\";\n\t\tTagElement deprecatedTag = null;\n\t\tTagElement start = null;\n\t\tList<TagElement> parameters = new ArrayList<TagElement>();\n\t\tTagElement returnTag = null;\n\t\tList<TagElement> exceptions = new ArrayList<TagElement>();\n\t\tList<TagElement> versions = new ArrayList<TagElement>();\n\t\tList<TagElement> authors = new ArrayList<TagElement>();\n\t\tList<TagElement> sees = new ArrayList<TagElement>();\n\t\tList<TagElement> since = new ArrayList<TagElement>();\n\t\tList<TagElement> rest = new ArrayList<TagElement>();\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<TagElement> tags = javadoc.tags();\n\t\tfor (Iterator<TagElement> iter = tags.iterator(); iter.hasNext();) {\n\t\t\tTagElement tag = iter.next();\n\t\t\tString tagName = tag.getTagName();\n\t\t\tif (tagName == null) {\n\t\t\t\tstart = tag;\n\t\t\t} else if (TagElement.TAG_PARAM.equals(tagName)) {\n\t\t\t\tparameters.add(tag);\n\t\t\t} else if (TagElement.TAG_RETURN.equals(tagName)) {\n\t\t\t\tif (returnTag == null)\n\t\t\t\t\treturnTag = tag; // the Javadoc tool only shows the first return tag\n\t\t\t} else if (TagElement.TAG_EXCEPTION.equals(tagName) || TagElement.TAG_THROWS.equals(tagName)) {\n\t\t\t\texceptions.add(tag);\n\t\t\t} else if (TagElement.TAG_SINCE.equals(tagName)) {\n\t\t\t\tsince.add(tag);\n\t\t\t} else if (TagElement.TAG_VERSION.equals(tagName)) {\n\t\t\t\tversions.add(tag);\n\t\t\t} else if (TagElement.TAG_AUTHOR.equals(tagName)) {\n\t\t\t\tauthors.add(tag);\n\t\t\t} else if (TagElement.TAG_SEE.equals(tagName)) {\n\t\t\t\tsees.add(tag);\n\t\t\t} else if (TagElement.TAG_DEPRECATED.equals(tagName)) {\n\t\t\t\tif (deprecatedTag == null)\n\t\t\t\t\tdeprecatedTag = tag; // the Javadoc tool only shows the first deprecated tag\n\t\t\t} else {\n\t\t\t\trest.add(tag);\n\t\t\t}\n\t\t}\n\t\tfLiteralContent = 0;\n\t\tboolean hasParameters = parameters.size() > 0;\n\t\tboolean hasReturnTag = returnTag != null;\n\t\tboolean hasExceptions = exceptions.size() > 0;\n\t\tif (deprecatedTag != null)\n\t\t\thandleDeprecatedTag(deprecatedTag);\n\t\tif (start != null) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tList<ASTNode> fragments = start.fragments();\n\t\t\thandleContentElements(fragments);\n\t\t}\n\n\t\tif (hasParameters || hasReturnTag || hasExceptions || versions.size() > 0 || authors.size() > 0\n\t\t\t\t|| since.size() > 0 || sees.size() > 0 || rest.size() > 0 || (buffer.length() > 0)) {\n\t\t\thandleSuperMethodReferences(object);\n\t\t\tbuffer.append(BLOCK_TAG_START);\n\t\t\thandleParameters(object, parameters);\n\t\t\thandleReturnTag(returnTag);\n\t\t\thandleExceptionTags(exceptions);\n\t\t\thandleBlockTags(\"Since:\", since);\n\t\t\thandleBlockTags(\"Version:\", versions);\n\t\t\thandleBlockTags(\"Author:\", authors);\n\t\t\thandleBlockTags(\"See Also:\", sees);\n\t\t\thandleBlockTags(rest);\n\t\t\tbuffer.append(BLOCK_TAG_END);\n\t\t} else if (buffer.length() > 0) {\n\t\t\thandleSuperMethodReferences(object);\n\t\t}\n\t\tString result = buffer.toString();\n\t\tbuffer = null;\n\t\trawJavaDoc = null;\n\t\tcontext = null;\n\t\treturn result;\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void addAnnotations(EObject object) {\n\t\tSet<EObject> jvmElements = associations.getJvmElements(object);\n\t\tif (jvmElements.size() > 0) {\n\t\t\tEObject associatedElement = Lists.newArrayList(jvmElements).get(0);\n\t\t\tif (associatedElement instanceof JvmAnnotationTarget) {\n\t\t\t\tEList<JvmAnnotationReference> annotations = ((JvmAnnotationTarget) associatedElement).getAnnotations();\n\t\t\t\tHoverReference reference = new HoverReference(TypesPackage.Literals.JVM_TYPE);\n\t\t\t\tIScope scope = scopeProvider.getScope(context, reference);\n\t\t\t\tfor (JvmAnnotationReference annotationReference : annotations) {\n\t\t\t\t\tbuffer.append(\"@\");\n\t\t\t\t\tbuffer.append(createLinkWithLabel(EcoreUtil.getURI(annotationReference.getAnnotation()),\n\t\t\t\t\t\t\tannotationReference.getAnnotation().getSimpleName()));\n\t\t\t\t\tif (annotationReference.getValues().size() > 0) {\n\t\t\t\t\t\tbuffer.append(\"(\");\n\t\t\t\t\t\tfor (JvmAnnotationValue value : annotationReference.getValues()) {\n\t\t\t\t\t\t\tCharSequence java = jvmModelGenerator.toJava(value, null);\n\t\t\t\t\t\t\tbuffer.append(java);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t\tbuffer.append(\"<br>\");\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}","id":80996,"modified_method":"protected void addAnnotations(EObject object) {\n\t\tSet<EObject> jvmElements = associations.getJvmElements(object);\n\t\tif (jvmElements.size() > 0) {\n\t\t\tEObject associatedElement = Lists.newArrayList(jvmElements).get(0);\n\t\t\tif (associatedElement instanceof JvmAnnotationTarget) {\n\t\t\t\tEList<JvmAnnotationReference> annotations = ((JvmAnnotationTarget) associatedElement).getAnnotations();\n\t\t\t\tfor (JvmAnnotationReference annotationReference : annotations) {\n\t\t\t\t\tbuffer.append(\"@\");\n\t\t\t\t\tbuffer.append(createLinkWithLabel(EcoreUtil.getURI(annotationReference.getAnnotation()),\n\t\t\t\t\t\t\tannotationReference.getAnnotation().getSimpleName()));\n\t\t\t\t\tif (annotationReference.getValues().size() > 0) {\n\t\t\t\t\t\tbuffer.append(\"(\");\n\t\t\t\t\t\tfor (JvmAnnotationValue value : annotationReference.getValues()) {\n\t\t\t\t\t\t\tStringBuilderBasedAppendable appendable = new StringBuilderBasedAppendable();\n\t\t\t\t\t\t\tTracingAppendable tracing = new TracingAppendable(appendable, locationProvider);\n\t\t\t\t\t\t\tjvmModelGenerator.toJava(value, tracing);\n\t\t\t\t\t\t\tString java = tracing.toString();\n\t\t\t\t\t\t\tbuffer.append(java);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t\tbuffer.append(\"<br>\");\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void handleDeprecatedTag(TagElement tag) {\n\t\tbuffer.append(\"<p><b>\"); //$NON-NLS-1$\n\t\t//TODO: Messages out of properties like in JDT?\n\t\tbuffer.append(\"Deprecarted.\");\n\t\tbuffer.append(\"<\/b> <i>\"); //$NON-NLS-1$\n\t\thandleContentElements(tag.fragments());\n\t\tbuffer.append(\"<\/i><\/p>\"); //$NON-NLS-1$\n\t}","id":80997,"modified_method":"protected void handleDeprecatedTag(TagElement tag) {\n\t\tbuffer.append(\"<p><b>\"); //$NON-NLS-1$\n\t\t//TODO: Messages out of properties like in JDT?\n\t\tbuffer.append(\"Deprecated.\");\n\t\tbuffer.append(\"<\/b> <i>\"); //$NON-NLS-1$\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<ASTNode> fragments = tag.fragments();\n\t\thandleContentElements(fragments);\n\t\tbuffer.append(\"<\/i><\/p>\"); //$NON-NLS-1$\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void handleParamTag(TagElement tag) {\n\t\tList<? extends ASTNode> fragments = tag.fragments();\n\t\tint i = 0;\n\t\tint size = fragments.size();\n\t\tif (size > 0) {\n\t\t\tObject first = fragments.get(0);\n\t\t\tbuffer.append(PARAM_NAME_START);\n\t\t\tif (first instanceof SimpleName) {\n\t\t\t\tString name = ((SimpleName) first).getIdentifier();\n\t\t\t\tbuffer.append(name);\n\t\t\t\ti++;\n\t\t\t} else if (first instanceof TextElement) {\n\t\t\t\tString firstText = ((TextElement) first).getText();\n\t\t\t\tif (\"<\".equals(firstText)) { //$NON-NLS-1$\n\t\t\t\t\tbuffer.append(\"&lt;\"); //$NON-NLS-1$\n\t\t\t\t\ti++;\n\t\t\t\t\tif (size > 1) {\n\t\t\t\t\t\tObject second = fragments.get(1);\n\t\t\t\t\t\tif (second instanceof SimpleName) {\n\t\t\t\t\t\t\tString name = ((SimpleName) second).getIdentifier();\n\t\t\t\t\t\t\tbuffer.append(name);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif (size > 2) {\n\t\t\t\t\t\t\t\tObject third = fragments.get(2);\n\t\t\t\t\t\t\t\tString thirdText = ((TextElement) third).getText();\n\t\t\t\t\t\t\t\tif (\">\".equals(thirdText)) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\tbuffer.append(\"&gt;\"); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer.append(PARAM_NAME_END);\n\t\t\thandleContentElements(fragments.subList(i, fragments.size()));\n\t\t}\n\t}","id":80998,"modified_method":"protected void handleParamTag(TagElement tag) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<? extends ASTNode> fragments = tag.fragments();\n\t\tint i = 0;\n\t\tint size = fragments.size();\n\t\tif (size > 0) {\n\t\t\tObject first = fragments.get(0);\n\t\t\tbuffer.append(PARAM_NAME_START);\n\t\t\tif (first instanceof SimpleName) {\n\t\t\t\tString name = ((SimpleName) first).getIdentifier();\n\t\t\t\tbuffer.append(name);\n\t\t\t\ti++;\n\t\t\t} else if (first instanceof TextElement) {\n\t\t\t\tString firstText = ((TextElement) first).getText();\n\t\t\t\tif (\"<\".equals(firstText)) { //$NON-NLS-1$\n\t\t\t\t\tbuffer.append(\"&lt;\"); //$NON-NLS-1$\n\t\t\t\t\ti++;\n\t\t\t\t\tif (size > 1) {\n\t\t\t\t\t\tObject second = fragments.get(1);\n\t\t\t\t\t\tif (second instanceof SimpleName) {\n\t\t\t\t\t\t\tString name = ((SimpleName) second).getIdentifier();\n\t\t\t\t\t\t\tbuffer.append(name);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif (size > 2) {\n\t\t\t\t\t\t\t\tObject third = fragments.get(2);\n\t\t\t\t\t\t\t\tString thirdText = ((TextElement) third).getText();\n\t\t\t\t\t\t\t\tif (\">\".equals(thirdText)) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\tbuffer.append(\"&gt;\"); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer.append(PARAM_NAME_END);\n\t\t\thandleContentElements(fragments.subList(i, fragments.size()));\n\t\t}\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void handleBlockTags(String title, List<TagElement> tags) {\n\t\tif (tags.isEmpty())\n\t\t\treturn;\n\t\thandleBlockTagTitle(title);\n\t\tfor (Iterator<TagElement> iter = tags.iterator(); iter.hasNext();) {\n\t\t\tTagElement tag = iter.next();\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_START);\n\t\t\tif (TagElement.TAG_SEE.equals(tag.getTagName())) {\n\t\t\t\thandleSeeTag(tag);\n\t\t\t} else {\n\t\t\t\thandleContentElements(tag.fragments());\n\t\t\t}\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_END);\n\t\t}\n\t}","id":80999,"modified_method":"protected void handleBlockTags(String title, List<TagElement> tags) {\n\t\tif (tags.isEmpty())\n\t\t\treturn;\n\t\thandleBlockTagTitle(title);\n\t\tfor (Iterator<TagElement> iter = tags.iterator(); iter.hasNext();) {\n\t\t\tTagElement tag = iter.next();\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_START);\n\t\t\tif (TagElement.TAG_SEE.equals(tag.getTagName())) {\n\t\t\t\thandleSeeTag(tag);\n\t\t\t} else {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tList<ASTNode> fragments = tag.fragments();\n\t\t\t\thandleContentElements(fragments);\n\t\t\t}\n\t\t\tbuffer.append(BlOCK_TAG_ENTRY_END);\n\t\t}\n\t}","commit_id":"9d46e29b283e4707c146575145335430e0fc24f3","url":"https://github.com/eclipse/xtext"}]