[{"original_method":"public Result generateRequestHeaders(int request, HttpFields fields, Callback callback)\n    {\n        request &= 0xFF_FF;\n\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        List<byte[]> bytes = new ArrayList<>(fields.size() * 2);\n        int fieldsLength = 0;\n        for (HttpField field : fields)\n        {\n            String name = field.getName();\n            byte[] nameBytes = name.getBytes(utf8);\n            if (nameBytes.length > MAX_PARAM_LENGTH)\n                throw new IllegalArgumentException(\"Field name \" + name + \" exceeds max length \" + MAX_PARAM_LENGTH);\n            bytes.add(nameBytes);\n\n            String value = field.getValue();\n            byte[] valueBytes = value.getBytes(utf8);\n            if (valueBytes.length > MAX_PARAM_LENGTH)\n                throw new IllegalArgumentException(\"Field value \" + value + \" exceeds max length \" + MAX_PARAM_LENGTH);\n            bytes.add(valueBytes);\n\n            int nameLength = nameBytes.length;\n            fieldsLength += bytesForLength(nameLength);\n\n            int valueLength = valueBytes.length;\n            fieldsLength += bytesForLength(valueLength);\n\n            fieldsLength += nameLength;\n            fieldsLength += valueLength;\n        }\n\n        // Worst case FCGI_PARAMS frame: long name + long value - both of MAX_PARAM_LENGTH\n        int maxCapacity = 4 + 4 + 2 * MAX_PARAM_LENGTH;\n\n        // One FCGI_BEGIN_REQUEST + N FCGI_PARAMS + one last FCGI_PARAMS\n        Result result = new Result(byteBufferPool, callback);\n\n        ByteBuffer beginRequestBuffer = byteBufferPool.acquire(16, false);\n        BufferUtil.clearToFill(beginRequestBuffer);\n        result.add(beginRequestBuffer, true);\n\n        // Generate the FCGI_BEGIN_REQUEST frame\n        beginRequestBuffer.putInt(0x01_01_00_00 + request);\n        beginRequestBuffer.putInt(0x00_08_00_00);\n        beginRequestBuffer.putLong(0x00_01_01_00_00_00_00_00L);\n        beginRequestBuffer.flip();\n\n        int index = 0;\n        while (fieldsLength > 0)\n        {\n            int capacity = 8 + Math.min(maxCapacity, fieldsLength);\n            ByteBuffer buffer = byteBufferPool.acquire(capacity, true);\n            BufferUtil.clearToFill(buffer);\n            result.add(buffer, true);\n\n            // Generate the FCGI_PARAMS frame\n            buffer.putInt(0x01_04_00_00 + request);\n            buffer.putShort((short)0);\n            buffer.putShort((short)0);\n            capacity -= 8;\n\n            int length = 0;\n            while (index < bytes.size())\n            {\n                byte[] nameBytes = bytes.get(index);\n                int nameLength = nameBytes.length;\n                byte[] valueBytes = bytes.get(index + 1);\n                int valueLength = valueBytes.length;\n\n                int required = bytesForLength(nameLength) + bytesForLength(valueLength) + nameLength + valueLength;\n                if (required > capacity)\n                    break;\n\n                putParamLength(buffer, nameLength);\n                putParamLength(buffer, valueLength);\n                buffer.put(nameBytes);\n                buffer.put(valueBytes);\n\n                length += required;\n                fieldsLength -= required;\n                capacity -= required;\n                index += 2;\n            }\n\n            buffer.putShort(4, (short)length);\n            buffer.flip();\n        }\n\n\n        ByteBuffer lastParamsBuffer = byteBufferPool.acquire(8, false);\n        BufferUtil.clearToFill(lastParamsBuffer);\n        result.add(lastParamsBuffer, true);\n\n        // Generate the last FCGI_PARAMS frame\n        lastParamsBuffer.putInt(0x01_04_00_00 + request);\n        lastParamsBuffer.putInt(0x00_00_00_00);\n        lastParamsBuffer.flip();\n\n        return result;\n    }","id":81000,"modified_method":"public Result generateRequestHeaders(int request, HttpFields fields, Callback callback)\n    {\n        request &= 0xFF_FF;\n\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        List<byte[]> bytes = new ArrayList<>(fields.size() * 2);\n        int fieldsLength = 0;\n        for (HttpField field : fields)\n        {\n            String name = field.getName();\n            byte[] nameBytes = name.getBytes(utf8);\n            if (nameBytes.length > MAX_PARAM_LENGTH)\n                throw new IllegalArgumentException(\"Field name \" + name + \" exceeds max length \" + MAX_PARAM_LENGTH);\n            bytes.add(nameBytes);\n\n            String value = field.getValue();\n            byte[] valueBytes = value.getBytes(utf8);\n            if (valueBytes.length > MAX_PARAM_LENGTH)\n                throw new IllegalArgumentException(\"Field value \" + value + \" exceeds max length \" + MAX_PARAM_LENGTH);\n            bytes.add(valueBytes);\n\n            int nameLength = nameBytes.length;\n            fieldsLength += bytesForLength(nameLength);\n\n            int valueLength = valueBytes.length;\n            fieldsLength += bytesForLength(valueLength);\n\n            fieldsLength += nameLength;\n            fieldsLength += valueLength;\n        }\n\n        // Worst case FCGI_PARAMS frame: long name + long value - both of MAX_PARAM_LENGTH\n        int maxCapacity = 4 + 4 + 2 * MAX_PARAM_LENGTH;\n\n        // One FCGI_BEGIN_REQUEST + N FCGI_PARAMS + one last FCGI_PARAMS\n\n        ByteBuffer beginRequestBuffer = byteBufferPool.acquire(16, false);\n        BufferUtil.clearToFill(beginRequestBuffer);\n        Result result = new Result(byteBufferPool, callback, beginRequestBuffer, true);\n\n        // Generate the FCGI_BEGIN_REQUEST frame\n        beginRequestBuffer.putInt(0x01_01_00_00 + request);\n        beginRequestBuffer.putInt(0x00_08_00_00);\n        beginRequestBuffer.putLong(0x00_01_01_00_00_00_00_00L);\n        beginRequestBuffer.flip();\n\n        int index = 0;\n        while (fieldsLength > 0)\n        {\n            int capacity = 8 + Math.min(maxCapacity, fieldsLength);\n            ByteBuffer buffer = byteBufferPool.acquire(capacity, true);\n            BufferUtil.clearToFill(buffer);\n            result = result.append(buffer, true);\n\n            // Generate the FCGI_PARAMS frame\n            buffer.putInt(0x01_04_00_00 + request);\n            buffer.putShort((short)0);\n            buffer.putShort((short)0);\n            capacity -= 8;\n\n            int length = 0;\n            while (index < bytes.size())\n            {\n                byte[] nameBytes = bytes.get(index);\n                int nameLength = nameBytes.length;\n                byte[] valueBytes = bytes.get(index + 1);\n                int valueLength = valueBytes.length;\n\n                int required = bytesForLength(nameLength) + bytesForLength(valueLength) + nameLength + valueLength;\n                if (required > capacity)\n                    break;\n\n                putParamLength(buffer, nameLength);\n                putParamLength(buffer, valueLength);\n                buffer.put(nameBytes);\n                buffer.put(valueBytes);\n\n                length += required;\n                fieldsLength -= required;\n                capacity -= required;\n                index += 2;\n            }\n\n            buffer.putShort(4, (short)length);\n            buffer.flip();\n        }\n\n\n        ByteBuffer lastParamsBuffer = byteBufferPool.acquire(8, false);\n        BufferUtil.clearToFill(lastParamsBuffer);\n        result = result.append(lastParamsBuffer, true);\n\n        // Generate the last FCGI_PARAMS frame\n        lastParamsBuffer.putInt(0x01_04_00_00 + request);\n        lastParamsBuffer.putInt(0x00_00_00_00);\n        lastParamsBuffer.flip();\n\n        return result;\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Result generateRequestContent(int request, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        return generateContent(request, content, lastContent, callback, FCGI.FrameType.STDIN);\n    }","id":81001,"modified_method":"public Result generateRequestContent(int request, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        return generateContent(request, content, false, lastContent, callback, FCGI.FrameType.STDIN);\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private ShutdownResult()\n        {\n            super(null, new Adapter());\n        }","id":81002,"modified_method":"private ShutdownResult()\n        {\n            super(null, null, null, false);\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        protected boolean process() throws Exception\n        {\n            // Look if other writes are needed.\n            Generator.Result result;\n            synchronized (queue)\n            {\n                if (queue.isEmpty())\n                {\n                    // No more writes to do, switch to non-flushing\n                    flushing = false;\n                    return false;\n                }\n                // TODO: here is where we want to gather more results to perform gathered writes\n                result = queue.poll();\n            }\n            active = result;\n            List<ByteBuffer> buffers = result.getByteBuffers();\n            endPoint.write(this, buffers.toArray(new ByteBuffer[buffers.size()]));\n            return false;\n        }","id":81003,"modified_method":"@Override\n        protected boolean process() throws Exception\n        {\n            // Look if other writes are needed.\n            Generator.Result result;\n            synchronized (queue)\n            {\n                if (queue.isEmpty())\n                {\n                    // No more writes to do, switch to non-flushing\n                    flushing = false;\n                    return false;\n                }\n                // TODO: here is where we want to gather more results to perform gathered writes\n                result = queue.poll();\n            }\n            active = result;\n            ByteBuffer[] buffers = result.getByteBuffers();\n            endPoint.write(this, buffers);\n            return false;\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void recycle()\n        {\n            for (int i = 0; i < buffers.size(); ++i)\n            {\n                ByteBuffer buffer = buffers.get(i);\n                if (recycles.get(i))\n                    byteBufferPool.release(buffer);\n            }\n        }","id":81004,"modified_method":"protected void recycle()\n        {\n            if (recycle)\n                byteBufferPool.release(buffer);\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public List<ByteBuffer> getByteBuffers()\n        {\n            return buffers;\n        }","id":81005,"modified_method":"public ByteBuffer[] getByteBuffers()\n        {\n            return getByteBuffers(0);\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Result(ByteBufferPool byteBufferPool, Callback callback)\n        {\n            this(byteBufferPool, callback, new ArrayList<ByteBuffer>(4), new ArrayList<Boolean>(4));\n        }","id":81006,"modified_method":"public Result(ByteBufferPool byteBufferPool, Callback callback, ByteBuffer buffer, boolean recycle)\n        {\n            this(byteBufferPool, callback, buffer, recycle, null);\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            recycle();\n            callback.succeeded();\n        }","id":81007,"modified_method":"@Override\n        public void succeeded()\n        {\n            recycle();\n            if (previous != null)\n                previous.succeeded();\n            if (callback != null)\n                callback.succeeded();\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void failed(Throwable x)\n        {\n            recycle();\n            callback.failed(x);\n        }","id":81008,"modified_method":"@Override\n        public void failed(Throwable x)\n        {\n            recycle();\n            if (previous != null)\n                previous.failed(x);\n            if (callback != null)\n                callback.failed(x);\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void add(ByteBuffer buffer, boolean recycle)\n        {\n            buffers.add(buffer);\n            recycles.add(recycle);\n        }","id":81009,"modified_method":"public Result append(ByteBuffer buffer, boolean recycle)\n        {\n            return new Result(byteBufferPool, null, buffer, recycle, this);\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected Result generateContent(int id, ByteBuffer content, boolean lastContent, Callback callback, FCGI.FrameType frameType)\n    {\n        id &= 0xFF_FF;\n\n        int remaining = content == null ? 0 : content.remaining();\n        Result result = new Result(byteBufferPool, callback);\n\n        while (remaining > 0 || lastContent)\n        {\n            ByteBuffer buffer = byteBufferPool.acquire(8, false);\n            BufferUtil.clearToFill(buffer);\n            result.add(buffer, true);\n\n            // Generate the frame header\n            buffer.put((byte)0x01);\n            buffer.put((byte)frameType.code);\n            buffer.putShort((short)id);\n            int length = Math.min(MAX_CONTENT_LENGTH, remaining);\n            buffer.putShort((short)length);\n            buffer.putShort((short)0);\n            buffer.flip();\n\n            if (remaining == 0)\n                break;\n\n            // Slice to content to avoid copying\n            int limit = content.limit();\n            content.limit(content.position() + length);\n            ByteBuffer slice = content.slice();\n            result.add(slice, false);\n            content.position(content.limit());\n            content.limit(limit);\n            remaining -= length;\n        }\n\n        return result;\n    }","id":81010,"modified_method":"protected Result generateContent(int id, ByteBuffer content, boolean recycle, boolean lastContent, Callback callback, FCGI.FrameType frameType)\n    {\n        id &= 0xFF_FF;\n\n        int remaining = content == null ? 0 : content.remaining();\n        Result result = new Result(byteBufferPool, callback, null, false);\n\n        while (remaining > 0 || lastContent)\n        {\n            ByteBuffer buffer = byteBufferPool.acquire(8, false);\n            BufferUtil.clearToFill(buffer);\n            result = result.append(buffer, true);\n\n            // Generate the frame header\n            buffer.put((byte)0x01);\n            buffer.put((byte)frameType.code);\n            buffer.putShort((short)id);\n            int length = Math.min(MAX_CONTENT_LENGTH, remaining);\n            buffer.putShort((short)length);\n            buffer.putShort((short)0);\n            buffer.flip();\n\n            if (remaining == 0)\n                break;\n\n            // Slice to content to avoid copying\n            int limit = content.limit();\n            content.limit(content.position() + length);\n            ByteBuffer slice = content.slice();\n            result = result.append(slice, recycle);\n            content.position(content.limit());\n            content.limit(limit);\n            remaining -= length;\n        }\n\n        return result;\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private Result(ByteBufferPool byteBufferPool, Callback callback, List<ByteBuffer> buffers, List<Boolean> recycles)\n        {\n            this.byteBufferPool = byteBufferPool;\n            this.callback = callback;\n            this.buffers = buffers;\n            this.recycles = recycles;\n        }","id":81011,"modified_method":"private Result(ByteBufferPool byteBufferPool, Callback callback, ByteBuffer buffer, boolean recycle, Result previous)\n        {\n            this.byteBufferPool = byteBufferPool;\n            this.callback = callback;\n            this.buffer = buffer;\n            this.recycle = recycle;\n            this.previous = previous;\n        }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void header(HttpField field)\n    {\n        if (FCGI.Headers.REQUEST_METHOD.equalsIgnoreCase(field.getName()))\n            method = field.getValue();\n        else if (FCGI.Headers.REQUEST_URI.equalsIgnoreCase(field.getName()))\n            path = field.getValue();\n        else if (FCGI.Headers.QUERY_STRING.equalsIgnoreCase(field.getName()))\n            query = field.getValue();\n        else if (FCGI.Headers.SERVER_PROTOCOL.equalsIgnoreCase(field.getName()))\n            version = field.getValue();\n        else\n            fields.add(field);\n    }","id":81012,"modified_method":"protected void header(HttpField field)\n    {\n        if (FCGI.Headers.REQUEST_METHOD.equalsIgnoreCase(field.getName()))\n            method = field.getValue();\n        else if (FCGI.Headers.DOCUMENT_URI.equalsIgnoreCase(field.getName()))\n            path = field.getValue();\n        else if (FCGI.Headers.QUERY_STRING.equalsIgnoreCase(field.getName()))\n            query = field.getValue();\n        else if (FCGI.Headers.SERVER_PROTOCOL.equalsIgnoreCase(field.getName()))\n            version = field.getValue();\n        else\n            fields.add(field);\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public HttpClientTransportOverFCGI(String scriptRoot)\n    {\n        this(Runtime.getRuntime().availableProcessors() / 2 + 1, false, scriptRoot);\n    }","id":81013,"modified_method":"public HttpClientTransportOverFCGI(String scriptRoot)\n    {\n        this(Math.max(1, Runtime.getRuntime().availableProcessors() / 2), false, scriptRoot);\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Result generateResponseHeaders(int request, int code, String reason, HttpFields fields, Callback callback)\n    {\n        request &= 0xFF_FF;\n\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        List<byte[]> bytes = new ArrayList<>(fields.size() * 2);\n        int length = 0;\n\n        // Special 'Status' header\n        bytes.add(STATUS);\n        length += STATUS.length + COLON.length;\n        if (reason == null)\n            reason = HttpStatus.getMessage(code);\n        byte[] responseBytes = (code + \" \" + reason).getBytes(utf8);\n        bytes.add(responseBytes);\n        length += responseBytes.length + EOL.length;\n\n        // Other headers\n        for (HttpField field : fields)\n        {\n            String name = field.getName();\n            byte[] nameBytes = name.getBytes(utf8);\n            bytes.add(nameBytes);\n\n            String value = field.getValue();\n            byte[] valueBytes = value.getBytes(utf8);\n            bytes.add(valueBytes);\n\n            length += nameBytes.length + COLON.length;\n            length += valueBytes.length + EOL.length;\n        }\n        // End of headers\n        length += EOL.length;\n\n        final ByteBuffer buffer = byteBufferPool.acquire(length, true);\n        BufferUtil.clearToFill(buffer);\n\n        for (int i = 0; i < bytes.size(); i += 2)\n            buffer.put(bytes.get(i)).put(COLON).put(bytes.get(i + 1)).put(EOL);\n        buffer.put(EOL);\n\n        buffer.flip();\n\n        return new Result(generateContent(request, buffer, false, callback, FCGI.FrameType.STDOUT))\n        {\n            @Override\n            protected void recycle()\n            {\n                super.recycle();\n                byteBufferPool.release(buffer);\n            }\n        };\n    }","id":81014,"modified_method":"public Result generateResponseHeaders(int request, int code, String reason, HttpFields fields, Callback callback)\n    {\n        request &= 0xFF_FF;\n\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        List<byte[]> bytes = new ArrayList<>(fields.size() * 2);\n        int length = 0;\n\n        // Special 'Status' header\n        bytes.add(STATUS);\n        length += STATUS.length + COLON.length;\n        if (reason == null)\n            reason = HttpStatus.getMessage(code);\n        byte[] responseBytes = (code + \" \" + reason).getBytes(utf8);\n        bytes.add(responseBytes);\n        length += responseBytes.length + EOL.length;\n\n        // Other headers\n        for (HttpField field : fields)\n        {\n            String name = field.getName();\n            byte[] nameBytes = name.getBytes(utf8);\n            bytes.add(nameBytes);\n\n            String value = field.getValue();\n            byte[] valueBytes = value.getBytes(utf8);\n            bytes.add(valueBytes);\n\n            length += nameBytes.length + COLON.length;\n            length += valueBytes.length + EOL.length;\n        }\n        // End of headers\n        length += EOL.length;\n\n        final ByteBuffer buffer = byteBufferPool.acquire(length, true);\n        BufferUtil.clearToFill(buffer);\n\n        for (int i = 0; i < bytes.size(); i += 2)\n            buffer.put(bytes.get(i)).put(COLON).put(bytes.get(i + 1)).put(EOL);\n        buffer.put(EOL);\n\n        buffer.flip();\n\n        return generateContent(request, buffer, true, false, callback, FCGI.FrameType.STDOUT);\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Result generateResponseContent(int request, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        Result result = generateContent(request, content, lastContent, callback, FCGI.FrameType.STDOUT);\n        if (lastContent)\n        {\n            // Generate the FCGI_END_REQUEST\n            request &= 0xFF_FF;\n            ByteBuffer endRequestBuffer = byteBufferPool.acquire(8, false);\n            BufferUtil.clearToFill(endRequestBuffer);\n            endRequestBuffer.putInt(0x01_03_00_00 + request);\n            endRequestBuffer.putInt(0x00_08_00_00);\n            endRequestBuffer.putLong(0x00L);\n            endRequestBuffer.flip();\n            result.add(endRequestBuffer, true);\n        }\n        return result;\n    }","id":81015,"modified_method":"public Result generateResponseContent(int request, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        Result result = generateContent(request, content, false, lastContent, callback, FCGI.FrameType.STDOUT);\n        if (lastContent)\n        {\n            // Generate the FCGI_END_REQUEST\n            request &= 0xFF_FF;\n            ByteBuffer endRequestBuffer = byteBufferPool.acquire(8, false);\n            BufferUtil.clearToFill(endRequestBuffer);\n            endRequestBuffer.putInt(0x01_03_00_00 + request);\n            endRequestBuffer.putInt(0x00_08_00_00);\n            endRequestBuffer.putLong(0x00L);\n            endRequestBuffer.flip();\n            result = result.append(endRequestBuffer, true);\n        }\n        return result;\n    }","commit_id":"98de7500f93aa585b4ae381461c02e8e1d5a587e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Call to signal a failure to a registered interest\n     */\n    public void onFail(Throwable cause)\n    {\n        if (_interested.compareAndSet(true,false))\n        {\n            Callback callback=_callback;\n            _callback=null;\n            callback.failed(cause);\n        }\n    }","id":81016,"modified_method":"/** Call to signal a failure to a registered interest\n     */\n    public void onFail(Throwable cause)\n    {\n        Callback callback=_interested.get();\n        if (callback!=null && _interested.compareAndSet(callback,null))\n            callback.failed(cause);\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @return True if a read callback has been registered\n     */\n    public boolean isInterested()\n    {\n        return _interested.get();\n    }","id":81017,"modified_method":"/**\n     * @return True if a read callback has been registered\n     */\n    public boolean isInterested()\n    {\n        return _interested.get()!=null;\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Call to register interest in a callback when a read is possible.\n     * The callback will be called either immediately if {@link #needsFill()} \n     * returns true or eventually once {@link #fillable()} is called.\n     * @param context\n     * @param callback\n     * @throws ReadPendingException\n     */\n    public <C> void register(Callback callback) throws ReadPendingException\n    {\n        if (!_interested.compareAndSet(false,true))\n            throw new ReadPendingException();\n        _callback=callback;\n        try\n        {\n            if (needsFill())\n                fillable();\n        }\n        catch(IOException e)\n        {\n            onFail(e);\n        }\n    }","id":81018,"modified_method":"/** Call to register interest in a callback when a read is possible.\n     * The callback will be called either immediately if {@link #needsFill()} \n     * returns true or eventually once {@link #fillable()} is called.\n     * @param context\n     * @param callback\n     * @throws ReadPendingException\n     */\n    public <C> void register(Callback callback) throws ReadPendingException\n    {\n        if (callback==null)\n            throw new IllegalArgumentException();\n        \n        if (!_interested.compareAndSet(null,callback))\n            throw new ReadPendingException();\n        try\n        {\n            if (needsFill())\n                fillable();\n        }\n        catch(IOException e)\n        {\n            onFail(e);\n        }\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Call to signal that a read is now possible.\n     */\n    public void fillable()\n    {\n        if (_interested.compareAndSet(true,false))\n        {\n            Callback callback=_callback;\n            _callback=null;\n            callback.succeeded();\n        }\n    }","id":81019,"modified_method":"/** Call to signal that a read is now possible.\n     */\n    public void fillable()\n    {\n        Callback callback=_interested.get();\n        if (callback!=null && _interested.compareAndSet(callback,null))\n            callback.succeeded();\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void onClose()\n    {\n        if (_interested.compareAndSet(true,false))\n        {\n            Callback callback=_callback;\n            _callback=null;\n            callback.failed(new ClosedChannelException());\n        }\n    }","id":81020,"modified_method":"public void onClose()\n    {\n        Callback callback=_interested.get();\n        if (callback!=null && _interested.compareAndSet(callback,null))\n            callback.failed(new ClosedChannelException());\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        return String.format(\"FillInterest@%x{%b,%s}\",hashCode(),_interested.get(),_callback);\n    }","id":81021,"modified_method":"@Override\n    public String toString()\n    {\n        return String.format(\"FillInterest@%x{%b,%s}\",hashCode(),_interested.get(),_interested.get());\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void doStop() throws Exception\n    {\n        super.doStop();\n\n        long timeout = getStopTimeout();\n        BlockingQueue<Runnable> jobs = getQueue();\n\n        // If no stop timeout, clear job queue\n        if (timeout <= 0)\n            jobs.clear();\n\n        // Fill job Q with noop jobs to wakeup idle\n        Runnable noop = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n            }\n        };\n        for (int i = _threadsStarted.get(); i-- > 0; )\n            jobs.offer(noop);\n\n        // try to jobs complete naturally for half our stop time\n        long stopby = System.currentTimeMillis() + timeout / 2;\n        for (Thread thread : _threads)\n        {\n            long canwait = stopby - System.currentTimeMillis();\n            if (canwait > 0)\n                thread.join(canwait);\n        }\n\n        // If we still have threads running, get a bit more aggressive\n\n        // interrupt remaining threads\n        if (_threadsStarted.get() > 0)\n            for (Thread thread : _threads)\n                thread.interrupt();\n\n        // wait again for the other half of our stop time\n        stopby = System.currentTimeMillis() + timeout / 2;\n        for (Thread thread : _threads)\n        {\n            long canwait = stopby - System.currentTimeMillis();\n            if (canwait > 0)\n                thread.join(canwait);\n        }\n\n        Thread.yield();\n        int size = _threads.size();\n        if (size > 0)\n        {\n            LOG.warn(\"{} threads could not be stopped\", size);\n\n            if ((size <= Runtime.getRuntime().availableProcessors()) || LOG.isDebugEnabled())\n            {\n                for (Thread unstopped : _threads)\n                {\n                    StringBuilder dmp = new StringBuilder();\n                    for (StackTraceElement element : unstopped.getStackTrace())\n                    {\n                        dmp.append(StringUtil.__LINE_SEPARATOR).append(\"\\tat \").append(element);\n                    }\n                    LOG.warn(\"Couldn't stop {}{}\", unstopped, dmp.toString());\n                }\n            }\n        }\n\n        synchronized (_joinLock)\n        {\n            _joinLock.notifyAll();\n        }\n    }","id":81022,"modified_method":"@Override\n    protected void doStop() throws Exception\n    {\n        super.doStop();\n\n        long timeout = getStopTimeout();\n        BlockingQueue<Runnable> jobs = getQueue();\n\n        // If no stop timeout, clear job queue\n        if (timeout <= 0)\n            jobs.clear();\n\n        // Fill job Q with noop jobs to wakeup idle\n        Runnable noop = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n            }\n        };\n        for (int i = _threadsStarted.get(); i-- > 0; )\n            jobs.offer(noop);\n\n        // try to jobs complete naturally for half our stop time\n        long stopby = System.currentTimeMillis() + timeout / 2;\n        for (Thread thread : _threads)\n        {\n            long canwait = stopby - System.currentTimeMillis();\n            if (canwait > 0)\n                thread.join(canwait);\n        }\n\n        // If we still have threads running, get a bit more aggressive\n\n        // interrupt remaining threads\n        if (_threadsStarted.get() > 0)\n            for (Thread thread : _threads)\n                thread.interrupt();\n\n        // wait again for the other half of our stop time\n        stopby = System.currentTimeMillis() + timeout / 2;\n        for (Thread thread : _threads)\n        {\n            long canwait = stopby - System.currentTimeMillis();\n            if (canwait > 0)\n                thread.join(canwait);\n        }\n\n        Thread.yield();\n        int size = _threads.size();\n        if (size > 0)\n        {\n            Thread.yield();\n            \n            if (LOG.isDebugEnabled())\n            {\n                for (Thread unstopped : _threads)\n                {\n                    StringBuilder dmp = new StringBuilder();\n                    for (StackTraceElement element : unstopped.getStackTrace())\n                    {\n                        dmp.append(StringUtil.__LINE_SEPARATOR).append(\"\\tat \").append(element);\n                    }\n                    LOG.warn(\"Couldn't stop {}{}\", unstopped, dmp.toString());\n                }\n            }\n            else\n            {\n                for (Thread unstopped : _threads)\n                    LOG.warn(\"{} Couldn't stop {}\",this,unstopped);\n            }\n        }\n\n        synchronized (_joinLock)\n        {\n            _joinLock.notifyAll();\n        }\n    }","commit_id":"955e7e8d74d6d9ce1cb996568f46706be9e939d3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            AsyncChunk chunk;\n            synchronized (lock)\n            {\n                chunk = current;\n                --size;\n                lock.notify();\n            }\n            chunk.callback.succeeded();\n        }","id":81023,"modified_method":"@Override\n        public void succeeded()\n        {\n            AsyncChunk chunk;\n            synchronized (lock)\n            {\n                chunk = current;\n                if (chunk != null)\n                {\n                    --size;\n                    lock.notify();\n                }\n            }\n            if (chunk != null)\n                chunk.callback.succeeded();\n        }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void failed(Throwable x)\n        {\n            AsyncChunk chunk;\n            synchronized (lock)\n            {\n                chunk = current;\n                failure = x;\n                lock.notify();\n            }\n            chunk.callback.failed(x);\n        }","id":81024,"modified_method":"@Override\n        public void failed(Throwable x)\n        {\n            AsyncChunk chunk;\n            synchronized (lock)\n            {\n                chunk = current;\n                failure = x;\n                lock.notify();\n            }\n            if (chunk != null)\n                chunk.callback.failed(x);\n        }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected boolean content(ByteBuffer buffer)\n    {\n        HttpExchange exchange = getHttpExchange();\n        return exchange != null && receiver.responseContent(exchange, buffer);\n    }","id":81025,"modified_method":"protected boolean content(ByteBuffer buffer)\n    {\n        HttpExchange exchange = getHttpExchange();\n        // TODO: handle callback properly\n        return exchange != null && receiver.responseContent(exchange, buffer, new Callback.Adapter());\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Method to be invoked after all response HTTP headers are available.\n     * <p />\n     * This method takes case of notifying {@link org.eclipse.jetty.client.api.Response.HeadersListener}s.\n     *\n     * @param exchange the HTTP exchange\n     * @return whether the processing should continue\n     */\n    protected boolean responseHeaders(HttpExchange exchange)\n    {\n        out: while (true)\n        {\n            ResponseState current = responseState.get();\n            switch (current)\n            {\n                case BEGIN:\n                case HEADER:\n                {\n                    if (updateResponseState(current, ResponseState.HEADERS))\n                        break out;\n                    break;\n                }\n                default:\n                {\n                    return false;\n                }\n            }\n        }\n\n        HttpResponse response = exchange.getResponse();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Response headers {}{}{}\", response, System.getProperty(\"line.separator\"), response.getHeaders().toString().trim());\n        ResponseNotifier notifier = getHttpDestination().getResponseNotifier();\n        notifier.notifyHeaders(exchange.getConversation().getResponseListeners(), response);\n\n        Enumeration<String> contentEncodings = response.getHeaders().getValues(HttpHeader.CONTENT_ENCODING.asString(), \",\");\n        if (contentEncodings != null)\n        {\n            for (ContentDecoder.Factory factory : getHttpDestination().getHttpClient().getContentDecoderFactories())\n            {\n                while (contentEncodings.hasMoreElements())\n                {\n                    if (factory.getEncoding().equalsIgnoreCase(contentEncodings.nextElement()))\n                    {\n                        this.decoder = factory.newContentDecoder();\n                        break;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","id":81026,"modified_method":"/**\n     * Method to be invoked after all response HTTP headers are available.\n     * <p />\n     * This method takes case of notifying {@link org.eclipse.jetty.client.api.Response.HeadersListener}s.\n     *\n     * @param exchange the HTTP exchange\n     * @return whether the processing should continue\n     */\n    protected boolean responseHeaders(HttpExchange exchange)\n    {\n        out: while (true)\n        {\n            ResponseState current = responseState.get();\n            switch (current)\n            {\n                case BEGIN:\n                case HEADER:\n                {\n                    if (updateResponseState(current, ResponseState.HEADERS))\n                        break out;\n                    break;\n                }\n                default:\n                {\n                    return false;\n                }\n            }\n        }\n\n        HttpResponse response = exchange.getResponse();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Response headers {}{}{}\", response, System.lineSeparator(), response.getHeaders().toString().trim());\n        ResponseNotifier notifier = getHttpDestination().getResponseNotifier();\n        notifier.notifyHeaders(exchange.getConversation().getResponseListeners(), response);\n\n        Enumeration<String> contentEncodings = response.getHeaders().getValues(HttpHeader.CONTENT_ENCODING.asString(), \",\");\n        if (contentEncodings != null)\n        {\n            for (ContentDecoder.Factory factory : getHttpDestination().getHttpClient().getContentDecoderFactories())\n            {\n                while (contentEncodings.hasMoreElements())\n                {\n                    if (factory.getEncoding().equalsIgnoreCase(contentEncodings.nextElement()))\n                    {\n                        this.decoder = factory.newContentDecoder();\n                        break;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Method to be invoked when response HTTP content is available.\n     * <p />\n     * This method takes case of decoding the content, if necessary, and notifying {@link org.eclipse.jetty.client.api.Response.ContentListener}s.\n     *\n     * @param exchange the HTTP exchange\n     * @param buffer the response HTTP content buffer\n     * @return whether the processing should continue\n     */\n    protected boolean responseContent(HttpExchange exchange, ByteBuffer buffer)\n    {\n        out: while (true)\n        {\n            ResponseState current = responseState.get();\n            switch (current)\n            {\n                case HEADERS:\n                case CONTENT:\n                {\n                    if (updateResponseState(current, ResponseState.CONTENT))\n                        break out;\n                    break;\n                }\n                default:\n                {\n                    return false;\n                }\n            }\n        }\n\n        HttpResponse response = exchange.getResponse();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Response content {}{}{}\", response, System.getProperty(\"line.separator\"), BufferUtil.toDetailString(buffer));\n\n        ContentDecoder decoder = this.decoder;\n        if (decoder != null)\n        {\n            buffer = decoder.decode(buffer);\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Response content decoded ({}) {}{}{}\", decoder, response, System.getProperty(\"line.separator\"), BufferUtil.toDetailString(buffer));\n        }\n\n        ResponseNotifier notifier = getHttpDestination().getResponseNotifier();\n        notifier.notifyContent(exchange.getConversation().getResponseListeners(), response, buffer);\n\n        return true;\n    }","id":81027,"modified_method":"/**\n     * Method to be invoked when response HTTP content is available.\n     * <p />\n     * This method takes case of decoding the content, if necessary, and notifying {@link org.eclipse.jetty.client.api.Response.ContentListener}s.\n     *\n     * @param exchange the HTTP exchange\n     * @param buffer the response HTTP content buffer\n     * @return whether the processing should continue\n     */\n    protected boolean responseContent(HttpExchange exchange, ByteBuffer buffer, Callback callback)\n    {\n        out: while (true)\n        {\n            ResponseState current = responseState.get();\n            switch (current)\n            {\n                case HEADERS:\n                case CONTENT:\n                {\n                    if (updateResponseState(current, ResponseState.CONTENT))\n                        break out;\n                    break;\n                }\n                default:\n                {\n                    return false;\n                }\n            }\n        }\n\n        HttpResponse response = exchange.getResponse();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Response content {}{}{}\", response, System.lineSeparator(), BufferUtil.toDetailString(buffer));\n\n        ContentDecoder decoder = this.decoder;\n        if (decoder != null)\n        {\n            buffer = decoder.decode(buffer);\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Response content decoded ({}) {}{}{}\", decoder, response, System.lineSeparator(), BufferUtil.toDetailString(buffer));\n        }\n\n        ResponseNotifier notifier = getHttpDestination().getResponseNotifier();\n        notifier.notifyContent(exchange.getConversation().getResponseListeners(), response, buffer, callback);\n\n        return true;\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected boolean responseContent(HttpExchange exchange, ByteBuffer buffer)\n    {\n        return super.responseContent(exchange, buffer);\n    }","id":81028,"modified_method":"@Override\n    protected boolean responseContent(HttpExchange exchange, ByteBuffer buffer, Callback callback)\n    {\n        return super.responseContent(exchange, buffer, callback);\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void receive()\n    {\n        HttpConnectionOverHTTP connection = getHttpConnection();\n        EndPoint endPoint = connection.getEndPoint();\n        HttpClient client = getHttpDestination().getHttpClient();\n        ByteBufferPool bufferPool = client.getByteBufferPool();\n        ByteBuffer buffer = bufferPool.acquire(client.getResponseBufferSize(), true);\n        try\n        {\n            while (true)\n            {\n                // Connection may be closed in a parser callback\n                if (connection.isClosed())\n                {\n                    LOG.debug(\"{} closed\", connection);\n                    break;\n                }\n                else\n                {\n                    int read = endPoint.fill(buffer);\n                    if (LOG.isDebugEnabled()) // Avoid boxing of variable 'read'\n                        LOG.debug(\"Read {} bytes from {}\", read, endPoint);\n                    if (read > 0)\n                    {\n                        parse(buffer);\n                    }\n                    else if (read == 0)\n                    {\n                        fillInterested();\n                        break;\n                    }\n                    else\n                    {\n                        shutdown();\n                        break;\n                    }\n                }\n            }\n        }\n        catch (EofException x)\n        {\n            LOG.ignore(x);\n            failAndClose(x);\n        }\n        catch (Exception x)\n        {\n            LOG.debug(x);\n            failAndClose(x);\n        }\n        finally\n        {\n            bufferPool.release(buffer);\n        }\n    }","id":81029,"modified_method":"public void receive()\n    {\n        HttpClient client = getHttpDestination().getHttpClient();\n        ByteBufferPool bufferPool = client.getByteBufferPool();\n        buffer = bufferPool.acquire(client.getResponseBufferSize(), true);\n        if (process())\n        {\n            bufferPool.release(buffer);\n            // Don't linger the buffer around if we are idle.\n            buffer = null;\n        }\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean content(ByteBuffer buffer)\n    {\n        HttpExchange exchange = getHttpExchange();\n        if (exchange == null)\n            return false;\n\n        // TODO: need to create the callback here, then check whether it has completed\n        // TODO: after the call to responseContent. If it has, return false.\n        // TODO: if it has not, return true, and when will be invoked, we need to\n        // TODO: proceed with parsing.\n\n        responseContent(exchange, buffer);\n        return false;\n    }","id":81030,"modified_method":"@Override\n    public boolean content(ByteBuffer buffer)\n    {\n        HttpExchange exchange = getHttpExchange();\n        if (exchange == null)\n            return false;\n\n        final AtomicBoolean completed = new AtomicBoolean();\n        Callback callback = new Callback()\n        {\n            @Override\n            public void succeeded()\n            {\n                if (!completed.compareAndSet(false, true))\n                {\n                    LOG.debug(\"Content consumed asynchronously, resuming processing\");\n                    if (process())\n                    {\n                        // TODO: release the buffer to the pool !\n                    }\n                }\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                failAndClose(x);\n            }\n        };\n        responseContent(exchange, buffer, callback);\n        // Return false to have the parser continue parsing.\n        // TODO: there is a race here: when this thread returns true, the parser is still running\n        // TODO: some stateful code that may be changed concurrently by the callback thread.\n        return completed.compareAndSet(false, true);\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void parse(ByteBuffer buffer)\n    {\n        while (buffer.hasRemaining())\n            parser.parseNext(buffer);\n    }","id":81031,"modified_method":"private boolean parse(ByteBuffer buffer)\n    {\n        while (buffer.hasRemaining())\n        {\n            if (parser.parseNext(buffer))\n                return parser.isStart();\n        }\n        return true;\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onData(Stream stream, DataInfo dataInfo)\n    {\n        HttpExchange exchange = getHttpExchange();\n        if (exchange == null)\n            return;\n\n        try\n        {\n            int length = dataInfo.length();\n            // TODO: avoid data copy here\n            boolean process = responseContent(exchange, dataInfo.asByteBuffer(false));\n            dataInfo.consume(length);\n\n            if (process)\n            {\n                if (dataInfo.isClose())\n                {\n                    responseSuccess(exchange);\n                }\n            }\n        }\n        catch (Exception x)\n        {\n            responseFailure(x);\n        }\n    }","id":81032,"modified_method":"@Override\n    public void onData(Stream stream, DataInfo dataInfo)\n    {\n        HttpExchange exchange = getHttpExchange();\n        if (exchange == null)\n            return;\n\n        try\n        {\n            int length = dataInfo.length();\n            // TODO: avoid data copy here\n            // TODO: handle callback properly\n            boolean process = responseContent(exchange, dataInfo.asByteBuffer(false), new Callback.Adapter());\n            dataInfo.consume(length);\n\n            if (process)\n            {\n                if (dataInfo.isClose())\n                {\n                    responseSuccess(exchange);\n                }\n            }\n        }\n        catch (Exception x)\n        {\n            responseFailure(x);\n        }\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void forwardFailure(List<Response.ResponseListener> listeners, Response response, Throwable failure)\n    {\n        notifyBegin(listeners, response);\n        for (Iterator<HttpField> iterator = response.getHeaders().iterator(); iterator.hasNext();)\n        {\n            HttpField field = iterator.next();\n            if (!notifyHeader(listeners, response, field))\n                iterator.remove();\n        }\n        notifyHeaders(listeners, response);\n        if (response instanceof ContentResponse)\n            notifyContent(listeners, response, ByteBuffer.wrap(((ContentResponse)response).getContent()));\n        notifyFailure(listeners, response, failure);\n    }","id":81033,"modified_method":"public void forwardFailure(List<Response.ResponseListener> listeners, Response response, Throwable failure)\n    {\n        notifyBegin(listeners, response);\n        for (Iterator<HttpField> iterator = response.getHeaders().iterator(); iterator.hasNext();)\n        {\n            HttpField field = iterator.next();\n            if (!notifyHeader(listeners, response, field))\n                iterator.remove();\n        }\n        notifyHeaders(listeners, response);\n        if (response instanceof ContentResponse)\n            // TODO: handle callback\n            notifyContent(listeners, response, ByteBuffer.wrap(((ContentResponse)response).getContent()), new Callback.Adapter());\n        notifyFailure(listeners, response, failure);\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void forwardSuccess(List<Response.ResponseListener> listeners, Response response)\n    {\n        notifyBegin(listeners, response);\n        for (Iterator<HttpField> iterator = response.getHeaders().iterator(); iterator.hasNext();)\n        {\n            HttpField field = iterator.next();\n            if (!notifyHeader(listeners, response, field))\n                iterator.remove();\n        }\n        notifyHeaders(listeners, response);\n        if (response instanceof ContentResponse)\n            notifyContent(listeners, response, ByteBuffer.wrap(((ContentResponse)response).getContent()));\n        notifySuccess(listeners, response);\n    }","id":81034,"modified_method":"public void forwardSuccess(List<Response.ResponseListener> listeners, Response response)\n    {\n        notifyBegin(listeners, response);\n        for (Iterator<HttpField> iterator = response.getHeaders().iterator(); iterator.hasNext();)\n        {\n            HttpField field = iterator.next();\n            if (!notifyHeader(listeners, response, field))\n                iterator.remove();\n        }\n        notifyHeaders(listeners, response);\n        if (response instanceof ContentResponse)\n            // TODO: handle callback\n            notifyContent(listeners, response, ByteBuffer.wrap(((ContentResponse)response).getContent()), new Callback.Adapter());\n        notifySuccess(listeners, response);\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void notifyContent(List<Response.ResponseListener> listeners, Response response, ByteBuffer buffer)\n    {\n        // TODO: we need to create a \"cumulative\" callback that keeps track of how many listeners\n        // TODO: are invoked, and how many of these actually invoked the callback, and eventually\n        // TODO: call the callback passed to this method.\n\n        // Slice the buffer to avoid that listeners peek into data they should not look at.\n        buffer = buffer.slice();\n        if (!buffer.hasRemaining())\n            return;\n        // Optimized to avoid allocations of iterator instances\n        for (int i = 0; i < listeners.size(); ++i)\n        {\n            Response.ResponseListener listener = listeners.get(i);\n            if (listener instanceof Response.ContentListener)\n            {\n                // The buffer was sliced, so we always clear it (position=0, limit=capacity)\n                // before passing it to the listener that may consume it.\n                buffer.clear();\n                notifyContent((Response.ContentListener)listener, response, buffer);\n            }\n        }\n    }","id":81035,"modified_method":"public void notifyContent(List<Response.ResponseListener> listeners, Response response, ByteBuffer buffer, Callback callback)\n    {\n        ContentCallback contentCallback = new ContentCallback(listeners, response, buffer, callback);\n        contentCallback.iterate();\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void notifyContent(Response.ContentListener listener, Response response, ByteBuffer buffer)\n    {\n        try\n        {\n            listener.onContent(response, buffer);\n        }\n        catch (Throwable x)\n        {\n            LOG.info(\"Exception while notifying listener \" + listener, x);\n        }\n    }","id":81036,"modified_method":"private void notifyContent(Response.AsyncContentListener listener, Response response, ByteBuffer buffer, Callback callback)\n    {\n        try\n        {\n            listener.onContent(response, buffer, callback);\n        }\n        catch (Throwable x)\n        {\n            LOG.info(\"Exception while notifying listener \" + listener, x);\n        }\n    }","commit_id":"aeb27cd461d2faa4b77413e029f04f4b13e79777","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@NotNull\n  GitBranchState readState(@NotNull Collection<GitRemote> remotes) {\n    Pair<Set<GitLocalBranch>, Set<GitRemoteBranch>> branches = readBranches(remotes);\n    HeadInfo headInfo = readHead();\n    Repository.State state = readRepositoryState(headInfo);\n    GitLocalBranch currentBranch = findCurrentBranch(headInfo, state, branches.first);\n    String currentRevision = getCurrentRevision(headInfo, currentBranch);\n    return new GitBranchState(currentRevision, currentBranch, state, branches.first, branches.second);\n  }","id":81037,"modified_method":"@NotNull\n  GitBranchState readState(@NotNull Collection<GitRemote> remotes) {\n    Pair<Set<GitLocalBranch>, Set<GitRemoteBranch>> branches = readBranches(remotes);\n    Set<GitLocalBranch> localBranches = branches.first;\n\n    HeadInfo headInfo = readHead();\n    Repository.State state = readRepositoryState(headInfo);\n\n    GitLocalBranch currentBranch;\n    String currentRevision;\n    if (localBranches.isEmpty() && headInfo.content != null) {\n      currentBranch = new GitLocalBranch(headInfo.content, GitBranch.DUMMY_HASH);\n      currentRevision = null;\n    }\n    else {\n      currentBranch = findCurrentBranch(headInfo, state, localBranches);\n      currentRevision = getCurrentRevision(headInfo, currentBranch);\n    }\n    return new GitBranchState(currentRevision, currentBranch, state, localBranches, branches.second);\n  }","commit_id":"f0ea5015b4a05880a1463066c4860c69062da4aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void test_remote_reference_without_remote() {\n    final String INVALID_REMOTE = \"invalid-remote\";\n    final String INVALID_REMOTE_BRANCH = \"master\";\n    git(\"update-ref refs/remotes/\" + INVALID_REMOTE + \"/\" + INVALID_REMOTE_BRANCH + \" HEAD\");\n\n    Collection<GitRemoteBranch> remoteBranches = readState().getRemoteBranches();\n    assertTrue(\"Remote branch not found\", ContainerUtil.exists(remoteBranches, new Condition<GitRemoteBranch>() {\n      @Override\n      public boolean value(GitRemoteBranch branch) {\n        return branch.getNameForLocalOperations().equals(INVALID_REMOTE + \"/\" + INVALID_REMOTE_BRANCH);\n      }\n    }));\n  }","id":81038,"modified_method":"public void test_remote_reference_without_remote() throws IOException {\n    makeCommit(\"file.txt\");\n    final String INVALID_REMOTE = \"invalid-remote\";\n    final String INVALID_REMOTE_BRANCH = \"master\";\n    git(\"update-ref refs/remotes/\" + INVALID_REMOTE + \"/\" + INVALID_REMOTE_BRANCH + \" HEAD\");\n\n    Collection<GitRemoteBranch> remoteBranches = readState().getRemoteBranches();\n    assertTrue(\"Remote branch not found\", ContainerUtil.exists(remoteBranches, new Condition<GitRemoteBranch>() {\n      @Override\n      public boolean value(GitRemoteBranch branch) {\n        return branch.getNameForLocalOperations().equals(INVALID_REMOTE + \"/\" + INVALID_REMOTE_BRANCH);\n      }\n    }));\n  }","commit_id":"f0ea5015b4a05880a1463066c4860c69062da4aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void test_rebase_with_conflicts_while_being_on_detached_HEAD() {\n    conflict(myRepo, \"feature\");\n    commit(myRepo);\n    commit(myRepo);\n    git(\"checkout HEAD^\");\n    git(\"rebase feature\", true);\n\n    GitBranchState state = readState();\n    assertNull(\"Current branch can't be identified for this case\", state.getCurrentBranch());\n    assertEquals(\"State value is incorrect\", Repository.State.REBASING, state.getState());\n  }","id":81039,"modified_method":"public void test_rebase_with_conflicts_while_being_on_detached_HEAD() throws IOException {\n    makeCommit(\"file.txt\");\n    conflict(myRepo, \"feature\");\n    commit(myRepo);\n    commit(myRepo);\n    git(\"checkout HEAD^\");\n    git(\"rebase feature\", true);\n\n    GitBranchState state = readState();\n    assertNull(\"Current branch can't be identified for this case\", state.getCurrentBranch());\n    assertEquals(\"State value is incorrect\", Repository.State.REBASING, state.getState());\n  }","commit_id":"f0ea5015b4a05880a1463066c4860c69062da4aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void test_detached_HEAD() throws IOException {\n    makeCommit(\"file.txt\");\n    git(\"checkout HEAD^\");\n    GitBranchState state = readState();\n    assertEquals(\"Detached HEAD is not detected\", GitRepository.State.DETACHED, state.getState());\n    assertEquals(\"Detached HEAD hash is incorrect\", last(), state.getCurrentRevision());\n  }","id":81040,"modified_method":"public void test_detached_HEAD() throws IOException {\n    makeCommit(\"file.txt\");\n    makeCommit(\"file.txt\");\n    git(\"checkout HEAD^\");\n    GitBranchState state = readState();\n    assertEquals(\"Detached HEAD is not detected\", GitRepository.State.DETACHED, state.getState());\n    assertEquals(\"Detached HEAD hash is incorrect\", last(), state.getCurrentRevision());\n  }","commit_id":"f0ea5015b4a05880a1463066c4860c69062da4aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void showDiffWithBranch(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head, @NotNull String branchToCompare) throws VcsException {\n      final FilePath filePath = new FilePathImpl(file);\n      final VcsRevisionNumber currentRevisionNumber = GitHistoryUtils.getCurrentRevision(project, filePath, head);\n      final VcsRevisionNumber compareRevisionNumber = GitHistoryUtils.getCurrentRevision(project, filePath, branchToCompare);\n      if (compareRevisionNumber == null) {\n        fileDoesntExistInBranchError(project, file, branchToCompare);\n        return;\n      }\n      final VcsFileRevision compareRevision = new GitFileRevision(project, filePath, (GitRevisionNumber)compareRevisionNumber, false);\n      final String currentTitle = currentRevisionNumber != null ? ((GitRevisionNumber)currentRevisionNumber).getShortRev() + \" on \" + head : \"Local changes on \" + head;\n      final String compareTitle = ((GitRevisionNumber)compareRevisionNumber).getShortRev() + \" on \" + branchToCompare;\n\n      try {\n        VcsHistoryUtil.showDiff(project, filePath, new CurrentRevision(file, currentRevisionNumber), compareRevision, currentTitle, compareTitle);\n      }\n      catch (IOException e) {\n        throw new VcsException(String.format(\"Couldn't show diff for file [%s], head [%s] and branch [%s]\", file.getPresentableUrl(), head, branchToCompare), e);\n      }\n    }","id":81041,"modified_method":"private static void showDiffWithBranch(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head,\n                                           @NotNull String branchToCompare) throws VcsException {\n      final FilePath filePath = new FilePathImpl(file);\n      // we could use something like GitRepository#getCurrentRevision here,\n      // but this way we can easily identify if the file is available in the branch\n      final GitRevisionNumber currentRevisionNumber = (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, head);\n      final GitRevisionNumber compareRevisionNumber =\n        (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, branchToCompare);\n\n      if (compareRevisionNumber == null) {\n        fileDoesntExistInBranchError(project, file, branchToCompare);\n        return;\n      }\n      LOG.assertTrue(currentRevisionNumber != null,\n                     String.format(\"Current revision number is null for file [%s] and branch [%s]\", filePath, head));\n\n      // constructing the revision with human readable name (will work for files comparison however).\n      final VcsFileRevision compareRevision =\n        new GitFileRevision(project, filePath, new GitRevisionNumber(branchToCompare, compareRevisionNumber.getTimestamp()), false);\n      CurrentRevision currentRevision = new CurrentRevision(file, new GitRevisionNumber(head, currentRevisionNumber.getTimestamp()));\n      new GitDiffFromHistoryHandler(project).showDiff(new FilePathImpl(file), compareRevision, currentRevision);\n    }","commit_id":"edaff474e8f5b77bd9952a3bd3d314aa6ac1ee03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    Presentation presentation = e.getPresentation();\n    Project project = e.getProject();\n    if (project == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    VirtualFile[] vFiles = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length != 1 || vFiles[0] == null || vFiles[0].isDirectory()) { // only 1 file for now, not for dirs\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n      return;\n    }\n\n    GitRepositoryManager manager = GitUtil.getRepositoryManager(project);\n\n    GitRepository repository = manager.getRepositoryForFile(vFiles[0]);\n    if (repository == null || repository.isFresh() || noBranchesToCompare(repository)) {\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n      return;\n    }\n\n    presentation.setEnabled(true);\n    presentation.setVisible(true);\n  }","id":81042,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    Presentation presentation = e.getPresentation();\n    Project project = e.getProject();\n    if (project == null) {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n      return;\n    }\n\n    VirtualFile[] vFiles = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    if (vFiles == null || vFiles.length != 1 || vFiles[0] == null) { // only 1 file for now\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n      return;\n    }\n\n    GitRepositoryManager manager = GitUtil.getRepositoryManager(project);\n\n    GitRepository repository = manager.getRepositoryForFile(vFiles[0]);\n    if (repository == null || repository.isFresh() || noBranchesToCompare(repository)) {\n      presentation.setEnabled(false);\n      presentation.setVisible(true);\n      return;\n    }\n\n    presentation.setEnabled(true);\n    presentation.setVisible(true);\n  }","commit_id":"edaff474e8f5b77bd9952a3bd3d314aa6ac1ee03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void run() {\n      new Task.Backgroundable(myProject, \"Comparing...\") {\n        @Override public void run(@NotNull ProgressIndicator indicator) {\n          String branchToCompare = myList.getSelectedValue().toString();\n          try {\n            showDiffWithBranch(myProject, myFile, myHead, branchToCompare);\n          }\n          catch (VcsException e) {\n            if (e.getMessage().contains(\"exists on disk, but not in\")) {\n              fileDoesntExistInBranchError(myProject, myFile, branchToCompare);\n            } else {\n              GitUIUtil.notifyError(myProject, \"Couldn't compare with branch\",\n                                    \"Couldn't compare file [\" + myFile + \"] with selected branch [\" + myList.getSelectedValue() + \"]\",\n                                    false, e);\n            }\n          }\n        }\n      }.queue();\n    }","id":81043,"modified_method":"@Override\n    public void run() {\n      String branchToCompare = myList.getSelectedValue().toString();\n      try {\n        showDiffWithBranch(myProject, myFile, myHead, branchToCompare);\n      }\n      catch (VcsException e) {\n        if (e.getMessage().contains(\"exists on disk, but not in\")) {\n          fileDoesntExistInBranchError(myProject, myFile, branchToCompare);\n        } else {\n          GitUIUtil.notifyError(myProject, \"Couldn't compare with branch\",\n                                String.format(\"Couldn't compare file [%s] with selected branch [%s]\", myFile, myList.getSelectedValue()),\n                                false, e);\n        }\n      }\n    }","commit_id":"edaff474e8f5b77bd9952a3bd3d314aa6ac1ee03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"GitDiffFromHistoryHandler(@NotNull Project project) {\n    myProject = project;\n    myGit = ServiceManager.getService(project, Git.class);\n    myRepositoryManager = GitUtil.getRepositoryManager(project);\n  }","id":81044,"modified_method":"public GitDiffFromHistoryHandler(@NotNull Project project) {\n    myProject = project;\n    myGit = ServiceManager.getService(project, Git.class);\n    myRepositoryManager = GitUtil.getRepositoryManager(project);\n  }","commit_id":"edaff474e8f5b77bd9952a3bd3d314aa6ac1ee03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void outputVersions(ModuleSpec module, Collection<ModuleVersionDetails> versions) throws IOException {\n        if (findMember == null) {\n            msg(\"version.query\", module.getName()).newline();\n        } else {\n            msg(\"version.query.find\", module.getName(), findMember).newline();\n        }\n        outputVersions(versions, \"    \");\n    }","id":81045,"modified_method":"private void outputVersions(ModuleSpec module, Collection<ModuleVersionDetails> versions) throws IOException {\n        if (System.console() != null) {\n            if (findMember == null) {\n                msg(\"version.query\", module.getName()).newline();\n            } else {\n                msg(\"version.query.find\", module.getName(), findMember).newline();\n            }\n        }\n        outputVersions(module.getName(), versions, \"    \");\n    }","commit_id":"89a63125cc3c4a2503de7d44ba8ccc5d05c6915d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputNames(ModuleVersionDetails version, String prefix) throws IOException {\n        for (String member : version.getMembers()) {\n            append(prefix).append(member).newline();\n        }\n    }","id":81046,"modified_method":"private void outputNames(String moduleName, ModuleVersionDetails version, String prefix) throws IOException {\n        for (String member : version.getMembers()) {\n            if (System.console() != null) {\n                append(prefix).append(member).newline();\n            } else {\n                append(moduleName);\n                if (showVersions) {\n                    append(\"/\").append(version.getVersion());\n                }\n                append(\"::\").append(member).newline();\n            }\n        }\n    }","commit_id":"89a63125cc3c4a2503de7d44ba8ccc5d05c6915d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputVersions(Collection<ModuleVersionDetails> versions, String prefix) throws IOException {\n        for (ModuleVersionDetails version : versions) {\n            append(prefix).append(version.getVersion());\n            if (version.isRemote()) {\n                append(\" *\");\n            }\n            newline();\n            if (showDependencies) {\n                for (ModuleInfo dep : version.getDependencies()) {\n                    append(prefix).append(\"    \").append(dep).newline();\n                }\n            }\n            if (showNames) {\n                outputNames(version, prefix + \"    \");\n            }\n        }\n    }","id":81047,"modified_method":"private void outputVersions(String moduleName, Collection<ModuleVersionDetails> versions, String prefix) throws IOException {\n        String namePrefix = (System.console() != null) ? prefix + \"    \" : \"\";\n        for (ModuleVersionDetails version : versions) {\n            if (System.console() != null || (!showDependencies && !showNames)) {\n                append(prefix);\n                if (System.console() == null) {\n                    append(moduleName).append(\"/\");\n                }\n                append(version.getVersion());\n                if (version.isRemote() && System.console() != null) {\n                    append(\" *\");\n                }\n                newline();\n            }\n            if (showDependencies) {\n                for (ModuleInfo dep : version.getDependencies()) {\n                    if (System.console() != null) {\n                        append(prefix).append(\"    \");\n                    } else {\n                        append(moduleName).append(\"/\").append(version.getVersion());\n                    }\n                    append(dep).newline();\n                }\n            }\n            if (showNames) {\n                outputNames(moduleName, version, namePrefix);\n            }\n        }\n    }","commit_id":"89a63125cc3c4a2503de7d44ba8ccc5d05c6915d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputModules(ModuleSpec query, Collection<ModuleDetails> modules) throws IOException {\n        if (findMember == null) {\n            msg(\"module.query\", query.getName()).newline();\n        } else {\n            msg(\"module.query.find\", query.getName(), findMember).newline();\n        }\n        for (ModuleDetails module : modules) {\n            append(\"    \").append(module.getName()).newline();\n            if (showVersions) {\n                outputVersions(module.getVersions(), \"        \");\n            } else if (showNames) {\n                outputNames(module.getLastVersion(), \"        \");\n            }\n        }\n    }","id":81048,"modified_method":"private void outputModules(ModuleSpec query, Collection<ModuleDetails> modules) throws IOException {\n        if (System.console() != null) {\n            if (findMember == null) {\n                msg(\"module.query\", query.getName()).newline();\n            } else {\n                msg(\"module.query.find\", query.getName(), findMember).newline();\n            }\n        }\n        String prefix = (System.console() != null) ? \"    \" : \"\";\n        for (ModuleDetails module : modules) {\n            if (System.console() != null || (!showVersions && !showNames)) {\n                append(prefix).append(module.getName()).newline();\n            }\n            if (showVersions) {\n                outputVersions(module.getName(), module.getVersions(), prefix + prefix);\n            } else if (showNames) {\n                outputNames(module.getName(), module.getLastVersion(), prefix + prefix);\n            }\n        }\n    }","commit_id":"89a63125cc3c4a2503de7d44ba8ccc5d05c6915d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputVersions(Collection<ModuleVersionDetails> versions, String prefix) throws IOException {\n        for (ModuleVersionDetails version : versions) {\n            append(prefix).append(version.getVersion());\n            if (version.isRemote()) {\n                append(\" *\");\n            }\n            newline();\n            if (showDependencies) {\n                for (ModuleInfo dep : version.getDependencies()) {\n                    append(prefix).append(\"    \").append(dep).newline();\n                }\n            }\n        }\n    }","id":81049,"modified_method":"private void outputVersions(Collection<ModuleVersionDetails> versions, String prefix) throws IOException {\n        for (ModuleVersionDetails version : versions) {\n            append(prefix).append(version.getVersion());\n            if (version.isRemote()) {\n                append(\" *\");\n            }\n            newline();\n            if (showDependencies) {\n                for (ModuleInfo dep : version.getDependencies()) {\n                    append(prefix).append(\"    \").append(dep).newline();\n                }\n            }\n            if (showMembers) {\n                outputMembers(version, prefix + \"    \");\n            }\n        }\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputVersions(ModuleSpec module, Collection<ModuleVersionDetails> versions) throws IOException {\n        msg(\"version.query\").append(module.getName()).newline();\n        outputVersions(versions, \"    \");\n    }","id":81050,"modified_method":"private void outputVersions(ModuleSpec module, Collection<ModuleVersionDetails> versions) throws IOException {\n        if (findMember == null) {\n            msg(\"version.query\", module.getName()).newline();\n        } else {\n            msg(\"version.query.find\", module.getName(), findMember).newline();\n        }\n        outputVersions(versions, \"    \");\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void initialize() {\n        if (showType != null) {\n            if (\"jvm\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.JVM;\n            } else if (\"js\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.JS;\n            } else if (\"src\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.SRC;\n            } else if (\"all\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.ALL;\n            } else {\n                throw new IllegalArgumentException(CeylonInfoMessages.msg(\"illegal.type\", showType));\n            }\n        }\n    }","id":81051,"modified_method":"@Override\n    public void initialize() {\n        if (showType != null) {\n            if (\"jvm\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.JVM;\n            } else if (\"js\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.JS;\n            } else if (\"src\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.SRC;\n            } else if (\"all\".equalsIgnoreCase(showType)) {\n                queryType = ModuleQuery.Type.ALL;\n            } else {\n                throw new IllegalArgumentException(CeylonInfoMessages.msg(\"illegal.type\", showType));\n            }\n        }\n        if (findMember != null &&\"src\".equalsIgnoreCase(showType)) {\n            throw new IllegalArgumentException(CeylonInfoMessages.msg(\"incompatible.query.and.find\", showType));\n        }\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputModules(ModuleSpec query, Collection<ModuleDetails> modules) throws IOException {\n        msg(\"module.query\").append(query.getName()).newline();\n        for (ModuleDetails module : modules) {\n            append(\"    \").append(module.getName()).newline();\n            if (showVersions) {\n                outputVersions(module.getVersions(), \"        \");\n            }\n        }\n    }","id":81052,"modified_method":"private void outputModules(ModuleSpec query, Collection<ModuleDetails> modules) throws IOException {\n        if (findMember == null) {\n            msg(\"module.query\", query.getName()).newline();\n        } else {\n            msg(\"module.query.find\", query.getName(), findMember).newline();\n        }\n        for (ModuleDetails module : modules) {\n            append(\"    \").append(module.getName()).newline();\n            if (showVersions) {\n                outputVersions(module.getVersions(), \"        \");\n            } else if (showMembers) {\n                outputMembers(module.getLastVersion(), \"        \");\n            }\n        }\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private Collection<ModuleDetails> getModules(RepositoryManager repoMgr, String name, ModuleQuery.Type type, Integer binaryMajor, Integer binaryMinor) {\n        String queryString = name;\n        if (queryString.startsWith(\"*\")) {\n            queryString = queryString.substring(1);\n        }\n        if (queryString.endsWith(\"*\")) {\n            queryString = queryString.substring(0, queryString.length() - 1);\n        }\n        \n        ModuleQuery query = new ModuleQuery(queryString, type);\n        if (binaryMajor != null) {\n            query.setBinaryMajor(binaryMajor);\n        }\n        if (binaryMinor != null) {\n            query.setBinaryMinor(binaryMinor);\n        }\n        ModuleSearchResult result;\n        if (!name.startsWith(\"*\")) {\n            result = repoMgr.completeModules(query);\n        } else {\n            result = repoMgr.searchModules(query);\n        }\n        return result.getResults();\n    }","id":81053,"modified_method":"private Collection<ModuleDetails> getModules(RepositoryManager repoMgr, String name, ModuleQuery.Type type, Integer binaryMajor, Integer binaryMinor, String memberName) {\n        String queryString = name;\n        if (queryString.startsWith(\"*\")) {\n            queryString = queryString.substring(1);\n        }\n        if (queryString.endsWith(\"*\")) {\n            queryString = queryString.substring(0, queryString.length() - 1);\n        }\n        \n        ModuleQuery query = new ModuleQuery(queryString, type);\n        if (binaryMajor != null) {\n            query.setBinaryMajor(binaryMajor);\n        }\n        if (binaryMinor != null) {\n            query.setBinaryMinor(binaryMinor);\n        }\n        if (memberName != null) {\n            query.setMemberName(findMember);\n        }\n        \n        ModuleSearchResult result;\n        if (!name.startsWith(\"*\") || name.equals(\"*\")) {\n            result = repoMgr.completeModules(query);\n        } else {\n            result = repoMgr.searchModules(query);\n        }\n        return result.getResults();\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void run() throws Exception {\n        setSystemProperties();\n        if (!showIncompatible) {\n            binaryMajor = Versions.JVM_BINARY_MAJOR_VERSION;\n            binaryMinor = Versions.JVM_BINARY_MINOR_VERSION;\n        }\n        for (ModuleSpec module : modules) {\n            String name = module.getName();\n            if (!module.isVersioned() && (name.startsWith(\"*\") || name.endsWith(\"*\"))) {\n                Collection<ModuleDetails> modules = getModules(name, queryType, binaryMajor, binaryMinor);\n                if (modules.isEmpty()) {\n                    String err = getModuleNotFoundErrorMessage(getRepositoryManager(), module.getName(), module.getVersion());\n                    errorAppend(err);\n                    errorNewline();\n                    continue;\n                }\n                outputModules(module, modules);\n            } else {\n                Collection<ModuleVersionDetails> versions = getModuleVersions(module.getName(), module.getVersion(), queryType, binaryMajor, binaryMinor);\n                if (versions.isEmpty()) {\n                    String err = getModuleNotFoundErrorMessage(getRepositoryManager(), module.getName(), module.getVersion());\n                    errorAppend(err);\n                    errorNewline();\n                    continue;\n                }\n                if (module.getVersion() == null || module.getVersion().isEmpty()) {\n                    outputVersions(module, versions);\n                } else {\n                    outputDetails(module, versions.iterator().next());\n                }\n            }\n        }\n    }","id":81054,"modified_method":"@Override\n    public void run() throws Exception {\n        setSystemProperties();\n        if (!showIncompatible) {\n            binaryMajor = Versions.JVM_BINARY_MAJOR_VERSION;\n            binaryMinor = Versions.JVM_BINARY_MINOR_VERSION;\n        }\n        for (ModuleSpec module : modules) {\n            String name = module.getName();\n            if (!module.isVersioned() && (name.startsWith(\"*\") || name.endsWith(\"*\"))) {\n                Collection<ModuleDetails> modules = getModules(name, queryType, binaryMajor, binaryMinor, findMember);\n                if (modules.isEmpty()) {\n                    String err = getModuleNotFoundErrorMessage(getRepositoryManager(), module.getName(), module.getVersion());\n                    errorAppend(err);\n                    errorNewline();\n                    continue;\n                }\n                outputModules(module, modules);\n            } else {\n                Collection<ModuleVersionDetails> versions = getModuleVersions(module.getName(), module.getVersion(), queryType, binaryMajor, binaryMinor, findMember);\n                if (versions.isEmpty()) {\n                    String err = getModuleNotFoundErrorMessage(getRepositoryManager(), module.getName(), module.getVersion());\n                    errorAppend(err);\n                    errorNewline();\n                    continue;\n                }\n                if (module.getVersion() == null || module.getVersion().isEmpty()) {\n                    outputVersions(module, versions);\n                } else {\n                    outputDetails(module, versions.iterator().next());\n                }\n            }\n        }\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private Collection<ModuleDetails> getModules(String name, ModuleQuery.Type type, Integer binaryMajor, Integer binaryMinor) {\n        return getModules(getRepositoryManager(), name, type, binaryMajor, binaryMinor);\n    }","id":81055,"modified_method":"private Collection<ModuleDetails> getModules(String name, ModuleQuery.Type type, Integer binaryMajor, Integer binaryMinor, String memberName) {\n        return getModules(getRepositoryManager(), name, type, binaryMajor, binaryMinor, memberName);\n    }","commit_id":"13869b8456dff16c80cf24e3356be75398476413","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void outputVersion(ModuleVersionDetails version) throws IOException {\n        msg(\"module.version\").append(version.getVersion()).newline();\n        msg(\"module.description\").append(version.getDoc()).newline();\n        msg(\"module.license\").append(version.getLicense()).newline();\n        // XXX info about artifacts (e.g. src, car, js, etc) and/or supports JVM/JS?\n        \n        msg(\"module.dependencies\", (depth == INFINITE_DEPTH ? \"\" : String.valueOf(depth))).newline();\n        \n        int depth = 0;\n        recurseDependencies(version, depth);\n    }","id":81056,"modified_method":"private void outputVersion(ModuleVersionDetails version) throws IOException {\n        msg(\"module.version\").append(version.getVersion()).newline();\n        outputArtifacts(version.getArtifactTypes());\n        msg(\"module.available\").append((version.isRemote() ? \"No\" : \"Yes\")).newline();\n        if (version.getOrigin() != null) {\n            msg(\"module.origin\").append(version.getOrigin()).newline();\n        }\n        if (version.getDoc() != null) {\n            msg(\"module.description\").append(version.getDoc()).newline();\n        }\n        if (version.getLicense() != null) {\n            msg(\"module.license\").append(version.getLicense()).newline();\n        }\n        if (!version.getDependencies().isEmpty()) {\n            msg(\"module.dependencies\", (depth == INFINITE_DEPTH ? \"\" : String.valueOf(depth))).newline();\n            recurseDependencies(version, 0);\n        }\n    }","commit_id":"ecd8808c306e1c0694edfe84ffa7d30778604195","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void run() throws Exception {\n        for (ModuleSpec module : modules) {\n            // TODO Figure out how to use Type.ALL instead of Type.JVM\n            Collection<ModuleVersionDetails> versions = getModuleVersions(module.getName(), module.getVersion(), ModuleQuery.Type.JVM, null);\n            if (versions.isEmpty()) {\n                errorMsg(\"module.not.found\", module, getRepositoryManager().getRepositoriesDisplayString());\n                continue;\n            }\n            outputModuleVersions(module, versions);\n        }\n    }","id":81057,"modified_method":"@Override\n    public void run() throws Exception {\n        for (ModuleSpec module : modules) {\n            // TODO Figure out how to use Type.ALL instead of Type.JVM\n            Collection<ModuleVersionDetails> versions = getModuleVersions(module.getName(), module.getVersion(), ModuleQuery.Type.ALL, null);\n            if (versions.isEmpty()) {\n                errorMsg(\"module.not.found\", module, getRepositoryManager().getRepositoriesDisplayString());\n                continue;\n            }\n            outputModuleVersions(module, versions);\n        }\n    }","commit_id":"ecd8808c306e1c0694edfe84ffa7d30778604195","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public Object invoke(Exchange exchange, Object o) {\n        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);\n        MethodDispatcher md = (MethodDispatcher) \n            exchange.get(Service.class).get(MethodDispatcher.class.getName());\n        Method m = md.getMethod(bop);\n        \n        List<Object> params = null;\n        if (o instanceof List) {\n            params = CastUtils.cast((List<?>)o);\n        } else if (o != null) {\n            params = new MessageContentsList(o);\n        }\n        \n        final List<Object> messageBody = new ArrayList<Object>(params.size()+1);\n        messageBody.add(m.getName());\n        for (Object obj: params) {\n            messageBody.add(obj);\n        }  \n        \n        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();\n        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());\n        cxfExchange.getIn().setBody(messageBody);\n        \n        \n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception e) {\n            // catch the exception and send back to cxf client\n            e.printStackTrace();\n        }\n        System.out.println(cxfExchange.getOut().getBody());\n        //TODO deal with the paraments that contains holders\n        Object[] result = (Object[])cxfExchange.getOut().getBody();\n        return result;\n        \n    }","id":81058,"modified_method":"/**\n     * This method is called when the incoming pojo invocation is called\n     * from the service invocation interceptor. The return value is the response\n     * from the processor\n     * @param inMessage\n     * @return outMessage\n     */\n    public Object invoke(Exchange exchange, Object o) {\n        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);\n        MethodDispatcher md = (MethodDispatcher) \n            exchange.get(Service.class).get(MethodDispatcher.class.getName());\n        Method m = md.getMethod(bop);\n        \n        List<Object> params = null;\n        if (o instanceof List) {\n            params = CastUtils.cast((List<?>)o);\n        } else if (o != null) {\n            params = new MessageContentsList(o);\n        }\n        \n        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();\n        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());\n        cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, m.getName());\n        cxfExchange.getIn().setBody(params);\n        \n        \n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception e) {\n            // catch the exception and send back to cxf client\n            e.printStackTrace();\n        }\n        //System.out.println(cxfExchange.getOut().getBody());\n        //TODO deal with the paraments that contains holders\n        //TODO deal with the fault message\n        Object[] result = (Object[])cxfExchange.getOut().getBody();\n        return result;\n        \n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public MessageImpl createCxfMessage(CxfExchange exchange) {\n        MessageImpl answer = (MessageImpl) exchange.getInMessage();\n\n        // CXF uses the stax which is based on the stream API to parser the XML, so\n        // the CXF transport is also based on the stream API.\n        // And the interceptors are also based on the stream API,\n        // so lets use an InputStream to host the CXF on wire message.\n\n        CxfMessage in = exchange.getIn();\n        Object body = in.getBody(InputStream.class);\n        if (body == null) {\n            body = in.getBody();\n        }\n        if (body instanceof InputStream) {\n        \tanswer.setContent(InputStream.class, body);\n        } else if (body instanceof List) {\n        \t//just set the operation's parament\n        \tanswer.setContent(List.class, body);\n        }\n        \n        \n        return answer;\n    }","id":81059,"modified_method":"public Message createCxfMessage(CxfExchange exchange) {\n        Message answer = exchange.getInMessage();\n\n        // CXF uses the stax which is based on the stream API to parser the XML, so\n        // the CXF transport is also based on the stream API.\n        // And the interceptors are also based on the stream API,\n        // so lets use an InputStream to host the CXF on wire message.\n\n        CxfMessage in = exchange.getIn();\n        Object body = in.getBody(InputStream.class);\n        if (body == null) {\n            body = in.getBody();\n        }\n        if (body instanceof InputStream) {\n        \tanswer.setContent(InputStream.class, body);\n                // we need copy context \n        } else if (body instanceof List) {\n        \t//just set the operation's parament\n        \tanswer.setContent(List.class, body);\n                //just set the method name\n                answer.setContent(String.class, in.getHeader(CxfConstants.OPERATION_NAME));\n        }\n        \n        \n        return answer;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"protected Object getBody(Message message) {\n        Set<Class<?>> contentFormats = message.getContentFormats();\n        for (Class<?> contentFormat : contentFormats) {            \n            Object answer = message.getContent(contentFormat);\n            if (answer != null) {\n                return answer;\n            }\n        }\n        return null;\n    }","id":81060,"modified_method":"protected Object getBody(Message message) {\n        Set<Class<?>> contentFormats = message.getContentFormats();\n        if (contentFormats != null) {\n            for (Class<?> contentFormat : contentFormats) {            \n                Object answer = message.getContent(contentFormat);\n                if (answer != null) {\n                    return answer;\n                }\n            }\n        }    \n        return null;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws ClassNotFoundException {\n       \n        super(endpoint, processor);\n        System.out.println(processor.toString());\n        this.endpoint = endpoint;\n        //we setup the interceptors by the endpoint configuration\n        //create server here, now we just use the simple front-end        \n        ServerFactoryBean svrBean = new ServerFactoryBean();\n        Class serviceClass = Class.forName(endpoint.getServiceClass());        \n        svrBean.setAddress(endpoint.getAddress());\n        svrBean.setServiceClass(serviceClass);\n        if (endpoint.isInvoker()) {\n            System.out.println(\"setup the invoker \");\n            svrBean.setInvoker(new CamelInvoker(this));\n        }    \n        svrBean.setStart(false);\n        server = svrBean.create();\n    }","id":81061,"modified_method":"public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {\n       \n        super(endpoint, processor);        \n        this.endpoint = endpoint;\n        try {\n            // now we just use the default bus here   \n            Bus bus = BusFactory.getDefaultBus();\n            Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass()); \n            ServerFactoryBean svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);                           \n            svrBean.setAddress(endpoint.getAddress());\n            svrBean.setServiceClass(serviceClass);\n            if (endpoint.getWsdlURL() != null) {                \n                svrBean.setWsdlURL(endpoint.getWsdlURL());\n            }\n            DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n            if (dataFormat.equals(DataFormat.POJO)) {\n                svrBean.setInvoker(new CamelInvoker(this));\n            }\n            svrBean.setBus(bus);\n            svrBean.setStart(false);\n            server = svrBean.create();            \n            if (!dataFormat.equals(DataFormat.POJO)) {\n                CxfMessageObserver observer = new CxfMessageObserver(this, server.getEndpoint(), bus , dataFormat);\n                //set the message observer for the Message and PayLoad mode message \n                ServerImpl serverImpl = (ServerImpl)server;\n                serverImpl.setMessageObserver(observer);\n            } \n            \n        } catch (Exception ex) {\n            \n        }\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public QName getServiceName() {\n        return serviceName;\n    }","id":81062,"modified_method":"public String getServiceName() {\n        return serviceName;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public void setPortName(QName port) {\n        portName = port;\n    }","id":81063,"modified_method":"public void setPortName(String port) {\n        portName = port;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public QName getPortName(){\n        return portName;\n    }","id":81064,"modified_method":"public String getPortName(){\n        return portName;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public void setServiceName(QName service) {\n        serviceName = service;\n    }","id":81065,"modified_method":"public void setServiceName(String service) {\n        serviceName = service;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public CxfExchange(CamelContext context, CxfBinding binding, Exchange exchange) {\n        super(context);\n        this.binding = binding;\n        this.exchange = exchange;\n\n        setIn(new CxfMessage(exchange.getInMessage()));\n        setOut(new CxfMessage(exchange.getOutMessage()));\n        setFault(new CxfMessage(exchange.getInFaultMessage()));\n    }","id":81066,"modified_method":"public CxfExchange(CamelContext context, CxfBinding binding, Exchange exchange) {\n        super(context);\n        this.binding = binding;\n        this.exchange = exchange;\n\n        setIn(new CxfMessage(exchange.getInMessage()));\n        setOut(new CxfMessage(exchange.getOutMessage()));\n        if (exchange.getInFaultMessage() != null) {\n            setFault(new CxfMessage(exchange.getInFaultMessage()));\n        }    \n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public CxfExchange(CamelContext context, ExchangePattern pattern, CxfBinding binding, Message inMessage) {\n        this(context, pattern, binding);\n        this.exchange = inMessage.getExchange();\n\n        setIn(new CxfMessage(inMessage));\n        if (exchange != null) {\n            setOut(new CxfMessage(exchange.getOutMessage()));\n            setFault(new CxfMessage(exchange.getInFaultMessage()));\n        }\n    }","id":81067,"modified_method":"public CxfExchange(CamelContext context, ExchangePattern pattern, CxfBinding binding, Message inMessage) {\n        this(context, pattern, binding);\n        this.exchange = inMessage.getExchange();\n\n        setIn(new CxfMessage(inMessage));\n        if (exchange != null) {\n            setOut(new CxfMessage(exchange.getOutMessage()));\n            if (exchange.getInFaultMessage() != null) {\n                setFault(new CxfMessage(exchange.getInFaultMessage()));\n            }    \n        }\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public CxfMessage(Message cxfMessage) {\n        this.cxfMessage = cxfMessage;\n    }","id":81068,"modified_method":"public CxfMessage(Message cxfMessage) {\n        if (cxfMessage == null) {\n            this.cxfMessage = new MessageImpl();\n        }\n        this.cxfMessage = cxfMessage;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public void process(CxfExchange exchange) {\n        try {\n            CxfBinding binding = endpoint.getBinding();\n            MessageImpl m = binding.createCxfMessage(exchange);\n            //InputStream is = m.getContent(InputStream.class);\n            // now we just deal with the POJO invocations \n            List paraments = m.getContent(List.class);\n            Message response = new MessageImpl();            \n            if (paraments != null) {\n            \tString operation = (String)paraments.get(0);\n            \tObject[] args = new Object[paraments.size()-1];\n            \tfor(int i = 0 ; i < paraments.size()-1 ; i++) {            \t\t\n            \t\targs[i] = paraments.get(i+1);\n            \t}\n            \t// now we just deal with the invoking the paraments\n            \tObject[] result = client.invoke(operation, args);                \n            \tresponse.setContent(Object[].class, result);\n                binding.storeCxfResponse(exchange, response);\n            }          \t\n            \n        } catch (Exception e) {\n            throw new RuntimeCamelException(e);\n        }   \n                \n    }","id":81069,"modified_method":"public void process(CxfExchange exchange) {\n        CxfBinding cxfBinding = endpoint.getBinding();\n        Message inMessage = cxfBinding.createCxfMessage(exchange);\n        try {\n            if (dataFormat.equals(DataFormat.POJO)) {\n                //InputStream is = m.getContent(InputStream.class);\n                // now we just deal with the POJO invocations \n                List paraments = inMessage.getContent(List.class);\n                String operation = inMessage.getContent(String.class);\n                Message response = new MessageImpl();            \n                if (operation != null && paraments != null) {                \n                  \t// now we just deal with the invoking the paraments\n                  \tObject[] result = client.invoke(operation, paraments.toArray());                \n                   \tresponse.setContent(Object[].class, result);\n                    cxfBinding.storeCxfResponse(exchange, response);\n                }  \n            } else {\n                // get the invocation context\n                org.apache.cxf.message.Exchange ex = exchange.getExchange();\n                InvokingContext invokingContext = ex.get(InvokingContext.class);\n                Object params = invokingContext.getRequestContent(inMessage);\n                // invoke the stream message with the exchange context\n                CxfClient cxfClient = (CxfClient) client;\n                // invoke the message\n                //TODO need setup the call context here\n                //TODO need to handle the one way message\n                Object result = cxfClient.dispatch(params, null, ex);\n                System.out.println(\"the result object is \" + result);\n                // need to get the binding object to create the message\n                BindingOperationInfo boi = ex.get(BindingOperationInfo.class);\n                Message response = null;\n                System.out.println(\"the boi is \" + boi);\n                if (boi == null) {\n                    // it should be the raw message                    \n                    response = new MessageImpl(); \n                } else {\n                    // create the message here\n                    Endpoint ep = ex.get(Endpoint.class);                    \n                    response = ep.getBinding().createMessage();\n                }                \n                response.setExchange(ex);\n                ex.setOutMessage(response);                \n                invokingContext.setResponseContent(response, result);\n                cxfBinding.storeCxfResponse(exchange, response);\n            }\n        } catch (Exception e) {\n            //TODO add the falut message handling work\n            throw new RuntimeCamelException(e);\n        }     \n                \n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n                \n        client = createClient();\n        conduit = client.getConduit();\n        \n    }","id":81070,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart(); \n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public CxfProducer(CxfEndpoint endpoint) throws MalformedURLException {\n        super(endpoint);\n        this.endpoint = endpoint;\n        client = createClient();\n    }","id":81071,"modified_method":"public CxfProducer(CxfEndpoint endpoint) throws CamelException {\n        super(endpoint);\n        this.endpoint = endpoint;\n        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n        \n        if (dataFormat.equals(DataFormat.POJO)) {\n            client = createClientFormClientFactoryBean(null);\n        } else {\n            // create CxfClient for message\n            client = createClientForStreamMessge();           \n        }\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"private Client createClient() throws MalformedURLException {\n        Bus bus = BusFactory.getDefaultBus();\n        // setup the ClientFactoryBean with endpoint\n        ClientFactoryBean cfb = new ClientFactoryBean();\n        cfb.setBus(bus);\n        cfb.setAddress(endpoint.getAddress());\n        if (null != endpoint.getServiceClass()) {            \n            cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));\n        }\n        if (null != endpoint.getWsdlURL()) {\n            cfb.setWsdlURL(endpoint.getWsdlURL());\n        }       \n        // there may other setting work\n        // create client \n        return cfb.create();\n    }","id":81072,"modified_method":"private Client createClientForStreamMessge() throws CamelException {\n        ClientFactoryBean cfb = new CxfClientFactoryBean();\n        return createClientFormClientFactoryBean(cfb);\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n\n        // start a service\n        ServerFactoryBean svrBean = new ServerFactoryBean();\n\n        svrBean.setAddress(transportAddress);\n        svrBean.setServiceClass(HelloService.class);\n        svrBean.setServiceBean(new HelloServiceImpl());\n        svrBean.setBus(CXFBusFactory.getDefaultBus());\n\n        server = (ServerImpl)svrBean.create();\n        server.start();\n    }","id":81073,"modified_method":"@Override\n    protected void setUp() throws Exception {\n\n        // start a simple front service\n        ServerFactoryBean svrBean = new ServerFactoryBean();\n        svrBean.setAddress(SIMPLE_SERVER_ADDRESS);\n        svrBean.setServiceClass(HelloService.class);\n        svrBean.setServiceBean(new HelloServiceImpl());\n        svrBean.setBus(CXFBusFactory.getDefaultBus());\n\n        simpleServer = (ServerImpl)svrBean.create();\n        simpleServer.start();\n        \n        GreeterImpl greeterImpl = new GreeterImpl();\n        jaxwsEndpoint = Endpoint.publish(JAXWS_SERVER_ADDRESS, greeterImpl);\n                \n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void tearDown() throws Exception {\n        if (server != null) {\n            server.stop();\n        }\n    }","id":81074,"modified_method":"@Override\n    protected void tearDown() throws Exception {\n        if (simpleServer != null) {\n            simpleServer.stop();\n        }\n        if (jaxwsEndpoint != null) {\n            jaxwsEndpoint.stop();\n        }\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public void testInvokingServerWithParams() throws Exception {    \t\n\n        CxfExchange exchange = (CxfExchange)template.send(getUri(), new Processor() {\n            public void process(final Exchange exchange) {\n                final List<String> params = new ArrayList<String>();\n                params.add(operation);\n                params.add(testMessage);\n                exchange.getIn().setBody(params);\n            }\n        });\n       \n        org.apache.camel.Message out = exchange.getOut();\n        Object[] output = (Object[])out.getBody();\n        LOG.info(\"Received output text: \" + output[0]);\n        assertEquals(\"reply body on Camel\", testMessage, output[0]);\n    }","id":81075,"modified_method":"public void testInvokingSimpleServerWithParams() throws Exception {    \t\n\n        CxfExchange exchange = (CxfExchange)template.send(getSimpleEndpointUri(), new Processor() {\n            public void process(final Exchange exchange) {\n                final List<String> params = new ArrayList<String>();                \n                params.add(TEST_MESSAGE);\n                exchange.getIn().setBody(params);\n                exchange.getIn().setHeader(CxfConstants.OPERATION_NAME, ECHO_OPERATION);\n            }\n        });\n       \n        org.apache.camel.Message out = exchange.getOut();\n        Object[] output = (Object[])out.getBody();\n        LOG.info(\"Received output text: \" + output[0]);\n        assertEquals(\"reply body on Camel\", TEST_MESSAGE, output[0]);\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"public String echo(String text) {        \n        return text;\n    }","id":81076,"modified_method":"public String echo(String text) {        \n        System.out.println(\"call for echo with \" + text);\n        return text;\n    }","commit_id":"64a4b6aa85a599505008fab00a8c498323469787","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a payload object with the information from the given exchange.\n     *\n     * @param exchange the exchange\n     * @param includeProperties whether or not to include exchange properties\n     * @return the holder object with information copied form the exchange\n     */\n    public static DefaultExchangeHolder marshal(Exchange exchange, boolean includeProperties) {\n        // we do not support files\n        Object body = exchange.getIn().getBody();\n        if (body instanceof WrappedFile || body instanceof File) {\n            throw new RuntimeExchangeException(\"Message body of type \" + body.getClass().getCanonicalName() + \" is not supported by this marshaller.\", exchange);\n        }\n\n        DefaultExchangeHolder payload = new DefaultExchangeHolder();\n\n        payload.exchangeId = exchange.getExchangeId();\n        payload.inBody = checkSerializableBody(\"in body\", exchange, exchange.getIn().getBody());\n        payload.safeSetInHeaders(exchange);\n        if (exchange.hasOut()) {\n            payload.outBody = checkSerializableBody(\"out body\", exchange, exchange.getOut().getBody());\n            payload.outFaultFlag = exchange.getOut().isFault();\n            payload.safeSetOutHeaders(exchange);\n        }\n        if (includeProperties) {\n            payload.safeSetProperties(exchange);\n        }\n        payload.exception = exchange.getException();\n\n        return payload;\n    }","id":81077,"modified_method":"/**\n     * Creates a payload object with the information from the given exchange.\n     *\n     * @param exchange the exchange, must <b>not<\/b> be <tt>null<\/tt>\n     * @param includeProperties whether or not to include exchange properties\n     * @return the holder object with information copied form the exchange\n     */\n    public static DefaultExchangeHolder marshal(Exchange exchange, boolean includeProperties) {\n        ObjectHelper.notNull(exchange, \"exchange\");\n\n        // we do not support files\n        Object body = exchange.getIn().getBody();\n        if (body instanceof WrappedFile || body instanceof File) {\n            throw new RuntimeExchangeException(\"Message body of type \" + body.getClass().getCanonicalName() + \" is not supported by this marshaller.\", exchange);\n        }\n\n        DefaultExchangeHolder payload = new DefaultExchangeHolder();\n\n        payload.exchangeId = exchange.getExchangeId();\n        payload.inBody = checkSerializableBody(\"in body\", exchange, exchange.getIn().getBody());\n        payload.safeSetInHeaders(exchange);\n        if (exchange.hasOut()) {\n            payload.outBody = checkSerializableBody(\"out body\", exchange, exchange.getOut().getBody());\n            payload.outFaultFlag = exchange.getOut().isFault();\n            payload.safeSetOutHeaders(exchange);\n        }\n        if (includeProperties) {\n            payload.safeSetProperties(exchange);\n        }\n        payload.exception = exchange.getException();\n\n        return payload;\n    }","commit_id":"7edd77c02efd97dd147466ddc3e63231cc9e687f","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Transfers the information from the payload to the exchange.\n     *\n     * @param exchange the exchange to set values from the payload\n     * @param payload  the payload with the values\n     */\n    public static void unmarshal(Exchange exchange, DefaultExchangeHolder payload) {\n        exchange.setExchangeId(payload.exchangeId);\n        exchange.getIn().setBody(payload.inBody);\n        if (payload.inHeaders != null) {\n            exchange.getIn().setHeaders(payload.inHeaders);\n        }\n        if (payload.outBody != null) {\n            exchange.getOut().setBody(payload.outBody);\n            if (payload.outHeaders != null) {\n                exchange.getOut().setHeaders(payload.outHeaders);\n            }\n            exchange.getOut().setFault(payload.outFaultFlag.booleanValue());\n        }\n        if (payload.properties != null) {\n            for (String key : payload.properties.keySet()) {\n                exchange.setProperty(key, payload.properties.get(key));\n            }\n        }\n        exchange.setException(payload.exception);\n    }","id":81078,"modified_method":"/**\n     * Transfers the information from the payload to the exchange.\n     *\n     * @param exchange the exchange to set values from the payload, must <b>not<\/b> be <tt>null<\/tt>\n     * @param payload  the payload with the values, must <b>not<\/b> be <tt>null<\/tt>\n     */\n    public static void unmarshal(Exchange exchange, DefaultExchangeHolder payload) {\n        ObjectHelper.notNull(exchange, \"exchange\");\n        ObjectHelper.notNull(payload, \"payload\");\n\n        exchange.setExchangeId(payload.exchangeId);\n        exchange.getIn().setBody(payload.inBody);\n        if (payload.inHeaders != null) {\n            exchange.getIn().setHeaders(payload.inHeaders);\n        }\n        if (payload.outBody != null) {\n            exchange.getOut().setBody(payload.outBody);\n            if (payload.outHeaders != null) {\n                exchange.getOut().setHeaders(payload.outHeaders);\n            }\n            if (payload.outFaultFlag != null) {\n                exchange.getOut().setFault(payload.outFaultFlag);\n            }\n        }\n        if (payload.properties != null) {\n            for (String key : payload.properties.keySet()) {\n                exchange.setProperty(key, payload.properties.get(key));\n            }\n        }\n        exchange.setException(payload.exception);\n    }","commit_id":"7edd77c02efd97dd147466ddc3e63231cc9e687f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n\tpublic void config(String name,\n\t\t\tfinal OServerParameterConfiguration[] iParameters) {\n\n\t\tsuper.config(name, iParameters);\n\t\tfor (OServerParameterConfiguration param : iParameters) {\n\t\t\tif (param.name.equalsIgnoreCase(PARAM_NETWORK_SSL_CLIENT_AUTH)) {\n\t\t\t\tclientAuth = Boolean.parseBoolean(param.value);\n\t\t\t} else if (param.name.equalsIgnoreCase(PARAM_NETWORK_SSL_KEYSTORE)) {\n\t\t\t\tkeyStorePath = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_KEYSTORE_PASSWORD)) {\n\t\t\t\tkeyStorePassword = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_KEYSTORE_TYPE)) {\n\t\t\t\tkeyStoreType = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_TRUSTSTORE)) {\n\t\t\t\ttrustStorePath = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_TRUSTSTORE_PASSWORD)) {\n\t\t\t\ttrustStorePassword = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_TRUSTSTORE_TYPE)) {\n\t\t\t\ttrustStoreType = param.value;\n\t\t\t}\n\t\t}\n\n\t\tif (keyStorePath == null) {\n\t\t\tthrow new OConfigurationException(\"Missing parameter \"\n\t\t\t\t\t+ PARAM_NETWORK_SSL_KEYSTORE);\n\t\t} else if (keyStorePassword == null) {\n\t\t\tthrow new OConfigurationException(\"Missing parameter \"\n\t\t\t\t\t+ PARAM_NETWORK_SSL_KEYSTORE_PASSWORD);\n\t\t} else if (trustStorePath == null) {\n\t\t\tthrow new OConfigurationException(\"Missing parameter \"\n\t\t\t\t\t+ PARAM_NETWORK_SSL_TRUSTSTORE);\n\t\t} else if (trustStorePassword == null) {\n\t\t\tthrow new OConfigurationException(\"Missing parameter \"\n\t\t\t\t\t+ PARAM_NETWORK_SSL_TRUSTSTORE_PASSWORD);\n\t\t}\n\n\t\tkeyStoreFile = new File(keyStorePath);\n\t\tif (!keyStoreFile.isAbsolute()) {\n\t\t\tkeyStoreFile = new File(\n\t\t\t\t\tOSystemVariableResolver\n\t\t\t\t\t\t\t.resolveSystemVariables(\"${ORIENTDB_HOME}\"),\n\t\t\t\t\tkeyStorePath);\n\t\t}\n\n\t\ttrustStoreFile = new File(trustStorePath);\n\t\tif (!trustStoreFile.isAbsolute()) {\n\t\t\ttrustStoreFile = new File(\n\t\t\t\t\tOSystemVariableResolver\n\t\t\t\t\t\t\t.resolveSystemVariables(\"${ORIENTDB_HOME}\"),\n\t\t\t\t\ttrustStorePath);\n\t\t}\n\t}","id":81079,"modified_method":"@Override\n\tpublic void config(String name,\n\t\t\tfinal OServerParameterConfiguration[] iParameters) {\n\n\t\tsuper.config(name, iParameters);\n\t\tfor (OServerParameterConfiguration param : iParameters) {\n\t\t\tif (param.name.equalsIgnoreCase(PARAM_NETWORK_SSL_CLIENT_AUTH)) {\n\t\t\t\tclientAuth = Boolean.parseBoolean(param.value);\n\t\t\t} else if (param.name.equalsIgnoreCase(PARAM_NETWORK_SSL_KEYSTORE)) {\n\t\t\t\tkeyStorePath = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_KEYSTORE_PASSWORD)) {\n\t\t\t\tkeyStorePassword = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_KEYSTORE_TYPE)) {\n\t\t\t\tkeyStoreType = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_TRUSTSTORE)) {\n\t\t\t\ttrustStorePath = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_TRUSTSTORE_PASSWORD)) {\n\t\t\t\ttrustStorePassword = param.value;\n\t\t\t} else if (param.name\n\t\t\t\t\t.equalsIgnoreCase(PARAM_NETWORK_SSL_TRUSTSTORE_TYPE)) {\n\t\t\t\ttrustStoreType = param.value;\n\t\t\t}\n\t\t}\n\n\t\tif (keyStorePath == null) {\n\t\t\tthrow new OConfigurationException(\"Missing parameter \"\n\t\t\t\t\t+ PARAM_NETWORK_SSL_KEYSTORE);\n\t\t} else if (keyStorePassword == null) {\n\t\t\tthrow new OConfigurationException(\"Missing parameter \"\n\t\t\t\t\t+ PARAM_NETWORK_SSL_KEYSTORE_PASSWORD);\n\t\t}\n\n\t\tkeyStoreFile = new File(keyStorePath);\n\t\tif (!keyStoreFile.isAbsolute()) {\n\t\t\tkeyStoreFile = new File(\n\t\t\t\t\tOSystemVariableResolver\n\t\t\t\t\t\t\t.resolveSystemVariables(\"${ORIENTDB_HOME}\"),\n\t\t\t\t\tkeyStorePath);\n\t\t}\n\n\t\tif (trustStorePath != null) {\n\t\t\ttrustStoreFile = new File(trustStorePath);\n\t\t\tif (!trustStoreFile.isAbsolute()) {\n\t\t\t\ttrustStoreFile = new File(\n\t\t\t\t\t\tOSystemVariableResolver\n\t\t\t\t\t\t\t\t.resolveSystemVariables(\"${ORIENTDB_HOME}\"),\n\t\t\t\t\t\ttrustStorePath);\n\t\t\t}\n\t\t}\n\t}","commit_id":"d9bf419c3f246c2f8b58ead1a172dc8578ea654a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected SSLContext getSSLContext() {\n\n\t\ttry {\n\t\t\tSSLContext context = SSLContext.getInstance(\"TLS\");\n\n\t\t\tKeyManagerFactory kmf = KeyManagerFactory\n\t\t\t\t\t.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n\t\t\tTrustManagerFactory tmf = TrustManagerFactory\n\t\t\t\t\t.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n\t\t\tKeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\t\t\tchar[] keyStorePass = keyStorePassword.toCharArray();\n\t\t\tkeyStore.load(new FileInputStream(keyStoreFile), keyStorePass);\n\n\t\t\tKeyStore trustStore = KeyStore.getInstance(trustStoreType);\n\t\t\tchar[] trustStorePass = trustStorePassword.toCharArray();\n\t\t\ttrustStore\n\t\t\t\t\t.load(new FileInputStream(trustStoreFile), trustStorePass);\n\n\t\t\tkmf.init(keyStore, keyStorePass);\n\t\t\ttmf.init(trustStore);\n\n\t\t\tcontext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n\n\t\t\treturn context;\n\t\t} catch (Exception e) {\n\t\t\tthrow new OConfigurationException(\"Failed to create SSL context\", e);\n\t\t}\n\t}","id":81080,"modified_method":"protected SSLContext getSSLContext() {\n\n\t\ttry {\n\t\t\tSSLContext context = SSLContext.getInstance(\"TLS\");\n\n\t\t\tKeyManagerFactory kmf = KeyManagerFactory\n\t\t\t\t\t.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n\n\t\t\tKeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\t\t\tchar[] keyStorePass = keyStorePassword.toCharArray();\n\t\t\tkeyStore.load(new FileInputStream(keyStoreFile), keyStorePass);\n\n\t\t\tkmf.init(keyStore, keyStorePass);\n\n\t\t\tTrustManagerFactory tmf = null;\n\t\t\tif (trustStoreFile != null) {\n\t\t\t\ttmf = TrustManagerFactory.getInstance(TrustManagerFactory\n\t\t\t\t\t\t.getDefaultAlgorithm());\n\t\t\t\tKeyStore trustStore = KeyStore.getInstance(trustStoreType);\n\t\t\t\tchar[] trustStorePass = trustStorePassword.toCharArray();\n\t\t\t\ttrustStore.load(new FileInputStream(trustStoreFile),\n\t\t\t\t\t\ttrustStorePass);\n\t\t\t\ttmf.init(trustStore);\n\t\t\t}\n\n\t\t\tcontext.init(kmf.getKeyManagers(),\n\t\t\t\t\t(tmf == null ? null : tmf.getTrustManagers()), null);\n\n\t\t\treturn context;\n\t\t} catch (Exception e) {\n\t\t\tthrow new OConfigurationException(\"Failed to create SSL context\", e);\n\t\t}\n\t}","commit_id":"d9bf419c3f246c2f8b58ead1a172dc8578ea654a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void setSSLContent(SSLContext context) {\n\t\tthis.context = context;\n\t\tsynchronized(socketFactory) {\n\t\t\tsocketFactory = null;\n\t\t}\n\t}","id":81081,"modified_method":"public void setSSLContext(SSLContext context) {\n\t\tthis.context = context;\n\t\tsynchronized(socketFactory) {\n\t\t\tsocketFactory = null;\n\t\t}\n\t}","commit_id":"d9bf419c3f246c2f8b58ead1a172dc8578ea654a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static OSocketFactory instance(final OContextConfiguration iConfig,\n\t\t\tSSLContext context) {\n\n\t\tOSocketFactory sFactory = instance(iConfig);\n\t\tsFactory.setSSLContent(context);\n\t\treturn sFactory;\n\t}","id":81082,"modified_method":"public static OSocketFactory instance(final OContextConfiguration iConfig,\n\t\t\tSSLContext context) {\n\n\t\tOSocketFactory sFactory = instance(iConfig);\n\t\tsFactory.setSSLContext(context);\n\t\treturn sFactory;\n\t}","commit_id":"d9bf419c3f246c2f8b58ead1a172dc8578ea654a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * This method assigns the various TLS parameters on the HttpsURLConnection\n     * from the TLS Client Parameters. Connection parameter is of supertype HttpURLConnection, \n     * which allows internal cast to potentially divergent subtype (https) implementations.\n     */\n    protected synchronized void decorateWithTLS(HttpURLConnection connection)\n        throws NoSuchAlgorithmException,\n               NoSuchProviderException,\n               KeyManagementException {\n\n        // First see if an SSLSocketFactory was set.  This allows easy interop\n        // with not-yet-commons-ssl.jar, or even just people who like doing their\n        // own JSSE.\n        if (socketFactory == null) {\n            SSLSocketFactory preSetFactory = tlsClientParameters.getSSLSocketFactory();\n            if (preSetFactory != null) {\n                socketFactory = preSetFactory;\n            }\n        }\n\n        // Okay, no SSLSocketFactory available in TLSClientParameters.  Maybe\n        // TrustManagers, KeyManagers, etc?\n        if (socketFactory == null) {\n            String provider = tlsClientParameters.getJsseProvider();\n            \n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null\n                      ? tlsClientParameters.getSecureSocketProtocol()\n                      : \"TLS\";\n                      \n            SSLContext ctx = provider == null\n                      ? SSLContext.getInstance(protocol)\n                      : SSLContext.getInstance(protocol, provider);\n            \n                      \n\n            TrustManager[] trustAllCerts = tlsClientParameters.getTrustManagers();\n            /*\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new javax.net.ssl.X509TrustManager() {\n                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                    public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                    }\n                    public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                    }\n                }\n            };\n            */         \n            ctx.init(\n                tlsClientParameters.getKeyManagers(),\n                trustAllCerts, \n                tlsClientParameters.getSecureRandom());\n            \n            // The \"false\" argument means opposite of exclude.\n            String[] cipherSuites =\n                SSLUtils.getCiphersuites(tlsClientParameters.getCipherSuites(),\n                                         SSLUtils.getSupportedCipherSuites(ctx),\n                                         tlsClientParameters.getCipherSuitesFilter(),\n                                         LOG, false);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(),\n                                                        cipherSuites,\n                                                        tlsClientParameters.getSecureSocketProtocol());\n        }\n        \n        HostnameVerifier verifier = tlsClientParameters.isDisableCNCheck() \n            ? CertificateHostnameVerifier.ALLOW_ALL : CertificateHostnameVerifier.DEFAULT;\n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's \n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n                \n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy, \n                                         Method method, \n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return true;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory =  connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The \n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    c.setAccessible(true);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                } \n                //if we cannot set the SSLSocketFactor, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \" \n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }","id":81083,"modified_method":"/**\n     * This method assigns the various TLS parameters on the HttpsURLConnection\n     * from the TLS Client Parameters. Connection parameter is of supertype HttpURLConnection, \n     * which allows internal cast to potentially divergent subtype (https) implementations.\n     */\n    protected synchronized void decorateWithTLS(HttpURLConnection connection)\n        throws GeneralSecurityException {\n\n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and \n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n            \n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n            \n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            String provider = tlsClientParameters.getJsseProvider();\n\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n\n            SSLContext ctx = provider == null ? SSLContext.getInstance(protocol) : SSLContext\n                .getInstance(protocol, provider);\n\n            ctx.init(tlsClientParameters.getKeyManagers(), tlsClientParameters.getTrustManagers(),\n                     tlsClientParameters.getSecureRandom());\n\n            // The \"false\" argument means opposite of exclude.\n            String[] cipherSuites = SSLUtils.getCiphersuites(tlsClientParameters.getCipherSuites(), SSLUtils\n                .getSupportedCipherSuites(ctx), tlsClientParameters.getCipherSuitesFilter(), LOG, false);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        tlsClientParameters.getSecureSocketProtocol());\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n        \n        \n        HostnameVerifier verifier;\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultHostnameVerifier()) {\n            verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n        } else if (tlsClientParameters.isDisableCNCheck()) {\n            verifier = CertificateHostnameVerifier.ALLOW_ALL;\n        } else {\n            verifier = CertificateHostnameVerifier.DEFAULT;\n        }\n        \n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's \n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n                \n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy, \n                                         Method method, \n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return true;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory =  connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The \n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    c.setAccessible(true);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                } \n                //if we cannot set the SSLSocketFactor, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \" \n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }","commit_id":"19bb44cb288462ef9122be6a697a8d74cef6ec69","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create a HttpURLConnection, proxified if necessary.\n     * \n     * \n     * @param proxy This parameter is non-null if connection should be proxied.\n     * @param url   The target URL. This parameter must be an https url.\n     * \n     * @return The HttpsURLConnection for the given URL.\n     * @throws IOException This exception is thrown if \n     *         the \"url\" is not \"https\" or other IOException\n     *         is thrown. \n     *                     \n     */\n    public HttpURLConnection createConnection(Proxy proxy, URL url)\n        throws IOException {\n\n        if (!url.getProtocol().equals(HTTPS_URL_PROTOCOL_ID)) {\n            throw new IOException(\"Illegal Protocol \" \n                    + url.getProtocol() \n                    + \" for HTTPS URLConnection Factory.\");\n        }\n        \n        HttpURLConnection connection =\n            (HttpURLConnection) (proxy != null \n                                   ? url.openConnection(proxy)\n                                   : url.openConnection());\n                                   \n        if (tlsClientParameters != null) {\n            Exception ex = null;\n            try {\n                decorateWithTLS(connection);\n            } catch (Exception e) {\n                ex = e;\n            } finally {\n                if (ex != null) {\n                    if (ex instanceof IOException) {\n                        throw (IOException) ex;\n                    }\n                    throw new IIOException(\"Error while initializing secure socket\", ex);\n                }\n            }\n        }\n\n        return connection;\n    }","id":81084,"modified_method":"/**\n     * Create a HttpURLConnection, proxified if necessary.\n     * \n     * \n     * @param proxy This parameter is non-null if connection should be proxied.\n     * @param url   The target URL. This parameter must be an https url.\n     * \n     * @return The HttpsURLConnection for the given URL.\n     * @throws IOException This exception is thrown if \n     *         the \"url\" is not \"https\" or other IOException\n     *         is thrown. \n     *                     \n     */\n    public HttpURLConnection createConnection(Proxy proxy, URL url)\n        throws IOException {\n\n        if (!url.getProtocol().equals(HTTPS_URL_PROTOCOL_ID)) {\n            throw new IOException(\"Illegal Protocol \" \n                    + url.getProtocol() \n                    + \" for HTTPS URLConnection Factory.\");\n        }\n        \n        HttpURLConnection connection =\n            (HttpURLConnection) (proxy != null \n                                   ? url.openConnection(proxy)\n                                   : url.openConnection());\n                                   \n        if (tlsClientParameters != null) {\n            Exception ex = null;\n            try {\n                decorateWithTLS(connection);\n            } catch (Exception e) {\n                ex = e;\n            } finally {\n                if (ex != null) {\n                    if (ex instanceof IOException) {\n                        throw (IOException) ex;\n                    }\n                    throw new IOException(\"Error while initializing secure socket\", ex);\n                }\n            }\n        }\n\n        return connection;\n    }","commit_id":"19bb44cb288462ef9122be6a697a8d74cef6ec69","url":"https://github.com/apache/cxf"},{"original_method":"static TLSClientParameters createTLSClientParametersFromType(TLSClientParametersType params) \n        throws GeneralSecurityException,\n               IOException {\n\n        TLSClientParameters ret = new TLSClientParameters();\n        if (params.isDisableCNCheck()) {\n            ret.setDisableCNCheck(true);\n        }\n        if (params.isSetSecureSocketProtocol()) {\n            ret.setSecureSocketProtocol(params.getSecureSocketProtocol());\n        }\n        if (params.isSetCipherSuitesFilter()) {\n            ret.setCipherSuitesFilter(params.getCipherSuitesFilter());\n        }\n        if (params.isSetCipherSuites()) {\n            ret.setCipherSuites(params.getCipherSuites().getCipherSuite());\n        }\n        if (params.isSetJsseProvider()) {\n            ret.setJsseProvider(params.getJsseProvider());\n        }\n        if (params.isSetSecureRandomParameters()) {\n            ret.setSecureRandom(\n                TLSParameterJaxBUtils.getSecureRandom(\n                        params.getSecureRandomParameters()));\n        }\n        if (params.isSetKeyManagers()) {\n            ret.setKeyManagers(\n                TLSParameterJaxBUtils.getKeyManagers(params.getKeyManagers()));\n        }\n        if (params.isSetTrustManagers()) {\n            ret.setTrustManagers(\n                TLSParameterJaxBUtils.getTrustManagers(\n                        params.getTrustManagers()));\n        }\n        if (params.isSetCertConstraints()) {\n            ret.setCertConstraints(params.getCertConstraints());\n        }\n        return ret;\n    }","id":81085,"modified_method":"static TLSClientParameters createTLSClientParametersFromType(TLSClientParametersType params) \n        throws GeneralSecurityException,\n               IOException {\n\n        TLSClientParameters ret = new TLSClientParameters();\n        if (params.isDisableCNCheck()) {\n            ret.setDisableCNCheck(true);\n        }\n        if (params.isUseHttpsURLConnectionDefaultHostnameVerifier()) {\n            ret.setUseHttpsURLConnectionDefaultHostnameVerifier(true);\n        }\n        if (params.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            ret.setUseHttpsURLConnectionDefaultSslSocketFactory(true);\n        }\n        if (params.isSetSecureSocketProtocol()) {\n            ret.setSecureSocketProtocol(params.getSecureSocketProtocol());\n        }\n        if (params.isSetCipherSuitesFilter()) {\n            ret.setCipherSuitesFilter(params.getCipherSuitesFilter());\n        }\n        if (params.isSetCipherSuites()) {\n            ret.setCipherSuites(params.getCipherSuites().getCipherSuite());\n        }\n        if (params.isSetJsseProvider()) {\n            ret.setJsseProvider(params.getJsseProvider());\n        }\n        if (params.isSetSecureRandomParameters()) {\n            ret.setSecureRandom(\n                TLSParameterJaxBUtils.getSecureRandom(\n                        params.getSecureRandomParameters()));\n        }\n        if (params.isSetKeyManagers()) {\n            ret.setKeyManagers(\n                TLSParameterJaxBUtils.getKeyManagers(params.getKeyManagers()));\n        }\n        if (params.isSetTrustManagers()) {\n            ret.setTrustManagers(\n                TLSParameterJaxBUtils.getTrustManagers(\n                        params.getTrustManagers()));\n        }\n        if (params.isSetCertConstraints()) {\n            ret.setCertConstraints(params.getCertConstraints());\n        }\n        return ret;\n    }","commit_id":"19bb44cb288462ef9122be6a697a8d74cef6ec69","url":"https://github.com/apache/cxf"},{"original_method":"public void init(Properties properties) throws Exception {\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        KeyStore ts = KeyStore.getInstance(\"JKS\");\n        String keyStorePassword = getProperty(properties, \"keyStorePassword\");\n        String keyStore = getProperty(properties, \"keyStore\");\n        if (keyStore == null || keyStorePassword == null) {\n            throw new RuntimeException(\"SSL is enabled but keyStore[Password] properties aren't set!\");\n        }\n        String trustStore = getProperty(properties, \"trustStore\", keyStore);\n        String trustStorePassword = getProperty(properties, \"trustStorePassword\", keyStorePassword);\n\n        String keyManagerAlgorithm = properties.getProperty(\"keyManagerAlgorithm\", KeyManagerFactory.getDefaultAlgorithm());\n        String trustManagerAlgorithm = properties.getProperty(\"trustManagerAlgorithm\", TrustManagerFactory.getDefaultAlgorithm());\n        String protocol = properties.getProperty(\"protocol\", \"TLS\");\n\n        final char[] keyStorePassPhrase = keyStorePassword.toCharArray();\n        loadKeyStore(ks, keyStorePassPhrase, keyStore);\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        kmf.init(ks, keyStorePassPhrase);\n\n        loadKeyStore(ts, trustStorePassword.toCharArray(), trustStore);\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        tmf.init(ts);\n\n        sslContext = SSLContext.getInstance(protocol);\n        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n    }","id":81086,"modified_method":"public void init(Properties properties) throws Exception {\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        KeyStore ts = KeyStore.getInstance(\"JKS\");\n\n        String keyStorePassword = getProperty(properties, \"keyStorePassword\");\n        String keyStore = getProperty(properties, \"keyStore\");\n        String trustStore = getProperty(properties, \"trustStore\", keyStore);\n        String trustStorePassword = getProperty(properties, \"trustStorePassword\", keyStorePassword);\n        String keyManagerAlgorithm = properties.getProperty(\"keyManagerAlgorithm\", KeyManagerFactory.getDefaultAlgorithm());\n        String trustManagerAlgorithm = properties.getProperty(\"trustManagerAlgorithm\", TrustManagerFactory.getDefaultAlgorithm());\n        String protocol = properties.getProperty(\"protocol\", \"TLS\");\n\n        KeyManager[] keyManagers = null;\n        if (keyStore != null) {\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            char[] passPhrase = keyStorePassword != null ? keyStorePassword.toCharArray() : null;\n            loadKeyStore(ks, passPhrase, keyStore);\n            kmf.init(ks, passPhrase);\n            keyManagers = kmf.getKeyManagers();\n        }\n\n        TrustManager[] trustManagers = null;\n        if (trustStore != null) {\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            char[] passPhrase = trustStorePassword != null ? trustStorePassword.toCharArray() : null;\n            loadKeyStore(ts, passPhrase, trustStore);\n            tmf.init(ts);\n            trustManagers = tmf.getTrustManagers();\n        }\n\n        sslContext = SSLContext.getInstance(protocol);\n        sslContext.init(keyManagers, trustManagers, null);\n    }","commit_id":"d18a16445fb5aca5f20d64c3f3b9bfa9accfa5f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    @Category(ProblematicTest.class)\n    public void test() throws IOException {\n        Properties props = TestKeyStoreUtil.createSslProperties();\n        Config cfg = new Config();\n        cfg.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);\n        cfg.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true).addMember(\"127.0.0.1\");\n        cfg.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));\n        final HazelcastInstance hz1 = Hazelcast.newHazelcastInstance(cfg);\n        final HazelcastInstance hz2 = Hazelcast.newHazelcastInstance(cfg);\n\n        ClientConfig config = new ClientConfig();\n        config.getNetworkConfig().addAddress(\"127.0.0.1\");\n        config.getNetworkConfig().setRedoOperation(true);\n        config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));\n\n\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(config);\n        IMap<Object, Object> clientMap = client.getMap(\"test\");\n\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            Assert.assertNull(clientMap.put(i, 2 * i + 1));\n        }\n\n        IMap<Object, Object> map = hz1.getMap(\"test\");\n        for (int i = 0; i < size; i++) {\n            assertEquals(2 * i + 1, map.get(i));\n        }\n    }","id":81087,"modified_method":"@Test\n    @Category(ProblematicTest.class)\n    public void test() throws IOException {\n        Properties serverSslProps = TestKeyStoreUtil.createSslProperties();\n        Config cfg = new Config();\n        cfg.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);\n        cfg.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true).addMember(\"127.0.0.1\");\n        cfg.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(serverSslProps));\n        final HazelcastInstance hz1 = Hazelcast.newHazelcastInstance(cfg);\n        final HazelcastInstance hz2 = Hazelcast.newHazelcastInstance(cfg);\n\n        Properties clientSslProps = TestKeyStoreUtil.createSslProperties();\n        // no need for keystore on client side\n        clientSslProps.remove(TestKeyStoreUtil.JAVAX_NET_SSL_KEY_STORE);\n        clientSslProps.remove(TestKeyStoreUtil.JAVAX_NET_SSL_KEY_STORE_PASSWORD);\n        ClientConfig config = new ClientConfig();\n        config.getNetworkConfig().addAddress(\"127.0.0.1\");\n        config.getNetworkConfig().setRedoOperation(true);\n        config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(clientSslProps));\n\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(config);\n        IMap<Object, Object> clientMap = client.getMap(\"test\");\n\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            Assert.assertNull(clientMap.put(i, 2 * i + 1));\n        }\n\n        IMap<Object, Object> map = hz1.getMap(\"test\");\n        for (int i = 0; i < size; i++) {\n            assertEquals(2 * i + 1, map.get(i));\n        }\n    }","commit_id":"d18a16445fb5aca5f20d64c3f3b9bfa9accfa5f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(timeout = 1000 * 60)\n    public void testSockets() throws Exception {\n        Properties props = TestKeyStoreUtil.createSslProperties();\n        ServerSocketChannel serverSocketChannel = null;\n        Socket socket = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 250;\n            BasicSSLContextFactory factory = new BasicSSLContextFactory();\n            factory.init(props);\n            final SSLContext context = factory.getSSLContext();\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.configureBlocking(true);\n            int port = 13131;\n            serverSocketChannel.socket().bind(new InetSocketAddress(port));\n\n            final ServerSocketChannel ssc = serverSocketChannel;\n            ex.execute(new Runnable() {\n                public void run() {\n                    SocketChannelWrapper socketChannel = null;\n                    try {\n                        socketChannel = new SSLSocketChannelWrapper(context, ssc.accept(), false);\n                        final CountDownLatch latch = new CountDownLatch(2);\n                        final BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(count);\n\n                        ex.execute(new ChannelReader(socketChannel, count, latch) {\n                            void processData(int i, int data) throws Exception {\n                                queue.add(data);\n                            }\n                        });\n                        ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                            int prepareData(int i) throws Exception {\n                                int data = queue.poll(30, TimeUnit.SECONDS);\n                                return data * 2 + 1;\n                            }\n                        });\n\n                        latch.await(2, TimeUnit.MINUTES);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    } finally {\n                        IOUtil.closeResource(socketChannel);\n                    }\n                }\n            });\n\n            javax.net.ssl.SSLSocketFactory socketFactory = context.getSocketFactory();\n            socket = socketFactory.createSocket();\n            socket.connect(new InetSocketAddress(port));\n\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n\n            for (int i = 0; i < count; i++) {\n                out.writeInt(i);\n                out.flush();\n                int k = in.readInt();\n                assertEquals(i * 2 + 1, k);\n            }\n        } finally {\n            ex.shutdownNow();\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                }\n            }\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","id":81088,"modified_method":"@Test(timeout = 1000 * 60)\n    public void testSockets() throws Exception {\n        ServerSocketChannel serverSocketChannel = null;\n        Socket socket = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 250;\n            serverSocketChannel = ServerSocketChannel.open();\n            ex.execute(new ServerSocketChannelProcessor(serverSocketChannel, count, ex));\n\n            SSLContext clientContext = createClientSslContext();\n            javax.net.ssl.SSLSocketFactory socketFactory = clientContext.getSocketFactory();\n            socket = socketFactory.createSocket();\n            socket.connect(new InetSocketAddress(PORT));\n\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n\n            for (int i = 0; i < count; i++) {\n                out.writeInt(i);\n                out.flush();\n                int k = in.readInt();\n                assertEquals(i * 2 + 1, k);\n            }\n        } finally {\n            ex.shutdownNow();\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                }\n            }\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","commit_id":"d18a16445fb5aca5f20d64c3f3b9bfa9accfa5f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(timeout = 1000 * 60)\n    public void testSocketChannels() throws Exception {\n        Properties props = TestKeyStoreUtil.createSslProperties();\n        ServerSocketChannel serverSocketChannel = null;\n        SocketChannelWrapper socketChannel = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 1000;\n            final int port = 13131;\n            BasicSSLContextFactory factory = new BasicSSLContextFactory();\n            factory.init(props);\n            final SSLContext context = factory.getSSLContext();\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.configureBlocking(true);\n            serverSocketChannel.socket().bind(new InetSocketAddress(port));\n\n            final ServerSocketChannel ssc = serverSocketChannel;\n            ex.execute(new Runnable() {\n                public void run() {\n                    SocketChannelWrapper socketChannel = null;\n                    try {\n                        socketChannel = new SSLSocketChannelWrapper(context, ssc.accept(), false);\n                        final CountDownLatch latch = new CountDownLatch(2);\n                        final BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(count);\n\n                        ex.execute(new ChannelReader(socketChannel, count, latch) {\n                            void processData(int i, int data) throws Exception {\n                                queue.add(data);\n                            }\n                        });\n                        ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                            int prepareData(int i) throws Exception {\n                                int data = queue.poll(30, TimeUnit.SECONDS);\n                                return data * 2 + 1;\n                            }\n                        });\n\n                        latch.await(2, TimeUnit.MINUTES);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    } finally {\n                        IOUtil.closeResource(socketChannel);\n                    }\n                }\n            });\n\n            final AtomicReference<Error> error = new AtomicReference<Error>();\n            socketChannel = new SSLSocketChannelWrapper(context, SocketChannel.open(), true);\n            socketChannel.connect(new InetSocketAddress(port));\n            final CountDownLatch latch = new CountDownLatch(2);\n\n            ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                int prepareData(int i) throws Exception {\n                    return i;\n                }\n            });\n\n            ex.execute(new ChannelReader(socketChannel, count, latch) {\n                void processData(int i, int data) throws Exception {\n                    try {\n                        assertEquals(i * 2 + 1, data);\n                    } catch (AssertionError e) {\n                        error.compareAndSet(null, e);\n                        throw e;\n                    }\n                }\n            });\n\n            latch.await(2, TimeUnit.MINUTES);\n\n            Error e = error.get();\n            if (e != null) {\n                throw e;\n            }\n        } finally {\n            ex.shutdownNow();\n            IOUtil.closeResource(socketChannel);\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","id":81089,"modified_method":"@Test(timeout = 1000 * 60)\n    public void testSocketChannels() throws Exception {\n        ServerSocketChannel serverSocketChannel = null;\n        SocketChannelWrapper socketChannel = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 1000;\n            serverSocketChannel = ServerSocketChannel.open();\n            ex.execute(new ServerSocketChannelProcessor(serverSocketChannel, count, ex));\n\n            final AtomicReference<Error> error = new AtomicReference<Error>();\n            SSLContext clientContext = createClientSslContext();\n            socketChannel = new SSLSocketChannelWrapper(clientContext, SocketChannel.open(), true);\n            socketChannel.connect(new InetSocketAddress(PORT));\n            final CountDownLatch latch = new CountDownLatch(2);\n\n            ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                int prepareData(int i) throws Exception {\n                    return i;\n                }\n            });\n\n            ex.execute(new ChannelReader(socketChannel, count, latch) {\n                void processData(int i, int data) throws Exception {\n                    try {\n                        assertEquals(i * 2 + 1, data);\n                    } catch (AssertionError e) {\n                        error.compareAndSet(null, e);\n                        throw e;\n                    }\n                }\n            });\n\n            latch.await(2, TimeUnit.MINUTES);\n\n            Error e = error.get();\n            if (e != null) {\n                throw e;\n            }\n        } finally {\n            ex.shutdownNow();\n            IOUtil.closeResource(socketChannel);\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","commit_id":"d18a16445fb5aca5f20d64c3f3b9bfa9accfa5f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static Properties createSslProperties() throws IOException {\n        Properties props = new Properties();\n        props.setProperty(\"javax.net.ssl.keyStore\", getKeyStoreFilePath());\n        props.setProperty(\"javax.net.ssl.trustStore\", getTrustStoreFilePath());\n        props.setProperty(\"javax.net.ssl.keyStorePassword\", \"123456\");\n        props.setProperty(\"javax.net.ssl.trustStorePassword\", \"123456\");\n        return props;\n    }","id":81090,"modified_method":"public static Properties createSslProperties() throws IOException {\n        Properties props = new Properties();\n        props.setProperty(JAVAX_NET_SSL_KEY_STORE, getKeyStoreFilePath());\n        props.setProperty(JAVAX_NET_SSL_TRUST_STORE, getTrustStoreFilePath());\n        props.setProperty(JAVAX_NET_SSL_KEY_STORE_PASSWORD, \"123456\");\n        props.setProperty(JAVAX_NET_SSL_TRUST_STORE_PASSWORD, \"123456\");\n        return props;\n    }","commit_id":"d18a16445fb5aca5f20d64c3f3b9bfa9accfa5f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static Optional<SSLOptions> getSSLOptions(Configuration conf)\n    {\n        Optional<String> truststorePath = getInputNativeSSLTruststorePath(conf);\n        Optional<String> keystorePath = getInputNativeSSLKeystorePath(conf);\n        Optional<String> truststorePassword = getInputNativeSSLTruststorePassword(conf);\n        Optional<String> keystorePassword = getInputNativeSSLKeystorePassword(conf);\n        Optional<String> cipherSuites = getInputNativeSSLCipherSuites(conf);\n        \n        if (truststorePath.isPresent() && keystorePath.isPresent() && truststorePassword.isPresent() && keystorePassword.isPresent())\n        {\n            SSLContext context;\n            try\n            {\n                context = getSSLContext(truststorePath.get(), truststorePassword.get(), keystorePath.get(), keystorePassword.get());\n            }\n            catch (UnrecoverableKeyException | KeyManagementException |\n                    NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            String[] css = SSLOptions.DEFAULT_SSL_CIPHER_SUITES;\n            if (cipherSuites.isPresent())\n                css = cipherSuites.get().split(\",\");\n            return Optional.of(new SSLOptions(context,css));\n        }\n        return Optional.absent();\n    }","id":81091,"modified_method":"public static Optional<SSLOptions> getSSLOptions(Configuration conf)\n    {\n        Optional<String> truststorePath = getInputNativeSSLTruststorePath(conf);\n        Optional<String> keystorePath = getInputNativeSSLKeystorePath(conf);\n        Optional<String> truststorePassword = getInputNativeSSLTruststorePassword(conf);\n        Optional<String> keystorePassword = getInputNativeSSLKeystorePassword(conf);\n        Optional<String> cipherSuites = getInputNativeSSLCipherSuites(conf);\n\n        if (truststorePath.isPresent())\n        {\n            SSLContext context;\n            try\n            {\n                context = getSSLContext(truststorePath, truststorePassword, keystorePath, keystorePassword);\n            }\n            catch (UnrecoverableKeyException | KeyManagementException |\n                    NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            String[] css = SSLOptions.DEFAULT_SSL_CIPHER_SUITES;\n            if (cipherSuites.isPresent())\n                css = cipherSuites.get().split(\",\");\n            return Optional.of(new SSLOptions(context,css));\n        }\n        return Optional.absent();\n    }","commit_id":"19b4b637ac79b5d53b9384bd95bed8e08b43f111","url":"https://github.com/apache/cassandra"},{"original_method":"private static SSLContext getSSLContext(String truststorePath, String truststorePassword, String keystorePath, String keystorePassword)\n            throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException, UnrecoverableKeyException, KeyManagementException\n    {\n        SSLContext ctx;\n        try (FileInputStream tsf = new FileInputStream(truststorePath); FileInputStream ksf = new FileInputStream(keystorePath))\n        {\n            ctx = SSLContext.getInstance(\"SSL\");\n\n            KeyStore ts = KeyStore.getInstance(\"JKS\");\n            ts.load(tsf, truststorePassword.toCharArray());\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(ts);\n\n            KeyStore ks = KeyStore.getInstance(\"JKS\");\n            ks.load(ksf, keystorePassword.toCharArray());\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(ks, keystorePassword.toCharArray());\n\n            ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());\n        }\n        return ctx;\n    }","id":81092,"modified_method":"private static SSLContext getSSLContext(Optional<String> truststorePath,\n                                            Optional<String> truststorePassword,\n                                            Optional<String> keystorePath,\n                                            Optional<String> keystorePassword)\n    throws NoSuchAlgorithmException,\n           KeyStoreException,\n           CertificateException,\n           IOException,\n           UnrecoverableKeyException,\n           KeyManagementException\n    {\n        SSLContext ctx = SSLContext.getInstance(\"SSL\");\n\n        TrustManagerFactory tmf = null;\n        if (truststorePath.isPresent())\n        {\n            try (FileInputStream tsf = new FileInputStream(truststorePath.get()))\n            {\n                KeyStore ts = KeyStore.getInstance(\"JKS\");\n                ts.load(tsf, truststorePassword.isPresent() ? truststorePassword.get().toCharArray() : null);\n                tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                tmf.init(ts);\n            }\n        }\n\n        KeyManagerFactory kmf = null;\n        if (keystorePath.isPresent())\n        {\n            try (FileInputStream ksf = new FileInputStream(keystorePath.get()))\n            {\n                KeyStore ks = KeyStore.getInstance(\"JKS\");\n                ks.load(ksf, keystorePassword.isPresent() ? keystorePassword.get().toCharArray() : null);\n                kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n                kmf.init(ks, keystorePassword.isPresent() ? keystorePassword.get().toCharArray() : null);\n            }\n        }\n\n        ctx.init(kmf != null ? kmf.getKeyManagers() : null,\n                 tmf != null ? tmf.getTrustManagers() : null,\n                 new SecureRandom());\n        return ctx;\n    }","commit_id":"19b4b637ac79b5d53b9384bd95bed8e08b43f111","url":"https://github.com/apache/cassandra"},{"original_method":"public void init(Properties properties) throws Exception {\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        KeyStore ts = KeyStore.getInstance(\"JKS\");\n        String keyStorePassword = getProperty(properties, \"keyStorePassword\");\n        String keyStore = getProperty(properties, \"keyStore\");\n        if (keyStore == null || keyStorePassword == null) {\n            throw new RuntimeException(\"SSL is enabled but keyStore[Password] properties aren't set!\");\n        }\n        String trustStore = getProperty(properties, \"trustStore\", keyStore);\n        String trustStorePassword = getProperty(properties, \"trustStorePassword\", keyStorePassword);\n\n        String keyManagerAlgorithm = properties.getProperty(\"keyManagerAlgorithm\", KeyManagerFactory.getDefaultAlgorithm());\n        String trustManagerAlgorithm = properties.getProperty(\"trustManagerAlgorithm\", TrustManagerFactory.getDefaultAlgorithm());\n        String protocol = properties.getProperty(\"protocol\", \"TLS\");\n\n        final char[] keyStorePassPhrase = keyStorePassword.toCharArray();\n        loadKeyStore(ks, keyStorePassPhrase, keyStore);\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        kmf.init(ks, keyStorePassPhrase);\n\n        loadKeyStore(ts, trustStorePassword.toCharArray(), trustStore);\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        tmf.init(ts);\n\n        sslContext = SSLContext.getInstance(protocol);\n        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n    }","id":81093,"modified_method":"public void init(Properties properties) throws Exception {\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        KeyStore ts = KeyStore.getInstance(\"JKS\");\n\n        String keyStorePassword = getProperty(properties, \"keyStorePassword\");\n        String keyStore = getProperty(properties, \"keyStore\");\n        String trustStore = getProperty(properties, \"trustStore\", keyStore);\n        String trustStorePassword = getProperty(properties, \"trustStorePassword\", keyStorePassword);\n        String keyManagerAlgorithm = properties.getProperty(\"keyManagerAlgorithm\", KeyManagerFactory.getDefaultAlgorithm());\n        String trustManagerAlgorithm = properties.getProperty(\"trustManagerAlgorithm\", TrustManagerFactory.getDefaultAlgorithm());\n        String protocol = properties.getProperty(\"protocol\", \"TLS\");\n\n        KeyManager[] keyManagers = null;\n        if (keyStore != null) {\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            char[] passPhrase = keyStorePassword != null ? keyStorePassword.toCharArray() : null;\n            loadKeyStore(ks, passPhrase, keyStore);\n            kmf.init(ks, passPhrase);\n            keyManagers = kmf.getKeyManagers();\n        }\n\n        TrustManager[] trustManagers = null;\n        if (trustStore != null) {\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            char[] passPhrase = trustStorePassword != null ? trustStorePassword.toCharArray() : null;\n            loadKeyStore(ts, passPhrase, trustStore);\n            tmf.init(ts);\n            trustManagers = tmf.getTrustManagers();\n        }\n\n        sslContext = SSLContext.getInstance(protocol);\n        sslContext.init(keyManagers, trustManagers, null);\n    }","commit_id":"4ddfbd28a06ce24f4d20c241c28df0225903eada","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void test() throws IOException {\n        Properties props = TestKeyStoreUtil.createSslProperties();\n        Config cfg = new Config();\n        cfg.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);\n        cfg.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true).addMember(\"127.0.0.1\");\n        cfg.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));\n        final HazelcastInstance hz1 = Hazelcast.newHazelcastInstance(cfg);\n        final HazelcastInstance hz2 = Hazelcast.newHazelcastInstance(cfg);\n\n        ClientConfig config = new ClientConfig();\n        config.getNetworkConfig().addAddress(\"127.0.0.1\");\n        config.getNetworkConfig().setRedoOperation(true);\n        config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));\n\n\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(config);\n        IMap<Object, Object> clientMap = client.getMap(\"test\");\n\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            Assert.assertNull(clientMap.put(i, 2 * i + 1));\n        }\n\n        IMap<Object, Object> map = hz1.getMap(\"test\");\n        for (int i = 0; i < size; i++) {\n            assertEquals(2 * i + 1, map.get(i));\n        }\n    }","id":81094,"modified_method":"@Test\n    public void test() throws IOException {\n        Properties serverSslProps = TestKeyStoreUtil.createSslProperties();\n        Config cfg = new Config();\n        cfg.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);\n        cfg.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true).addMember(\"127.0.0.1\");\n        cfg.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(serverSslProps));\n        final HazelcastInstance hz1 = Hazelcast.newHazelcastInstance(cfg);\n        final HazelcastInstance hz2 = Hazelcast.newHazelcastInstance(cfg);\n\n        Properties clientSslProps = TestKeyStoreUtil.createSslProperties();\n        // no need for keystore on client side\n        clientSslProps.remove(TestKeyStoreUtil.JAVAX_NET_SSL_KEY_STORE);\n        clientSslProps.remove(TestKeyStoreUtil.JAVAX_NET_SSL_KEY_STORE_PASSWORD);\n        ClientConfig config = new ClientConfig();\n        config.getNetworkConfig().addAddress(\"127.0.0.1\");\n        config.getNetworkConfig().setRedoOperation(true);\n        config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(clientSslProps));\n\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(config);\n        IMap<Object, Object> clientMap = client.getMap(\"test\");\n\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            Assert.assertNull(clientMap.put(i, 2 * i + 1));\n        }\n\n        IMap<Object, Object> map = hz1.getMap(\"test\");\n        for (int i = 0; i < size; i++) {\n            assertEquals(2 * i + 1, map.get(i));\n        }\n    }","commit_id":"4ddfbd28a06ce24f4d20c241c28df0225903eada","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(timeout = 1000 * 60)\n    public void testSockets() throws Exception {\n        Properties props = TestKeyStoreUtil.createSslProperties();\n        ServerSocketChannel serverSocketChannel = null;\n        Socket socket = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 250;\n            BasicSSLContextFactory factory = new BasicSSLContextFactory();\n            factory.init(props);\n            final SSLContext context = factory.getSSLContext();\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.configureBlocking(true);\n            int port = 13131;\n            serverSocketChannel.socket().bind(new InetSocketAddress(port));\n\n            final ServerSocketChannel ssc = serverSocketChannel;\n            ex.execute(new Runnable() {\n                public void run() {\n                    SocketChannelWrapper socketChannel = null;\n                    try {\n                        socketChannel = new SSLSocketChannelWrapper(context, ssc.accept(), false);\n                        final CountDownLatch latch = new CountDownLatch(2);\n                        final BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(count);\n\n                        ex.execute(new ChannelReader(socketChannel, count, latch) {\n                            void processData(int i, int data) throws Exception {\n                                queue.add(data);\n                            }\n                        });\n                        ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                            int prepareData(int i) throws Exception {\n                                int data = queue.poll(30, TimeUnit.SECONDS);\n                                return data * 2 + 1;\n                            }\n                        });\n\n                        latch.await(2, TimeUnit.MINUTES);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    } finally {\n                        IOUtil.closeResource(socketChannel);\n                    }\n                }\n            });\n\n            javax.net.ssl.SSLSocketFactory socketFactory = context.getSocketFactory();\n            socket = socketFactory.createSocket();\n            socket.connect(new InetSocketAddress(port));\n\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n\n            for (int i = 0; i < count; i++) {\n                out.writeInt(i);\n                out.flush();\n                int k = in.readInt();\n                assertEquals(i * 2 + 1, k);\n            }\n        } finally {\n            ex.shutdownNow();\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                }\n            }\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","id":81095,"modified_method":"@Test(timeout = 1000 * 60)\n    public void testSockets() throws Exception {\n        ServerSocketChannel serverSocketChannel = null;\n        Socket socket = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 250;\n            serverSocketChannel = ServerSocketChannel.open();\n            ex.execute(new ServerSocketChannelProcessor(serverSocketChannel, count, ex));\n\n            SSLContext clientContext = createClientSslContext();\n            javax.net.ssl.SSLSocketFactory socketFactory = clientContext.getSocketFactory();\n            socket = socketFactory.createSocket();\n            socket.connect(new InetSocketAddress(PORT));\n\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n\n            for (int i = 0; i < count; i++) {\n                out.writeInt(i);\n                out.flush();\n                int k = in.readInt();\n                assertEquals(i * 2 + 1, k);\n            }\n        } finally {\n            ex.shutdownNow();\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                }\n            }\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","commit_id":"4ddfbd28a06ce24f4d20c241c28df0225903eada","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(timeout = 1000 * 60)\n    public void testSocketChannels() throws Exception {\n        Properties props = TestKeyStoreUtil.createSslProperties();\n        ServerSocketChannel serverSocketChannel = null;\n        SocketChannelWrapper socketChannel = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 1000;\n            final int port = 13131;\n            BasicSSLContextFactory factory = new BasicSSLContextFactory();\n            factory.init(props);\n            final SSLContext context = factory.getSSLContext();\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.configureBlocking(true);\n            serverSocketChannel.socket().bind(new InetSocketAddress(port));\n\n            final ServerSocketChannel ssc = serverSocketChannel;\n            ex.execute(new Runnable() {\n                public void run() {\n                    SocketChannelWrapper socketChannel = null;\n                    try {\n                        socketChannel = new SSLSocketChannelWrapper(context, ssc.accept(), false);\n                        final CountDownLatch latch = new CountDownLatch(2);\n                        final BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(count);\n\n                        ex.execute(new ChannelReader(socketChannel, count, latch) {\n                            void processData(int i, int data) throws Exception {\n                                queue.add(data);\n                            }\n                        });\n                        ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                            int prepareData(int i) throws Exception {\n                                int data = queue.poll(30, TimeUnit.SECONDS);\n                                return data * 2 + 1;\n                            }\n                        });\n\n                        latch.await(2, TimeUnit.MINUTES);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    } finally {\n                        IOUtil.closeResource(socketChannel);\n                    }\n                }\n            });\n\n            final AtomicReference<Error> error = new AtomicReference<Error>();\n            socketChannel = new SSLSocketChannelWrapper(context, SocketChannel.open(), true);\n            socketChannel.connect(new InetSocketAddress(port));\n            final CountDownLatch latch = new CountDownLatch(2);\n\n            ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                int prepareData(int i) throws Exception {\n                    return i;\n                }\n            });\n\n            ex.execute(new ChannelReader(socketChannel, count, latch) {\n                void processData(int i, int data) throws Exception {\n                    try {\n                        assertEquals(i * 2 + 1, data);\n                    } catch (AssertionError e) {\n                        error.compareAndSet(null, e);\n                        throw e;\n                    }\n                }\n            });\n\n            latch.await(2, TimeUnit.MINUTES);\n\n            Error e = error.get();\n            if (e != null) {\n                throw e;\n            }\n        } finally {\n            ex.shutdownNow();\n            IOUtil.closeResource(socketChannel);\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","id":81096,"modified_method":"@Test(timeout = 1000 * 60)\n    public void testSocketChannels() throws Exception {\n        ServerSocketChannel serverSocketChannel = null;\n        SocketChannelWrapper socketChannel = null;\n        final ExecutorService ex = Executors.newCachedThreadPool();\n        try {\n            final int count = 1000;\n            serverSocketChannel = ServerSocketChannel.open();\n            ex.execute(new ServerSocketChannelProcessor(serverSocketChannel, count, ex));\n\n            final AtomicReference<Error> error = new AtomicReference<Error>();\n            SSLContext clientContext = createClientSslContext();\n            socketChannel = new SSLSocketChannelWrapper(clientContext, SocketChannel.open(), true);\n            socketChannel.connect(new InetSocketAddress(PORT));\n            final CountDownLatch latch = new CountDownLatch(2);\n\n            ex.execute(new ChannelWriter(socketChannel, count, latch) {\n                int prepareData(int i) throws Exception {\n                    return i;\n                }\n            });\n\n            ex.execute(new ChannelReader(socketChannel, count, latch) {\n                void processData(int i, int data) throws Exception {\n                    try {\n                        assertEquals(i * 2 + 1, data);\n                    } catch (AssertionError e) {\n                        error.compareAndSet(null, e);\n                        throw e;\n                    }\n                }\n            });\n\n            latch.await(2, TimeUnit.MINUTES);\n\n            Error e = error.get();\n            if (e != null) {\n                throw e;\n            }\n        } finally {\n            ex.shutdownNow();\n            IOUtil.closeResource(socketChannel);\n            IOUtil.closeResource(serverSocketChannel);\n        }\n    }","commit_id":"4ddfbd28a06ce24f4d20c241c28df0225903eada","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static Properties createSslProperties() throws IOException {\n        Properties props = new Properties();\n        props.setProperty(\"javax.net.ssl.keyStore\", getKeyStoreFilePath());\n        props.setProperty(\"javax.net.ssl.trustStore\", getTrustStoreFilePath());\n        props.setProperty(\"javax.net.ssl.keyStorePassword\", \"123456\");\n        props.setProperty(\"javax.net.ssl.trustStorePassword\", \"123456\");\n        return props;\n    }","id":81097,"modified_method":"public static Properties createSslProperties() throws IOException {\n        Properties props = new Properties();\n        props.setProperty(JAVAX_NET_SSL_KEY_STORE, getKeyStoreFilePath());\n        props.setProperty(JAVAX_NET_SSL_TRUST_STORE, getTrustStoreFilePath());\n        props.setProperty(JAVAX_NET_SSL_KEY_STORE_PASSWORD, \"123456\");\n        props.setProperty(JAVAX_NET_SSL_TRUST_STORE_PASSWORD, \"123456\");\n        return props;\n    }","commit_id":"4ddfbd28a06ce24f4d20c241c28df0225903eada","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static long getUsedHeapSize(final MapContainer mapContainer) {\n        long heapCost = 0L;\n        final MapService mapService = mapContainer.getMapService();\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final Address thisAddress = nodeEngine.getThisAddress();\n        for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n            if (nodeEngine.getPartitionService().getPartition(i).isOwnerOrBackup(thisAddress)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return -1L;\n                }\n                heapCost += container.getRecordStore(mapName).getHeapCost();\n            }\n        }\n        heapCost += mapContainer.getNearCacheSizeEstimator().getSize();\n        return heapCost;\n    }","id":81098,"modified_method":"private static long getUsedHeapSize(final MapContainer mapContainer) {\n        long heapCost = 0L;\n        final MapService mapService = mapContainer.getMapService();\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final Address thisAddress = nodeEngine.getThisAddress();\n        for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n            if (nodeEngine.getPartitionService().getPartition(i).isOwnerOrBackup(thisAddress)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return -1L;\n                }\n                heapCost += getRecordStoreHeapCost(mapName, container);\n            }\n        }\n        heapCost += mapContainer.getNearCacheSizeEstimator().getSize();\n        return heapCost;\n    }","commit_id":"5408c80de937e6d9bfeccb82bba19cf4f2f5902b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static boolean isEvictablePerPartition(final MapContainer mapContainer) {\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        for (int i = 0; i < partitionService.getPartitionCount(); i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                final int size = container.getRecordStore(mapName).size();\n                if (size >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":81099,"modified_method":"private static boolean isEvictablePerPartition(final MapContainer mapContainer) {\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        for (int i = 0; i < partitionService.getPartitionCount(); i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                final int size = getRecordStoreSize(mapName, container);\n                if (size >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"5408c80de937e6d9bfeccb82bba19cf4f2f5902b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static boolean isEvictablePerNode(MapContainer mapContainer) {\n        int nodeTotalSize = 0;\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        final int partitionCount = partitionService.getPartitionCount();\n        for (int i = 0; i < partitionCount; i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                nodeTotalSize += container.getRecordStore(mapName).size();\n                if (nodeTotalSize >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":81100,"modified_method":"private static boolean isEvictablePerNode(MapContainer mapContainer) {\n        int nodeTotalSize = 0;\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        final int partitionCount = partitionService.getPartitionCount();\n        for (int i = 0; i < partitionCount; i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                nodeTotalSize += getRecordStoreSize(mapName, container);\n                if (nodeTotalSize >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"5408c80de937e6d9bfeccb82bba19cf4f2f5902b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static boolean isEvictablePerNode(MapContainer mapContainer) {\n        int nodeTotalSize = 0;\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        final int partitionCount = partitionService.getPartitionCount();\n        for (int i = 0; i < partitionCount; i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                nodeTotalSize += container.getRecordStore(mapName).size();\n                if (nodeTotalSize >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":81101,"modified_method":"private static boolean isEvictablePerNode(MapContainer mapContainer) {\n        int nodeTotalSize = 0;\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        final int partitionCount = partitionService.getPartitionCount();\n        for (int i = 0; i < partitionCount; i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                nodeTotalSize += getRecordStoreSize(mapName, container);\n                if (nodeTotalSize >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"83462a5b48d25e56b5c82a80e1b539de8eaf43d9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static boolean isEvictablePerPartition(final MapContainer mapContainer) {\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        for (int i = 0; i < partitionService.getPartitionCount(); i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                final int size = container.getRecordStore(mapName).size();\n                if (size >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":81102,"modified_method":"private static boolean isEvictablePerPartition(final MapContainer mapContainer) {\n        final MapService mapService = mapContainer.getMapService();\n        final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n        final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        for (int i = 0; i < partitionService.getPartitionCount(); i++) {\n            final Address owner = partitionService.getPartitionOwner(i);\n            if (nodeEngine.getThisAddress().equals(owner)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return false;\n                }\n                final int size = getRecordStoreSize(mapName, container);\n                if (size >= maxSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"83462a5b48d25e56b5c82a80e1b539de8eaf43d9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static long getUsedHeapSize(final MapContainer mapContainer) {\n        long heapCost = 0L;\n        final MapService mapService = mapContainer.getMapService();\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final Address thisAddress = nodeEngine.getThisAddress();\n        for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n            if (nodeEngine.getPartitionService().getPartition(i).isOwnerOrBackup(thisAddress)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return -1L;\n                }\n                heapCost += container.getRecordStore(mapName).getHeapCost();\n            }\n        }\n        heapCost += mapContainer.getNearCacheSizeEstimator().getSize();\n        return heapCost;\n    }","id":81103,"modified_method":"private static long getUsedHeapSize(final MapContainer mapContainer) {\n        long heapCost = 0L;\n        final MapService mapService = mapContainer.getMapService();\n        final String mapName = mapContainer.getName();\n        final NodeEngine nodeEngine = mapService.getNodeEngine();\n        final Address thisAddress = nodeEngine.getThisAddress();\n        for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n            if (nodeEngine.getPartitionService().getPartition(i).isOwnerOrBackup(thisAddress)) {\n                final PartitionContainer container = mapService.getPartitionContainer(i);\n                if (container == null) {\n                    return -1L;\n                }\n                heapCost += getRecordStoreHeapCost(mapName, container);\n            }\n        }\n        heapCost += mapContainer.getNearCacheSizeEstimator().getSize();\n        return heapCost;\n    }","commit_id":"83462a5b48d25e56b5c82a80e1b539de8eaf43d9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private int getEvictableSize(int currentPartitionSize, MapConfig mapConfig) {\n        int evictableSize;\n        final MaxSizeConfig.MaxSizePolicy maxSizePolicy = mapConfig.getMaxSizeConfig().getMaxSizePolicy();\n        final int evictionPercentage = mapConfig.getEvictionPercentage();\n        switch (maxSizePolicy) {\n            case PER_PARTITION:\n                int maxSize = mapConfig.getMaxSizeConfig().getSize();\n                int targetSizePerPartition = Double.valueOf(maxSize * ((100 - evictionPercentage) / 100.0)).intValue();\n                int diffFromTargetSize = currentPartitionSize - targetSizePerPartition;\n                int prunedSize = currentPartitionSize * evictionPercentage / 100 + 1;\n                evictableSize = Math.max(diffFromTargetSize, prunedSize);\n                break;\n            case PER_NODE:\n                maxSize = mapConfig.getMaxSizeConfig().getSize();\n                int memberCount = mapService.getNodeEngine().getClusterService().getMembers().size();\n                int maxPartitionSize = (maxSize * memberCount / mapService.getNodeEngine().getPartitionService().getPartitionCount());\n                targetSizePerPartition = Double.valueOf(maxPartitionSize * ((100 - evictionPercentage) / 100.0)).intValue();\n                diffFromTargetSize = currentPartitionSize - targetSizePerPartition;\n                prunedSize = currentPartitionSize * evictionPercentage / 100 + 1;\n                evictableSize = Math.max(diffFromTargetSize, prunedSize);\n                break;\n            case USED_HEAP_PERCENTAGE:\n            case USED_HEAP_SIZE:\n                evictableSize = currentPartitionSize * evictionPercentage / 100;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Max size policy is not defined [\" + maxSizePolicy + \"]\");\n        }\n        return evictableSize;\n    }","id":81104,"modified_method":"private int getEvictableSize(int currentPartitionSize, MapConfig mapConfig) {\n        int evictableSize;\n        final MaxSizeConfig.MaxSizePolicy maxSizePolicy = mapConfig.getMaxSizeConfig().getMaxSizePolicy();\n        final int evictionPercentage = mapConfig.getEvictionPercentage();\n        switch (maxSizePolicy) {\n            case PER_PARTITION:\n                int maxSize = mapConfig.getMaxSizeConfig().getSize();\n                int targetSizePerPartition = Double.valueOf(maxSize * ((100 - evictionPercentage) / 100.0)).intValue();\n                int diffFromTargetSize = currentPartitionSize - targetSizePerPartition;\n                int prunedSize = currentPartitionSize * evictionPercentage / 100 + 1;\n                evictableSize = Math.max(diffFromTargetSize, prunedSize);\n                break;\n            case PER_NODE:\n                maxSize = mapConfig.getMaxSizeConfig().getSize();\n                int memberCount = mapService.getNodeEngine().getClusterService().getMembers().size();\n                int maxPartitionSize = (maxSize * memberCount / mapService.getNodeEngine().getPartitionService().getPartitionCount());\n                targetSizePerPartition = Double.valueOf(maxPartitionSize * ((100 - evictionPercentage) / 100.0)).intValue();\n                diffFromTargetSize = currentPartitionSize - targetSizePerPartition;\n                prunedSize = currentPartitionSize * evictionPercentage / 100 + 1;\n                evictableSize = Math.max(diffFromTargetSize, prunedSize);\n                break;\n            case USED_HEAP_PERCENTAGE:\n            case USED_HEAP_SIZE:\n                evictableSize = Math.max(currentPartitionSize * evictionPercentage / 100, 1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Max size policy is not defined [\" + maxSizePolicy + \"]\");\n        }\n        return evictableSize;\n    }","commit_id":"4c25ab2d097a51b15322a3956ee331b9e6b3d9d1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private boolean isEvictablePerPartition(final MapContainer mapContainer) {\n            final MapService mapService = MapEvictionManager.this.mapService;\n            final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n            final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n            final String mapName = mapContainer.getName();\n            final NodeEngine nodeEngine = mapService.getNodeEngine();\n            final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n            for (int i = 0; i < partitionService.getPartitionCount(); i++) {\n                final Address owner = partitionService.getPartitionOwner(i);\n                if (nodeEngine.getThisAddress().equals(owner)) {\n                    final PartitionContainer container = mapService.getPartitionContainer(i);\n                    if (container == null) {\n                        return false;\n                    }\n                    final int size = container.getRecordStore(mapName).size();\n                    if (size >= maxSize) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }","id":81105,"modified_method":"private boolean isEvictablePerPartition(final MapContainer mapContainer) {\n            final MapService mapService = MapEvictionManager.this.mapService;\n            final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n            final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n            final String mapName = mapContainer.getName();\n            final NodeEngine nodeEngine = mapService.getNodeEngine();\n            final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n            for (int i = 0; i < partitionService.getPartitionCount(); i++) {\n                final Address owner = partitionService.getPartitionOwner(i);\n                if (nodeEngine.getThisAddress().equals(owner)) {\n                    final PartitionContainer container = mapService.getPartitionContainer(i);\n                    if (container == null) {\n                        continue;\n                    }\n                    final int size = getRecordStoreSize(mapName, container);\n                    if (size >= maxSize) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }","commit_id":"4c25ab2d097a51b15322a3956ee331b9e6b3d9d1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private long getUsedHeapSize(final MapContainer mapContainer) {\n            long heapCost = 0L;\n            final MapService mapService = MapEvictionManager.this.mapService;\n            final String mapName = mapContainer.getName();\n            final NodeEngine nodeEngine = mapService.getNodeEngine();\n            final Address thisAddress = nodeEngine.getThisAddress();\n            for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n                if (nodeEngine.getPartitionService().getPartition(i).isOwnerOrBackup(thisAddress)) {\n                    final PartitionContainer container = mapService.getPartitionContainer(i);\n                    if (container == null) {\n                        return -1;\n                    }\n                    heapCost += container.getRecordStore(mapName).getHeapCost();\n                }\n            }\n            heapCost += mapContainer.getNearCacheSizeEstimator().getSize();\n            return heapCost;\n        }","id":81106,"modified_method":"private long getUsedHeapSize(final MapContainer mapContainer) {\n            long heapCost = 0L;\n            final MapService mapService = MapEvictionManager.this.mapService;\n            final String mapName = mapContainer.getName();\n            final NodeEngine nodeEngine = mapService.getNodeEngine();\n            final Address thisAddress = nodeEngine.getThisAddress();\n            for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {\n                if (nodeEngine.getPartitionService().getPartition(i).isOwnerOrBackup(thisAddress)) {\n                    final PartitionContainer container = mapService.getPartitionContainer(i);\n                    if (container == null) {\n                        return -1;\n                    }\n                    heapCost += getRecordStoreHeapCost(mapName, container);\n                }\n            }\n            heapCost += mapContainer.getNearCacheSizeEstimator().getSize();\n            return heapCost;\n        }","commit_id":"4c25ab2d097a51b15322a3956ee331b9e6b3d9d1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private boolean isEvictablePerNode(MapContainer mapContainer) {\n            int nodeTotalSize = 0;\n            final MapService mapService = MapEvictionManager.this.mapService;\n            final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n            final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n            final String mapName = mapContainer.getName();\n            final NodeEngine nodeEngine = mapService.getNodeEngine();\n            final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n            final int partitionCount = partitionService.getPartitionCount();\n            for (int i = 0; i < partitionCount; i++) {\n                final Address owner = partitionService.getPartitionOwner(i);\n                if (nodeEngine.getThisAddress().equals(owner)) {\n                    final PartitionContainer container = mapService.getPartitionContainer(i);\n                    if (container == null) {\n                        return false;\n                    }\n                    nodeTotalSize += container.getRecordStore(mapName).size();\n                    if (nodeTotalSize >= maxSize) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }","id":81107,"modified_method":"private boolean isEvictablePerNode(MapContainer mapContainer) {\n            int nodeTotalSize = 0;\n            final MapService mapService = MapEvictionManager.this.mapService;\n            final MaxSizeConfig maxSizeConfig = mapContainer.getMapConfig().getMaxSizeConfig();\n            final int maxSize = getApproximateMaxSize(maxSizeConfig.getSize());\n            final String mapName = mapContainer.getName();\n            final NodeEngine nodeEngine = mapService.getNodeEngine();\n            final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n            final int partitionCount = partitionService.getPartitionCount();\n            for (int i = 0; i < partitionCount; i++) {\n                final Address owner = partitionService.getPartitionOwner(i);\n                if (nodeEngine.getThisAddress().equals(owner)) {\n                    final PartitionContainer container = mapService.getPartitionContainer(i);\n                    if (container == null) {\n                        continue;\n                    }\n                    nodeTotalSize += getRecordStoreSize(mapName, container);\n                    if (nodeTotalSize >= maxSize) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }","commit_id":"4c25ab2d097a51b15322a3956ee331b9e6b3d9d1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n\t * Initialization.\n\t */\n\t@PostConstruct\n\tpublic void init() throws IOException, RestErrorException {\n\t\tgigaSpace = restConfig.getGigaSpace();\n\t\tpermissionEvaluator = restConfig.getPermissionEvaluator();\n\t\trepo.init();\n\t\trepo.setBaseDir(restConfig.getRestTempFolder());\n\t\tlogger.fine(\"starting DeolpymentsController, injecting rest temp folder to uploadrepo: \" \n\t\t\t\t+ restConfig.getRestTempFolder().getAbsolutePath());\n\t\trepo.createUploadDir();\n\t\tthis.admin = restConfig.getAdmin();\n\t\tthis.eventsCache = new EventsCache(admin);\n\t\tthis.controllerHelper = new ControllerHelper(gigaSpace, admin);\n\t}","id":81108,"modified_method":"/**\n\t * Initialization.\n\t */\n\t@PostConstruct\n\tpublic void init() throws IOException, RestErrorException {\n\t\tgigaSpace = restConfig.getGigaSpace();\n\t\tpermissionEvaluator = restConfig.getPermissionEvaluator();\n\t\trepo.init();\n\t\tif (restConfig.getCloud() != null) {\n\t\t\t// working on an actual cloud (not localcloud)\n\t\t\trepo.setBaseDir(restConfig.getRestTempFolder());\n\t\t\tlogger.fine(\"starting DeolpymentsController, injecting rest temp folder to uploadrepo: \" \n\t\t\t\t\t+ restConfig.getRestTempFolder().getAbsolutePath());\n\t\t}\n\t\trepo.createUploadDir();\n\t\tthis.admin = restConfig.getAdmin();\n\t\tthis.eventsCache = new EventsCache(admin);\n\t\tthis.controllerHelper = new ControllerHelper(gigaSpace, admin);\n\t}","commit_id":"2555cd25bf0518d4ac71c08f0396acb0060a29de","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public DefaultModuleFileSystem(ModuleInputFileCache moduleInputFileCache, Project module, Settings settings, FileIndexer index, ModuleFileSystemInitializer initializer,\n                                 ComponentIndexer componentIndexer) {\n    super(moduleInputFileCache);\n    this.componentIndexer = componentIndexer;\n    this.moduleKey = module.getKey();\n    this.settings = settings;\n    this.index = index;\n    setBaseDir(initializer.baseDir());\n    setWorkDir(initializer.workingDir());\n    this.buildDir = initializer.buildDir();\n    this.sourceDirs = initializer.sourceDirs();\n    this.testDirs = initializer.testDirs();\n    this.binaryDirs = initializer.binaryDirs();\n    this.sourceFiles = initializer.additionalSourceFiles();\n    this.testFiles = initializer.additionalTestFiles();\n  }","id":81109,"modified_method":"public DefaultModuleFileSystem(ModuleInputFileCache moduleInputFileCache, Project module, Settings settings, FileIndexer index, ModuleFileSystemInitializer initializer,\n                                 ComponentIndexer componentIndexer) {\n    super(moduleInputFileCache);\n    this.componentIndexer = componentIndexer;\n    this.moduleKey = module.getKey();\n    this.settings = settings;\n    this.index = index;\n    if (initializer.baseDir() != null) {\n      setBaseDir(initializer.baseDir());\n    }\n    setWorkDir(initializer.workingDir());\n    this.buildDir = initializer.buildDir();\n    this.sourceDirs = initializer.sourceDirs();\n    this.testDirs = initializer.testDirs();\n    this.binaryDirs = initializer.binaryDirs();\n    this.sourceFiles = initializer.additionalSourceFiles();\n    this.testFiles = initializer.additionalTestFiles();\n  }","commit_id":"bc75bfaad86e30160c40d0002d15de4360a31dc2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void doOpenProject(String projectPath, Project projectToClose, boolean forceNewFrame) {\n    final VirtualFile projectFile = LocalFileSystem.getInstance().findFileByPath(FileUtil.toSystemIndependentName(projectPath));\n    if (projectFile != null) {\n      Project project = ProjectUtil.openProject(projectPath, projectToClose, forceNewFrame);\n      ProjectBaseDirectory.getInstance(project).setBaseDir(project.getBaseDir());\n    }\n  }","id":81110,"modified_method":"protected void doOpenProject(String projectPath, Project projectToClose, boolean forceNewFrame) {\n    final VirtualFile projectFile = LocalFileSystem.getInstance().findFileByPath(FileUtil.toSystemIndependentName(projectPath));\n    if (projectFile != null) {\n      Project project = ProjectUtil.openProject(projectPath, projectToClose, forceNewFrame);\n      if (project != null) {\n        ProjectBaseDirectory.getInstance(project).setBaseDir(project.getBaseDir());\n      }\n    }\n  }","commit_id":"96c91730b12eaba6adfb6ae645c4a87e92d59966","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void updatePreviewPanel(@NotNull EditorSchemeAttributeDescriptor descriptor) {\n    if (!(myPreviewPanel instanceof SimpleEditorPreview)) return;\n\n    SimpleEditorPreview simpleEditorPreview = (SimpleEditorPreview)myPreviewPanel;\n\n    if (myActive == myRainbowPanel\n        && myPage instanceof RainbowColorSettingsPage\n        && descriptor instanceof RainbowAttributeDescriptor) {\n      simpleEditorPreview.setDemoText(((RainbowColorSettingsPage)myPage).getRainbowDemoText());\n      List<HighlightData> highlightDatas = simpleEditorPreview.getHighlightDataForExtension();\n      if (myRainbowPanel.myGlobalState.isRainbowOn) {\n        addRainbowHighlighting(simpleEditorPreview.getEditor().getDocument(), highlightDatas);\n      }\n      else {\n        removeRainbowHighlighting(highlightDatas);\n      }\n    }\n    else {\n      simpleEditorPreview.setDemoText(myPage.getDemoText());\n    }\n  }","id":81111,"modified_method":"protected void updatePreviewPanel(@NotNull EditorSchemeAttributeDescriptor descriptor) {\n    if (!(myPreviewPanel instanceof SimpleEditorPreview)) return;\n\n    SimpleEditorPreview simpleEditorPreview = (SimpleEditorPreview)myPreviewPanel;\n\n    if (myActive == myRainbowPanel\n        && myPage instanceof RainbowColorSettingsPage\n        && descriptor instanceof RainbowAttributeDescriptor) {\n      if (myRainbowPanel.myGlobalState.isRainbowOn) {\n        RainbowHighlighter highlighter = new RainbowHighlighter(descriptor.getScheme());\n        List<TextAttributesKey> tempKeys = highlighter.getRainbowTempKeys();\n        Pair<String, List<HighlightData>> demo = getColorDemoLine(highlighter, tempKeys);\n        simpleEditorPreview.setDemoText(demo.first + \"\\n\" + ((RainbowColorSettingsPage)myPage).getRainbowDemoText());\n        addRainbowHighlighting(simpleEditorPreview.getEditor().getDocument(),\n                               demo.second,\n                               simpleEditorPreview.getHighlightDataForExtension(),\n                               highlighter,\n                               tempKeys);\n      }\n      else {\n        simpleEditorPreview.setDemoText(((RainbowColorSettingsPage)myPage).getRainbowDemoText());\n        removeRainbowHighlighting(simpleEditorPreview.getHighlightDataForExtension());\n      }\n    }\n    else {\n      simpleEditorPreview.setDemoText(myPage.getDemoText());\n    }\n  }","commit_id":"fd45083d236c681b2e5137af520492a02002a260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addRainbowHighlighting(DocumentEx document, @NotNull List<HighlightData> data) {\n    List<TextAttributesKey> keys = RainbowHighlighter.getRainbowKeys();\n    if (!keys.isEmpty()) {\n      List<HighlightData> newData = new ArrayList<HighlightData>();\n      int i = 0;\n      HashMap<String, Integer> id2index = new HashMap<String, Integer>();\n      for (HighlightData d : data) {\n        if (((RainbowColorSettingsPage)myPage).isRainbowType(d.getHighlightKey())) {\n          // sequential approach for color selection\n          String id = document.getText(TextRange.create(d.getStartOffset(), d.getEndOffset()));\n          Integer index = id2index.get(id);\n          if (index == null) {\n            index = i++ % keys.size();\n            id2index.put(id, index);\n          }\n          TextAttributesKey type = keys.get(index);\n\n          HighlightData rainbow = new HighlightData(d.getStartOffset(), d.getEndOffset(), type);\n          //fixme: twisted coloring in editor. We need add rainbow-tag twice.\n          newData.add(rainbow);\n          newData.add(d);\n          newData.add(rainbow);\n        }\n        else {\n          newData.add(d);\n        }\n      }\n      data.clear();\n      data.addAll(newData);\n    }\n  }","id":81112,"modified_method":"private void addRainbowHighlighting(@NotNull DocumentEx document,\n                                      @NotNull List<HighlightData> showLineData,\n                                      @NotNull List<HighlightData> data,\n                                      @NotNull RainbowHighlighter rainbowHighlighter,\n                                      @NotNull List<TextAttributesKey> rainbowTempKeys) {\n    if (!rainbowTempKeys.isEmpty()) {\n      List<HighlightData> newData = new ArrayList<HighlightData>(showLineData);\n      HashMap<String, Integer> id2index = new HashMap<String, Integer>();\n\n      for (HighlightData d : data) {\n        if (((RainbowColorSettingsPage)myPage).isRainbowType(d.getHighlightKey())) {\n          String id = document.getText(TextRange.create(d.getStartOffset(), d.getEndOffset()));\n\n          int index = rainbowHighlighter.getColorIndex(id2index, id, RainbowHighlighter.getRainbowHash(id));\n          HighlightData rainbow = new HighlightData(d.getStartOffset(), d.getEndOffset(), rainbowTempKeys.get(index));\n\n          //fixme: twisted coloring in editor. We need add rainbow-tag twice.\n          newData.add(rainbow);\n          newData.add(d);\n          newData.add(rainbow);\n        }\n        else if (!RainbowHighlighter.isRainbowTempKey(d.getHighlightKey())) {\n          newData.add(d);\n        }\n      }\n      data.clear();\n      data.addAll(newData);\n    }\n  }","commit_id":"fd45083d236c681b2e5137af520492a02002a260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HighlightInfo getInfo(int colorIndex, @Nullable PsiElement id, @Nullable TextAttributesKey colorKey) {\n    if (id == null) {\n      return null;\n    }\n    if (colorKey == null) {\n      colorKey = DefaultLanguageHighlighterColors.LOCAL_VARIABLE;\n    }\n    return HighlightInfo\n      .newHighlightInfo(RAINBOW_ELEMENT)\n      .textAttributes(TextAttributes\n                        .fromFlyweight(myColorsScheme\n                                         .getAttributes(colorKey)\n                                         .getFlyweight()\n                                         .withForeground(calculateForeground(colorIndex))))\n      .range(id)\n      .create();\n  }","id":81113,"modified_method":"public HighlightInfo getInfo(int colorIndex, @Nullable PsiElement id, @Nullable TextAttributesKey colorKey) {\n    return id == null ? null : getInfoBuilder(colorIndex, colorKey).range(id).create();\n  }","commit_id":"fd45083d236c681b2e5137af520492a02002a260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected HighlightInfo getInfo(@NotNull PsiElement context,\n                                  @NotNull PsiElement rainbowElement,\n                                  @NotNull String id,\n                                  @Nullable TextAttributesKey colorKey) {\n    HashMap<String, Integer> id2index = USED_COLORS.getValue(context);\n    Integer colorIndex = id2index.get(id);\n    if (colorIndex == null) {\n      colorIndex = Math.abs(StringHash.murmur(id, 0x55AA));\n\n      Map<Integer, Integer> index2usage = new HashMap<Integer, Integer>();\n      id2index.values().forEach(i -> {\n        Integer useCount = index2usage.get(i);\n        index2usage.put(i, useCount == null ? 1 : ++useCount);\n      });\n\n      int colorsCount = getHighlighter().getColorsCount();\n      out:\n      for (int cutoff = 0; ; ++cutoff) {\n        for (int i = 0; i < colorsCount; ++i) {\n          colorIndex %= colorsCount;\n          Integer useCount = index2usage.get(colorIndex % colorsCount);\n          if (useCount == null) useCount = 0;\n          if (useCount == cutoff) break out;\n          ++colorIndex;\n        }\n      }\n      id2index.put(id, colorIndex);\n    }\n    return getHighlighter().getInfo(colorIndex, rainbowElement, colorKey);\n  }","id":81114,"modified_method":"protected HighlightInfo getInfo(@NotNull PsiElement context,\n                                  @NotNull PsiElement rainbowElement,\n                                  @NotNull String id,\n                                  @Nullable TextAttributesKey colorKey) {\n    return getHighlighter()\n      .getInfo(getHighlighter().getColorIndex(\n                   USED_COLORS.getValue(context),\n                   id,\n                   RainbowHighlighter.getRainbowHash(id)),\n               rainbowElement,\n               colorKey);\n  }","commit_id":"fd45083d236c681b2e5137af520492a02002a260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disableBreakpoints(final DebugProcessImpl debugProcess) {\n    final List<Breakpoint> breakpoints = getBreakpoints();\n    for (Iterator<Breakpoint> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      debugProcess.getRequestsManager().deleteRequest(breakpoint);\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        updateBreakpointsUI();\n      }\n    });\n  }","id":81115,"modified_method":"public void disableBreakpoints(final DebugProcessImpl debugProcess) {\n    final List<Breakpoint> breakpoints = getBreakpoints();\n    for (Breakpoint breakpoint : breakpoints) {\n      debugProcess.getRequestsManager().deleteRequest(breakpoint);\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        updateBreakpointsUI();\n      }\n    });\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LineBreakpoint findLineBreakpoint(final Document document, final int offset) {\n    List<BreakpointWithHighlighter> breakpoints = findBreakpoints(document, offset);\n    for (Iterator<BreakpointWithHighlighter> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      BreakpointWithHighlighter breakpointWithHighlighter = iterator.next();\n      if(breakpointWithHighlighter instanceof LineBreakpoint) return (LineBreakpoint)breakpointWithHighlighter;\n    }\n    return null;\n  }","id":81116,"modified_method":"public LineBreakpoint findLineBreakpoint(final Document document, final int offset) {\n    List<BreakpointWithHighlighter> breakpoints = findBreakpoints(document, offset);\n    for (BreakpointWithHighlighter breakpointWithHighlighter : breakpoints) {\n      if (breakpointWithHighlighter instanceof LineBreakpoint) return (LineBreakpoint)breakpointWithHighlighter;\n    }\n    return null;\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addBreakpoint(Breakpoint breakpoint) {\n    myBreakpoints.add(breakpoint);\n    myBreakpointsListForIteration = null;\n    if(breakpoint instanceof BreakpointWithHighlighter) {\n      BreakpointWithHighlighter breakpointWithHighlighter = ((BreakpointWithHighlighter) breakpoint);\n      Document document = breakpointWithHighlighter.getDocument();\n      if(document != null) {\n        List<BreakpointWithHighlighter> breakpoints = myDocumentBreakpoints.get(document);\n\n        if(breakpoints == null) {\n          breakpoints = new ArrayList<BreakpointWithHighlighter>();\n          myDocumentBreakpoints.put(document, breakpoints);\n        }\n        breakpoints.add(breakpointWithHighlighter);\n      }\n    }\n    myDispatcher.getMulticaster().breakpointsChanged();\n  }","id":81117,"modified_method":"public synchronized void addBreakpoint(Breakpoint breakpoint) {\n    myBreakpoints.add(breakpoint);\n    myBreakpointsListForIteration = null;\n    if(breakpoint instanceof BreakpointWithHighlighter) {\n      BreakpointWithHighlighter breakpointWithHighlighter = (BreakpointWithHighlighter)breakpoint;\n      Document document = breakpointWithHighlighter.getDocument();\n      if(document != null) {\n        List<BreakpointWithHighlighter> breakpoints = myDocumentBreakpoints.get(document);\n\n        if(breakpoints == null) {\n          breakpoints = new ArrayList<BreakpointWithHighlighter>();\n          myDocumentBreakpoints.put(document, breakpoints);\n        }\n        breakpoints.add(breakpointWithHighlighter);\n      }\n    }\n    myDispatcher.getMulticaster().breakpointsChanged();\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FieldBreakpoint findFieldBreakpoint(final Document document, final int offset) {\n    List<BreakpointWithHighlighter> breakpoints = findBreakpoints(document, offset);\n    for (Iterator<BreakpointWithHighlighter> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      BreakpointWithHighlighter breakpointWithHighlighter = iterator.next();\n      if(breakpointWithHighlighter instanceof FieldBreakpoint) return (FieldBreakpoint)breakpointWithHighlighter;\n    }\n    return null;\n  }","id":81118,"modified_method":"public FieldBreakpoint findFieldBreakpoint(final Document document, final int offset) {\n    List<BreakpointWithHighlighter> breakpoints = findBreakpoints(document, offset);\n    for (BreakpointWithHighlighter breakpointWithHighlighter : breakpoints) {\n      if (breakpointWithHighlighter instanceof FieldBreakpoint) return (FieldBreakpoint)breakpointWithHighlighter;\n    }\n    return null;\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(final Element parentNode) throws InvalidDataException {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n\n    myStartupManager.registerPostStartupActivity(new Runnable() {\n      @SuppressWarnings({\"HardCodedStringLiteral\"}) public void run() {\n        PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Runnable() {\n          @SuppressWarnings({\"HardCodedStringLiteral\"})\n          public void run() {\n            final Map<String, Breakpoint> nameToBreakpointMap = new java.util.HashMap<String, Breakpoint>();\n            try {\n              final List groups = parentNode.getChildren();\n              for (Iterator it = groups.iterator(); it.hasNext();) {\n                final Element group = (Element)it.next();\n                final String category = group.getName();\n                Element anyExceptionBreakpointGroup = null;\n                if (!AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT.equals(category)) {\n                  // for compatibility with previous format\n                  anyExceptionBreakpointGroup = group.getChild(AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT);\n                  final BreakpointFactory factory = BreakpointFactory.getInstance(category);\n                  if (factory != null) {\n                    for (Iterator i = group.getChildren(\"breakpoint\").iterator(); i.hasNext();) {\n                      Element breakpointNode = (Element)i.next();\n                      Breakpoint breakpoint = factory.createBreakpoint(myProject, breakpointNode);\n                      breakpoint.readExternal(breakpointNode);\n                      addBreakpoint(breakpoint);\n                      nameToBreakpointMap.put(breakpoint.getDisplayName(), breakpoint);\n                    }\n                  }\n                }\n                else {\n                  anyExceptionBreakpointGroup = group;\n                }\n\n                if (anyExceptionBreakpointGroup != null) {\n                  final Element breakpointElement = group.getChild(\"breakpoint\");\n                  if (breakpointElement != null) {\n                    myAnyExceptionBreakpoint.readExternal(breakpointElement);\n                  }\n                }\n                \n              }\n            }\n            catch (InvalidDataException e) {\n            }\n\n            final Element rulesGroup = parentNode.getChild(RULES_GROUP_NAME);\n            if (rulesGroup != null) {\n              final List rules = rulesGroup.getChildren(\"rule\");\n              for (Iterator it = rules.iterator(); it.hasNext();) {\n                final Element rule = (Element)it.next();\n                final Element master = rule.getChild(MASTER_BREAKPOINT_TAGNAME);\n                if (master == null) {\n                  continue;\n                }\n                final Element slave = rule.getChild(SLAVE_BREAKPOINT_TAGNAME);\n                if (slave == null) {\n                  continue;\n                }\n                final Breakpoint masterBreakpoint = nameToBreakpointMap.get(master.getAttributeValue(\"name\"));\n                if (masterBreakpoint == null) {\n                  continue;\n                }\n                final Breakpoint slaveBreakpoint = nameToBreakpointMap.get(slave.getAttributeValue(\"name\"));\n                if (slaveBreakpoint == null) {\n                  continue;\n                }\n                addBreakpointRule(new EnableBreakpointRule(BreakpointManager.this, masterBreakpoint, slaveBreakpoint));\n              }\n            }\n\n            DebuggerInvocationUtil.invokeLater(myProject, new Runnable() {\n              public void run() {\n                updateBreakpointsUI();\n              }\n            });            \n          }\n        });\n        \n        myUIProperties.clear();\n        final Element props = parentNode.getChild(\"ui_properties\");\n        if (props != null) {\n          final List children = props.getChildren(\"property\");\n          for (Object child : children) {\n            Element property = (Element)child;\n            final String name = property.getAttributeValue(\"name\");\n            final String value = property.getAttributeValue(\"value\");\n            if (name != null && value != null) {\n              myUIProperties.put(name, value);\n            }\n          }\n        }\n      }\n    });\n\n  }","id":81119,"modified_method":"public void readExternal(final Element parentNode) throws InvalidDataException {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n\n    myStartupManager.registerPostStartupActivity(new Runnable() {\n      @SuppressWarnings({\"HardCodedStringLiteral\"}) public void run() {\n        PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Runnable() {\n          @SuppressWarnings({\"HardCodedStringLiteral\"})\n          public void run() {\n            final Map<String, Breakpoint> nameToBreakpointMap = new java.util.HashMap<String, Breakpoint>();\n            try {\n              final List groups = parentNode.getChildren();\n              for (final Object group1 : groups) {\n                final Element group = (Element)group1;\n                final String category = group.getName();\n                Element anyExceptionBreakpointGroup;\n                if (!AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT.equals(category)) {\n                  // for compatibility with previous format\n                  anyExceptionBreakpointGroup = group.getChild(AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT);\n                  final BreakpointFactory factory = BreakpointFactory.getInstance(category);\n                  if (factory != null) {\n                    for (final Object o : group.getChildren(\"breakpoint\")) {\n                      Element breakpointNode = (Element)o;\n                      Breakpoint breakpoint = factory.createBreakpoint(myProject, breakpointNode);\n                      breakpoint.readExternal(breakpointNode);\n                      addBreakpoint(breakpoint);\n                      nameToBreakpointMap.put(breakpoint.getDisplayName(), breakpoint);\n                    }\n                  }\n                }\n                else {\n                  anyExceptionBreakpointGroup = group;\n                }\n\n                if (anyExceptionBreakpointGroup != null) {\n                  final Element breakpointElement = group.getChild(\"breakpoint\");\n                  if (breakpointElement != null) {\n                    myAnyExceptionBreakpoint.readExternal(breakpointElement);\n                  }\n                }\n\n              }\n            }\n            catch (InvalidDataException e) {\n            }\n\n            final Element rulesGroup = parentNode.getChild(RULES_GROUP_NAME);\n            if (rulesGroup != null) {\n              final List rules = rulesGroup.getChildren(\"rule\");\n              for (final Object rule1 : rules) {\n                final Element rule = (Element)rule1;\n                final Element master = rule.getChild(MASTER_BREAKPOINT_TAGNAME);\n                if (master == null) {\n                  continue;\n                }\n                final Element slave = rule.getChild(SLAVE_BREAKPOINT_TAGNAME);\n                if (slave == null) {\n                  continue;\n                }\n                final Breakpoint masterBreakpoint = nameToBreakpointMap.get(master.getAttributeValue(\"name\"));\n                if (masterBreakpoint == null) {\n                  continue;\n                }\n                final Breakpoint slaveBreakpoint = nameToBreakpointMap.get(slave.getAttributeValue(\"name\"));\n                if (slaveBreakpoint == null) {\n                  continue;\n                }\n                addBreakpointRule(new EnableBreakpointRule(BreakpointManager.this, masterBreakpoint, slaveBreakpoint));\n              }\n            }\n\n            DebuggerInvocationUtil.invokeLater(myProject, new Runnable() {\n              public void run() {\n                updateBreakpointsUI();\n              }\n            });            \n          }\n        });\n        \n        myUIProperties.clear();\n        final Element props = parentNode.getChild(\"ui_properties\");\n        if (props != null) {\n          final List children = props.getChildren(\"property\");\n          for (Object child : children) {\n            Element property = (Element)child;\n            final String name = property.getAttributeValue(\"name\");\n            final String value = property.getAttributeValue(\"value\");\n            if (name != null && value != null) {\n              myUIProperties.put(name, value);\n            }\n          }\n        }\n      }\n    });\n\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodBreakpoint findMethodBreakpoint(final Document document, final int offset) {\n    List<BreakpointWithHighlighter> breakpoints = findBreakpoints(document, offset);\n    for (Iterator<BreakpointWithHighlighter> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      BreakpointWithHighlighter breakpointWithHighlighter = iterator.next();\n      if(breakpointWithHighlighter instanceof MethodBreakpoint) return (MethodBreakpoint)breakpointWithHighlighter;\n    }\n    return null;\n  }","id":81120,"modified_method":"public MethodBreakpoint findMethodBreakpoint(final Document document, final int offset) {\n    List<BreakpointWithHighlighter> breakpoints = findBreakpoints(document, offset);\n    for (BreakpointWithHighlighter breakpointWithHighlighter : breakpoints) {\n      if (breakpointWithHighlighter instanceof MethodBreakpoint) return (MethodBreakpoint)breakpointWithHighlighter;\n    }\n    return null;\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processBreakpointHit(@NotNull final Breakpoint breakpoint) {\n    for (Iterator<EnableBreakpointRule> it = myBreakpointRules.iterator(); it.hasNext();) {\n      final EnableBreakpointRule rule = it.next();\n      rule.processBreakpointHit(breakpoint);\n    }\n  }","id":81121,"modified_method":"public void processBreakpointHit(@NotNull final Breakpoint breakpoint) {\n    for (final EnableBreakpointRule rule : myBreakpointRules) {\n      rule.processBreakpointHit(breakpoint);\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeInvalidBreakpoints() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    ArrayList<Breakpoint> toDelete = new ArrayList<Breakpoint>();\n\n    for (Iterator it = getBreakpoints().listIterator(); it.hasNext();) {\n      Breakpoint breakpoint = (Breakpoint)it.next();\n      if (!breakpoint.isValid()) {\n        toDelete.add(breakpoint);\n      }\n    }\n\n    for (Iterator<Breakpoint> iterator = toDelete.iterator(); iterator.hasNext();) {\n      removeBreakpoint(iterator.next());\n    }\n  }","id":81122,"modified_method":"private void removeInvalidBreakpoints() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    ArrayList<Breakpoint> toDelete = new ArrayList<Breakpoint>();\n\n    for (Iterator it = getBreakpoints().listIterator(); it.hasNext();) {\n      Breakpoint breakpoint = (Breakpoint)it.next();\n      if (!breakpoint.isValid()) {\n        toDelete.add(breakpoint);\n      }\n    }\n\n    for (final Breakpoint aToDelete : toDelete) {\n      removeBreakpoint(aToDelete);\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateBreakpointsUI() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    for (Iterator<Breakpoint> iterator = getBreakpoints().iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      breakpoint.updateUI();\n    }\n  }","id":81123,"modified_method":"public void updateBreakpointsUI() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    for (Breakpoint breakpoint : getBreakpoints()) {\n      breakpoint.updateUI();\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Breakpoint findMasterBreakpoint(@NotNull Breakpoint dependentBreakpoint) {\n    for (Iterator<EnableBreakpointRule> it = myBreakpointRules.iterator(); it.hasNext();) {\n      final EnableBreakpointRule rule = it.next();\n      if (dependentBreakpoint.equals(rule.getSlaveBreakpoint())) {\n        return rule.getMasterBreakpoint();\n      }\n    }\n    return null;\n  }","id":81124,"modified_method":"public Breakpoint findMasterBreakpoint(@NotNull Breakpoint dependentBreakpoint) {\n    for (final EnableBreakpointRule rule : myBreakpointRules) {\n      if (dependentBreakpoint.equals(rule.getSlaveBreakpoint())) {\n        return rule.getMasterBreakpoint();\n      }\n    }\n    return null;\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reloadBreakpoints() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n\n    for (Iterator<Breakpoint> iterator = getBreakpoints().iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      breakpoint.reload();\n    }\n  }","id":81125,"modified_method":"public void reloadBreakpoints() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n\n    for (Breakpoint breakpoint : getBreakpoints()) {\n      breakpoint.reload();\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeBreakpoint(final Breakpoint breakpoint) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    if (breakpoint == null) {\n      return;\n    }\n\n    if (myBreakpoints.remove(breakpoint)) {\n      updateBreakpointRules(breakpoint);\n      myBreakpointsListForIteration = null;\n      if(breakpoint instanceof BreakpointWithHighlighter) {\n        //breakpoint.saveToString() may be invalid\n\n        for (Iterator<Document> iterator = myDocumentBreakpoints.keySet().iterator(); iterator.hasNext();) {\n          final Document document = iterator.next();\n          final List<BreakpointWithHighlighter> documentBreakpoints = myDocumentBreakpoints.get(document);\n          final boolean reallyRemoved = documentBreakpoints.remove(breakpoint);\n          if (reallyRemoved) {\n            if (documentBreakpoints.isEmpty()) {\n              myDocumentBreakpoints.remove(document);\n            }\n            break;\n          }\n        }\n      }\n      //we delete breakpoints inside release, so gutter will not fire events to deleted breakpoints\n      breakpoint.delete();\n\n      myDispatcher.getMulticaster().breakpointsChanged();\n    }\n  }","id":81126,"modified_method":"public synchronized void removeBreakpoint(final Breakpoint breakpoint) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    if (breakpoint == null) {\n      return;\n    }\n\n    if (myBreakpoints.remove(breakpoint)) {\n      updateBreakpointRules(breakpoint);\n      myBreakpointsListForIteration = null;\n      if(breakpoint instanceof BreakpointWithHighlighter) {\n        //breakpoint.saveToString() may be invalid\n\n        for (final Document document : myDocumentBreakpoints.keySet()) {\n          final List<BreakpointWithHighlighter> documentBreakpoints = myDocumentBreakpoints.get(document);\n          final boolean reallyRemoved = documentBreakpoints.remove(breakpoint);\n          if (reallyRemoved) {\n            if (documentBreakpoints.isEmpty()) {\n              myDocumentBreakpoints.remove(document);\n            }\n            break;\n          }\n        }\n      }\n      //we delete breakpoints inside release, so gutter will not fire events to deleted breakpoints\n      breakpoint.delete();\n\n      myDispatcher.getMulticaster().breakpointsChanged();\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void init() {\n    EditorEventMulticaster eventMulticaster = EditorFactory.getInstance().getEventMulticaster();\n    myEditorMouseListener = new EditorMouseAdapter() {\n      private EditorMouseEvent myMousePressedEvent;\n\n      private @Nullable Breakpoint toggleBreakpoint(final boolean mostSuitingBreakpoint, final int line) {\n        final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n        if (editor == null) {\n          return null;\n        }\n        final Document document = editor.getDocument();\n        final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n\n        final FileType fileType = psiFile.getFileType();\n        boolean isInsideCompiledClass = StdFileTypes.CLASS.equals(fileType);\n        if (!isInsideCompiledClass && !DebuggerUtils.supportsJVMDebugging(fileType)) {\n          return null;\n        }\n        PsiDocumentManager.getInstance(myProject).commitDocument(document);\n\n        int offset = editor.getCaretModel().getOffset();\n        int editorLine = editor.getDocument().getLineNumber(offset);\n        if(editorLine != line) {\n          if (line < 0 || line >= document.getLineCount()) {\n            return null;\n          }\n          offset = editor.getDocument().getLineStartOffset(line);\n        }\n\n        Breakpoint breakpoint = findBreakpoint(document, offset);\n        if (breakpoint == null) {\n          if(mostSuitingBreakpoint || isInsideCompiledClass) {\n            breakpoint = addFieldBreakpoint(document, offset);\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n            if (breakpoint == null && !isInsideCompiledClass) {\n              breakpoint = addLineBreakpoint(document, line);\n            }\n          }\n          else {\n            breakpoint = addLineBreakpoint(document, line);\n\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n          }\n\n          if(breakpoint != null) {\n            RequestManagerImpl.createRequests(breakpoint);\n          }\n          return breakpoint;\n        }\n        else {\n          removeBreakpoint(breakpoint);\n          return null;\n        }\n      }\n\n      private boolean isFromMyProject(Editor editor) {\n        FileEditor[] allEditors = FileEditorManager.getInstance(myProject).getAllEditors();\n        for (int idx = 0; idx < allEditors.length; idx++) {\n          FileEditor ed = allEditors[idx];\n          if (!(ed instanceof TextEditor)) {\n            continue;\n          }\n          if (((TextEditor)ed).getEditor().equals(editor)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      //mousePressed + mouseReleased is a hack to keep selection in editor when shift is pressed\n      public void mousePressed(EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA && e.getMouseEvent().isShiftDown()) {\n          myMousePressedEvent = e;\n          e.consume();\n        }\n      }\n\n      public void mouseReleased(EditorMouseEvent e) {\n        if(myMousePressedEvent != null) {\n          mouseClicked(e);\n        }\n        myMousePressedEvent = null;\n      }\n\n      public void mouseClicked(final EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA) {\n          PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Runnable() {\n            public void run() {\n              final Editor editor = e.getEditor();\n              if (!isFromMyProject(editor)) {\n                return;\n              }\n              final int line = editor.xyToLogicalPosition(e.getMouseEvent().getPoint()).line;\n              if (line < 0 || line >= editor.getDocument().getLineCount()) {\n                return;\n              }\n              MouseEvent event = e.getMouseEvent();\n              if (event.isPopupTrigger()) {\n                return;\n              }\n              if (event.getButton() != 1) {\n                return;\n              }\n\n              e.consume();\n\n              DebuggerInvocationUtil.invokeLater(myProject, new Runnable() {\n                public void run() {\n                  Breakpoint breakpoint = toggleBreakpoint(e.getMouseEvent().isAltDown(), line);\n\n                  if(e.getMouseEvent().isShiftDown() && breakpoint != null) {\n                    breakpoint.LOG_EXPRESSION_ENABLED = true;\n                    final TextWithImports logMessage = DebuggerUtilsEx.getEditorText(editor);\n                    breakpoint.setLogMessage(logMessage != null? logMessage : new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, DebuggerBundle.message(\"breakpoint.log.message\", breakpoint.getDisplayName())));\n                    breakpoint.SUSPEND_POLICY = DebuggerSettings.SUSPEND_NONE;\n\n                    DialogWrapper dialog = DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().createConfigurationDialog(breakpoint, BreakpointPropertiesPanel.CONTROL_LOG_MESSAGE);\n                    dialog.show();\n\n                    if(!dialog.isOK()) {\n                      removeBreakpoint(breakpoint);\n                    }\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    };\n\n    eventMulticaster.addEditorMouseListener(myEditorMouseListener);\n    eventMulticaster.addDocumentListener(myDocumentListener);\n  }","id":81127,"modified_method":"public void init() {\n    EditorEventMulticaster eventMulticaster = EditorFactory.getInstance().getEventMulticaster();\n    myEditorMouseListener = new EditorMouseAdapter() {\n      private EditorMouseEvent myMousePressedEvent;\n\n      private @Nullable Breakpoint toggleBreakpoint(final boolean mostSuitingBreakpoint, final int line) {\n        final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n        if (editor == null) {\n          return null;\n        }\n        final Document document = editor.getDocument();\n        final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n\n        final FileType fileType = psiFile.getFileType();\n        boolean isInsideCompiledClass = StdFileTypes.CLASS.equals(fileType);\n        if (!isInsideCompiledClass && !DebuggerUtils.supportsJVMDebugging(fileType)) {\n          return null;\n        }\n        PsiDocumentManager.getInstance(myProject).commitDocument(document);\n\n        int offset = editor.getCaretModel().getOffset();\n        int editorLine = editor.getDocument().getLineNumber(offset);\n        if(editorLine != line) {\n          if (line < 0 || line >= document.getLineCount()) {\n            return null;\n          }\n          offset = editor.getDocument().getLineStartOffset(line);\n        }\n\n        Breakpoint breakpoint = findBreakpoint(document, offset);\n        if (breakpoint == null) {\n          if(mostSuitingBreakpoint || isInsideCompiledClass) {\n            breakpoint = addFieldBreakpoint(document, offset);\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n            if (breakpoint == null && !isInsideCompiledClass) {\n              breakpoint = addLineBreakpoint(document, line);\n            }\n          }\n          else {\n            breakpoint = addLineBreakpoint(document, line);\n\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n          }\n\n          if(breakpoint != null) {\n            RequestManagerImpl.createRequests(breakpoint);\n          }\n          return breakpoint;\n        }\n        else {\n          removeBreakpoint(breakpoint);\n          return null;\n        }\n      }\n\n      private boolean isFromMyProject(Editor editor) {\n        FileEditor[] allEditors = FileEditorManager.getInstance(myProject).getAllEditors();\n        for (FileEditor ed : allEditors) {\n          if (!(ed instanceof TextEditor)) {\n            continue;\n          }\n          if (((TextEditor)ed).getEditor().equals(editor)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      //mousePressed + mouseReleased is a hack to keep selection in editor when shift is pressed\n      public void mousePressed(EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA && e.getMouseEvent().isShiftDown()) {\n          myMousePressedEvent = e;\n          e.consume();\n        }\n      }\n\n      public void mouseReleased(EditorMouseEvent e) {\n        if(myMousePressedEvent != null) {\n          mouseClicked(e);\n        }\n        myMousePressedEvent = null;\n      }\n\n      public void mouseClicked(final EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA) {\n          PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Runnable() {\n            public void run() {\n              final Editor editor = e.getEditor();\n              if (!isFromMyProject(editor)) {\n                return;\n              }\n              final int line = editor.xyToLogicalPosition(e.getMouseEvent().getPoint()).line;\n              if (line < 0 || line >= editor.getDocument().getLineCount()) {\n                return;\n              }\n              MouseEvent event = e.getMouseEvent();\n              if (event.isPopupTrigger()) {\n                return;\n              }\n              if (event.getButton() != 1) {\n                return;\n              }\n\n              e.consume();\n\n              DebuggerInvocationUtil.invokeLater(myProject, new Runnable() {\n                public void run() {\n                  Breakpoint breakpoint = toggleBreakpoint(e.getMouseEvent().isAltDown(), line);\n\n                  if(e.getMouseEvent().isShiftDown() && breakpoint != null) {\n                    breakpoint.LOG_EXPRESSION_ENABLED = true;\n                    final TextWithImports logMessage = DebuggerUtilsEx.getEditorText(editor);\n                    breakpoint.setLogMessage(logMessage != null? logMessage : new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, DebuggerBundle.message(\"breakpoint.log.message\", breakpoint.getDisplayName())));\n                    breakpoint.SUSPEND_POLICY = DebuggerSettings.SUSPEND_NONE;\n\n                    DialogWrapper dialog = DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().createConfigurationDialog(breakpoint, BreakpointPropertiesPanel.CONTROL_LOG_MESSAGE);\n                    dialog.show();\n\n                    if(!dialog.isOK()) {\n                      removeBreakpoint(breakpoint);\n                    }\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    };\n\n    eventMulticaster.addEditorMouseListener(myEditorMouseListener);\n    eventMulticaster.addDocumentListener(myDocumentListener);\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean removeBreakpointRule(@NotNull Breakpoint slaveBreakpoint) {\n    for (Iterator<EnableBreakpointRule> it = myBreakpointRules.iterator(); it.hasNext();) {\n      final EnableBreakpointRule rule = it.next();\n      if (slaveBreakpoint.equals(rule.getSlaveBreakpoint())) {\n        removeBreakpointRule(rule);\n        return true;\n      }\n    }\n    return false;\n  }","id":81128,"modified_method":"public boolean removeBreakpointRule(@NotNull Breakpoint slaveBreakpoint) {\n    for (final EnableBreakpointRule rule : myBreakpointRules) {\n      if (slaveBreakpoint.equals(rule.getSlaveBreakpoint())) {\n        removeBreakpointRule(rule);\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"}) public void writeExternal(final Element parentNode) throws WriteExternalException {\n    WriteExternalException ex = PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Computable<WriteExternalException>() {\n      public WriteExternalException compute() {\n        try {\n          removeInvalidBreakpoints();\n          final Map<String, Element> categoryToElementMap = new java.util.HashMap<String, Element>();\n          for (Iterator<Breakpoint> it = getBreakpoints().iterator(); it.hasNext(); ) {\n            final Breakpoint breakpoint = it.next();\n            final String category = breakpoint.getCategory();\n            final Element group = getCategoryGroupElement(categoryToElementMap, category, parentNode);\n            if(breakpoint.isValid()) {\n              writeBreakpoint(group, breakpoint);\n            }\n          }\n          final Element group = getCategoryGroupElement(categoryToElementMap, myAnyExceptionBreakpoint.getCategory(), parentNode);\n          writeBreakpoint(group, myAnyExceptionBreakpoint);\n          \n          final Element rules = new Element(RULES_GROUP_NAME);\n          parentNode.addContent(rules);\n          for (Iterator<EnableBreakpointRule> it = myBreakpointRules.iterator(); it.hasNext();) {\n            writeRule(it.next(), rules);\n          }\n          \n          return null;\n        }\n        catch (WriteExternalException e) {\n          return e;\n        }\n      }\n    });\n    if (ex != null) {\n      throw ex;\n    }\n    \n    final Element props = new Element(\"ui_properties\");\n    parentNode.addContent(props);\n    for (Iterator<String> it = myUIProperties.keySet().iterator(); it.hasNext();) {\n      final String name = it.next();\n      final String value = myUIProperties.get(name);\n      final Element property = new Element(\"property\");\n      props.addContent(property);\n      property.setAttribute(\"name\", name);\n      property.setAttribute(\"value\", value);\n    }\n  }","id":81129,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"}) public void writeExternal(final Element parentNode) throws WriteExternalException {\n    WriteExternalException ex = PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Computable<WriteExternalException>() {\n      public WriteExternalException compute() {\n        try {\n          removeInvalidBreakpoints();\n          final Map<String, Element> categoryToElementMap = new java.util.HashMap<String, Element>();\n          for (final Breakpoint breakpoint : getBreakpoints()) {\n            final String category = breakpoint.getCategory();\n            final Element group = getCategoryGroupElement(categoryToElementMap, category, parentNode);\n            if (breakpoint.isValid()) {\n              writeBreakpoint(group, breakpoint);\n            }\n          }\n          final Element group = getCategoryGroupElement(categoryToElementMap, myAnyExceptionBreakpoint.getCategory(), parentNode);\n          writeBreakpoint(group, myAnyExceptionBreakpoint);\n          \n          final Element rules = new Element(RULES_GROUP_NAME);\n          parentNode.addContent(rules);\n          for (final EnableBreakpointRule myBreakpointRule : myBreakpointRules) {\n            writeRule(myBreakpointRule, rules);\n          }\n\n          return null;\n        }\n        catch (WriteExternalException e) {\n          return e;\n        }\n      }\n    });\n    if (ex != null) {\n      throw ex;\n    }\n    \n    final Element props = new Element(\"ui_properties\");\n    parentNode.addContent(props);\n    for (final String name : myUIProperties.keySet()) {\n      final String value = myUIProperties.get(name);\n      final Element property = new Element(\"property\");\n      props.addContent(property);\n      property.setAttribute(\"name\", name);\n      property.setAttribute(\"value\", value);\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void enableBreakpoints(final DebugProcessImpl debugProcess) {\n    List<Breakpoint> breakpoints = getBreakpoints();\n    for (Iterator<Breakpoint> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      breakpoint.createRequest(debugProcess);\n    }\n  }","id":81130,"modified_method":"public void enableBreakpoints(final DebugProcessImpl debugProcess) {\n    List<Breakpoint> breakpoints = getBreakpoints();\n    for (Breakpoint breakpoint : breakpoints) {\n      breakpoint.createRequest(debugProcess);\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return breakpoints of one of the category:\n   *         LINE_BREAKPOINTS, EXCEPTION_BREKPOINTS, FIELD_BREAKPOINTS, METHOD_BREAKPOINTS\n   */\n  public Breakpoint[] getBreakpoints(final String category) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    removeInvalidBreakpoints();\n\n    final ArrayList<Breakpoint> breakpoints = new ArrayList<Breakpoint>();\n\n    for (Iterator<Breakpoint> iterator = getBreakpoints().iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      if(category.equals(breakpoint.getCategory())) {\n        breakpoints.add(breakpoint);\n      }\n    }\n\n    return breakpoints.toArray(new Breakpoint[breakpoints.size()]);\n  }","id":81131,"modified_method":"/**\n   * @return breakpoints of one of the category:\n   *         LINE_BREAKPOINTS, EXCEPTION_BREKPOINTS, FIELD_BREAKPOINTS, METHOD_BREAKPOINTS\n   */\n  public Breakpoint[] getBreakpoints(final String category) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    removeInvalidBreakpoints();\n\n    final ArrayList<Breakpoint> breakpoints = new ArrayList<Breakpoint>();\n\n    for (Breakpoint breakpoint : getBreakpoints()) {\n      if (category.equals(breakpoint.getCategory())) {\n        breakpoints.add(breakpoint);\n      }\n    }\n\n    return breakpoints.toArray(new Breakpoint[breakpoints.size()]);\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateAllRequests() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n\n    List<Breakpoint> breakpoints = getBreakpoints();\n    for (Iterator<Breakpoint> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      fireBreakpointChanged(breakpoint);\n    }\n  }","id":81132,"modified_method":"public void updateAllRequests() {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n\n    List<Breakpoint> breakpoints = getBreakpoints();\n    for (Breakpoint breakpoint : breakpoints) {\n      fireBreakpointChanged(breakpoint);\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return null if not found or a breakpoint object\n   */\n  public List<BreakpointWithHighlighter> findBreakpoints(final Document document, final int offset) {\n    LinkedList<BreakpointWithHighlighter> result = new LinkedList<BreakpointWithHighlighter>();\n\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    for (Iterator iterator = getBreakpoints().iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = (Breakpoint)iterator.next();\n      if (breakpoint instanceof BreakpointWithHighlighter && ((BreakpointWithHighlighter)breakpoint).isAt(document, offset)) {\n        result.add((BreakpointWithHighlighter)breakpoint);\n      }\n    }\n\n    return result;\n  }","id":81133,"modified_method":"/**\n   * @return null if not found or a breakpoint object\n   */\n  public List<BreakpointWithHighlighter> findBreakpoints(final Document document, final int offset) {\n    LinkedList<BreakpointWithHighlighter> result = new LinkedList<BreakpointWithHighlighter>();\n\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    for (final Breakpoint breakpoint : getBreakpoints()) {\n      if (breakpoint instanceof BreakpointWithHighlighter && ((BreakpointWithHighlighter)breakpoint).isAt(document, offset)) {\n        result.add((BreakpointWithHighlighter)breakpoint);\n      }\n    }\n\n    return result;\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateBreakpoints(final DebugProcessImpl debugProcess) {\n    List<Breakpoint> breakpoints = getBreakpoints();\n    for (Iterator<Breakpoint> iterator = breakpoints.iterator(); iterator.hasNext();) {\n      Breakpoint breakpoint = iterator.next();\n      RequestManagerImpl.updateRequests(breakpoint);\n    }\n  }","id":81134,"modified_method":"public void updateBreakpoints(final DebugProcessImpl debugProcess) {\n    List<Breakpoint> breakpoints = getBreakpoints();\n    for (Breakpoint breakpoint : breakpoints) {\n      RequestManagerImpl.updateRequests(breakpoint);\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setInitialBreakpointsState() {\n    myAllowMulticasting = false;\n    for (Iterator<EnableBreakpointRule> it = myBreakpointRules.iterator(); it.hasNext();) {\n      it.next().init();\n    }\n    myAllowMulticasting = true;\n    if (myBreakpointRules.size() > 0) {\n      IJSwingUtilities.invoke(new Runnable() {\n        public void run() {\n          myDispatcher.getMulticaster().breakpointsChanged();\n        }\n      });\n    }\n  }","id":81135,"modified_method":"public void setInitialBreakpointsState() {\n    myAllowMulticasting = false;\n    for (final EnableBreakpointRule myBreakpointRule : myBreakpointRules) {\n      myBreakpointRule.init();\n    }\n    myAllowMulticasting = true;\n    if (!myBreakpointRules.isEmpty()) {\n      IJSwingUtilities.invoke(new Runnable() {\n        public void run() {\n          myDispatcher.getMulticaster().breakpointsChanged();\n        }\n      });\n    }\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static boolean isPositionValid(final SourcePosition sourcePosition) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){\n      public Boolean compute() {\n        return sourcePosition != null && sourcePosition.getFile().isValid()? Boolean.TRUE : Boolean.FALSE;\n      }\n    }).booleanValue();\n  }","id":81136,"modified_method":"private static boolean isPositionValid(final SourcePosition sourcePosition) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){\n      public Boolean compute() {\n        return sourcePosition != null && sourcePosition.getFile().isValid()? Boolean.TRUE : Boolean.FALSE;\n      }\n    }).booleanValue();\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAt(Document document, int offset) {\n    if (getHighlighter() == null || !getHighlighter().isValid()) {\n      return false;\n    }\n    return document.equals(getHighlighter().getDocument()) && getSourcePosition().getLine() == document.getLineNumber(offset);\n  }","id":81137,"modified_method":"public boolean isAt(Document document, int offset) {\n    RangeHighlighter highlighter = getHighlighter();\n    return highlighter != null\n           && highlighter.isValid()\n           && document.equals(highlighter.getDocument())\n           && getSourcePosition().getLine() == document.getLineNumber(offset);\n  }","commit_id":"e2cf2dc9726f06999a20d9e820bab976eb28e4fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected HighlightInfo getInfo(@NotNull final PsiElement context,\n                                  @NotNull final PsiElement rainbowElement,\n                                  @NotNull final String id,\n                                  @Nullable final TextAttributesKey colorKey) {\n    //noinspection SynchronizationOnLocalVariableOrMethodParameter\n    synchronized (context) {\n      HashMap<String, Integer> id2index = USED_COLORS.getValue(context);\n      Integer colorIndex = id2index.get(id);\n      if (colorIndex == null) {\n        colorIndex = Math.abs(StringHash.murmur(id, 0x55AA));\n\n        Map<Integer, Integer> index2usage = new HashMap<Integer, Integer>();\n        id2index.values().forEach(i -> {\n          Integer useCount = index2usage.get(i);\n          index2usage.put(i, useCount == null ? 1 : ++useCount);\n        });\n\n        int colorsCount = getHighlighter().getColorsCount();\n        out:\n        for (int cutoff = 0; ; ++cutoff) {\n          for (int i = 0; i < colorsCount; ++i) {\n            colorIndex %= colorsCount;\n            Integer useCount = index2usage.get(colorIndex % colorsCount);\n            if (useCount == null) useCount = 0;\n            if (useCount == cutoff) break out;\n            ++colorIndex;\n          }\n        }\n        id2index.put(id, colorIndex);\n      }\n      return getHighlighter().getInfo(colorIndex, rainbowElement, colorKey);\n    }\n  }","id":81138,"modified_method":"protected HighlightInfo getInfo(@NotNull final PsiElement context,\n                                  @NotNull final PsiElement rainbowElement,\n                                  @NotNull final String name,\n                                  @Nullable final TextAttributesKey colorKey) {\n    int colorIndex = UsedColors.getOrAddColorIndex((UserDataHolderEx)context, name, getHighlighter());\n    return getHighlighter().getInfo(colorIndex, rainbowElement, colorKey);\n  }","commit_id":"c6012e98be85b8e11c75ea0dd26ba90b6f05090d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test public void testSimpleOperations() throws Exception {\n        Engine.Searcher searchResult = engine.searcher();\n\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        searchResult.release();\n\n        // create a document\n        engine.create(new Engine.Create(doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        searchResult.release();\n\n        // refresh and it should be there\n        engine.refresh(new Engine.Refresh(true));\n\n        // now its there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        searchResult.release();\n\n        // now do an update\n        engine.index(new Engine.Index(newUid(\"1\"), doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test1\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not updated yet...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // refresh and it should be updated\n        engine.refresh(new Engine.Refresh(true));\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n\n        // now delete\n        engine.delete(new Engine.Delete(newUid(\"1\")));\n\n        // its not deleted yet\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n\n        // refresh and it should be deleted\n        engine.refresh(new Engine.Refresh(true));\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // add it back\n        engine.create(new Engine.Create(doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // refresh and it should be there\n        engine.refresh(new Engine.Refresh(true));\n\n        // now its there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // now flush\n        engine.flush(new Engine.Flush());\n\n        // make sure we can still work with the engine\n        // now do an update\n        engine.index(new Engine.Index(newUid(\"1\"), doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test1\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not updated yet...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // refresh and it should be updated\n        engine.refresh(new Engine.Refresh(true));\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n\n        engine.close();\n\n        // TODO check that operations on engine will throw an EngineAlreadyClosed exception (and while you are at it, create the exception as well)\n\n        // now create a new engine, it should see the flushed changes\n        engine = createEngine(store);\n        engine.start();\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n    }","id":81139,"modified_method":"@Test public void testSimpleOperations() throws Exception {\n        Engine.Searcher searchResult = engine.searcher();\n\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        searchResult.release();\n\n        // create a document\n        engine.create(new Engine.Create(doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        searchResult.release();\n\n        // refresh and it should be there\n        engine.refresh(new Engine.Refresh(true));\n\n        // now its there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        searchResult.release();\n\n        // now do an update\n        engine.index(new Engine.Index(newUid(\"1\"), doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test1\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not updated yet...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // refresh and it should be updated\n        engine.refresh(new Engine.Refresh(true));\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n\n        // now delete\n        engine.delete(new Engine.Delete(newUid(\"1\")));\n\n        // its not deleted yet\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n\n        // refresh and it should be deleted\n        engine.refresh(new Engine.Refresh(true));\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // add it back\n        engine.create(new Engine.Create(doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // refresh and it should be there\n        engine.refresh(new Engine.Refresh(true));\n\n        // now its there...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // now flush\n        engine.flush(new Engine.Flush());\n\n        // make sure we can still work with the engine\n        // now do an update\n        engine.index(new Engine.Index(newUid(\"1\"), doc().add(field(\"_uid\", \"1\")).add(field(\"value\", \"test1\")).build(), Lucene.STANDARD_ANALYZER, \"test\", \"1\", B_1));\n\n        // its not updated yet...\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 0));\n        searchResult.release();\n\n        // refresh and it should be updated\n        engine.refresh(new Engine.Refresh(true));\n\n        searchResult = engine.searcher();\n        assertThat(searchResult, engineSearcherTotalHits(1));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test\")), 0));\n        assertThat(searchResult, engineSearcherTotalHits(new TermQuery(new Term(\"value\", \"test1\")), 1));\n        searchResult.release();\n\n        engine.close();\n    }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private CustomMMapDirectory(File path, boolean syncToDisk) throws IOException {\n            super(path);\n            this.syncToDisk = syncToDisk;\n        }","id":81140,"modified_method":"private CustomMMapDirectory(File path, LockFactory lockFactory, boolean syncToDisk) throws IOException {\n            super(path, lockFactory);\n            this.syncToDisk = syncToDisk;\n        }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public MmapFsStore(ShardId shardId, @IndexSettings Settings indexSettings, Environment environment, @LocalNodeId String localNodeId) throws IOException {\n        super(shardId, indexSettings);\n        // by default, we don't need to sync to disk, since we use the gateway\n        this.syncToDisk = componentSettings.getAsBoolean(\"sync_to_disk\", false);\n        this.fsDirectory = new CustomMMapDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), syncToDisk);\n\n        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory);\n        if (switchDirectory != null) {\n            suggestUseCompoundFile = false;\n            logger.debug(\"Using [mmap_fs] Store with path [{}], cache [true] with extensions [{}]\", new Object[]{fsDirectory.getFile(), switchDirectory.primaryExtensions()});\n            directory = switchDirectory;\n        } else {\n            suggestUseCompoundFile = true;\n            directory = fsDirectory;\n            logger.debug(\"Using [mmap_fs] Store with path [{}]\", fsDirectory.getFile());\n        }\n    }","id":81141,"modified_method":"@Inject public MmapFsStore(ShardId shardId, @IndexSettings Settings indexSettings, Environment environment, @LocalNodeId String localNodeId) throws IOException {\n        super(shardId, indexSettings);\n        // by default, we don't need to sync to disk, since we use the gateway\n        this.syncToDisk = componentSettings.getAsBoolean(\"sync_to_disk\", false);\n        String fsLock = componentSettings.get(\"use_fs_lock\", \"none\");\n        LockFactory lockFactory = new NoLockFactory();\n        if (fsLock.equals(\"native\")) {\n            lockFactory = new NativeFSLockFactory();\n        } else if (fsLock.equals(\"simple\")) {\n            lockFactory = new SimpleFSLockFactory();\n        }\n        this.fsDirectory = new CustomMMapDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), lockFactory, syncToDisk);\n\n        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory);\n        if (switchDirectory != null) {\n            suggestUseCompoundFile = false;\n            logger.debug(\"Using [mmap_fs] Store with path [{}], cache [true] with extensions [{}]\", fsDirectory.getFile(), switchDirectory.primaryExtensions());\n            directory = switchDirectory;\n        } else {\n            suggestUseCompoundFile = true;\n            directory = fsDirectory;\n            logger.debug(\"Using [mmap_fs] Store with path [{}]\", fsDirectory.getFile());\n        }\n    }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private CustomNioFSDirectory(File path, boolean syncToDisk) throws IOException {\n            super(path);\n            this.syncToDisk = syncToDisk;\n        }","id":81142,"modified_method":"private CustomNioFSDirectory(File path, LockFactory lockFactory, boolean syncToDisk) throws IOException {\n            super(path, lockFactory);\n            this.syncToDisk = syncToDisk;\n        }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public NioFsStore(ShardId shardId, @IndexSettings Settings indexSettings, Environment environment, @LocalNodeId String localNodeId) throws IOException {\n        super(shardId, indexSettings);\n        // by default, we don't need to sync to disk, since we use the gateway\n        this.syncToDisk = componentSettings.getAsBoolean(\"sync_to_disk\", false);\n        this.fsDirectory = new CustomNioFSDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), syncToDisk);\n\n        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory);\n        if (switchDirectory != null) {\n            suggestUseCompoundFile = false;\n            logger.debug(\"Using [nio_fs] Store with path [{}], cache [true] with extensions [{}]\", new Object[]{fsDirectory.getFile(), switchDirectory.primaryExtensions()});\n            directory = switchDirectory;\n        } else {\n            suggestUseCompoundFile = true;\n            directory = fsDirectory;\n            logger.debug(\"Using [nio_fs] Store with path [{}]\", fsDirectory.getFile());\n        }\n    }","id":81143,"modified_method":"@Inject public NioFsStore(ShardId shardId, @IndexSettings Settings indexSettings, Environment environment, @LocalNodeId String localNodeId) throws IOException {\n        super(shardId, indexSettings);\n        // by default, we don't need to sync to disk, since we use the gateway\n        this.syncToDisk = componentSettings.getAsBoolean(\"sync_to_disk\", false);\n        String fsLock = componentSettings.get(\"use_fs_lock\", \"none\");\n        LockFactory lockFactory = new NoLockFactory();\n        if (fsLock.equals(\"native\")) {\n            lockFactory = new NativeFSLockFactory();\n        } else if (fsLock.equals(\"simple\")) {\n            lockFactory = new SimpleFSLockFactory();\n        }\n        this.fsDirectory = new CustomNioFSDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), lockFactory, syncToDisk);\n\n        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory);\n        if (switchDirectory != null) {\n            suggestUseCompoundFile = false;\n            logger.debug(\"Using [nio_fs] Store with path [{}], cache [true] with extensions [{}]\", fsDirectory.getFile(), switchDirectory.primaryExtensions());\n            directory = switchDirectory;\n        } else {\n            suggestUseCompoundFile = true;\n            directory = fsDirectory;\n            logger.debug(\"Using [nio_fs] Store with path [{}]\", fsDirectory.getFile());\n        }\n    }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public RobinEngine(ShardId shardId, @IndexSettings Settings indexSettings, Store store, SnapshotDeletionPolicy deletionPolicy, Translog translog,\n                               MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler,\n                               AnalysisService analysisService, SimilarityService similarityService) throws EngineException {\n        super(shardId, indexSettings);\n        Preconditions.checkNotNull(store, \"Store must be provided to the engine\");\n        Preconditions.checkNotNull(deletionPolicy, \"Snapshot deletion policy must be provided to the engine\");\n        Preconditions.checkNotNull(translog, \"Translog must be provided to the engine\");\n\n        this.ramBufferSize = componentSettings.getAsSize(\"ram_buffer_size\", new SizeValue(64, SizeUnit.MB));\n        this.refreshInterval = componentSettings.getAsTime(\"refresh_interval\", timeValueSeconds(1));\n        this.termIndexInterval = componentSettings.getAsInt(\"term_index_interval\", IndexWriter.DEFAULT_TERM_INDEX_INTERVAL);\n\n        this.store = store;\n        this.deletionPolicy = deletionPolicy;\n        this.translog = translog;\n        this.mergePolicyProvider = mergePolicyProvider;\n        this.mergeScheduler = mergeScheduler;\n        this.analysisService = analysisService;\n        this.similarityService = similarityService;\n    }","id":81144,"modified_method":"@Inject public RobinEngine(ShardId shardId, @IndexSettings Settings indexSettings, Store store, SnapshotDeletionPolicy deletionPolicy, Translog translog,\n                               MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler,\n                               AnalysisService analysisService, SimilarityService similarityService) throws EngineException {\n        super(shardId, indexSettings);\n        Preconditions.checkNotNull(store, \"Store must be provided to the engine\");\n        Preconditions.checkNotNull(deletionPolicy, \"Snapshot deletion policy must be provided to the engine\");\n        Preconditions.checkNotNull(translog, \"Translog must be provided to the engine\");\n\n        this.ramBufferSize = componentSettings.getAsSize(\"ram_buffer_size\", new SizeValue(64, SizeUnit.MB));\n        this.refreshInterval = componentSettings.getAsTime(\"refresh_interval\", timeValueSeconds(1));\n        this.termIndexInterval = componentSettings.getAsInt(\"term_index_interval\", IndexWriter.DEFAULT_TERM_INDEX_INTERVAL);\n\n        this.store = store;\n        this.deletionPolicy = deletionPolicy;\n        this.translog = translog;\n        this.mergePolicyProvider = mergePolicyProvider;\n        this.mergeScheduler = mergeScheduler;\n        this.analysisService = analysisService;\n        this.similarityService = similarityService;\n\n        // clear the index dir by creating a new index\n        try {\n            // release locks when started\n            if (IndexWriter.isLocked(store.directory())) {\n                logger.trace(\"Shard is locked, releasing lock\");\n                store.directory().clearLock(IndexWriter.WRITE_LOCK_NAME);\n            }\n            IndexWriter writer = new IndexWriter(store.directory(), analysisService.defaultIndexAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n            writer.commit();\n            writer.close();\n        } catch (IOException e) {\n            logger.warn(\"Failed to clean the index\", e);\n        }\n    }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public SimpleFsStore(ShardId shardId, @IndexSettings Settings indexSettings, Environment environment, @LocalNodeId String localNodeId) throws IOException {\n        super(shardId, indexSettings);\n        // by default, we don't need to sync to disk, since we use the gateway\n        this.syncToDisk = componentSettings.getAsBoolean(\"sync_to_disk\", false);\n        this.fsDirectory = new CustomSimpleFSDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), syncToDisk);\n\n        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory);\n        if (switchDirectory != null) {\n            suggestUseCompoundFile = false;\n            logger.debug(\"Using [simple_fs] Store with path [{}], cache [true] with extensions [{}]\", new Object[]{fsDirectory.getFile(), switchDirectory.primaryExtensions()});\n            directory = switchDirectory;\n        } else {\n            suggestUseCompoundFile = true;\n            directory = fsDirectory;\n            logger.debug(\"Using [simple_fs] Store with path [{}]\", fsDirectory.getFile());\n        }\n    }","id":81145,"modified_method":"@Inject public SimpleFsStore(ShardId shardId, @IndexSettings Settings indexSettings, Environment environment, @LocalNodeId String localNodeId) throws IOException {\n        super(shardId, indexSettings);\n        // by default, we don't need to sync to disk, since we use the gateway\n        this.syncToDisk = componentSettings.getAsBoolean(\"sync_to_disk\", false);\n        String fsLock = componentSettings.get(\"use_fs_lock\", \"none\");\n        LockFactory lockFactory = new NoLockFactory();\n        if (fsLock.equals(\"native\")) {\n            lockFactory = new NativeFSLockFactory();\n        } else if (fsLock.equals(\"simple\")) {\n            lockFactory = new SimpleFSLockFactory();\n        }\n        this.fsDirectory = new CustomSimpleFSDirectory(createStoreFilePath(environment.workWithClusterFile(), localNodeId, shardId, MAIN_INDEX_SUFFIX), lockFactory, syncToDisk);\n\n        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory);\n        if (switchDirectory != null) {\n            suggestUseCompoundFile = false;\n            logger.debug(\"Using [simple_fs] Store with path [{}], cache [true] with extensions [{}]\", fsDirectory.getFile(), switchDirectory.primaryExtensions());\n            directory = switchDirectory;\n        } else {\n            suggestUseCompoundFile = true;\n            directory = fsDirectory;\n            logger.debug(\"Using [simple_fs] Store with path [{}]\", fsDirectory.getFile());\n        }\n    }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private CustomSimpleFSDirectory(File path, boolean syncToDisk) throws IOException {\n            super(path);\n            this.syncToDisk = syncToDisk;\n        }","id":81146,"modified_method":"private CustomSimpleFSDirectory(File path, LockFactory lockFactory, boolean syncToDisk) throws IOException {\n            super(path, lockFactory);\n            this.syncToDisk = syncToDisk;\n        }","commit_id":"26364afd7e9e377b8449ab0c2ad3ac301f3bebf6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        if (post == null) {\r\n            prop.put(\"info\", 1);//no information submitted\r\n            return prop;\r\n        }\r\n        \r\n        // admin password\r\n        if (post.containsKey(\"adminaccount\")) {\r\n            // read and process data\r\n            String user   = (String) post.get(\"adminuser\");\r\n            String pw1    = (String) post.get(\"adminpw1\");\r\n            String pw2    = (String) post.get(\"adminpw2\");\r\n            // do checks\r\n            if ((user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            // check passed. set account:\r\n            env.setConfig(\"adminAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"adminAccount\", \"\");\r\n            prop.put(\"info\", 5);//admin account changed\r\n            prop.put(\"info_user\", user);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // proxy password\r\n        if (post.containsKey(\"proxyaccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"proxyfilter\");\r\n            String user   = (String) post.get(\"proxyuser\");\r\n            String pw1    = (String) post.get(\"proxypw1\");\r\n            String pw2    = (String) post.get(\"proxypw2\");\r\n            // do checks\r\n            if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"proxyClient\", filter);\r\n            if (pw1.length() == 0) {\r\n                // only ip filter setting without account\r\n                env.setConfig(\"proxyAccountBase64MD5\", \"\");\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 6);//proxy account has changed(no pw)\r\n                prop.put(\"info_filter\", filter);\r\n            } else {\r\n                // also paccount setting\r\n                env.setConfig(\"proxyAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 7);//proxy account has changed\r\n                prop.put(\"info_user\", user);\r\n                prop.put(\"info_filter\", filter);\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        // server password\r\n        if (post.containsKey(\"serveraccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"serverfilter\");\r\n            String user   = (String) post.get(\"serveruser\");\r\n            String pw1    = (String) post.get(\"serverpw1\");\r\n            String pw2    = (String) post.get(\"serverpw2\");\r\n            // do checks\r\n            if (filter == null) {\r\n                //if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"serverClient\", filter);\r\n            env.setConfig(\"serverAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"serverAccount\", \"\");\r\n            \r\n            prop.put(\"info\", 8);//server access filter updated\r\n            prop.put(\"info_user\", user);\r\n            prop.put(\"info_filter\", filter);\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"dispop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"false\");\r\n            prop.put(\"info\", 9);//popup disabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"enpop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"true\");\r\n            prop.put(\"info\", 10);//popup enabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"pmode\")) {\r\n            env.setConfig(\"onlineMode\", \"2\");\r\n            prop.put(\"info\", 11);//permanent online mode\r\n            yacyCore.triggerOnlineAction();\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"generalsettings\")) {\r\n            String port = (String) post.get(\"port\");\r\n            String peerName = (String) post.get(\"peername\");\r\n            \r\n            httpdProxyHandler.isTransparentProxy = post.containsKey(\"isTransparentProxy\");\r\n            \r\n            // check if peer name already exists\r\n            yacySeed oldSeed = yacyCore.seedDB.lookupByName(peerName);\r\n            \r\n            if ((oldSeed == null) || (env.getConfig(\"peerName\",\"\").equals(peerName))) {\r\n                // the name is new\r\n                boolean nameOK = (peerName.length() <= 80);\r\n                for (int i = 0; i < peerName.length(); i++) {\r\n                    if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\".indexOf(peerName.charAt(i)) < 0) nameOK = false;\r\n                }\r\n                if (!(nameOK)) {\r\n                    // deny change\r\n                    prop.put(\"info\", 17);//peer name is wrong\r\n                } else {\r\n                    \r\n                    // set values\r\n                    env.setConfig(\"port\", port);\r\n                    env.setConfig(\"peerName\", peerName);\r\n                    env.setConfig(\"isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"true\" : \"false\");                    \r\n                    \r\n                    prop.put(\"info\", 12);//port or peername changed\r\n                    prop.put(\"info_port\", port);\r\n                    prop.put(\"info_peerName\", peerName);\r\n                    prop.put(\"info_isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"on\" : \"off\");\r\n                }\r\n            } else {\r\n                // deny change\r\n                prop.put(\"info\", 16);//peer name is already used by another peer\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"proxysettings\")) {\r\n            httpdProxyHandler.remoteProxyUse = ((String) post.get(\"remoteProxyUse\", \"\")).equals(\"on\");\r\n            httpdProxyHandler.remoteProxyHost = (String) post.get(\"remoteProxyHost\", \"\");\r\n            try {\r\n                httpdProxyHandler.remoteProxyPort = Integer.parseInt((String) post.get(\"remoteProxyPort\", \"\"));\r\n            } catch (NumberFormatException e) {\r\n                httpdProxyHandler.remoteProxyPort = 3128;\r\n            }\r\n            httpdProxyHandler.remoteProxyNoProxy = (String) post.get(\"remoteProxyNoProxy\", \"\");\r\n            httpdProxyHandler.remoteProxyNoProxyPatterns = httpdProxyHandler.remoteProxyNoProxy.split(\",\");\r\n            env.setConfig(\"remoteProxyHost\", httpdProxyHandler.remoteProxyHost);\r\n            env.setConfig(\"remoteProxyPort\", \"\" + httpdProxyHandler.remoteProxyPort);\r\n            env.setConfig(\"remoteProxyNoProxy\", httpdProxyHandler.remoteProxyNoProxy);\r\n            env.setConfig(\"remoteProxyUse\", (httpdProxyHandler.remoteProxyUse) ? \"true\" : \"false\");\r\n            prop.put(\"info\", 15); // The remote-proxy setting has been changed\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedSettings\")) {            \r\n            try {\r\n                // getting the currently used uploading method\r\n                String oldSeedUploadMethod = env.getConfig(\"seedUploadMethod\",\"none\");\r\n                String newSeedUploadMethod = (String)post.get(\"seedUploadMethod\");\r\n                String oldSeedURLStr = env.getConfig(\"seedURL\",\"\");\r\n                String newSeedURLStr = (String)post.get(\"seedURL\");\r\n                new URL(newSeedURLStr);\r\n                \r\n                boolean seedUrlChanged = !oldSeedURLStr.equals(newSeedURLStr);\r\n                boolean uploadMethodChanged = !oldSeedUploadMethod.equals(newSeedUploadMethod);\r\n                if (uploadMethodChanged) {\r\n                    uploadMethodChanged = yacyCore.changeSeedUploadMethod(newSeedUploadMethod); \r\n                }\r\n\r\n                if (seedUrlChanged || uploadMethodChanged) {\r\n                    env.setConfig(\"seedUploadMethod\", newSeedUploadMethod);\r\n                    env.setConfig(\"seedURL\", newSeedURLStr);\r\n                    \r\n                    // trying to upload the seed-list file\r\n                    yacyCore.saveSeedList(env);\r\n                    \r\n                    // we have successfully uploaded the seed-list file\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",(newSeedUploadMethod.equalsIgnoreCase(\"none\")?0:1));\r\n                    prop.put(\"info\", 19);                                     \r\n                } else {\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",0);\r\n                    prop.put(\"info\", 19);                    \r\n                    \r\n                }\r\n            } catch (Exception e) {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\"); \r\n            }\r\n            return prop;            \r\n        }\r\n        \r\n        /* \r\n         * Loop through the available seed uploaders to see if the \r\n         * configuration of one of them has changed \r\n         */\r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            // getting the uploader module name\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            \r\n            \r\n            // determining if the user has reconfigured the settings of this uploader\r\n            if (post.containsKey(\"seed\" + uploaderName + \"Settings\")) {\r\n                nothingChanged = true;\r\n                yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n                String[] configOptions = theUploader.getConfigurationOptions();\r\n                if (configOptions != null) {\r\n                    for (int i=0; i<configOptions.length; i++) {\r\n                        String newSettings = post.get(configOptions[i],\"\");\r\n                        String oldSettings = env.getConfig(configOptions[i],\"\");\r\n                        nothingChanged &= newSettings.equals(oldSettings); \r\n                        if (!nothingChanged) {\r\n                            env.setConfig(configOptions[i],newSettings);\r\n                        }\r\n                    }\r\n                }   \r\n                if (!nothingChanged) {\r\n                    // if the seed upload method is equal to the seed uploader whose settings\r\n                    // were changed, we now try to upload the seed list with the new settings\r\n                    if (env.getConfig(\"seedUploadMethod\",\"none\").equalsIgnoreCase(uploaderName)) {\r\n                        try {\r\n                            yacyCore.saveSeedList(env);\r\n                            \r\n                            // we have successfully uploaded the seed file\r\n                            prop.put(\"info\", 13);\r\n                            prop.put(\"info_success\",1);\r\n                        } catch (Exception e) {\r\n                            // if uploading failed we print out an error message\r\n                            prop.put(\"info\", 14);\r\n                            prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                            env.setConfig(\"seedUploadMethod\",\"none\");                            \r\n                        }                       \r\n                    } else {\r\n                        prop.put(\"info\", 13);\r\n                        prop.put(\"info_success\",0);\r\n                    }\r\n                } else {\r\n                    prop.put(\"info\", 13);\r\n                    prop.put(\"info_success\",0);\r\n                }\r\n                return prop;\r\n            }            \r\n        }\r\n        \r\n\r\n        \r\n        if (post.containsKey(\"parserSettings\")) {   \r\n            plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n\t\t\tpost.remove(\"parserSettings\");\r\n            \r\n            String[] enabledMimes = null;\r\n            if (post.containsKey(\"allParserEnabled\")) {\r\n                // enable all available parsers\r\n                enabledMimes = sb.parser.setEnabledParserList(sb.parser.getAvailableParserList().keySet());\r\n            } else {\r\n                // activate all received parsers       \r\n                enabledMimes = sb.parser.setEnabledParserList(post.keySet());\r\n            }\r\n            Arrays.sort(enabledMimes);\r\n            \r\n            StringBuffer enabledMimesTxt = new StringBuffer();\r\n            for (int i=0; i < enabledMimes.length; i++) {\r\n                enabledMimesTxt.append(enabledMimes[i]).append(\",\");\r\n                prop.put(\"info_parser_\" + i + \"_enabledMime\",enabledMimes[i]);\r\n            }\r\n            prop.put(\"info_parser\",enabledMimes.length);\r\n            if (enabledMimesTxt.length() > 0) enabledMimesTxt.deleteCharAt(enabledMimesTxt.length()-1);            \r\n            \r\n            env.setConfig(\"parseableMimeTypes\",enabledMimesTxt.toString());\r\n            \r\n            prop.put(\"info\", 18);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // nothing made\r\n        prop.put(\"info\", 1);//no information submitted\r\n        return prop;\r\n    }","id":81147,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        if (post == null) {\r\n            prop.put(\"info\", 1);//no information submitted\r\n            return prop;\r\n        }\r\n        \r\n        // admin password\r\n        if (post.containsKey(\"adminaccount\")) {\r\n            // read and process data\r\n            String user   = (String) post.get(\"adminuser\");\r\n            String pw1    = (String) post.get(\"adminpw1\");\r\n            String pw2    = (String) post.get(\"adminpw2\");\r\n            // do checks\r\n            if ((user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            // check passed. set account:\r\n            env.setConfig(\"adminAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"adminAccount\", \"\");\r\n            prop.put(\"info\", 5);//admin account changed\r\n            prop.put(\"info_user\", user);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // proxy password\r\n        if (post.containsKey(\"proxyaccount\")) {\r\n\t    // set new port\r\n            String port = (String) post.get(\"port\");\r\n\t    env.setConfig(\"port\", port);\r\n\t    prop.put(\"info_port\", port);\r\n\r\n\t    // set transparent proxy flag\r\n            httpdProxyHandler.isTransparentProxy = post.containsKey(\"isTransparentProxy\");\r\n\t    env.setConfig(\"isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"true\" : \"false\");\r\n\t    prop.put(\"info_isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"on\" : \"off\");\r\n\r\n            // read and process data\r\n            String filter = (String) post.get(\"proxyfilter\");\r\n            String user   = (String) post.get(\"proxyuser\");\r\n            String pw1    = (String) post.get(\"proxypw1\");\r\n            String pw2    = (String) post.get(\"proxypw2\");\r\n            // do checks\r\n            if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"proxyClient\", filter);\r\n            if (pw1.length() == 0) {\r\n                // only ip filter setting without account\r\n                env.setConfig(\"proxyAccountBase64MD5\", \"\");\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 6);//proxy account has changed(no pw)\r\n                prop.put(\"info_filter\", filter);\r\n            } else {\r\n                // also paccount setting\r\n                env.setConfig(\"proxyAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 7);//proxy account has changed\r\n                prop.put(\"info_user\", user);\r\n                prop.put(\"info_filter\", filter);\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        // server password\r\n        if (post.containsKey(\"serveraccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"serverfilter\");\r\n            String user   = (String) post.get(\"serveruser\");\r\n            String pw1    = (String) post.get(\"serverpw1\");\r\n            String pw2    = (String) post.get(\"serverpw2\");\r\n            // do checks\r\n            if (filter == null) {\r\n                //if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"serverClient\", filter);\r\n            env.setConfig(\"serverAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"serverAccount\", \"\");\r\n            \r\n            prop.put(\"info\", 8);//server access filter updated\r\n            prop.put(\"info_user\", user);\r\n            prop.put(\"info_filter\", filter);\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"dispop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"false\");\r\n            prop.put(\"info\", 9);//popup disabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"enpop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"true\");\r\n            prop.put(\"info\", 10);//popup enabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"pmode\")) {\r\n            env.setConfig(\"onlineMode\", \"2\");\r\n            prop.put(\"info\", 11);//permanent online mode\r\n            yacyCore.triggerOnlineAction();\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"generalsettings\")) {\r\n\t    // set peer language\r\n            String peerLang = (String) post.get(\"peerlang\");\r\n            if ((peerLang == null) || (peerLang.equals(\"en\"))) peerLang = \"default\";\r\n\t    HashMap lm = langMap(env);\r\n\t    if (!(lm.containsKey(peerLang))) peerLang = \"default\";\r\n\t    env.setConfig(\"htLocaleSelection\", peerLang);\r\n\t    prop.put(\"info_peerLang\", (String) lm.get(peerLang));\r\n\r\n            // check if peer name already exists\r\n            String peerName = (String) post.get(\"peername\");\r\n            yacySeed oldSeed = yacyCore.seedDB.lookupByName(peerName);\r\n            \r\n            if ((oldSeed == null) || (env.getConfig(\"peerName\",\"\").equals(peerName))) {\r\n                // the name is new\r\n                boolean nameOK = (peerName.length() <= 80);\r\n                for (int i = 0; i < peerName.length(); i++) {\r\n                    if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\".indexOf(peerName.charAt(i)) < 0) nameOK = false;\r\n                }\r\n                if (!(nameOK)) {\r\n                    // deny change\r\n                    prop.put(\"info\", 17);//peer name is wrong\r\n                } else {\r\n                    \r\n                    // set values\r\n                    env.setConfig(\"peerName\", peerName);\r\n                    prop.put(\"info\", 12);//port or peername changed\r\n                    prop.put(\"info_peerName\", peerName);\r\n                }\r\n            } else {\r\n                // deny change\r\n                prop.put(\"info\", 16);//peer name is already used by another peer\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"proxysettings\")) {\r\n            httpdProxyHandler.remoteProxyUse = ((String) post.get(\"remoteProxyUse\", \"\")).equals(\"on\");\r\n            httpdProxyHandler.remoteProxyHost = (String) post.get(\"remoteProxyHost\", \"\");\r\n            try {\r\n                httpdProxyHandler.remoteProxyPort = Integer.parseInt((String) post.get(\"remoteProxyPort\", \"\"));\r\n            } catch (NumberFormatException e) {\r\n                httpdProxyHandler.remoteProxyPort = 3128;\r\n            }\r\n            httpdProxyHandler.remoteProxyNoProxy = (String) post.get(\"remoteProxyNoProxy\", \"\");\r\n            httpdProxyHandler.remoteProxyNoProxyPatterns = httpdProxyHandler.remoteProxyNoProxy.split(\",\");\r\n            env.setConfig(\"remoteProxyHost\", httpdProxyHandler.remoteProxyHost);\r\n            env.setConfig(\"remoteProxyPort\", \"\" + httpdProxyHandler.remoteProxyPort);\r\n            env.setConfig(\"remoteProxyNoProxy\", httpdProxyHandler.remoteProxyNoProxy);\r\n            env.setConfig(\"remoteProxyUse\", (httpdProxyHandler.remoteProxyUse) ? \"true\" : \"false\");\r\n            prop.put(\"info\", 15); // The remote-proxy setting has been changed\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedSettings\")) {            \r\n            try {\r\n                // getting the currently used uploading method\r\n                String oldSeedUploadMethod = env.getConfig(\"seedUploadMethod\",\"none\");\r\n                String newSeedUploadMethod = (String)post.get(\"seedUploadMethod\");\r\n                String oldSeedURLStr = env.getConfig(\"seedURL\",\"\");\r\n                String newSeedURLStr = (String)post.get(\"seedURL\");\r\n                new URL(newSeedURLStr);\r\n                \r\n                boolean seedUrlChanged = !oldSeedURLStr.equals(newSeedURLStr);\r\n                boolean uploadMethodChanged = !oldSeedUploadMethod.equals(newSeedUploadMethod);\r\n                if (uploadMethodChanged) {\r\n                    uploadMethodChanged = yacyCore.changeSeedUploadMethod(newSeedUploadMethod); \r\n                }\r\n\r\n                if (seedUrlChanged || uploadMethodChanged) {\r\n                    env.setConfig(\"seedUploadMethod\", newSeedUploadMethod);\r\n                    env.setConfig(\"seedURL\", newSeedURLStr);\r\n                    \r\n                    // trying to upload the seed-list file\r\n                    yacyCore.saveSeedList(env);\r\n                    \r\n                    // we have successfully uploaded the seed-list file\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",(newSeedUploadMethod.equalsIgnoreCase(\"none\")?0:1));\r\n                    prop.put(\"info\", 19);                                     \r\n                } else {\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",0);\r\n                    prop.put(\"info\", 19);                    \r\n                    \r\n                }\r\n            } catch (Exception e) {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\"); \r\n            }\r\n            return prop;            \r\n        }\r\n        \r\n        /* \r\n         * Loop through the available seed uploaders to see if the \r\n         * configuration of one of them has changed \r\n         */\r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            // getting the uploader module name\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            \r\n            \r\n            // determining if the user has reconfigured the settings of this uploader\r\n            if (post.containsKey(\"seed\" + uploaderName + \"Settings\")) {\r\n                nothingChanged = true;\r\n                yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n                String[] configOptions = theUploader.getConfigurationOptions();\r\n                if (configOptions != null) {\r\n                    for (int i=0; i<configOptions.length; i++) {\r\n                        String newSettings = post.get(configOptions[i],\"\");\r\n                        String oldSettings = env.getConfig(configOptions[i],\"\");\r\n                        nothingChanged &= newSettings.equals(oldSettings); \r\n                        if (!nothingChanged) {\r\n                            env.setConfig(configOptions[i],newSettings);\r\n                        }\r\n                    }\r\n                }   \r\n                if (!nothingChanged) {\r\n                    // if the seed upload method is equal to the seed uploader whose settings\r\n                    // were changed, we now try to upload the seed list with the new settings\r\n                    if (env.getConfig(\"seedUploadMethod\",\"none\").equalsIgnoreCase(uploaderName)) {\r\n                        try {\r\n                            yacyCore.saveSeedList(env);\r\n                            \r\n                            // we have successfully uploaded the seed file\r\n                            prop.put(\"info\", 13);\r\n                            prop.put(\"info_success\",1);\r\n                        } catch (Exception e) {\r\n                            // if uploading failed we print out an error message\r\n                            prop.put(\"info\", 14);\r\n                            prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                            env.setConfig(\"seedUploadMethod\",\"none\");                            \r\n                        }                       \r\n                    } else {\r\n                        prop.put(\"info\", 13);\r\n                        prop.put(\"info_success\",0);\r\n                    }\r\n                } else {\r\n                    prop.put(\"info\", 13);\r\n                    prop.put(\"info_success\",0);\r\n                }\r\n                return prop;\r\n            }            \r\n        }\r\n        \r\n        if (post.containsKey(\"parserSettings\")) {   \r\n            plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n\t\t\tpost.remove(\"parserSettings\");\r\n            \r\n            String[] enabledMimes = null;\r\n            if (post.containsKey(\"allParserEnabled\")) {\r\n                // enable all available parsers\r\n                enabledMimes = sb.parser.setEnabledParserList(sb.parser.getAvailableParserList().keySet());\r\n            } else {\r\n                // activate all received parsers       \r\n                enabledMimes = sb.parser.setEnabledParserList(post.keySet());\r\n            }\r\n            Arrays.sort(enabledMimes);\r\n            \r\n            StringBuffer enabledMimesTxt = new StringBuffer();\r\n            for (int i=0; i < enabledMimes.length; i++) {\r\n                enabledMimesTxt.append(enabledMimes[i]).append(\",\");\r\n                prop.put(\"info_parser_\" + i + \"_enabledMime\",enabledMimes[i]);\r\n            }\r\n            prop.put(\"info_parser\",enabledMimes.length);\r\n            if (enabledMimesTxt.length() > 0) enabledMimesTxt.deleteCharAt(enabledMimesTxt.length()-1);            \r\n            \r\n            env.setConfig(\"parseableMimeTypes\",enabledMimesTxt.toString());\r\n            \r\n            prop.put(\"info\", 18);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // nothing made\r\n        prop.put(\"info\", 1);//no information submitted\r\n        return prop;\r\n    }","commit_id":"6f09251bbc85cf22ec0b7c23f3ecbb6147d2b912","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        prop.put(\"port\", env.getConfig(\"port\", \"8080\"));\r\n        prop.put(\"peerName\", env.getConfig(\"peerName\", \"nameless\"));\r\n        prop.put(\"isTransparentProxy\", env.getConfig(\"isTransparentProxy\", \"false\").equals(\"true\") ? 1 : 0);\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        // admin password\r\n        if (env.getConfig(\"adminAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"adminuser\",\"admin\");\r\n        } else {\r\n            s = env.getConfig(\"adminAccount\", \"admin:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"adminuser\",\"admin\");\r\n            } else {\r\n                prop.put(\"adminuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // remote proxy\r\n        prop.put(\"remoteProxyHost\", env.getConfig(\"remoteProxyHost\", \"\"));\r\n        prop.put(\"remoteProxyPort\", env.getConfig(\"remoteProxyPort\", \"\"));\r\n        prop.put(\"remoteProxyNoProxy\", env.getConfig(\"remoteProxyNoProxy\", \"\"));\r\n        prop.put(\"remoteProxyUseChecked\", ((String) env.getConfig(\"remoteProxyUse\", \"false\")).equals(\"true\") ? 1 : 0);\r\n        \r\n        // proxy access filter\r\n        prop.put(\"proxyfilter\", env.getConfig(\"proxyClient\", \"*\"));\r\n        \r\n        // proxy password\r\n        if (env.getConfig(\"proxyAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"proxyuser\",\"proxy\");\r\n        } else {\r\n            s = env.getConfig(\"proxyAccount\", \"proxy:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"proxyuser\",\"proxy\");\r\n            } else {\r\n                prop.put(\"proxyuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // server access filter\r\n        prop.put(\"serverfilter\", env.getConfig(\"serverClient\", \"*\"));\r\n        \r\n        // server password\r\n        if (env.getConfig(\"serverAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"serveruser\",\"server\");\r\n        } else {\r\n            s = env.getConfig(\"serverAccount\", \"server:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"serveruser\",\"server\");\r\n            } else {\r\n                prop.put(\"serveruser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // clientIP\r\n        prop.put(\"clientIP\", (String) header.get(\"CLIENTIP\", \"<unknown>\")); // read an artificial header addendum\r\n        \r\n        /* \r\n         * seed upload settings\r\n         */\r\n        // available methods\r\n        String enabledUploader = env.getConfig(\"seedUploadMethod\", \"none\");\r\n        \r\n        // for backward compatiblity ....\r\n        if ((enabledUploader.equalsIgnoreCase(\"Ftp\")) || \r\n                ((enabledUploader.equals(\"\")) &&\r\n                 (env.getConfig(\"seedFTPPassword\",\"\").length() > 0) &&\r\n                 (env.getConfig(\"seedFilePath\", \"\").length() > 0))) {\r\n            enabledUploader = \"Ftp\";\r\n            env.setConfig(\"seedUploadMethod\",enabledUploader);\r\n        }                  \r\n        \r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        prop.put(\"seedUploadMethods\", uploaders.size() + 1);\r\n        prop.put(\"seedUploadMethods_0_name\", \"none\");\r\n        prop.put(\"seedUploadMethods_0_selected\", enabledUploader.equals(\"none\")?1:0);\r\n        prop.put(\"seedUploadMethods_0_file\", \"\");\r\n        \r\n        int count = 0;\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            count++;\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_name\", uploaderName);\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_selected\", uploaderName.equals(enabledUploader)?1:0);            \r\n            prop.put(\"seedUploadMethods_\" +count+ \"_file\", \"yacy/seedUpload/yacySeedUpload\" + uploaderName + \".html\");\r\n            \r\n            yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n            String[] configOptions = theUploader.getConfigurationOptions();\r\n            if (configOptions != null) {\r\n                for (int i=0; i<configOptions.length; i++) {\r\n                    prop.put(\"seedUploadMethods_\" +count+ \"_\" + configOptions[i], env.getConfig(configOptions[i], \"\"));\r\n                    // prop.put(\"seedUpload\" + uploaderName,1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // general settings\r\n        prop.put(\"seedURL\", env.getConfig(\"seedURL\", \"\"));\r\n        \r\n        \r\n        /*\r\n         * Parser Configuration\r\n         */\r\n        plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n        Hashtable enabledParsers = sb.parser.getEnabledParserList();\r\n        Hashtable availableParsers = sb.parser.getAvailableParserList();\r\n        \r\n        // fetching a list of all available mimetypes\r\n        List availableParserKeys = Arrays.asList(availableParsers.keySet().toArray(new String[availableParsers.size()]));\r\n        \r\n        // sort it\r\n        Collections.sort(availableParserKeys);\r\n        \r\n        // loop through the mimeTypes and add it to the properties\r\n        boolean allParsersEnabled = true;\r\n        int parserIdx = 0;\r\n        Iterator availableParserIter = availableParserKeys.iterator();\r\n        while (availableParserIter.hasNext()) {\r\n            String mimeType = (String) availableParserIter.next();\r\n            String parserName = (String) availableParsers.get(mimeType);\r\n            boolean parserIsEnabled = enabledParsers.containsKey(mimeType);\r\n            \r\n            prop.put(\"parser_\" + parserIdx + \"_mime\", mimeType);\r\n            prop.put(\"parser_\" + parserIdx + \"_name\", parserName);\r\n            prop.put(\"parser_\" + parserIdx + \"_shortname\", parserName.substring(parserName.lastIndexOf(\".\")+1));\r\n            prop.put(\"parser_\" + parserIdx + \"_status\", parserIsEnabled ? 1:0);\r\n            allParsersEnabled &= parserIsEnabled;\r\n            \r\n            parserIdx++;\r\n        }\r\n        \r\n        prop.put(\"allParserEnabled\",allParsersEnabled ? 1:0);\r\n        prop.put(\"parser\", parserIdx);\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":81148,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        prop.put(\"port\", env.getConfig(\"port\", \"8080\"));\r\n        prop.put(\"isTransparentProxy\", env.getConfig(\"isTransparentProxy\", \"false\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"peerName\", env.getConfig(\"peerName\", \"nameless\"));\r\n\tString peerLang = env.getConfig(\"htLocaleSelection\", \"default\");\r\n\tif (peerLang.equals(\"default\")) peerLang = \"en\";\r\n        prop.put(\"peerLang\", peerLang);\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        // admin password\r\n        if (env.getConfig(\"adminAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"adminuser\",\"admin\");\r\n        } else {\r\n            s = env.getConfig(\"adminAccount\", \"admin:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"adminuser\",\"admin\");\r\n            } else {\r\n                prop.put(\"adminuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // remote proxy\r\n        prop.put(\"remoteProxyHost\", env.getConfig(\"remoteProxyHost\", \"\"));\r\n        prop.put(\"remoteProxyPort\", env.getConfig(\"remoteProxyPort\", \"\"));\r\n        prop.put(\"remoteProxyNoProxy\", env.getConfig(\"remoteProxyNoProxy\", \"\"));\r\n        prop.put(\"remoteProxyUseChecked\", ((String) env.getConfig(\"remoteProxyUse\", \"false\")).equals(\"true\") ? 1 : 0);\r\n        \r\n        // proxy access filter\r\n        prop.put(\"proxyfilter\", env.getConfig(\"proxyClient\", \"*\"));\r\n        \r\n        // proxy password\r\n        if (env.getConfig(\"proxyAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"proxyuser\",\"proxy\");\r\n        } else {\r\n            s = env.getConfig(\"proxyAccount\", \"proxy:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"proxyuser\",\"proxy\");\r\n            } else {\r\n                prop.put(\"proxyuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // server access filter\r\n        prop.put(\"serverfilter\", env.getConfig(\"serverClient\", \"*\"));\r\n        \r\n        // server password\r\n        if (env.getConfig(\"serverAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"serveruser\",\"server\");\r\n        } else {\r\n            s = env.getConfig(\"serverAccount\", \"server:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"serveruser\",\"server\");\r\n            } else {\r\n                prop.put(\"serveruser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // clientIP\r\n        prop.put(\"clientIP\", (String) header.get(\"CLIENTIP\", \"<unknown>\")); // read an artificial header addendum\r\n        \r\n        /* \r\n         * seed upload settings\r\n         */\r\n        // available methods\r\n        String enabledUploader = env.getConfig(\"seedUploadMethod\", \"none\");\r\n        \r\n        // for backward compatiblity ....\r\n        if ((enabledUploader.equalsIgnoreCase(\"Ftp\")) || \r\n                ((enabledUploader.equals(\"\")) &&\r\n                 (env.getConfig(\"seedFTPPassword\",\"\").length() > 0) &&\r\n                 (env.getConfig(\"seedFilePath\", \"\").length() > 0))) {\r\n            enabledUploader = \"Ftp\";\r\n            env.setConfig(\"seedUploadMethod\",enabledUploader);\r\n        }                  \r\n        \r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        prop.put(\"seedUploadMethods\", uploaders.size() + 1);\r\n        prop.put(\"seedUploadMethods_0_name\", \"none\");\r\n        prop.put(\"seedUploadMethods_0_selected\", enabledUploader.equals(\"none\")?1:0);\r\n        prop.put(\"seedUploadMethods_0_file\", \"\");\r\n        \r\n        int count = 0;\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            count++;\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_name\", uploaderName);\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_selected\", uploaderName.equals(enabledUploader)?1:0);            \r\n            prop.put(\"seedUploadMethods_\" +count+ \"_file\", \"yacy/seedUpload/yacySeedUpload\" + uploaderName + \".html\");\r\n            \r\n            yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n            String[] configOptions = theUploader.getConfigurationOptions();\r\n            if (configOptions != null) {\r\n                for (int i=0; i<configOptions.length; i++) {\r\n                    prop.put(\"seedUploadMethods_\" +count+ \"_\" + configOptions[i], env.getConfig(configOptions[i], \"\"));\r\n                    // prop.put(\"seedUpload\" + uploaderName,1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // general settings\r\n        prop.put(\"seedURL\", env.getConfig(\"seedURL\", \"\"));\r\n        \r\n        \r\n        /*\r\n         * Parser Configuration\r\n         */\r\n        plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n        Hashtable enabledParsers = sb.parser.getEnabledParserList();\r\n        Hashtable availableParsers = sb.parser.getAvailableParserList();\r\n        \r\n        // fetching a list of all available mimetypes\r\n        List availableParserKeys = Arrays.asList(availableParsers.keySet().toArray(new String[availableParsers.size()]));\r\n        \r\n        // sort it\r\n        Collections.sort(availableParserKeys);\r\n        \r\n        // loop through the mimeTypes and add it to the properties\r\n        boolean allParsersEnabled = true;\r\n        int parserIdx = 0;\r\n        Iterator availableParserIter = availableParserKeys.iterator();\r\n        while (availableParserIter.hasNext()) {\r\n            String mimeType = (String) availableParserIter.next();\r\n            String parserName = (String) availableParsers.get(mimeType);\r\n            boolean parserIsEnabled = enabledParsers.containsKey(mimeType);\r\n            \r\n            prop.put(\"parser_\" + parserIdx + \"_mime\", mimeType);\r\n            prop.put(\"parser_\" + parserIdx + \"_name\", parserName);\r\n            prop.put(\"parser_\" + parserIdx + \"_shortname\", parserName.substring(parserName.lastIndexOf(\".\")+1));\r\n            prop.put(\"parser_\" + parserIdx + \"_status\", parserIsEnabled ? 1:0);\r\n            allParsersEnabled &= parserIsEnabled;\r\n            \r\n            parserIdx++;\r\n        }\r\n        \r\n        prop.put(\"allParserEnabled\",allParsersEnabled ? 1:0);\r\n        prop.put(\"parser\", parserIdx);\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"6f09251bbc85cf22ec0b7c23f3ecbb6147d2b912","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n        \r\n        if (post != null) {\r\n            // AUTHENTICATE\r\n            if (!header.containsKey(RequestHeader.AUTHORIZATION)) {\r\n                prop.putHTML(\"AUTHENTICATE\",\"log-in\");\r\n                return prop;\r\n            }\r\n            \r\n            if (post.containsKey(\"popup\")) {\r\n                final String popup = post.get(\"popup\", \"status\");\r\n                if (\"front\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"index.html?display=2\");\r\n                } else if (\"search\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacysearch.html?display=2\");\r\n                } else if (\"interactive\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacyinteractive.html?display=2\");\r\n                } else {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                }\r\n            }\r\n            if (post.containsKey(\"searchpage_set\")) {\r\n                final String newGreeting = post.get(SwitchboardConstants.GREETING, \"\");\r\n                // store this call as api call\r\n                sb.tables.recordAPICall(post, \"ConfigPortal.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"new portal design. greeting: \" + newGreeting);\r\n                \r\n                sb.setConfig(SwitchboardConstants.GREETING, newGreeting);\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, post.get(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, post.get(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, post.get(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, post.get(\"target\", \"_self\"));\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, post.get(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n                HTTPDFileHandler.indexForward = post.get(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                sb.setConfig(\"publicTopmenu\", post.get(\"publicTopmenu\", \"true\"));\r\n                sb.setConfig(\"search.options\", post.getBoolean(\"search.options\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.date\", post.getBoolean(\"search.result.show.date\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.size\", post.getBoolean(\"search.result.show.size\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.metadata\", post.getBoolean(\"search.result.show.metadata\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.parser\", post.getBoolean(\"search.result.show.parser\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.pictures\", post.getBoolean(\"search.result.show.pictures\", false) ? \"true\" : \"false\");\r\n            }\r\n            if (post.containsKey(\"searchpage_default\")) {\r\n                sb.setConfig(SwitchboardConstants.GREETING, \"P2P Web Search\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"http://yacy.net\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"/env/grafics/YaCyLogo_120ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"/env/grafics/YaCyLogo_60ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                sb.setConfig(\"indexForward\", \"Status.html\");\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n            }            \r\n        }\r\n\r\n        prop.putHTML(SwitchboardConstants.GREETING, sb.getConfig(SwitchboardConstants.GREETING, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.INDEX_FORWARD, sb.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n        prop.put(\"publicTopmenu\", sb.getConfigBool(\"publicTopmenu\", false) ? 1 : 0);\r\n        prop.put(\"search.options\", sb.getConfigBool(\"search.options\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.date\", sb.getConfigBool(\"search.result.show.date\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.size\", sb.getConfigBool(\"search.result.show.size\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.metadata\", sb.getConfigBool(\"search.result.show.metadata\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.parser\", sb.getConfigBool(\"search.result.show.parser\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.pictures\", sb.getConfigBool(\"search.result.show.pictures\", false) ? 1 : 0);\r\n\r\n        final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n        prop.put(\"popupFront\", 0);\r\n        prop.put(\"popupSearch\", 0);\r\n        prop.put(\"popupInteractive\", 0);\r\n        prop.put(\"popupStatus\", 0);\r\n        if (browserPopUpPage.startsWith(\"index\")) {\r\n            prop.put(\"popupFront\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacysearch\")) {\r\n            prop.put(\"popupSearch\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacyinteractive\")) {\r\n            prop.put(\"popupInteractive\", 1);\r\n        } else {\r\n            prop.put(\"popupStatus\", 1);\r\n        }\r\n        \r\n        final String target = sb.getConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n        prop.put(\"selected_blank\", \"_blank\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_self\", \"_self\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_parent\", \"_parent\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_top\", \"_top\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_searchresult\", \"searchresult\".equals(target) ? 1 : 0);\r\n                \r\n        String myaddress = sb.peers.mySeed().getPublicAddress();\r\n        if (myaddress == null) {\r\n            myaddress = \"localhost:\" + sb.getConfig(\"port\", \"8090\");\r\n        }\r\n        prop.put(\"myaddress\", myaddress);\r\n        return prop;\r\n    }","id":81149,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n        \r\n        if (post != null) {\r\n            // AUTHENTICATE\r\n            if (!header.containsKey(RequestHeader.AUTHORIZATION)) {\r\n                prop.putHTML(\"AUTHENTICATE\",\"log-in\");\r\n                return prop;\r\n            }\r\n            \r\n            if (post.containsKey(\"popup\")) {\r\n                final String popup = post.get(\"popup\", \"status\");\r\n                if (\"front\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"index.html?display=2\");\r\n                } else if (\"search\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacysearch.html?display=2\");\r\n                } else if (\"interactive\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacyinteractive.html?display=2\");\r\n                } else {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                }\r\n            }\r\n            if (post.containsKey(\"searchpage_set\")) {\r\n                final String newGreeting = post.get(SwitchboardConstants.GREETING, \"\");\r\n                // store this call as api call\r\n                sb.tables.recordAPICall(post, \"ConfigPortal.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"new portal design. greeting: \" + newGreeting);\r\n                \r\n                sb.setConfig(SwitchboardConstants.GREETING, newGreeting);\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, post.get(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, post.get(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, post.get(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, post.get(\"target\", \"_self\"));\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, post.get(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n                HTTPDFileHandler.indexForward = post.get(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                sb.setConfig(\"publicTopmenu\", post.get(\"publicTopmenu\", \"true\"));\r\n                sb.setConfig(\"search.options\", post.getBoolean(\"search.options\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.date\", post.getBoolean(\"search.result.show.date\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.size\", post.getBoolean(\"search.result.show.size\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.metadata\", post.getBoolean(\"search.result.show.metadata\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.parser\", post.getBoolean(\"search.result.show.parser\", false) ? \"true\" : \"false\");\r\n                sb.setConfig(\"search.result.show.pictures\", post.getBoolean(\"search.result.show.pictures\", false) ? \"true\" : \"false\");\r\n            }\r\n            if (post.containsKey(\"searchpage_default\")) {\r\n                sb.setConfig(SwitchboardConstants.GREETING, \"P2P Web Search\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"http://yacy.net\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"/env/grafics/YaCyLogo_120ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"/env/grafics/YaCyLogo_60ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                HTTPDFileHandler.indexForward = \"\";\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n                sb.setConfig(\"publicTopmenu\", \"true\");\r\n                sb.setConfig(\"search.options\", \"true\");\r\n                sb.setConfig(\"search.result.show.date\", \"true\");\r\n                sb.setConfig(\"search.result.show.size\", \"true\");\r\n                sb.setConfig(\"search.result.show.metadata\", \"true\");\r\n                sb.setConfig(\"search.result.show.parser\", \"true\");\r\n                sb.setConfig(\"search.result.show.pictures\", \"true\");\r\n            }            \r\n        }\r\n\r\n        prop.putHTML(SwitchboardConstants.GREETING, sb.getConfig(SwitchboardConstants.GREETING, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.INDEX_FORWARD, sb.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n        prop.put(\"publicTopmenu\", sb.getConfigBool(\"publicTopmenu\", false) ? 1 : 0);\r\n        prop.put(\"search.options\", sb.getConfigBool(\"search.options\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.date\", sb.getConfigBool(\"search.result.show.date\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.size\", sb.getConfigBool(\"search.result.show.size\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.metadata\", sb.getConfigBool(\"search.result.show.metadata\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.parser\", sb.getConfigBool(\"search.result.show.parser\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.pictures\", sb.getConfigBool(\"search.result.show.pictures\", false) ? 1 : 0);\r\n\r\n        final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n        prop.put(\"popupFront\", 0);\r\n        prop.put(\"popupSearch\", 0);\r\n        prop.put(\"popupInteractive\", 0);\r\n        prop.put(\"popupStatus\", 0);\r\n        if (browserPopUpPage.startsWith(\"index\")) {\r\n            prop.put(\"popupFront\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacysearch\")) {\r\n            prop.put(\"popupSearch\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacyinteractive\")) {\r\n            prop.put(\"popupInteractive\", 1);\r\n        } else {\r\n            prop.put(\"popupStatus\", 1);\r\n        }\r\n        \r\n        final String target = sb.getConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n        prop.put(\"selected_blank\", \"_blank\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_self\", \"_self\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_parent\", \"_parent\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_top\", \"_top\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_searchresult\", \"searchresult\".equals(target) ? 1 : 0);\r\n                \r\n        String myaddress = sb.peers.mySeed().getPublicAddress();\r\n        if (myaddress == null) {\r\n            myaddress = \"localhost:\" + sb.getConfig(\"port\", \"8090\");\r\n        }\r\n        prop.put(\"myaddress\", myaddress);\r\n        return prop;\r\n    }","commit_id":"70ca7cec8c049c6963d051e5febf2a985547116d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static final void initDefaultPath() {\n        // create default files array\n        defaultFiles = switchboard.getConfig(\"defaultFiles\",\"index.html\").split(\",\");\n        if (defaultFiles.length == 0) defaultFiles = new String[] {\"index.html\"};\n        indexForward = switchboard.getConfig(\"indexForward\", \"\");\n        if (indexForward.startsWith(\"/\")) indexForward = indexForward.substring(1);\n    }","id":81150,"modified_method":"public static final void initDefaultPath() {\n        // create default files array\n        defaultFiles = switchboard.getConfig(\"defaultFiles\",\"index.html\").split(\",\");\n        if (defaultFiles.length == 0) defaultFiles = new String[] {\"index.html\"};\n        indexForward = switchboard.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\n        if (indexForward.startsWith(\"/\")) indexForward = indexForward.substring(1);\n    }","commit_id":"70ca7cec8c049c6963d051e5febf2a985547116d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        String forwardTarget = sb.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n        if (forwardTarget.length() > 0) {\r\n            // forward the page\r\n            prop.put(\"forward\", 1);\r\n            prop.put(\"forward_target\", forwardTarget);\r\n            return prop;\r\n        }\r\n        \r\n        // access control\r\n        boolean publicPage = sb.getConfigBool(\"publicSearchpage\", true);\r\n        final boolean authorizedAccess = sb.verifyAuthentication(header, false);\r\n        if ((post != null) && (post.containsKey(\"publicPage\"))) {\r\n            if (!authorizedAccess) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            publicPage = post.get(\"publicPage\", \"0\").equals(\"1\");\r\n            sb.setConfig(\"publicSearchpage\", publicPage);\r\n        }\r\n        \r\n        final boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n\r\n        int searchoptions = (post == null) ? 1 : post.getInt(\"searchoptions\", 1);\r\n        if (!sb.getConfigBool(\"search.options\", true)) searchoptions = 0;\r\n        final String former = (post == null) ? \"\" : post.get(\"former\", \"\");\r\n        final int count = Math.min(100, (post == null) ? 10 : post.getInt(\"count\", 10));\r\n        final int maximumRecords = Integer.parseInt((sb.getConfig(SwitchboardConstants.SEARCH_ITEMS, \"10\")));\r\n        final String urlmaskfilter = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\");\r\n        final String prefermaskfilter = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        final String constraint = (post == null) ? \"\" : post.get(\"constraint\", \"\");\r\n        final String cat = (post == null) ? \"href\" : post.get(\"cat\", \"href\");\r\n        final int type = (post == null) ? 0 : post.getInt(\"type\", 0);\r\n        \r\n        final boolean indexDistributeGranted = sb.getConfigBool(SwitchboardConstants.INDEX_DIST_ALLOW, true);\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) ||\r\n        \t\t\t\t\t\t\t\t\tsb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\r\n        //global = global && indexDistributeGranted && indexReceiveGranted;\r\n        \r\n        // search domain\r\n        ContentDomain contentdom = ContentDomain.TEXT;\r\n        final String cds = (post == null) ? \"text\" : post.get(\"contentdom\", \"text\");\r\n        if (cds.equals(\"text\")) contentdom = ContentDomain.TEXT;\r\n        if (cds.equals(\"audio\")) contentdom = ContentDomain.AUDIO;\r\n        if (cds.equals(\"video\")) contentdom = ContentDomain.VIDEO;\r\n        if (cds.equals(\"image\")) contentdom = ContentDomain.IMAGE;\r\n        if (cds.equals(\"app\")) contentdom = ContentDomain.APP;\r\n        \r\n        // we create empty entries for template strings\r\n        String promoteSearchPageGreeting = env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        if (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        prop.putHTML(SwitchboardConstants.GREETING, promoteSearchPageGreeting);\r\n        prop.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(\"former\", former);\r\n        prop.put(\"num-results\", \"0\");\r\n        prop.put(\"excluded\", \"0\");\r\n        prop.put(\"combine\", \"0\");\r\n        prop.put(\"resultbottomline\", \"0\");\r\n        prop.put(\"searchoptions\", searchoptions);\r\n        prop.put(\"searchoptions_maximumRecords\", maximumRecords);\r\n        prop.put(\"searchoptions_count-10\", (count == 10) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-50\", (count == 50) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-100\", (count == 100) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global\", global ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global-disabled\", (indexReceiveGranted && indexDistributeGranted) ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_resource-global-disabled_reason\", (indexReceiveGranted) ? \"0\" : (indexDistributeGranted ? \"1\" : \"2\"));\r\n        prop.put(\"searchoptions_resource-local\", global ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_urlmaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_urlmaskoptions_urlmaskfilter\", urlmaskfilter);\r\n        prop.put(\"searchoptions_prefermaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_prefermaskoptions_prefermaskfilter\", prefermaskfilter);\r\n        prop.put(\"searchoptions_indexofChecked\", \"\");\r\n        prop.put(\"searchoptions_publicSearchpage\", (publicPage) ? \"0\" : \"1\");\r\n        prop.put(\"results\", \"\");\r\n        prop.putHTML(\"cat\", cat);\r\n        prop.put(\"type\", type);\r\n        prop.put(\"depth\", \"0\");\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n        prop.putHTML(\"constraint\", constraint);\r\n        prop.put(\"searchdomswitches\", sb.getConfigBool(\"search.text\", true) || sb.getConfigBool(\"search.audio\", true) || sb.getConfigBool(\"search.video\", true) || sb.getConfigBool(\"search.image\", true) || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n        // online caution timing\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        return prop;\r\n    }","id":81151,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        String forwardTarget = sb.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n        if (forwardTarget.length() > 0) {\r\n            // forward the page\r\n            prop.put(\"forward\", 1);\r\n            prop.put(\"forward_target\", forwardTarget);\r\n            return prop;\r\n        }\r\n        \r\n        // access control\r\n        boolean publicPage = sb.getConfigBool(\"publicSearchpage\", true);\r\n        final boolean authorizedAccess = sb.verifyAuthentication(header, false);\r\n        if ((post != null) && (post.containsKey(\"publicPage\"))) {\r\n            if (!authorizedAccess) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            publicPage = post.get(\"publicPage\", \"0\").equals(\"1\");\r\n            sb.setConfig(\"publicSearchpage\", publicPage);\r\n        }\r\n        \r\n        final boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n\r\n        int searchoptions = (post == null) ? 1 : post.getInt(\"searchoptions\", 1);\r\n        if (!sb.getConfigBool(\"search.options\", true)) searchoptions = 0;\r\n        final String former = (post == null) ? \"\" : post.get(\"former\", \"\");\r\n        final int count = Math.min(100, (post == null) ? 10 : post.getInt(\"count\", 10));\r\n        final int maximumRecords = Integer.parseInt((sb.getConfig(SwitchboardConstants.SEARCH_ITEMS, \"10\")));\r\n        final String urlmaskfilter = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\");\r\n        final String prefermaskfilter = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        final String constraint = (post == null) ? \"\" : post.get(\"constraint\", \"\");\r\n        final String cat = (post == null) ? \"href\" : post.get(\"cat\", \"href\");\r\n        final int type = (post == null) ? 0 : post.getInt(\"type\", 0);\r\n        \r\n        final boolean indexDistributeGranted = sb.getConfigBool(SwitchboardConstants.INDEX_DIST_ALLOW, true);\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) ||\r\n        \t\t\t\t\t\t\t\t\tsb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\r\n        //global = global && indexDistributeGranted && indexReceiveGranted;\r\n        \r\n        // search domain\r\n        ContentDomain contentdom = ContentDomain.TEXT;\r\n        final String cds = (post == null) ? \"text\" : post.get(\"contentdom\", \"text\");\r\n        if (cds.equals(\"text\")) contentdom = ContentDomain.TEXT;\r\n        if (cds.equals(\"audio\")) contentdom = ContentDomain.AUDIO;\r\n        if (cds.equals(\"video\")) contentdom = ContentDomain.VIDEO;\r\n        if (cds.equals(\"image\")) contentdom = ContentDomain.IMAGE;\r\n        if (cds.equals(\"app\")) contentdom = ContentDomain.APP;\r\n        \r\n        // we create empty entries for template strings\r\n        String promoteSearchPageGreeting = env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        if (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        prop.putHTML(SwitchboardConstants.GREETING, promoteSearchPageGreeting);\r\n        prop.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(\"former\", former);\r\n        prop.put(\"num-results\", \"0\");\r\n        prop.put(\"excluded\", \"0\");\r\n        prop.put(\"combine\", \"0\");\r\n        prop.put(\"resultbottomline\", \"0\");\r\n        prop.put(\"maximumRecords\", maximumRecords);\r\n        prop.put(\"searchoptions\", searchoptions);\r\n        prop.put(\"searchoptions_count-10\", (count == 10) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-50\", (count == 50) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-100\", (count == 100) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global\", global ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global-disabled\", (indexReceiveGranted && indexDistributeGranted) ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_resource-global-disabled_reason\", (indexReceiveGranted) ? \"0\" : (indexDistributeGranted ? \"1\" : \"2\"));\r\n        prop.put(\"searchoptions_resource-local\", global ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_urlmaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_urlmaskoptions_urlmaskfilter\", urlmaskfilter);\r\n        prop.put(\"searchoptions_prefermaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_prefermaskoptions_prefermaskfilter\", prefermaskfilter);\r\n        prop.put(\"searchoptions_indexofChecked\", \"\");\r\n        prop.put(\"searchoptions_publicSearchpage\", (publicPage) ? \"0\" : \"1\");\r\n        prop.put(\"results\", \"\");\r\n        prop.putHTML(\"cat\", cat);\r\n        prop.put(\"type\", type);\r\n        prop.put(\"depth\", \"0\");\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n        prop.putHTML(\"constraint\", constraint);\r\n        prop.put(\"searchdomswitches\", sb.getConfigBool(\"search.text\", true) || sb.getConfigBool(\"search.audio\", true) || sb.getConfigBool(\"search.video\", true) || sb.getConfigBool(\"search.image\", true) || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n        // online caution timing\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        return prop;\r\n    }","commit_id":"70ca7cec8c049c6963d051e5febf2a985547116d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final httpRequestHeader header, final serverObjects post, final serverSwitch<?> sb) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard switchboard = (plasmaSwitchboard) sb;\r\n        final serverObjects prop = new serverObjects();\r\n        File defaultSettingsFile = new File(switchboard.getRootPath(), \"defaults/yacy.init\");\r\n        if(post != null && post.containsKey(\"defaultFile\")) {\r\n            // TODO check file-path!\r\n            final File value = new File(switchboard.getRootPath(), post.get(\"defaultFile\", \"defaults/yacy.init\"));\r\n            // check if value is readable file\r\n            if(value.exists() && value.isFile() && value.canRead()) {\r\n                defaultSettingsFile = value;\r\n            }\r\n        }\r\n        final Map<String, String> defaultSettings = ((post == null) || (!(post.containsKey(\"submitdefault\")))) ? null : serverFileUtils.loadHashMap(defaultSettingsFile);\r\n        Iterator<String> threads = switchboard.threadNames();\r\n        String threadName;\r\n        serverBusyThread thread;\r\n        \r\n        final boolean xml = (header.get(\"PATH\")).endsWith(\".xml\");\r\n        prop.setLocalized(!xml);\r\n        \r\n        // calculate totals\r\n        long blocktime_total = 0, sleeptime_total = 0, exectime_total = 0;\r\n        while (threads.hasNext()) {\r\n            threadName = threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            blocktime_total += thread.getBlockTime();\r\n            sleeptime_total += thread.getSleepTime();\r\n            exectime_total += thread.getExecTime();\r\n        }   \r\n        if (blocktime_total == 0) blocktime_total = 1;\r\n        if (sleeptime_total == 0) sleeptime_total = 1;\r\n        if (exectime_total == 0) exectime_total = 1;\r\n        \r\n        // set templates for latest news from the threads\r\n        long blocktime, sleeptime, exectime;\r\n        long idlesleep, busysleep, memuse, memprereq;\r\n        int queuesize;\r\n        threads = switchboard.threadNames();\r\n        int c = 0;\r\n        long idleCycles, busyCycles, memshortageCycles;\r\n        // set profile?\r\n        final double multiplier = (post != null) && post.containsKey(\"multiplier\") ? post.getDouble(\"multiplier\", 1) : 1;\r\n        final boolean setProfile = (post != null && post.containsKey(\"submitdefault\"));\r\n        final boolean setDelay = (post != null) && (post.containsKey(\"submitdelay\"));\r\n        // save used settings file to config\r\n        if (setProfile && post != null) switchboard.setConfig(\"performanceProfile\", post.get(\"defaultFile\", \"defaults/yacy.init\"));\r\n        \r\n        while (threads.hasNext()) {\r\n            threadName = threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            \r\n            // set values to templates\r\n            prop.put(\"table_\" + c + \"_threadname\", threadName);\r\n\r\n\t\t\tprop.putHTML(\"table_\" + c + \"_hasurl_shortdescr\", thread.getShortDescription(), xml);\r\n\t\t\tif(thread.getMonitorURL() == null) {\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"0\");\r\n\t\t\t}else{\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"1\");\r\n\t\t\t\tprop.put(\"table_\" + c + \"_hasurl_url\", thread.getMonitorURL());\r\n\t\t\t}\r\n            prop.putHTML(\"table_\" + c + \"_longdescr\", thread.getLongDescription(), xml);\r\n            queuesize = thread.getJobCount();\r\n            prop.put(\"table_\" + c + \"_queuesize\", (queuesize == Integer.MAX_VALUE) ? \"unlimited\" : yFormatter.number(queuesize, !xml));\r\n            \r\n            blocktime = thread.getBlockTime();\r\n            sleeptime = thread.getSleepTime();\r\n            exectime = thread.getExecTime();\r\n            memuse = thread.getMemoryUse();\r\n            idleCycles = thread.getIdleCycles();\r\n            busyCycles = thread.getBusyCycles();\r\n            memshortageCycles = thread.getOutOfMemoryCycles();\r\n            prop.putNum(\"table_\" + c + \"_blocktime\", blocktime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_blockpercent\", 100 * blocktime / blocktime_total);\r\n            prop.putNum(\"table_\" + c + \"_sleeptime\", sleeptime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercent\", 100 * sleeptime / sleeptime_total);\r\n            prop.putNum(\"table_\" + c + \"_exectime\", exectime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_execpercent\", 100 * exectime / exectime_total);\r\n            prop.putNum(\"table_\" + c + \"_totalcycles\", idleCycles + busyCycles + memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_idlecycles\", idleCycles);\r\n            prop.putNum(\"table_\" + c + \"_busycycles\", busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memscycles\", memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercycle\", ((idleCycles + busyCycles) == 0) ? -1 : sleeptime / (idleCycles + busyCycles));\r\n            prop.putNum(\"table_\" + c + \"_execpercycle\", (busyCycles == 0) ? -1 : exectime / busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memusepercycle\", (busyCycles == 0) ? -1 : memuse / busyCycles / 1024);\r\n            \r\n            // load with old values\r\n            idlesleep = switchboard.getConfigLong(threadName + \"_idlesleep\" , 1000);\r\n            busysleep = switchboard.getConfigLong(threadName + \"_busysleep\",   100);\r\n            memprereq = switchboard.getConfigLong(threadName + \"_memprereq\",     0);\r\n            if (setDelay && post != null) {\r\n                // load with new values\r\n                idlesleep = post.getLong(threadName + \"_idlesleep\", idlesleep);\r\n                busysleep = post.getLong(threadName + \"_busysleep\", busysleep);\r\n                memprereq = post.getLong(threadName + \"_memprereq\", memprereq) * 1024;\r\n                if (memprereq == 0) memprereq = switchboard.getConfigLong(threadName + \"_memprereq\", 0);\r\n                    \r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                \r\n                onTheFlyReconfiguration(switchboard, threadName, idlesleep, busysleep, memprereq);\r\n            } if (setProfile) {\r\n                // load with new values\r\n                idlesleep = (long) (Long.parseLong(d(defaultSettings.get(threadName + \"_idlesleep\"), String.valueOf(idlesleep))) * multiplier);\r\n                busysleep = (long) (Long.parseLong(d(defaultSettings.get(threadName + \"_busysleep\"), String.valueOf(busysleep))) * multiplier);\r\n                memprereq = (long) (Long.parseLong(d(defaultSettings.get(threadName + \"_memprereq\"), String.valueOf(memprereq))) * multiplier);\r\n\r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                if ((threadName.equals(\"50_localcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"61_globalcrawltrigger\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"62_remotetriggeredcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n\r\n                onTheFlyReconfiguration(switchboard, threadName, idlesleep, busysleep, memprereq);\r\n            }\r\n            prop.put(\"table_\" + c + \"_idlesleep\", idlesleep);\r\n            prop.put(\"table_\" + c + \"_busysleep\", busysleep);\r\n            prop.put(\"table_\" + c + \"_memprereq\", memprereq / 1024);\r\n            // disallow setting of memprereq for indexer to prevent db from throwing OOMs\r\n            prop.put(\"table_\" + c + \"_disabled\", /*(threadName.endsWith(\"_indexing\")) ? 1 :*/ \"0\");\r\n            prop.put(\"table_\" + c + \"_recommendation\", threadName.endsWith(\"_indexing\") ? \"1\" : \"0\");\r\n            prop.putNum(\"table_\" + c + \"_recommendation_value\", threadName.endsWith(\"_indexing\") ? (switchboard.webIndex.minMem() / 1024) : 0);\r\n            c++;\r\n        }\r\n        prop.put(\"table\", c);\r\n        \r\n        // performance profiles\r\n        c = 0;\r\n        final String usedfile = switchboard.getConfig(\"performanceProfile\", \"defaults/yacy.init\");\r\n        for(final String filename: performanceProfiles.keySet()) {\r\n            prop.put(\"profile_\" + c + \"_filename\", filename);\r\n            prop.put(\"profile_\" + c + \"_description\", performanceProfiles.get(filename));\r\n            prop.put(\"profile_\" + c + \"_used\", usedfile.equalsIgnoreCase(filename) ? \"1\" : \"0\");\r\n            c++;\r\n        }\r\n        prop.put(\"profile\", c);\r\n        \r\n        if ((post != null) && (post.containsKey(\"cacheSizeSubmit\"))) {\r\n            final int wordCacheMaxCount = post.getInt(\"wordCacheMaxCount\", 20000);\r\n            switchboard.setConfig(plasmaSwitchboardConstants.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\r\n            switchboard.webIndex.setMaxWordCount(wordCacheMaxCount);\r\n            \r\n            final int wordCacheInitCount = post.getInt(plasmaSwitchboardConstants.WORDCACHE_INIT_COUNT, 30000);\r\n            switchboard.setConfig(plasmaSwitchboardConstants.WORDCACHE_INIT_COUNT, Integer.toString(wordCacheInitCount));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"poolConfig\"))) {\r\n            \r\n            /* \r\n             * configuring the crawler pool \r\n             */\r\n            // getting the current crawler pool configuration\r\n            int maxBusy = Integer.parseInt(post.get(\"Crawler Pool_maxActive\",\"8\"));\r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(plasmaSwitchboardConstants.CRAWLER_THREADS_ACTIVE_MAX,maxBusy);\r\n            //switchboard.setConfig(\"crawler.MinIdleThreads\",minIdle);\r\n            \r\n            /* \r\n             * configuring the http pool \r\n             */\r\n            final serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n            try {\r\n                maxBusy = Integer.parseInt(post.get(\"httpd Session Pool_maxActive\",\"8\"));\r\n            } catch (final NumberFormatException e) {\r\n                maxBusy = 8;\r\n            }\r\n\r\n            ((serverCore)httpd).setMaxSessionCount(maxBusy);    \r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(\"httpdMaxBusySessions\",maxBusy);\r\n\r\n        }        \r\n        \r\n        if ((post != null) && (post.containsKey(\"PrioritySubmit\"))) {\r\n        \tswitchboard.setConfig(\"javastart_priority\",post.get(\"YaCyPriority\",\"0\"));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"onlineCautionSubmit\"))) {\r\n            switchboard.setConfig(plasmaSwitchboardConstants.PROXY_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseProxy\", 30000)));\r\n            switchboard.setConfig(plasmaSwitchboardConstants.LOCALSEACH_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseLocalsearch\", 30000)));\r\n            switchboard.setConfig(plasmaSwitchboardConstants.REMOTESEARCH_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseRemotesearch\", 30000)));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"minimumDeltaSubmit\"))) {\r\n            final long minimumLocalDelta = post.getLong(\"minimumLocalDelta\", switchboard.crawlQueues.noticeURL.getMinimumLocalDelta());\r\n            final long minimumGlobalDelta = post.getLong(\"minimumGlobalDelta\", switchboard.crawlQueues.noticeURL.getMinimumGlobalDelta());\r\n            switchboard.setConfig(\"minimumLocalDelta\", minimumLocalDelta);\r\n            switchboard.setConfig(\"minimumGlobalDelta\", minimumGlobalDelta);\r\n            switchboard.crawlQueues.noticeURL.setMinimumLocalDelta(minimumLocalDelta);\r\n            switchboard.crawlQueues.noticeURL.setMinimumGlobalDelta(minimumGlobalDelta);\r\n        }\r\n        \r\n        // delta settings\r\n        prop.put(\"minimumLocalDelta\", switchboard.crawlQueues.noticeURL.getMinimumLocalDelta());\r\n        prop.put(\"minimumGlobalDelta\", switchboard.crawlQueues.noticeURL.getMinimumGlobalDelta());\r\n        \r\n        // table cache settings\r\n        prop.putNum(\"urlCacheSize\", switchboard.webIndex.getURLwriteCacheSize());  \r\n        prop.putNum(\"wordCacheWSize\", switchboard.webIndex.dhtOutCacheSize());\r\n        prop.putNum(\"wordCacheKSize\", switchboard.webIndex.dhtInCacheSize());\r\n        prop.putNum(\"wordCacheWSizeKBytes\", switchboard.webIndex.dhtCacheSizeBytes(false)/1024);\r\n        prop.putNum(\"wordCacheKSizeKBytes\", switchboard.webIndex.dhtCacheSizeBytes(true)/1024);\r\n        prop.putNum(\"maxURLinWCache\", switchboard.webIndex.maxURLinDHTOutCache());\r\n        prop.putNum(\"maxURLinKCache\", switchboard.webIndex.maxURLinDHTInCache());\r\n        prop.putNum(\"maxAgeOfWCache\", switchboard.webIndex.maxAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxAgeOfKCache\", switchboard.webIndex.maxAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfWCache\", switchboard.webIndex.minAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfKCache\", switchboard.webIndex.minAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxWaitingWordFlush\", switchboard.getConfigLong(\"maxWaitingWordFlush\", 180));\r\n        prop.put(\"wordCacheMaxCount\", switchboard.getConfigLong(plasmaSwitchboardConstants.WORDCACHE_MAX_COUNT, 20000));\r\n        prop.put(\"wordCacheInitCount\", switchboard.getConfigLong(plasmaSwitchboardConstants.WORDCACHE_INIT_COUNT, 30000));\r\n        prop.put(\"crawlPauseProxy\", switchboard.getConfigLong(plasmaSwitchboardConstants.PROXY_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.put(\"crawlPauseLocalsearch\", switchboard.getConfigLong(plasmaSwitchboardConstants.LOCALSEACH_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.put(\"crawlPauseRemotesearch\", switchboard.getConfigLong(plasmaSwitchboardConstants.REMOTESEARCH_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.putNum(\"crawlPauseProxyCurrent\", (System.currentTimeMillis() - switchboard.proxyLastAccess) / 1000);\r\n        prop.putNum(\"crawlPauseLocalsearchCurrent\", (System.currentTimeMillis() - switchboard.localSearchLastAccess) / 1000);\r\n        prop.putNum(\"crawlPauseRemotesearchCurrent\", (System.currentTimeMillis() - switchboard.remoteSearchLastAccess) / 1000);\r\n        \r\n        // table thread pool settings\n        prop.put(\"pool_0_name\",\"Crawler Pool\");\r\n        prop.put(\"pool_0_maxActive\", switchboard.getConfigLong(\"crawler.MaxActiveThreads\", 0));\r\n        prop.put(\"pool_0_numActive\",switchboard.crawlQueues.size());\n        \r\n        final serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n        prop.put(\"pool_1_name\", \"httpd Session Pool\");\r\n        prop.put(\"pool_1_maxActive\", ((serverCore)httpd).getMaxSessionCount());\r\n        prop.put(\"pool_1_numActive\", ((serverCore)httpd).getJobCount());\r\n        \n        prop.put(\"pool\", \"2\");\n        \r\n        final long curr_prio = switchboard.getConfigLong(\"javastart_priority\",0);\r\n        prop.put(\"priority_normal\",(curr_prio==0) ? \"1\" : \"0\");\r\n        prop.put(\"priority_below\",(curr_prio==10) ? \"1\" : \"0\");\r\n        prop.put(\"priority_low\",(curr_prio==20) ? \"1\" : \"0\");\r\n        \r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","id":81152,"modified_method":"public static serverObjects respond(final httpRequestHeader header, final serverObjects post, final serverSwitch<?> sb) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard switchboard = (plasmaSwitchboard) sb;\r\n        final serverObjects prop = new serverObjects();\r\n        File defaultSettingsFile = new File(switchboard.getRootPath(), \"defaults/yacy.init\");\r\n        if(post != null && post.containsKey(\"defaultFile\")) {\r\n            // TODO check file-path!\r\n            final File value = new File(switchboard.getRootPath(), post.get(\"defaultFile\", \"defaults/yacy.init\"));\r\n            // check if value is readable file\r\n            if(value.exists() && value.isFile() && value.canRead()) {\r\n                defaultSettingsFile = value;\r\n            }\r\n        }\r\n        final Map<String, String> defaultSettings = ((post == null) || (!(post.containsKey(\"submitdefault\")))) ? null : serverFileUtils.loadHashMap(defaultSettingsFile);\r\n        Iterator<String> threads = switchboard.threadNames();\r\n        String threadName;\r\n        serverBusyThread thread;\r\n        \r\n        final boolean xml = (header.get(\"PATH\")).endsWith(\".xml\");\r\n        prop.setLocalized(!xml);\r\n        \r\n        // calculate totals\r\n        long blocktime_total = 0, sleeptime_total = 0, exectime_total = 0;\r\n        while (threads.hasNext()) {\r\n            threadName = threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            blocktime_total += thread.getBlockTime();\r\n            sleeptime_total += thread.getSleepTime();\r\n            exectime_total += thread.getExecTime();\r\n        }   \r\n        if (blocktime_total == 0) blocktime_total = 1;\r\n        if (sleeptime_total == 0) sleeptime_total = 1;\r\n        if (exectime_total == 0) exectime_total = 1;\r\n        \r\n        // set templates for latest news from the threads\r\n        long blocktime, sleeptime, exectime;\r\n        long idlesleep, busysleep, memuse, memprereq;\r\n        int queuesize;\r\n        threads = switchboard.threadNames();\r\n        int c = 0;\r\n        long idleCycles, busyCycles, memshortageCycles;\r\n        // set profile?\r\n        final double multiplier = (post != null) && post.containsKey(\"profileSpeed\") ? 100.0 / post.getDouble(\"profileSpeed\", 100.0) : 1.0;\r\n        final boolean setProfile = (post != null && post.containsKey(\"submitdefault\"));\r\n        final boolean setDelay = (post != null) && (post.containsKey(\"submitdelay\"));\r\n        // save used settings file to config\r\n        if (setProfile && post != null){\r\n        \tswitchboard.setConfig(\"performanceProfile\", post.get(\"defaultFile\", \"defaults/yacy.init\"));\r\n        \tswitchboard.setConfig(\"performanceSpeed\", post.getInt(\"profileSpeed\", 100));\r\n        }\r\n        \r\n        while (threads.hasNext()) {\r\n            threadName = threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            \r\n            // set values to templates\r\n            prop.put(\"table_\" + c + \"_threadname\", threadName);\r\n\r\n\t\t\tprop.putHTML(\"table_\" + c + \"_hasurl_shortdescr\", thread.getShortDescription(), xml);\r\n\t\t\tif(thread.getMonitorURL() == null) {\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"0\");\r\n\t\t\t}else{\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"1\");\r\n\t\t\t\tprop.put(\"table_\" + c + \"_hasurl_url\", thread.getMonitorURL());\r\n\t\t\t}\r\n            prop.putHTML(\"table_\" + c + \"_longdescr\", thread.getLongDescription(), xml);\r\n            queuesize = thread.getJobCount();\r\n            prop.put(\"table_\" + c + \"_queuesize\", (queuesize == Integer.MAX_VALUE) ? \"unlimited\" : yFormatter.number(queuesize, !xml));\r\n            \r\n            blocktime = thread.getBlockTime();\r\n            sleeptime = thread.getSleepTime();\r\n            exectime = thread.getExecTime();\r\n            memuse = thread.getMemoryUse();\r\n            idleCycles = thread.getIdleCycles();\r\n            busyCycles = thread.getBusyCycles();\r\n            memshortageCycles = thread.getOutOfMemoryCycles();\r\n            prop.putNum(\"table_\" + c + \"_blocktime\", blocktime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_blockpercent\", 100 * blocktime / blocktime_total);\r\n            prop.putNum(\"table_\" + c + \"_sleeptime\", sleeptime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercent\", 100 * sleeptime / sleeptime_total);\r\n            prop.putNum(\"table_\" + c + \"_exectime\", exectime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_execpercent\", 100 * exectime / exectime_total);\r\n            prop.putNum(\"table_\" + c + \"_totalcycles\", idleCycles + busyCycles + memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_idlecycles\", idleCycles);\r\n            prop.putNum(\"table_\" + c + \"_busycycles\", busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memscycles\", memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercycle\", ((idleCycles + busyCycles) == 0) ? -1 : sleeptime / (idleCycles + busyCycles));\r\n            prop.putNum(\"table_\" + c + \"_execpercycle\", (busyCycles == 0) ? -1 : exectime / busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memusepercycle\", (busyCycles == 0) ? -1 : memuse / busyCycles / 1024);\r\n            \r\n            // load with old values\r\n            idlesleep = switchboard.getConfigLong(threadName + \"_idlesleep\" , 1000);\r\n            busysleep = switchboard.getConfigLong(threadName + \"_busysleep\",   100);\r\n            memprereq = switchboard.getConfigLong(threadName + \"_memprereq\",     0);\r\n            if (setDelay && post != null) {\r\n                // load with new values\r\n                idlesleep = post.getLong(threadName + \"_idlesleep\", idlesleep);\r\n                busysleep = post.getLong(threadName + \"_busysleep\", busysleep);\r\n                memprereq = post.getLong(threadName + \"_memprereq\", memprereq) * 1024;\r\n                if (memprereq == 0) memprereq = switchboard.getConfigLong(threadName + \"_memprereq\", 0);\r\n                    \r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                \r\n                onTheFlyReconfiguration(switchboard, threadName, idlesleep, busysleep, memprereq);\r\n            } if (setProfile) {\r\n                // load with new values\r\n                idlesleep = (long) (Long.parseLong(d(defaultSettings.get(threadName + \"_idlesleep\"), String.valueOf(idlesleep))) * multiplier);\r\n                busysleep = (long) (Long.parseLong(d(defaultSettings.get(threadName + \"_busysleep\"), String.valueOf(busysleep))) * multiplier);\r\n                memprereq = (long) (Long.parseLong(d(defaultSettings.get(threadName + \"_memprereq\"), String.valueOf(memprereq))) * multiplier);\r\n\r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                if ((threadName.equals(\"50_localcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"61_globalcrawltrigger\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"62_remotetriggeredcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n\r\n                onTheFlyReconfiguration(switchboard, threadName, idlesleep, busysleep, memprereq);\r\n            }\r\n            prop.put(\"table_\" + c + \"_idlesleep\", idlesleep);\r\n            prop.put(\"table_\" + c + \"_busysleep\", busysleep);\r\n            prop.put(\"table_\" + c + \"_memprereq\", memprereq / 1024);\r\n            // disallow setting of memprereq for indexer to prevent db from throwing OOMs\r\n            prop.put(\"table_\" + c + \"_disabled\", /*(threadName.endsWith(\"_indexing\")) ? 1 :*/ \"0\");\r\n            prop.put(\"table_\" + c + \"_recommendation\", threadName.endsWith(\"_indexing\") ? \"1\" : \"0\");\r\n            prop.putNum(\"table_\" + c + \"_recommendation_value\", threadName.endsWith(\"_indexing\") ? (switchboard.webIndex.minMem() / 1024) : 0);\r\n            c++;\r\n        }\r\n        prop.put(\"table\", c);\r\n        \r\n        // performance profiles\r\n        c = 0;\r\n        final String usedfile = switchboard.getConfig(\"performanceProfile\", \"defaults/yacy.init\");\r\n        for(final String filename: performanceProfiles.keySet()) {\r\n            prop.put(\"profile_\" + c + \"_filename\", filename);\r\n            prop.put(\"profile_\" + c + \"_description\", performanceProfiles.get(filename));\r\n            prop.put(\"profile_\" + c + \"_used\", usedfile.equalsIgnoreCase(filename) ? \"1\" : \"0\");\r\n            c++;\r\n        }\r\n        prop.put(\"profile\", c);\r\n        \r\n        c = 0;\r\n        final int[] speedValues = {200,150,100,50,25,10};\r\n        final int usedspeed = Integer.parseInt(switchboard.getConfig(\"performanceSpeed\", \"100\"));\r\n        for(final int speed: speedValues){\r\n        \tprop.put(\"speed_\" + c + \"_value\", speed);\r\n        \tprop.put(\"speed_\" + c + \"_label\", speed + \" %\");\r\n        \tprop.put(\"speed_\" + c + \"_used\", (speed == usedspeed) ? \"1\" : \"0\");\r\n        \tc++;\r\n        }\r\n        prop.put(\"speed\", c);\r\n        \r\n        if ((post != null) && (post.containsKey(\"cacheSizeSubmit\"))) {\r\n            final int wordCacheMaxCount = post.getInt(\"wordCacheMaxCount\", 20000);\r\n            switchboard.setConfig(plasmaSwitchboardConstants.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\r\n            switchboard.webIndex.setMaxWordCount(wordCacheMaxCount);\r\n            \r\n            final int wordCacheInitCount = post.getInt(plasmaSwitchboardConstants.WORDCACHE_INIT_COUNT, 30000);\r\n            switchboard.setConfig(plasmaSwitchboardConstants.WORDCACHE_INIT_COUNT, Integer.toString(wordCacheInitCount));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"poolConfig\"))) {\r\n            \r\n            /* \r\n             * configuring the crawler pool \r\n             */\r\n            // getting the current crawler pool configuration\r\n            int maxBusy = Integer.parseInt(post.get(\"Crawler Pool_maxActive\",\"8\"));\r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(plasmaSwitchboardConstants.CRAWLER_THREADS_ACTIVE_MAX,maxBusy);\r\n            //switchboard.setConfig(\"crawler.MinIdleThreads\",minIdle);\r\n            \r\n            /* \r\n             * configuring the http pool \r\n             */\r\n            final serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n            try {\r\n                maxBusy = Integer.parseInt(post.get(\"httpd Session Pool_maxActive\",\"8\"));\r\n            } catch (final NumberFormatException e) {\r\n                maxBusy = 8;\r\n            }\r\n\r\n            ((serverCore)httpd).setMaxSessionCount(maxBusy);    \r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(\"httpdMaxBusySessions\",maxBusy);\r\n\r\n        }        \r\n        \r\n        if ((post != null) && (post.containsKey(\"PrioritySubmit\"))) {\r\n        \tswitchboard.setConfig(\"javastart_priority\",post.get(\"YaCyPriority\",\"0\"));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"onlineCautionSubmit\"))) {\r\n            switchboard.setConfig(plasmaSwitchboardConstants.PROXY_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseProxy\", 30000)));\r\n            switchboard.setConfig(plasmaSwitchboardConstants.LOCALSEACH_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseLocalsearch\", 30000)));\r\n            switchboard.setConfig(plasmaSwitchboardConstants.REMOTESEARCH_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseRemotesearch\", 30000)));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"minimumDeltaSubmit\"))) {\r\n            final long minimumLocalDelta = post.getLong(\"minimumLocalDelta\", switchboard.crawlQueues.noticeURL.getMinimumLocalDelta());\r\n            final long minimumGlobalDelta = post.getLong(\"minimumGlobalDelta\", switchboard.crawlQueues.noticeURL.getMinimumGlobalDelta());\r\n            switchboard.setConfig(\"minimumLocalDelta\", minimumLocalDelta);\r\n            switchboard.setConfig(\"minimumGlobalDelta\", minimumGlobalDelta);\r\n            switchboard.crawlQueues.noticeURL.setMinimumLocalDelta(minimumLocalDelta);\r\n            switchboard.crawlQueues.noticeURL.setMinimumGlobalDelta(minimumGlobalDelta);\r\n        }\r\n        \r\n        // delta settings\r\n        prop.put(\"minimumLocalDelta\", switchboard.crawlQueues.noticeURL.getMinimumLocalDelta());\r\n        prop.put(\"minimumGlobalDelta\", switchboard.crawlQueues.noticeURL.getMinimumGlobalDelta());\r\n        \r\n        // table cache settings\r\n        prop.putNum(\"urlCacheSize\", switchboard.webIndex.getURLwriteCacheSize());  \r\n        prop.putNum(\"wordCacheWSize\", switchboard.webIndex.dhtOutCacheSize());\r\n        prop.putNum(\"wordCacheKSize\", switchboard.webIndex.dhtInCacheSize());\r\n        prop.putNum(\"wordCacheWSizeKBytes\", switchboard.webIndex.dhtCacheSizeBytes(false)/1024);\r\n        prop.putNum(\"wordCacheKSizeKBytes\", switchboard.webIndex.dhtCacheSizeBytes(true)/1024);\r\n        prop.putNum(\"maxURLinWCache\", switchboard.webIndex.maxURLinDHTOutCache());\r\n        prop.putNum(\"maxURLinKCache\", switchboard.webIndex.maxURLinDHTInCache());\r\n        prop.putNum(\"maxAgeOfWCache\", switchboard.webIndex.maxAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxAgeOfKCache\", switchboard.webIndex.maxAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfWCache\", switchboard.webIndex.minAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfKCache\", switchboard.webIndex.minAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxWaitingWordFlush\", switchboard.getConfigLong(\"maxWaitingWordFlush\", 180));\r\n        prop.put(\"wordCacheMaxCount\", switchboard.getConfigLong(plasmaSwitchboardConstants.WORDCACHE_MAX_COUNT, 20000));\r\n        prop.put(\"wordCacheInitCount\", switchboard.getConfigLong(plasmaSwitchboardConstants.WORDCACHE_INIT_COUNT, 30000));\r\n        prop.put(\"crawlPauseProxy\", switchboard.getConfigLong(plasmaSwitchboardConstants.PROXY_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.put(\"crawlPauseLocalsearch\", switchboard.getConfigLong(plasmaSwitchboardConstants.LOCALSEACH_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.put(\"crawlPauseRemotesearch\", switchboard.getConfigLong(plasmaSwitchboardConstants.REMOTESEARCH_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.putNum(\"crawlPauseProxyCurrent\", (System.currentTimeMillis() - switchboard.proxyLastAccess) / 1000);\r\n        prop.putNum(\"crawlPauseLocalsearchCurrent\", (System.currentTimeMillis() - switchboard.localSearchLastAccess) / 1000);\r\n        prop.putNum(\"crawlPauseRemotesearchCurrent\", (System.currentTimeMillis() - switchboard.remoteSearchLastAccess) / 1000);\r\n        \r\n        // table thread pool settings\n        prop.put(\"pool_0_name\",\"Crawler Pool\");\r\n        prop.put(\"pool_0_maxActive\", switchboard.getConfigLong(\"crawler.MaxActiveThreads\", 0));\r\n        prop.put(\"pool_0_numActive\",switchboard.crawlQueues.size());\n        \r\n        final serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n        prop.put(\"pool_1_name\", \"httpd Session Pool\");\r\n        prop.put(\"pool_1_maxActive\", ((serverCore)httpd).getMaxSessionCount());\r\n        prop.put(\"pool_1_numActive\", ((serverCore)httpd).getJobCount());\r\n        \n        prop.put(\"pool\", \"2\");\n        \r\n        final long curr_prio = switchboard.getConfigLong(\"javastart_priority\",0);\r\n        prop.put(\"priority_normal\",(curr_prio==0) ? \"1\" : \"0\");\r\n        prop.put(\"priority_below\",(curr_prio==10) ? \"1\" : \"0\");\r\n        prop.put(\"priority_low\",(curr_prio==20) ? \"1\" : \"0\");\r\n        \r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","commit_id":"e5c0b969d62230ff49a978febf4283d1a120ea86","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        if (post == null) {\r\n            prop.put(\"info\", 1);//no information submitted\r\n            return prop;\r\n        }\r\n        \r\n        // admin password\r\n        if (post.containsKey(\"adminaccount\")) {\r\n            // read and process data\r\n            String user   = (String) post.get(\"adminuser\");\r\n            String pw1    = (String) post.get(\"adminpw1\");\r\n            String pw2    = (String) post.get(\"adminpw2\");\r\n            // do checks\r\n            if ((user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            // check passed. set account:\r\n            env.setConfig(\"adminAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"adminAccount\", \"\");\r\n            prop.put(\"info\", 5);//admin account changed\r\n            prop.put(\"info_user\", user);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // proxy password\r\n        if (post.containsKey(\"proxyaccount\")) {\r\n\t    // set new port\r\n            String port = (String) post.get(\"port\");\r\n\t    env.setConfig(\"port\", port);\r\n\t    prop.put(\"info_port\", port);\r\n\r\n\t    // set transparent proxy flag\r\n            httpdProxyHandler.isTransparentProxy = post.containsKey(\"isTransparentProxy\");\r\n\t    env.setConfig(\"isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"true\" : \"false\");\r\n\t    prop.put(\"info_isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"on\" : \"off\");\r\n\r\n            // read and process data\r\n            String filter = (String) post.get(\"proxyfilter\");\r\n            String user   = (String) post.get(\"proxyuser\");\r\n            String pw1    = (String) post.get(\"proxypw1\");\r\n            String pw2    = (String) post.get(\"proxypw2\");\r\n            // do checks\r\n            if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"proxyClient\", filter);\r\n            if (pw1.length() == 0) {\r\n                // only ip filter setting without account\r\n                env.setConfig(\"proxyAccountBase64MD5\", \"\");\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 6);//proxy account has changed(no pw)\r\n                prop.put(\"info_filter\", filter);\r\n            } else {\r\n                // also paccount setting\r\n                env.setConfig(\"proxyAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 7);//proxy account has changed\r\n                prop.put(\"info_user\", user);\r\n                prop.put(\"info_filter\", filter);\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        // server password\r\n        if (post.containsKey(\"serveraccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"serverfilter\");\r\n            String user   = (String) post.get(\"serveruser\");\r\n            String pw1    = (String) post.get(\"serverpw1\");\r\n            String pw2    = (String) post.get(\"serverpw2\");\r\n            // do checks\r\n            if (filter == null) {\r\n                //if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"serverClient\", filter);\r\n            env.setConfig(\"serverAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"serverAccount\", \"\");\r\n            \r\n            prop.put(\"info\", 8);//server access filter updated\r\n            prop.put(\"info_user\", user);\r\n            prop.put(\"info_filter\", filter);\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"dispop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"false\");\r\n            prop.put(\"info\", 9);//popup disabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"enpop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"true\");\r\n            prop.put(\"info\", 10);//popup enabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"pmode\")) {\r\n            env.setConfig(\"onlineMode\", \"2\");\r\n            prop.put(\"info\", 11);//permanent online mode\r\n            yacyCore.triggerOnlineAction();\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"generalsettings\")) {\r\n            /*\r\n            // set peer language\r\n            String peerLang = (String) post.get(\"peerlang\");\r\n            if ((peerLang == null) || (peerLang.equals(\"en\"))) peerLang = \"default\";\r\n\t    HashMap lm = langMap(env);\r\n\t    if (!(lm.containsKey(peerLang))) peerLang = \"default\";\r\n\t    env.setConfig(\"htLocaleSelection\", peerLang);\r\n\t    prop.put(\"info_peerLang\", (String) lm.get(peerLang));\r\n            */\r\n            \r\n            // check if peer name already exists\r\n            String peerName = (String) post.get(\"peername\");\r\n            yacySeed oldSeed = yacyCore.seedDB.lookupByName(peerName);\r\n            \r\n            if ((oldSeed == null) || (env.getConfig(\"peerName\",\"\").equals(peerName))) {\r\n                // the name is new\r\n                boolean nameOK = (peerName.length() <= 80);\r\n                for (int i = 0; i < peerName.length(); i++) {\r\n                    if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\".indexOf(peerName.charAt(i)) < 0) nameOK = false;\r\n                }\r\n                if (!(nameOK)) {\r\n                    // deny change\r\n                    prop.put(\"info\", 17);//peer name is wrong\r\n                } else {\r\n                    \r\n                    // set values\r\n                    env.setConfig(\"peerName\", peerName);\r\n                    prop.put(\"info\", 12);//port or peername changed\r\n                    prop.put(\"info_peerName\", peerName);\r\n                }\r\n            } else {\r\n                // deny change\r\n                prop.put(\"info\", 16);//peer name is already used by another peer\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"proxysettings\")) {\r\n            httpdProxyHandler.remoteProxyUse = ((String) post.get(\"remoteProxyUse\", \"\")).equals(\"on\");\r\n            httpdProxyHandler.remoteProxyHost = (String) post.get(\"remoteProxyHost\", \"\");\r\n            try {\r\n                httpdProxyHandler.remoteProxyPort = Integer.parseInt((String) post.get(\"remoteProxyPort\", \"\"));\r\n            } catch (NumberFormatException e) {\r\n                httpdProxyHandler.remoteProxyPort = 3128;\r\n            }\r\n            httpdProxyHandler.remoteProxyNoProxy = (String) post.get(\"remoteProxyNoProxy\", \"\");\r\n            httpdProxyHandler.remoteProxyNoProxyPatterns = httpdProxyHandler.remoteProxyNoProxy.split(\",\");\r\n            env.setConfig(\"remoteProxyHost\", httpdProxyHandler.remoteProxyHost);\r\n            env.setConfig(\"remoteProxyPort\", \"\" + httpdProxyHandler.remoteProxyPort);\r\n            env.setConfig(\"remoteProxyNoProxy\", httpdProxyHandler.remoteProxyNoProxy);\r\n            env.setConfig(\"remoteProxyUse\", (httpdProxyHandler.remoteProxyUse) ? \"true\" : \"false\");\r\n            prop.put(\"info\", 15); // The remote-proxy setting has been changed\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedSettings\")) {            \r\n            try {\r\n                // getting the currently used uploading method\r\n                String oldSeedUploadMethod = env.getConfig(\"seedUploadMethod\",\"none\");\r\n                String newSeedUploadMethod = (String)post.get(\"seedUploadMethod\");\r\n                String oldSeedURLStr = env.getConfig(\"seedURL\",\"\");\r\n                String newSeedURLStr = (String)post.get(\"seedURL\");\r\n                new URL(newSeedURLStr);\r\n                \r\n                boolean seedUrlChanged = !oldSeedURLStr.equals(newSeedURLStr);\r\n                boolean uploadMethodChanged = !oldSeedUploadMethod.equals(newSeedUploadMethod);\r\n                if (uploadMethodChanged) {\r\n                    uploadMethodChanged = yacyCore.changeSeedUploadMethod(newSeedUploadMethod); \r\n                }\r\n\r\n                if (seedUrlChanged || uploadMethodChanged) {\r\n                    env.setConfig(\"seedUploadMethod\", newSeedUploadMethod);\r\n                    env.setConfig(\"seedURL\", newSeedURLStr);\r\n                    \r\n                    // trying to upload the seed-list file\r\n                    yacyCore.saveSeedList(env);\r\n                    \r\n                    // we have successfully uploaded the seed-list file\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",(newSeedUploadMethod.equalsIgnoreCase(\"none\")?0:1));\r\n                    prop.put(\"info\", 19);                                     \r\n                } else {\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",0);\r\n                    prop.put(\"info\", 19);                    \r\n                    \r\n                }\r\n            } catch (Exception e) {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\"); \r\n            }\r\n            return prop;            \r\n        }\r\n        \r\n        /* \r\n         * Loop through the available seed uploaders to see if the \r\n         * configuration of one of them has changed \r\n         */\r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            // getting the uploader module name\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            \r\n            \r\n            // determining if the user has reconfigured the settings of this uploader\r\n            if (post.containsKey(\"seed\" + uploaderName + \"Settings\")) {\r\n                nothingChanged = true;\r\n                yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n                String[] configOptions = theUploader.getConfigurationOptions();\r\n                if (configOptions != null) {\r\n                    for (int i=0; i<configOptions.length; i++) {\r\n                        String newSettings = post.get(configOptions[i],\"\");\r\n                        String oldSettings = env.getConfig(configOptions[i],\"\");\r\n                        nothingChanged &= newSettings.equals(oldSettings); \r\n                        if (!nothingChanged) {\r\n                            env.setConfig(configOptions[i],newSettings);\r\n                        }\r\n                    }\r\n                }   \r\n                if (!nothingChanged) {\r\n                    // if the seed upload method is equal to the seed uploader whose settings\r\n                    // were changed, we now try to upload the seed list with the new settings\r\n                    if (env.getConfig(\"seedUploadMethod\",\"none\").equalsIgnoreCase(uploaderName)) {\r\n                        try {\r\n                            yacyCore.saveSeedList(env);\r\n                            \r\n                            // we have successfully uploaded the seed file\r\n                            prop.put(\"info\", 13);\r\n                            prop.put(\"info_success\",1);\r\n                        } catch (Exception e) {\r\n                            // if uploading failed we print out an error message\r\n                            prop.put(\"info\", 14);\r\n                            prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                            env.setConfig(\"seedUploadMethod\",\"none\");                            \r\n                        }                       \r\n                    } else {\r\n                        prop.put(\"info\", 13);\r\n                        prop.put(\"info_success\",0);\r\n                    }\r\n                } else {\r\n                    prop.put(\"info\", 13);\r\n                    prop.put(\"info_success\",0);\r\n                }\r\n                return prop;\r\n            }            \r\n        }\r\n        \r\n        if (post.containsKey(\"parserSettings\")) {   \r\n            plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n\t\t\tpost.remove(\"parserSettings\");\r\n            \r\n            String[] enabledMimes = null;\r\n            if (post.containsKey(\"allParserEnabled\")) {\r\n                // enable all available parsers\r\n                enabledMimes = sb.parser.setEnabledParserList(sb.parser.getAvailableParserList().keySet());\r\n            } else {\r\n                // activate all received parsers       \r\n                enabledMimes = sb.parser.setEnabledParserList(post.keySet());\r\n            }\r\n            Arrays.sort(enabledMimes);\r\n            \r\n            StringBuffer enabledMimesTxt = new StringBuffer();\r\n            for (int i=0; i < enabledMimes.length; i++) {\r\n                enabledMimesTxt.append(enabledMimes[i]).append(\",\");\r\n                prop.put(\"info_parser_\" + i + \"_enabledMime\",enabledMimes[i]);\r\n            }\r\n            prop.put(\"info_parser\",enabledMimes.length);\r\n            if (enabledMimesTxt.length() > 0) enabledMimesTxt.deleteCharAt(enabledMimesTxt.length()-1);            \r\n            \r\n            env.setConfig(\"parseableMimeTypes\",enabledMimesTxt.toString());\r\n            \r\n            prop.put(\"info\", 18);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // nothing made\r\n        prop.put(\"info\", 1);//no information submitted\r\n        return prop;\r\n    }","id":81153,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        if (post == null) {\r\n            prop.put(\"info\", 1);//no information submitted\r\n            return prop;\r\n        }\r\n        \r\n        // admin password\r\n        if (post.containsKey(\"adminaccount\")) {\r\n            // read and process data\r\n            String user   = (String) post.get(\"adminuser\");\r\n            String pw1    = (String) post.get(\"adminpw1\");\r\n            String pw2    = (String) post.get(\"adminpw2\");\r\n            // do checks\r\n            if ((user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            // check passed. set account:\r\n            env.setConfig(\"adminAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"adminAccount\", \"\");\r\n            prop.put(\"info\", 5);//admin account changed\r\n            prop.put(\"info_user\", user);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // proxy password\r\n        if (post.containsKey(\"proxyaccount\")) {\r\n            // set new port\r\n            String port = (String) post.get(\"port\");\r\n            env.setConfig(\"port\", port);\r\n            prop.put(\"info_port\", port);\r\n\r\n            // read and process data\r\n            String filter = (String) post.get(\"proxyfilter\");\r\n            String user   = (String) post.get(\"proxyuser\");\r\n            String pw1    = (String) post.get(\"proxypw1\");\r\n            String pw2    = (String) post.get(\"proxypw2\");\r\n            // do checks\r\n            if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"proxyClient\", filter);\r\n            if (pw1.length() == 0) {\r\n                // only ip filter setting without account\r\n                env.setConfig(\"proxyAccountBase64MD5\", \"\");\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 6);//proxy account has changed(no pw)\r\n                prop.put(\"info_filter\", filter);\r\n            } else {\r\n                // also paccount setting\r\n                env.setConfig(\"proxyAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 7);//proxy account has changed\r\n                prop.put(\"info_user\", user);\r\n                prop.put(\"info_filter\", filter);\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        // http networking\r\n        if (post.containsKey(\"httpNetworking\")) {\r\n            \r\n            // set transparent proxy flag\r\n            httpdProxyHandler.isTransparentProxy = post.containsKey(\"isTransparentProxy\");\r\n            env.setConfig(\"isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"true\" : \"false\");\r\n            prop.put(\"info_isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"on\" : \"off\");            \r\n            \r\n            // setting the keep alive property\r\n            httpd.keepAliveSupport = post.containsKey(\"connectionKeepAliveSupport\");\r\n            env.setConfig(\"connectionKeepAliveSupport\", httpd.keepAliveSupport ? \"true\" : \"false\");\r\n            prop.put(\"info_connectionKeepAliveSupport\", httpd.keepAliveSupport ? \"on\" : \"off\"); \r\n            \r\n            prop.put(\"info\", 20);             \r\n            return prop;\r\n        }\r\n        \r\n        // server password\r\n        if (post.containsKey(\"serveraccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"serverfilter\");\r\n            String user   = (String) post.get(\"serveruser\");\r\n            String pw1    = (String) post.get(\"serverpw1\");\r\n            String pw2    = (String) post.get(\"serverpw2\");\r\n            // do checks\r\n            if (filter == null) {\r\n                //if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"serverClient\", filter);\r\n            env.setConfig(\"serverAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"serverAccount\", \"\");\r\n            \r\n            prop.put(\"info\", 8);//server access filter updated\r\n            prop.put(\"info_user\", user);\r\n            prop.put(\"info_filter\", filter);\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"dispop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"false\");\r\n            prop.put(\"info\", 9);//popup disabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"enpop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"true\");\r\n            prop.put(\"info\", 10);//popup enabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"pmode\")) {\r\n            env.setConfig(\"onlineMode\", \"2\");\r\n            prop.put(\"info\", 11);//permanent online mode\r\n            yacyCore.triggerOnlineAction();\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"generalsettings\")) {\r\n            /*\r\n            // set peer language\r\n            String peerLang = (String) post.get(\"peerlang\");\r\n            if ((peerLang == null) || (peerLang.equals(\"en\"))) peerLang = \"default\";\r\n\t    HashMap lm = langMap(env);\r\n\t    if (!(lm.containsKey(peerLang))) peerLang = \"default\";\r\n\t    env.setConfig(\"htLocaleSelection\", peerLang);\r\n\t    prop.put(\"info_peerLang\", (String) lm.get(peerLang));\r\n            */\r\n            \r\n            // check if peer name already exists\r\n            String peerName = (String) post.get(\"peername\");\r\n            yacySeed oldSeed = yacyCore.seedDB.lookupByName(peerName);\r\n            \r\n            if ((oldSeed == null) || (env.getConfig(\"peerName\",\"\").equals(peerName))) {\r\n                // the name is new\r\n                boolean nameOK = (peerName.length() <= 80);\r\n                for (int i = 0; i < peerName.length(); i++) {\r\n                    if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\".indexOf(peerName.charAt(i)) < 0) nameOK = false;\r\n                }\r\n                if (!(nameOK)) {\r\n                    // deny change\r\n                    prop.put(\"info\", 17);//peer name is wrong\r\n                } else {\r\n                    \r\n                    // set values\r\n                    env.setConfig(\"peerName\", peerName);\r\n                    prop.put(\"info\", 12);//port or peername changed\r\n                    prop.put(\"info_peerName\", peerName);\r\n                }\r\n            } else {\r\n                // deny change\r\n                prop.put(\"info\", 16);//peer name is already used by another peer\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"proxysettings\")) {\r\n            httpdProxyHandler.remoteProxyUse = ((String) post.get(\"remoteProxyUse\", \"\")).equals(\"on\");\r\n            httpdProxyHandler.remoteProxyHost = (String) post.get(\"remoteProxyHost\", \"\");\r\n            try {\r\n                httpdProxyHandler.remoteProxyPort = Integer.parseInt((String) post.get(\"remoteProxyPort\", \"\"));\r\n            } catch (NumberFormatException e) {\r\n                httpdProxyHandler.remoteProxyPort = 3128;\r\n            }\r\n            httpdProxyHandler.remoteProxyNoProxy = (String) post.get(\"remoteProxyNoProxy\", \"\");\r\n            httpdProxyHandler.remoteProxyNoProxyPatterns = httpdProxyHandler.remoteProxyNoProxy.split(\",\");\r\n            env.setConfig(\"remoteProxyHost\", httpdProxyHandler.remoteProxyHost);\r\n            env.setConfig(\"remoteProxyPort\", \"\" + httpdProxyHandler.remoteProxyPort);\r\n            env.setConfig(\"remoteProxyNoProxy\", httpdProxyHandler.remoteProxyNoProxy);\r\n            env.setConfig(\"remoteProxyUse\", (httpdProxyHandler.remoteProxyUse) ? \"true\" : \"false\");\r\n            prop.put(\"info\", 15); // The remote-proxy setting has been changed\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedSettings\")) {            \r\n            try {\r\n                // getting the currently used uploading method\r\n                String oldSeedUploadMethod = env.getConfig(\"seedUploadMethod\",\"none\");\r\n                String newSeedUploadMethod = (String)post.get(\"seedUploadMethod\");\r\n                String oldSeedURLStr = env.getConfig(\"seedURL\",\"\");\r\n                String newSeedURLStr = (String)post.get(\"seedURL\");\r\n                new URL(newSeedURLStr);\r\n                \r\n                boolean seedUrlChanged = !oldSeedURLStr.equals(newSeedURLStr);\r\n                boolean uploadMethodChanged = !oldSeedUploadMethod.equals(newSeedUploadMethod);\r\n                if (uploadMethodChanged) {\r\n                    uploadMethodChanged = yacyCore.changeSeedUploadMethod(newSeedUploadMethod); \r\n                }\r\n\r\n                if (seedUrlChanged || uploadMethodChanged) {\r\n                    env.setConfig(\"seedUploadMethod\", newSeedUploadMethod);\r\n                    env.setConfig(\"seedURL\", newSeedURLStr);\r\n                    \r\n                    // trying to upload the seed-list file\r\n                    yacyCore.saveSeedList(env);\r\n                    \r\n                    // we have successfully uploaded the seed-list file\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",(newSeedUploadMethod.equalsIgnoreCase(\"none\")?0:1));\r\n                    prop.put(\"info\", 19);                                     \r\n                } else {\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",0);\r\n                    prop.put(\"info\", 19);                    \r\n                    \r\n                }\r\n            } catch (Exception e) {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\"); \r\n            }\r\n            return prop;            \r\n        }\r\n        \r\n        /* \r\n         * Loop through the available seed uploaders to see if the \r\n         * configuration of one of them has changed \r\n         */\r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            // getting the uploader module name\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            \r\n            \r\n            // determining if the user has reconfigured the settings of this uploader\r\n            if (post.containsKey(\"seed\" + uploaderName + \"Settings\")) {\r\n                nothingChanged = true;\r\n                yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n                String[] configOptions = theUploader.getConfigurationOptions();\r\n                if (configOptions != null) {\r\n                    for (int i=0; i<configOptions.length; i++) {\r\n                        String newSettings = post.get(configOptions[i],\"\");\r\n                        String oldSettings = env.getConfig(configOptions[i],\"\");\r\n                        nothingChanged &= newSettings.equals(oldSettings); \r\n                        if (!nothingChanged) {\r\n                            env.setConfig(configOptions[i],newSettings);\r\n                        }\r\n                    }\r\n                }   \r\n                if (!nothingChanged) {\r\n                    // if the seed upload method is equal to the seed uploader whose settings\r\n                    // were changed, we now try to upload the seed list with the new settings\r\n                    if (env.getConfig(\"seedUploadMethod\",\"none\").equalsIgnoreCase(uploaderName)) {\r\n                        try {\r\n                            yacyCore.saveSeedList(env);\r\n                            \r\n                            // we have successfully uploaded the seed file\r\n                            prop.put(\"info\", 13);\r\n                            prop.put(\"info_success\",1);\r\n                        } catch (Exception e) {\r\n                            // if uploading failed we print out an error message\r\n                            prop.put(\"info\", 14);\r\n                            prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                            env.setConfig(\"seedUploadMethod\",\"none\");                            \r\n                        }                       \r\n                    } else {\r\n                        prop.put(\"info\", 13);\r\n                        prop.put(\"info_success\",0);\r\n                    }\r\n                } else {\r\n                    prop.put(\"info\", 13);\r\n                    prop.put(\"info_success\",0);\r\n                }\r\n                return prop;\r\n            }            \r\n        }\r\n        \r\n        if (post.containsKey(\"parserSettings\")) {   \r\n            plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n\t\t\tpost.remove(\"parserSettings\");\r\n            \r\n            String[] enabledMimes = null;\r\n            if (post.containsKey(\"allParserEnabled\")) {\r\n                // enable all available parsers\r\n                enabledMimes = sb.parser.setEnabledParserList(sb.parser.getAvailableParserList().keySet());\r\n            } else {\r\n                // activate all received parsers       \r\n                enabledMimes = sb.parser.setEnabledParserList(post.keySet());\r\n            }\r\n            Arrays.sort(enabledMimes);\r\n            \r\n            StringBuffer enabledMimesTxt = new StringBuffer();\r\n            for (int i=0; i < enabledMimes.length; i++) {\r\n                enabledMimesTxt.append(enabledMimes[i]).append(\",\");\r\n                prop.put(\"info_parser_\" + i + \"_enabledMime\",enabledMimes[i]);\r\n            }\r\n            prop.put(\"info_parser\",enabledMimes.length);\r\n            if (enabledMimesTxt.length() > 0) enabledMimesTxt.deleteCharAt(enabledMimesTxt.length()-1);            \r\n            \r\n            env.setConfig(\"parseableMimeTypes\",enabledMimesTxt.toString());\r\n            \r\n            prop.put(\"info\", 18);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // nothing made\r\n        prop.put(\"info\", 1);//no information submitted\r\n        return prop;\r\n    }","commit_id":"a566588e9bdcc02197d9d2de0fc81411a4698f03","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        prop.put(\"port\", env.getConfig(\"port\", \"8080\"));\r\n        prop.put(\"isTransparentProxy\", env.getConfig(\"isTransparentProxy\", \"false\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"peerName\", env.getConfig(\"peerName\", \"nameless\"));\r\n\tString peerLang = env.getConfig(\"htLocaleSelection\", \"default\");\r\n\tif (peerLang.equals(\"default\")) peerLang = \"en\";\r\n        prop.put(\"peerLang\", peerLang);\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        // admin password\r\n        if (env.getConfig(\"adminAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"adminuser\",\"admin\");\r\n        } else {\r\n            s = env.getConfig(\"adminAccount\", \"admin:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"adminuser\",\"admin\");\r\n            } else {\r\n                prop.put(\"adminuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // remote proxy\r\n        prop.put(\"remoteProxyHost\", env.getConfig(\"remoteProxyHost\", \"\"));\r\n        prop.put(\"remoteProxyPort\", env.getConfig(\"remoteProxyPort\", \"\"));\r\n        prop.put(\"remoteProxyNoProxy\", env.getConfig(\"remoteProxyNoProxy\", \"\"));\r\n        prop.put(\"remoteProxyUseChecked\", ((String) env.getConfig(\"remoteProxyUse\", \"false\")).equals(\"true\") ? 1 : 0);\r\n        \r\n        // proxy access filter\r\n        prop.put(\"proxyfilter\", env.getConfig(\"proxyClient\", \"*\"));\r\n        \r\n        // proxy password\r\n        if (env.getConfig(\"proxyAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"proxyuser\",\"proxy\");\r\n        } else {\r\n            s = env.getConfig(\"proxyAccount\", \"proxy:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"proxyuser\",\"proxy\");\r\n            } else {\r\n                prop.put(\"proxyuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // server access filter\r\n        prop.put(\"serverfilter\", env.getConfig(\"serverClient\", \"*\"));\r\n        \r\n        // server password\r\n        if (env.getConfig(\"serverAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"serveruser\",\"server\");\r\n        } else {\r\n            s = env.getConfig(\"serverAccount\", \"server:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"serveruser\",\"server\");\r\n            } else {\r\n                prop.put(\"serveruser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // clientIP\r\n        prop.put(\"clientIP\", (String) header.get(\"CLIENTIP\", \"<unknown>\")); // read an artificial header addendum\r\n        \r\n        /* \r\n         * seed upload settings\r\n         */\r\n        // available methods\r\n        String enabledUploader = env.getConfig(\"seedUploadMethod\", \"none\");\r\n        \r\n        // for backward compatiblity ....\r\n        if ((enabledUploader.equalsIgnoreCase(\"Ftp\")) || \r\n                ((enabledUploader.equals(\"\")) &&\r\n                 (env.getConfig(\"seedFTPPassword\",\"\").length() > 0) &&\r\n                 (env.getConfig(\"seedFilePath\", \"\").length() > 0))) {\r\n            enabledUploader = \"Ftp\";\r\n            env.setConfig(\"seedUploadMethod\",enabledUploader);\r\n        }                  \r\n        \r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        prop.put(\"seedUploadMethods\", uploaders.size() + 1);\r\n        prop.put(\"seedUploadMethods_0_name\", \"none\");\r\n        prop.put(\"seedUploadMethods_0_selected\", enabledUploader.equals(\"none\")?1:0);\r\n        prop.put(\"seedUploadMethods_0_file\", \"\");\r\n        \r\n        int count = 0;\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            count++;\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_name\", uploaderName);\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_selected\", uploaderName.equals(enabledUploader)?1:0);            \r\n            prop.put(\"seedUploadMethods_\" +count+ \"_file\", \"yacy/seedUpload/yacySeedUpload\" + uploaderName + \".html\");\r\n            \r\n            yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n            String[] configOptions = theUploader.getConfigurationOptions();\r\n            if (configOptions != null) {\r\n                for (int i=0; i<configOptions.length; i++) {\r\n                    prop.put(\"seedUploadMethods_\" +count+ \"_\" + configOptions[i], env.getConfig(configOptions[i], \"\"));\r\n                    // prop.put(\"seedUpload\" + uploaderName,1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // general settings\r\n        prop.put(\"seedURL\", env.getConfig(\"seedURL\", \"\"));\r\n        \r\n        \r\n        /*\r\n         * Parser Configuration\r\n         */\r\n        plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n        Hashtable enabledParsers = sb.parser.getEnabledParserList();\r\n        Hashtable availableParsers = sb.parser.getAvailableParserList();\r\n        \r\n        // fetching a list of all available mimetypes\r\n        List availableParserKeys = Arrays.asList(availableParsers.keySet().toArray(new String[availableParsers.size()]));\r\n        \r\n        // sort it\r\n        Collections.sort(availableParserKeys);\r\n        \r\n        // loop through the mimeTypes and add it to the properties\r\n        boolean allParsersEnabled = true;\r\n        int parserIdx = 0;\r\n        Iterator availableParserIter = availableParserKeys.iterator();\r\n        while (availableParserIter.hasNext()) {\r\n            String mimeType = (String) availableParserIter.next();\r\n            String parserName = (String) availableParsers.get(mimeType);\r\n            boolean parserIsEnabled = enabledParsers.containsKey(mimeType);\r\n            \r\n            prop.put(\"parser_\" + parserIdx + \"_mime\", mimeType);\r\n            prop.put(\"parser_\" + parserIdx + \"_name\", parserName);\r\n            prop.put(\"parser_\" + parserIdx + \"_shortname\", parserName.substring(parserName.lastIndexOf(\".\")+1));\r\n            prop.put(\"parser_\" + parserIdx + \"_status\", parserIsEnabled ? 1:0);\r\n            allParsersEnabled &= parserIsEnabled;\r\n            \r\n            parserIdx++;\r\n        }\r\n        \r\n        prop.put(\"allParserEnabled\",allParsersEnabled ? 1:0);\r\n        prop.put(\"parser\", parserIdx);\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":81154,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        prop.put(\"port\", env.getConfig(\"port\", \"8080\"));               \r\n        \r\n        prop.put(\"peerName\", env.getConfig(\"peerName\", \"nameless\"));\r\n\tString peerLang = env.getConfig(\"htLocaleSelection\", \"default\");\r\n\tif (peerLang.equals(\"default\")) peerLang = \"en\";\r\n        prop.put(\"peerLang\", peerLang);\r\n        \r\n        // http networking settings\r\n        prop.put(\"isTransparentProxy\", env.getConfig(\"isTransparentProxy\", \"false\").equals(\"true\") ? 1 : 0); \r\n        prop.put(\"connectionKeepAliveSupport\", env.getConfig(\"connectionKeepAliveSupport\", \"false\").equals(\"true\") ? 1 : 0);\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        // admin password\r\n        if (env.getConfig(\"adminAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"adminuser\",\"admin\");\r\n        } else {\r\n            s = env.getConfig(\"adminAccount\", \"admin:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"adminuser\",\"admin\");\r\n            } else {\r\n                prop.put(\"adminuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // remote proxy\r\n        prop.put(\"remoteProxyHost\", env.getConfig(\"remoteProxyHost\", \"\"));\r\n        prop.put(\"remoteProxyPort\", env.getConfig(\"remoteProxyPort\", \"\"));\r\n        prop.put(\"remoteProxyNoProxy\", env.getConfig(\"remoteProxyNoProxy\", \"\"));\r\n        prop.put(\"remoteProxyUseChecked\", ((String) env.getConfig(\"remoteProxyUse\", \"false\")).equals(\"true\") ? 1 : 0);\r\n        \r\n        // proxy access filter\r\n        prop.put(\"proxyfilter\", env.getConfig(\"proxyClient\", \"*\"));\r\n        \r\n        // proxy password\r\n        if (env.getConfig(\"proxyAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"proxyuser\",\"proxy\");\r\n        } else {\r\n            s = env.getConfig(\"proxyAccount\", \"proxy:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"proxyuser\",\"proxy\");\r\n            } else {\r\n                prop.put(\"proxyuser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // server access filter\r\n        prop.put(\"serverfilter\", env.getConfig(\"serverClient\", \"*\"));\r\n        \r\n        // server password\r\n        if (env.getConfig(\"serverAccountBase64\", \"\").length() == 0) {\r\n            // no password has been specified\r\n            prop.put(\"serveruser\",\"server\");\r\n        } else {\r\n            s = env.getConfig(\"serverAccount\", \"server:void\");\r\n            pos = s.indexOf(\":\");\r\n            if (pos < 0) {\r\n                prop.put(\"serveruser\",\"server\");\r\n            } else {\r\n                prop.put(\"serveruser\",s.substring(0, pos));\r\n            }\r\n        }\r\n        \r\n        // clientIP\r\n        prop.put(\"clientIP\", (String) header.get(\"CLIENTIP\", \"<unknown>\")); // read an artificial header addendum\r\n        \r\n        /* \r\n         * seed upload settings\r\n         */\r\n        // available methods\r\n        String enabledUploader = env.getConfig(\"seedUploadMethod\", \"none\");\r\n        \r\n        // for backward compatiblity ....\r\n        if ((enabledUploader.equalsIgnoreCase(\"Ftp\")) || \r\n                ((enabledUploader.equals(\"\")) &&\r\n                 (env.getConfig(\"seedFTPPassword\",\"\").length() > 0) &&\r\n                 (env.getConfig(\"seedFilePath\", \"\").length() > 0))) {\r\n            enabledUploader = \"Ftp\";\r\n            env.setConfig(\"seedUploadMethod\",enabledUploader);\r\n        }                  \r\n        \r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        prop.put(\"seedUploadMethods\", uploaders.size() + 1);\r\n        prop.put(\"seedUploadMethods_0_name\", \"none\");\r\n        prop.put(\"seedUploadMethods_0_selected\", enabledUploader.equals(\"none\")?1:0);\r\n        prop.put(\"seedUploadMethods_0_file\", \"\");\r\n        \r\n        int count = 0;\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            count++;\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_name\", uploaderName);\r\n            prop.put(\"seedUploadMethods_\" +count+ \"_selected\", uploaderName.equals(enabledUploader)?1:0);            \r\n            prop.put(\"seedUploadMethods_\" +count+ \"_file\", \"yacy/seedUpload/yacySeedUpload\" + uploaderName + \".html\");\r\n            \r\n            yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n            String[] configOptions = theUploader.getConfigurationOptions();\r\n            if (configOptions != null) {\r\n                for (int i=0; i<configOptions.length; i++) {\r\n                    prop.put(\"seedUploadMethods_\" +count+ \"_\" + configOptions[i], env.getConfig(configOptions[i], \"\"));\r\n                    // prop.put(\"seedUpload\" + uploaderName,1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // general settings\r\n        prop.put(\"seedURL\", env.getConfig(\"seedURL\", \"\"));\r\n        \r\n        \r\n        /*\r\n         * Parser Configuration\r\n         */\r\n        plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n        Hashtable enabledParsers = sb.parser.getEnabledParserList();\r\n        Hashtable availableParsers = sb.parser.getAvailableParserList();\r\n        \r\n        // fetching a list of all available mimetypes\r\n        List availableParserKeys = Arrays.asList(availableParsers.keySet().toArray(new String[availableParsers.size()]));\r\n        \r\n        // sort it\r\n        Collections.sort(availableParserKeys);\r\n        \r\n        // loop through the mimeTypes and add it to the properties\r\n        boolean allParsersEnabled = true;\r\n        int parserIdx = 0;\r\n        Iterator availableParserIter = availableParserKeys.iterator();\r\n        while (availableParserIter.hasNext()) {\r\n            String mimeType = (String) availableParserIter.next();\r\n            String parserName = (String) availableParsers.get(mimeType);\r\n            boolean parserIsEnabled = enabledParsers.containsKey(mimeType);\r\n            \r\n            prop.put(\"parser_\" + parserIdx + \"_mime\", mimeType);\r\n            prop.put(\"parser_\" + parserIdx + \"_name\", parserName);\r\n            prop.put(\"parser_\" + parserIdx + \"_shortname\", parserName.substring(parserName.lastIndexOf(\".\")+1));\r\n            prop.put(\"parser_\" + parserIdx + \"_status\", parserIsEnabled ? 1:0);\r\n            allParsersEnabled &= parserIsEnabled;\r\n            \r\n            parserIdx++;\r\n        }\r\n        \r\n        prop.put(\"allParserEnabled\",allParsersEnabled ? 1:0);\r\n        prop.put(\"parser\", parserIdx);\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"a566588e9bdcc02197d9d2de0fc81411a4698f03","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * If canCommit, and we have received all the data, and it\n     * verifies, then commit it.\n     */\n    private void finish() {\n        Message toSend = null;\n        synchronized(this) { // REDFLAG do not use synch(this) for any other purpose!\n            if(!canCommit) return;\n            if(!prb.allReceived()) return;\n            try {\n                CHKBlock block = new CHKBlock(prb.getBlock(), headers, key);\n                node.store(block);\n            } catch (CHKVerifyException e) {\n                Logger.error(this, \"Verify failed in InsertHandler: \"+e+\" - headers: \"+HexUtil.bytesToHex(headers), e);\n                toSend = DMT.createFNPDataInsertRejected(uid, DMT.DATA_INSERT_REJECTED_VERIFY_FAILED);\n            }\n        }\n        if(toSend != null) {\n            source.sendAsync(toSend);\n        } else {\n            // Succeeded! Yay!\n            Message msg = DMT.createFNPInsertReply(uid);\n            try {\n                source.send(msg);\n            } catch (NotConnectedException e) {\n                // Ugh\n                Logger.normal(this, \"Finished InsertHandler but can't tell original node!: \"+e);\n            }\n        }\n    }","id":81155,"modified_method":"/**\n     * If canCommit, and we have received all the data, and it\n     * verifies, then commit it.\n     */\n    private void finish() {\n        Message toSend = null;\n        synchronized(this) { // REDFLAG do not use synch(this) for any other purpose!\n            if(!canCommit) return;\n            if(!prb.allReceived()) return;\n            try {\n                CHKBlock block = new CHKBlock(prb.getBlock(), headers, key);\n                node.store(block);\n            } catch (CHKVerifyException e) {\n                Logger.error(this, \"Verify failed in InsertHandler: \"+e+\" - headers: \"+HexUtil.bytesToHex(headers), e);\n                toSend = DMT.createFNPDataInsertRejected(uid, DMT.DATA_INSERT_REJECTED_VERIFY_FAILED);\n            }\n        }\n        if(toSend != null) {\n            try {\n                source.sendAsync(toSend);\n            } catch (NotConnectedException e) {\n                // :(\n                Logger.minor(this, \"Lost connection in \"+this+\" when sending FNPDataInsertRejected\");\n            }\n        } else {\n            // Succeeded! Yay!\n            Message msg = DMT.createFNPInsertReply(uid);\n            try {\n                source.send(msg);\n            } catch (NotConnectedException e) {\n                // Ugh\n                Logger.normal(this, \"Finished InsertHandler but can't tell original node!: \"+e);\n            }\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an incoming SwapRequest\n     * @return True if we have handled the message, false if it needs\n     * to be handled otherwise.\n     */\n    public boolean handleSwapRequest(Message m) {\n        PeerNode pn = (PeerNode)m.getSource();\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        long oid = uid+1;\n        // We have two separate IDs so we can deal with two visits\n        // separately. This is because we want it to be as random \n        // as possible.\n        // This means we can and should check for the same ID being\n        // sent twice.\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item != null) {\n            Logger.minor(this, \"Rejecting - same ID as previous request\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(uid);\n            pn.sendAsync(reject);\n            swapsRejectedRecognizedID++;\n            return true;\n        }\n        if(pn.shouldRejectSwapRequest()) {\n            Logger.minor(this, \"Advised to reject SwapRequest by PeerNode - rate limit\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(uid);\n            pn.sendAsync(reject);\n            swapsRejectedRateLimit++;\n            return true;\n        }\n        Logger.minor(this, \"SwapRequest from \"+pn+\" - uid=\"+uid);\n        int htl = m.getInt(DMT.HTL)-1;\n        // Either forward it or handle it\n        if(htl == 0) {\n            Logger.minor(this, \"Accepting?... \"+uid);\n            // Accept - handle locally\n            if(!lock()) {\n                Logger.minor(this, \"Can't obtain lock on \"+uid);\n                // Reject\n                Message reject = DMT.createFNPSwapRejected(uid);\n                pn.sendAsync(reject);\n                swapsRejectedAlreadyLocked++;\n                return true;\n            }\n            try {\n                // Locked, do it\n                IncomingSwapRequestHandler isrh =\n                    new IncomingSwapRequestHandler(m, pn);\n                Logger.minor(this, \"Handling... \"+uid);\n                Thread t = new Thread(isrh, \"Incoming swap request handler for port \"+node.portNumber);\n                t.setDaemon(true);\n                t.start();\n                return true;\n            } catch (Error e) {\n                unlock();\n                throw e;\n            } catch (RuntimeException e) {\n                unlock();\n                throw e;\n            }\n        } else {\n            m.set(DMT.HTL, htl);\n            m.set(DMT.UID, oid);\n            Logger.minor(this, \"Forwarding... \"+uid);\n            while(true) {\n                try {\n                    // Forward\n                    PeerNode randomPeer = node.peers.getRandomPeer(pn);\n                    if(randomPeer == null) {\n                        Logger.minor(this, \"Late reject \"+uid);\n                        Message reject = DMT.createFNPSwapRejected(uid);\n                        pn.sendAsync(reject);\n                        swapsRejectedNowhereToGo++;\n                        return true;\n                    }\n                    Logger.minor(this, \"Forwarding \"+uid+\" to \"+randomPeer);\n                    addForwardedItem(uid, oid, pn, randomPeer);\n                    node.usm.send(randomPeer, m);\n                    return true;\n                } catch (NotConnectedException e) {\n                    // Try again\n                }\n            }\n        }\n    }","id":81156,"modified_method":"/**\n     * Handle an incoming SwapRequest\n     * @return True if we have handled the message, false if it needs\n     * to be handled otherwise.\n     */\n    public boolean handleSwapRequest(Message m) {\n        PeerNode pn = (PeerNode)m.getSource();\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        long oid = uid+1;\n        // We have two separate IDs so we can deal with two visits\n        // separately. This is because we want it to be as random \n        // as possible.\n        // This means we can and should check for the same ID being\n        // sent twice.\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item != null) {\n            Logger.minor(this, \"Rejecting - same ID as previous request\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(uid);\n            try {\n                pn.sendAsync(reject);\n            } catch (NotConnectedException e) {\n                Logger.minor(this, \"Lost connection to \"+pn+\" rejecting SwapRequest\");\n            }\n            swapsRejectedRecognizedID++;\n            return true;\n        }\n        if(pn.shouldRejectSwapRequest()) {\n            Logger.minor(this, \"Advised to reject SwapRequest by PeerNode - rate limit\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(uid);\n            try {\n                pn.sendAsync(reject);\n            } catch (NotConnectedException e) {\n                Logger.minor(this, \"Lost connection rejecting SwapRequest from \"+pn);\n            }\n            swapsRejectedRateLimit++;\n            return true;\n        }\n        Logger.minor(this, \"SwapRequest from \"+pn+\" - uid=\"+uid);\n        int htl = m.getInt(DMT.HTL)-1;\n        // Either forward it or handle it\n        if(htl == 0) {\n            Logger.minor(this, \"Accepting?... \"+uid);\n            // Accept - handle locally\n            if(!lock()) {\n                Logger.minor(this, \"Can't obtain lock on \"+uid);\n                // Reject\n                Message reject = DMT.createFNPSwapRejected(uid);\n                try {\n                    pn.sendAsync(reject);\n                } catch (NotConnectedException e1) {\n                    Logger.minor(this, \"Lost connection rejecting SwapRequest (locked) from \"+pn);\n                }\n                swapsRejectedAlreadyLocked++;\n                return true;\n            }\n            try {\n                // Locked, do it\n                IncomingSwapRequestHandler isrh =\n                    new IncomingSwapRequestHandler(m, pn);\n                Logger.minor(this, \"Handling... \"+uid);\n                Thread t = new Thread(isrh, \"Incoming swap request handler for port \"+node.portNumber);\n                t.setDaemon(true);\n                t.start();\n                return true;\n            } catch (Error e) {\n                unlock();\n                throw e;\n            } catch (RuntimeException e) {\n                unlock();\n                throw e;\n            }\n        } else {\n            m.set(DMT.HTL, htl);\n            m.set(DMT.UID, oid);\n            Logger.minor(this, \"Forwarding... \"+uid);\n            while(true) {\n                try {\n                    // Forward\n                    PeerNode randomPeer = node.peers.getRandomPeer(pn);\n                    if(randomPeer == null) {\n                        Logger.minor(this, \"Late reject \"+uid);\n                        Message reject = DMT.createFNPSwapRejected(uid);\n                        pn.sendAsync(reject);\n                        swapsRejectedNowhereToGo++;\n                        return true;\n                    }\n                    Logger.minor(this, \"Forwarding \"+uid+\" to \"+randomPeer);\n                    addForwardedItem(uid, oid, pn, randomPeer);\n                    randomPeer.sendAsync(m);\n                    // FIXME: could be disconnected before sent, in which case\n                    // we will timeout. Should catch this with some sort of\n                    // send failure handler callback. However this will be very\n                    // rare.\n                    // Note that we MUST NOT send this blocking as we are on the\n                    // receiver thread.\n                    return true;\n                } catch (NotConnectedException e) {\n                    // Try again\n                }\n            }\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapCommit\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapCommit(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) return false;\n        if(item.routedTo == null) return false;\n        if(m.getSource() != item.requestSender) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.requestSender+\" to \"+item.routedTo);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        Logger.minor(this, \"Forwarding SwapCommit \"+uid+\",\"+item.outgoingID+\" from \"+m.getSource()+\" to \"+item.routedTo);\n        // Sending onwards - use outgoing ID\n        m.set(DMT.UID, item.outgoingID);\n        item.routedTo.sendAsync(m);\n        return true;\n    }","id":81157,"modified_method":"/**\n     * Handle an unmatched FNPSwapCommit\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapCommit(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) return false;\n        if(item.routedTo == null) return false;\n        if(m.getSource() != item.requestSender) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.requestSender+\" to \"+item.routedTo);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        Logger.minor(this, \"Forwarding SwapCommit \"+uid+\",\"+item.outgoingID+\" from \"+m.getSource()+\" to \"+item.routedTo);\n        // Sending onwards - use outgoing ID\n        m.set(DMT.UID, item.outgoingID);\n        try {\n            item.routedTo.sendAsync(m);\n        } catch (NotConnectedException e) {\n            Logger.minor(this, \"Lost connection forwarding SwapCommit \"+uid+\" to \"+item.routedTo);\n        }\n        return true;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapReply\n     * @return True if we recognized and forwarded this reply.\n     */\n    public boolean handleSwapReply(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) {\n            Logger.error(this, \"Unrecognized SwapReply: ID \"+uid);\n            return false;\n        }\n        if(item.requestSender == null) return false;\n        if(item == null) {\n            Logger.minor(this, \"SwapReply from \"+m.getSource()+\" on chain originated locally \"+uid);\n            return false;\n        }\n        if(m.getSource() != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        Logger.minor(this, \"Forwarding SwapReply \"+uid+\" from \"+m.getSource()+\" to \"+item.requestSender);\n        item.requestSender.sendAsync(m);\n        return true;\n    }","id":81158,"modified_method":"/**\n     * Handle an unmatched FNPSwapReply\n     * @return True if we recognized and forwarded this reply.\n     */\n    public boolean handleSwapReply(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) {\n            Logger.error(this, \"Unrecognized SwapReply: ID \"+uid);\n            return false;\n        }\n        if(item.requestSender == null) return false;\n        if(item == null) {\n            Logger.minor(this, \"SwapReply from \"+m.getSource()+\" on chain originated locally \"+uid);\n            return false;\n        }\n        if(m.getSource() != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        Logger.minor(this, \"Forwarding SwapReply \"+uid+\" from \"+m.getSource()+\" to \"+item.requestSender);\n        try {\n            item.requestSender.sendAsync(m);\n        } catch (NotConnectedException e) {\n            Logger.minor(this, \"Lost connection forwarding SwapReply \"+uid+\" to \"+item.requestSender);\n        }\n        return true;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapComplete\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapComplete(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Logger.minor(this, \"handleSwapComplete(\"+uid+\")\");\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) {\n            Logger.minor(this, \"Item not found: \"+uid+\": \"+m);\n            return false;\n        }\n        if(item.requestSender == null) {\n            Logger.minor(this, \"Not matched \"+uid+\": \"+m);\n            return false;\n        }\n        if(m.getSource() != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        Logger.minor(this, \"Forwarding SwapComplete \"+uid+\" from \"+m.getSource()+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        item.requestSender.sendAsync(m);\n        item.lastMessageTime = System.currentTimeMillis();\n        recentlyForwardedIDs.remove(luid);\n        return true;\n    }","id":81159,"modified_method":"/**\n     * Handle an unmatched FNPSwapComplete\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapComplete(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Logger.minor(this, \"handleSwapComplete(\"+uid+\")\");\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) {\n            Logger.minor(this, \"Item not found: \"+uid+\": \"+m);\n            return false;\n        }\n        if(item.requestSender == null) {\n            Logger.minor(this, \"Not matched \"+uid+\": \"+m);\n            return false;\n        }\n        if(m.getSource() != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        Logger.minor(this, \"Forwarding SwapComplete \"+uid+\" from \"+m.getSource()+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        try {\n            item.requestSender.sendAsync(m);\n        } catch (NotConnectedException e) {\n            Logger.normal(this, \"Lost connection forwarding SwapComplete \"+uid+\" to \"+item.requestSender);\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        recentlyForwardedIDs.remove(luid);\n        return true;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapRejected\n     * @return True if we recognized and forwarded this message.\n     * FIXME: Implement backtracking.\n     */\n    public boolean handleSwapRejected(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) return false;\n        if(item.requestSender == null) return false;\n        if(m.getSource() != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        recentlyForwardedIDs.remove(luid);\n        item.lastMessageTime = System.currentTimeMillis();\n        Logger.minor(this, \"Forwarding SwapRejected \"+uid+\" from \"+m.getSource()+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        item.requestSender.sendAsync(m);\n        return true;\n    }","id":81160,"modified_method":"/**\n     * Handle an unmatched FNPSwapRejected\n     * @return True if we recognized and forwarded this message.\n     * FIXME: Implement backtracking.\n     */\n    public boolean handleSwapRejected(Message m) {\n        long uid = m.getLong(DMT.UID);\n        Long luid = new Long(uid);\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(luid);\n        if(item == null) return false;\n        if(item.requestSender == null) return false;\n        if(m.getSource() != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+m.getSource()+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        recentlyForwardedIDs.remove(luid);\n        item.lastMessageTime = System.currentTimeMillis();\n        Logger.minor(this, \"Forwarding SwapRejected \"+uid+\" from \"+m.getSource()+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        try {\n            item.requestSender.sendAsync(m);\n        } catch (NotConnectedException e) {\n            Logger.minor(this, \"Lost connection forwarding SwapRejected \"+uid+\" to \"+item.requestSender);\n        }\n        return true;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Deal with a routed-to-node message that landed on this node.\n     * This is where message-type-specific code executes. \n     * @param m\n     * @return\n     */\n    private boolean dispatchRoutedMessage(Message m, PeerNode src, long id) {\n        if(m.getSpec() == DMT.FNPRoutedPing) {\n            Logger.minor(this, \"RoutedPing reached other side!\");\n            int x = m.getInt(DMT.COUNTER);\n            Message reply = DMT.createFNPRoutedPong(id, x);\n            src.sendAsync(reply);\n            return true;\n        }\n        return false;\n    }","id":81161,"modified_method":"/**\n     * Deal with a routed-to-node message that landed on this node.\n     * This is where message-type-specific code executes. \n     * @param m\n     * @return\n     */\n    private boolean dispatchRoutedMessage(Message m, PeerNode src, long id) {\n        if(m.getSpec() == DMT.FNPRoutedPing) {\n            Logger.minor(this, \"RoutedPing reached other side!\");\n            int x = m.getInt(DMT.COUNTER);\n            Message reply = DMT.createFNPRoutedPong(id, x);\n            try {\n                src.sendAsync(reply);\n            } catch (NotConnectedException e) {\n                Logger.minor(this, \"Lost connection replying to \"+m+\" in dispatchRoutedMessage\");\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"private boolean forward(Message m, long id, PeerNode pn, short htl, double target, RoutedContext ctx) {\n        Logger.minor(this, \"Should forward\");\n        // Forward\n        m = preForward(m, htl);\n        PeerNode next = node.peers.closerPeer(pn, ctx.routedTo, target, pn == null);\n        Logger.minor(this, \"Next: \"+next+\" message: \"+m);\n        if(next != null) {\n            Logger.minor(this, \"Forwarding \"+m.getSpec()+\" to \"+next.getPeer().getPort());\n            ctx.addSent(next);\n            next.sendAsync(m);\n        } else {\n            Logger.minor(this, \"Reached dead end for \"+m.getSpec()+\" on \"+node.portNumber);\n            // Reached a dead end...\n            Message reject = DMT.createFNPRoutedRejected(id, htl);\n            if(pn != null)\n                pn.sendAsync(reject);\n        }\n        return true;\n    }","id":81162,"modified_method":"private boolean forward(Message m, long id, PeerNode pn, short htl, double target, RoutedContext ctx) {\n        Logger.minor(this, \"Should forward\");\n        // Forward\n        m = preForward(m, htl);\n        while(true) {\n            PeerNode next = node.peers.closerPeer(pn, ctx.routedTo, target, pn == null);\n            Logger.minor(this, \"Next: \"+next+\" message: \"+m);\n            if(next != null) {\n                Logger.minor(this, \"Forwarding \"+m.getSpec()+\" to \"+next.getPeer().getPort());\n                ctx.addSent(next);\n                try {\n                    next.sendAsync(m);\n                } catch (NotConnectedException e) {\n                    continue;\n                }\n            } else {\n                Logger.minor(this, \"Reached dead end for \"+m.getSpec()+\" on \"+node.portNumber);\n                // Reached a dead end...\n                Message reject = DMT.createFNPRoutedRejected(id, htl);\n                if(pn != null) try {\n                    pn.sendAsync(reject);\n                } catch (NotConnectedException e) {\n                    continue;\n                }\n            }\n            return true;\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"boolean handleRoutedReply(Message m) {\n        long id = m.getLong(DMT.UID);\n        Logger.minor(this, \"Got reply: \"+m);\n        Long lid = new Long(id);\n        RoutedContext ctx = (RoutedContext) routedContexts.get(lid);\n        if(ctx == null) {\n            Logger.error(this, \"Unrecognized routed reply: \"+m);\n            return false;\n        }\n        PeerNode pn = ctx.source;\n        if(pn == null) return false;\n        pn.sendAsync(m);\n        return true;\n    }","id":81163,"modified_method":"boolean handleRoutedReply(Message m) {\n        long id = m.getLong(DMT.UID);\n        Logger.minor(this, \"Got reply: \"+m);\n        Long lid = new Long(id);\n        RoutedContext ctx = (RoutedContext) routedContexts.get(lid);\n        if(ctx == null) {\n            Logger.error(this, \"Unrecognized routed reply: \"+m);\n            return false;\n        }\n        PeerNode pn = ctx.source;\n        if(pn == null) return false;\n        try {\n            pn.sendAsync(m);\n        } catch (NotConnectedException e) {\n            Logger.minor(this, \"Lost connection forwarding \"+m+\" to \"+pn);\n        }\n        return true;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"public boolean handleMessage(Message m) {\n        PeerNode source = (PeerNode)m.getSource();\n        Logger.minor(this, \"Dispatching \"+m);\n        if(m.getSpec() == DMT.FNPPing) {\n            // Send an FNPPong\n            Message reply = DMT.createFNPPong(m.getInt(DMT.PING_SEQNO));\n            ((PeerNode)m.getSource()).sendAsync(reply);\n            return true;\n        }\n        if(m.getSpec() == DMT.FNPLocChangeNotification) {\n            double newLoc = m.getDouble(DMT.LOCATION);\n            source.updateLocation(newLoc);\n            return true;\n        }\n        if(m.getSpec() == DMT.FNPSwapRequest) {\n            return node.lm.handleSwapRequest(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapReply) {\n            return node.lm.handleSwapReply(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapRejected) {\n            return node.lm.handleSwapRejected(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapCommit) {\n            return node.lm.handleSwapCommit(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapComplete) {\n            return node.lm.handleSwapComplete(m);\n        }\n        if(m.getSpec() == DMT.FNPRoutedPing) {\n            return handleRouted(m);\n        }\n        if(m.getSpec() == DMT.FNPRoutedPong) {\n            return handleRoutedReply(m);\n        }\n        if(m.getSpec() == DMT.FNPRoutedRejected) {\n            return handleRoutedRejected(m);\n        }\n        if(m.getSpec() == DMT.FNPDataRequest) {\n            return handleDataRequest(m);\n        }\n        if(m.getSpec() == DMT.FNPInsertRequest) {\n            return handleInsertRequest(m);\n        }\n        return false;\n    }","id":81164,"modified_method":"public boolean handleMessage(Message m) {\n        PeerNode source = (PeerNode)m.getSource();\n        Logger.minor(this, \"Dispatching \"+m);\n        if(m.getSpec() == DMT.FNPPing) {\n            // Send an FNPPong\n            Message reply = DMT.createFNPPong(m.getInt(DMT.PING_SEQNO));\n            try {\n                ((PeerNode)m.getSource()).sendAsync(reply);\n            } catch (NotConnectedException e) {\n                Logger.minor(this, \"Lost connection replying to \"+m);\n            }\n            return true;\n        }\n        if(m.getSpec() == DMT.FNPLocChangeNotification) {\n            double newLoc = m.getDouble(DMT.LOCATION);\n            source.updateLocation(newLoc);\n            return true;\n        }\n        if(m.getSpec() == DMT.FNPSwapRequest) {\n            return node.lm.handleSwapRequest(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapReply) {\n            return node.lm.handleSwapReply(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapRejected) {\n            return node.lm.handleSwapRejected(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapCommit) {\n            return node.lm.handleSwapCommit(m);\n        }\n        if(m.getSpec() == DMT.FNPSwapComplete) {\n            return node.lm.handleSwapComplete(m);\n        }\n        if(m.getSpec() == DMT.FNPRoutedPing) {\n            return handleRouted(m);\n        }\n        if(m.getSpec() == DMT.FNPRoutedPong) {\n            return handleRoutedReply(m);\n        }\n        if(m.getSpec() == DMT.FNPRoutedRejected) {\n            return handleRoutedRejected(m);\n        }\n        if(m.getSpec() == DMT.FNPDataRequest) {\n            return handleDataRequest(m);\n        }\n        if(m.getSpec() == DMT.FNPInsertRequest) {\n            return handleInsertRequest(m);\n        }\n        return false;\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle a routed-to-a-specific-node message.\n     * @param m\n     * @return False if we want the message put back on the queue.\n     */\n    boolean handleRouted(Message m) {\n        Logger.minor(this, \"handleRouted(\"+m+\")\");\n        if(m.getSource() != null && (!(m.getSource() instanceof PeerNode))) {\n            Logger.error(this, \"Routed message but source \"+m.getSource()+\" not a PeerNode!\");\n            return true;\n        }\n        long id = m.getLong(DMT.UID);\n        Long lid = new Long(id);\n        PeerNode pn = (PeerNode) (m.getSource());\n        short htl = m.getShort(DMT.HTL);\n        if(pn != null) htl = pn.decrementHTL(htl);\n        RoutedContext ctx;\n        ctx = (RoutedContext)routedContexts.get(lid);\n        if(ctx != null) {\n            ((PeerNode)m.getSource()).sendAsync(DMT.createFNPRoutedRejected(id, (short)(htl-1)));\n            return true;\n        }\n        ctx = new RoutedContext(m);\n        routedContexts.put(lid, ctx);\n        // pn == null => originated locally, keep full htl\n        double target = m.getDouble(DMT.TARGET_LOCATION);\n        Logger.minor(this, \"id \"+id+\" from \"+pn+\" htl \"+htl+\" target \"+target);\n        if(node.lm.getLocation().getValue() == target) {\n            Logger.minor(this, \"Dispatching \"+m.getSpec()+\" on \"+node.portNumber);\n            // Handle locally\n            // Message type specific processing\n            dispatchRoutedMessage(m, pn, id);\n            return true;\n        } else if(htl == 0) {\n            Message reject = DMT.createFNPRoutedRejected(id, (short)0);\n            if(pn != null)\n                pn.sendAsync(reject);\n            return true;\n        } else {\n            return forward(m, id, pn, htl, target, ctx);\n        }\n    }","id":81165,"modified_method":"/**\n     * Handle a routed-to-a-specific-node message.\n     * @param m\n     * @return False if we want the message put back on the queue.\n     */\n    boolean handleRouted(Message m) {\n        Logger.minor(this, \"handleRouted(\"+m+\")\");\n        if(m.getSource() != null && (!(m.getSource() instanceof PeerNode))) {\n            Logger.error(this, \"Routed message but source \"+m.getSource()+\" not a PeerNode!\");\n            return true;\n        }\n        long id = m.getLong(DMT.UID);\n        Long lid = new Long(id);\n        PeerNode pn = (PeerNode) (m.getSource());\n        short htl = m.getShort(DMT.HTL);\n        if(pn != null) htl = pn.decrementHTL(htl);\n        RoutedContext ctx;\n        ctx = (RoutedContext)routedContexts.get(lid);\n        if(ctx != null) {\n            try {\n                ((PeerNode)m.getSource()).sendAsync(DMT.createFNPRoutedRejected(id, (short)(htl-1)));\n            } catch (NotConnectedException e) {\n                Logger.minor(this, \"Lost connection rejecting \"+m);\n            }\n            return true;\n        }\n        ctx = new RoutedContext(m);\n        routedContexts.put(lid, ctx);\n        // pn == null => originated locally, keep full htl\n        double target = m.getDouble(DMT.TARGET_LOCATION);\n        Logger.minor(this, \"id \"+id+\" from \"+pn+\" htl \"+htl+\" target \"+target);\n        if(node.lm.getLocation().getValue() == target) {\n            Logger.minor(this, \"Dispatching \"+m.getSpec()+\" on \"+node.portNumber);\n            // Handle locally\n            // Message type specific processing\n            dispatchRoutedMessage(m, pn, id);\n            return true;\n        } else if(htl == 0) {\n            Message reject = DMT.createFNPRoutedRejected(id, (short)0);\n            if(pn != null) try {\n                pn.sendAsync(reject);\n            } catch (NotConnectedException e) {\n                Logger.minor(this, \"Lost connection rejecting \"+m);\n            }\n            return true;\n        } else {\n            return forward(m, id, pn, htl, target, ctx);\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Asynchronously send this message to every connected peer.\n     */\n    public void localBroadcast(Message msg) {\n        PeerNode[] peers = connectedPeers; // avoid synchronization\n        for(int i=0;i<peers.length;i++) {\n            if(peers[i].isConnected())\n                peers[i].sendAsync(msg);\n        }\n    }","id":81166,"modified_method":"/**\n     * Asynchronously send this message to every connected peer.\n     */\n    public void localBroadcast(Message msg) {\n        PeerNode[] peers = connectedPeers; // avoid synchronization\n        for(int i=0;i<peers.length;i++) {\n            if(peers[i].isConnected()) try {\n                peers[i].sendAsync(msg);\n            } catch (NotConnectedException e) {\n                // Ignore\n            }\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Called when we have completed a handshake, and have a new session key.\n     * Creates a new tracker and demotes the old one. Deletes the old one if\n     * the bootID isn't recognized.\n     * @param bootID\n     * @param encKey\n     * @param replyTo\n     */\n    public synchronized void completedHandshake(long thisBootID, BlockCipher encKey, Peer replyTo) {\n        KeyTracker newTracker = new KeyTracker(this, encKey);\n        changedIP(replyTo);\n        previousTracker = currentTracker;\n        currentTracker = newTracker;\n        if(previousTracker != null)\n            previousTracker.deprecated();\n        \n        isConnected = true;\n        if(thisBootID != this.bootID) {\n            // Wipe old KeyTracker\n            previousTracker = null;\n            this.bootID = thisBootID;\n        } // else it's a rekey\n        Logger.normal(this, \"Completed handshake with \"+this+\" on \"+replyTo);\n        ctx = null;\n        receivedPacket();\n        node.peers.addConnectedPeer(this);\n        Message msg = DMT.createFNPLocChangeNotification(node.lm.loc.getValue());\n        \n        sendAsync(msg);\n    }","id":81167,"modified_method":"/**\n     * Called when we have completed a handshake, and have a new session key.\n     * Creates a new tracker and demotes the old one. Deletes the old one if\n     * the bootID isn't recognized.\n     * @param bootID\n     * @param encKey\n     * @param replyTo\n     */\n    public synchronized void completedHandshake(long thisBootID, BlockCipher encKey, Peer replyTo) {\n        KeyTracker newTracker = new KeyTracker(this, encKey);\n        changedIP(replyTo);\n        previousTracker = currentTracker;\n        currentTracker = newTracker;\n        if(previousTracker != null)\n            previousTracker.deprecated();\n        \n        isConnected = true;\n        if(thisBootID != this.bootID) {\n            // Wipe old KeyTracker\n            previousTracker = null;\n            this.bootID = thisBootID;\n        } // else it's a rekey\n        Logger.normal(this, \"Completed handshake with \"+this+\" on \"+replyTo);\n        ctx = null;\n        receivedPacket();\n        node.peers.addConnectedPeer(this);\n        Message msg = DMT.createFNPLocChangeNotification(node.lm.loc.getValue());\n        \n        try {\n            sendAsync(msg);\n        } catch (NotConnectedException e) {\n            Logger.error(this, \"Completed handshake but disconnected!!!\", new Exception(\"error\"));\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Send a message, off-thread, to this node.\n     * @param msg The message to be sent.\n     */\n    public void sendAsync(Message msg) {\n        messagesToSendNow.addLast(msg);\n        synchronized(node.ps) {\n            node.ps.notifyAll();\n        }\n    }","id":81168,"modified_method":"/**\n     * Send a message, off-thread, to this node.\n     * @param msg The message to be sent.\n     */\n    public void sendAsync(Message msg) throws NotConnectedException {\n        if(!isConnected) throw new NotConnectedException();\n        messagesToSendNow.addLast(msg);\n        synchronized(node.ps) {\n            node.ps.notifyAll();\n        }\n    }","commit_id":"db3bc8d8624526da4116ed2c6e8583678d958aa9","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Handle an incoming FNPDataRequest.\n\t */\n\tprivate boolean handleDataRequest(Message m, boolean isSSK) {\n\t\tlong id = m.getLong(DMT.UID);\n\t\tif(node.recentlyCompleted(id)) {\n\t\t\tMessage rejected = DMT.createFNPRejectedLoop(id);\n\t\t\ttry {\n\t\t\t\t((PeerNode)(m.getSource())).sendAsync(rejected, null, 0, null);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Rejecting data request (loop, finished): \"+e);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif(!node.lockUID(id, isSSK, false)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Could not lock ID \"+id+\" -> rejecting (already running)\");\n\t\t\tMessage rejected = DMT.createFNPRejectedLoop(id);\n\t\t\ttry {\n\t\t\t\t((PeerNode)(m.getSource())).sendAsync(rejected, null, 0, null);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Rejecting insert request from \"+m.getSource().getPeer()+\": \"+e);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif(logMINOR) Logger.minor(this, \"Locked \"+id);\n\t\t}\n\t\tString rejectReason = nodeStats.shouldRejectRequest(!isSSK, false, isSSK);\n\t\tif(rejectReason != null) {\n\t\t\t// can accept 1 CHK request every so often, but not with SSKs because they aren't throttled so won't sort out bwlimitDelayTime, which was the whole reason for accepting them when overloaded...\n\t\t\tLogger.normal(this, \"Rejecting request from \"+m.getSource().getPeer()+\" preemptively because \"+rejectReason);\n\t\t\tMessage rejected = DMT.createFNPRejectedOverload(id, true);\n\t\t\ttry {\n\t\t\t\t((PeerNode)(m.getSource())).sendAsync(rejected, null, 0, null);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Rejecting (overload) data request from \"+m.getSource().getPeer()+\": \"+e);\n\t\t\t}\n\t\t\tnode.unlockUID(id, isSSK, false);\n\t\t\treturn true;\n\t\t}\n\t\t//if(!node.lockUID(id)) return false;\n\t\tRequestHandler rh = new RequestHandler(m, id, node); // Do we need to keep a record of in flight RHs?\n\t\trh.run();\n\t\treturn true;\n\t}","id":81169,"modified_method":"/**\n\t * Handle an incoming FNPDataRequest.\n\t */\n\tprivate boolean handleDataRequest(Message m, boolean isSSK) {\n\t\tlong id = m.getLong(DMT.UID);\n\t\tif(node.recentlyCompleted(id)) {\n\t\t\tMessage rejected = DMT.createFNPRejectedLoop(id);\n\t\t\ttry {\n\t\t\t\t((PeerNode)(m.getSource())).sendAsync(rejected, null, 0, null);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Rejecting data request (loop, finished): \"+e);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif(!node.lockUID(id, isSSK, false)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Could not lock ID \"+id+\" -> rejecting (already running)\");\n\t\t\tMessage rejected = DMT.createFNPRejectedLoop(id);\n\t\t\ttry {\n\t\t\t\t((PeerNode)(m.getSource())).sendAsync(rejected, null, 0, null);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Rejecting insert request from \"+m.getSource().getPeer()+\": \"+e);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif(logMINOR) Logger.minor(this, \"Locked \"+id);\n\t\t}\n\t\tString rejectReason = nodeStats.shouldRejectRequest(!isSSK, false, isSSK);\n\t\tif(rejectReason != null) {\n\t\t\t// can accept 1 CHK request every so often, but not with SSKs because they aren't throttled so won't sort out bwlimitDelayTime, which was the whole reason for accepting them when overloaded...\n\t\t\tLogger.normal(this, \"Rejecting request from \"+m.getSource().getPeer()+\" preemptively because \"+rejectReason);\n\t\t\tMessage rejected = DMT.createFNPRejectedOverload(id, true);\n\t\t\ttry {\n\t\t\t\t((PeerNode)(m.getSource())).sendAsync(rejected, null, 0, null);\n\t\t\t} catch (NotConnectedException e) {\n\t\t\t\tLogger.normal(this, \"Rejecting (overload) data request from \"+m.getSource().getPeer()+\": \"+e);\n\t\t\t}\n\t\t\tnode.unlockUID(id, isSSK, false);\n\t\t\treturn true;\n\t\t}\n\t\t//if(!node.lockUID(id)) return false;\n\t\tRequestHandler rh = new RequestHandler(m, id, node);\n\t\tThread t = new Thread(rh, \"RequestHandler for UID \"+id);\n\t\tt.setDaemon(true);\n\t\tt.start();\n\t\treturn true;\n\t}","commit_id":"18d9a494bbaef4666c1b2a6fb1b80553959d419c","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n        try {\n        \tif(logMINOR) Logger.minor(this, \"Handling a request: \"+uid);\n        \thtl = source.decrementHTL(htl);\n\n        \tMessage accepted = DMT.createFNPAccepted(uid);\n        \tsource.sendAsync(accepted, null, 0, null);\n\n        \tObject o = node.makeRequestSender(key, htl, uid, source, closestLoc, resetClosestLoc, false, true, false);\n        \tif(o instanceof KeyBlock) {\n        \t\tKeyBlock block = (KeyBlock) o;\n        \t\tMessage df = createDataFound(block);\n            \tsource.sendAsync(df, null, 0, null);        \t\t\n        \t\tif(key instanceof NodeSSK) {\n        \t\t\tif(needsPubKey) {\n        \t\t\t\tDSAPublicKey key = ((NodeSSK)block.getKey()).getPubKey();\n        \t\t\t\tMessage pk = DMT.createFNPSSKPubKey(uid, key.asBytes());\n        \t\t\t\tif(logMINOR) Logger.minor(this, \"Sending PK: \"+key+ ' ' +key.toLongString());\n        \t        \tsource.sendAsync(pk, null, 0, null);\n        \t\t\t}\n        \t\t\tstatus = RequestSender.SUCCESS; // for byte logging\n        \t\t}\n        \t\tif(block instanceof CHKBlock) {\n        \t\t\tPartiallyReceivedBlock prb =\n        \t\t\t\tnew PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE, block.getRawData());\n        \t\t\tBlockTransmitter bt =\n        \t\t\t\tnew BlockTransmitter(node.usm, source, uid, prb, node.outputThrottle, this);\n        \t\t\tnode.addTransferringRequestHandler(uid);\n        \t\t\tif(bt.send())\n        \t\t\t\tstatus = RequestSender.SUCCESS; // for byte logging\n        \t\t}\n        \t\treturn;\n        \t}\n        \trs = (RequestSender) o;\n\n        \tif(rs == null) { // ran out of htl?\n        \t\tMessage dnf = DMT.createFNPDataNotFound(uid);\n            \tsource.sendAsync(dnf, null, 0, null);\n        \t\tstatus = RequestSender.DATA_NOT_FOUND; // for byte logging\n        \t\treturn;\n        \t}\n        \t\n    \t\tsynchronized (this) {\n\t\t\t\tcurrentState = WAIT_FOR_FIRST_REPLY;\n\t\t\t}\n        \trs.callbackWhenStatusChange(this, waitStatus);\n\n        } catch (Throwable t) {\n        \tLogger.error(this, \"Caught \"+t, t);\n        \t_finally(); // Yes, we don't want the finally() block here anyway\n        } \n    }","id":81170,"modified_method":"public void run() {\n    \tint status = RequestSender.NOT_FINISHED;\n    \tRequestSender rs = null;\n        try {\n        if(logMINOR) Logger.minor(this, \"Handling a request: \"+uid);\n        htl = source.decrementHTL(htl);\n        \n        Message accepted = DMT.createFNPAccepted(uid);\n        source.send(accepted, null);\n        \n        Object o = node.makeRequestSender(key, htl, uid, source, closestLoc, resetClosestLoc, false, true, false);\n        if(o instanceof KeyBlock) {\n            KeyBlock block = (KeyBlock) o;\n            Message df = createDataFound(block);\n            source.send(df, null);\n            if(key instanceof NodeSSK) {\n                if(needsPubKey) {\n                \tDSAPublicKey key = ((NodeSSK)block.getKey()).getPubKey();\n                \tMessage pk = DMT.createFNPSSKPubKey(uid, key.asBytes());\n                \tif(logMINOR) Logger.minor(this, \"Sending PK: \"+key+ ' ' +key.toLongString());\n                \tsource.send(pk, null);\n                }\n                status = RequestSender.SUCCESS; // for byte logging\n            }\n            if(block instanceof CHKBlock) {\n            \tPartiallyReceivedBlock prb =\n            \t\tnew PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE, block.getRawData());\n            \tBlockTransmitter bt =\n            \t\tnew BlockTransmitter(node.usm, source, uid, prb, node.outputThrottle, this);\n            \tnode.addTransferringRequestHandler(uid);\n            \tif(bt.send())\n            \t\tstatus = RequestSender.SUCCESS; // for byte logging\n            }\n            return;\n        }\n        rs = (RequestSender) o;\n        \n        if(rs == null) { // ran out of htl?\n            Message dnf = DMT.createFNPDataNotFound(uid);\n            source.send(dnf, null);\n            status = RequestSender.DATA_NOT_FOUND; // for byte logging\n            return;\n        }\n        \n        boolean shouldHaveStartedTransfer = false;\n        \n        short waitStatus = 0;\n        \n        while(true) {\n            \n        \twaitStatus = rs.waitUntilStatusChange(waitStatus);\n            if((waitStatus & RequestSender.WAIT_REJECTED_OVERLOAD) != 0) {\n            \t// Forward RejectedOverload\n            \tMessage msg = DMT.createFNPRejectedOverload(uid, false);\n            \tsource.sendAsync(msg, null, 0, null);\n            }\n            \n            if((waitStatus & RequestSender.WAIT_TRANSFERRING_DATA) != 0) {\n            \t// Is a CHK.\n                Message df = DMT.createFNPCHKDataFound(uid, rs.getHeaders());\n                source.send(df, null);\n                PartiallyReceivedBlock prb = rs.getPRB();\n            \tBlockTransmitter bt =\n            \t    new BlockTransmitter(node.usm, source, uid, prb, node.outputThrottle, this);\n            \tnode.addTransferringRequestHandler(uid);\n            \tif(!bt.send()){\n            \t\tfinalTransferFailed = true;\n            \t}\n        \t    return;\n            }\n            \n            status = rs.getStatus();\n\n            if(status == RequestSender.NOT_FINISHED) continue;\n            \n            switch(status) {\n            \tcase RequestSender.NOT_FINISHED:\n            \tcase RequestSender.DATA_NOT_FOUND:\n                    Message dnf = DMT.createFNPDataNotFound(uid);\n            \t\tsource.send(dnf, this);\n            \t\treturn;\n            \tcase RequestSender.GENERATED_REJECTED_OVERLOAD:\n            \tcase RequestSender.TIMED_OUT:\n            \tcase RequestSender.INTERNAL_ERROR:\n            \t\t// Locally generated.\n            \t    // Propagate back to source who needs to reduce send rate\n            \t    Message reject = DMT.createFNPRejectedOverload(uid, true);\n            \t\tsource.send(reject, this);\n            \t\treturn;\n            \tcase RequestSender.ROUTE_NOT_FOUND:\n            \t    // Tell source\n            \t    Message rnf = DMT.createFNPRouteNotFound(uid, rs.getHTL());\n            \t\tsource.send(rnf, this);\n            \t\treturn;\n            \tcase RequestSender.SUCCESS:\n            \t\tif(key instanceof NodeSSK) {\n                        Message df = DMT.createFNPSSKDataFound(uid, rs.getHeaders(), rs.getSSKData());\n                        source.send(df, this);\n                        node.sentPayload(rs.getSSKData().length);\n                        if(needsPubKey) {\n                        \tMessage pk = DMT.createFNPSSKPubKey(uid, ((NodeSSK)rs.getSSKBlock().getKey()).getPubKey().asBytes());\n                        \tsource.send(pk, this);\n                        }\n            \t\t} else if(!rs.transferStarted()) {\n            \t\t\tLogger.error(this, \"Status is SUCCESS but we never started a transfer on \"+uid);\n            \t\t}\n            \t\treturn;\n            \tcase RequestSender.VERIFY_FAILURE:\n            \t\tif(key instanceof NodeCHK) {\n            \t\t\tif(shouldHaveStartedTransfer)\n            \t\t\t\tthrow new IllegalStateException(\"Got status code \"+status+\" but transfer not started\");\n            \t\t\tshouldHaveStartedTransfer = true;\n            \t\t\tcontinue; // should have started transfer\n            \t\t}\n            \t    reject = DMT.createFNPRejectedOverload(uid, true);\n            \t\tsource.send(reject, this);\n            \t\treturn;\n            \tcase RequestSender.TRANSFER_FAILED:\n            \t\tif(key instanceof NodeCHK) {\n            \t\t\tif(shouldHaveStartedTransfer)\n            \t\t\t\tthrow new IllegalStateException(\"Got status code \"+status+\" but transfer not started\");\n            \t\t\tshouldHaveStartedTransfer = true;\n            \t\t\tcontinue; // should have started transfer\n            \t\t}\n            \t\t// Other side knows, right?\n            \t\treturn;\n            \tdefault:\n            \t    throw new IllegalStateException(\"Unknown status code \"+status);\n            }\n        }\n        } catch (Throwable t) {\n            Logger.error(this, \"Caught \"+t, t);\n        } finally {\n        \tnode.removeTransferringRequestHandler(uid);\n            node.unlockUID(uid, key instanceof NodeSSK, false);\n            if((!finalTransferFailed) && rs != null && status != RequestSender.TIMED_OUT && status != RequestSender.GENERATED_REJECTED_OVERLOAD \n            \t\t&& status != RequestSender.INTERNAL_ERROR) {\n            \tint sent = rs.getTotalSentBytes() + sentBytes;\n            \tint rcvd = rs.getTotalReceivedBytes() + receivedBytes;\n            \tif(key instanceof NodeSSK) {\n            \t\tif(logMINOR) Logger.minor(this, \"Remote SSK fetch cost \"+sent+ '/' +rcvd+\" bytes (\"+status+ ')');\n                \tnode.nodeStats.remoteSskFetchBytesSentAverage.report(sent);\n                \tnode.nodeStats.remoteSskFetchBytesReceivedAverage.report(rcvd);\n                \tif(status == RequestSender.SUCCESS) {\n                \t\tnode.nodeStats.successfulSskFetchBytesSentAverage.report(sent);\n                \t\tnode.nodeStats.successfulSskFetchBytesReceivedAverage.report(sent);\n                \t}\n            \t} else {\n            \t\tif(logMINOR) Logger.minor(this, \"Remote CHK fetch cost \"+sent+ '/' +rcvd+\" bytes (\"+status+ ')');\n                \tnode.nodeStats.remoteChkFetchBytesSentAverage.report(sent);\n                \tnode.nodeStats.remoteChkFetchBytesReceivedAverage.report(rcvd);\n                \tif(status == RequestSender.SUCCESS) {\n                \t\tnode.nodeStats.successfulChkFetchBytesSentAverage.report(sent);\n                \t\tnode.nodeStats.successfulChkFetchBytesReceivedAverage.report(sent);\n                \t}\n            \t}\n            }\n\n        }\n    }","commit_id":"18d9a494bbaef4666c1b2a6fb1b80553959d419c","url":"https://github.com/freenet/fred"},{"original_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static EnterpriseArchive deployment1() {\n        return SSOTestBase.createSsoEar();\n    }","id":81171,"modified_method":"@Deployment(name = DEPLOYMENT_1, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_1)\n    public static Archive<?> deployment1() {\n        return createArchive();\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static EnterpriseArchive deployment2() {\n        return SSOTestBase.createSsoEar();\n    }","id":81172,"modified_method":"@Deployment(name = DEPLOYMENT_2, managed = false, testable = false)\n    @TargetsContainer(CONTAINER_2)\n    public static Archive<?> deployment2() {\n        return createArchive();\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ServiceBuilder<SessionManagerFactory> build(ServiceTarget target, ServiceName name, ServiceName deploymentServiceName, Module module, JBossWebMetaData metaData) {\n        ServiceName clusteringServiceName = name.append(\"clustering\");\n        this.builder.buildDeploymentDependency(target, clusteringServiceName, deploymentServiceName, module, metaData)\n                .setInitialMode(ServiceController.Mode.ON_DEMAND)\n                .install()\n        ;\n        return DistributableSessionManagerFactoryService.build(target, name, clusteringServiceName);\n    }","id":81173,"modified_method":"@Override\n    public ServiceBuilder<SessionManagerFactory> build(ServiceTarget target, ServiceName name, ServiceName deploymentServiceName, Module module, JBossWebMetaData metaData) {\n        ServiceName clusteringServiceName = name.append(\"distributable\");\n        this.builder.buildDeploymentDependency(target, clusteringServiceName, deploymentServiceName, module, metaData)\n                .setInitialMode(ServiceController.Mode.ON_DEMAND)\n                .install()\n        ;\n        return DistributableSessionManagerFactoryService.build(target, name, clusteringServiceName);\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ServiceBuilder<SingleSignOnManagerFactory> build(ServiceTarget target, ServiceName name, final ServiceName hostServiceName) {\n        ServiceName managerServiceName = name.append(\"clustering\");\n        this.builder.build(target, managerServiceName, hostServiceName.getSimpleName()).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        SessionManagerRegistryService.build(target, hostServiceName).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        return DistributableSingleSignOnManagerFactoryService.build(target, name, hostServiceName, managerServiceName);\n    }","id":81174,"modified_method":"@Override\n    public ServiceBuilder<SingleSignOnManagerFactory> build(ServiceTarget target, ServiceName name, final ServiceName hostServiceName) {\n        ServiceName managerServiceName = name.append(\"distributable\");\n        this.builder.build(target, managerServiceName, hostServiceName.getSimpleName()).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        SessionManagerRegistryService.build(target, hostServiceName).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        return DistributableSingleSignOnManagerFactoryService.build(target, name, hostServiceName, managerServiceName);\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        processRequest(request, response);\n    }","id":81175,"modified_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {\n/*\n        try {\n            InitialContext ctx = new InitialContext();\n            Context enc = (Context) ctx.lookup(\"java:comp/env\");\n            StatelessSessionHome home = (StatelessSessionHome) enc.lookup(\"ejb/OptimizedEJB\");\n            StatelessSession bean = home.create();\n            bean.noop();\n\n            Object homeRef = enc.lookup(\"ejb/OptimizedEJB\");\n            home = (StatelessSessionHome) PortableRemoteObject.narrow(homeRef, StatelessSessionHome.class);\n            bean = home.create();\n            bean.noop();\n            bean.getData();\n\n            StatelessSessionLocalHome localHome = (StatelessSessionLocalHome) enc.lookup(\"ejb/local/OptimizedEJB\");\n            StatelessSessionLocal localBean = localHome.create();\n            localBean.noop();\n        } catch (Exception e) {\n            throw new ServletException(\"Failed to call OptimizedEJB through remote and local interfaces\", e);\n        }\n*/\n        response.setContentType(\"text/html\");\n        try (PrintWriter out = response.getWriter()) {\n            out.println(\"<html>\");\n            out.println(\"<head><title>EJBServlet<\/title><\/head>\");\n            out.println(\"<body>Tests passed<br>Time:\" + new Date().toString() + \"<\/body>\");\n            out.println(\"<\/html>\");\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        processRequest(request, response);\n    }","id":81176,"modified_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            session.invalidate();\n        }\n        response.sendRedirect(request.getContextPath() + \"/index.html\");\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void executeNoAuthSingleSignOnTest(URL serverA, URL serverB, Logger log) throws Exception {\n        URL warA1 = new URL(serverA, \"/war1/\");\n        URL warB2 = new URL(serverB + \"/war2/\");\n        URL warB6 = new URL(serverB + \"/war6/\");\n\n        // Start by accessing the secured index.html of war1\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n\n        checkAccessDenied(httpclient, warA1 + \"index.html\");\n\n        CookieStore store = httpclient.getCookieStore();\n\n        log.debug(\"Saw JSESSIONID=\" + getSessionIdValueFromState(store));\n\n        // Submit the login form\n        executeFormLogin(httpclient, warA1);\n\n        String ssoID = processSSOCookie(store, serverA.toString(), serverB.toString());\n        log.debug(\"Saw JSESSIONIDSSO=\" + ssoID);\n\n        // Now try getting the war2 index using the JSESSIONIDSSO cookie\n        log.debug(\"Prepare /war2/index.html get\");\n        checkAccessAllowed(httpclient, warB2 + \"index.html\");\n\n        // Access a secured servlet that calls a secured ejb in war2 to test\n        // propagation of the SSO identity to the ejb container.\n        checkAccessAllowed(httpclient, warB2 + \"EJBServlet\");\n\n        // Do the same test on war6 to test SSO auth replication with no auth\n        // configured war\n        checkAccessAllowed(httpclient, warB6 + \"index.html\");\n\n        checkAccessAllowed(httpclient, warB2 + \"EJBServlet\");\n\n    }","id":81177,"modified_method":"public static void executeNoAuthSingleSignOnTest(URL serverA, URL serverB, Logger log) throws Exception {\n        URL warA1 = new URL(serverA, \"/war1/\");\n        URL warB2 = new URL(serverB + \"/war2/\");\n        URL warB6 = new URL(serverB + \"/war6/\");\n\n        // Start by accessing the secured index.html of war1\n        DefaultHttpClient httpclient = org.jboss.as.test.http.util.HttpClientUtils.relaxedCookieHttpClient();\n        try {\n            checkAccessDenied(httpclient, warA1 + \"index.html\");\n\n            CookieStore store = httpclient.getCookieStore();\n\n            log.debug(\"Saw JSESSIONID=\" + getSessionIdValueFromState(store));\n\n            // Submit the login form\n            executeFormLogin(httpclient, warA1);\n\n            String ssoID = processSSOCookie(store, serverA.toString(), serverB.toString());\n            log.debug(\"Saw JSESSIONIDSSO=\" + ssoID);\n\n            // Now try getting the war2 index using the JSESSIONIDSSO cookie\n            log.debug(\"Prepare /war2/index.html get\");\n            checkAccessAllowed(httpclient, warB2 + \"index.html\");\n\n            // Access a secured servlet that calls a secured ejb in war2 to test\n            // propagation of the SSO identity to the ejb container.\n            checkAccessAllowed(httpclient, warB2 + \"EJBServlet\");\n\n            // Do the same test on war6 to test SSO auth replication with no auth\n            // configured war\n            checkAccessAllowed(httpclient, warB6 + \"index.html\");\n\n            checkAccessAllowed(httpclient, warB2 + \"EJBServlet\");\n        } finally {\n            HttpClientUtils.closeQuietly(httpclient);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void executeFormLogin(HttpClient httpConn, URL warURL) throws IOException {\n        // Submit the login form\n        HttpPost formPost = new HttpPost(warURL + \"j_security_check\");\n        formPost.addHeader(\"Referer\", warURL + \"login.html\");\n\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"j_username\", \"user1\"));\n        formparams.add(new BasicNameValuePair(\"j_password\", \"password1\"));\n        formPost.setEntity(new UrlEncodedFormEntity(formparams, \"UTF-8\"));\n\n        HttpResponse postResponse = httpConn.execute(formPost);\n\n        int statusCode = postResponse.getStatusLine().getStatusCode();\n        Header[] errorHeaders = postResponse.getHeaders(\"X-NoJException\");\n        assertTrue(\"Should see HTTP_MOVED_TEMP. Got \" + statusCode, statusCode == HttpURLConnection.HTTP_MOVED_TEMP);\n        assertTrue(\"X-NoJException(\" + Arrays.toString(errorHeaders) + \") is null\", errorHeaders.length == 0);\n        EntityUtils.consume(postResponse.getEntity());\n\n        // Follow the redirect to the index.html page\n        String indexURL = postResponse.getFirstHeader(\"Location\").getValue();\n        HttpGet rediretGet = new HttpGet(indexURL.toString());\n        HttpResponse redirectResponse = httpConn.execute(rediretGet);\n\n        statusCode = redirectResponse.getStatusLine().getStatusCode();\n        errorHeaders = redirectResponse.getHeaders(\"X-NoJException\");\n        assertTrue(\"Wrong response code: \" + statusCode, statusCode == HttpURLConnection.HTTP_OK);\n        assertTrue(\"X-NoJException(\" + Arrays.toString(errorHeaders) + \") is null\", errorHeaders.length == 0);\n\n        String body = EntityUtils.toString(redirectResponse.getEntity());\n        assertTrue(\"Get of \" + indexURL + \" redirected to login page\", body.indexOf(\"j_security_check\") < 0);\n    }","id":81178,"modified_method":"public static void executeFormLogin(HttpClient httpConn, URL warURL) throws IOException {\n        // Submit the login form\n        HttpPost formPost = new HttpPost(warURL + \"j_security_check\");\n        formPost.addHeader(\"Referer\", warURL + \"login.html\");\n\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"j_username\", \"user1\"));\n        formparams.add(new BasicNameValuePair(\"j_password\", \"password1\"));\n        formPost.setEntity(new UrlEncodedFormEntity(formparams, \"UTF-8\"));\n\n        HttpResponse postResponse = httpConn.execute(formPost);\n        try {\n            int statusCode = postResponse.getStatusLine().getStatusCode();\n            Header[] errorHeaders = postResponse.getHeaders(\"X-NoJException\");\n            assertTrue(\"Should see HTTP_MOVED_TEMP. Got \" + statusCode, statusCode == HttpURLConnection.HTTP_MOVED_TEMP);\n            assertTrue(\"X-NoJException(\" + Arrays.toString(errorHeaders) + \") is null\", errorHeaders.length == 0);\n            EntityUtils.consume(postResponse.getEntity());\n\n            // Follow the redirect to the index.html page\n            String indexURL = postResponse.getFirstHeader(\"Location\").getValue();\n            HttpGet rediretGet = new HttpGet(indexURL.toString());\n            HttpResponse redirectResponse = httpConn.execute(rediretGet);\n\n            statusCode = redirectResponse.getStatusLine().getStatusCode();\n            errorHeaders = redirectResponse.getHeaders(\"X-NoJException\");\n            assertTrue(\"Wrong response code: \" + statusCode, statusCode == HttpURLConnection.HTTP_OK);\n            assertTrue(\"X-NoJException(\" + Arrays.toString(errorHeaders) + \") is null\", errorHeaders.length == 0);\n\n            String body = EntityUtils.toString(redirectResponse.getEntity());\n            assertTrue(\"Get of \" + indexURL + \" redirected to login page\", body.indexOf(\"j_security_check\") < 0);\n        } finally {\n            HttpClientUtils.closeQuietly(postResponse);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void checkAccessAllowed(HttpClient httpConn, String url) throws IOException {\n        HttpGet getMethod = new HttpGet(url);\n        HttpResponse response = httpConn.execute(getMethod);\n\n        int statusCode = response.getStatusLine().getStatusCode();\n        assertTrue(\"Expected code == OK but got \" + statusCode + \" for request=\" + url, statusCode == HttpURLConnection.HTTP_OK);\n\n        String body = EntityUtils.toString(response.getEntity());\n        assertTrue(\"Get of \" + url + \" redirected to login page\", body.indexOf(\"j_security_check\") < 0);\n    }","id":81179,"modified_method":"public static void checkAccessAllowed(HttpClient httpConn, String url) throws IOException {\n        HttpGet getMethod = new HttpGet(url);\n        HttpResponse response = httpConn.execute(getMethod);\n        try {\n            int statusCode = response.getStatusLine().getStatusCode();\n            assertTrue(\"Expected code == OK but got \" + statusCode + \" for request=\" + url, statusCode == HttpURLConnection.HTTP_OK);\n\n            String body = EntityUtils.toString(response.getEntity());\n            assertTrue(\"Get of \" + url + \" redirected to login page\", body.indexOf(\"j_security_check\") < 0);\n        } finally {\n            HttpClientUtils.closeQuietly(response);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addSso(ModelControllerClient client) throws Exception {\n        final List<ModelNode> updates = new ArrayList<ModelNode>();\n\n        // SSO element name must be 'configuration'\n        updates.add(createOpNode(\"subsystem=web/virtual-server=default-host/sso=configuration\", ADD));\n\n        applyUpdates(updates, client);\n    }","id":81180,"modified_method":"public static void addSso(ModelControllerClient client) throws Exception {\n        final List<ModelNode> updates = new ArrayList<ModelNode>();\n\n        // SSO element name must be 'configuration'\n        ModelNode op = createOpNode(\"subsystem=undertow/server=default-server/host=default-host/setting=single-sign-on\", ADD);\n        op.get(\"domain\").set(\"${jboss.bind.address:127.0.0.1}\");\n        updates.add(op);\n\n        applyUpdates(updates, client);\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void removeSso(final ModelControllerClient client) throws Exception {\n        final List<ModelNode> updates = new ArrayList<ModelNode>();\n\n        updates.add(createOpNode(\"subsystem=web/virtual-server=default-host/sso=configuration\", REMOVE));\n\n        applyUpdates(updates, client);\n    }","id":81181,"modified_method":"public static void removeSso(final ModelControllerClient client) throws Exception {\n        final List<ModelNode> updates = new ArrayList<ModelNode>();\n\n        ModelNode op = createOpNode(\"subsystem=undertow/server=default-server/host=default-host/setting=single-sign-on\", REMOVE);\n        op.get(\"domain\").set(\"${jboss.bind.address:127.0.0.1}\");\n        updates.add(op);\n\n        applyUpdates(updates, client);\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Test single sign-on across two web apps using form based auth\n     *\n     * @throws Exception\n     */\n    public static void executeFormAuthSingleSignOnTest(URL serverA, URL serverB, Logger log) throws Exception {\n        URL warA1 = new URL (serverA, \"/war1/\");\n        URL warB2 = new URL (serverB, \"/war2/\");\n\n        // Start by accessing the secured index.html of war1\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n\n        checkAccessDenied(httpclient, warA1 + \"index.html\");\n\n        CookieStore store = httpclient.getCookieStore();\n\n        log.debug(\"Saw JSESSIONID=\" + getSessionIdValueFromState(store));\n\n        // Submit the login form\n        executeFormLogin(httpclient, warA1);\n\n        String ssoID = processSSOCookie(store, serverA.toString(), serverB.toString());\n        log.debug(\"Saw JSESSIONIDSSO=\" + ssoID);\n\n        // Now try getting the war2 index using the JSESSIONIDSSO cookie\n        log.debug(\"Prepare /war2/index.html get\");\n        checkAccessAllowed(httpclient, warB2 + \"index.html\");\n\n        // Access a secured servlet that calls a secured ejb in war2 to test\n        // propagation of the SSO identity to the ejb container.\n        checkAccessAllowed(httpclient, warB2 + \"EJBServlet\");\n\n        // Now try logging out of war2\n        executeLogout(httpclient, warB2);\n\n        // Reset Http client\n        httpclient = new DefaultHttpClient();\n\n        // Try accessing war1 again\n        checkAccessDenied(httpclient, warA1 + \"index.html\");\n\n        // Try accessing war2 again\n        checkAccessDenied(httpclient, warB2 + \"index.html\");\n\n    }","id":81182,"modified_method":"/**\n     * Test single sign-on across two web apps using form based auth\n     *\n     * @throws Exception\n     */\n    public static void executeFormAuthSingleSignOnTest(URL serverA, URL serverB, Logger log) throws Exception {\n        URL warA1 = new URL (serverA, \"/war1/\");\n        URL warB2 = new URL (serverB, \"/war2/\");\n\n        // Start by accessing the secured index.html of war1\n        DefaultHttpClient httpclient = org.jboss.as.test.http.util.HttpClientUtils.relaxedCookieHttpClient();\n        try {\n            checkAccessDenied(httpclient, warA1 + \"index.html\");\n\n            CookieStore store = httpclient.getCookieStore();\n\n            log.debug(\"Saw JSESSIONID=\" + getSessionIdValueFromState(store));\n\n            // Submit the login form\n            executeFormLogin(httpclient, warA1);\n\n            String ssoID = processSSOCookie(store, serverA.toString(), serverB.toString());\n            log.debug(\"Saw JSESSIONIDSSO=\" + ssoID);\n\n            // Now try getting the war2 index using the JSESSIONIDSSO cookie\n            log.debug(\"Prepare /war2/index.html get\");\n            checkAccessAllowed(httpclient, warB2 + \"index.html\");\n\n            // Access a secured servlet that calls a secured ejb in war2 to test\n            // propagation of the SSO identity to the ejb container.\n            checkAccessAllowed(httpclient, warB2 + \"EJBServlet\");\n\n            // Now try logging out of war2\n            executeLogout(httpclient, warB2);\n        } finally {\n            HttpClientUtils.closeQuietly(httpclient);\n        }\n\n        httpclient = org.jboss.as.test.http.util.HttpClientUtils.relaxedCookieHttpClient();\n        try {\n            // Reset Http client\n            httpclient = new DefaultHttpClient();\n\n            // Try accessing war1 again\n            checkAccessDenied(httpclient, warA1 + \"index.html\");\n\n            // Try accessing war2 again\n            checkAccessDenied(httpclient, warB2 + \"index.html\");\n        } finally {\n            HttpClientUtils.closeQuietly(httpclient);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void checkAccessDenied(HttpClient httpConn, String url) throws IOException {\n        HttpGet getMethod = new HttpGet(url);\n        HttpResponse response = httpConn.execute(getMethod);\n\n        int statusCode = response.getStatusLine().getStatusCode();\n        assertTrue(\"Expected code == OK but got \" + statusCode + \" for request=\" + url, statusCode == HttpURLConnection.HTTP_OK);\n\n        String body = EntityUtils.toString(response.getEntity());\n        assertTrue(\"Redirected to login page for request=\" + url + \", body[\" + body + \"]\", body.indexOf(\"j_security_check\") > 0);\n    }","id":81183,"modified_method":"public static void checkAccessDenied(HttpClient httpConn, String url) throws IOException {\n        HttpGet getMethod = new HttpGet(url);\n        HttpResponse response = httpConn.execute(getMethod);\n        try {\n            int statusCode = response.getStatusLine().getStatusCode();\n            assertTrue(\"Expected code == OK but got \" + statusCode + \" for request=\" + url, statusCode == HttpURLConnection.HTTP_OK);\n\n            String body = EntityUtils.toString(response.getEntity());\n            assertTrue(\"Redirected to login page for request=\" + url + \", body[\" + body + \"]\", body.indexOf(\"j_security_check\") > 0);\n        } finally {\n            HttpClientUtils.closeQuietly(response);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static String processSSOCookie(CookieStore cookieStore, String serverA, String serverB) {\n        String ssoID = null;\n        for (Cookie cookie : cookieStore.getCookies()) {\n            if (\"JSESSIONIDSSO\".equalsIgnoreCase(cookie.getName())) {\n                ssoID = cookie.getValue();\n                if (serverA.equals(serverB) == false) {\n                    // Make an sso cookie to send to serverB\n                    Cookie copy = copyCookie(cookie, serverB);\n                    cookieStore.addCookie(copy);\n                }\n            }\n        }\n\n        assertTrue(\"Didn't saw JSESSIONIDSSO\", ssoID != null);\n        return ssoID;\n    }","id":81184,"modified_method":"public static String processSSOCookie(CookieStore cookieStore, String serverA, String serverB) {\n        String ssoID = null;\n        for (Cookie cookie : cookieStore.getCookies()) {\n            if (\"JSESSIONIDSSO\".equalsIgnoreCase(cookie.getName())) {\n                ssoID = cookie.getValue();\n                if (serverA.equals(serverB) == false) {\n                    // Make an sso cookie to send to serverB\n                    Cookie copy = copyCookie(cookie, serverB);\n                    cookieStore.addCookie(copy);\n                }\n            }\n        }\n\n        assertTrue(\"Didn't see JSESSIONIDSSO: \" + cookieStore.getCookies(), ssoID != null);\n        return ssoID;\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void executeLogout(HttpClient httpConn, URL warURL) throws IOException {\n        HttpGet logout = new HttpGet(warURL + \"Logout\");\n        logout.setParams(new BasicHttpParams().setParameter(\"http.protocol.handle-redirects\", false));\n        HttpResponse response = httpConn.execute(logout);\n\n        int statusCode = response.getStatusLine().getStatusCode();\n        assertTrue(\"Logout: Didn't saw HTTP_MOVED_TEMP(\" + statusCode + \")\", statusCode == HttpURLConnection.HTTP_MOVED_TEMP);\n\n        Header location = response.getFirstHeader(\"Location\");\n        assertTrue(\"Get of \" + warURL + \"Logout not redirected to login page\", location.getValue().indexOf(\"index.html\") >= 0);\n    }","id":81185,"modified_method":"public static void executeLogout(HttpClient httpConn, URL warURL) throws IOException {\n        HttpGet logout = new HttpGet(warURL + \"Logout\");\n        logout.setParams(new BasicHttpParams().setParameter(\"http.protocol.handle-redirects\", false));\n        HttpResponse response = httpConn.execute(logout);\n        try {\n            int statusCode = response.getStatusLine().getStatusCode();\n            assertTrue(\"Logout: Didn't saw HTTP_MOVED_TEMP(\" + statusCode + \")\", statusCode == HttpURLConnection.HTTP_MOVED_TEMP);\n\n            Header location = response.getFirstHeader(\"Location\");\n            assertTrue(\"Get of \" + warURL + \"Logout not redirected to login page\", location.getValue().indexOf(\"index.html\") >= 0);\n        } finally {\n            HttpClientUtils.closeQuietly(response);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        for (SimpleAttributeDefinition def : SingleSignOnDefinition.ATTRIBUTES) {\n            def.validateAndSet(operation, model);\n        }\n    }","id":81186,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        for (AttributeDefinition def : SingleSignOnDefinition.ATTRIBUTES) {\n            def.validateAndSet(operation, model);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model, final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final PathAddress hostAddress = address.subAddress(0, address.size() - 1);\n                final PathAddress serverAddress = hostAddress.subAddress(0, hostAddress.size() - 1);\n\n        final String domain = SingleSignOnDefinition.DOMAIN.resolveModelAttribute(context, model).asString();\n        final boolean reAuthenticate = SingleSignOnDefinition.RE_AUTHENTICATE.resolveModelAttribute(context, model).asBoolean();\n        /*final ModelNode cacheNameNode = SingleSignOnDefinition.CACHE_NAME.resolveModelAttribute(context, model);\n        final ModelNode cacheContainerNode = SingleSignOnDefinition.CACHE_CONTAINER.resolveModelAttribute(context, model);\n\n        final String cacheName = cacheNameNode.isDefined() ? cacheNameNode.asString() : null;\n        final String cacheContainer = cacheContainerNode.isDefined() ? cacheContainerNode.asString() : null;*/\n\n        final String serverName = serverAddress.getLastElement().getValue();\n        final String hostName = hostAddress.getLastElement().getValue();\n        final ServiceName serviceName = UndertowService.ssoServiceName(serverName, hostName);\n        final ServiceName virtualHostServiceName = UndertowService.virtualHostName(serverName, hostName);\n\n        final SingleSignOnService service = new SingleSignOnService(domain, reAuthenticate);\n        final ServiceTarget target = context.getServiceTarget();\n        final ServiceController<?> sc = target.addService(serviceName, service)\n                .addDependency(virtualHostServiceName, Host.class, service.getHost())\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n\n        if (newControllers != null) {\n            newControllers.add(sc);\n        }\n    }","id":81187,"modified_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model, final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final PathAddress hostAddress = address.subAddress(0, address.size() - 1);\n                final PathAddress serverAddress = hostAddress.subAddress(0, hostAddress.size() - 1);\n\n        final String domain = SingleSignOnDefinition.DOMAIN.resolveModelAttribute(context, model).asString();\n\n        final String serverName = serverAddress.getLastElement().getValue();\n        final String hostName = hostAddress.getLastElement().getValue();\n        final ServiceName serviceName = UndertowService.ssoServiceName(serverName, hostName);\n        final ServiceName virtualHostServiceName = UndertowService.virtualHostName(serverName, hostName);\n\n        final ServiceTarget target = context.getServiceTarget();\n\n        ServiceName managerServiceName = serviceName.append(\"manager\");\n        ServiceController<?> factoryController = SingleSignOnManagerService.build(target, managerServiceName, virtualHostServiceName).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        if (newControllers != null) {\n            newControllers.add(factoryController);\n        }\n\n        final SingleSignOnService service = new SingleSignOnService(domain);\n        final ServiceController<?> sc = target.addService(serviceName, service)\n                .addDependency(virtualHostServiceName, Host.class, service.getHost())\n                .addDependency(managerServiceName, SingleSignOnManager.class, service.getSingleSignOnSessionManager())\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n\n        if (newControllers != null) {\n            newControllers.add(sc);\n        }\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"private SingleSignOnDefinition() {\n        super(UndertowExtension.PATH_SSO, UndertowExtension.getResolver(\"single-sign-on\"), new SingleSignOnAdd(), ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","id":81188,"modified_method":"private SingleSignOnDefinition() {\n        super(UndertowExtension.PATH_SSO, UndertowExtension.getResolver(Constants.SINGLE_SIGN_ON), new SingleSignOnAdd(), ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        //noinspection unchecked\n        return (Collection) ATTRIBUTES;\n    }","id":81189,"modified_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return ATTRIBUTES;\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext startContext) throws StartException {\n        SingleSignOnAuthenticationMechanism authenticationMechanism = createInMemory();\n\n        host.getValue().registerAdditionalAuthenticationMechanism(\"sso\", authenticationMechanism);\n    }","id":81190,"modified_method":"@Override\n    public void start(StartContext startContext) {\n        SingleSignOnAuthenticationMechanism mechanism = new SingleSignOnAuthenticationMechanism(this.manager.getValue());\n        if (this.domain != null) {\n            mechanism.setDomain(this.domain);\n        }\n\n        host.getValue().registerAdditionalAuthenticationMechanism(\"sso\", mechanism);\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"InjectedValue<Host> getHost() {\n        return host;\n    }","id":81191,"modified_method":"Injector<Host> getHost() {\n        return host;\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SingleSignOnService(String domain, boolean reAuthenticate) {\n        this.domain = domain;\n        this.reAuthenticate = reAuthenticate;\n    }","id":81192,"modified_method":"public SingleSignOnService(String domain) {\n        this.domain = domain;\n    }","commit_id":"cf26d9662e1be1e6b1ff0eb882406efd37f59ba2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void setup(ManagementClient managementClient, String containerId) throws Exception {\n\n            FileUtils.deleteDirectory(WORK_DIR);\n            WORK_DIR.mkdirs();\n            Utils.createKeyMaterial(WORK_DIR);\n\n            TRACE_SECURITY.setup(managementClient, null);\n\n            final ModelControllerClient client = managementClient.getControllerClient();\n\n            // add new HTTPS_REALM with SSL\n            ModelNode operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM, ModelDescriptionConstants.ADD);\n            Utils.applyUpdate(operation, client);\n\n            operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/authentication=truststore\",\n                    ModelDescriptionConstants.ADD);\n            operation.get(\"keystore-path\").set(SERVER_TRUSTSTORE_FILE.getAbsolutePath());\n            operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n            Utils.applyUpdate(operation, client);\n\n            operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/server-identity=ssl\",\n                    ModelDescriptionConstants.ADD);\n            operation.get(PROTOCOL).set(\"TLSv1\");\n            operation.get(\"keystore-path\").set(SERVER_KEYSTORE_FILE.getAbsolutePath());\n            operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n            Utils.applyUpdate(operation, client);\n\n            executeReloadAndWaitForCompletion(client, 100000);\n\n            operation = createOpNode(\"subsystem=undertow/server=default-server/https-listener=https\", ModelDescriptionConstants.ADD);\n            operation.get(\"socket-binding\").set(\"https\");\n            operation.get(\"security-realm\").set(HTTPS_REALM);\n            Utils.applyUpdate(operation, client);\n        }","id":81193,"modified_method":"@Override\n        public void setup(ManagementClient managementClient, String containerId) throws Exception {\n\n            FileUtils.deleteDirectory(WORK_DIR);\n            WORK_DIR.mkdirs();\n            Utils.createKeyMaterial(WORK_DIR);\n\n            TRACE_SECURITY.setup(managementClient, null);\n\n            final ModelControllerClient client = managementClient.getControllerClient();\n\n            // add new HTTPS_REALM with SSL\n            ModelNode operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM, ModelDescriptionConstants.ADD);\n            Utils.applyUpdate(operation, client);\n\n            operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/authentication=truststore\",\n                    ModelDescriptionConstants.ADD);\n            operation.get(\"keystore-path\").set(SERVER_TRUSTSTORE_FILE.getAbsolutePath());\n            operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n            Utils.applyUpdate(operation, client);\n\n            operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/server-identity=ssl\",\n                    ModelDescriptionConstants.ADD);\n            operation.get(PROTOCOL).set(\"TLSv1\");\n            operation.get(\"keystore-path\").set(SERVER_KEYSTORE_FILE.getAbsolutePath());\n            operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n            Utils.applyUpdate(operation, client);\n\n            executeReloadAndWaitForCompletion(client, 100000);\n\n            operation = createOpNode(\"socket-binding-group=standard-sockets/socket-binding=https2\" , ADD);\n            operation.get(PORT).set(Integer.toString(HTTPS_PORT));\n            operation.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n            operation.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n            Utils.applyUpdate(operation, client);\n\n            operation = createOpNode(\"subsystem=undertow/server=default-server/https-listener=https2\", ModelDescriptionConstants.ADD);\n            operation.get(\"socket-binding\").set(\"https2\");\n            operation.get(\"security-realm\").set(HTTPS_REALM);\n            Utils.applyUpdate(operation, client);\n        }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void tearDown(ManagementClient managementClient, String containerId) throws Exception {\n\n            ModelNode operation = createOpNode(\"subsystem=undertow/server=default-server/https-listener=https\",\n                    ModelDescriptionConstants.REMOVE);\n            Utils.applyUpdate(operation, managementClient.getControllerClient());\n\n            operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM, ModelDescriptionConstants.REMOVE);\n            Utils.applyUpdate(operation, managementClient.getControllerClient());\n\n            FileUtils.deleteDirectory(WORK_DIR);\n            TRACE_SECURITY.tearDown(managementClient, null);\n\n        }","id":81194,"modified_method":"@Override\n        public void tearDown(ManagementClient managementClient, String containerId) throws Exception {\n\n            ModelNode operation = createOpNode(\"subsystem=undertow/server=default-server/https-listener=https2\",\n                    ModelDescriptionConstants.REMOVE);\n            operation.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n            Utils.applyUpdate(operation, managementClient.getControllerClient());\n\n            operation = createOpNode(\"socket-binding-group=standard-sockets/socket-binding=https2\",\n                    ModelDescriptionConstants.REMOVE);\n            Utils.applyUpdate(operation, managementClient.getControllerClient());\n\n            operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM, ModelDescriptionConstants.REMOVE);\n            Utils.applyUpdate(operation, managementClient.getControllerClient());\n\n            FileUtils.deleteDirectory(WORK_DIR);\n            TRACE_SECURITY.tearDown(managementClient, null);\n\n        }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void adjustForVersion(final DomainClient client, final Version.AsVersion asVersion) throws Exception {\n\n        final DomainAdjuster adjuster;\n        switch (asVersion) {\n            case EAP_6_2_0:\n                adjuster = new DomainAdjuster620();\n                break;\n            case EAP_6_3_0:\n                adjuster = new DomainAdjuster630();\n                break;\n            case EAP_6_4_0:\n                adjuster = new DomainAdjuster640();\n                break;\n            default:\n                adjuster = new DomainAdjuster();\n        }\n\n        adjuster.adjust(client);\n    }","id":81195,"modified_method":"static void adjustForVersion(final DomainClient client, final Version.AsVersion asVersion) throws Exception {\n\n        final DomainAdjuster adjuster;\n        switch (asVersion) {\n            case EAP_6_2_0:\n                adjuster = new DomainAdjuster620();\n                break;\n            case EAP_6_3_0:\n                adjuster = new DomainAdjuster630();\n                break;\n            case EAP_6_4_0:\n                adjuster = new DomainAdjuster640();\n                break;\n            case EAP_7_0_0:\n                adjuster = new DomainAdjuster700();\n                break;\n            default:\n                adjuster = new DomainAdjuster();\n        }\n\n        adjuster.adjust(client);\n    }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected List<ModelNode> adjustForVersion(final DomainClient client, PathAddress profileAddress) throws Exception {\n        final List<ModelNode> list = new ArrayList<>();\n\n        return list;\n    }","id":81196,"modified_method":"@Override\n    protected List<ModelNode> adjustForVersion(final DomainClient client, PathAddress profileAddress) throws Exception {\n        final List<ModelNode> list = new ArrayList<>();\n\n        removeHTTPSListener(profileAddress, list);\n\n        return list;\n    }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void serverSetup(ManagementClient managementClient) throws Exception {\n        FileUtils.deleteDirectory(WORK_DIR);\n        WORK_DIR.mkdirs();\n        Utils.createKeyMaterial(WORK_DIR);\n\n        TRACE_SECURITY.setup(managementClient, null);\n\n        SecurityDomainsSetup.INSTANCE.setup(managementClient, null);\n\n        final ModelControllerClient client = managementClient.getControllerClient();\n\n        // add new HTTPS_REALM with SSL\n        ModelNode operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM, ModelDescriptionConstants.ADD);\n        Utils.applyUpdate(operation, client);\n\n        operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/authentication=truststore\",\n                ModelDescriptionConstants.ADD);\n        operation.get(\"keystore-path\").set(SERVER_TRUSTSTORE_FILE.getAbsolutePath());\n        operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n        Utils.applyUpdate(operation, client);\n\n        operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/server-identity=ssl\",\n                ModelDescriptionConstants.ADD);\n        operation.get(PROTOCOL).set(\"TLSv1\");\n        operation.get(\"keystore-path\").set(SERVER_KEYSTORE_FILE.getAbsolutePath());\n        operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n        // operation.get(\"alias\").set(\"management\");\n        Utils.applyUpdate(operation, client);\n\n        LOGGER.info(\"*** restarting server\");\n        containerController.stop(CONTAINER);\n        containerController.start(CONTAINER);\n        \n        operation = createOpNode(\"subsystem=undertow/server=default-server/https-listener=\" + HTTPS, ModelDescriptionConstants.ADD);\n        operation.get(\"socket-binding\").set(HTTPS);\n        operation.get(\"security-realm\").set(HTTPS_REALM);\n        Utils.applyUpdate(operation, client);\n\n        addHttpsConnector(\"NOT_REQUESTED\", HTTPS_NAME_VERIFY_NOT_REQUESTED, HTTPS_PORT_VERIFY_FALSE, client);\n        addHttpsConnector(\"REQUESTED\", HTTPS_NAME_VERIFY_REQUESTED, HTTPS_PORT_VERIFY_WANT, client);\n        addHttpsConnector(\"REQUIRED\", HTTPS_NAME_VERIFY_REQUIRED, HTTPS_PORT_VERIFY_TRUE, client);\n\n    }","id":81197,"modified_method":"private void serverSetup(ManagementClient managementClient) throws Exception {\n        FileUtils.deleteDirectory(WORK_DIR);\n        WORK_DIR.mkdirs();\n        Utils.createKeyMaterial(WORK_DIR);\n\n        TRACE_SECURITY.setup(managementClient, null);\n\n        SecurityDomainsSetup.INSTANCE.setup(managementClient, null);\n\n        final ModelControllerClient client = managementClient.getControllerClient();\n\n        // add new HTTPS_REALM with SSL\n        ModelNode operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM, ModelDescriptionConstants.ADD);\n        Utils.applyUpdate(operation, client);\n\n        operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/authentication=truststore\",\n                ModelDescriptionConstants.ADD);\n        operation.get(\"keystore-path\").set(SERVER_TRUSTSTORE_FILE.getAbsolutePath());\n        operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n        Utils.applyUpdate(operation, client);\n\n        operation = createOpNode(\"core-service=management/security-realm=\" + HTTPS_REALM + \"/server-identity=ssl\",\n                ModelDescriptionConstants.ADD);\n        operation.get(PROTOCOL).set(\"TLSv1\");\n        operation.get(\"keystore-path\").set(SERVER_KEYSTORE_FILE.getAbsolutePath());\n        operation.get(\"keystore-password\").set(SecurityTestConstants.KEYSTORE_PASSWORD);\n        // operation.get(\"alias\").set(\"management\");\n        Utils.applyUpdate(operation, client);\n\n        LOGGER.info(\"*** restarting server\");\n        containerController.stop(CONTAINER);\n        containerController.start(CONTAINER);\n\n        addHttpsConnector(\"NOT_REQUESTED\", HTTPS_NAME_VERIFY_NOT_REQUESTED, HTTPS_PORT_VERIFY_FALSE, client);\n        addHttpsConnector(\"REQUESTED\", HTTPS_NAME_VERIFY_REQUESTED, HTTPS_PORT_VERIFY_WANT, client);\n        addHttpsConnector(\"REQUIRED\", HTTPS_NAME_VERIFY_REQUIRED, HTTPS_PORT_VERIFY_TRUE, client);\n\n    }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    @RunAsClient\n    @OperateOnDeployment(HOLDER_OF_KEY_SERVER_DEP)\n    @WrapThreadContextClassLoader\n    public void testHolderOfKey() throws Exception {\n\n        Bus bus = BusFactory.newInstance().createBus();\n        try {\n\n            BusFactory.setThreadDefaultBus(bus);\n\n            final QName serviceName = new QName(\"http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy\", \"HolderOfKeyService\");\n            final URL wsdlURL = new URL(\"https\", serviceURL.getHost(), serviceURL.getPort() - 8080 + 8443, \"/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService?wsdl\");\n            Service service = Service.create(wsdlURL, serviceName);\n            HolderOfKeyIface proxy = (HolderOfKeyIface) service.getPort(HolderOfKeyIface.class);\n\n            WSTrustTestUtils.setupWsseAndSTSClientHolderOfKey((BindingProvider) proxy, bus);\n            assertEquals(\"Holder-Of-Key WS-Trust Hello World!\", proxy.sayHello());\n\n        } finally {\n            bus.shutdown(true);\n        }\n    }","id":81198,"modified_method":"@Test\n    @RunAsClient\n    @OperateOnDeployment(HOLDER_OF_KEY_SERVER_DEP)\n    @WrapThreadContextClassLoader\n    public void testHolderOfKey() throws Exception {\n\n        Bus bus = BusFactory.newInstance().createBus();\n        try {\n\n            BusFactory.setThreadDefaultBus(bus);\n\n            final QName serviceName = new QName(\"http://www.jboss.org/jbossws/ws-extensions/holderofkeywssecuritypolicy\", \"HolderOfKeyService\");\n            final URL wsdlURL = new URL(\"https\", serviceURL.getHost(), serviceURL.getPort() - 8080 + 8444, \"/jaxws-samples-wsse-policy-trust-holderofkey/HolderOfKeyService?wsdl\");\n            Service service = Service.create(wsdlURL, serviceName);\n            HolderOfKeyIface proxy = (HolderOfKeyIface) service.getPort(HolderOfKeyIface.class);\n\n            WSTrustTestUtils.setupWsseAndSTSClientHolderOfKey((BindingProvider) proxy, bus);\n            assertEquals(\"Holder-Of-Key WS-Trust Hello World!\", proxy.sayHello());\n\n        } finally {\n            bus.shutdown(true);\n        }\n    }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void removeHttpsListener(ManagementClient managementClient) throws Exception {\n        final ModelNode removeOp = createOpNode(\"subsystem=undertow/server=default-server/https-listener=\" + HTTPS_LISTENER_NAME, REMOVE);\n        removeOp.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n        removeOp.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n        CoreUtils.applyUpdate(removeOp, managementClient.getControllerClient());\n    }","id":81199,"modified_method":"private void removeHttpsListener(ManagementClient managementClient) throws Exception {\n        ModelNode removeOp = createOpNode(\"socket-binding-group=standard-sockets/socket-binding=https2\" + HTTPS_LISTENER_NAME, REMOVE);\n        removeOp.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n        removeOp.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n        CoreUtils.applyUpdate(removeOp, managementClient.getControllerClient());\n        removeOp = createOpNode(\"subsystem=undertow/server=default-server/https-listener=\" + HTTPS_LISTENER_NAME, REMOVE);\n        removeOp.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n        removeOp.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n        CoreUtils.applyUpdate(removeOp, managementClient.getControllerClient());\n    }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add https listner like this:\n     * <p/>\n     * <subsystem xmlns=\"urn:jboss:domain:undertow:3.0\">\n     * <server name=\"default-server\">\n     * <https-listener name=\"jbws-test-https-listener\" socket-binding=\"https\" security-realm=\"jbws-test-https-realm\"/>\n     * ....\n     * <\/server>\n     * ...\n     * <\/subsystem>\n     */\n    private void addHttpsListener(ManagementClient managementClient) throws Exception {\n        final ModelNode addOp = createOpNode(\"subsystem=undertow/server=default-server/https-listener=\" + HTTPS_LISTENER_NAME, ADD);\n        addOp.get(SOCKET_BINDING).set(\"https\");\n        addOp.get(SECURITY_REALM).set(SECURITY_REALM_NAME);\n        addOp.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n        addOp.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n        CoreUtils.applyUpdate(addOp, managementClient.getControllerClient());\n    }","id":81200,"modified_method":"/**\n     * Add https listner like this:\n     * <p/>\n     * <subsystem xmlns=\"urn:jboss:domain:undertow:3.0\">\n     * <server name=\"default-server\">\n     * <https-listener name=\"jbws-test-https-listener\" socket-binding=\"https\" security-realm=\"jbws-test-https-realm\"/>\n     * ....\n     * <\/server>\n     * ...\n     * <\/subsystem>\n     */\n    private void addHttpsListener(ManagementClient managementClient) throws Exception {\n\n\n        ModelNode addOp = createOpNode(\"socket-binding-group=standard-sockets/socket-binding=https2\" , ADD);\n        addOp.get(PORT).set(\"8444\");\n        addOp.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n        addOp.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n        CoreUtils.applyUpdate(addOp, managementClient.getControllerClient());\n        addOp = createOpNode(\"subsystem=undertow/server=default-server/https-listener=\" + HTTPS_LISTENER_NAME, ADD);\n        addOp.get(SOCKET_BINDING).set(\"https2\");\n        addOp.get(SECURITY_REALM).set(SECURITY_REALM_NAME);\n        addOp.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n        addOp.get(OPERATION_HEADERS, ALLOW_RESOURCE_SERVICE_RESTART).set(true);\n        CoreUtils.applyUpdate(addOp, managementClient.getControllerClient());\n    }","commit_id":"8f66017f291c6e11bf1c4c9eb8a860d75146975b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void setLinkStyle(LWComponent style) {\n        System.err.println(\"linkStyle=\" + style);\n        linkStyle = style;\n    }","id":81201,"modified_method":"public void setLinkStyle(LWComponent style) {\n        if (DEBUG.Enabled) Log.debug(\"setLinkStyle \" + style);\n        linkStyle = style;\n    }","commit_id":"cff91a2a41f10597c18095410b2d9606054f9de7","url":"https://github.com/VUE/VUE"},{"original_method":"public void setTextStyle(LWComponent style) {\n        System.err.println(\"textStyle=\" + style);\n        textStyle = style;\n    }","id":81202,"modified_method":"public void setTextStyle(LWComponent style) {\n        if (DEBUG.Enabled) Log.debug(\"setTextStyle \" + style);\n        textStyle = style;\n    }","commit_id":"cff91a2a41f10597c18095410b2d9606054f9de7","url":"https://github.com/VUE/VUE"},{"original_method":"public void setTitleStyle(LWComponent style) {\n        System.err.println(\"headerStyle=\" + style);\n        headerStyle = style;\n    }","id":81203,"modified_method":"public void setTitleStyle(LWComponent style) {\n        if (DEBUG.Enabled) Log.debug(\"setHeaderStyle \" + style);\n        headerStyle = style;\n    }","commit_id":"cff91a2a41f10597c18095410b2d9606054f9de7","url":"https://github.com/VUE/VUE"},{"original_method":"public static URI makeURI(String s)\n    {\n        URI uri = null;\n        final String encoded = encodeForURI(s);\n        try {\n            uri = new java.net.URI(encoded);\n        } catch (java.net.URISyntaxException e) {\n            Util.printStackTrace(e, s);\n        }\n        if (uri != null && uri.toString().equals(s))\n            System.err.println(\"            MADE URI: \" + uri);\n        else\n            System.err.println(\"            MADE URI: \" + uri + \" src=[\" + s + \"]\");\n        \n        return uri;\n    }","id":81204,"modified_method":"public static URI makeURI(String s)\n    {\n        URI uri = null;\n        final String encoded = encodeForURI(s);\n        try {\n            uri = new java.net.URI(encoded);\n        } catch (java.net.URISyntaxException e) {\n            Util.printStackTrace(e, s);\n        }\n        if (DEBUG.RESOURCE) {\n            if (uri != null && uri.toString().equals(s))\n                System.err.println(\"            MADE URI: \" + uri);\n            else\n                System.err.println(\"            MADE URI: \" + uri + \" src=[\" + s + \"]\");\n        }\n        \n        return uri;\n    }","commit_id":"cff91a2a41f10597c18095410b2d9606054f9de7","url":"https://github.com/VUE/VUE"},{"original_method":"private URI findRelativeURI(URI root)\n    {\n        if (DEBUG.Enabled) {\n            System.out.println(\"\\n=======================================================\");\n            Log.debug(\"attempting to relativize [\" + this + \"] against root \" + root);\n        }\n        \n        final URL url = asURL();\n        if (url == null)\n            return null;\n\n        final URI absURI = makeURI(url.toString());\n        // absURI should always be absolute -- the way we persist them\n\n        if (!absURI.isAbsolute())\n            Log.warn(\"Non absolute URI: \" + absURI + \"; from URL \" + url);\n\n        if (absURI == null) {\n            System.out.println(\"URL INVALID FOR URI: \" + url + \"; in \" + this);\n            return null;\n        }\n\n        Util.dumpURI(absURI, \"ORIGINAL\");\n        final URI relativeURI = root.relativize(absURI);\n\n        if (relativeURI == absURI) {\n            // oldRoot was unable to relativize absURI -- this resource\n            // was not relative to it's map in it's previous incarnation.\n            return null;\n        }\n        \n        if (relativeURI != absURI)\n            Util.dumpURI(relativeURI, \"RELATIVE\");\n\n\n        System.out.println(TERM_GREEN+\"FOUND RELATIVE: \" + relativeURI + TERM_CLEAR);        \n\n        return relativeURI;\n\n    }","id":81205,"modified_method":"private URI findRelativeURI(URI root)\n    {\n        if (DEBUG.Enabled) {\n            System.out.println(\"\\n=======================================================\");\n            Log.debug(\"attempting to relativize [\" + this + \"] against root \" + root);\n        }\n        \n        final URL url = asURL();\n        if (url == null)\n            return null;\n\n        final URI absURI = makeURI(url.toString());\n        // absURI should always be absolute -- the way we persist them\n\n        if (!absURI.isAbsolute())\n            Log.warn(\"Non absolute URI: \" + absURI + \"; from URL \" + url);\n\n        if (absURI == null) {\n            System.out.println(\"URL INVALID FOR URI: \" + url + \"; in \" + this);\n            return null;\n        }\n\n        if (DEBUG.Enabled) Util.dumpURI(absURI, \"ORIGINAL\");\n        final URI relativeURI = root.relativize(absURI);\n\n        if (relativeURI == absURI) {\n            // oldRoot was unable to relativize absURI -- this resource\n            // was not relative to it's map in it's previous incarnation.\n            return null;\n        }\n        \n        if (relativeURI != absURI) {\n            if (DEBUG.Enabled) Util.dumpURI(relativeURI, \"RELATIVE\");\n        }\n\n        if (DEBUG.Enabled) System.out.println(TERM_GREEN+\"FOUND RELATIVE: \" + relativeURI + TERM_CLEAR);        \n\n        return relativeURI;\n\n    }","commit_id":"cff91a2a41f10597c18095410b2d9606054f9de7","url":"https://github.com/VUE/VUE"},{"original_method":"public static URI makeURI(File f) {\n        URI uri = f.toURI();\n        Util.dumpURI(uri, \"NEW FILE URI FROM \" + f);\n        if (uri.getPath().startsWith(\"/C:\"))\n            return makeURI(uri.getPath().substring(3));\n        else\n            return uri;\n        //return makeURI(f.toString());\n    }","id":81206,"modified_method":"public static URI makeURI(File f) {\n        URI uri = f.toURI();\n        if (DEBUG.RESOURCE) Util.dumpURI(uri, \"NEW FILE URI FROM \" + f);\n        if (uri.getPath().startsWith(\"/C:\"))\n            return makeURI(uri.getPath().substring(3));\n        else\n            return uri;\n        //return makeURI(f.toString());\n    }","commit_id":"cff91a2a41f10597c18095410b2d9606054f9de7","url":"https://github.com/VUE/VUE"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        if (post == null) {\r\n            prop.put(\"info\", 1);//no information submitted\r\n            return prop;\r\n        }\r\n        \r\n        // admin password\r\n        if (post.containsKey(\"adminaccount\")) {\r\n            // read and process data\r\n            String user   = (String) post.get(\"adminuser\");\r\n            String pw1    = (String) post.get(\"adminpw1\");\r\n            String pw2    = (String) post.get(\"adminpw2\");\r\n            // do checks\r\n            if ((user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            // check passed. set account:\r\n            env.setConfig(\"adminAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"adminAccount\", \"\");\r\n            prop.put(\"info\", 5);//admin account changed\r\n            prop.put(\"info_user\", user);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // proxy password\r\n        if (post.containsKey(\"proxyaccount\")) {\r\n            // set new port\r\n            String port = (String) post.get(\"port\");\r\n            env.setConfig(\"port\", port);\r\n            prop.put(\"info_port\", port);\r\n            \r\n            // read and process data\r\n            String filter = (String) post.get(\"proxyfilter\");\r\n            String user   = (String) post.get(\"proxyuser\");\r\n            String pw1    = (String) post.get(\"proxypw1\");\r\n            String pw2    = (String) post.get(\"proxypw2\");\r\n            // do checks\r\n            if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"proxyClient\", filter);\r\n            if (pw1.length() == 0) {\r\n                // only ip filter setting without account\r\n                env.setConfig(\"proxyAccountBase64MD5\", \"\");\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 6);//proxy account has changed(no pw)\r\n                prop.put(\"info_filter\", filter);\r\n            } else {\r\n                // also paccount setting\r\n                env.setConfig(\"proxyAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 7);//proxy account has changed\r\n                prop.put(\"info_user\", user);\r\n                prop.put(\"info_filter\", filter);\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        // http networking\r\n        if (post.containsKey(\"httpNetworking\")) {\r\n            \r\n            // set transparent proxy flag\r\n            httpdProxyHandler.isTransparentProxy = post.containsKey(\"isTransparentProxy\");\r\n            env.setConfig(\"isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"true\" : \"false\");\r\n            prop.put(\"info_isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"on\" : \"off\");            \r\n            \r\n            // setting the keep alive property\r\n            httpd.keepAliveSupport = post.containsKey(\"connectionKeepAliveSupport\");\r\n            env.setConfig(\"connectionKeepAliveSupport\", httpd.keepAliveSupport ? \"true\" : \"false\");\r\n            prop.put(\"info_connectionKeepAliveSupport\", httpd.keepAliveSupport ? \"on\" : \"off\"); \r\n            \r\n            prop.put(\"info\", 20);             \r\n            return prop;\r\n        }\r\n        \r\n        // port forwarding configuration\r\n        if (post.containsKey(\"portForwarding\")) {            \r\n            env.setConfig(\"portForwardingEnabled\", post.containsKey(\"portForwardingEnabled\")?\"true\":\"false\");\r\n            env.setConfig(\"portForwardingUseProxy\",post.containsKey(\"portForwardingUseProxy\")?\"true\":\"false\");\r\n            env.setConfig(\"portForwardingPort\",    (String)post.get(\"portForwardingPort\"));\r\n                        \r\n            env.setConfig(\"portForwardingHost\",    (String)post.get(\"portForwardingHost\"));\r\n            env.setConfig(\"portForwardingHostPort\",(String)post.get(\"portForwardingHostPort\"));\r\n            env.setConfig(\"portForwardingHostUser\",(String)post.get(\"portForwardingHostUser\"));\r\n            env.setConfig(\"portForwardingHostPwd\", (String)post.get(\"portForwardingHostPwd\"));\r\n            \r\n            // trying to reconnect the port forwarding channel\r\n            try {\r\n                serverCore httpd = (serverCore) env.getThread(\"10_httpd\");\r\n                if ((serverCore.portForwardingEnabled) && (serverCore.portForwarding != null)) {\r\n                    // trying to shutdown the current port forwarding channel\r\n                    serverCore.portForwarding.disconnect();                \r\n                }            \r\n                // trying to reinitialize the port forwarding\r\n                httpd.initPortForwarding();\r\n                \r\n                // notifying publishSeed Thread\r\n                serverThread peerPing = env.getThread(\"30_peerping\");\r\n                peerPing.notifyThread();\r\n            } catch (Exception e) {\r\n                prop.put(\"info\", 23); \r\n                prop.put(\"info_errormsg\",(e.getMessage() == null) ? \"unknown\" : e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                return prop;\r\n            }\r\n            \r\n            prop.put(\"info\", 22); \r\n            prop.put(\"info_portForwardingEnabled\", post.containsKey(\"portForwardingEnabled\")?\"on\":\"off\");  \r\n            prop.put(\"info_portForwardingUseProxy\",post.containsKey(\"portForwardingUseProxy\")?\"on\":\"off\");\r\n            prop.put(\"info_portForwardingPort\",    (String)post.get(\"portForwardingPort\"));\r\n            prop.put(\"info_portForwardingHost\",    (String)post.get(\"portForwardingHost\"));\r\n            prop.put(\"info_portForwardingHostPort\",(String)post.get(\"portForwardingHostPort\"));\r\n            prop.put(\"info_portForwardingHostUser\",(String)post.get(\"portForwardingHostUser\"));\r\n            prop.put(\"info_portForwardingHostPwd\", (String)post.get(\"portForwardingHostPwd\"));   \r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // server password\r\n        if (post.containsKey(\"serveraccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"serverfilter\");\r\n            String user   = (String) post.get(\"serveruser\");\r\n            String pw1    = (String) post.get(\"serverpw1\");\r\n            String pw2    = (String) post.get(\"serverpw2\");\r\n            // do checks\r\n            if (filter == null) {\r\n                //if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"serverClient\", filter);\r\n            env.setConfig(\"serverAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"serverAccount\", \"\");\r\n            \r\n            prop.put(\"info\", 8);//server access filter updated\r\n            prop.put(\"info_user\", user);\r\n            prop.put(\"info_filter\", filter);\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"dispop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"false\");\r\n            prop.put(\"info\", 9);//popup disabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"enpop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"true\");\r\n            prop.put(\"info\", 10);//popup enabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"pmode\")) {\r\n            env.setConfig(\"onlineMode\", \"2\");\r\n            prop.put(\"info\", 11);//permanent online mode\r\n            yacyCore.triggerOnlineAction();\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"generalsettings\")) {\r\n            /*\r\n            // set peer language\r\n            String peerLang = (String) post.get(\"peerlang\");\r\n            if ((peerLang == null) || (peerLang.equals(\"en\"))) peerLang = \"default\";\r\n\t    HashMap lm = langMap(env);\r\n\t    if (!(lm.containsKey(peerLang))) peerLang = \"default\";\r\n\t    env.setConfig(\"htLocaleSelection\", peerLang);\r\n\t    prop.put(\"info_peerLang\", (String) lm.get(peerLang));\r\n            */\r\n            \r\n            // check if peer name already exists\r\n            String peerName = (String) post.get(\"peername\");\r\n            String staticIP =  (String)post.get(\"staticIP\");\r\n            env.setConfig(\"staticIP\", staticIP);\r\n            if (staticIP.length() > 0) yacyCore.seedDB.mySeed.put(\"IP\", staticIP);\r\n            yacySeed oldSeed = yacyCore.seedDB.lookupByName(peerName);\r\n            \r\n            if ((oldSeed == null) || (env.getConfig(\"peerName\",\"\").equals(peerName))) {\r\n                // the name is new\r\n                boolean nameOK = (peerName.length() <= 80);\r\n                for (int i = 0; i < peerName.length(); i++) {\r\n                    if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\".indexOf(peerName.charAt(i)) < 0) nameOK = false;\r\n                }\r\n                if (!(nameOK)) {\r\n                    // deny change\r\n                    prop.put(\"info\", 17);//peer name is wrong\r\n                } else {\r\n                    \r\n                    // set values\r\n                    env.setConfig(\"peerName\", peerName);\r\n                    prop.put(\"info\", 12);//port or peername changed\r\n                    prop.put(\"info_peerName\", peerName);\r\n                    prop.put(\"info_staticIP\", staticIP);\r\n                }\r\n            } else {\r\n                // deny change\r\n                prop.put(\"info\", 16);//peer name is already used by another peer\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"proxysettings\")) {\r\n            httpdProxyHandler.remoteProxyUse = ((String) post.get(\"remoteProxyUse\", \"\")).equals(\"on\");\r\n            httpdProxyHandler.remoteProxyHost = (String) post.get(\"remoteProxyHost\", \"\");\r\n            try {\r\n                httpdProxyHandler.remoteProxyPort = Integer.parseInt((String) post.get(\"remoteProxyPort\", \"\"));\r\n            } catch (NumberFormatException e) {\r\n                httpdProxyHandler.remoteProxyPort = 3128;\r\n            }\r\n            httpdProxyHandler.remoteProxyNoProxy = (String) post.get(\"remoteProxyNoProxy\", \"\");\r\n            httpdProxyHandler.remoteProxyNoProxyPatterns = httpdProxyHandler.remoteProxyNoProxy.split(\",\");\r\n            env.setConfig(\"remoteProxyHost\", httpdProxyHandler.remoteProxyHost);\r\n            env.setConfig(\"remoteProxyPort\", \"\" + httpdProxyHandler.remoteProxyPort);\r\n            env.setConfig(\"remoteProxyNoProxy\", httpdProxyHandler.remoteProxyNoProxy);\r\n            env.setConfig(\"remoteProxyUse\", (httpdProxyHandler.remoteProxyUse) ? \"true\" : \"false\");\r\n            prop.put(\"info\", 15); // The remote-proxy setting has been changed\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedUploadRetry\")) {\r\n            try {\r\n                // trying to upload the seed-list file\r\n                yacyCore.saveSeedList(env);     \r\n                prop.put(\"info\", 13);\r\n                prop.put(\"info_success\",1);\r\n            } catch (Exception e) {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\");                 \r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedSettings\")) {            \r\n            try {\r\n                // getting the currently used uploading method\r\n                String oldSeedUploadMethod = env.getConfig(\"seedUploadMethod\",\"none\");\r\n                String newSeedUploadMethod = (String)post.get(\"seedUploadMethod\");\r\n                String oldSeedURLStr = env.getConfig(\"seedURL\",\"\");\r\n                String newSeedURLStr = (String)post.get(\"seedURL\");\r\n                new URL(newSeedURLStr);\r\n                \r\n                boolean seedUrlChanged = !oldSeedURLStr.equals(newSeedURLStr);\r\n                boolean uploadMethodChanged = !oldSeedUploadMethod.equals(newSeedUploadMethod);\r\n                if (uploadMethodChanged) {\r\n                    uploadMethodChanged = yacyCore.changeSeedUploadMethod(newSeedUploadMethod); \r\n                }\r\n\r\n                if (seedUrlChanged || uploadMethodChanged) {\r\n                    env.setConfig(\"seedUploadMethod\", newSeedUploadMethod);\r\n                    env.setConfig(\"seedURL\", newSeedURLStr);\r\n                    \r\n                    // trying to upload the seed-list file\r\n                    yacyCore.saveSeedList(env);\r\n                    \r\n                    // we have successfully uploaded the seed-list file\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",(newSeedUploadMethod.equalsIgnoreCase(\"none\")?0:1));\r\n                    prop.put(\"info\", 19);                                     \r\n                } else {\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",0);\r\n                    prop.put(\"info\", 19);                    \r\n                    \r\n                }\r\n            } catch (Exception e) {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\"); \r\n            }\r\n            return prop;            \r\n        }\r\n        \r\n        /* \r\n         * Loop through the available seed uploaders to see if the \r\n         * configuration of one of them has changed \r\n         */\r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            // getting the uploader module name\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            \r\n            \r\n            // determining if the user has reconfigured the settings of this uploader\r\n            if (post.containsKey(\"seed\" + uploaderName + \"Settings\")) {\r\n                nothingChanged = true;\r\n                yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n                String[] configOptions = theUploader.getConfigurationOptions();\r\n                if (configOptions != null) {\r\n                    for (int i=0; i<configOptions.length; i++) {\r\n                        String newSettings = post.get(configOptions[i],\"\");\r\n                        String oldSettings = env.getConfig(configOptions[i],\"\");\r\n                        nothingChanged &= newSettings.equals(oldSettings); \r\n                        if (!nothingChanged) {\r\n                            env.setConfig(configOptions[i],newSettings);\r\n                        }\r\n                    }\r\n                }   \r\n                if (!nothingChanged) {\r\n                    // if the seed upload method is equal to the seed uploader whose settings\r\n                    // were changed, we now try to upload the seed list with the new settings\r\n                    if (env.getConfig(\"seedUploadMethod\",\"none\").equalsIgnoreCase(uploaderName)) {\r\n                        try {\r\n                            yacyCore.saveSeedList(env);\r\n                            \r\n                            // we have successfully uploaded the seed file\r\n                            prop.put(\"info\", 13);\r\n                            prop.put(\"info_success\",1);\r\n                        } catch (Exception e) {\r\n                            // if uploading failed we print out an error message\r\n                            prop.put(\"info\", 14);\r\n                            prop.put(\"info_errormsg\",e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                            env.setConfig(\"seedUploadMethod\",\"none\");                            \r\n                        }                       \r\n                    } else {\r\n                        prop.put(\"info\", 13);\r\n                        prop.put(\"info_success\",0);\r\n                    }\r\n                } else {\r\n                    prop.put(\"info\", 13);\r\n                    prop.put(\"info_success\",0);\r\n                }\r\n                return prop;\r\n            }            \r\n        }\r\n        \r\n        /*\r\n         * Message forwarding configuration\r\n         */\r\n        if (post.containsKey(\"msgForwarding\")) {\r\n            env.setConfig(\"msgForwardingEnabled\",post.containsKey(\"msgForwardingEnabled\")?\"true\":\"false\");\r\n            env.setConfig(\"msgForwardingCmd\",(String) post.get(\"msgForwardingCmd\"));\r\n            env.setConfig(\"msgForwardingTo\",(String) post.get(\"msgForwardingTo\"));\r\n            \r\n            prop.put(\"info\", 21);\r\n            prop.put(\"info_msgForwardingEnabled\", post.containsKey(\"msgForwardingEnabled\") ? \"on\" : \"off\");\r\n            prop.put(\"info_msgForwardingCmd\", (String) post.get(\"msgForwardingCmd\"));\r\n            prop.put(\"info_msgForwardingTo\", (String) post.get(\"msgForwardingTo\"));\r\n            \r\n            return prop;\r\n        }\r\n        \r\n        /*\r\n         * Parser configuration\r\n         */\r\n        if (post.containsKey(\"parserSettings\")) {   \r\n            plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n\t\t\tpost.remove(\"parserSettings\");\r\n            \r\n            String[] enabledMimes = null;\r\n            if (post.containsKey(\"allParserEnabled\")) {\r\n                // enable all available parsers\r\n                enabledMimes = sb.parser.setEnabledParserList(sb.parser.getAvailableParserList().keySet());\r\n            } else {\r\n                // activate all received parsers       \r\n                enabledMimes = sb.parser.setEnabledParserList(post.keySet());\r\n            }\r\n            Arrays.sort(enabledMimes);\r\n            \r\n            StringBuffer enabledMimesTxt = new StringBuffer();\r\n            for (int i=0; i < enabledMimes.length; i++) {\r\n                enabledMimesTxt.append(enabledMimes[i]).append(\",\");\r\n                prop.put(\"info_parser_\" + i + \"_enabledMime\",enabledMimes[i]);\r\n            }\r\n            prop.put(\"info_parser\",enabledMimes.length);\r\n            if (enabledMimesTxt.length() > 0) enabledMimesTxt.deleteCharAt(enabledMimesTxt.length()-1);            \r\n            \r\n            env.setConfig(\"parseableMimeTypes\",enabledMimesTxt.toString());\r\n            \r\n            prop.put(\"info\", 18);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // nothing made\r\n        prop.put(\"info\", 1);//no information submitted\r\n        return prop;\r\n    }","id":81207,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        //if (post == null) System.out.println(\"POST: NULL\"); else System.out.println(\"POST: \" + post.toString());\r\n        \r\n        // set values\r\n        String s;\r\n        int pos;\r\n        \r\n        if (post == null) {\r\n            prop.put(\"info\", 1);//no information submitted\r\n            return prop;\r\n        }\r\n        \r\n        // admin password\r\n        if (post.containsKey(\"adminaccount\")) {\r\n            // read and process data\r\n            String user   = (String) post.get(\"adminuser\");\r\n            String pw1    = (String) post.get(\"adminpw1\");\r\n            String pw2    = (String) post.get(\"adminpw2\");\r\n            // do checks\r\n            if ((user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            // check passed. set account:\r\n            env.setConfig(\"adminAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"adminAccount\", \"\");\r\n            prop.put(\"info\", 5);//admin account changed\r\n            prop.put(\"info_user\", user);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // proxy password\r\n        if (post.containsKey(\"proxyaccount\")) {\r\n            // set new port\r\n            String port = (String) post.get(\"port\");\r\n            env.setConfig(\"port\", port);\r\n            prop.put(\"info_port\", port);\r\n            \r\n            // read and process data\r\n            String filter = (String) post.get(\"proxyfilter\");\r\n            String user   = (String) post.get(\"proxyuser\");\r\n            String pw1    = (String) post.get(\"proxypw1\");\r\n            String pw2    = (String) post.get(\"proxypw2\");\r\n            // do checks\r\n            if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"proxyClient\", filter);\r\n            if (pw1.length() == 0) {\r\n                // only ip filter setting without account\r\n                env.setConfig(\"proxyAccountBase64MD5\", \"\");\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 6);//proxy account has changed(no pw)\r\n                prop.put(\"info_filter\", filter);\r\n            } else {\r\n                // also paccount setting\r\n                env.setConfig(\"proxyAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n                env.setConfig(\"proxyAccount\", \"\");\r\n                prop.put(\"info\", 7);//proxy account has changed\r\n                prop.put(\"info_user\", user);\r\n                prop.put(\"info_filter\", filter);\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        // http networking\r\n        if (post.containsKey(\"httpNetworking\")) {\r\n            \r\n            // set transparent proxy flag\r\n            httpdProxyHandler.isTransparentProxy = post.containsKey(\"isTransparentProxy\");\r\n            env.setConfig(\"isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"true\" : \"false\");\r\n            prop.put(\"info_isTransparentProxy\", httpdProxyHandler.isTransparentProxy ? \"on\" : \"off\");            \r\n            \r\n            // setting the keep alive property\r\n            httpd.keepAliveSupport = post.containsKey(\"connectionKeepAliveSupport\");\r\n            env.setConfig(\"connectionKeepAliveSupport\", httpd.keepAliveSupport ? \"true\" : \"false\");\r\n            prop.put(\"info_connectionKeepAliveSupport\", httpd.keepAliveSupport ? \"on\" : \"off\"); \r\n            \r\n            prop.put(\"info\", 20);             \r\n            return prop;\r\n        }\r\n        \r\n        // port forwarding configuration\r\n        if (post.containsKey(\"portForwarding\")) {            \r\n            env.setConfig(\"portForwardingEnabled\", post.containsKey(\"portForwardingEnabled\")?\"true\":\"false\");\r\n            env.setConfig(\"portForwardingUseProxy\",post.containsKey(\"portForwardingUseProxy\")?\"true\":\"false\");\r\n            env.setConfig(\"portForwardingPort\",    (String)post.get(\"portForwardingPort\"));\r\n                        \r\n            env.setConfig(\"portForwardingHost\",    (String)post.get(\"portForwardingHost\"));\r\n            env.setConfig(\"portForwardingHostPort\",(String)post.get(\"portForwardingHostPort\"));\r\n            env.setConfig(\"portForwardingHostUser\",(String)post.get(\"portForwardingHostUser\"));\r\n            env.setConfig(\"portForwardingHostPwd\", (String)post.get(\"portForwardingHostPwd\"));\r\n            \r\n            // trying to reconnect the port forwarding channel\r\n            try {\r\n                serverCore httpd = (serverCore) env.getThread(\"10_httpd\");\r\n                if ((serverCore.portForwardingEnabled) && (serverCore.portForwarding != null)) {\r\n                    // trying to shutdown the current port forwarding channel\r\n                    serverCore.portForwarding.disconnect();                \r\n                }            \r\n                // trying to reinitialize the port forwarding\r\n                httpd.initPortForwarding();\r\n                \r\n                // notifying publishSeed Thread\r\n                serverThread peerPing = env.getThread(\"30_peerping\");\r\n                peerPing.notifyThread();\r\n            } catch (Exception e) {\r\n                prop.put(\"info\", 23); \r\n                prop.put(\"info_errormsg\",(e.getMessage() == null) ? \"unknown\" : e.getMessage().replaceAll(\"\\n\",\"<br>\"));\r\n                return prop;\r\n            }\r\n            \r\n            prop.put(\"info\", 22); \r\n            prop.put(\"info_portForwardingEnabled\", post.containsKey(\"portForwardingEnabled\")?\"on\":\"off\");  \r\n            prop.put(\"info_portForwardingUseProxy\",post.containsKey(\"portForwardingUseProxy\")?\"on\":\"off\");\r\n            prop.put(\"info_portForwardingPort\",    (String)post.get(\"portForwardingPort\"));\r\n            prop.put(\"info_portForwardingHost\",    (String)post.get(\"portForwardingHost\"));\r\n            prop.put(\"info_portForwardingHostPort\",(String)post.get(\"portForwardingHostPort\"));\r\n            prop.put(\"info_portForwardingHostUser\",(String)post.get(\"portForwardingHostUser\"));\r\n            prop.put(\"info_portForwardingHostPwd\", (String)post.get(\"portForwardingHostPwd\"));   \r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // server password\r\n        if (post.containsKey(\"serveraccount\")) {\r\n            // read and process data\r\n            String filter = (String) post.get(\"serverfilter\");\r\n            String user   = (String) post.get(\"serveruser\");\r\n            String pw1    = (String) post.get(\"serverpw1\");\r\n            String pw2    = (String) post.get(\"serverpw2\");\r\n            // do checks\r\n            if (filter == null) {\r\n                //if ((filter == null) || (user == null) || (pw1 == null) || (pw2 == null)) {\r\n                prop.put(\"info\", 1);//error with submitted information\r\n                return prop;\r\n            }\r\n            if (user.length() == 0) {\r\n                prop.put(\"info\", 2);//username must be given\r\n                return prop;\r\n            }\r\n            if (!(pw1.equals(pw2))) {\r\n                prop.put(\"info\", 3);//pw check failed\r\n                return prop;\r\n            }\r\n            if (filter.length() == 0) filter = \"*\";\r\n            // check passed. set account:\r\n            env.setConfig(\"serverClient\", filter);\r\n            env.setConfig(\"serverAccountBase64MD5\", serverCodings.standardCoder.encodeMD5Hex(serverCodings.standardCoder.encodeBase64String(user + \":\" + pw1)));\r\n            env.setConfig(\"serverAccount\", \"\");\r\n            \r\n            prop.put(\"info\", 8);//server access filter updated\r\n            prop.put(\"info_user\", user);\r\n            prop.put(\"info_filter\", filter);\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"dispop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"false\");\r\n            prop.put(\"info\", 9);//popup disabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"enpop\")) {\r\n            env.setConfig(\"browserPopUpTrigger\", \"true\");\r\n            prop.put(\"info\", 10);//popup enabled\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"pmode\")) {\r\n            env.setConfig(\"onlineMode\", \"2\");\r\n            prop.put(\"info\", 11);//permanent online mode\r\n            yacyCore.triggerOnlineAction();\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"generalsettings\")) {\r\n            /*\r\n            // set peer language\r\n            String peerLang = (String) post.get(\"peerlang\");\r\n            if ((peerLang == null) || (peerLang.equals(\"en\"))) peerLang = \"default\";\r\n\t    HashMap lm = langMap(env);\r\n\t    if (!(lm.containsKey(peerLang))) peerLang = \"default\";\r\n\t    env.setConfig(\"htLocaleSelection\", peerLang);\r\n\t    prop.put(\"info_peerLang\", (String) lm.get(peerLang));\r\n            */\r\n            \r\n            // check if peer name already exists\r\n            String peerName = (String) post.get(\"peername\");\r\n            String staticIP =  (String)post.get(\"staticIP\");\r\n            env.setConfig(\"staticIP\", staticIP);\r\n            if (staticIP.length() > 0) yacyCore.seedDB.mySeed.put(\"IP\", staticIP);\r\n            yacySeed oldSeed = yacyCore.seedDB.lookupByName(peerName);\r\n            \r\n            if ((oldSeed == null) || (env.getConfig(\"peerName\",\"\").equals(peerName))) {\r\n                // the name is new\r\n                boolean nameOK = (peerName.length() <= 80);\r\n                for (int i = 0; i < peerName.length(); i++) {\r\n                    if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\".indexOf(peerName.charAt(i)) < 0) nameOK = false;\r\n                }\r\n                if (!(nameOK)) {\r\n                    // deny change\r\n                    prop.put(\"info\", 17);//peer name is wrong\r\n                } else {\r\n                    \r\n                    // set values\r\n                    env.setConfig(\"peerName\", peerName);\r\n                    prop.put(\"info\", 12);//port or peername changed\r\n                    prop.put(\"info_peerName\", peerName);\r\n                    prop.put(\"info_staticIP\", staticIP);\r\n                }\r\n            } else {\r\n                // deny change\r\n                prop.put(\"info\", 16);//peer name is already used by another peer\r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"proxysettings\")) {\r\n            httpdProxyHandler.remoteProxyUse = ((String) post.get(\"remoteProxyUse\", \"\")).equals(\"on\");\r\n            httpdProxyHandler.remoteProxyHost = (String) post.get(\"remoteProxyHost\", \"\");\r\n            try {\r\n                httpdProxyHandler.remoteProxyPort = Integer.parseInt((String) post.get(\"remoteProxyPort\", \"\"));\r\n            } catch (NumberFormatException e) {\r\n                httpdProxyHandler.remoteProxyPort = 3128;\r\n            }\r\n            httpdProxyHandler.remoteProxyNoProxy = (String) post.get(\"remoteProxyNoProxy\", \"\");\r\n            httpdProxyHandler.remoteProxyNoProxyPatterns = httpdProxyHandler.remoteProxyNoProxy.split(\",\");\r\n            env.setConfig(\"remoteProxyHost\", httpdProxyHandler.remoteProxyHost);\r\n            env.setConfig(\"remoteProxyPort\", \"\" + httpdProxyHandler.remoteProxyPort);\r\n            env.setConfig(\"remoteProxyNoProxy\", httpdProxyHandler.remoteProxyNoProxy);\r\n            env.setConfig(\"remoteProxyUse\", (httpdProxyHandler.remoteProxyUse) ? \"true\" : \"false\");\r\n            prop.put(\"info\", 15); // The remote-proxy setting has been changed\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedUploadRetry\")) {\r\n            String error;\r\n            if ((error = yacyCore.saveSeedList(env)) == null) {\r\n                // trying to upload the seed-list file    \r\n                prop.put(\"info\", 13);\r\n                prop.put(\"info_success\",1);\r\n            } else {\r\n                prop.put(\"info\",14);\r\n                prop.put(\"info_errormsg\",error.replaceAll(\"\\n\",\"<br>\"));                \r\n                env.setConfig(\"seedUploadMethod\",\"none\");                 \r\n            }\r\n            return prop;\r\n        }\r\n        \r\n        if (post.containsKey(\"seedSettings\")) {\r\n            // getting the currently used uploading method\r\n            String oldSeedUploadMethod = env.getConfig(\"seedUploadMethod\",\"none\");\r\n            String newSeedUploadMethod = (String)post.get(\"seedUploadMethod\");\r\n            String oldSeedURLStr = env.getConfig(\"seedURL\",\"\");\r\n            String newSeedURLStr = (String)post.get(\"seedURL\");\r\n            \r\n            boolean seedUrlChanged = !oldSeedURLStr.equals(newSeedURLStr);\r\n            boolean uploadMethodChanged = !oldSeedUploadMethod.equals(newSeedUploadMethod);\r\n            if (uploadMethodChanged) {\r\n                uploadMethodChanged = yacyCore.changeSeedUploadMethod(newSeedUploadMethod);\r\n            }\r\n            \r\n            if (seedUrlChanged || uploadMethodChanged) {\r\n                env.setConfig(\"seedUploadMethod\", newSeedUploadMethod);\r\n                env.setConfig(\"seedURL\", newSeedURLStr);\r\n                \r\n                // try an upload\r\n                String error;\r\n                if ((error = yacyCore.saveSeedList(env)) == null) {\r\n                    // we have successfully uploaded the seed-list file\r\n                    prop.put(\"info_seedUploadMethod\",newSeedUploadMethod);\r\n                    prop.put(\"info_seedURL\",newSeedURLStr);\r\n                    prop.put(\"info_success\",(newSeedUploadMethod.equalsIgnoreCase(\"none\")?0:1));\r\n                    prop.put(\"info\", 19);\r\n                } else {\r\n                    prop.put(\"info\",14);\r\n                    prop.put(\"info_errormsg\",error.replaceAll(\"\\n\",\"<br>\"));                \r\n                    env.setConfig(\"seedUploadMethod\",\"none\");\r\n                }\r\n                return prop;\r\n            }\r\n        }\r\n        \r\n        /* \r\n         * Loop through the available seed uploaders to see if the \r\n         * configuration of one of them has changed \r\n         */\r\n        Hashtable uploaders = yacyCore.getSeedUploadMethods();\r\n        Enumeration uploaderKeys = uploaders.keys();\r\n        while (uploaderKeys.hasMoreElements()) {\r\n            // getting the uploader module name\r\n            String uploaderName = (String) uploaderKeys.nextElement();\r\n            \r\n            \r\n            // determining if the user has reconfigured the settings of this uploader\r\n            if (post.containsKey(\"seed\" + uploaderName + \"Settings\")) {\r\n                nothingChanged = true;\r\n                yacySeedUploader theUploader = yacyCore.getSeedUploader(uploaderName);\r\n                String[] configOptions = theUploader.getConfigurationOptions();\r\n                if (configOptions != null) {\r\n                    for (int i=0; i<configOptions.length; i++) {\r\n                        String newSettings = post.get(configOptions[i],\"\");\r\n                        String oldSettings = env.getConfig(configOptions[i],\"\");\r\n                        nothingChanged &= newSettings.equals(oldSettings); \r\n                        if (!nothingChanged) {\r\n                            env.setConfig(configOptions[i],newSettings);\r\n                        }\r\n                    }\r\n                }   \r\n                if (!nothingChanged) {\r\n                    // if the seed upload method is equal to the seed uploader whose settings\r\n                    // were changed, we now try to upload the seed list with the new settings\r\n                    if (env.getConfig(\"seedUploadMethod\",\"none\").equalsIgnoreCase(uploaderName)) {\r\n                        String error;\r\n                        if ((error = yacyCore.saveSeedList(env)) == null) {;\r\n                            \r\n                            // we have successfully uploaded the seed file\r\n                            prop.put(\"info\", 13);\r\n                            prop.put(\"info_success\",1);\r\n                        } else {\r\n                            // if uploading failed we print out an error message\r\n                            prop.put(\"info\", 14);\r\n                            prop.put(\"info_errormsg\",error.replaceAll(\"\\n\",\"<br>\"));\r\n                            env.setConfig(\"seedUploadMethod\",\"none\");                            \r\n                        }                       \r\n                    } else {\r\n                        prop.put(\"info\", 13);\r\n                        prop.put(\"info_success\",0);\r\n                    }\r\n                } else {\r\n                    prop.put(\"info\", 13);\r\n                    prop.put(\"info_success\",0);\r\n                }\r\n                return prop;\r\n            }            \r\n        }\r\n        \r\n        /*\r\n         * Message forwarding configuration\r\n         */\r\n        if (post.containsKey(\"msgForwarding\")) {\r\n            env.setConfig(\"msgForwardingEnabled\",post.containsKey(\"msgForwardingEnabled\")?\"true\":\"false\");\r\n            env.setConfig(\"msgForwardingCmd\",(String) post.get(\"msgForwardingCmd\"));\r\n            env.setConfig(\"msgForwardingTo\",(String) post.get(\"msgForwardingTo\"));\r\n            \r\n            prop.put(\"info\", 21);\r\n            prop.put(\"info_msgForwardingEnabled\", post.containsKey(\"msgForwardingEnabled\") ? \"on\" : \"off\");\r\n            prop.put(\"info_msgForwardingCmd\", (String) post.get(\"msgForwardingCmd\"));\r\n            prop.put(\"info_msgForwardingTo\", (String) post.get(\"msgForwardingTo\"));\r\n            \r\n            return prop;\r\n        }\r\n        \r\n        /*\r\n         * Parser configuration\r\n         */\r\n        if (post.containsKey(\"parserSettings\")) {   \r\n            plasmaSwitchboard sb = (plasmaSwitchboard)env;\r\n\t\t\tpost.remove(\"parserSettings\");\r\n            \r\n            String[] enabledMimes = null;\r\n            if (post.containsKey(\"allParserEnabled\")) {\r\n                // enable all available parsers\r\n                enabledMimes = sb.parser.setEnabledParserList(sb.parser.getAvailableParserList().keySet());\r\n            } else {\r\n                // activate all received parsers       \r\n                enabledMimes = sb.parser.setEnabledParserList(post.keySet());\r\n            }\r\n            Arrays.sort(enabledMimes);\r\n            \r\n            StringBuffer enabledMimesTxt = new StringBuffer();\r\n            for (int i=0; i < enabledMimes.length; i++) {\r\n                enabledMimesTxt.append(enabledMimes[i]).append(\",\");\r\n                prop.put(\"info_parser_\" + i + \"_enabledMime\",enabledMimes[i]);\r\n            }\r\n            prop.put(\"info_parser\",enabledMimes.length);\r\n            if (enabledMimesTxt.length() > 0) enabledMimesTxt.deleteCharAt(enabledMimesTxt.length()-1);            \r\n            \r\n            env.setConfig(\"parseableMimeTypes\",enabledMimesTxt.toString());\r\n            \r\n            prop.put(\"info\", 18);\r\n            return prop;\r\n        }\r\n        \r\n        \r\n        // nothing made\r\n        prop.put(\"info\", 1);//no information submitted\r\n        return prop;\r\n    }","commit_id":"85877413a0fed82e9d627420ac54fd141af77252","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean saveSeedList() {\r\n        try {\r\n            saveSeedList(this.switchboard);\r\n            return true;\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }","id":81208,"modified_method":"public String saveSeedList() {\r\n        // return an error if this is not successful, and NULL if everything is fine\r\n        return saveSeedList(this.switchboard);\r\n    }","commit_id":"85877413a0fed82e9d627420ac54fd141af77252","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void saveSeedList(serverSwitch sb) \r\n    throws Exception {\r\n        String logt;\r\n        \r\n        // be shure that we have something to say\r\n        if (seedDB.mySeed.getAddress() == null) {\r\n            String errorMsg = \"We have no valid IP address until now\";\r\n            log.logWarning(\"SaveSeedList: \" + errorMsg);\r\n            throw new Exception (errorMsg);        \r\n        }\r\n        \r\n        // getting the configured seed uploader\r\n        String seedUploadMethod = sb.getConfig(\"seedUploadMethod\",\"\");\r\n        \r\n        // for backward compatiblity ....\r\n        if (\r\n                (seedUploadMethod.equalsIgnoreCase(\"Ftp\")) || \r\n                ((seedUploadMethod.equals(\"\")) &&\r\n                 (sb.getConfig(\"seedFTPPassword\",\"\").length() > 0))\r\n        ) {\r\n            seedUploadMethod = \"Ftp\";\r\n            sb.setConfig(\"seedUploadMethod\",seedUploadMethod);\r\n        } else if (\r\n                (seedUploadMethod.equalsIgnoreCase(\"File\")) ||\r\n                ((seedUploadMethod.equals(\"\")) &&\r\n                 (sb.getConfig(\"seedFilePath\", \"\").length() > 0))                \r\n        ) {\r\n            seedUploadMethod = \"File\";\r\n            sb.setConfig(\"seedUploadMethod\",seedUploadMethod);            \r\n        }\r\n\r\n        //  determine the seed uploader that should be used ...       \r\n        if (seedUploadMethod.equalsIgnoreCase(\"none\")) return;\r\n\r\n        yacySeedUploader uploader = getSeedUploader(seedUploadMethod);\r\n        if (uploader == null) {\r\n            String errorMsg = \"Unable to get the proper uploader-class for seed uploading method '\" + seedUploadMethod + \"'.\";\r\n            log.logWarning(\"SaveSeedList: \" + errorMsg);\r\n            throw new Exception (errorMsg);               \r\n        }        \r\n        \r\n        // ensure that the seed file url is configured properly\r\n        URL seedURL;\r\n        try{\r\n            String seedURLStr = sb.getConfig(\"seedURL\",\"\");\r\n            if (seedURLStr.length() == 0) throw new MalformedURLException(\"The seed-file url must not be empty.\");\r\n            if (!seedURLStr.toLowerCase().startsWith(\"http://\")) throw new MalformedURLException(\"Unsupported protocol.\");\r\n            seedURL = new URL(seedURLStr);\r\n        }catch(MalformedURLException e){\r\n            String errorMsg = \"Malformed seed file URL '\" + sb.getConfig(\"seedURL\",\"\") + \"'. \" + e.getMessage();\r\n            log.logWarning(\"SaveSeedList: \" + errorMsg);            \r\n            throw new Exception(errorMsg);\r\n        }              \r\n        \r\n        // upload the seed-list using the configured uploader class\r\n        String prevStatus = seedDB.mySeed.get(\"PeerType\", \"junior\");\r\n        if (prevStatus.equals(\"principal\")) prevStatus = \"senior\";\r\n\r\n        try {\r\n            seedDB.mySeed.put(\"PeerType\", \"principal\"); // this information shall also be uploaded\r\n            \r\n            log.logDebug(\"SaveSeedList: Using seed uploading method '\" + seedUploadMethod + \"' for seed-list uploading.\" +\r\n                         \"\\n\\tPrevious peerType is '\" + seedDB.mySeed.get(\"PeerType\", \"junior\") + \"'.\");\r\n            \r\n            //logt = seedDB.uploadCache(seedFTPServer, seedFTPAccount, seedFTPPassword, seedFTPPath, seedURL);\r\n            logt = seedDB.uploadCache(uploader,sb, seedDB, seedURL);\r\n            if (logt != null) {\r\n                if (logt.indexOf(\"Error\") >= 0) {\r\n                    seedDB.mySeed.put(\"PeerType\", prevStatus);\r\n                    log.logError(\"SaveSeedList: seed upload failed using \" + uploader.getClass().getName() + \" (error): \" + logt.substring(logt.indexOf(\"Error\") + 6));\r\n                    throw new Exception(\"Seed-list uploading failed using uploader '\" + uploader.getClass().getName() + \"'\\n(error): \" + logt.substring(logt.indexOf(\"Error\") + 6));                    \r\n                }\r\n                log.logInfo(logt);\r\n            }\r\n            \r\n            // finally, set the principal status\r\n            sb.setConfig(\"yacyStatus\",\"principal\");\r\n            return;\r\n        } catch (Exception e) {\r\n            seedDB.mySeed.put(\"PeerType\", prevStatus);\r\n            sb.setConfig(\"yacyStatus\", prevStatus);\r\n            log.logInfo(\"SaveSeedList: Seed upload failed (IO error): \" + e.getMessage());\r\n            throw new Exception(\"Seed-list uploading failed using uploader '\" + uploader.getClass().getName() + \"'\\n(error): \" + e.getMessage());\r\n        }\r\n    }","id":81209,"modified_method":"public static String saveSeedList(serverSwitch sb) {\r\n        // return an error if this is not successful, and NULL if everything is fine\r\n        String logt;\r\n        \r\n        // be shure that we have something to say\r\n        if (seedDB.mySeed.getAddress() == null) {\r\n            String errorMsg = \"We have no valid IP address until now\";\r\n            log.logWarning(\"SaveSeedList: \" + errorMsg);\r\n            return errorMsg;\r\n        }\r\n        \r\n        // getting the configured seed uploader\r\n        String seedUploadMethod = sb.getConfig(\"seedUploadMethod\",\"\");\r\n        \r\n        // for backward compatiblity ....\r\n        if (\r\n                (seedUploadMethod.equalsIgnoreCase(\"Ftp\")) || \r\n                ((seedUploadMethod.equals(\"\")) &&\r\n                 (sb.getConfig(\"seedFTPPassword\",\"\").length() > 0))\r\n        ) {\r\n            seedUploadMethod = \"Ftp\";\r\n            sb.setConfig(\"seedUploadMethod\",seedUploadMethod);\r\n        } else if (\r\n                (seedUploadMethod.equalsIgnoreCase(\"File\")) ||\r\n                ((seedUploadMethod.equals(\"\")) &&\r\n                 (sb.getConfig(\"seedFilePath\", \"\").length() > 0))                \r\n        ) {\r\n            seedUploadMethod = \"File\";\r\n            sb.setConfig(\"seedUploadMethod\",seedUploadMethod);            \r\n        }\r\n\r\n        //  determine the seed uploader that should be used ...       \r\n        if (seedUploadMethod.equalsIgnoreCase(\"none\")) return \"no uploader specified\";\r\n\r\n        yacySeedUploader uploader = getSeedUploader(seedUploadMethod);\r\n        if (uploader == null) {\r\n            String errorMsg = \"Unable to get the proper uploader-class for seed uploading method '\" + seedUploadMethod + \"'.\";\r\n            log.logWarning(\"SaveSeedList: \" + errorMsg);\r\n            return errorMsg;               \r\n        }\r\n        \r\n        // ensure that the seed file url is configured properly\r\n        URL seedURL;\r\n        try{\r\n            String seedURLStr = sb.getConfig(\"seedURL\",\"\");\r\n            if (seedURLStr.length() == 0) throw new MalformedURLException(\"The seed-file url must not be empty.\");\r\n            if (!seedURLStr.toLowerCase().startsWith(\"http://\")) throw new MalformedURLException(\"Unsupported protocol.\");\r\n            seedURL = new URL(seedURLStr);\r\n        }catch(MalformedURLException e){\r\n            String errorMsg = \"Malformed seed file URL '\" + sb.getConfig(\"seedURL\",\"\") + \"'. \" + e.getMessage();\r\n            log.logWarning(\"SaveSeedList: \" + errorMsg);            \r\n            return errorMsg;\r\n        }              \r\n        \r\n        // upload the seed-list using the configured uploader class\r\n        String prevStatus = seedDB.mySeed.get(\"PeerType\", \"junior\");\r\n        if (prevStatus.equals(\"principal\")) prevStatus = \"senior\";\r\n\r\n        try {\r\n            seedDB.mySeed.put(\"PeerType\", \"principal\"); // this information shall also be uploaded\r\n            \r\n            log.logDebug(\"SaveSeedList: Using seed uploading method '\" + seedUploadMethod + \"' for seed-list uploading.\" +\r\n                         \"\\n\\tPrevious peerType is '\" + seedDB.mySeed.get(\"PeerType\", \"junior\") + \"'.\");\r\n            \r\n            //logt = seedDB.uploadCache(seedFTPServer, seedFTPAccount, seedFTPPassword, seedFTPPath, seedURL);\r\n            logt = seedDB.uploadCache(uploader,sb, seedDB, seedURL);\r\n            if (logt != null) {\r\n                if (logt.indexOf(\"Error\") >= 0) {\r\n                    seedDB.mySeed.put(\"PeerType\", prevStatus);\r\n                    String errorMsg = \"SaveSeedList: seed upload failed using \" + uploader.getClass().getName() + \" (error): \" + logt.substring(logt.indexOf(\"Error\") + 6);\r\n                    log.logError(errorMsg);\r\n                    return errorMsg;\r\n                }\r\n                log.logInfo(logt);\r\n            }\r\n            \r\n            // finally, set the principal status\r\n            sb.setConfig(\"yacyStatus\",\"principal\");\r\n            return null;\r\n        } catch (Exception e) {\r\n            seedDB.mySeed.put(\"PeerType\", prevStatus);\r\n            sb.setConfig(\"yacyStatus\", prevStatus);\r\n            String errorMsg = \"SaveSeedList: Seed upload failed (IO error): \" + e.getMessage();\r\n            log.logInfo(errorMsg);\r\n            return errorMsg;\r\n        }\r\n    }","commit_id":"85877413a0fed82e9d627420ac54fd141af77252","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private InputStream sendHttpRequestStream(String method, boolean overrideTrust) throws HttpClientException {\n        // setup some SSL variables\n        SSLUtil.loadJsseProperties();\n            \n        String arguments = null;\n        InputStream in = null;                     \n\n        if (url == null) {\n            throw new HttpClientException(\"Cannot process a null URL.\");\n        }\n\n        if (rawStream != null) {\n            arguments = rawStream;\n        } else if (parameters != null && parameters.size() > 0) {\n            arguments = UtilHttp.urlEncodeArgs(parameters, false);\n        }\n\n        // Append the arguments to the query string if GET.\n        if (method.equalsIgnoreCase(\"get\") && arguments != null) {\n            url = url + \"?\" + arguments;\n        }\n\n        // Create the URL and open the connection.\n        try {\n            requestUrl = new URL(url);\n            if (overrideTrust) {\n                con = URLConnector.openUntrustedConnection(requestUrl, timeout, clientCertAlias, SSLUtil.HOSTCERT_NORMAL_CHECK);\n            } else {\n                con = URLConnector.openConnection(requestUrl, timeout, clientCertAlias, SSLUtil.HOSTCERT_NORMAL_CHECK);\n            }\n            if (Debug.verboseOn() || debug) Debug.log(\"Connection opened to : \" + requestUrl.toExternalForm(), module);\n\n            if ((con instanceof HttpURLConnection)) {\n                ((HttpURLConnection) con).setInstanceFollowRedirects(followRedirects);\n                if (Debug.verboseOn() || debug) Debug.log(\"Connection is of type HttpURLConnection\", module);\n            }\n\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            if (Debug.verboseOn() || debug) Debug.log(\"Do Input = true / Use Caches = false\", module);\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n                con.setDoInput(true);\n                if (Debug.verboseOn() || debug) Debug.log(\"Set content type to : application/x-www-form-urlencoded\", module);\n            }\n\n            if (headers != null && headers.size() > 0) {\n                Set headerSet = headers.keySet();\n                Iterator i = headerSet.iterator();\n\n                while (i.hasNext()) {\n                    String headerName = (String) i.next();\n                    String headerValue = (String) headers.get(headerName);\n                    con.setRequestProperty(headerName, headerValue);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Header : \" + headerName + \" -> \" + headerValue, module);\n                }\n            } else {\n                if (Debug.verboseOn() || debug) Debug.log(\"No headers to set\", module);\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                DataOutputStream out = new DataOutputStream(con.getOutputStream());\n                if (Debug.verboseOn() || debug) Debug.log(\"Opened output stream\", module);\n\n                out.writeBytes(arguments);\n                if (Debug.verboseOn() || debug) Debug.log(\"Wrote arguements (parameters) : \" + arguments, module);\n\n                out.flush();\n                out.close();\n                if (Debug.verboseOn() || debug) Debug.log(\"Flushed and closed buffer\", module);\n            }\n\n            if (Debug.verboseOn() || debug) {\n                Map headerFields = con.getHeaderFields();\n                Debug.log(\"Header Fields : \" + headerFields, module);\n            }\n\n            in = con.getInputStream();\n        } catch (IOException ioe) {\n            if ((trustAny && !overrideTrust) && (ioe.getCause() instanceof CertificateException)) {\n                Debug.logWarning(ioe.getCause(), module);\n                return sendHttpRequestStream(method, true);\n            }\n            throw new HttpClientException(\"IO Error processing request\", ioe);\n        } catch (Exception e) {\n            throw new HttpClientException(\"Error processing request\", e);\n        }\n\n        return in;\n    }","id":81210,"modified_method":"private InputStream sendHttpRequestStream(String method, boolean overrideTrust) throws HttpClientException {\n        // setup some SSL variables\n        SSLUtil.loadJsseProperties();\n            \n        String arguments = null;\n        InputStream in = null;                     \n\n        if (url == null) {\n            throw new HttpClientException(\"Cannot process a null URL.\");\n        }\n\n        if (rawStream != null) {\n            arguments = rawStream;\n        } else if (parameters != null && parameters.size() > 0) {\n            arguments = UtilHttp.urlEncodeArgs(parameters, false);\n        }\n\n        // Append the arguments to the query string if GET.\n        if (method.equalsIgnoreCase(\"get\") && arguments != null) {\n            url = url + \"?\" + arguments;\n        }\n\n        // Create the URL and open the connection.\n        try {\n            requestUrl = new URL(url);\n            if (overrideTrust) {\n                con = URLConnector.openUntrustedConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            } else {\n                con = URLConnector.openConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            }\n            if (Debug.verboseOn() || debug) Debug.log(\"Connection opened to : \" + requestUrl.toExternalForm(), module);\n\n            if ((con instanceof HttpURLConnection)) {\n                ((HttpURLConnection) con).setInstanceFollowRedirects(followRedirects);\n                if (Debug.verboseOn() || debug) Debug.log(\"Connection is of type HttpURLConnection\", module);\n            }\n\n            // set the content type\n            if (contentType != null) {\n                con.setRequestProperty(\"Content-type\", contentType);\n            }\n\n            // connection settings\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            if (keepAlive) {\n                con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                if (contentType == null)\n                    con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n                con.setDoInput(true);\n            }\n\n            if (headers != null && headers.size() > 0) {\n                Set headerSet = headers.keySet();\n                Iterator i = headerSet.iterator();\n\n                while (i.hasNext()) {\n                    String headerName = (String) i.next();\n                    String headerValue = (String) headers.get(headerName);\n                    con.setRequestProperty(headerName, headerValue);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Header : \" + headerName + \" -> \" + headerValue, module);\n                }\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                DataOutputStream out = new DataOutputStream(con.getOutputStream());\n                if (Debug.verboseOn() || debug) Debug.log(\"Opened output stream\", module);\n\n                out.writeBytes(arguments);\n                if (Debug.verboseOn() || debug) Debug.log(\"Wrote arguements (parameters) : \" + arguments, module);\n\n                out.flush();\n                out.close();\n                if (Debug.verboseOn() || debug) Debug.log(\"Flushed and closed buffer\", module);\n            }\n\n            if (Debug.verboseOn() || debug) {\n                Map headerFields = con.getHeaderFields();\n                Debug.log(\"Header Fields : \" + headerFields, module);\n            }\n\n            in = con.getInputStream();\n        } catch (IOException ioe) {\n            if ((trustAny && !overrideTrust) && (ioe.getCause() instanceof CertificateException)) {\n                Debug.logWarning(ioe.getCause(), module);\n                return sendHttpRequestStream(method, true);\n            }\n            throw new HttpClientException(\"IO Error processing request\", ioe);\n        } catch (Exception e) {\n            throw new HttpClientException(\"Error processing request\", e);\n        }\n\n        return in;\n    }","commit_id":"1528b98d6336a08ca50fe7163350ac3c14b6dce4","url":"https://github.com/apache/ofbiz"},{"original_method":"private InputStream sendHttpRequestStream(String method, boolean overrideTrust) throws HttpClientException {\n        // setup some SSL variables\n        SSLUtil.loadJsseProperties();\n            \n        String arguments = null;\n        InputStream in = null;                     \n\n        if (url == null) {\n            throw new HttpClientException(\"Cannot process a null URL.\");\n        }\n\n        if (rawStream != null) {\n            arguments = rawStream;\n        } else if (parameters != null && parameters.size() > 0) {\n            arguments = UtilHttp.urlEncodeArgs(parameters, false);\n        }\n\n        // Append the arguments to the query string if GET.\n        if (method.equalsIgnoreCase(\"get\") && arguments != null) {\n            url = url + \"?\" + arguments;\n        }\n\n        // Create the URL and open the connection.\n        try {\n            requestUrl = new URL(url);\n            if (overrideTrust) {\n                con = URLConnector.openUntrustedConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            } else {\n                con = URLConnector.openConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            }\n            if (Debug.verboseOn() || debug) Debug.log(\"Connection opened to : \" + requestUrl.toExternalForm(), module);\n\n            if ((con instanceof HttpURLConnection)) {\n                ((HttpURLConnection) con).setInstanceFollowRedirects(followRedirects);\n                if (Debug.verboseOn() || debug) Debug.log(\"Connection is of type HttpURLConnection\", module);\n            }\n\n            // set the content type\n            if (contentType != null) {\n                con.setRequestProperty(\"Content-type\", contentType);\n            }\n\n            // connection settings\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            if (keepAlive) {\n                con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                if (contentType == null)\n                    con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n                con.setDoInput(true);\n            }\n\n            if (headers != null && headers.size() > 0) {\n                Set headerSet = headers.keySet();\n                Iterator i = headerSet.iterator();\n\n                while (i.hasNext()) {\n                    String headerName = (String) i.next();\n                    String headerValue = (String) headers.get(headerName);\n                    con.setRequestProperty(headerName, headerValue);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Header : \" + headerName + \" -> \" + headerValue, module);\n                }\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                DataOutputStream out = new DataOutputStream(con.getOutputStream());\n                if (Debug.verboseOn() || debug) Debug.log(\"Opened output stream\", module);\n\n                if (arguments != null) {\n                    out.writeBytes(arguments);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Wrote arguements (parameters) : \" + arguments, module);\n                }\n\n                out.flush();\n                out.close();\n                if (Debug.verboseOn() || debug) Debug.log(\"Flushed and closed buffer\", module);\n            }\n\n            if (Debug.verboseOn() || debug) {\n                Map headerFields = con.getHeaderFields();\n                Debug.log(\"Header Fields : \" + headerFields, module);\n            }\n\n            in = con.getInputStream();\n        } catch (IOException ioe) {\n            if ((trustAny && !overrideTrust) && (ioe.getCause() instanceof CertificateException)) {\n                Debug.logWarning(ioe.getCause(), module);\n                return sendHttpRequestStream(method, true);\n            }\n            throw new HttpClientException(\"IO Error processing request\", ioe);\n        } catch (Exception e) {\n            throw new HttpClientException(\"Error processing request\", e);\n        }\n\n        return in;\n    }","id":81211,"modified_method":"private InputStream sendHttpRequestStream(String method, boolean overrideTrust) throws HttpClientException {\n        // setup some SSL variables\n        SSLUtil.loadJsseProperties();\n            \n        String arguments = null;\n        InputStream in = null;                     \n\n        if (url == null) {\n            throw new HttpClientException(\"Cannot process a null URL.\");\n        }\n\n        if (rawStream != null) {\n            arguments = rawStream;\n        } else if (parameters != null && parameters.size() > 0) {\n            arguments = UtilHttp.urlEncodeArgs(parameters, false);\n        }\n\n        // Append the arguments to the query string if GET.\n        if (method.equalsIgnoreCase(\"get\") && arguments != null) {\n            url = url + \"?\" + arguments;\n        }\n\n        // Create the URL and open the connection.\n        try {\n            requestUrl = new URL(url);\n            if (overrideTrust) {\n                con = URLConnector.openUntrustedConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            } else {\n                con = URLConnector.openConnection(requestUrl, timeout, clientCertAlias, hostVerification);\n            }\n            if (Debug.verboseOn() || debug) Debug.log(\"Connection opened to : \" + requestUrl.toExternalForm(), module);\n\n            if ((con instanceof HttpURLConnection)) {\n                ((HttpURLConnection) con).setInstanceFollowRedirects(followRedirects);\n                if (Debug.verboseOn() || debug) Debug.log(\"Connection is of type HttpURLConnection\", module);\n            }\n\n            // set the content type\n            if (contentType != null) {\n                con.setRequestProperty(\"Content-type\", contentType);\n            }\n\n            // connection settings\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            if (keepAlive) {\n                con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                if (contentType == null) {\n                    con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n                }\n                con.setDoInput(true);\n            }\n            \n            // if there is basicAuth info set the request property for it\n            if (basicAuthUsername != null) {\n            \tString basicAuthString = \"Basic \" + Base64.base64Encode(basicAuthUsername + \":\" + (basicAuthPassword == null ? \"\" : basicAuthPassword));\n                con.setRequestProperty(\"Authorization\", basicAuthString);\n                if (Debug.verboseOn() || debug) Debug.log(\"Header - Authorization: \" + basicAuthString, module);\n            }\n            \n            if (headers != null && headers.size() > 0) {\n                Set headerSet = headers.keySet();\n                Iterator i = headerSet.iterator();\n\n                while (i.hasNext()) {\n                    String headerName = (String) i.next();\n                    String headerValue = (String) headers.get(headerName);\n                    con.setRequestProperty(headerName, headerValue);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Header - \" + headerName + \": \" + headerValue, module);\n                }\n            }\n\n            if (method.equalsIgnoreCase(\"post\")) {\n                DataOutputStream out = new DataOutputStream(con.getOutputStream());\n                if (Debug.verboseOn() || debug) Debug.log(\"Opened output stream\", module);\n\n                if (arguments != null) {\n                    out.writeBytes(arguments);\n                    if (Debug.verboseOn() || debug) Debug.log(\"Wrote arguements (parameters) : \" + arguments, module);\n                }\n\n                out.flush();\n                out.close();\n                if (Debug.verboseOn() || debug) Debug.log(\"Flushed and closed buffer\", module);\n            }\n\n            if (Debug.verboseOn() || debug) {\n                Map headerFields = con.getHeaderFields();\n                Debug.log(\"Header Fields : \" + headerFields, module);\n            }\n\n            in = con.getInputStream();\n        } catch (IOException ioe) {\n            if ((trustAny && !overrideTrust) && (ioe.getCause() instanceof CertificateException)) {\n                Debug.logWarning(ioe.getCause(), module);\n                return sendHttpRequestStream(method, true);\n            }\n            throw new HttpClientException(\"IO Error processing request\", ioe);\n        } catch (Exception e) {\n            throw new HttpClientException(\"Error processing request\", e);\n        }\n\n        return in;\n    }","commit_id":"e0c4ab812359577de1029599795b91aa99afde41","url":"https://github.com/apache/ofbiz"},{"original_method":"public void updateCalendarResource(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tlong calendarResourceId = ParamUtil.getLong(\n\t\t\tactionRequest, \"calendarResourceId\");\n\n\t\tlong defaultCalendarId = ParamUtil.getLong(\n\t\t\tactionRequest, \"defaultCalendarId\");\n\t\tString code = ParamUtil.getString(actionRequest, \"code\");\n\t\tMap<Locale, String> nameMap = LocalizationUtil.getLocalizationMap(\n\t\t\tactionRequest, \"name\");\n\t\tMap<Locale, String> descriptionMap =\n\t\t\tLocalizationUtil.getLocalizationMap(actionRequest, \"description\");\n\t\tString type = ParamUtil.getString(actionRequest, \"type\");\n\t\tboolean active = ParamUtil.getBoolean(actionRequest, \"active\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tCalendarResource.class.getName(), actionRequest);\n\n\t\tif (calendarResourceId <= 0) {\n\t\t\tCalendarResourceServiceUtil.addCalendarResource(\n\t\t\t\tserviceContext.getScopeGroupId(), null, 0,\n\t\t\t\tPortalUUIDUtil.generate(), defaultCalendarId, code, nameMap,\n\t\t\t\tdescriptionMap, type, active, serviceContext);\n\t\t}\n\t\telse {\n\t\t\tCalendarResourceServiceUtil.updateCalendarResource(\n\t\t\t\tcalendarResourceId, defaultCalendarId, code, nameMap,\n\t\t\t\tdescriptionMap, type, active, serviceContext);\n\t\t}\n\t}","id":81212,"modified_method":"public void updateCalendarResource(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tlong calendarResourceId = ParamUtil.getLong(\n\t\t\tactionRequest, \"calendarResourceId\");\n\n\t\tlong defaultCalendarId = ParamUtil.getLong(\n\t\t\tactionRequest, \"defaultCalendarId\");\n\t\tString code = ParamUtil.getString(actionRequest, \"code\");\n\t\tMap<Locale, String> nameMap = LocalizationUtil.getLocalizationMap(\n\t\t\tactionRequest, \"name\");\n\t\tMap<Locale, String> descriptionMap =\n\t\t\tLocalizationUtil.getLocalizationMap(actionRequest, \"description\");\n\t\tString type = ParamUtil.getString(actionRequest, \"type\");\n\t\tboolean active = ParamUtil.getBoolean(actionRequest, \"active\");\n\n\t\tboolean autoGenerateCode = false;\n\n\t\tif (PortletPropsValues.CALENDAR_RESOURCE_FORCE_AUTOGENERATE_CODE) {\n\t\t\tautoGenerateCode = true;\n\t\t}\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tCalendarResource.class.getName(), actionRequest);\n\n\t\tif (calendarResourceId <= 0) {\n\t\t\tCalendarResourceServiceUtil.addCalendarResource(\n\t\t\t\tserviceContext.getScopeGroupId(), null, 0,\n\t\t\t\tPortalUUIDUtil.generate(), defaultCalendarId, code,\n\t\t\t\tautoGenerateCode, nameMap, descriptionMap, type, active,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tCalendarResourceServiceUtil.updateCalendarResource(\n\t\t\t\tcalendarResourceId, defaultCalendarId, nameMap, descriptionMap,\n\t\t\t\ttype, active, serviceContext);\n\t\t}\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected boolean isSessionErrorException(Throwable cause) {\n\t\tif (cause instanceof DuplicateCalendarResourceException ||\n\t\t\tcause instanceof PrincipalException) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":81213,"modified_method":"@Override\n\tprotected boolean isSessionErrorException(Throwable cause) {\n\t\tif (cause instanceof CalendarResourceCodeException ||\n\t\t\tcause instanceof DuplicateCalendarResourceException ||\n\t\t\tcause instanceof PrincipalException) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarResourcePersistence.findByPrimaryKey(calendarResourceId);\n\n\t\treturn updateCalendarResource(\n\t\t\tcalendarResourceId, calendarResource.getDefaultCalendarId(), code,\n\t\t\tnameMap, descriptionMap, type, active, serviceContext);\n\t}","id":81214,"modified_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarResourcePersistence.findByPrimaryKey(calendarResourceId);\n\n\t\treturn updateCalendarResource(\n\t\t\tcalendarResourceId, calendarResource.getDefaultCalendarId(),\n\t\t\tnameMap, descriptionMap, type, active, serviceContext);\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void validate(long classNameId, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarResourcePersistence.fetchByC_C(classNameId, classPK);\n\n\t\tif (calendarResource != null) {\n\t\t\tthrow new DuplicateCalendarResourceException();\n\t\t}\n\t}","id":81215,"modified_method":"protected void validate(long groupId, String code)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(code) || (code.indexOf(CharPool.SPACE) != -1)) {\n\t\t\tthrow new CalendarResourceCodeException();\n\t\t}\n\n\t\tif (calendarResourcePersistence.countByG_C(groupId, code) > 0) {\n\t\t\tthrow new DuplicateCalendarResourceException();\n\t\t}\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarResource addCalendarResource(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString classUuid, long defaultCalendarId, String code, Map<Locale,\n\t\t\tString> nameMap, Map<Locale, String> descriptionMap, String type,\n\t\t\tboolean active, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong calendarResourceId = counterLocalService.increment();\n\n\t\tif (Validator.isNull(className)) {\n\t\t\tclassName = CalendarResource.class.getName();\n\t\t\tclassPK = calendarResourceId;\n\t\t}\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tlong globalUserId = 0;\n\n\t\tif (isGlobalResource(classNameId)) {\n\t\t\tglobalUserId = getGlobalResourceUserId(classNameId, classPK);\n\n\t\t\tgroupId = getGlobalResourceGroupId(serviceContext.getCompanyId());\n\t\t}\n\n\t\tif (globalUserId > 0) {\n\t\t\tuserId = globalUserId;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(classNameId, classPK);\n\n\t\tCalendarResource calendarResource = calendarResourcePersistence.create(\n\t\t\tcalendarResourceId);\n\n\t\tcalendarResource.setUuid(serviceContext.getUuid());\n\t\tcalendarResource.setGroupId(groupId);\n\t\tcalendarResource.setCompanyId(user.getCompanyId());\n\t\tcalendarResource.setUserId(user.getUserId());\n\t\tcalendarResource.setUserName(user.getFullName());\n\t\tcalendarResource.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarResource.setClassNameId(classNameId);\n\n\t\tif (className.equals(CalendarResource.class.getName())) {\n\t\t\tcalendarResource.setClassPK(calendarResourceId);\n\t\t}\n\t\telse {\n\t\t\tcalendarResource.setClassPK(classPK);\n\t\t}\n\n\t\tcalendarResource.setClassUuid(classUuid);\n\n\t\tif (defaultCalendarId <= 0) {\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tCalendar calendar = calendarLocalService.addCalendar(\n\t\t\t\tuserId, groupId, calendarResourceId, nameMap, descriptionMap,\n\t\t\t\tPortletPropsValues.CALENDAR_COLOR_DEFAULT, true,\n\t\t\t\tserviceContext);\n\n\t\t\tdefaultCalendarId = calendar.getCalendarId();\n\t\t}\n\n\t\tcalendarResource.setDefaultCalendarId(defaultCalendarId);\n\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setType(type);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\treturn calendarResource;\n\t}","id":81216,"modified_method":"public CalendarResource addCalendarResource(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString classUuid, long defaultCalendarId, String code,\n\t\t\tboolean autoGenerateCode, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong calendarResourceId = counterLocalService.increment();\n\t\tcode = code.trim().toUpperCase();\n\n\t\tif (Validator.isNull(className)) {\n\t\t\tclassName = CalendarResource.class.getName();\n\t\t\tclassPK = calendarResourceId;\n\t\t}\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tvalidate(groupId, classNameId, classPK, code, autoGenerateCode);\n\n\t\tif (autoGenerateCode) {\n\t\t\tcode = String.valueOf(counterLocalService.increment());\n\t\t}\n\n\t\tlong globalUserId = 0;\n\n\t\tif (isGlobalResource(classNameId)) {\n\t\t\tglobalUserId = getGlobalResourceUserId(classNameId, classPK);\n\n\t\t\tgroupId = getGlobalResourceGroupId(serviceContext.getCompanyId());\n\t\t}\n\n\t\tif (globalUserId > 0) {\n\t\t\tuserId = globalUserId;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tCalendarResource calendarResource = calendarResourcePersistence.create(\n\t\t\tcalendarResourceId);\n\n\t\tcalendarResource.setUuid(serviceContext.getUuid());\n\t\tcalendarResource.setGroupId(groupId);\n\t\tcalendarResource.setCompanyId(user.getCompanyId());\n\t\tcalendarResource.setUserId(user.getUserId());\n\t\tcalendarResource.setUserName(user.getFullName());\n\t\tcalendarResource.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarResource.setClassNameId(classNameId);\n\n\t\tif (className.equals(CalendarResource.class.getName())) {\n\t\t\tcalendarResource.setClassPK(calendarResourceId);\n\t\t}\n\t\telse {\n\t\t\tcalendarResource.setClassPK(classPK);\n\t\t}\n\n\t\tcalendarResource.setClassUuid(classUuid);\n\n\t\tif (defaultCalendarId <= 0) {\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tCalendar calendar = calendarLocalService.addCalendar(\n\t\t\t\tuserId, groupId, calendarResourceId, nameMap, descriptionMap,\n\t\t\t\tPortletPropsValues.CALENDAR_COLOR_DEFAULT, true,\n\t\t\t\tserviceContext);\n\n\t\t\tdefaultCalendarId = calendar.getCalendarId();\n\t\t}\n\n\t\tcalendarResource.setDefaultCalendarId(defaultCalendarId);\n\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setType(type);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\treturn calendarResource;\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, long defaultCalendarId, String code,\n\t\t\tMap<Locale, String> nameMap, Map<Locale, String> descriptionMap,\n\t\t\tString type, boolean active, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarResourcePersistence.findByPrimaryKey(calendarResourceId);\n\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarResource.setDefaultCalendarId(defaultCalendarId);\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setType(type);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.updateModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\treturn calendarResource;\n\t}","id":81217,"modified_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, long defaultCalendarId,\n\t\t\tMap<Locale, String> nameMap, Map<Locale, String> descriptionMap,\n\t\t\tString type, boolean active, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarResourcePersistence.findByPrimaryKey(calendarResourceId);\n\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarResource.setDefaultCalendarId(defaultCalendarId);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setType(type);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.updateModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\treturn calendarResource;\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, long defaultCalendarId, String code,\n\t\t\tMap<Locale, String> nameMap, Map<Locale, String> descriptionMap,\n\t\t\tString type, boolean active, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResourcePermission.check(\n\t\t\tgetPermissionChecker(), calendarResourceId, ActionKeys.UPDATE);\n\n\t\treturn calendarResourceLocalService.updateCalendarResource(\n\t\t\tcalendarResourceId, defaultCalendarId, code, nameMap,\n\t\t\tdescriptionMap, type, active, serviceContext);\n\t}","id":81218,"modified_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, long defaultCalendarId,\n\t\t\tMap<Locale, String> nameMap, Map<Locale, String> descriptionMap,\n\t\t\tString type, boolean active, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResourcePermission.check(\n\t\t\tgetPermissionChecker(), calendarResourceId, ActionKeys.UPDATE);\n\n\t\treturn calendarResourceLocalService.updateCalendarResource(\n\t\t\tcalendarResourceId, defaultCalendarId, nameMap, descriptionMap,\n\t\t\ttype, active, serviceContext);\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResourcePermission.check(\n\t\t\tgetPermissionChecker(), calendarResourceId, ActionKeys.UPDATE);\n\n\t\treturn calendarResourceLocalService.updateCalendarResource(\n\t\t\tcalendarResourceId, code, nameMap, descriptionMap, type, active,\n\t\t\tserviceContext);\n\t}","id":81219,"modified_method":"public CalendarResource updateCalendarResource(\n\t\t\tlong calendarResourceId, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResourcePermission.check(\n\t\t\tgetPermissionChecker(), calendarResourceId, ActionKeys.UPDATE);\n\n\t\treturn calendarResourceLocalService.updateCalendarResource(\n\t\t\tcalendarResourceId, nameMap, descriptionMap, type, active,\n\t\t\tserviceContext);\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarResource addCalendarResource(\n\t\t\tlong groupId, String className, long classPK, String classUuid,\n\t\t\tlong defaultCalendarId, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarPortletPermission.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.ADD_RESOURCE);\n\n\t\treturn calendarResourceLocalService.addCalendarResource(\n\t\t\tgetUserId(), groupId, className, classPK, classUuid,\n\t\t\tdefaultCalendarId, code, nameMap, descriptionMap, type, active,\n\t\t\tserviceContext);\n\t}","id":81220,"modified_method":"public CalendarResource addCalendarResource(\n\t\t\tlong groupId, String className, long classPK, String classUuid,\n\t\t\tlong defaultCalendarId, String code, boolean autoGenerateCode,\n\t\t\tMap<Locale, String> nameMap, Map<Locale, String> descriptionMap,\n\t\t\tString type, boolean active, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarPortletPermission.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.ADD_RESOURCE);\n\n\t\treturn calendarResourceLocalService.addCalendarResource(\n\t\t\tgetUserId(), groupId, className, classPK, classUuid,\n\t\t\tdefaultCalendarId, code, autoGenerateCode, nameMap, descriptionMap,\n\t\t\ttype, active, serviceContext);\n\t}","commit_id":"f0d9f414d95f1b93cc600195c9cf672476501e4f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic CalendarBooking addCalendarBooking(\n\t\t\tlong userId, long calendarId, long[] childCalendarIds,\n\t\t\tlong parentCalendarBookingId, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startTime,\n\t\t\tlong endTime, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\n\t\tlong calendarBookingId = counterLocalService.increment();\n\n\t\tfor (Locale locale : descriptionMap.keySet()) {\n\t\t\tString sanitizedDescription = SanitizerUtil.sanitize(\n\t\t\t\tcalendar.getCompanyId(), calendar.getGroupId(), userId,\n\t\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\t\tContentTypes.TEXT_HTML, Sanitizer.MODE_ALL,\n\t\t\t\tdescriptionMap.get(locale), null);\n\n\t\t\tdescriptionMap.put(locale, sanitizedDescription);\n\t\t}\n\n\t\tjava.util.Calendar startTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartTime);\n\t\tjava.util.Calendar endTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendTime);\n\n\t\tif (allDay) {\n\t\t\tstartTimeJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartTimeJCalendar);\n\t\t\tendTimeJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendTimeJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(titleMap, startTimeJCalendar, endTimeJCalendar);\n\n\t\tCalendarBooking calendarBooking = calendarBookingPersistence.create(\n\t\t\tcalendarBookingId);\n\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setCalendarResourceId(calendar.getCalendarResourceId());\n\n\t\tif (parentCalendarBookingId > 0) {\n\t\t\tcalendarBooking.setParentCalendarBookingId(parentCalendarBookingId);\n\t\t}\n\t\telse {\n\t\t\tcalendarBooking.setParentCalendarBookingId(calendarBookingId);\n\t\t}\n\n\t\tString vEventUid = (String)serviceContext.getAttribute(\"vEventUid\");\n\n\t\tif (vEventUid == null) {\n\t\t\tvEventUid = PortalUUIDUtil.generate();\n\t\t}\n\n\t\tcalendarBooking.setVEventUid(vEventUid);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartTime(startTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndTime(endTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\t\tcalendarBooking.setExpandoBridgeAttributes(serviceContext);\n\t\tcalendarBooking.setStatus(\n\t\t\tCalendarBookingWorkflowConstants.STATUS_DRAFT);\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(calendarBooking, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\tCalendarActivityKeys.ADD_CALENDAR_BOOKING,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\t// Notifications\n\n\t\tsendNotification(\n\t\t\tcalendarBooking, NotificationTemplateType.INVITE, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tcalendarBooking.getCompanyId(), calendarBooking.getGroupId(),\n\t\t\tuserId, CalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(), calendarBooking,\n\t\t\tserviceContext);\n\n\t\treturn calendarBooking;\n\t}","id":81221,"modified_method":"@Override\n\tpublic CalendarBooking addCalendarBooking(\n\t\t\tlong userId, long calendarId, long[] childCalendarIds,\n\t\t\tlong parentCalendarBookingId, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startTime,\n\t\t\tlong endTime, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\n\t\tlong calendarBookingId = counterLocalService.increment();\n\n\t\tfor (Locale locale : descriptionMap.keySet()) {\n\t\t\tString sanitizedDescription = SanitizerUtil.sanitize(\n\t\t\t\tcalendar.getCompanyId(), calendar.getGroupId(), userId,\n\t\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\t\tContentTypes.TEXT_HTML, Sanitizer.MODE_ALL,\n\t\t\t\tdescriptionMap.get(locale), null);\n\n\t\t\tdescriptionMap.put(locale, sanitizedDescription);\n\t\t}\n\n\t\tjava.util.Calendar startTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartTime);\n\t\tjava.util.Calendar endTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendTime);\n\n\t\tif (allDay) {\n\t\t\tstartTimeJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartTimeJCalendar);\n\t\t\tendTimeJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendTimeJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tif (Validator.isNull(recurrence)) {\n\t\t\tvalidate(titleMap, startTimeJCalendar, endTimeJCalendar);\n\t\t}\n\t\telse {\n\t\t\tjava.util.Calendar untilJCalendar =\n\t\t\t\tRecurrenceSerializer.deserialize(recurrence).getUntilJCalendar();\n\n\t\t\tvalidate(\n\t\t\t\ttitleMap, startTimeJCalendar, endTimeJCalendar, untilJCalendar);\n\t\t}\n\n\t\tCalendarBooking calendarBooking = calendarBookingPersistence.create(\n\t\t\tcalendarBookingId);\n\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setCalendarResourceId(calendar.getCalendarResourceId());\n\n\t\tif (parentCalendarBookingId > 0) {\n\t\t\tcalendarBooking.setParentCalendarBookingId(parentCalendarBookingId);\n\t\t}\n\t\telse {\n\t\t\tcalendarBooking.setParentCalendarBookingId(calendarBookingId);\n\t\t}\n\n\t\tString vEventUid = (String)serviceContext.getAttribute(\"vEventUid\");\n\n\t\tif (vEventUid == null) {\n\t\t\tvEventUid = PortalUUIDUtil.generate();\n\t\t}\n\n\t\tcalendarBooking.setVEventUid(vEventUid);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartTime(startTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndTime(endTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\t\tcalendarBooking.setExpandoBridgeAttributes(serviceContext);\n\t\tcalendarBooking.setStatus(\n\t\t\tCalendarBookingWorkflowConstants.STATUS_DRAFT);\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(calendarBooking, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\tCalendarActivityKeys.ADD_CALENDAR_BOOKING,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\t// Notifications\n\n\t\tsendNotification(\n\t\t\tcalendarBooking, NotificationTemplateType.INVITE, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tcalendarBooking.getCompanyId(), calendarBooking.getGroupId(),\n\t\t\tuserId, CalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(), calendarBooking,\n\t\t\tserviceContext);\n\n\t\treturn calendarBooking;\n\t}","commit_id":"f7952910234be9d8fb73351f8e2789f0a87b429c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validate(\n\t\t\tMap<Locale, String> titleMap, java.util.Calendar startTimeJCalendar,\n\t\t\tjava.util.Calendar endTimeJCalendar)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(titleMap) || titleMap.isEmpty()) {\n\t\t\tthrow new CalendarBookingTitleException();\n\t\t}\n\n\t\tif (startTimeJCalendar.after(endTimeJCalendar)) {\n\t\t\tthrow new CalendarBookingDurationException();\n\t\t}\n\t}","id":81222,"modified_method":"protected void validate(\n\t\t\tMap<Locale, String> titleMap, java.util.Calendar startTimeJCalendar,\n\t\t\tjava.util.Calendar endTimeJCalendar)\n\t\tthrows PortalException {\n\n\t\tvalidate(titleMap, startTimeJCalendar, endTimeJCalendar, null);\n\t}","commit_id":"f7952910234be9d8fb73351f8e2789f0a87b429c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic CalendarBooking updateCalendarBooking(\n\t\t\tlong userId, long calendarBookingId, long calendarId,\n\t\t\tlong[] childCalendarIds, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startTime,\n\t\t\tlong endTime, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Calendar booking\n\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\t\tCalendarBooking calendarBooking =\n\t\t\tcalendarBookingPersistence.findByPrimaryKey(calendarBookingId);\n\n\t\tfor (Locale locale : descriptionMap.keySet()) {\n\t\t\tString sanitizedDescription = SanitizerUtil.sanitize(\n\t\t\t\tcalendar.getCompanyId(), calendar.getGroupId(), userId,\n\t\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\t\tContentTypes.TEXT_HTML, Sanitizer.MODE_ALL,\n\t\t\t\tdescriptionMap.get(locale), null);\n\n\t\t\tdescriptionMap.put(locale, sanitizedDescription);\n\t\t}\n\n\t\tjava.util.Calendar startTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartTime);\n\t\tjava.util.Calendar endTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendTime);\n\n\t\tif (allDay) {\n\t\t\tstartTimeJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartTimeJCalendar);\n\t\t\tendTimeJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendTimeJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tvalidate(titleMap, startTimeJCalendar, endTimeJCalendar);\n\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartTime(startTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndTime(endTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\t\tcalendarBooking.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\tCalendarActivityKeys.UPDATE_CALENDAR_BOOKING,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\t// Notifications\n\n\t\tsendNotification(\n\t\t\tcalendarBooking, NotificationTemplateType.UPDATE, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tcalendarBooking.getCompanyId(), calendarBooking.getGroupId(),\n\t\t\tuserId, CalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(), calendarBooking,\n\t\t\tserviceContext);\n\n\t\treturn calendarBooking;\n\t}","id":81223,"modified_method":"@Override\n\tpublic CalendarBooking updateCalendarBooking(\n\t\t\tlong userId, long calendarBookingId, long calendarId,\n\t\t\tlong[] childCalendarIds, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startTime,\n\t\t\tlong endTime, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Calendar booking\n\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\t\tCalendarBooking calendarBooking =\n\t\t\tcalendarBookingPersistence.findByPrimaryKey(calendarBookingId);\n\n\t\tfor (Locale locale : descriptionMap.keySet()) {\n\t\t\tString sanitizedDescription = SanitizerUtil.sanitize(\n\t\t\t\tcalendar.getCompanyId(), calendar.getGroupId(), userId,\n\t\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\t\tContentTypes.TEXT_HTML, Sanitizer.MODE_ALL,\n\t\t\t\tdescriptionMap.get(locale), null);\n\n\t\t\tdescriptionMap.put(locale, sanitizedDescription);\n\t\t}\n\n\t\tjava.util.Calendar startTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartTime);\n\t\tjava.util.Calendar endTimeJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendTime);\n\n\t\tif (allDay) {\n\t\t\tstartTimeJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartTimeJCalendar);\n\t\t\tendTimeJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendTimeJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tif (Validator.isNull(recurrence)) {\n\t\t\tvalidate(titleMap, startTimeJCalendar, endTimeJCalendar);\n\t\t}\n\t\telse {\n\t\t\tjava.util.Calendar untilJCalendar =\n\t\t\t\tRecurrenceSerializer.deserialize(recurrence).getUntilJCalendar();\n\n\t\t\tvalidate(\n\t\t\t\ttitleMap, startTimeJCalendar, endTimeJCalendar, untilJCalendar);\n\t\t}\n\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartTime(startTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndTime(endTimeJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\t\tcalendarBooking.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\tCalendarActivityKeys.UPDATE_CALENDAR_BOOKING,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\t// Notifications\n\n\t\tsendNotification(\n\t\t\tcalendarBooking, NotificationTemplateType.UPDATE, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tcalendarBooking.getCompanyId(), calendarBooking.getGroupId(),\n\t\t\tuserId, CalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(), calendarBooking,\n\t\t\tserviceContext);\n\n\t\treturn calendarBooking;\n\t}","commit_id":"f7952910234be9d8fb73351f8e2789f0a87b429c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected boolean isSessionErrorException(Throwable cause) {\n\t\tif (cause instanceof CalendarBookingDurationException ||\n\t\t\tcause instanceof CalendarNameException ||\n\t\t\tcause instanceof CalendarResourceCodeException ||\n\t\t\tcause instanceof CalendarResourceNameException ||\n\t\t\tcause instanceof DuplicateCalendarResourceException ||\n\t\t\tcause instanceof PrincipalException) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":81224,"modified_method":"@Override\n\tprotected boolean isSessionErrorException(Throwable cause) {\n\t\tif (cause instanceof CalendarBookingDurationException ||\n\t\t\tcause instanceof CalendarBookingRecurrenceException ||\n\t\t\tcause instanceof CalendarNameException ||\n\t\t\tcause instanceof CalendarResourceCodeException ||\n\t\t\tcause instanceof CalendarResourceNameException ||\n\t\t\tcause instanceof DuplicateCalendarResourceException ||\n\t\t\tcause instanceof PrincipalException) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"f7952910234be9d8fb73351f8e2789f0a87b429c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, file);\n\n\t\tstore.addFile(companyId, repositoryId, fileName, file);\n\t}","id":81225,"modified_method":"public void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, file);\n\n\t\tAntiVirusScannerUtil.scan(file);\n\n\t\tstore.addFile(companyId, repositoryId, fileName, file);\n\t}","commit_id":"9512ec6bd3c44f15d1bf3857b99a193609d7bb66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString fileExtension, boolean validateFileExtension,\n\t\t\tString versionNumber, String sourceFileName, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(\n\t\t\tfileName, fileExtension, sourceFileName, validateFileExtension, is);\n\n\t\tstore.updateFile(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber, sourceFileName,\n\t\t\tis);\n\t}","id":81226,"modified_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString fileExtension, boolean validateFileExtension,\n\t\t\tString versionNumber, String sourceFileName, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(\n\t\t\tfileName, fileExtension, sourceFileName,\n\t\t\tvalidateFileExtension, is);\n\n\t\tif (!AntiVirusScannerUtil.isActive()) {\n\t\t\tstore.updateFile(\n\t\t\t\tcompanyId, repositoryId, fileName, versionNumber,\n\t\t\t\tsourceFileName, is);\n\t\t}\n\t\telse {\n\t\t\tFile tempFile = null;\n\n\t\t\ttry {\n\t\t\t\tif (is.markSupported()) {\n\t\t\t\t\tis.mark(is.available() + 1);\n\n\t\t\t\t\tAntiVirusScannerUtil.scan(is);\n\n\t\t\t\t\tis.reset();\n\n\t\t\t\t\tstore.updateFile(\n\t\t\t\t\t\tcompanyId, repositoryId, fileName, versionNumber,\n\t\t\t\t\t\tsourceFileName, is);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttempFile = FileUtil.createTempFile();\n\n\t\t\t\t\tFileUtil.write(tempFile, is);\n\n\t\t\t\t\tAntiVirusScannerUtil.scan(tempFile);\n\n\t\t\t\t\tstore.updateFile(\n\t\t\t\t\t\tcompanyId, repositoryId, fileName, versionNumber,\n\t\t\t\t\t\tsourceFileName, tempFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new SystemException(\"Unable to process file: \" + fileName, e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (tempFile != null) {\n\t\t\t\t\ttempFile.delete();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"9512ec6bd3c44f15d1bf3857b99a193609d7bb66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber, String sourceFileName, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, bytes);\n\n\t\tstore.updateFile(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber, sourceFileName,\n\t\t\tbytes);\n\t}","id":81227,"modified_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber, String sourceFileName, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, bytes);\n\n\t\tAntiVirusScannerUtil.scan(bytes);\n\n\t\tstore.updateFile(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber, sourceFileName,\n\t\t\tbytes);\n\t}","commit_id":"9512ec6bd3c44f15d1bf3857b99a193609d7bb66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, bytes);\n\n\t\tstore.addFile(companyId, repositoryId, fileName, bytes);\n\t}","id":81228,"modified_method":"public void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, bytes);\n\n\t\tAntiVirusScannerUtil.scan(bytes);\n\n\t\tstore.addFile(companyId, repositoryId, fileName, bytes);\n\t}","commit_id":"9512ec6bd3c44f15d1bf3857b99a193609d7bb66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber, String sourceFileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, file);\n\n\t\tstore.updateFile(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber, sourceFileName,\n\t\t\tfile);\n\t}","id":81229,"modified_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber, String sourceFileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, true, file);\n\n\t\tAntiVirusScannerUtil.scan(file);\n\n\t\tstore.updateFile(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber, sourceFileName,\n\t\t\tfile);\n\t}","commit_id":"9512ec6bd3c44f15d1bf3857b99a193609d7bb66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tboolean validateFileExtension, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, validateFileExtension, is);\n\n\t\tstore.addFile(companyId, repositoryId, fileName, is);\n\t}","id":81230,"modified_method":"public void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tboolean validateFileExtension, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(fileName, validateFileExtension, is);\n\n\t\tif (!AntiVirusScannerUtil.isActive()) {\n\t\t\tstore.addFile(companyId, repositoryId, fileName, is);\n\t\t}\n\t\telse {\n\t\t\tFile tempFile = null;\n\n\t\t\ttry {\n\t\t\t\tif (is.markSupported()) {\n\t\t\t\t\tis.mark(is.available() + 1);\n\n\t\t\t\t\tAntiVirusScannerUtil.scan(is);\n\n\t\t\t\t\tis.reset();\n\n\t\t\t\t\tstore.addFile(companyId, repositoryId, fileName, is);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttempFile = FileUtil.createTempFile();\n\n\t\t\t\t\tFileUtil.write(tempFile, is);\n\n\t\t\t\t\tAntiVirusScannerUtil.scan(tempFile);\n\n\t\t\t\t\tstore.addFile(companyId, repositoryId, fileName, tempFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new SystemException(\"Unable to process file: \" + fileName, e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (tempFile != null) {\n\t\t\t\t\ttempFile.delete();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"9512ec6bd3c44f15d1bf3857b99a193609d7bb66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void persistOutgoing(SourceSequence seq, RMMessage msg) {\n        verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            updateSourceSequence(seq);\n            \n            if (msg != null && msg.getCachedOutputStream() != null) {\n                storeMessage(seq.getIdentifier(), msg, true);\n            }\n            \n            commit();\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort();\n            throw new RMStoreException(ex);\n        } catch (IOException ex) {\n            abort();\n            throw new RMStoreException(ex);        \n        } finally {\n            updateConnectionState(conex);\n        }        \n    }","id":81231,"modified_method":"public void persistOutgoing(SourceSequence seq, RMMessage msg) {\n        Connection con = verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            updateSourceSequence(con, seq);\n            \n            if (msg != null && msg.getCachedOutputStream() != null) {\n                storeMessage(con, seq.getIdentifier(), msg, true);\n            }\n            \n            commit(con);\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort(con);\n            throw new RMStoreException(ex);\n        } catch (IOException ex) {\n            abort(con);\n            throw new RMStoreException(ex);        \n        } finally {\n            updateConnectionState(con, conex);\n        }        \n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void verifyTable(String tableName, String[][] tableCols) {\n        try {\n            DatabaseMetaData metadata = connection.getMetaData();\n            ResultSet rs = metadata.getColumns(null, null, tableName, \"%\");\n            Set<String> dbCols = new HashSet<String>();\n            List<String[]> newCols = new ArrayList<String[]>(); \n            while (rs.next()) {\n                dbCols.add(rs.getString(4));\n            }\n            for (String[] col : tableCols) {\n                if (!dbCols.contains(col[0])) {\n                    newCols.add(col);\n                }\n            }\n            if (newCols.size() > 0) {\n                // need to add the new columns\n                if (LOG.isLoggable(Level.FINE)) {\n                    LOG.log(Level.FINE, \"Table \" + tableName + \" needs additional columns\");\n                }\n                \n                for (String[] newCol : newCols) {\n                    Statement st = connection.createStatement();\n                    try {\n                        st.executeUpdate(MessageFormat.format(ALTER_TABLE_STMT_STR, \n                                                              tableName, newCol[0], newCol[1]));\n                        if (LOG.isLoggable(Level.FINE)) {\n                            LOG.log(Level.FINE, \"Successfully added column {0} to table {1}\",\n                                    new Object[] {tableName, newCol[0]});\n                        }\n                    } finally {\n                        st.close();\n                    }\n                }\n            }\n            \n        } catch (SQLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.fine(\"Table \" + tableName + \" cannot be verified.\");\n            }\n        }\n    }","id":81232,"modified_method":"protected void verifyTable(String tableName, String[][] tableCols) {\n        verifyTable(connection, tableName, tableCols);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void beginTransaction() {\n        // avoid sharing of statements and result sets\n        writeLock.lock();\n    }","id":81233,"modified_method":"protected void beginTransaction() {\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public void createSourceSequence(SourceSequence seq) {\n        String sequenceIdentifier = seq.getIdentifier().getValue();\n        String endpointIdentifier = seq.getEndpointIdentifier();\n        String protocolVersion = encodeProtocolVersion(seq.getProtocol());\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Creating source sequence: \" + sequenceIdentifier + \", (endpoint: \"\n                     + endpointIdentifier + \")\"); \n        }\n        verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            createSrcSequenceStmt.setString(1, sequenceIdentifier);\n            Date expiry = seq.getExpires();\n            createSrcSequenceStmt.setLong(2, expiry == null ? 0 : expiry.getTime());\n            Identifier osid = seq.getOfferingSequenceIdentifier();\n            createSrcSequenceStmt.setString(3, osid == null ? null : osid.getValue());\n            createSrcSequenceStmt.setString(4, endpointIdentifier);\n            createSrcSequenceStmt.setString(5, protocolVersion);\n            createSrcSequenceStmt.execute();    \n            \n            commit();\n        } catch (SQLException ex) {\n            conex = ex;\n            abort();\n            throw new RMStoreException(ex);\n        } finally {\n            updateConnectionState(conex);\n        }\n    }","id":81234,"modified_method":"public void createSourceSequence(SourceSequence seq) {\n        String sequenceIdentifier = seq.getIdentifier().getValue();\n        String endpointIdentifier = seq.getEndpointIdentifier();\n        String protocolVersion = encodeProtocolVersion(seq.getProtocol());\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Creating source sequence: \" + sequenceIdentifier + \", (endpoint: \"\n                     + endpointIdentifier + \")\"); \n        }\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            stmt = getStatement(con, CREATE_SRC_SEQUENCE_STMT_STR);\n            \n            stmt.setString(1, sequenceIdentifier);\n            Date expiry = seq.getExpires();\n            stmt.setLong(2, expiry == null ? 0 : expiry.getTime());\n            Identifier osid = seq.getOfferingSequenceIdentifier();\n            stmt.setString(3, osid == null ? null : osid.getValue());\n            stmt.setString(4, endpointIdentifier);\n            stmt.setString(5, protocolVersion);\n            stmt.execute();    \n            \n            commit(con);\n        } catch (SQLException ex) {\n            conex = ex;\n            abort(con);\n            throw new RMStoreException(ex);\n        } finally {\n            releaseResources(stmt, null);\n            updateConnectionState(con, conex);\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void commit() throws SQLException {\n        try {\n            connection.commit();\n        } finally {\n            writeLock.unlock();\n        }\n    }","id":81235,"modified_method":"/**\n     * This method assumes that the connection is held and reused.\n     * Otherwise, use commit(Connection con)\n     */\n    protected void commit() throws SQLException {\n        commit(connection);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public void persistIncoming(DestinationSequence seq, RMMessage msg) {        \n        verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            updateDestinationSequence(seq);\n            \n            if (msg != null && msg.getCachedOutputStream() != null) {\n                storeMessage(seq.getIdentifier(), msg, false);\n            }\n            \n            commit();\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort();\n            throw new RMStoreException(ex);\n        } catch (IOException ex) {\n            abort();\n            throw new RMStoreException(ex);        \n        } finally {\n            updateConnectionState(conex);\n        }\n    }","id":81236,"modified_method":"public void persistIncoming(DestinationSequence seq, RMMessage msg) {        \n        Connection con = verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            updateDestinationSequence(con, seq);\n            \n            if (msg != null && msg.getCachedOutputStream() != null) {\n                storeMessage(con, seq.getIdentifier(), msg, false);\n            }\n            \n            commit(con);\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort(con);\n            throw new RMStoreException(ex);\n        } catch (IOException ex) {\n            abort(con);\n            throw new RMStoreException(ex);        \n        } finally {\n            updateConnectionState(con, conex);\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"private void createStatements() throws SQLException {\n        // create the statements in advance to avoid synchronization later \n        createDestSequenceStmt = connection.prepareStatement(CREATE_DEST_SEQUENCE_STMT_STR);\n        createSrcSequenceStmt = connection.prepareStatement(CREATE_SRC_SEQUENCE_STMT_STR);\n        deleteDestSequenceStmt = connection.prepareStatement(DELETE_DEST_SEQUENCE_STMT_STR);\n        deleteSrcSequenceStmt = connection.prepareStatement(DELETE_SRC_SEQUENCE_STMT_STR);\n        updateDestSequenceStmt = connection.prepareStatement(UPDATE_DEST_SEQUENCE_STMT_STR);\n        updateSrcSequenceStmt = connection.prepareStatement(UPDATE_SRC_SEQUENCE_STMT_STR);\n        selectDestSequencesStmt = connection.prepareStatement(SELECT_DEST_SEQUENCES_STMT_STR);\n        selectSrcSequencesStmt = connection.prepareStatement(SELECT_SRC_SEQUENCES_STMT_STR);\n        selectDestSequenceStmt = connection.prepareStatement(SELECT_DEST_SEQUENCE_STMT_STR);\n        selectSrcSequenceStmt = connection.prepareStatement(SELECT_SRC_SEQUENCE_STMT_STR);\n        createInboundMessageStmt = connection.prepareStatement(\n            MessageFormat.format(CREATE_MESSAGE_STMT_STR, INBOUND_MSGS_TABLE_NAME));\n        createOutboundMessageStmt = connection.prepareStatement(\n            MessageFormat.format(CREATE_MESSAGE_STMT_STR, OUTBOUND_MSGS_TABLE_NAME));\n        deleteInboundMessageStmt = connection.prepareStatement(\n            MessageFormat.format(DELETE_MESSAGE_STMT_STR, INBOUND_MSGS_TABLE_NAME));\n        deleteOutboundMessageStmt = connection.prepareStatement(\n            MessageFormat.format(DELETE_MESSAGE_STMT_STR, OUTBOUND_MSGS_TABLE_NAME));\n        selectInboundMessagesStmt = connection.prepareStatement(\n            MessageFormat.format(SELECT_MESSAGES_STMT_STR, INBOUND_MSGS_TABLE_NAME));\n        selectOutboundMessagesStmt = connection.prepareStatement(\n            MessageFormat.format(SELECT_MESSAGES_STMT_STR, OUTBOUND_MSGS_TABLE_NAME));\n    }","id":81237,"modified_method":"private void cacheStatements() throws SQLException {\n        if (connection == null) {\n            // if the connection is not held, no statement is cached.\n            return;\n        }\n        // create a statement specific lock table\n        statementLocks = new HashMap<Statement, Lock>();\n        cachedStatements = new HashMap<String, PreparedStatement>();\n        \n        // create the statements in advance if the connection is to be kept \n        cacheStatement(connection, CREATE_DEST_SEQUENCE_STMT_STR);\n        cacheStatement(connection, CREATE_SRC_SEQUENCE_STMT_STR);\n        cacheStatement(connection, DELETE_DEST_SEQUENCE_STMT_STR);\n        cacheStatement(connection, DELETE_SRC_SEQUENCE_STMT_STR);\n        cacheStatement(connection, UPDATE_DEST_SEQUENCE_STMT_STR);\n        cacheStatement(connection, UPDATE_SRC_SEQUENCE_STMT_STR);\n        cacheStatement(connection, SELECT_DEST_SEQUENCES_STMT_STR);\n        cacheStatement(connection, SELECT_SRC_SEQUENCES_STMT_STR);\n        cacheStatement(connection, SELECT_DEST_SEQUENCE_STMT_STR);\n        cacheStatement(connection, SELECT_SRC_SEQUENCE_STMT_STR);\n        cacheStatement(connection, CREATE_INBOUND_MESSAGE_STMT_STR);\n        cacheStatement(connection, CREATE_OUTBOUND_MESSAGE_STMT_STR);\n        cacheStatement(connection, DELETE_INBOUND_MESSAGE_STMT_STR);\n        cacheStatement(connection, DELETE_OUTBOUND_MESSAGE_STMT_STR);\n        cacheStatement(connection, SELECT_INBOUND_MESSAGES_STMT_STR);\n        cacheStatement(connection, SELECT_OUTBOUND_MESSAGES_STMT_STR);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public void removeMessages(Identifier sid, Collection<Long> messageNrs, boolean outbound) {\n        verifyConnection();\n        SQLException conex = null;\n        try {\n            PreparedStatement stmt = outbound ? deleteOutboundMessageStmt : deleteInboundMessageStmt;\n            beginTransaction();\n\n            stmt.setString(1, sid.getValue());\n                        \n            for (Long messageNr : messageNrs) {\n                stmt.setLong(2, messageNr);\n                stmt.execute();\n            }\n            \n            commit();\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort();\n            throw new RMStoreException(ex);\n        } finally {\n            updateConnectionState(conex);\n        }\n    }","id":81238,"modified_method":"public void removeMessages(Identifier sid, Collection<Long> messageNrs, boolean outbound) {\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        try {\n            stmt = getStatement(con, outbound ? DELETE_OUTBOUND_MESSAGE_STMT_STR : DELETE_INBOUND_MESSAGE_STMT_STR);\n\n            beginTransaction();\n\n            stmt.setString(1, sid.getValue());\n                        \n            for (Long messageNr : messageNrs) {\n                stmt.setLong(2, messageNr);\n                stmt.execute();\n            }\n            \n            commit(con);\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort(con);\n            throw new RMStoreException(ex);\n        } finally {\n            releaseResources(stmt, null);\n            updateConnectionState(con, conex);\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public Collection<DestinationSequence> getDestinationSequences(String endpointIdentifier) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting destination sequences for endpoint: \" + endpointIdentifier);\n        }\n        verifyConnection();\n        SQLException conex = null;\n        Collection<DestinationSequence> seqs = new ArrayList<DestinationSequence>();\n        ResultSet res = null;\n        try {\n            synchronized (selectDestSequencesStmt) {\n                selectDestSequencesStmt.setString(1, endpointIdentifier);\n                res = selectDestSequencesStmt.executeQuery(); \n                while (res.next()) {\n                    Identifier sid = new Identifier();                \n                    sid.setValue(res.getString(1));\n                    EndpointReferenceType acksTo = RMUtils.createReference(res.getString(2));  \n                    long lm = res.getLong(3);\n                    ProtocolVariation pv = decodeProtocolVersion(res.getString(4));\n                    InputStream is = res.getBinaryStream(5);\n                    SequenceAcknowledgement ack = null;\n                    if (null != is) {\n                        ack = PersistenceUtils.getInstance()\n                            .deserialiseAcknowledgment(is); \n                    }\n                    DestinationSequence seq = new DestinationSequence(sid, acksTo, lm, ack, pv);\n                    seqs.add(seq);                                                 \n                }\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            LOG.log(Level.WARNING, new Message(\"SELECT_DEST_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            if (res != null) {\n                try {\n                    res.close();\n                } catch (SQLException e) {\n                    // ignore\n                }\n            }\n            updateConnectionState(conex);\n        } \n        return seqs;\n    }","id":81239,"modified_method":"public Collection<DestinationSequence> getDestinationSequences(String endpointIdentifier) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting destination sequences for endpoint: \" + endpointIdentifier);\n        }\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        Collection<DestinationSequence> seqs = new ArrayList<DestinationSequence>();\n        ResultSet res = null;\n        try {\n            stmt = getStatement(con, SELECT_DEST_SEQUENCES_STMT_STR);\n\n            stmt.setString(1, endpointIdentifier);\n            res = stmt.executeQuery(); \n            while (res.next()) {\n                Identifier sid = new Identifier();                \n                sid.setValue(res.getString(1));\n                EndpointReferenceType acksTo = RMUtils.createReference(res.getString(2));  \n                long lm = res.getLong(3);\n                ProtocolVariation pv = decodeProtocolVersion(res.getString(4));\n                InputStream is = res.getBinaryStream(5);\n                SequenceAcknowledgement ack = null;\n                if (null != is) {\n                    ack = PersistenceUtils.getInstance()\n                        .deserialiseAcknowledgment(is); \n                }\n                DestinationSequence seq = new DestinationSequence(sid, acksTo, lm, ack, pv);\n                seqs.add(seq);                                                 \n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            LOG.log(Level.WARNING, new Message(\"SELECT_DEST_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            releaseResources(stmt, res);\n            updateConnectionState(con, conex);\n        } \n        return seqs;\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public void removeDestinationSequence(Identifier sid) {\n        verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            deleteDestSequenceStmt.setString(1, sid.getValue());\n            deleteDestSequenceStmt.execute();\n            \n            commit();\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort();\n            throw new RMStoreException(ex);\n        } finally {\n            updateConnectionState(conex);\n        }\n    }","id":81240,"modified_method":"public void removeDestinationSequence(Identifier sid) {\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            stmt = getStatement(con, DELETE_DEST_SEQUENCE_STMT_STR);\n\n            stmt.setString(1, sid.getValue());\n            stmt.execute();\n            \n            commit(con);\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort(con);\n            throw new RMStoreException(ex);\n        } finally {\n            releaseResources(stmt, null);\n            updateConnectionState(con, conex);\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public DestinationSequence getDestinationSequence(Identifier sid) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting destination sequence for id: \" + sid);\n        }\n        verifyConnection();\n        SQLException conex = null;\n        ResultSet res = null;\n        try {\n            synchronized (selectDestSequenceStmt) {\n                selectDestSequenceStmt.setString(1, sid.getValue());\n                res = selectDestSequenceStmt.executeQuery();\n            \n                if (res.next()) {\n                    EndpointReferenceType acksTo = RMUtils.createReference(res.getString(1));  \n                    long lm = res.getLong(2);\n                    ProtocolVariation pv = decodeProtocolVersion(res.getString(3));\n                    InputStream is = res.getBinaryStream(4);\n                    SequenceAcknowledgement ack = null;\n                    if (null != is) {\n                        ack = PersistenceUtils.getInstance()\n                            .deserialiseAcknowledgment(is); \n                    }\n                    return new DestinationSequence(sid, acksTo, lm, ack, pv);\n                }\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            LOG.log(Level.WARNING, new Message(\"SELECT_DEST_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            if (res != null) {\n                try {\n                    res.close();\n                } catch (SQLException e) {\n                    // ignore\n                }\n            }\n            updateConnectionState(conex);\n        }\n        return null;\n    }","id":81241,"modified_method":"public DestinationSequence getDestinationSequence(Identifier sid) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting destination sequence for id: \" + sid);\n        }\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        ResultSet res = null;\n        try {\n            stmt = getStatement(con, SELECT_DEST_SEQUENCE_STMT_STR);\n\n            stmt.setString(1, sid.getValue());\n            res = stmt.executeQuery();\n            \n            if (res.next()) {\n                EndpointReferenceType acksTo = RMUtils.createReference(res.getString(1));  \n                long lm = res.getLong(2);\n                ProtocolVariation pv = decodeProtocolVersion(res.getString(3));\n                InputStream is = res.getBinaryStream(4);\n                SequenceAcknowledgement ack = null;\n                if (null != is) {\n                    ack = PersistenceUtils.getInstance()\n                        .deserialiseAcknowledgment(is); \n                }\n                return new DestinationSequence(sid, acksTo, lm, ack, pv);\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            LOG.log(Level.WARNING, new Message(\"SELECT_DEST_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            releaseResources(stmt, res);\n            updateConnectionState(con, conex);\n        }\n        return null;\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void setCurrentSchema() throws SQLException {\n        if (schemaName == null || connection == null) {\n            return;\n        }\n        \n        Statement stmt = connection.createStatement();\n        // schemaName has been verified at setSchemaName(String)\n        try {\n            stmt.executeUpdate(MessageFormat.format(CREATE_SCHEMA_STMT_STR, \n                                                    schemaName));\n        } catch (SQLException ex) {\n            // assume it is already created or no authorization is provided (create one manually)\n        } finally {\n            stmt.close();\n        }\n        stmt = connection.createStatement();\n        SQLException ex0 = null;\n        for (int i = 0; i < SET_SCHEMA_STMT_STRS.length; i++) {\n            try {\n                stmt.executeUpdate(MessageFormat.format(SET_SCHEMA_STMT_STRS[i], schemaName));\n                break;\n            } catch (SQLException ex) {\n                ex.setNextException(ex0);\n                ex0 = ex;\n                if (i == SET_SCHEMA_STMT_STRS.length - 1) {\n                    throw ex0;\n                }\n                // continue\n            } finally {\n                // close the statement after its last use\n                if (ex0 == null || i == SET_SCHEMA_STMT_STRS.length - 1) {\n                    stmt.close();\n                }\n            }\n        }\n    }","id":81242,"modified_method":"/**\n     * Sets the current schema associated with the connection.\n     * If the connection is not set (e.g., keepConnection is false, it has no effect.\n     * @throws SQLException\n     */\n    protected void setCurrentSchema() throws SQLException {\n        if (schemaName == null || connection == null) {\n            return;\n        }\n        \n        Statement stmt = connection.createStatement();\n        // schemaName has been verified at setSchemaName(String)\n        try {\n            stmt.executeUpdate(MessageFormat.format(CREATE_SCHEMA_STMT_STR, \n                                                    schemaName));\n        } catch (SQLException ex) {\n            // assume it is already created or no authorization is provided (create one manually)\n        } finally {\n            stmt.close();\n        }\n        stmt = connection.createStatement();\n        SQLException ex0 = null;\n        for (int i = 0; i < SET_SCHEMA_STMT_STRS.length; i++) {\n            try {\n                stmt.executeUpdate(MessageFormat.format(SET_SCHEMA_STMT_STRS[i], schemaName));\n                break;\n            } catch (SQLException ex) {\n                ex.setNextException(ex0);\n                ex0 = ex;\n                if (i == SET_SCHEMA_STMT_STRS.length - 1) {\n                    throw ex0;\n                }\n                // continue\n            } finally {\n                // close the statement after its last use\n                if (ex0 == null || i == SET_SCHEMA_STMT_STRS.length - 1) {\n                    stmt.close();\n                }\n            }\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected synchronized void updateConnectionState(SQLException e) {\n        if (e == null) {\n            // reset the previous error status\n            reconnectDelay = 0;\n            reconnectAttempts = 0;\n            nextReconnectAttempt = 0;\n        } else if (createdConnection && isRecoverableError(e)) {\n            // update the next reconnect schedule \n            if (reconnectDelay == 0) {\n                reconnectDelay = initialReconnectDelay;\n            }\n            if (nextReconnectAttempt < System.currentTimeMillis()) {\n                nextReconnectAttempt = System.currentTimeMillis() + reconnectDelay;\n                reconnectDelay = reconnectDelay * useExponentialBackOff;\n            }\n        }\n    }","id":81243,"modified_method":"protected void updateConnectionState(Connection con, SQLException e) {\n        if (connection == null) {\n            // close the locally created connection\n            try {\n                con.close();\n            } catch (SQLException ex) {\n                // ignore\n            }\n        } else {\n            synchronized (this) {\n                // update the status of the cached connection\n                if (e == null) {\n                    // reset the previous error status\n                    reconnectDelay = 0;\n                    reconnectAttempts = 0;\n                    nextReconnectAttempt = 0;\n                } else if (createdConnection && isRecoverableError(e)) {\n                    // update the next reconnect schedule \n                    if (reconnectDelay == 0) {\n                        reconnectDelay = initialReconnectDelay;\n                    }\n                    if (nextReconnectAttempt < System.currentTimeMillis()) {\n                        nextReconnectAttempt = System.currentTimeMillis() + reconnectDelay;\n                        reconnectDelay = reconnectDelay * useExponentialBackOff;\n                    }\n                }\n            }\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public SourceSequence getSourceSequence(Identifier sid) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting source sequences for id: \" + sid);\n        }\n        verifyConnection();\n        SQLException conex = null;\n        ResultSet res = null;\n        try {\n            synchronized (selectSrcSequenceStmt) {\n                selectSrcSequenceStmt.setString(1, sid.getValue());\n                res = selectSrcSequenceStmt.executeQuery();\n            \n                if (res.next()) {\n                    long cmn = res.getLong(1);\n                    boolean lm = res.getBoolean(2);\n                    long lval = res.getLong(3);\n                    Date expiry = 0 == lval ? null : new Date(lval);\n                    String oidValue = res.getString(4);\n                    Identifier oi = null;\n                    if (null != oidValue) {\n                        oi = RMUtils.getWSRMFactory().createIdentifier();\n                        oi.setValue(oidValue);\n                    }\n                    ProtocolVariation pv = decodeProtocolVersion(res.getString(5));\n                    return new SourceSequence(sid, expiry, oi, cmn, lm, pv);\n                }\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            // ignore\n            LOG.log(Level.WARNING, new Message(\"SELECT_SRC_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            if (res != null) {\n                try {\n                    res.close();\n                } catch (SQLException e) {\n                    // ignore\n                }\n            }\n            updateConnectionState(conex);\n        } \n        return null;\n    }","id":81244,"modified_method":"public SourceSequence getSourceSequence(Identifier sid) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting source sequences for id: \" + sid);\n        }\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        ResultSet res = null;\n        try {\n            stmt = getStatement(con, SELECT_SRC_SEQUENCE_STMT_STR);\n\n            stmt.setString(1, sid.getValue());\n            res = stmt.executeQuery();\n            \n            if (res.next()) {\n                long cmn = res.getLong(1);\n                boolean lm = res.getBoolean(2);\n                long lval = res.getLong(3);\n                Date expiry = 0 == lval ? null : new Date(lval);\n                String oidValue = res.getString(4);\n                Identifier oi = null;\n                if (null != oidValue) {\n                    oi = RMUtils.getWSRMFactory().createIdentifier();\n                    oi.setValue(oidValue);\n                }\n                ProtocolVariation pv = decodeProtocolVersion(res.getString(5));\n                return new SourceSequence(sid, expiry, oi, cmn, lm, pv);\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            // ignore\n            LOG.log(Level.WARNING, new Message(\"SELECT_SRC_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            releaseResources(stmt, res);\n            updateConnectionState(con, conex);\n        } \n        return null;\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public Collection<SourceSequence> getSourceSequences(String endpointIdentifier) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting source sequences for endpoint: \" + endpointIdentifier);\n        }\n        verifyConnection();\n        SQLException conex = null;\n        Collection<SourceSequence> seqs = new ArrayList<SourceSequence>();\n        ResultSet res = null;\n        try {\n            synchronized (selectSrcSequencesStmt) {\n                selectSrcSequencesStmt.setString(1, endpointIdentifier);\n                res = selectSrcSequencesStmt.executeQuery();\n                while (res.next()) {\n                    Identifier sid = new Identifier();\n                    sid.setValue(res.getString(1));\n                    long cmn = res.getLong(2);\n                    boolean lm = res.getBoolean(3);\n                    long lval = res.getLong(4);\n                    Date expiry = 0 == lval ? null : new Date(lval);\n                    String oidValue = res.getString(5);\n                    Identifier oi = null;\n                    if (null != oidValue) {\n                        oi = new Identifier();\n                        oi.setValue(oidValue);\n                    }\n                    ProtocolVariation pv = decodeProtocolVersion(res.getString(6));\n                    SourceSequence seq = new SourceSequence(sid, expiry, oi, cmn, lm, pv);\n                    seqs.add(seq);                          \n                }\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            // ignore\n            LOG.log(Level.WARNING, new Message(\"SELECT_SRC_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            if (res != null) {\n                try {\n                    res.close();\n                } catch (SQLException e) {\n                    // ignore\n                }\n            }\n            updateConnectionState(conex);\n        } \n        return seqs;\n    }","id":81245,"modified_method":"public Collection<SourceSequence> getSourceSequences(String endpointIdentifier) {\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Getting source sequences for endpoint: \" + endpointIdentifier);\n        }\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        Collection<SourceSequence> seqs = new ArrayList<SourceSequence>();\n        ResultSet res = null;\n        try {\n            stmt = getStatement(con, SELECT_SRC_SEQUENCES_STMT_STR);\n            \n            stmt.setString(1, endpointIdentifier);\n            res = stmt.executeQuery();\n            while (res.next()) {\n                Identifier sid = new Identifier();\n                sid.setValue(res.getString(1));\n                long cmn = res.getLong(2);\n                boolean lm = res.getBoolean(3);\n                long lval = res.getLong(4);\n                Date expiry = 0 == lval ? null : new Date(lval);\n                String oidValue = res.getString(5);\n                Identifier oi = null;\n                if (null != oidValue) {\n                    oi = new Identifier();\n                    oi.setValue(oidValue);\n                }\n                ProtocolVariation pv = decodeProtocolVersion(res.getString(6));\n                SourceSequence seq = new SourceSequence(sid, expiry, oi, cmn, lm, pv);\n                seqs.add(seq);                          \n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            // ignore\n            LOG.log(Level.WARNING, new Message(\"SELECT_SRC_SEQ_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            releaseResources(stmt, res);\n            updateConnectionState(con, conex);\n        } \n        return seqs;\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void abort() {\n        try {\n            connection.rollback(); \n        } catch (SQLException ex) {\n            LogUtils.log(LOG, Level.SEVERE, \"ABORT_FAILED_MSG\", ex);\n        } finally {\n            writeLock.unlock();\n        }\n    }","id":81246,"modified_method":"protected void abort() {\n        abort(connection);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public synchronized void init() {\n        if (null == connection) {\n            LOG.log(Level.FINE, \"Using derby.system.home: {0}\", \n                    SystemPropertyAction.getProperty(\"derby.system.home\"));\n            if (null != dataSource) {\n                try {\n                    LOG.log(Level.FINE, \"Using dataSource: \" + dataSource);\n                    connection = dataSource.getConnection();\n                } catch (SQLException ex) {\n                    LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", ex);\n                    return;\n                }\n            } else {\n                assert null != url;\n                assert null != driverClassName;\n                try {\n                    Class.forName(driverClassName);\n                } catch (ClassNotFoundException ex) {\n                    LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", ex);\n                    return;\n                }\n    \n                try {\n                    LOG.log(Level.FINE, \"Using url: \" + url);\n                    connection = DriverManager.getConnection(url, userName, password);\n                } catch (SQLException ex) {\n                    LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", ex);\n                    return;\n                }\n            }\n        }\n        \n        try {\n            connection.setAutoCommit(true);\n            setCurrentSchema();\n            createTables();\n            createStatements();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", ex);\n            SQLException se = ex;\n            while (se.getNextException() != null) {\n                se = se.getNextException();\n                LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", se);\n            }\n            throw new RMStoreException(ex);\n        } catch (Throwable ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                connection.setAutoCommit(false);                \n            } catch (SQLException ex) {\n                LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", ex);\n                throw new RMStoreException(ex);\n            }\n        }\n    }","id":81247,"modified_method":"public synchronized void init() {\n        if (keepConnection && connection == null) {\n            connection = createConnection();\n        }\n        \n        try {\n            if (connection != null && schemaName != null) {\n                setCurrentSchema();\n            }\n            createTables();\n            if (connection != null) {\n                cacheStatements();\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", ex);\n            SQLException se = ex;\n            while (se.getNextException() != null) {\n                se = se.getNextException();\n                LogUtils.log(LOG, Level.SEVERE, \"CONNECT_EXC\", se);\n            }\n            throw new RMStoreException(ex);\n        } catch (Throwable ex) {\n            ex.printStackTrace();\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void storeMessage(Identifier sid, RMMessage msg, boolean outbound)         \n        throws IOException, SQLException {\n        String id = sid.getValue();\n        long nr = msg.getMessageNumber();\n        String to = msg.getTo();\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.log(Level.FINE, \"Storing {0} message number {1} for sequence {2}, to = {3}\",\n                    new Object[] {outbound ? \"outbound\" : \"inbound\", nr, id, to});\n        }\n        InputStream msgin = null;\n        try {\n            msgin = msg.getInputStream();\n            PreparedStatement stmt = outbound ? createOutboundMessageStmt : createInboundMessageStmt;\n            int i = 1;\n            stmt.setString(i++, id);  \n            stmt.setLong(i++, nr);\n            stmt.setString(i++, to); \n            stmt.setBinaryStream(i++, msgin, (int)msg.getSize());\n            stmt.execute();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Successfully stored {0} message number {1} for sequence {2}\",\n                        new Object[] {outbound ? \"outbound\" : \"inbound\", nr, id});\n            }\n        } finally  {\n            if (msgin != null) {\n                try {\n                    msgin.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n        \n    }","id":81248,"modified_method":"/**\n     * this method is only useful when keepConnection is set to true\n     */\n    protected void storeMessage(Identifier sid, RMMessage msg, boolean outbound)\n        throws IOException, SQLException {\n        storeMessage(connection, sid, msg, outbound);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public Collection<RMMessage> getMessages(Identifier sid, boolean outbound) {\n        verifyConnection();\n        SQLException conex = null;\n        Collection<RMMessage> msgs = new ArrayList<RMMessage>();\n        ResultSet res = null;\n        try {\n            PreparedStatement stmt = outbound ? selectOutboundMessagesStmt : selectInboundMessagesStmt;\n            synchronized (stmt) {\n                stmt.setString(1, sid.getValue());\n                res = stmt.executeQuery();\n                while (res.next()) {\n                    long mn = res.getLong(1);\n                    String to = res.getString(2);\n                    Blob blob = res.getBlob(3);\n                    RMMessage msg = new RMMessage();\n                    msg.setMessageNumber(mn);\n                    msg.setTo(to);\n                    msg.setContent(blob.getBinaryStream());\n                    msgs.add(msg);\n                }\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            LOG.log(Level.WARNING, new Message(outbound ? \"SELECT_OUTBOUND_MSGS_FAILED_MSG\"\n                : \"SELECT_INBOUND_MSGS_FAILED_MSG\", LOG).toString(), ex);\n        } catch (IOException ex) {\n            LOG.log(Level.WARNING, new Message(outbound ? \"SELECT_OUTBOUND_MSGS_FAILED_MSG\"\n                : \"SELECT_INBOUND_MSGS_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            if (res != null) {\n                try {\n                    res.close();\n                } catch (SQLException e) {\n                    // ignore\n                }\n            }\n            updateConnectionState(conex);\n        }\n        return msgs;\n    }","id":81249,"modified_method":"public Collection<RMMessage> getMessages(Identifier sid, boolean outbound) {\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        Collection<RMMessage> msgs = new ArrayList<RMMessage>();\n        ResultSet res = null;\n        try {\n            stmt = getStatement(con, outbound ? SELECT_OUTBOUND_MESSAGES_STMT_STR : SELECT_INBOUND_MESSAGES_STMT_STR);\n\n            stmt.setString(1, sid.getValue());\n            res = stmt.executeQuery();\n            while (res.next()) {\n                long mn = res.getLong(1);\n                String to = res.getString(2);\n                Blob blob = res.getBlob(3);\n                RMMessage msg = new RMMessage();\n                msg.setMessageNumber(mn);\n                msg.setTo(to);\n                msg.setContent(blob.getBinaryStream());\n                msgs.add(msg);\n            }\n        } catch (SQLException ex) {\n            conex = ex;\n            LOG.log(Level.WARNING, new Message(outbound ? \"SELECT_OUTBOUND_MSGS_FAILED_MSG\"\n                : \"SELECT_INBOUND_MSGS_FAILED_MSG\", LOG).toString(), ex);\n        } catch (IOException ex) {\n            LOG.log(Level.WARNING, new Message(outbound ? \"SELECT_OUTBOUND_MSGS_FAILED_MSG\"\n                : \"SELECT_INBOUND_MSGS_FAILED_MSG\", LOG).toString(), ex);\n        } finally {\n            releaseResources(stmt, res);\n            updateConnectionState(con, conex);\n        }\n        return msgs;\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateDestinationSequence(DestinationSequence seq) \n        throws SQLException, IOException {\n        synchronized (updateDestSequenceStmt) {\n            long lastMessageNr = seq.getLastMessageNumber();\n            updateDestSequenceStmt.setLong(1, lastMessageNr); \n            InputStream is = PersistenceUtils.getInstance()\n                .serialiseAcknowledgment(seq.getAcknowledgment());\n            updateDestSequenceStmt.setBinaryStream(2, is, is.available()); \n            updateDestSequenceStmt.setString(3, seq.getIdentifier() .getValue());\n            updateDestSequenceStmt.execute();\n        }\n    }","id":81250,"modified_method":"/**\n     * @throws IOException \n     * @throws SQLException\n     */\n    protected void updateDestinationSequence(DestinationSequence seq) \n        throws SQLException, IOException {\n        updateDestinationSequence(connection, seq);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected synchronized void verifyConnection() {\n        if (createdConnection && nextReconnectAttempt > 0\n            && (maxReconnectAttempts < 0 || maxReconnectAttempts > reconnectAttempts)) {\n            if (System.currentTimeMillis() > nextReconnectAttempt) {\n                // destroy the broken connection\n                destroy();\n                // try to reconnect\n                reconnectAttempts++;\n                init();\n                // reset the next reconnect attempt time\n                nextReconnectAttempt = 0;\n            } else {\n                LogUtils.log(LOG, Level.INFO, \"WAIT_RECONNECT_MSG\");\n            }\n        }\n    }","id":81251,"modified_method":"protected Connection verifyConnection() {\n        Connection con;\n        if (connection == null) {\n            // return a new connection\n            con = createConnection();\n        } else {\n            // return the cached connection or create and cache a new one if the old one is dead  \n            synchronized (this) {\n                if (createdConnection && nextReconnectAttempt > 0\n                    && (maxReconnectAttempts < 0 || maxReconnectAttempts > reconnectAttempts)) {\n                    if (System.currentTimeMillis() > nextReconnectAttempt) {\n                        // destroy the broken connection\n                        destroy();\n                        // try to reconnect\n                        reconnectAttempts++;\n                        init();\n                        // reset the next reconnect attempt time\n                        nextReconnectAttempt = 0;\n                    } else {\n                        LogUtils.log(LOG, Level.INFO, \"WAIT_RECONNECT_MSG\");\n                    }\n                }\n            }\n            con =  connection;\n        }\n        \n        return con;\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateSourceSequence(SourceSequence seq) \n        throws SQLException {\n        synchronized (updateSrcSequenceStmt) {\n            updateSrcSequenceStmt.setLong(1, seq.getCurrentMessageNr()); \n            updateSrcSequenceStmt.setString(2, seq.isLastMessage() ? \"1\" : \"0\"); \n            updateSrcSequenceStmt.setString(3, seq.getIdentifier().getValue());\n            updateSrcSequenceStmt.execute();\n        }\n    }","id":81252,"modified_method":"/**\n     * @throws SQLException \n     */\n    protected void updateSourceSequence(SourceSequence seq) throws SQLException  {\n        updateSourceSequence(connection, seq);\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public void removeSourceSequence(Identifier sid) {\n        verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            deleteSrcSequenceStmt.setString(1, sid.getValue());\n            deleteSrcSequenceStmt.execute();\n            \n            commit();\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort();\n            throw new RMStoreException(ex);\n        } finally {\n            updateConnectionState(conex);\n        }        \n    }","id":81253,"modified_method":"public void removeSourceSequence(Identifier sid) {\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            stmt = getStatement(con, DELETE_SRC_SEQUENCE_STMT_STR);\n\n            stmt.setString(1, sid.getValue());\n            stmt.execute();\n            \n            commit(con);\n            \n        } catch (SQLException ex) {\n            conex = ex;\n            abort(con);\n            throw new RMStoreException(ex);\n        } finally {\n            releaseResources(stmt, null);\n            updateConnectionState(con, conex);\n        }        \n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"public void createDestinationSequence(DestinationSequence seq) {\n        String sequenceIdentifier = seq.getIdentifier().getValue();\n        String endpointIdentifier = seq.getEndpointIdentifier();\n        String protocolVersion = encodeProtocolVersion(seq.getProtocol());\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Creating destination sequence: \" + sequenceIdentifier + \", (endpoint: \"\n                 + endpointIdentifier + \")\");\n        }\n        verifyConnection();\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            \n            createDestSequenceStmt.setString(1, sequenceIdentifier);\n            String addr = seq.getAcksTo().getAddress().getValue();\n            createDestSequenceStmt.setString(2, addr);\n            createDestSequenceStmt.setString(3, endpointIdentifier);\n            createDestSequenceStmt.setString(4, protocolVersion);\n            createDestSequenceStmt.execute();\n            \n            commit();\n        } catch (SQLException ex) {\n            abort();\n            conex = ex;\n            throw new RMStoreException(ex);\n        } finally {\n            updateConnectionState(conex);\n        }\n    }","id":81254,"modified_method":"public void createDestinationSequence(DestinationSequence seq) {\n        String sequenceIdentifier = seq.getIdentifier().getValue();\n        String endpointIdentifier = seq.getEndpointIdentifier();\n        String protocolVersion = encodeProtocolVersion(seq.getProtocol());\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.info(\"Creating destination sequence: \" + sequenceIdentifier + \", (endpoint: \"\n                 + endpointIdentifier + \")\");\n        }\n        Connection con = verifyConnection();\n        PreparedStatement stmt = null;\n        SQLException conex = null;\n        try {\n            beginTransaction();\n            stmt = getStatement(con, CREATE_DEST_SEQUENCE_STMT_STR); \n            \n            stmt.setString(1, sequenceIdentifier);\n            String addr = seq.getAcksTo().getAddress().getValue();\n            stmt.setString(2, addr);\n            stmt.setString(3, endpointIdentifier);\n            stmt.setString(4, protocolVersion);\n            stmt.execute();\n            \n            commit(con);\n        } catch (SQLException ex) {\n            abort(con);\n            conex = ex;\n            throw new RMStoreException(ex);\n        } finally {\n            releaseResources(stmt, null);\n            updateConnectionState(con, conex);\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"protected void createTables() throws SQLException {\n        \n        Statement stmt = null;\n        stmt = connection.createStatement();\n        try {\n            stmt.executeUpdate(CREATE_SRC_SEQUENCES_TABLE_STMT);\n        } catch (SQLException ex) {\n            if (!isTableExistsError(ex)) {\n                throw ex;\n            } else {\n                LOG.fine(\"Table CXF_RM_SRC_SEQUENCES already exists.\");\n                verifyTable(SRC_SEQUENCES_TABLE_NAME, SRC_SEQUENCES_TABLE_COLS);\n            }\n        } finally {\n            stmt.close();\n        }\n\n        stmt = connection.createStatement();\n        try {\n            stmt.executeUpdate(CREATE_DEST_SEQUENCES_TABLE_STMT);\n        } catch (SQLException ex) {\n            if (!isTableExistsError(ex)) {\n                throw ex;\n            } else {\n                LOG.fine(\"Table CXF_RM_DEST_SEQUENCES already exists.\");\n                verifyTable(DEST_SEQUENCES_TABLE_NAME, DEST_SEQUENCES_TABLE_COLS);        \n            }\n        } finally {\n            stmt.close();\n        }\n        \n        for (String tableName : new String[] {OUTBOUND_MSGS_TABLE_NAME, INBOUND_MSGS_TABLE_NAME}) {\n            stmt = connection.createStatement();\n            try {\n                stmt.executeUpdate(MessageFormat.format(CREATE_MESSAGES_TABLE_STMT, tableName));\n            } catch (SQLException ex) {\n                if (!isTableExistsError(ex)) {\n                    throw ex;\n                } else {\n                    if (LOG.isLoggable(Level.FINE)) {\n                        LOG.fine(\"Table \" + tableName + \" already exists.\");\n                    }\n                    verifyTable(tableName, MESSAGES_TABLE_COLS);\n                }\n            } finally {\n                stmt.close();\n            }\n        }\n    }","id":81255,"modified_method":"protected void createTables() throws SQLException {\n        Connection con = verifyConnection();\n        Statement stmt = null;\n        \n        try {\n            con.setAutoCommit(true);\n            stmt = con.createStatement();\n            try {\n                stmt.executeUpdate(CREATE_SRC_SEQUENCES_TABLE_STMT);\n            } catch (SQLException ex) {\n                if (!isTableExistsError(ex)) {\n                    throw ex;\n                } else {\n                    LOG.fine(\"Table CXF_RM_SRC_SEQUENCES already exists.\");\n                    verifyTable(con, SRC_SEQUENCES_TABLE_NAME, SRC_SEQUENCES_TABLE_COLS);\n                }\n            } finally {\n                stmt.close();\n            }\n\n            stmt = con.createStatement();\n            try {\n                stmt.executeUpdate(CREATE_DEST_SEQUENCES_TABLE_STMT);\n            } catch (SQLException ex) {\n                if (!isTableExistsError(ex)) {\n                    throw ex;\n                } else {\n                    LOG.fine(\"Table CXF_RM_DEST_SEQUENCES already exists.\");\n                    verifyTable(con, DEST_SEQUENCES_TABLE_NAME, DEST_SEQUENCES_TABLE_COLS);        \n                }\n            } finally {\n                stmt.close();\n            }\n\n            for (String tableName : new String[] {OUTBOUND_MSGS_TABLE_NAME, INBOUND_MSGS_TABLE_NAME}) {\n                stmt = con.createStatement();\n                try {\n                    stmt.executeUpdate(MessageFormat.format(CREATE_MESSAGES_TABLE_STMT, tableName));\n                } catch (SQLException ex) {\n                    if (!isTableExistsError(ex)) {\n                        throw ex;\n                    } else {\n                        if (LOG.isLoggable(Level.FINE)) {\n                            LOG.fine(\"Table \" + tableName + \" already exists.\");\n                        }\n                        verifyTable(con, tableName, MESSAGES_TABLE_COLS);\n                    }\n                } finally {\n                    stmt.close();\n                }\n            }\n        } finally {\n            if (connection == null) {\n                con.close();\n            }\n        }\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass \n    public static void setUpOnce() {\n        \n        RMTxStore.deleteDatabaseFiles();\n\n        store = new RMTxStore();\n        store.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n        store.init();\n        \n        ack1 = new SequenceAcknowledgement();\n        SequenceAcknowledgement.AcknowledgementRange range = \n            new SequenceAcknowledgement.AcknowledgementRange();\n        \n        range.setLower(ONE);\n        range.setUpper(ONE);\n        ack1.getAcknowledgementRange().add(range);\n        \n        ack2 = new SequenceAcknowledgement();\n        range = new SequenceAcknowledgement.AcknowledgementRange();\n        range.setLower(ONE);\n        range.setUpper(ONE);\n        ack2.getAcknowledgementRange().add(range);\n        range = new SequenceAcknowledgement.AcknowledgementRange();\n        range.setLower(new Long(3));\n        range.setUpper(TEN);\n        ack2.getAcknowledgementRange().add(range);\n    }","id":81256,"modified_method":"@BeforeClass \n    public static void setUpOnce() {\n        RMTxStoreTestBase.setUpOnce();\n        \n        RMTxStore.deleteDatabaseFiles();\n\n        store = new RMTxStore();\n        store.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n        store.init();\n    }","commit_id":"0d7af8c708cdda67c64cdc2279006ae8972b5f7e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n  public void createPathTest() throws Exception {\n    // create directory\n    mTree.createPath(TEST_URI, Constants.KB, false, true);\n    Inode test = mTree.getInodeByPath(TEST_URI);\n    Assert.assertEquals(TEST_PATH, test.getName());\n    Assert.assertTrue(test.isDirectory());\n\n    // create nested directory\n    mTree.createPath(NESTED_URI, Constants.KB, true, true);\n    Inode nested = mTree.getInodeByPath(NESTED_URI);\n    Assert.assertEquals(TEST_PATH, nested.getName());\n    Assert.assertEquals(2, nested.getParentId());\n    Assert.assertTrue(test.isDirectory());\n\n    // created nested file\n    mTree.createPath(NESTED_FILE_URI, Constants.KB, true, false);\n    Inode nestedFile = mTree.getInodeByPath(NESTED_FILE_URI);\n    Assert.assertEquals(\"file\", nestedFile.getName());\n    Assert.assertEquals(3, nestedFile.getParentId());\n    Assert.assertTrue(nestedFile.isFile());\n  }","id":81257,"modified_method":"@Test\n  public void createPathTest() throws Exception {\n    // create nested directory\n    List<Inode> inodes = mTree.createPath(NESTED_URI, Constants.KB, true, true);\n    Assert.assertEquals(2, inodes.size());\n    Assert.assertEquals(\"nested\", inodes.get(0).getName());\n    Assert.assertEquals(\"test\", inodes.get(1).getName());\n\n    // creating the directory path again results in no new inodes.\n    inodes = mTree.createPath(NESTED_URI, Constants.KB, true, true);\n    Assert.assertEquals(0, inodes.size());\n\n    // create a file\n    inodes = mTree.createPath(NESTED_FILE_URI, Constants.KB, true, false);\n    Assert.assertEquals(1, inodes.size());\n    Assert.assertEquals(\"file\", inodes.get(0).getName());\n  }","commit_id":"9b550ee2515d720167395a6d64618159a2986e79","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n    public void verifyPingIsSent() throws Exception\n    {\n        // Note that we verify that the ES Runner has been initialized as this allows us to more easily debug the test\n        // by manually starting an XWiki instance and an ES instance prior to running this test (in this case we don't\n        // provision ES).\n        if (ElasticSearchRunner.esSetup != null) {\n            // When XWiki was started by ElasticSearchRunner from AllTests, a page was checked to verify that the XWiki\n            // instance was up. This, in turn, triggered the send of an asynchronous ping to the ES instance\n            // (started prior to the XWiki start in ElasticSearchRunner).\n            //\n            // Since the ping may take some time to be sent to our ES instance, we wait till we have 1 index in ES or\n            // till the timeout expires.\n            long count = 0;\n            long time = System.currentTimeMillis();\n            while (count != 1 && (System.currentTimeMillis() - time) < 5000L) {\n                count = ElasticSearchRunner.esSetup.countAll();\n                Thread.sleep(100L);\n            }\n\n            // In order to verify backward compatibility with the previous Active Install format, we also add an index\n            // in the older format.\n            ElasticSearchRunner.esSetup.execute(index(\"installs\", \"install\", \"156231f3-705b-44c6-afe3-e191bcc4b746\")\n                .withSource(\"{ \\\"formatVersion\\\": \\\"1.0\\\", \\\"distributionVersion\\\": \\\"5.2\\\", \"\n                    + \"\\\"distributionId\\\": \\\"org.xwiki.enterprise:xwiki-enterprise-web\\\", \"\n                    + \"\\\"date\\\": \\\"2013-09-16T20:00:34.277Z\\\", \\\"extensions\\\": [ ] }\"));\n        }\n\n        // Navigate to the Active Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        ViewPage vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\", \"view\",\n            \"distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Also verify the Active Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Navigate to the Total Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\", \"view\",\n            \"distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Also verify the Total Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // Verify JavaVersion data\n        getUtil().gotoPage(\"ActiveInstalls\", \"JavaVersionsData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Java Version Active Installs Count\\\\r?\\\\n1\\\\.[0-9_\\\\.]* 1\"));\n\n        // Verify Databases data\n        getUtil().gotoPage(\"ActiveInstalls\", \"DatabasesData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Database Active Installs Count\\\\r?\\\\nHSQL Database Engine 1\"));\n\n        // Verify XWikiVersion data\n        getUtil().gotoPage(\"ActiveInstalls\", \"XWikiVersionsData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"XWiki Version Active Installs Count\\\\r?\\\\n[0-9]\\\\.[0-9].* 1\"));\n\n        // Verify ServletContainers data\n        getUtil().gotoPage(\"ActiveInstalls\", \"ServletContainersData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Servlet Container Active Installs Count\\\\r?\\\\njetty 1\"));\n    }","id":81258,"modified_method":"@Test\n    public void verifyPingIsSent() throws Exception\n    {\n        // Note that we verify that the ES Runner has been initialized as this allows us to more easily debug the test\n        // by manually starting an XWiki instance and an ES instance prior to running this test (in this case we don't\n        // provision ES).\n        if (ElasticSearchRunner.esSetup != null) {\n            // When XWiki was started by ElasticSearchRunner from AllTests, a page was checked to verify that the XWiki\n            // instance was up. This, in turn, triggered the send of an asynchronous ping to the ES instance\n            // (started prior to the XWiki start in ElasticSearchRunner).\n            //\n            // Since the ping may take some time to be sent to our ES instance, we wait till we have 1 index in ES or\n            // till the timeout expires.\n            long count = 0;\n            long time = System.currentTimeMillis();\n            while (count != 1 && (System.currentTimeMillis() - time) < 5000L) {\n                count = ElasticSearchRunner.esSetup.countAll();\n                Thread.sleep(100L);\n            }\n\n            // In order to verify backward compatibility with the previous Active Install format, we also add an index\n            // in the older format.\n            ElasticSearchRunner.esSetup.execute(index(\"installs\", \"install\", \"156231f3-705b-44c6-afe3-e191bcc4b746\")\n                .withSource(\"{ \\\"formatVersion\\\": \\\"1.0\\\", \\\"distributionVersion\\\": \\\"5.2\\\", \"\n                    + \"\\\"distributionId\\\": \\\"org.xwiki.platform:xwiki-platform-web\\\", \"\n                    + \"\\\"date\\\": \\\"2013-09-16T20:00:34.277Z\\\", \\\"extensions\\\": [ ] }\"));\n        }\n\n        // Configure the Active Installs feature to count \"org.xwiki.platform:xwiki-platform-web\" distribution ids.\n        getUtil().updateObject(\"ActiveInstalls\", \"ActiveInstallsConfig\", \"ActiveInstalls.ActiveInstallsConfig\", 0,\n            \"distributionId\", \"org.xwiki.platform:xwiki-platform-web\");\n\n        // By default we don't show SNAPSHOTs, verify that!\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\");\n        ViewPage vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\");\n        vp = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Configure the Active Installs feature to count SNAPSHOTs and to count\n        // \"org.xwiki.platform:xwiki-platform-web\" distribution ids.\n        getUtil().updateObject(\"ActiveInstalls\", \"ActiveInstallsConfig\", \"ActiveInstalls.ActiveInstallsConfig\", 0,\n            \"snapshots\", true);\n\n        // Navigate to the Active Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\");\n        vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // Also verify the Active Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Navigate to the Total Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\");\n        vp = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // Also verify the Total Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // Verify JavaVersion data\n        getUtil().gotoPage(\"ActiveInstalls\", \"JavaVersionsData\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Java Version Active Installs Count\\\\r?\\\\n1\\\\.[0-9_\\\\.]* 1\"));\n\n        // Verify Databases data\n        getUtil().gotoPage(\"ActiveInstalls\", \"DatabasesData\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Database Active Installs Count\\\\r?\\\\nHSQL Database Engine 1\"));\n\n        // Verify XWikiVersion data\n        getUtil().gotoPage(\"ActiveInstalls\", \"XWikiVersionsData\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"XWiki Version Active Installs Count\\\\r?\\\\n[0-9]\\\\.[0-9].* 1\"));\n\n        // Verify ServletContainers data\n        getUtil().gotoPage(\"ActiveInstalls\", \"ServletContainersData\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Servlet Container Active Installs Count\\\\r?\\\\njetty 1\"));\n    }","commit_id":"78c655967af56f44cf4098b8d3fa2b936180a893","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public AnAction getClickAction() {\n    return ActionManager.getInstance().getAction(\"jetbrains.mps.baseLanguage.pluginSolution.plugin.GoToOverridingMethod_Action#jetbrains.mps.baseLanguage.findUsages.DerivedMethods_Finder!\");\n  }","id":81259,"modified_method":"public AnAction getClickAction() {\n    return ((BaseAction) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.java.actions.GoToOverridingMethod_Action\"));\n  }","commit_id":"1332fe90821e067284899b486761177eafe8f2fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Load tags and branches\n   */\n  private void loadRefs() {\n    try {\n      myLocalBranches.clear();\n      myRemoteBranches.clear();\n      myTags.clear();\n      final VirtualFile root = gitRoot();\n      GitBranch.list(myProject, root, true, false, myLocalBranches, null);\n      GitBranch.list(myProject, root, false, true, myRemoteBranches, null);\n      GitTag.list(myProject, root, myTags);\n      myCurrentBranch = GitBranch.current(myProject, root);\n    }\n    catch (VcsException e) {\n      GitUIUtil.showOperationError(myProject, e, \"git branch -a\");\n    }\n  }","id":81260,"modified_method":"/**\n   * Load tags and branches\n   */\n  protected void loadRefs() {\n    try {\n      myLocalBranches.clear();\n      myRemoteBranches.clear();\n      myTags.clear();\n      final VirtualFile root = gitRoot();\n      GitBranch.list(myProject, root, true, false, myLocalBranches, null);\n      GitBranch.list(myProject, root, false, true, myRemoteBranches, null);\n      GitTag.list(myProject, root, myTags);\n      myCurrentBranch = GitBranch.current(myProject, root);\n    }\n    catch (VcsException e) {\n      GitUIUtil.showOperationError(myProject, e, \"git branch -a\");\n    }\n  }","commit_id":"60f95d822ed54b681e09f666775076e53a0fb0ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Update onto and from comboboxes.\n   */\n  private void updateOntoFrom() {\n    String onto = GitUIUtil.getTextField(myOntoComboBox).getText();\n    String from = GitUIUtil.getTextField(myFromComboBox).getText();\n    myFromComboBox.removeAllItems();\n    myOntoComboBox.removeAllItems();\n    for (GitBranch b : myLocalBranches) {\n      myFromComboBox.addItem(b);\n      myOntoComboBox.addItem(b);\n    }\n    if (myShowRemoteBranchesCheckBox.isSelected()) {\n      for (GitBranch b : myRemoteBranches) {\n        myFromComboBox.addItem(b);\n        myOntoComboBox.addItem(b);\n      }\n    }\n    if (myShowTagsCheckBox.isSelected()) {\n      for (GitTag t : myTags) {\n        myFromComboBox.addItem(t);\n        myOntoComboBox.addItem(t);\n      }\n    }\n    GitUIUtil.getTextField(myOntoComboBox).setText(onto);\n    GitUIUtil.getTextField(myFromComboBox).setText(from);\n  }","id":81261,"modified_method":"/**\n   * Update onto and from comboboxes.\n   */\n  protected void updateOntoFrom() {\n    String onto = GitUIUtil.getTextField(myOntoComboBox).getText();\n    String from = GitUIUtil.getTextField(myFromComboBox).getText();\n    myFromComboBox.removeAllItems();\n    myOntoComboBox.removeAllItems();\n    for (GitBranch b : myLocalBranches) {\n      myFromComboBox.addItem(b);\n      myOntoComboBox.addItem(b);\n    }\n    if (myShowRemoteBranchesCheckBox.isSelected()) {\n      for (GitBranch b : myRemoteBranches) {\n        myFromComboBox.addItem(b);\n        myOntoComboBox.addItem(b);\n      }\n    }\n    if (myShowTagsCheckBox.isSelected()) {\n      for (GitTag t : myTags) {\n        myFromComboBox.addItem(t);\n        myOntoComboBox.addItem(t);\n      }\n    }\n    GitUIUtil.getTextField(myOntoComboBox).setText(onto);\n    GitUIUtil.getTextField(myFromComboBox).setText(from);\n  }","commit_id":"60f95d822ed54b681e09f666775076e53a0fb0ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    final VirtualFile[] roots = ProjectRootManager.getInstance(project).getContentRoots();\n    if (roots.length == 0) {\n      Messages.showErrorDialog(project, \"Project doesn't have any project roots\", \"Cannot create new GitHub repository\");\n      return;\n    }\n    final VirtualFile root = roots[0];\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (!gitDetected) {\n      Messages.showErrorDialog(project, \"Cannot find any git repository configured for the project\", \"Cannot perform github rebase\");\n      return;\n    }\n\n    try {\n    // Check current branch\n      final GitBranch currentBranch = GitBranch.current(project, root);\n      if (currentBranch == null) {\n        Messages.showErrorDialog(project, \"Cannot find current branch\", \"Cannot perform github rebase\");\n        return;\n      }\n      if (!\"master\".equals(currentBranch.getName())) {\n        Messages.showErrorDialog(project, \"Cannot perform rebase with '\" + currentBranch.getName() + \"' branch.\\nPlease switch to master\",\n                                 \"Cannot perform github rebase\");\n        return;\n      }\n\n      // Check that given repository is properly configured git repository\n      GitRemote githubRemote = null;\n      final List<GitRemote> gitRemotes = GitRemote.list(project, root);\n      if (gitRemotes.isEmpty()) {\n        Messages.showErrorDialog(project, \"Git repository doesn't have any remotes configured\", \"Cannot perform github rebase\");\n        return;\n      }\n      for (GitRemote gitRemote : gitRemotes) {\n        if (gitRemote.pushUrl().contains(\"git@github.com\")) {\n          githubRemote = gitRemote;\n          break;\n        }\n      }\n      if (githubRemote == null) {\n        Messages.showErrorDialog(project, \"Configured own github repository is not found\", \"Cannot perform github rebase\");\n        return;\n      }\n\n      final String pushUrl = githubRemote.pushUrl();\n      final String login = GithubSettings.getInstance().getLogin();\n      final int index = pushUrl.lastIndexOf(login);\n      if (index == -1) {\n        Messages.showErrorDialog(project, \"Github remote repository doesn't seem to be your own repository: \" + pushUrl,\n                                 \"Cannot perform github rebase\");\n        return;\n      }\n      String repoName = pushUrl.substring(index + login.length() + 1);\n      if (repoName.endsWith(\".git\")) {\n        repoName = repoName.substring(0, repoName.length() - 4);\n      }\n\n      final RepositoryInfo repositoryInfo = GithubUtil.getDetailedRepositoryInfo(project, repoName);\n      if (repositoryInfo == null) {\n        Messages\n          .showErrorDialog(project, \"Github repository doesn't seem to be your own repository: \" + pushUrl, \"Cannot perform github rebase\");\n        return;\n      }\n\n      if (!repositoryInfo.isFork()) {\n        Messages.showErrorDialog(project, \"Github repository '\" + repoName + \"' is not a forked one\", \"Cannot perform github rebase\");\n        return;\n      }\n\n      final String parent = repositoryInfo.getParent();\n      LOG.assertTrue(parent != null, \"Parent repository not found!\");\n      final String parentRepoSuffix = parent + \".git\";\n      final String parentRepoUrl = \"git://github.com/\" + parentRepoSuffix;\n\n      // Check that corresponding remote branch is configured for the fork origin repo\n      boolean remoteForParentSeen = false;\n      for (GitRemote gitRemote : gitRemotes) {\n        final String fetchUrl = gitRemote.fetchUrl();\n        if (fetchUrl.endsWith(parent + \".git\")) {\n          remoteForParentSeen = true;\n          break;\n        }\n      }\n      if (!remoteForParentSeen){\n        final int result = Messages.showYesNoDialog(project, \"It is nescessary to have '\" +\n                                                        parentRepoUrl +\n                                                        \"' as a configured remote. Add remote?\", \"Github Rebase\",\n                                               Messages.getQuestionIcon());\n        if (result != Messages.OK){\n          return;\n        }\n\n        LOG.info(\"Adding GitHub as a remote host\");\n        final GitSimpleHandler addRemoteHandler = new GitSimpleHandler(project, root, GitCommand.REMOTE);\n        addRemoteHandler.setNoSSH(true);\n        addRemoteHandler.setSilent(true);\n        addRemoteHandler.addParameters(\"add\", repoName, parentRepoUrl);\n        addRemoteHandler.run();\n        if (addRemoteHandler.getExitCode() != 0) {\n          Messages.showErrorDialog(\"Failed to add GitHub remote: '\" + parentRepoUrl + \"'\", \"Failed to add GitHub remote\");\n          return;\n        }\n\n      }\n\n      BasicAction.saveAll();\n      final AnAction action = ActionManager.getInstance().getAction(\"Git.Rebase\");\n      final AnActionEvent actionEvent =\n        new AnActionEvent(e.getInputEvent(), e.getDataContext(), e.getPlace(), e.getPresentation(), e.getActionManager(), e.getModifiers());\n      action.actionPerformed(actionEvent);\n    }\n    catch (VcsException e1) {\n      Messages.showErrorDialog(project, \"Error happened during git operation: \" + e1.getMessage(), \"Cannot perform github rebase\");\n      return;\n    }\n  }","id":81262,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    final VirtualFile[] roots = ProjectRootManager.getInstance(project).getContentRoots();\n    if (roots.length == 0) {\n      Messages.showErrorDialog(project, \"Project doesn't have any project roots\", \"Cannot create new GitHub repository\");\n      return;\n    }\n    final VirtualFile root = roots[0];\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (!gitDetected) {\n      Messages.showErrorDialog(project, \"Cannot find any git repository configured for the project\", \"Cannot perform github rebase\");\n      return;\n    }\n\n    try {\n    // Check current branch\n      final GitBranch currentBranch = GitBranch.current(project, root);\n      if (currentBranch == null) {\n        Messages.showErrorDialog(project, \"Cannot find current branch\", \"Cannot perform github rebase\");\n        return;\n      }\n      if (!\"master\".equals(currentBranch.getName())) {\n        Messages.showErrorDialog(project, \"Cannot perform rebase with '\" + currentBranch.getName() + \"' branch.\\nPlease switch to master\",\n                                 \"Cannot perform github rebase\");\n        return;\n      }\n\n      // Check that given repository is properly configured git repository\n      GitRemote githubRemote = null;\n      final List<GitRemote> gitRemotes = GitRemote.list(project, root);\n      if (gitRemotes.isEmpty()) {\n        Messages.showErrorDialog(project, \"Git repository doesn't have any remotes configured\", \"Cannot perform github rebase\");\n        return;\n      }\n      for (GitRemote gitRemote : gitRemotes) {\n        if (gitRemote.pushUrl().contains(\"git@github.com\")) {\n          githubRemote = gitRemote;\n          break;\n        }\n      }\n      if (githubRemote == null) {\n        Messages.showErrorDialog(project, \"Configured own github repository is not found\", \"Cannot perform github rebase\");\n        return;\n      }\n\n      final String pushUrl = githubRemote.pushUrl();\n      final String login = GithubSettings.getInstance().getLogin();\n      final int index = pushUrl.lastIndexOf(login);\n      if (index == -1) {\n        Messages.showErrorDialog(project, \"Github remote repository doesn't seem to be your own repository: \" + pushUrl,\n                                 \"Cannot perform github rebase\");\n        return;\n      }\n      String repoName = pushUrl.substring(index + login.length() + 1);\n      if (repoName.endsWith(\".git\")) {\n        repoName = repoName.substring(0, repoName.length() - 4);\n      }\n\n      final RepositoryInfo repositoryInfo = GithubUtil.getDetailedRepositoryInfo(project, repoName);\n      if (repositoryInfo == null) {\n        Messages\n          .showErrorDialog(project, \"Github repository doesn't seem to be your own repository: \" + pushUrl, \"Cannot perform github rebase\");\n        return;\n      }\n\n      if (!repositoryInfo.isFork()) {\n        Messages.showErrorDialog(project, \"Github repository '\" + repoName + \"' is not a forked one\", \"Cannot perform github rebase\");\n        return;\n      }\n\n      final String parent = repositoryInfo.getParent();\n      LOG.assertTrue(parent != null, \"Parent repository not found!\");\n      final String parentRepoSuffix = parent + \".git\";\n      final String parentRepoUrl = \"git://github.com/\" + parentRepoSuffix;\n\n      // Check that corresponding remote branch is configured for the fork origin repo\n      boolean remoteForParentSeen = false;\n      for (GitRemote gitRemote : gitRemotes) {\n        final String fetchUrl = gitRemote.fetchUrl();\n        if (fetchUrl.endsWith(parent + \".git\")) {\n          remoteForParentSeen = true;\n          break;\n        }\n      }\n      if (!remoteForParentSeen){\n        final int result = Messages.showYesNoDialog(project, \"It is nescessary to have '\" +\n                                                        parentRepoUrl +\n                                                        \"' as a configured remote. Add remote?\", \"Github Rebase\",\n                                               Messages.getQuestionIcon());\n        if (result != Messages.OK){\n          return;\n        }\n\n        LOG.info(\"Adding GitHub as a remote host\");\n        final GitSimpleHandler addRemoteHandler = new GitSimpleHandler(project, root, GitCommand.REMOTE);\n        addRemoteHandler.setNoSSH(true);\n        addRemoteHandler.setSilent(true);\n        addRemoteHandler.addParameters(\"add\", repoName, parentRepoUrl);\n        addRemoteHandler.run();\n        if (addRemoteHandler.getExitCode() != 0) {\n          Messages.showErrorDialog(\"Failed to add GitHub remote: '\" + parentRepoUrl + \"'\", \"Failed to add GitHub remote\");\n          return;\n        }\n\n      }\n\n      BasicAction.saveAll();\n      final GithubRebase action = (GithubRebase) ActionManager.getInstance().getAction(\"Github.Rebase.Internal\");\n      action.setRebaseOrigin(parent);\n      final AnActionEvent actionEvent =\n        new AnActionEvent(e.getInputEvent(), e.getDataContext(), e.getPlace(), e.getPresentation(), e.getActionManager(), e.getModifiers());\n      action.actionPerformed(actionEvent);\n    }\n    catch (VcsException e1) {\n      Messages.showErrorDialog(project, \"Error happened during git operation: \" + e1.getMessage(), \"Cannot perform github rebase\");\n      return;\n    }\n  }","commit_id":"60f95d822ed54b681e09f666775076e53a0fb0ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createPanel() {\n    myPanel = new JPanel(new BorderLayout());\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n\n    final List<AnAction> actions = new LinkedList<AnAction>();\n    final CommonActionsManager cam = CommonActionsManager.getInstance();\n    final Expander expander = new Expander();\n    final AnAction expandAction = cam.createExpandAllAction(expander, myView);\n    actions.add(expandAction);\n    final AnAction collapseAction = cam.createCollapseAllAction(expander, myView);\n    actions.add(collapseAction);\n    actions.add(new ToggleShowFlattenAction());\n\n    AnAction addAction = ActionManager.getInstance().getAction(\"ChangesView.AddUnversioned.From.Dialog\");\n    AnAction moveAction = ActionManager.getInstance().getAction(IdeActions.MOVE_TO_ANOTHER_CHANGE_LIST);\n    AnAction deleteAction = ActionManager.getInstance().getAction(\"ChangesView.DeleteUnversioned.From.Dialog\");\n    AnAction ignoreAction = ActionManager.getInstance().getAction(\"ChangesView.Ignore\");\n\n    final AnAction[] operatingActions = { addAction, moveAction, deleteAction, ignoreAction };\n\n    for (AnAction action : operatingActions) {\n      actions.add(action);\n      action.registerCustomShortcutSet(action.getShortcutSet(), myView);\n    }\n    deleteAction.registerCustomShortcutSet(CommonShortcuts.DELETE, myView); // special shortcut for deleting file\n\n    ActionManager.getInstance().addAnActionListener(new AnActionListener.Adapter() {\n      @Override\n      public void afterActionPerformed(AnAction action, DataContext dataContext, AnActionEvent event) {\n        for (AnAction anAction : operatingActions) {\n          if (anAction.equals(action)) {\n            refreshView();\n            return;\n          }\n        }\n      }\n    }, myDisposable);\n\n    for (AnAction action : actions) {\n      group.add(action);\n    }\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(\"UNVERSIONED_DIALOG\", group, false);\n    myPanel.add(actionToolbar.getComponent(), BorderLayout.WEST);\n    myPanel.add(ScrollPaneFactory.createScrollPane(myView), BorderLayout.CENTER);\n\n    final DefaultActionGroup secondGroup = new DefaultActionGroup();\n    for (AnAction action : actions) {\n      secondGroup.add(action);\n    }\n\n    myView.setMenuActions(secondGroup);\n    myView.setShowFlatten(false);\n  }","id":81263,"modified_method":"private void createPanel() {\n    myPanel = new JPanel(new BorderLayout());\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n\n    final List<AnAction> actions = new LinkedList<AnAction>();\n    final CommonActionsManager cam = CommonActionsManager.getInstance();\n    final Expander expander = new Expander();\n    final AnAction expandAction = cam.createExpandAllAction(expander, myView);\n    actions.add(expandAction);\n    final AnAction collapseAction = cam.createCollapseAllAction(expander, myView);\n    actions.add(collapseAction);\n    actions.add(new ToggleShowFlattenAction());\n\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(\"UNVERSIONED_DIALOG\", group, false);\n\n    final ActionGroup operatingActions = (ActionGroup)ActionManager.getInstance().getAction(\"Unversioned.Files.Dialog\");\n    registerShortcuts(operatingActions, actionToolbar.getToolbarDataContext());\n    refreshViewAfterActionPerformed(operatingActions);\n    actions.add(operatingActions);\n\n    for (AnAction action : actions) {\n      group.add(action);\n    }\n    myPanel.add(actionToolbar.getComponent(), BorderLayout.WEST);\n    myPanel.add(ScrollPaneFactory.createScrollPane(myView), BorderLayout.CENTER);\n\n    final DefaultActionGroup secondGroup = new DefaultActionGroup();\n    for (AnAction action : actions) {\n      secondGroup.add(action);\n    }\n\n    myView.setMenuActions(secondGroup);\n    myView.setShowFlatten(false);\n  }","commit_id":"18eb56d72f623b8f6362e275f2a79532d0bb3a3f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private final JSONObject toJSON( Resource resource, Bundle[] bundles, boolean details ) throws JSONException\r\n    {\r\n        final String symbolicName = resource.getSymbolicName();\r\n        final String version = resource.getVersion().toString();\r\n        boolean installed = false;\r\n        for ( int i = 0; symbolicName != null && !installed && bundles != null && i < bundles.length; i++ )\r\n        {\r\n            final String ver = ( String ) bundles[i].getHeaders( \"\" ).get( Constants.BUNDLE_VERSION ); //$NON-NLS-1$\r\n            installed = symbolicName.equals( bundles[i].getSymbolicName() ) && version.equals( ver );\r\n        }\r\n        JSONObject json = new JSONObject( resource.getProperties() ) //\r\n            .put( \"id\", resource.getId() ) // //$NON-NLS-1$\r\n            .put( \"presentationname\", resource.getPresentationName() ) // //$NON-NLS-1$\r\n            .put( \"symbolicname\", symbolicName ) // //$NON-NLS-1$\r\n            .put( \"url\", resource.getURI() ) // //$NON-NLS-1$\r\n            .put( \"version\", version ) // //$NON-NLS-1$\r\n            .put( \"categories\", resource.getCategories() ) // //$NON-NLS-1$\r\n            .put( \"installed\", installed ); //$NON-NLS-1$\r\n\r\n        if ( details )\r\n        {\r\n            Capability[] caps = resource.getCapabilities();\r\n            for ( int i = 0; caps != null && i < caps.length; i++ )\r\n            {\r\n                json.append( \"capabilities\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", caps[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"properties\", toJSON( caps[i].getProperties() ) ) ); //$NON-NLS-1$\r\n            }\r\n            Requirement[] reqs = resource.getRequirements();\r\n            for ( int i = 0; reqs != null && i < reqs.length; i++ )\r\n            {\r\n                json.append( \"requirements\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", reqs[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", reqs[i].getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", reqs[i].isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n\r\n            final RepositoryAdmin admin = ( RepositoryAdmin ) getRepositoryAdmin();\r\n            Resolver resolver = admin.resolver();\r\n            resolver.add( resource );\r\n            resolver.resolve( Resolver.NO_OPTIONAL_RESOURCES );\r\n            Resource[] required = resolver.getRequiredResources();\r\n            for ( int i = 0; required != null && i < required.length; i++ )\r\n            {\r\n                json.append( \"required\", toJSON( required[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Resource[] optional = resolver.getOptionalResources();\r\n            for ( int i = 0; optional != null && i < optional.length; i++ )\r\n            {\r\n                json.append( \"optional\", toJSON( optional[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Reason[] unsatisfied = resolver.getUnsatisfiedRequirements();\r\n            for ( int i = 0; unsatisfied != null && i < unsatisfied.length; i++ )\r\n            {\r\n                json.append( \"unsatisfied\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", unsatisfied[i].getRequirement().getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", unsatisfied[i].getRequirement().getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", unsatisfied[i].getRequirement().isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n        }\r\n        return json;\r\n    }","id":81264,"modified_method":"private final JSONObject toJSON( Resource resource, Bundle[] bundles, boolean details ) throws JSONException\r\n    {\r\n        final String symbolicName = resource.getSymbolicName();\r\n        final Version version = resource.getVersion();\r\n        String installed = \"\";\r\n        for ( int i = 0; symbolicName != null && installed.length() == 0 && bundles != null && i < bundles.length; i++ )\r\n        {\r\n            final Version ver = bundles[i].getVersion();\r\n            if ( symbolicName.equals(bundles[i].getSymbolicName()))\r\n            {\r\n                installed = ver.toString();\r\n            }\r\n        }\r\n        JSONObject json = new JSONObject()\r\n            .put( \"id\", resource.getId() ) // //$NON-NLS-1$\r\n            .put( \"presentationname\", resource.getPresentationName() ) // //$NON-NLS-1$\r\n            .put( \"symbolicname\", symbolicName ) // //$NON-NLS-1$\r\n            .put( \"url\", resource.getURI() ) // //$NON-NLS-1$\r\n            .put( \"version\", version ) // //$NON-NLS-1$\r\n            .put( \"categories\", resource.getCategories() ) // //$NON-NLS-1$\r\n            .put( \"installed\", installed ); //$NON-NLS-1$\r\n\r\n        if ( details )\r\n        {\r\n            Capability[] caps = resource.getCapabilities();\r\n            for ( int i = 0; caps != null && i < caps.length; i++ )\r\n            {\r\n                json.append( \"capabilities\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", caps[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"properties\", toJSON( caps[i].getProperties() ) ) ); //$NON-NLS-1$\r\n            }\r\n            Requirement[] reqs = resource.getRequirements();\r\n            for ( int i = 0; reqs != null && i < reqs.length; i++ )\r\n            {\r\n                json.append( \"requirements\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", reqs[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", reqs[i].getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", reqs[i].isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n\r\n            final RepositoryAdmin admin = ( RepositoryAdmin ) getRepositoryAdmin();\r\n            Resolver resolver = admin.resolver();\r\n            resolver.add( resource );\r\n            resolver.resolve( Resolver.NO_OPTIONAL_RESOURCES );\r\n            Resource[] required = resolver.getRequiredResources();\r\n            for ( int i = 0; required != null && i < required.length; i++ )\r\n            {\r\n                json.append( \"required\", toJSON( required[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Resource[] optional = resolver.getOptionalResources();\r\n            for ( int i = 0; optional != null && i < optional.length; i++ )\r\n            {\r\n                json.append( \"optional\", toJSON( optional[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Reason[] unsatisfied = resolver.getUnsatisfiedRequirements();\r\n            for ( int i = 0; unsatisfied != null && i < unsatisfied.length; i++ )\r\n            {\r\n                json.append( \"unsatisfied\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", unsatisfied[i].getRequirement().getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", unsatisfied[i].getRequirement().getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", unsatisfied[i].getRequirement().isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n        }\r\n        return json;\r\n    }","commit_id":"f7863d457926ded013c0d4368236cc0b6c7f8601","url":"https://github.com/apache/felix"},{"original_method":"private final JSONObject toJSON( Resource resource, Bundle[] bundles, boolean details ) throws JSONException\r\n    {\r\n        final String symbolicName = resource.getSymbolicName();\r\n        final String version = resource.getVersion().toString();\r\n        boolean installed = false;\r\n        for ( int i = 0; symbolicName != null && !installed && bundles != null && i < bundles.length; i++ )\r\n        {\r\n            final String ver = ( String ) bundles[i].getHeaders( \"\" ).get( Constants.BUNDLE_VERSION ); //$NON-NLS-1$\r\n            installed = symbolicName.equals( bundles[i].getSymbolicName() ) && version.equals( ver );\r\n        }\r\n        JSONObject json = new JSONObject( resource.getProperties() ) //\r\n            .put( \"id\", resource.getId() ) // //$NON-NLS-1$\r\n            .put( \"presentationname\", resource.getPresentationName() ) // //$NON-NLS-1$\r\n            .put( \"symbolicname\", symbolicName ) // //$NON-NLS-1$\r\n            .put( \"url\", resource.getURL() ) // //$NON-NLS-1$\r\n            .put( \"version\", version ) // //$NON-NLS-1$\r\n            .put( \"categories\", resource.getCategories() ) // //$NON-NLS-1$\r\n            .put( \"installed\", installed ); //$NON-NLS-1$\r\n\r\n        if ( details )\r\n        {\r\n            Capability[] caps = resource.getCapabilities();\r\n            for ( int i = 0; caps != null && i < caps.length; i++ )\r\n            {\r\n                json.append( \"capabilities\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", caps[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"properties\", new JSONObject( caps[i].getProperties() ) ) ); //$NON-NLS-1$\r\n            }\r\n            Requirement[] reqs = resource.getRequirements();\r\n            for ( int i = 0; reqs != null && i < reqs.length; i++ )\r\n            {\r\n                json.append( \"requirements\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", reqs[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", reqs[i].getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", reqs[i].isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n\r\n            final RepositoryAdmin admin = ( RepositoryAdmin ) getRepositoryAdmin();\r\n            Resolver resolver = admin.resolver();\r\n            resolver.add( resource );\r\n            resolver.resolve(); // (Resolver.NO_OPTIONAL_RESOURCES);\r\n            Resource[] required = resolver.getRequiredResources();\r\n            for ( int i = 0; required != null && i < required.length; i++ )\r\n            {\r\n                json.append( \"required\", toJSON( required[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Resource[] optional = resolver.getOptionalResources();\r\n            for ( int i = 0; optional != null && i < optional.length; i++ )\r\n            {\r\n                json.append( \"optional\", toJSON( optional[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Requirement/*Reason*/[] unsatisfied = resolver.getUnsatisfiedRequirements();\r\n            for ( int i = 0; unsatisfied != null && i < unsatisfied.length; i++ )\r\n            {\r\n                json.append( \"unsatisfied\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", unsatisfied[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", unsatisfied[i].getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", unsatisfied[i].isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n        }\r\n        return json;\r\n    }","id":81265,"modified_method":"private final JSONObject toJSON( Resource resource, Bundle[] bundles, boolean details ) throws JSONException\r\n    {\r\n        final String symbolicName = resource.getSymbolicName();\r\n        final Version version = resource.getVersion();\r\n        String installed = \"\";\r\n        for ( int i = 0; symbolicName != null && installed.length() == 0 && bundles != null && i < bundles.length; i++ )\r\n        {\r\n            final Version ver = bundles[i].getVersion();\r\n            if ( symbolicName.equals(bundles[i].getSymbolicName()))\r\n            {\r\n                installed = ver.toString();\r\n            }\r\n        }\r\n        JSONObject json = new JSONObject()\r\n            .put( \"id\", resource.getId() ) // //$NON-NLS-1$\r\n            .put( \"presentationname\", resource.getPresentationName() ) // //$NON-NLS-1$\r\n            .put( \"symbolicname\", symbolicName ) // //$NON-NLS-1$\r\n            .put( \"url\", resource.getURL() ) // //$NON-NLS-1$\r\n            .put( \"version\", version ) // //$NON-NLS-1$\r\n            .put( \"categories\", resource.getCategories() ) // //$NON-NLS-1$\r\n            .put( \"installed\", installed ); //$NON-NLS-1$\r\n\r\n        if ( details )\r\n        {\r\n            Capability[] caps = resource.getCapabilities();\r\n            for ( int i = 0; caps != null && i < caps.length; i++ )\r\n            {\r\n                json.append( \"capabilities\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", caps[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"properties\", new JSONObject( caps[i].getProperties() ) ) ); //$NON-NLS-1$\r\n            }\r\n            Requirement[] reqs = resource.getRequirements();\r\n            for ( int i = 0; reqs != null && i < reqs.length; i++ )\r\n            {\r\n                json.append( \"requirements\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", reqs[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", reqs[i].getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", reqs[i].isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n\r\n            final RepositoryAdmin admin = ( RepositoryAdmin ) getRepositoryAdmin();\r\n            Resolver resolver = admin.resolver();\r\n            resolver.add( resource );\r\n            resolver.resolve(); // (Resolver.NO_OPTIONAL_RESOURCES);\r\n            Resource[] required = resolver.getRequiredResources();\r\n            for ( int i = 0; required != null && i < required.length; i++ )\r\n            {\r\n                json.append( \"required\", toJSON( required[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Resource[] optional = resolver.getOptionalResources();\r\n            for ( int i = 0; optional != null && i < optional.length; i++ )\r\n            {\r\n                json.append( \"optional\", toJSON( optional[i], bundles, false ) ); //$NON-NLS-1$\r\n            }\r\n            Requirement/*Reason*/[] unsatisfied = resolver.getUnsatisfiedRequirements();\r\n            for ( int i = 0; unsatisfied != null && i < unsatisfied.length; i++ )\r\n            {\r\n                json.append( \"unsatisfied\", new JSONObject() //$NON-NLS-1$\r\n                    .put( \"name\", unsatisfied[i].getName() ) //$NON-NLS-1$\r\n                    .put( \"filter\", unsatisfied[i].getFilter() ) //$NON-NLS-1$\r\n                    .put( \"optional\", unsatisfied[i].isOptional() ) ); //$NON-NLS-1$\r\n            }\r\n        }\r\n        return json;\r\n    }","commit_id":"f7863d457926ded013c0d4368236cc0b6c7f8601","url":"https://github.com/apache/felix"},{"original_method":"private IModule createModule() throws Exception\n    {\n        // Get and parse the manifest from the most recent revision to\n        // create an associated module for it.\n        Map headerMap = m_archive.getRevision(\n            m_archive.getRevisionCount() - 1).getManifestHeader();\n\n        final int revision = m_archive.getRevisionCount() - 1;\n        ModuleImpl module = new ModuleImpl(\n            getFramework().getLogger(),\n            getFramework().getConfig(),\n            getFramework().getResolver(),\n            Long.toString(getBundleId()) + \".\" + Integer.toString(revision),\n            headerMap,\n            m_archive.getRevision(revision).getContent());\n\n        // Verify that the bundle symbolic name + version is unique.\n        if (module.getManifestVersion().equals(\"2\"))\n        {\n            Version bundleVersion = module.getVersion();\n            bundleVersion = (bundleVersion == null) ? Version.emptyVersion : bundleVersion;\n            String symName = module.getSymbolicName();\n\n            Bundle[] bundles = getFramework().getBundles();\n            for (int i = 0; (bundles != null) && (i < bundles.length); i++)\n            {\n                long id = ((BundleImpl) bundles[i]).getBundleId();\n                if (id != getBundleId())\n                {\n                    String sym = bundles[i].getSymbolicName();\n                    Version ver = Version.parseVersion((String) ((BundleImpl) bundles[i])\n                        .getCurrentModule().getHeaders().get(Constants.BUNDLE_VERSION));\n                    if (symName.equals(sym) && bundleVersion.equals(ver))\n                    {\n                        throw new BundleException(\"Bundle symbolic name and version are not unique: \" + sym + ':' + ver);\n                    }\n                }\n            }\n        }\n\n        // Set the module's URL policy.\n// TODO: REFACTOR - Pass into constructor?\n        module.setURLPolicy(\n// TODO: REFACTOR - SUCKS NEEDING URL POLICY PER MODULE.\n            new URLPolicyImpl(\n                getFramework().getLogger(),\n                getFramework().getBundleStreamHandler(),\n                module));\n\n        return module;\n    }","id":81266,"modified_method":"private IModule createModule() throws Exception\n    {\n        // Get and parse the manifest from the most recent revision to\n        // create an associated module for it.\n        Map headerMap = m_archive.getRevision(\n            m_archive.getRevisionCount() - 1).getManifestHeader();\n\n        final int revision = m_archive.getRevisionCount() - 1;\n        ModuleImpl module = new ModuleImpl(\n            getFramework().getLogger(),\n            getFramework().getConfig(),\n            getFramework().getResolver(),\n            Long.toString(getBundleId()) + \".\" + Integer.toString(revision),\n            headerMap,\n            m_archive.getRevision(revision).getContent());\n\n        // Verify that the bundle symbolic name + version is unique.\n        if (module.getManifestVersion().equals(\"2\"))\n        {\n            Version bundleVersion = module.getVersion();\n            bundleVersion = (bundleVersion == null) ? Version.emptyVersion : bundleVersion;\n            String symName = module.getSymbolicName();\n\n            Bundle[] bundles = getFramework().getBundles();\n            for (int i = 0; (bundles != null) && (i < bundles.length); i++)\n            {\n                long id = ((BundleImpl) bundles[i]).getBundleId();\n                if (id != getBundleId())\n                {\n                    String sym = bundles[i].getSymbolicName();\n                    Version ver = ((ModuleImpl)\n                        ((BundleImpl) bundles[i]).getCurrentModule()).getVersion();\n                    if ((symName != null) && (sym != null) && symName.equals(sym) && bundleVersion.equals(ver))\n                    {\n                        throw new BundleException(\"Bundle symbolic name and version are not unique: \" + sym + ':' + ver);\n                    }\n                }\n            }\n        }\n\n        // Set the module's URL policy.\n// TODO: REFACTOR - Pass into constructor?\n        module.setURLPolicy(\n// TODO: REFACTOR - SUCKS NEEDING URL POLICY PER MODULE.\n            new URLPolicyImpl(\n                getFramework().getLogger(),\n                getFramework().getBundleStreamHandler(),\n                module));\n\n        return module;\n    }","commit_id":"7561a3744dff797f8fa6f49968a1df22df654b46","url":"https://github.com/apache/felix"},{"original_method":"public ManifestParser(Logger logger, Map configMap, Map headerMap)\n        throws BundleException\n    {\n        m_logger = logger;\n        m_configMap = configMap;\n        m_headerMap = headerMap;\n\n        // Verify that only manifest version 2 is specified.\n        String manifestVersion = (String) m_headerMap.get(Constants.BUNDLE_MANIFESTVERSION);\n        manifestVersion = (manifestVersion == null) ? null : manifestVersion.trim();\n        if ((manifestVersion != null) && !manifestVersion.equals(\"2\"))\n        {\n            throw new BundleException(\n                \"Unknown 'Bundle-ManifestVersion' value: \" + manifestVersion);\n        }\n\n        // Create map to check for duplicate imports/exports\n        // and lists to hold capabilities and requirements.\n        List capList = new ArrayList();\n        List reqList = new ArrayList();\n        Map dupeMap = new HashMap();\n\n        //\n        // Parse bundle symbolic name.\n        //\n\n        ICapability moduleCap = parseBundleSymbolicName(m_headerMap);\n        if (moduleCap != null)\n        {\n            m_bundleVersion = (Version)\n                moduleCap.getProperties().get(Constants.BUNDLE_VERSION_ATTRIBUTE);\n            m_bundleSymbolicName = (String)\n                moduleCap.getProperties().get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE);\n\n            // Add the module capability to all capabilities.\n            // TODO: FRAGMENT - Fragment bundles cannot be required, so we\n            //       should not add this capability, but for now we are using\n            //       it to get the symbolic name.\n            capList.add(moduleCap);\n            // Add a host capability if the bundle is not a fragment. A host\n            // capability is the same as a module capability, but with a\n            // different capability namespace.\n            if (headerMap.get(Constants.FRAGMENT_HOST) == null)\n            {\n                capList.add(new Capability(\n                    ICapability.HOST_NAMESPACE, null,\n                    ((Capability) moduleCap).getAttributes()));\n            }\n        }\n\n        //\n        // Parse Fragment-Host.\n        //\n        Object[][][] clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.FRAGMENT_HOST));\n        if (clauses.length > 0)\n        {\n            validateFragment(headerMap);\n            try\n            {\n                reqList.add(\n                    new Requirement(\n                        ICapability.HOST_NAMESPACE,\n                        \"(\" + Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE\n                            + \"=\" + clauses[0][CLAUSE_PATHS_INDEX][0] + \")\"));\n            }\n            catch (InvalidSyntaxException ex)\n            {\n                ex.printStackTrace();\n            }\n        }\n\n        //\n        // Parse Export-Package.\n        //\n\n        // Get exported packages from bundle manifest.\n        ICapability[] exportCaps = parseExportHeader(\n            (String) headerMap.get(Constants.EXPORT_PACKAGE));\n\n        // Verify that \"java.*\" packages are not exported.\n        for (int capIdx = 0; capIdx < exportCaps.length; capIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            String pkgName = (String)\n                exportCaps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n            // Verify that java.* packages are not exported.\n            if (pkgName.startsWith(\"java.\"))\n            {\n                throw new BundleException(\n                    \"Exporting java.* packages not allowed: \" + pkgName);\n            }\n            capList.add(exportCaps[capIdx]);\n        }\n\n        // Create an array of all capabilities.\n        m_capabilities = (ICapability[]) capList.toArray(new ICapability[capList.size()]);\n\n        //\n        // Parse Require-Bundle\n        //\n\n        IRequirement[] bundleReq = parseRequireBundleHeader(\n            (String) headerMap.get(Constants.REQUIRE_BUNDLE));\n        for (int reqIdx = 0; reqIdx < bundleReq.length; reqIdx++)\n        {\n            reqList.add(bundleReq[reqIdx]);\n        }\n\n        //\n        // Parse Import-Package.\n        //\n\n        // Get import packages from bundle manifest.\n        IRequirement[] importReqs = parseImportHeader(\n            (String) headerMap.get(Constants.IMPORT_PACKAGE));\n\n        // Create non-duplicated import array.\n        dupeMap.clear();\n        for (int reqIdx = 0; reqIdx < importReqs.length; reqIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            String pkgName = ((Requirement) importReqs[reqIdx]).getPackageName();\n\n            if (dupeMap.get(pkgName) == null)\n            {\n                // Verify that java.* packages are not imported.\n                if (pkgName.startsWith(\"java.\"))\n                {\n                    throw new BundleException(\n                        \"Importing java.* packages not allowed: \" + pkgName);\n                }\n                dupeMap.put(pkgName, importReqs[reqIdx]);\n            }\n            else\n            {\n                throw new BundleException(\n                    \"Duplicate import - \" + pkgName);\n            }\n        }\n\n        // Add import package requirements to requirement list.\n        reqList.addAll(dupeMap.values());\n\n        // Create an array of all requirements.\n        m_requirements = (IRequirement[]) reqList.toArray(new IRequirement[reqList.size()]);\n\n        //\n        // Parse DynamicImport-Package.\n        //\n\n        // Get dynamic import packages from bundle manifest.\n        m_dynamicRequirements = parseImportHeader(\n            (String) headerMap.get(Constants.DYNAMICIMPORT_PACKAGE));\n\n        // Dynamic imports can have duplicates, so just check for import\n        // of java.*.\n        for (int reqIdx = 0; reqIdx < m_dynamicRequirements.length; reqIdx++)\n        {\n            // Verify that java.* packages are not imported.\n            String pkgName = ((Requirement) m_dynamicRequirements[reqIdx]).getPackageName();\n            if (pkgName.startsWith(\"java.\"))\n            {\n                throw new BundleException(\n                    \"Dynamically importing java.* packages not allowed: \" + pkgName);\n            }\n        }\n\n        //\n        // Parse Bundle-NativeCode.\n        //\n\n        // Get native library entry names for module library sources.\n        m_libraryHeaders =\n            parseLibraryStrings(\n                m_logger,\n                parseDelimitedString((String) m_headerMap.get(Constants.BUNDLE_NATIVECODE), \",\"));\n\n        // Check to see if there was an optional native library clause, which is\n        // represented by a null library header; if so, record it and remove it.\n        if ((m_libraryHeaders.length > 0) &&\n            (m_libraryHeaders[m_libraryHeaders.length - 1].getLibraryEntries() == null))\n        {\n            m_libraryHeadersOptional = true;\n            R4LibraryClause[] tmp = new R4LibraryClause[m_libraryHeaders.length - 1];\n            System.arraycopy(m_libraryHeaders, 0, tmp, 0, m_libraryHeaders.length - 1);\n            m_libraryHeaders = tmp;\n        }\n\n        // Do final checks and normalization of manifest.\n        if (getManifestVersion().equals(\"2\"))\n        {\n            checkAndNormalizeR4();\n        }\n        else\n        {\n            checkAndNormalizeR3();\n        }\n    }","id":81267,"modified_method":"public ManifestParser(Logger logger, Map configMap, Map headerMap)\n        throws BundleException\n    {\n        m_logger = logger;\n        m_configMap = configMap;\n        m_headerMap = headerMap;\n\n        // Verify that only manifest version 2 is specified.\n        String manifestVersion = (String) m_headerMap.get(Constants.BUNDLE_MANIFESTVERSION);\n        manifestVersion = (manifestVersion == null) ? null : manifestVersion.trim();\n        if ((manifestVersion != null) && !manifestVersion.equals(\"2\"))\n        {\n            throw new BundleException(\n                \"Unknown 'Bundle-ManifestVersion' value: \" + manifestVersion);\n        }\n\n        // Create map to check for duplicate imports/exports\n        // and lists to hold capabilities and requirements.\n        List capList = new ArrayList();\n        List reqList = new ArrayList();\n        Map dupeMap = new HashMap();\n\n        //\n        // Parse bundle version.\n        //\n\n        m_bundleVersion = Version.emptyVersion;\n        if (headerMap.get(Constants.BUNDLE_VERSION) != null)\n        {\n            try\n            {\n                m_bundleVersion = Version.parseVersion((String) headerMap.get(Constants.BUNDLE_VERSION));\n            }\n            catch (RuntimeException ex)\n            {\n                // R4 bundle versions must parse, R3 bundle version may not.\n                if (manifestVersion.equals(\"2\"))\n                {\n                    throw ex;\n                }\n                m_bundleVersion = Version.emptyVersion;\n            }\n        }\n\n        //\n        // Parse bundle symbolic name.\n        //\n\n        ICapability moduleCap = parseBundleSymbolicName(m_headerMap);\n        if (moduleCap != null)\n        {\n            m_bundleSymbolicName = (String)\n                moduleCap.getProperties().get(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE);\n\n            // Add the module capability to all capabilities.\n            // TODO: FRAGMENT - Fragment bundles cannot be required, so we\n            //       should not add this capability, but for now we are using\n            //       it to get the symbolic name.\n            capList.add(moduleCap);\n            // Add a host capability if the bundle is not a fragment. A host\n            // capability is the same as a module capability, but with a\n            // different capability namespace.\n            if (headerMap.get(Constants.FRAGMENT_HOST) == null)\n            {\n                capList.add(new Capability(\n                    ICapability.HOST_NAMESPACE, null,\n                    ((Capability) moduleCap).getAttributes()));\n            }\n        }\n\n        //\n        // Parse Fragment-Host.\n        //\n        Object[][][] clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.FRAGMENT_HOST));\n        if (clauses.length > 0)\n        {\n            validateFragment(headerMap);\n            try\n            {\n                reqList.add(\n                    new Requirement(\n                        ICapability.HOST_NAMESPACE,\n                        \"(\" + Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE\n                            + \"=\" + clauses[0][CLAUSE_PATHS_INDEX][0] + \")\"));\n            }\n            catch (InvalidSyntaxException ex)\n            {\n                ex.printStackTrace();\n            }\n        }\n\n        //\n        // Parse Export-Package.\n        //\n\n        // Get exported packages from bundle manifest.\n        ICapability[] exportCaps = parseExportHeader(\n            (String) headerMap.get(Constants.EXPORT_PACKAGE));\n\n        // Verify that \"java.*\" packages are not exported.\n        for (int capIdx = 0; capIdx < exportCaps.length; capIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            String pkgName = (String)\n                exportCaps[capIdx].getProperties().get(ICapability.PACKAGE_PROPERTY);\n            // Verify that java.* packages are not exported.\n            if (pkgName.startsWith(\"java.\"))\n            {\n                throw new BundleException(\n                    \"Exporting java.* packages not allowed: \" + pkgName);\n            }\n            capList.add(exportCaps[capIdx]);\n        }\n\n        // Create an array of all capabilities.\n        m_capabilities = (ICapability[]) capList.toArray(new ICapability[capList.size()]);\n\n        //\n        // Parse Require-Bundle\n        //\n\n        IRequirement[] bundleReq = parseRequireBundleHeader(\n            (String) headerMap.get(Constants.REQUIRE_BUNDLE));\n        for (int reqIdx = 0; reqIdx < bundleReq.length; reqIdx++)\n        {\n            reqList.add(bundleReq[reqIdx]);\n        }\n\n        //\n        // Parse Import-Package.\n        //\n\n        // Get import packages from bundle manifest.\n        IRequirement[] importReqs = parseImportHeader(\n            (String) headerMap.get(Constants.IMPORT_PACKAGE));\n\n        // Create non-duplicated import array.\n        dupeMap.clear();\n        for (int reqIdx = 0; reqIdx < importReqs.length; reqIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            String pkgName = ((Requirement) importReqs[reqIdx]).getPackageName();\n\n            if (dupeMap.get(pkgName) == null)\n            {\n                // Verify that java.* packages are not imported.\n                if (pkgName.startsWith(\"java.\"))\n                {\n                    throw new BundleException(\n                        \"Importing java.* packages not allowed: \" + pkgName);\n                }\n                dupeMap.put(pkgName, importReqs[reqIdx]);\n            }\n            else\n            {\n                throw new BundleException(\n                    \"Duplicate import - \" + pkgName);\n            }\n        }\n\n        // Add import package requirements to requirement list.\n        reqList.addAll(dupeMap.values());\n\n        // Create an array of all requirements.\n        m_requirements = (IRequirement[]) reqList.toArray(new IRequirement[reqList.size()]);\n\n        //\n        // Parse DynamicImport-Package.\n        //\n\n        // Get dynamic import packages from bundle manifest.\n        m_dynamicRequirements = parseImportHeader(\n            (String) headerMap.get(Constants.DYNAMICIMPORT_PACKAGE));\n\n        // Dynamic imports can have duplicates, so just check for import\n        // of java.*.\n        for (int reqIdx = 0; reqIdx < m_dynamicRequirements.length; reqIdx++)\n        {\n            // Verify that java.* packages are not imported.\n            String pkgName = ((Requirement) m_dynamicRequirements[reqIdx]).getPackageName();\n            if (pkgName.startsWith(\"java.\"))\n            {\n                throw new BundleException(\n                    \"Dynamically importing java.* packages not allowed: \" + pkgName);\n            }\n        }\n\n        //\n        // Parse Bundle-NativeCode.\n        //\n\n        // Get native library entry names for module library sources.\n        m_libraryHeaders =\n            parseLibraryStrings(\n                m_logger,\n                parseDelimitedString((String) m_headerMap.get(Constants.BUNDLE_NATIVECODE), \",\"));\n\n        // Check to see if there was an optional native library clause, which is\n        // represented by a null library header; if so, record it and remove it.\n        if ((m_libraryHeaders.length > 0) &&\n            (m_libraryHeaders[m_libraryHeaders.length - 1].getLibraryEntries() == null))\n        {\n            m_libraryHeadersOptional = true;\n            R4LibraryClause[] tmp = new R4LibraryClause[m_libraryHeaders.length - 1];\n            System.arraycopy(m_libraryHeaders, 0, tmp, 0, m_libraryHeaders.length - 1);\n            m_libraryHeaders = tmp;\n        }\n\n        // Do final checks and normalization of manifest.\n        if (getManifestVersion().equals(\"2\"))\n        {\n            checkAndNormalizeR4();\n        }\n        else\n        {\n            checkAndNormalizeR3();\n        }\n    }","commit_id":"7561a3744dff797f8fa6f49968a1df22df654b46","url":"https://github.com/apache/felix"},{"original_method":"public static ICapability parseBundleSymbolicName(Map headerMap)\n        throws BundleException\n    {\n        Object[][][] clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n        if (clauses.length > 0)\n        {\n            if (clauses.length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n            else if (clauses[0][CLAUSE_PATHS_INDEX].length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n\n            // Get bundle version.\n            Version bundleVersion = null;\n            if (headerMap.get(Constants.BUNDLE_VERSION) != null)\n            {\n                try\n                {\n                    bundleVersion = Version.parseVersion((String) headerMap.get(Constants.BUNDLE_VERSION));\n                }\n                catch (RuntimeException ex)\n                {\n                    // R4 bundle versions must parse, R3 bundle version may not.\n                    if (((String) headerMap.get(Constants.BUNDLE_MANIFESTVERSION)).equals(\"2\"))\n                    {\n                        throw ex;\n                    }\n                    bundleVersion = Version.emptyVersion;\n                }\n            }\n\n            // Create a module capability and return it.\n            String symName = (String) clauses[0][CLAUSE_PATHS_INDEX][0];\n            R4Attribute[] attrs = new R4Attribute[2];\n            attrs[0] = new R4Attribute(\n                Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE, symName, false);\n            attrs[1] = new R4Attribute(\n                Constants.BUNDLE_VERSION_ATTRIBUTE, bundleVersion, false);\n            return new Capability(ICapability.MODULE_NAMESPACE, (R4Directive[]) clauses[0][CLAUSE_DIRECTIVES_INDEX], attrs);\n        }\n\n        return null;\n    }","id":81268,"modified_method":"public static ICapability parseBundleSymbolicName(Map headerMap)\n        throws BundleException\n    {\n        Object[][][] clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n        if (clauses.length > 0)\n        {\n            if (clauses.length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n            else if (clauses[0][CLAUSE_PATHS_INDEX].length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n\n            // Get bundle version.\n            Version bundleVersion = Version.emptyVersion;\n            if (headerMap.get(Constants.BUNDLE_VERSION) != null)\n            {\n                try\n                {\n                    bundleVersion = Version.parseVersion((String) headerMap.get(Constants.BUNDLE_VERSION));\n                }\n                catch (RuntimeException ex)\n                {\n                    // R4 bundle versions must parse, R3 bundle version may not.\n                    if (((String) headerMap.get(Constants.BUNDLE_MANIFESTVERSION)).equals(\"2\"))\n                    {\n                        throw ex;\n                    }\n                    bundleVersion = Version.emptyVersion;\n                }\n            }\n\n            // Create a module capability and return it.\n            String symName = (String) clauses[0][CLAUSE_PATHS_INDEX][0];\n            R4Attribute[] attrs = new R4Attribute[2];\n            attrs[0] = new R4Attribute(\n                Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE, symName, false);\n            attrs[1] = new R4Attribute(\n                Constants.BUNDLE_VERSION_ATTRIBUTE, bundleVersion, false);\n            return new Capability(ICapability.MODULE_NAMESPACE, (R4Directive[]) clauses[0][CLAUSE_DIRECTIVES_INDEX], attrs);\n        }\n\n        return null;\n    }","commit_id":"7561a3744dff797f8fa6f49968a1df22df654b46","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(NioChannel socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Set the remote address\n        remoteAddr = null;\n        remoteHost = null;\n        localAddr = null;\n        localName = null;\n        remotePort = -1;\n        localPort = -1;\n\n        // Setting up the socket\n        this.socket = socket;\n        inputBuffer.setSocket(socket);\n        outputBuffer.setSocket(socket);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n\n        int keepAliveLeft = maxKeepAliveRequests;\n        long soTimeout = endpoint.getSoTimeout();\n\n        int limit = 0;\n        if (endpoint.getFirstReadTimeout() > 0 || endpoint.getFirstReadTimeout() < -1) {\n            limit = endpoint.getMaxThreads() / 2;\n        }\n\n        boolean keptAlive = false;\n        boolean openSocket = false;\n\n        while (!error && keepAlive && !comet) {\n\n            // Parsing the request header\n            try {\n                if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {\n                    socket.getIOChannel().socket().setSoTimeout((int)soTimeout);\n                    inputBuffer.readTimeout = soTimeout;\n                }\n                if (!inputBuffer.parseRequestLine\n                        (keptAlive && (endpoint.getCurrentThreadsBusy() > limit))) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    openSocket = true;\n                    // Add the socket to the poller\n                    socket.getPoller().add(socket);\n                    break;\n                }\n                request.setStartTime(System.currentTimeMillis());\n                keptAlive = true;\n                if (!disableUploadTimeout) {\n                    socket.getIOChannel().socket().setSoTimeout((int)timeout);\n                    inputBuffer.readTimeout = soTimeout;\n                }\n                inputBuffer.parseHeaders();\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                error = true;\n            }\n\n            // Setting up filters, and parse some request headers\n            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n            try {\n                prepareRequest();\n            } catch (Throwable t) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                }\n                // 400 - Internal Server Error\n                response.setStatus(400);\n                error = true;\n            }\n\n            if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0)\n                keepAlive = false;\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                statusDropsConnection(response.getStatus());\n                    }\n                    // Comet support\n                    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n                    if (key != null) {\n                        NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();\n                        if (attach != null)  {\n                            attach.setComet(comet);\n                            Integer comettimeout = (Integer) request.getAttribute(\"org.apache.tomcat.comet.timeout\");\n                            if (comettimeout != null) attach.setTimeout(comettimeout.longValue());\n                        }\n                    }\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            if (!comet) {\n                endRequest();\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (comet) {\n            if (error) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.LONG;\n            }\n        } else {\n            recycle();\n            return (openSocket) ? SocketState.OPEN : SocketState.CLOSED;\n        }\n\n    }","id":81269,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(NioChannel socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Set the remote address\n        remoteAddr = null;\n        remoteHost = null;\n        localAddr = null;\n        localName = null;\n        remotePort = -1;\n        localPort = -1;\n\n        // Setting up the socket\n        this.socket = socket;\n        inputBuffer.setSocket(socket);\n        outputBuffer.setSocket(socket);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n\n        int keepAliveLeft = maxKeepAliveRequests;\n        long soTimeout = endpoint.getSoTimeout();\n\n        int limit = 0;\n        if (endpoint.getFirstReadTimeout() > 0 || endpoint.getFirstReadTimeout() < -1) {\n            limit = endpoint.getMaxThreads() / 2;\n        }\n\n        boolean keptAlive = false;\n        boolean openSocket = false;\n        boolean recycle = true;\n        while (!error && keepAlive && !comet) {\n\n            // Parsing the request header\n            try {\n                if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {\n                    socket.getIOChannel().socket().setSoTimeout((int)soTimeout);\n                    inputBuffer.readTimeout = soTimeout;\n                }\n                if (!inputBuffer.parseRequestLine(keptAlive && (endpoint.getCurrentThreadsBusy() > limit))) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    openSocket = true;\n                    // Add the socket to the poller\n                    socket.getPoller().add(socket);\n                    break;\n                }\n                keptAlive = true;\n                if ( !inputBuffer.parseHeaders() ) {\n                    openSocket = true;\n                    socket.getPoller().add(socket);\n                    recycle = false;\n                    break;\n                }\n                request.setStartTime(System.currentTimeMillis());\n                if (!disableUploadTimeout) { //only for body, not for request headers\n                    socket.getIOChannel().socket().setSoTimeout((int)timeout);\n                    inputBuffer.readTimeout = soTimeout;\n                }\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                error = true;\n            }\n\n            // Setting up filters, and parse some request headers\n            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n            try {\n                prepareRequest();\n            } catch (Throwable t) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                }\n                // 400 - Internal Server Error\n                response.setStatus(400);\n                error = true;\n            }\n\n            if (maxKeepAliveRequests > 0 && --keepAliveLeft == 0)\n                keepAlive = false;\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                statusDropsConnection(response.getStatus());\n                    }\n                    // Comet support\n                    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n                    if (key != null) {\n                        NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();\n                        if (attach != null)  {\n                            attach.setComet(comet);\n                            Integer comettimeout = (Integer) request.getAttribute(\"org.apache.tomcat.comet.timeout\");\n                            if (comettimeout != null) attach.setTimeout(comettimeout.longValue());\n                        }\n                    }\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            if (!comet) {\n                endRequest();\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (comet) {\n            if (error) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.LONG;\n            }\n        } else {\n            if ( recycle ) recycle();\n            return (openSocket) ? SocketState.OPEN : SocketState.CLOSED;\n        }\n\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Alternate constructor.\n     */\n    public InternalNioInputBuffer(Request request, int headerBufferSize, \n                                  long readTimeout) {\n\n        this.request = request;\n        headers = request.getMimeHeaders();\n\n        buf = new byte[headerBufferSize];\n//        if (headerBufferSize < (8 * 1024)) {\n//            bbuf = ByteBuffer.allocateDirect(6 * 1500);\n//        } else {\n//            bbuf = ByteBuffer.allocateDirect((headerBufferSize / 1500 + 1) * 1500);\n//        }\n\n        inputStreamInputBuffer = new SocketInputBuffer();\n\n        filterLibrary = new InputFilter[0];\n        activeFilters = new InputFilter[0];\n        lastActiveFilter = -1;\n\n        parsingHeader = true;\n        swallowInput = true;\n\n        if (readTimeout < 0) {\n            this.readTimeout = -1;\n        } else {\n            this.readTimeout = readTimeout;\n        }\n\n    }","id":81270,"modified_method":"/**\n     * Alternate constructor.\n     */\n    public InternalNioInputBuffer(Request request, int headerBufferSize, \n                                  long readTimeout) {\n\n        this.request = request;\n        headers = request.getMimeHeaders();\n\n        buf = new byte[headerBufferSize];\n//        if (headerBufferSize < (8 * 1024)) {\n//            bbuf = ByteBuffer.allocateDirect(6 * 1500);\n//        } else {\n//            bbuf = ByteBuffer.allocateDirect((headerBufferSize / 1500 + 1) * 1500);\n//        }\n\n        inputStreamInputBuffer = new SocketInputBuffer();\n\n        filterLibrary = new InputFilter[0];\n        activeFilters = new InputFilter[0];\n        lastActiveFilter = -1;\n\n        parsingHeader = true;\n        parsingRequestLine = true;\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        headerData.recycle();\n        swallowInput = true;\n\n        if (readTimeout < 0) {\n            this.readTimeout = -1;\n        } else {\n            this.readTimeout = readTimeout;\n        }\n\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Parse an HTTP header.\n     * \n     * @return false after reading a blank line (which indicates that the\n     * HTTP header parsing is done\n     */\n    public boolean parseHeader()\n        throws IOException {\n\n        //\n        // Check for blank line\n        //\n\n        byte chr = 0;\n        while (true) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill()) //parse header\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n\n            chr = buf[pos];\n\n            if ((chr == Constants.CR) || (chr == Constants.LF)) {\n                if (chr == Constants.LF) {\n                    pos++;\n                    return false;\n                }\n            } else {\n                break;\n            }\n\n            pos++;\n\n        }\n\n        // Mark the current buffer position\n        int start = pos;\n\n        //\n        // Reading the header name\n        // Header name is always US-ASCII\n        //\n\n        boolean colon = false;\n        MessageBytes headerValue = null;\n\n        while (!colon) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill()) //parse header\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n\n            if (buf[pos] == Constants.COLON) {\n                colon = true;\n                headerValue = headers.addValue(buf, start, pos - start);\n            }\n            chr = buf[pos];\n            if ((chr >= Constants.A) && (chr <= Constants.Z)) {\n                buf[pos] = (byte) (chr - Constants.LC_OFFSET);\n            }\n\n            pos++;\n\n        }\n\n        // Mark the current buffer position\n        start = pos;\n        int realPos = pos;\n\n        //\n        // Reading the header value (which can be spanned over multiple lines)\n        //\n\n        boolean eol = false;\n        boolean validLine = true;\n\n        while (validLine) {\n\n            boolean space = true;\n\n            // Skipping spaces\n            while (space) {\n\n                // Read new bytes if needed\n                if (pos >= lastValid) {\n                    if (!fill()) //parse header\n                        throw new EOFException(sm.getString(\"iib.eof.error\"));\n                }\n\n                if ((buf[pos] == Constants.SP) || (buf[pos] == Constants.HT)) {\n                    pos++;\n                } else {\n                    space = false;\n                }\n\n            }\n\n            int lastSignificantChar = realPos;\n\n            // Reading bytes until the end of the line\n            while (!eol) {\n\n                // Read new bytes if needed\n                if (pos >= lastValid) {\n                    if (!fill()) //parse header\n                        throw new EOFException(sm.getString(\"iib.eof.error\"));\n                }\n\n                if (buf[pos] == Constants.CR) {\n                } else if (buf[pos] == Constants.LF) {\n                    eol = true;\n                } else if (buf[pos] == Constants.SP) {\n                    buf[realPos] = buf[pos];\n                    realPos++;\n                } else {\n                    buf[realPos] = buf[pos];\n                    realPos++;\n                    lastSignificantChar = realPos;\n                }\n\n                pos++;\n\n            }\n\n            realPos = lastSignificantChar;\n\n            // Checking the first character of the new line. If the character\n            // is a LWS, then it's a multiline header\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill()) //parse header\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n\n            chr = buf[pos];\n            if ((chr != Constants.SP) && (chr != Constants.HT)) {\n                validLine = false;\n            } else {\n                eol = false;\n                // Copying one extra space in the buffer (since there must\n                // be at least one space inserted between the lines)\n                buf[realPos] = chr;\n                realPos++;\n            }\n\n        }\n\n        // Set the header value\n        headerValue.setBytes(buf, start, realPos - start);\n\n        return true;\n\n    }","id":81271,"modified_method":"/**\n     * Parse an HTTP header.\n     * \n     * @return false after reading a blank line (which indicates that the\n     * HTTP header parsing is done\n     */\n    public HeaderParseStatus parseHeader()\n        throws IOException {\n\n        //\n        // Check for blank line\n        //\n\n        byte chr = 0;\n        while (headerParsePos == HeaderParsePosition.HEADER_START) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill(true,false)) {//parse header \n                    headerParsePos = HeaderParsePosition.HEADER_START;\n                    return HeaderParseStatus.NEED_MORE_DATA;\n                }\n            }\n\n            chr = buf[pos];\n\n            if ((chr == Constants.CR) || (chr == Constants.LF)) {\n                if (chr == Constants.LF) {\n                    pos++;\n                    return HeaderParseStatus.DONE;\n                }\n            } else {\n                break;\n            }\n\n            pos++;\n\n        }\n\n        if ( headerParsePos == HeaderParsePosition.HEADER_START ) {\n            // Mark the current buffer position\n            headerData.start = pos;\n            headerParsePos = HeaderParsePosition.HEADER_NAME;\n        }    \n\n        //\n        // Reading the header name\n        // Header name is always US-ASCII\n        //\n        \n        \n\n        while (headerParsePos == HeaderParsePosition.HEADER_NAME) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill(true,false)) { //parse header \n                    return HeaderParseStatus.NEED_MORE_DATA;\n                }\n            }\n\n            if (buf[pos] == Constants.COLON) {\n                headerParsePos = HeaderParsePosition.HEADER_VALUE;\n                headerData.headerValue = headers.addValue(buf, headerData.start, pos - headerData.start);\n            }\n            chr = buf[pos];\n            if ((chr >= Constants.A) && (chr <= Constants.Z)) {\n                buf[pos] = (byte) (chr - Constants.LC_OFFSET);\n            }\n\n            pos++;\n            if ( headerParsePos == HeaderParsePosition.HEADER_VALUE ) { \n                // Mark the current buffer position\n                headerData.start = pos;\n                headerData.realPos = pos;\n            }\n        }\n\n        \n        //\n        // Reading the header value (which can be spanned over multiple lines)\n        //\n\n        boolean eol = false;\n\n        while (headerParsePos == HeaderParsePosition.HEADER_VALUE ||\n               headerParsePos == HeaderParsePosition.HEADER_MULTI_LINE) {\n            if ( headerParsePos == HeaderParsePosition.HEADER_VALUE ) {\n            \n                boolean space = true;\n\n                // Skipping spaces\n                while (space) {\n\n                    // Read new bytes if needed\n                    if (pos >= lastValid) {\n                        if (!fill(true,false)) {//parse header \n                            //HEADER_VALUE, should already be set\n                            return HeaderParseStatus.NEED_MORE_DATA;\n                        }\n                    }\n\n                    if ((buf[pos] == Constants.SP) || (buf[pos] == Constants.HT)) {\n                        pos++;\n                    } else {\n                        space = false;\n                    }\n\n                }\n\n                headerData.lastSignificantChar = headerData.realPos;\n\n                // Reading bytes until the end of the line\n                while (!eol) {\n\n                    // Read new bytes if needed\n                    if (pos >= lastValid) {\n                        if (!fill(true,false)) {//parse header \n                            //HEADER_VALUE\n                            return HeaderParseStatus.NEED_MORE_DATA;\n                        }\n\n                    }\n\n                    if (buf[pos] == Constants.CR) {\n                    } else if (buf[pos] == Constants.LF) {\n                        eol = true;\n                    } else if (buf[pos] == Constants.SP) {\n                        buf[headerData.realPos] = buf[pos];\n                        headerData.realPos++;\n                    } else {\n                        buf[headerData.realPos] = buf[pos];\n                        headerData.realPos++;\n                        headerData.lastSignificantChar = headerData.realPos;\n                    }\n\n                    pos++;\n\n                }\n\n                headerData.realPos = headerData.lastSignificantChar;\n\n                // Checking the first character of the new line. If the character\n                // is a LWS, then it's a multiline header\n                headerParsePos = HeaderParsePosition.HEADER_MULTI_LINE;\n            }\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill(true,false)) {//parse header\n                    \n                    //HEADER_MULTI_LINE\n                    return HeaderParseStatus.NEED_MORE_DATA;\n                }\n            }\n\n            chr = buf[pos];\n            if ( headerParsePos == HeaderParsePosition.HEADER_MULTI_LINE ) {\n                if ( (chr != Constants.SP) && (chr != Constants.HT)) {\n                    headerParsePos = HeaderParsePosition.HEADER_START;\n                } else {\n                    eol = false;\n                    // Copying one extra space in the buffer (since there must\n                    // be at least one space inserted between the lines)\n                    buf[headerData.realPos] = chr;\n                    headerData.realPos++;\n                }\n            }\n        }\n        // Set the header value\n        headerData.headerValue.setBytes(buf, headerData.start, headerData.realPos - headerData.start);\n        headerData.recycle();\n        return HeaderParseStatus.HAVE_MORE_HEADERS;\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Recycle the input buffer. This should be called when closing the \n     * connection.\n     */\n    public void recycle() {\n\n        // Recycle Request object\n        request.recycle();\n\n        socket = null;\n        lastValid = 0;\n        pos = 0;\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n    }","id":81272,"modified_method":"/**\n     * Recycle the input buffer. This should be called when closing the \n     * connection.\n     */\n    public void recycle() {\n\n        // Recycle Request object\n        request.recycle();\n\n        socket = null;\n        lastValid = 0;\n        pos = 0;\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        headerData.recycle();\n        swallowInput = true;\n\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * End processing of current HTTP request.\n     * Note: All bytes of the current request should have been already \n     * consumed. This method only resets all the pointers so that we are ready\n     * to parse the next HTTP request.\n     */\n    public void nextRequest() {\n\n        // Recycle Request object\n        request.recycle();\n\n        //System.out.println(\"LV-pos: \" + (lastValid - pos));\n        // Copy leftover bytes to the beginning of the buffer\n        if (lastValid - pos > 0) {\n            int npos = 0;\n            int opos = pos;\n            while (lastValid - opos > opos - npos) {\n                System.arraycopy(buf, opos, buf, npos, opos - npos);\n                npos += pos;\n                opos += pos;\n            }\n            System.arraycopy(buf, opos, buf, npos, lastValid - opos);\n        }\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastValid = lastValid - pos;\n        pos = 0;\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n    }","id":81273,"modified_method":"/**\n     * End processing of current HTTP request.\n     * Note: All bytes of the current request should have been already \n     * consumed. This method only resets all the pointers so that we are ready\n     * to parse the next HTTP request.\n     */\n    public void nextRequest() {\n\n        // Recycle Request object\n        request.recycle();\n\n        //System.out.println(\"LV-pos: \" + (lastValid - pos));\n        // Copy leftover bytes to the beginning of the buffer\n        if (lastValid - pos > 0) {\n            int npos = 0;\n            int opos = pos;\n            while (lastValid - opos > opos - npos) {\n                System.arraycopy(buf, opos, buf, npos, opos - npos);\n                npos += pos;\n                opos += pos;\n            }\n            System.arraycopy(buf, opos, buf, npos, lastValid - opos);\n        }\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastValid = lastValid - pos;\n        pos = 0;\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        headerData.recycle();\n        swallowInput = true;\n\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Parse the HTTP headers.\n     */\n    public void parseHeaders()\n        throws IOException {\n\n        while (parseHeader()) {\n        }\n\n        parsingHeader = false;\n        end = pos;\n\n    }","id":81274,"modified_method":"/**\n     * Parse the HTTP headers.\n     */\n    public boolean parseHeaders()\n        throws IOException {\n        HeaderParseStatus status = HeaderParseStatus.HAVE_MORE_HEADERS;\n        \n        do {\n            status = parseHeader();\n        } while ( status == HeaderParseStatus.HAVE_MORE_HEADERS );\n        if (status == HeaderParseStatus.DONE) {\n            parsingHeader = false;\n            end = pos;\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Read the request line. This function is meant to be used during the \n     * HTTP request header parsing. Do NOT attempt to read the request body \n     * using it.\n     *\n     * @throws IOException If an exception occurs during the underlying socket\n     * read operations, or if the given buffer is not big enough to accomodate\n     * the whole line.\n     * @return true if data is properly fed; false if no data is available \n     * immediately and thread should be freed\n     */\n    public boolean parseRequestLine(boolean useAvailableData)\n        throws IOException {\n\n        int start = 0;\n\n        //\n        // Skipping blank lines\n        //\n\n        byte chr = 0;\n        do {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (useAvailableData) {\n                    return false;\n                }\n                if (readTimeout == -1) {\n                    if (!fill()) //request line parsing\n                        throw new EOFException(sm.getString(\"iib.eof.error\"));\n                } else {\n                    // Do a simple read with a short timeout\n                    if ( !readSocket(true, false) ) return false;\n                }\n            }\n\n            chr = buf[pos++];\n\n        } while ((chr == Constants.CR) || (chr == Constants.LF));\n\n        pos--;\n\n        // Mark the current buffer position\n        start = pos;\n\n        if (pos >= lastValid) {\n            if (useAvailableData) {\n                return false;\n            }\n            if (readTimeout == -1) {\n                if (!fill()) //request line parsing\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            } else {\n                // Do a simple read with a short timeout\n                if ( !readSocket(true, false) ) return false;\n            }\n        }\n\n        //\n        // Reading the method name\n        // Method name is always US-ASCII\n        //\n\n        boolean space = false;\n\n        while (!space) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill()) //request line parsing\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n\n            if (buf[pos] == Constants.SP) {\n                space = true;\n                request.method().setBytes(buf, start, pos - start);\n            }\n\n            pos++;\n\n        }\n\n        // Mark the current buffer position\n        start = pos;\n        int end = 0;\n        int questionPos = -1;\n\n        //\n        // Reading the URI\n        //\n\n        space = false;\n        boolean eol = false;\n\n        while (!space) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill()) //request line parsing\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n\n            if (buf[pos] == Constants.SP) {\n                space = true;\n                end = pos;\n            } else if ((buf[pos] == Constants.CR) \n                       || (buf[pos] == Constants.LF)) {\n                // HTTP/0.9 style request\n                eol = true;\n                space = true;\n                end = pos;\n            } else if ((buf[pos] == Constants.QUESTION) \n                       && (questionPos == -1)) {\n                questionPos = pos;\n            }\n\n            pos++;\n\n        }\n\n        request.unparsedURI().setBytes(buf, start, end - start);\n        if (questionPos >= 0) {\n            request.queryString().setBytes(buf, questionPos + 1, \n                                           end - questionPos - 1);\n            request.requestURI().setBytes(buf, start, questionPos - start);\n        } else {\n            request.requestURI().setBytes(buf, start, end - start);\n        }\n\n        // Mark the current buffer position\n        start = pos;\n        end = 0;\n\n        //\n        // Reading the protocol\n        // Protocol is always US-ASCII\n        //\n\n        while (!eol) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill()) //reques line parsing\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n\n            if (buf[pos] == Constants.CR) {\n                end = pos;\n            } else if (buf[pos] == Constants.LF) {\n                if (end == 0)\n                    end = pos;\n                eol = true;\n            }\n\n            pos++;\n\n        }\n\n        if ((end - start) > 0) {\n            request.protocol().setBytes(buf, start, end - start);\n        } else {\n            request.protocol().setString(\"\");\n        }\n\n        return true;\n\n    }","id":81275,"modified_method":"/**\n     * Read the request line. This function is meant to be used during the \n     * HTTP request header parsing. Do NOT attempt to read the request body \n     * using it.\n     *\n     * @throws IOException If an exception occurs during the underlying socket\n     * read operations, or if the given buffer is not big enough to accomodate\n     * the whole line.\n     * @return true if data is properly fed; false if no data is available \n     * immediately and thread should be freed\n     */\n    public boolean parseRequestLine(boolean useAvailableData)\n        throws IOException {\n\n        //check state\n        if ( !parsingRequestLine ) return true;\n        \n        int start = 0;\n\n        //\n        // Skipping blank lines\n        //\n\n        byte chr = 0;\n        do {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (useAvailableData) {\n                    return false;\n                }\n                if (readTimeout == -1) {\n                    if (!fill(false,true)) //request line parsing\n                        throw new EOFException(sm.getString(\"iib.eof.error\"));\n                } else {\n                    // Do a simple read with a short timeout\n                    if ( !readSocket(true, false) ) return false;\n                }\n            }\n\n            chr = buf[pos++];\n\n        } while ((chr == Constants.CR) || (chr == Constants.LF));\n\n        pos--;\n\n        // Mark the current buffer position\n        start = pos;\n\n        if (pos >= lastValid) {\n            if (useAvailableData) {\n                return false;\n            }\n            if (readTimeout == -1) {\n                if (!fill(false,false)) //request line parsing\n                    return false;\n            } else {\n                // Do a simple read with a short timeout\n                if ( !readSocket(true, false) ) return false;\n            }\n        }\n\n        //\n        // Reading the method name\n        // Method name is always US-ASCII\n        //\n\n        boolean space = false;\n\n        while (!space) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill(true,false)) //request line parsing\n                    return false;\n            }\n\n            if (buf[pos] == Constants.SP) {\n                space = true;\n                request.method().setBytes(buf, start, pos - start);\n            }\n\n            pos++;\n\n        }\n\n        // Mark the current buffer position\n        start = pos;\n        int end = 0;\n        int questionPos = -1;\n\n        //\n        // Reading the URI\n        //\n\n        space = false;\n        boolean eol = false;\n\n        while (!space) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill(true,false)) //request line parsing\n                    return false;\n            }\n\n            if (buf[pos] == Constants.SP) {\n                space = true;\n                end = pos;\n            } else if ((buf[pos] == Constants.CR) \n                       || (buf[pos] == Constants.LF)) {\n                // HTTP/0.9 style request\n                eol = true;\n                space = true;\n                end = pos;\n            } else if ((buf[pos] == Constants.QUESTION) \n                       && (questionPos == -1)) {\n                questionPos = pos;\n            }\n\n            pos++;\n\n        }\n\n        request.unparsedURI().setBytes(buf, start, end - start);\n        if (questionPos >= 0) {\n            request.queryString().setBytes(buf, questionPos + 1, \n                                           end - questionPos - 1);\n            request.requestURI().setBytes(buf, start, questionPos - start);\n        } else {\n            request.requestURI().setBytes(buf, start, end - start);\n        }\n\n        // Mark the current buffer position\n        start = pos;\n        end = 0;\n\n        //\n        // Reading the protocol\n        // Protocol is always US-ASCII\n        //\n\n        while (!eol) {\n\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill(true,false)) //reques line parsing\n                    return false;\n            }\n\n            if (buf[pos] == Constants.CR) {\n                end = pos;\n            } else if (buf[pos] == Constants.LF) {\n                if (end == 0)\n                    end = pos;\n                eol = true;\n            }\n\n            pos++;\n\n        }\n\n        if ((end - start) > 0) {\n            request.protocol().setBytes(buf, start, end - start);\n        } else {\n            request.protocol().setString(\"\");\n        }\n        parsingRequestLine = false;\n        return true;\n\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Perform blocking read with a timeout if desired\n     * @param timeout boolean - if we want to use the timeout data\n     * @param block - true if the system should perform a blocking read, false otherwise\n     * @return boolean - true if data was read, false is no data read, EOFException if EOF is reached\n     * @throws IOException if a socket exception occurs\n     * @throws EOFException if end of stream is reached\n     */\n    private boolean readSocket(boolean timeout, boolean block) throws IOException {\n        int nRead = 0;\n        long start = System.currentTimeMillis();\n        boolean timedOut = false;\n        do {\n            \n            socket.getBufHandler().getReadBuffer().clear();\n            nRead = socket.read(socket.getBufHandler().getReadBuffer());\n            if (nRead > 0) {\n                socket.getBufHandler().getReadBuffer().flip();\n                socket.getBufHandler().getReadBuffer().limit(nRead);\n                expand(nRead + pos);\n                socket.getBufHandler().getReadBuffer().get(buf, pos, nRead);\n                lastValid = pos + nRead;\n                return true;\n            } else if (nRead == -1) {\n                //return false;\n                throw new EOFException(sm.getString(\"iib.eof.error\"));\n            } else if ( !block ) {\n                return false;\n            } else {\n                timedOut = (readTimeout != -1) && ((System.currentTimeMillis()-start)>readTimeout);\n                if ( !timedOut && nRead == 0 )  {\n                    try {\n                        final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n                        final KeyAttachment att = (KeyAttachment)key.attachment();\n                        //to do, add in a check, we might have just timed out on the wait,\n                        //so there is no need to register us again.\n                        boolean addToQueue = false;\n                        try { addToQueue = ((att.interestOps()&SelectionKey.OP_READ) != SelectionKey.OP_READ); } catch ( CancelledKeyException ckx ){ throw new IOException(\"Socket key cancelled.\");}\n                        if ( addToQueue ) {\n                            synchronized (att.getMutex()) {\n                                addToReadQueue(key, att);\n                                att.getMutex().wait(readTimeout);\n                            }\n                        }//end if\n                    }catch ( Exception x ) {}\n                }\n             }\n        }while ( nRead == 0 && (!timedOut) );\n        //else throw new IOException(sm.getString(\"iib.failedread\"));\n        //return false; //timeout\n        throw new IOException(\"read timed out.\");\n    }","id":81276,"modified_method":"/**\n     * Perform blocking read with a timeout if desired\n     * @param timeout boolean - if we want to use the timeout data\n     * @param block - true if the system should perform a blocking read, false otherwise\n     * @return boolean - true if data was read, false is no data read, EOFException if EOF is reached\n     * @throws IOException if a socket exception occurs\n     * @throws EOFException if end of stream is reached\n     */\n    private boolean readSocket(boolean timeout, boolean block) throws IOException {\n        int nRead = 0;\n        long start = System.currentTimeMillis();\n        boolean timedOut = false;\n        do {\n            \n            socket.getBufHandler().getReadBuffer().clear();\n            nRead = socket.read(socket.getBufHandler().getReadBuffer());\n            if (nRead > 0) {\n                socket.getBufHandler().getReadBuffer().flip();\n                socket.getBufHandler().getReadBuffer().limit(nRead);\n                expand(nRead + pos);\n                socket.getBufHandler().getReadBuffer().get(buf, pos, nRead);\n                lastValid = pos + nRead;\n                return true;\n            } else if (nRead == -1) {\n                //return false;\n                throw new EOFException(sm.getString(\"iib.eof.error\"));\n            } else if ( !block ) {\n                return false;\n            } else {\n                timedOut = timeout && (readTimeout != -1) && ((System.currentTimeMillis()-start)>readTimeout);\n                if ( !timedOut && nRead == 0 )  {\n                    try {\n                        final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n                        final KeyAttachment att = (KeyAttachment)key.attachment();\n                        //to do, add in a check, we might have just timed out on the wait,\n                        //so there is no need to register us again.\n                        boolean addToQueue = false;\n                        try { addToQueue = ((att.interestOps()&SelectionKey.OP_READ) != SelectionKey.OP_READ); } catch ( CancelledKeyException ckx ){ throw new IOException(\"Socket key cancelled.\");}\n                        if ( addToQueue ) {\n                            synchronized (att.getMutex()) {\n                                addToReadQueue(key, att);\n                                att.getMutex().wait(readTimeout);\n                            }\n                        }//end if\n                    }catch ( Exception x ) {}\n                }\n             }\n        }while ( nRead == 0 && (!timedOut) );\n        //else throw new IOException(sm.getString(\"iib.failedread\"));\n        //return false; //timeout\n        throw new IOException(\"read timed out.\");\n    }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n         * Read bytes into the specified chunk.\n         */\n        public int doRead(ByteChunk chunk, Request req ) \n            throws IOException {\n\n            if (pos >= lastValid) {\n                if (!fill()) //read body\n                    return -1;\n            }\n\n            int length = lastValid - pos;\n            chunk.setBytes(buf, pos, length);\n            pos = lastValid;\n\n            return (length);\n\n        }","id":81277,"modified_method":"/**\n         * Read bytes into the specified chunk.\n         */\n        public int doRead(ByteChunk chunk, Request req ) \n            throws IOException {\n\n            if (pos >= lastValid) {\n                if (!fill(true,true)) //read body, must be blocking, as the thread is inside the app\n                    return -1;\n            }\n\n            int length = lastValid - pos;\n            chunk.setBytes(buf, pos, length);\n            pos = lastValid;\n\n            return (length);\n\n        }","commit_id":"ebb47b6b1fbec3ae28fec73be084a0e1cafcfa3d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        long socketRef = socketWrapper.getSocket().longValue();\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n                \n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    inputBuffer.parseHeaders();\n                    if (!disableUploadTimeout) {\n                        Socket.timeoutSet(socketRef,\n                                connectionUploadTimeout * 1000);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) {\n                Socket.timeoutSet(socketRef, endpoint.getSoTimeout() * 1000);\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet  || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","id":81278,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        long socketRef = socketWrapper.getSocket().longValue();\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n                \n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    // Currently only NIO will ever return false here\n                    if (!inputBuffer.parseHeaders()) {\n                        // We've read part of the request, don't recycle it\n                        // instead associate it with the socket\n                        openSocket = true;\n                        readComplete = false;\n                        break;\n                    }\n                    if (!disableUploadTimeout) {\n                        Socket.timeoutSet(socketRef,\n                                connectionUploadTimeout * 1000);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) {\n                Socket.timeoutSet(socketRef, endpoint.getSoTimeout() * 1000);\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet  || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"10a4cdecefc0f1fcddb13bcc5207eb44514d2311","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Socket> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the I/O\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n\n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    // Reset timeout for reading headers\n                    socket.getSocket().setSoTimeout(endpoint.getSoTimeout());\n                    inputBuffer.parseHeaders();\n                    if (!disableUploadTimeout) {\n                        socket.getSocket().setSoTimeout(connectionUploadTimeout);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if(!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            // Next request\n            if (!isAsync() || error) {\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) {\n                socket.getSocket().setSoTimeout(endpoint.getSoTimeout());\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","id":81279,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Socket> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the I/O\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n\n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    // Reset timeout for reading headers\n                    socket.getSocket().setSoTimeout(endpoint.getSoTimeout());\n                    // Currently only NIO will ever return false here\n                    if (!inputBuffer.parseHeaders()) {\n                        // We've read part of the request, don't recycle it\n                        // instead associate it with the socket\n                        openSocket = true;\n                        readComplete = false;\n                        break;\n                    }\n                    if (!disableUploadTimeout) {\n                        socket.getSocket().setSoTimeout(connectionUploadTimeout);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if(!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            // Next request\n            if (!isAsync() || error) {\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) {\n                socket.getSocket().setSoTimeout(endpoint.getSoTimeout());\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"10a4cdecefc0f1fcddb13bcc5207eb44514d2311","url":"https://github.com/apache/tomcat"},{"original_method":"public void testSimulate() throws Exception {\n        new PutPipelineRequestBuilder(client(), PutPipelineAction.INSTANCE)\n                .setId(\"_id\")\n                .setSource(jsonBuilder().startObject()\n                        .field(\"description\", \"my_pipeline\")\n                        .startArray(\"processors\")\n                        .startObject()\n                        .startObject(\"grok\")\n                        .field(\"field\", \"field1\")\n                        .field(\"pattern\", \"%{NUMBER:val:float} %{NUMBER:status:int} <%{WORD:msg}>\")\n                        .endObject()\n                        .endObject()\n                        .endArray()\n                        .endObject().bytes())\n                .get();\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                GetPipelineResponse response = new GetPipelineRequestBuilder(client(), GetPipelineAction.INSTANCE)\n                        .setIds(\"_id\")\n                        .get();\n                assertThat(response.isFound(), is(true));\n                assertThat(response.pipelines().get(\"_id\"), notNullValue());\n            }\n        });\n\n        SimulatePipelineResponse response = new SimulatePipelineRequestBuilder(client(), SimulatePipelineAction.INSTANCE)\n                .setId(\"_id\")\n                .setSource(jsonBuilder().startObject()\n                        .startArray(\"docs\")\n                        .startObject()\n                        .field(\"_index\", \"index\")\n                        .field(\"_type\", \"type\")\n                        .field(\"_id\", \"id\")\n                        .startObject(\"_source\")\n                        .field(\"foo\", \"bar\")\n                        .endObject()\n                        .endObject()\n                        .endArray()\n                        .endObject().bytes())\n                .get();\n\n        Map<String, Object> expectedDoc = new HashMap<>();\n        expectedDoc.put(\"foo\", \"bar\");\n        Data expectedData = new Data(\"index\", \"type\", \"id\", expectedDoc);\n        SimulateDocumentResult expectedResponse = new SimulateSimpleDocumentResult(expectedData);\n        List<SimulateDocumentResult> expectedResponses = Arrays.asList(expectedResponse);\n        SimulatePipelineResponse expected = new SimulatePipelineResponse(\"_id\", expectedResponses);\n\n        assertThat(response, equalTo(expected));\n    }","id":81280,"modified_method":"public void testSimulate() throws Exception {\n        new PutPipelineRequestBuilder(client(), PutPipelineAction.INSTANCE)\n                .setId(\"_id\")\n                .setSource(jsonBuilder().startObject()\n                        .field(\"description\", \"my_pipeline\")\n                        .startArray(\"processors\")\n                        .startObject()\n                        .startObject(\"grok\")\n                        .field(\"field\", \"field1\")\n                        .field(\"pattern\", \"%{NUMBER:val:float} %{NUMBER:status:int} <%{WORD:msg}>\")\n                        .endObject()\n                        .endObject()\n                        .endArray()\n                        .endObject().bytes())\n                .get();\n        assertBusy(new Runnable() {\n            @Override\n            public void run() {\n                GetPipelineResponse response = new GetPipelineRequestBuilder(client(), GetPipelineAction.INSTANCE)\n                        .setIds(\"_id\")\n                        .get();\n                assertThat(response.isFound(), is(true));\n                assertThat(response.pipelines().get(\"_id\"), notNullValue());\n            }\n        });\n\n        SimulatePipelineResponse response = new SimulatePipelineRequestBuilder(client(), SimulatePipelineAction.INSTANCE)\n                .setId(\"_id\")\n                .setSource(jsonBuilder().startObject()\n                        .startArray(\"docs\")\n                        .startObject()\n                        .field(\"_index\", \"index\")\n                        .field(\"_type\", \"type\")\n                        .field(\"_id\", \"id\")\n                        .startObject(\"_source\")\n                        .field(\"foo\", \"bar\")\n                        .endObject()\n                        .endObject()\n                        .endArray()\n                        .endObject().bytes())\n                .get();\n\n        assertThat(response.isVerbose(), equalTo(false));\n        assertThat(response.getPipelineId(), equalTo(\"_id\"));\n        assertThat(response.getResults().size(), equalTo(1));\n        assertThat(response.getResults().get(0), instanceOf(SimulateDocumentSimpleResult.class));\n        SimulateDocumentSimpleResult simulateDocumentSimpleResult = (SimulateDocumentSimpleResult) response.getResults().get(0);\n        Data expectedData = new Data(\"index\", \"type\", \"id\", Collections.singletonMap(\"foo\", \"bar\"));\n        assertThat(simulateDocumentSimpleResult.getData(), equalTo(expectedData));\n        assertThat(simulateDocumentSimpleResult.getFailure(), nullValue());\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void execute(ParsedSimulateRequest request, ActionListener<SimulatePipelineResponse> listener) {\n        threadPool.executor(THREAD_POOL_NAME).execute(new Runnable() {\n            @Override\n            public void run() {\n                List<SimulateDocumentResult> responses = new ArrayList<>();\n                for (Data data : request.getDocuments()) {\n                    if (request.isVerbose()) {\n                        responses.add(executeVerboseItem(request.getPipeline(), data));\n                    } else {\n                        responses.add(executeItem(request.getPipeline(), data));\n                    }\n                }\n                listener.onResponse(new SimulatePipelineResponse(request.getPipeline().getId(), responses));\n            }\n        });\n    }","id":81281,"modified_method":"public void execute(ParsedSimulateRequest request, ActionListener<SimulatePipelineResponse> listener) {\n        threadPool.executor(THREAD_POOL_NAME).execute(new Runnable() {\n            @Override\n            public void run() {\n                List<SimulateDocumentResult> responses = new ArrayList<>();\n                for (Data data : request.getDocuments()) {\n                    if (request.isVerbose()) {\n                        responses.add(executeVerboseItem(request.getPipeline(), data));\n                    } else {\n                        responses.add(executeItem(request.getPipeline(), data));\n                    }\n                }\n                listener.onResponse(new SimulatePipelineResponse(request.getPipeline().getId(), request.isVerbose(), responses));\n            }\n        });\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"SimulateDocumentResult executeVerboseItem(Pipeline pipeline, Data data) {\n        List<SimulateProcessorResult> processorResultList = new ArrayList<>();\n        Data currentData = new Data(data);\n        for (int i = 0; i < pipeline.getProcessors().size(); i++) {\n            Processor processor = pipeline.getProcessors().get(i);\n            String processorId = \"processor[\" + processor.getType() + \"]-\" + i;\n\n            try {\n                processor.execute(currentData);\n                processorResultList.add(new SimulateProcessorResult(processorId, currentData));\n            } catch (Exception e) {\n                processorResultList.add(new SimulateProcessorResult(processorId, e));\n            }\n\n            currentData = new Data(currentData);\n        }\n        return new SimulateVerboseDocumentResult(processorResultList);\n    }","id":81282,"modified_method":"SimulateDocumentVerboseResult executeVerboseItem(Pipeline pipeline, Data data) {\n        List<SimulateProcessorResult> processorResultList = new ArrayList<>();\n        Data currentData = new Data(data);\n        for (int i = 0; i < pipeline.getProcessors().size(); i++) {\n            Processor processor = pipeline.getProcessors().get(i);\n            String processorId = \"processor[\" + processor.getType() + \"]-\" + i;\n\n            try {\n                processor.execute(currentData);\n                processorResultList.add(new SimulateProcessorResult(processorId, currentData));\n            } catch (Exception e) {\n                processorResultList.add(new SimulateProcessorResult(processorId, e));\n            }\n\n            currentData = new Data(currentData);\n        }\n        return new SimulateDocumentVerboseResult(processorResultList);\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"SimulateDocumentResult executeItem(Pipeline pipeline, Data data) {\n        try {\n            pipeline.execute(data);\n            return new SimulateSimpleDocumentResult(data);\n        } catch (Exception e) {\n            return new SimulateFailedDocumentResult(e);\n        }\n\n    }","id":81283,"modified_method":"SimulateDocumentResult executeItem(Pipeline pipeline, Data data) {\n        try {\n            pipeline.execute(data);\n            return new SimulateDocumentSimpleResult(data);\n        } catch (Exception e) {\n            return new SimulateDocumentSimpleResult(e);\n        }\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testExecuteItemWithFailure() throws Exception {\n        Exception e = new RuntimeException(\"processor failed\");\n        SimulateDocumentResult expectedItemResponse = new SimulateFailedDocumentResult(e);\n        doThrow(e).when(processor).execute(data);\n        SimulateDocumentResult actualItemResponse = executionService.executeItem(pipeline, data);\n        verify(processor, times(1)).execute(data);\n        assertThat(actualItemResponse, equalTo(expectedItemResponse));\n    }","id":81284,"modified_method":"public void testExecuteItemWithFailure() throws Exception {\n        Exception e = new RuntimeException(\"processor failed\");\n        doThrow(e).when(processor).execute(data);\n        SimulateDocumentResult actualItemResponse = executionService.executeItem(pipeline, data);\n        verify(processor, times(1)).execute(data);\n        assertThat(actualItemResponse, instanceOf(SimulateDocumentSimpleResult.class));\n        SimulateDocumentSimpleResult simulateDocumentSimpleResult = (SimulateDocumentSimpleResult) actualItemResponse;\n        assertThat(simulateDocumentSimpleResult.getData(), nullValue());\n        assertThat(simulateDocumentSimpleResult.getFailure(), instanceOf(RuntimeException.class));\n        RuntimeException runtimeException = (RuntimeException) simulateDocumentSimpleResult.getFailure();\n        assertThat(runtimeException.getMessage(), equalTo(\"processor failed\"));\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testExecuteVerboseItemWithFailure() throws Exception {\n        Exception e = new RuntimeException(\"processor failed\");\n        SimulateDocumentResult expectedItemResponse = new SimulateVerboseDocumentResult(\n                Arrays.asList(new SimulateProcessorResult(\"processor[mock]-0\", e), new SimulateProcessorResult(\"processor[mock]-1\", data))\n        );\n        doThrow(e).doNothing().when(processor).execute(data);\n        SimulateDocumentResult actualItemResponse = executionService.executeVerboseItem(pipeline, data);\n        verify(processor, times(2)).execute(data);\n        assertThat(actualItemResponse, equalTo(expectedItemResponse));\n    }","id":81285,"modified_method":"public void testExecuteVerboseItemWithFailure() throws Exception {\n        Exception e = new RuntimeException(\"processor failed\");\n        doThrow(e).doNothing().when(processor).execute(data);\n        SimulateDocumentResult actualItemResponse = executionService.executeVerboseItem(pipeline, data);\n        verify(processor, times(2)).execute(data);\n        assertThat(actualItemResponse, instanceOf(SimulateDocumentVerboseResult.class));\n        SimulateDocumentVerboseResult simulateDocumentVerboseResult = (SimulateDocumentVerboseResult) actualItemResponse;\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().size(), equalTo(2));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getProcessorId(), equalTo(\"processor[mock]-0\"));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getData(), nullValue());\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getFailure(), instanceOf(RuntimeException.class));\n        RuntimeException runtimeException = (RuntimeException) simulateDocumentVerboseResult.getProcessorResults().get(0).getFailure();\n        assertThat(runtimeException.getMessage(), equalTo(\"processor failed\"));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getProcessorId(), equalTo(\"processor[mock]-1\"));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getData(), not(sameInstance(data)));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getData(), equalTo(data));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getFailure(), nullValue());\n        runtimeException = (RuntimeException) simulateDocumentVerboseResult.getProcessorResults().get(0).getFailure();\n        assertThat(runtimeException.getMessage(), equalTo(\"processor failed\"));\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testExecuteVerboseItem() throws Exception {\n        SimulateDocumentResult expectedItemResponse = new SimulateVerboseDocumentResult(\n                Arrays.asList(new SimulateProcessorResult(\"processor[mock]-0\", data), new SimulateProcessorResult(\"processor[mock]-1\", data)));\n        SimulateDocumentResult actualItemResponse = executionService.executeVerboseItem(pipeline, data);\n        verify(processor, times(2)).execute(data);\n        assertThat(actualItemResponse, equalTo(expectedItemResponse));\n    }","id":81286,"modified_method":"public void testExecuteVerboseItem() throws Exception {\n        SimulateDocumentResult actualItemResponse = executionService.executeVerboseItem(pipeline, data);\n        verify(processor, times(2)).execute(data);\n        assertThat(actualItemResponse, instanceOf(SimulateDocumentVerboseResult.class));\n        SimulateDocumentVerboseResult simulateDocumentVerboseResult = (SimulateDocumentVerboseResult) actualItemResponse;\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().size(), equalTo(2));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getProcessorId(), equalTo(\"processor[mock]-0\"));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getData(), not(sameInstance(data)));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getData(), equalTo(data));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(0).getFailure(), nullValue());\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getProcessorId(), equalTo(\"processor[mock]-1\"));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getData(), not(sameInstance(data)));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getData(), equalTo(data));\n        assertThat(simulateDocumentVerboseResult.getProcessorResults().get(1).getFailure(), nullValue());\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void setup() {\n        threadPool = new ThreadPool(\n                Settings.builder()\n                        .put(\"name\", getClass().getName())\n                        .build()\n        );\n        executionService = new SimulateExecutionService(threadPool);\n        processor = mock(Processor.class);\n        when(processor.getType()).thenReturn(\"mock\");\n        pipeline = new Pipeline(\"_id\", \"_description\", Arrays.asList(processor, processor));\n        data = new Data(\"_index\", \"_type\", \"_id\", Collections.singletonMap(\"foo\", \"bar\"));\n        transportData = new TransportData(data);\n        listener = mock(ActionListener.class);\n    }","id":81287,"modified_method":"@Before\n    public void setup() {\n        threadPool = new ThreadPool(\n                Settings.builder()\n                        .put(\"name\", getClass().getName())\n                        .build()\n        );\n        executionService = new SimulateExecutionService(threadPool);\n        processor = mock(Processor.class);\n        when(processor.getType()).thenReturn(\"mock\");\n        pipeline = new Pipeline(\"_id\", \"_description\", Arrays.asList(processor, processor));\n        data = new Data(\"_index\", \"_type\", \"_id\", Collections.singletonMap(\"foo\", \"bar\"));\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testExecuteItem() throws Exception {\n        SimulateDocumentResult expectedItemResponse = new SimulateSimpleDocumentResult(data);\n        SimulateDocumentResult actualItemResponse = executionService.executeItem(pipeline, data);\n        verify(processor, times(2)).execute(data);\n        assertThat(actualItemResponse, equalTo(expectedItemResponse));\n    }","id":81288,"modified_method":"public void testExecuteItem() throws Exception {\n        SimulateDocumentResult actualItemResponse = executionService.executeItem(pipeline, data);\n        verify(processor, times(2)).execute(data);\n        assertThat(actualItemResponse, instanceOf(SimulateDocumentSimpleResult.class));\n        SimulateDocumentSimpleResult simulateDocumentSimpleResult = (SimulateDocumentSimpleResult) actualItemResponse;\n        assertThat(simulateDocumentSimpleResult.getData(), equalTo(data));\n        assertThat(simulateDocumentSimpleResult.getFailure(), nullValue());\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SimulatePipelineResponse(String pipelineId, List<SimulateDocumentResult> responses) {\n        this.pipelineId = pipelineId;\n        this.results = Collections.unmodifiableList(responses);\n    }","id":81289,"modified_method":"public SimulatePipelineResponse(String pipelineId, boolean verbose, List<SimulateDocumentResult> responses) {\n        this.pipelineId = pipelineId;\n        this.verbose = verbose;\n        this.results = Collections.unmodifiableList(responses);\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        this.pipelineId = in.readString();\n        int responsesLength = in.readVInt();\n        results = new ArrayList<>();\n        for (int i = 0; i < responsesLength; i++) {\n            SimulateDocumentResult result;\n            switch (in.readVInt()) {\n                case SimulateSimpleDocumentResult.STREAM_ID:\n                    result = new SimulateSimpleDocumentResult();\n                    break;\n                case SimulateVerboseDocumentResult.STREAM_ID:\n                    result = new SimulateVerboseDocumentResult();\n                    break;\n                case SimulateFailedDocumentResult.STREAM_ID:\n                    result = new SimulateFailedDocumentResult();\n                    break;\n                default:\n                    throw new IOException(\"Cannot read result from stream\");\n            }\n            result.readFrom(in);\n            results.add(result);\n        }\n\n    }","id":81290,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        this.pipelineId = in.readString();\n        boolean verbose = in.readBoolean();\n        int responsesLength = in.readVInt();\n        results = new ArrayList<>();\n        for (int i = 0; i < responsesLength; i++) {\n            SimulateDocumentResult<?> simulateDocumentResult;\n            if (verbose) {\n                simulateDocumentResult = SimulateDocumentVerboseResult.readSimulateDocumentVerboseResultFrom(in);\n            } else {\n                simulateDocumentResult = SimulateDocumentSimpleResult.readSimulateDocumentSimpleResult(in);\n            }\n            results.add(simulateDocumentResult);\n        }\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeString(pipelineId);\n        out.writeVInt(results.size());\n        for (SimulateDocumentResult response : results) {\n            out.writeVInt(response.getStreamId());\n            response.writeTo(out);\n        }\n    }","id":81291,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeString(pipelineId);\n        out.writeBoolean(verbose);\n        out.writeVInt(results.size());\n        for (SimulateDocumentResult response : results) {\n            response.writeTo(out);\n        }\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeBoolean(isFailed());\n        out.writeString(processorId);\n        if (isFailed()) {\n            out.writeThrowable(failure);\n        } else {\n            data.writeTo(out);\n        }\n    }","id":81292,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeString(processorId);\n        if (failure == null) {\n            out.writeBoolean(false);\n            data.writeTo(out);\n        } else {\n            out.writeBoolean(true);\n            out.writeThrowable(failure);\n        }\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        boolean isFailure = in.readBoolean();\n        this.processorId = in.readString();\n        if (isFailure) {\n            this.failure = in.readThrowable();\n        } else {\n            this.data = new TransportData();\n            this.data.readFrom(in);\n        }\n    }","id":81293,"modified_method":"@Override\n    public SimulateProcessorResult readFrom(StreamInput in) throws IOException {\n        String processorId = in.readString();\n        if (in.readBoolean()) {\n            Exception exception = in.readThrowable();\n            return new SimulateProcessorResult(processorId, exception);\n        }\n        return new SimulateProcessorResult(processorId, TransportData.readTransportDataFrom(in));\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Data getData() {\n        return data.get();\n    }","id":81294,"modified_method":"public Data getData() {\n        if (data == null) {\n            return null;\n        }\n        return data.get();\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SimulateProcessorResult(String processorId, Throwable failure) {\n        this.processorId = processorId;\n        this.failure = failure;\n    }","id":81295,"modified_method":"public SimulateProcessorResult(String processorId, Exception failure) {\n        this.processorId = processorId;\n        this.failure = failure;\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SimulateProcessorResult() {\n\n    }","id":81296,"modified_method":"private SimulateProcessorResult(String processorId, TransportData data) {\n        this.processorId = processorId;\n        this.data = data;\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject();\n        builder.field(Fields.PROCESSOR_ID, processorId);\n        if (isFailed()) {\n            ElasticsearchException.renderThrowable(builder, params, failure);\n        } else {\n            data.toXContent(builder, params);\n        }\n        builder.endObject();\n        return builder;\n    }","id":81297,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject();\n        builder.field(Fields.PROCESSOR_ID, processorId);\n        if (failure == null) {\n            data.toXContent(builder, params);\n        } else {\n            ElasticsearchException.renderThrowable(builder, params, failure);\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        String index = in.readString();\n        String type = in.readString();\n        String id = in.readString();\n        Map<String, Object> doc = in.readMap();\n        this.data = new Data(index, type, id, doc);\n    }","id":81298,"modified_method":"@Override\n    public TransportData readFrom(StreamInput in) throws IOException {\n        String index = in.readString();\n        String type = in.readString();\n        String id = in.readString();\n        Map<String, Object> doc = in.readMap();\n        return new TransportData(new Data(index, type, id, doc));\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testEquals() throws Exception {\n        Data data = new Data(\"_index\", \"_type\", \"_id\", Collections.singletonMap(\"foo\", \"bar\"));\n        Data otherData = new Data(\"_index\", \"_type\", \"_id\", Collections.singletonMap(\"foo\", \"bar\"));\n        assertThat(data, equalTo(otherData));\n    }","id":81299,"modified_method":"public void testEqualsAndHashcode() throws Exception {\n        String index = randomAsciiOfLengthBetween(1, 10);\n        String type = randomAsciiOfLengthBetween(1, 10);\n        String id = randomAsciiOfLengthBetween(1, 10);\n        String fieldName = randomAsciiOfLengthBetween(1, 10);\n        String fieldValue = randomAsciiOfLengthBetween(1, 10);\n        Data data = new Data(index, type, id, Collections.singletonMap(fieldName, fieldValue));\n        TransportData transportData = new TransportData(data);\n\n        boolean changed = false;\n        String otherIndex;\n        if (randomBoolean()) {\n            otherIndex = randomAsciiOfLengthBetween(1, 10);\n            changed = true;\n        } else {\n            otherIndex = index;\n        }\n        String otherType;\n        if (randomBoolean()) {\n            otherType = randomAsciiOfLengthBetween(1, 10);\n            changed = true;\n        } else {\n            otherType = type;\n        }\n        String otherId;\n        if (randomBoolean()) {\n            otherId = randomAsciiOfLengthBetween(1, 10);\n            changed = true;\n        } else {\n            otherId = id;\n        }\n        Map<String, Object> document;\n        if (randomBoolean()) {\n            document = Collections.singletonMap(randomAsciiOfLengthBetween(1, 10), randomAsciiOfLengthBetween(1, 10));\n            changed = true;\n        } else {\n            document = Collections.singletonMap(fieldName, fieldValue);\n        }\n\n        Data otherData = new Data(otherIndex, otherType, otherId, document);\n        TransportData otherTransportData = new TransportData(otherData);\n        if (changed) {\n            assertThat(data, not(equalTo(otherData)));\n            assertThat(otherData, not(equalTo(data)));\n            assertThat(transportData, not(equalTo(otherTransportData)));\n            assertThat(otherTransportData, not(equalTo(transportData)));\n        } else {\n            assertThat(data, equalTo(otherData));\n            assertThat(otherData, equalTo(data));\n            assertThat(transportData, equalTo(otherTransportData));\n            assertThat(otherTransportData, equalTo(transportData));\n            Data thirdData = new Data(index, type, id, Collections.singletonMap(fieldName, fieldValue));\n            TransportData thirdTransportData = new TransportData(thirdData);\n            assertThat(thirdData, equalTo(data));\n            assertThat(data, equalTo(thirdData));\n            assertThat(thirdTransportData, equalTo(transportData));\n            assertThat(transportData, equalTo(thirdTransportData));\n        }\n    }","commit_id":"d093600729e4669a2ee44c020e841f6c9113a721","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\r\n   * Query is executed in iterate mode.\r\n   * @throws IOException Exception\r\n   */\r\n  private void iterate() throws IOException {\r\n    QueryProcessor processor = new QueryProcessor(in.readString(), context);\r\n    try {\r\n      Iter iter = processor.iter();\r\n      XMLSerializer serializer = new XMLSerializer(out);\r\n      Item item;\r\n      while((item = iter.next()) != null) {\r\n          item.serialize(serializer);\r\n      }\r\n      out.write(0);\r\n      out.flush();\r\n      serializer.close();\r\n      processor.close();\r\n    } catch(QueryException e) {\r\n      e.printStackTrace();\r\n    } \r\n  }","id":81300,"modified_method":"/**\r\n   * Query is executed in iterate mode.\r\n   * @throws IOException Exception\r\n   */\r\n  private void iterate() throws IOException {\r\n    String input = in.readString();\r\n    QueryProcessor processor = new QueryProcessor(input, context);\r\n    try {\r\n      Iter iter = processor.iter();\r\n      XMLSerializer serializer = new XMLSerializer(out);\r\n      Item item;\r\n      while((item = iter.next()) != null) {\r\n          item.serialize(serializer);\r\n      }\r\n      out.write(0);\r\n      out.print(\"DONE\");\r\n      out.write(0);\r\n      send(true);\r\n      serializer.close();\r\n      processor.close();\r\n    } catch(QueryException ex) {\r\n   // invalid command was sent by a client; create error feedback\r\n      log.write(this, input, INFOERROR + ex.extended());\r\n      out.write(0);\r\n      out.print(ex.extended());\r\n      out.write(0);\r\n      send(false);\r\n    } \r\n  }","commit_id":"5c1b93e8c0b61ed6a8e83f6d562681efc1c04467","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        id = in.readVInt();\n        opType = in.readSharedString();\n\n        byte type = in.readByte();\n        if (type == 0) {\n            response = new IndexResponse();\n            response.readFrom(in);\n        } else if (type == 1) {\n            response = new DeleteResponse();\n            response.readFrom(in);\n        } else if (type == 3) { // make 3 instead of 2, because 2 is already in use for 'no responses'\n            response = new UpdateResponse();\n            response.readFrom(in);\n        }\n\n        if (in.readBoolean()) {\n            failure = new Failure(in.readSharedString(), in.readSharedString(), in.readString(), in.readString());\n        }\n    }","id":81301,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        id = in.readVInt();\n        opType = in.readSharedString();\n\n        byte type = in.readByte();\n        if (type == 0) {\n            response = new IndexResponse();\n            response.readFrom(in);\n        } else if (type == 1) {\n            response = new DeleteResponse();\n            response.readFrom(in);\n        } else if (type == 3) { // make 3 instead of 2, because 2 is already in use for 'no responses'\n            response = new UpdateResponse();\n            response.readFrom(in);\n        }\n\n        if (in.readBoolean()) {\n            String fIndex = in.readSharedString();\n            String fType = in.readSharedString();\n            String fId = in.readString();\n            String fMessage = in.readString();\n            RestStatus status = RestStatus.readFrom(in);\n            failure = new Failure(fIndex, fType, fId, fMessage, status);\n        }\n    }","commit_id":"a3f1c428c24663838cd0ee64cfdaeff3b65d449f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeVInt(id);\n        out.writeSharedString(opType);\n\n        if (response == null) {\n            out.writeByte((byte) 2);\n        } else {\n            if (response instanceof IndexResponse) {\n                out.writeByte((byte) 0);\n            } else if (response instanceof DeleteResponse) {\n                out.writeByte((byte) 1);\n            } else if (response instanceof UpdateResponse) {\n                out.writeByte((byte) 3); // make 3 instead of 2, because 2 is already in use for 'no responses'\n            }\n            response.writeTo(out);\n        }\n        if (failure == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeSharedString(failure.getIndex());\n            out.writeSharedString(failure.getType());\n            out.writeString(failure.getId());\n            out.writeString(failure.getMessage());\n        }\n    }","id":81302,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeVInt(id);\n        out.writeSharedString(opType);\n\n        if (response == null) {\n            out.writeByte((byte) 2);\n        } else {\n            if (response instanceof IndexResponse) {\n                out.writeByte((byte) 0);\n            } else if (response instanceof DeleteResponse) {\n                out.writeByte((byte) 1);\n            } else if (response instanceof UpdateResponse) {\n                out.writeByte((byte) 3); // make 3 instead of 2, because 2 is already in use for 'no responses'\n            }\n            response.writeTo(out);\n        }\n        if (failure == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeSharedString(failure.getIndex());\n            out.writeSharedString(failure.getType());\n            out.writeString(failure.getId());\n            out.writeString(failure.getMessage());\n            RestStatus.writeTo(out, failure.getStatus());\n        }\n    }","commit_id":"a3f1c428c24663838cd0ee64cfdaeff3b65d449f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Failure(String index, String type, String id, String message) {\n            this.index = index;\n            this.type = type;\n            this.id = id;\n            this.message = message;\n        }","id":81303,"modified_method":"public Failure(String index, String type, String id, String message, RestStatus status) {\n            this.index = index;\n            this.type = type;\n            this.id = id;\n            this.message = message;\n            this.status = status;\n        }","commit_id":"a3f1c428c24663838cd0ee64cfdaeff3b65d449f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        BulkRequest bulkRequest = Requests.bulkRequest();\n        bulkRequest.listenerThreaded(false);\n        String defaultIndex = request.param(\"index\");\n        String defaultType = request.param(\"type\");\n        String defaultRouting = request.param(\"routing\");\n\n        String replicationType = request.param(\"replication\");\n        if (replicationType != null) {\n            bulkRequest.replicationType(ReplicationType.fromString(replicationType));\n        }\n        String consistencyLevel = request.param(\"consistency\");\n        if (consistencyLevel != null) {\n            bulkRequest.consistencyLevel(WriteConsistencyLevel.fromString(consistencyLevel));\n        }\n        bulkRequest.timeout(request.paramAsTime(\"timeout\", BulkShardRequest.DEFAULT_TIMEOUT));\n        bulkRequest.refresh(request.paramAsBoolean(\"refresh\", bulkRequest.refresh()));\n        try {\n            bulkRequest.add(request.content(), request.contentUnsafe(), defaultIndex, defaultType, defaultRouting, null, allowExplicitIndex);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.bulk(bulkRequest, new ActionListener<BulkResponse>() {\n            @Override\n            public void onResponse(BulkResponse response) {\n                try {\n                    XContentBuilder builder = restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(Fields.TOOK, response.getTookInMillis());\n                    builder.startArray(Fields.ITEMS);\n                    for (BulkItemResponse itemResponse : response) {\n                        builder.startObject();\n                        builder.startObject(itemResponse.getOpType());\n                        builder.field(Fields._INDEX, itemResponse.getIndex());\n                        builder.field(Fields._TYPE, itemResponse.getType());\n                        builder.field(Fields._ID, itemResponse.getId());\n                        long version = itemResponse.getVersion();\n                        if (version != -1) {\n                            builder.field(Fields._VERSION, itemResponse.getVersion());\n                        }\n                        if (itemResponse.isFailed()) {\n                            builder.field(Fields.ERROR, itemResponse.getFailure().getMessage());\n                        } else {\n                            builder.field(Fields.OK, true);\n                        }\n                        if (itemResponse.getResponse() instanceof DeleteResponse) {\n                            DeleteResponse deleteResponse = itemResponse.getResponse();\n                            builder.field(Fields.FOUND, !deleteResponse.isNotFound());\n                        }\n                        builder.endObject();\n                        builder.endObject();\n                    }\n                    builder.endArray();\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Throwable e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":81304,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        BulkRequest bulkRequest = Requests.bulkRequest();\n        bulkRequest.listenerThreaded(false);\n        String defaultIndex = request.param(\"index\");\n        String defaultType = request.param(\"type\");\n        String defaultRouting = request.param(\"routing\");\n\n        String replicationType = request.param(\"replication\");\n        if (replicationType != null) {\n            bulkRequest.replicationType(ReplicationType.fromString(replicationType));\n        }\n        String consistencyLevel = request.param(\"consistency\");\n        if (consistencyLevel != null) {\n            bulkRequest.consistencyLevel(WriteConsistencyLevel.fromString(consistencyLevel));\n        }\n        bulkRequest.timeout(request.paramAsTime(\"timeout\", BulkShardRequest.DEFAULT_TIMEOUT));\n        bulkRequest.refresh(request.paramAsBoolean(\"refresh\", bulkRequest.refresh()));\n        try {\n            bulkRequest.add(request.content(), request.contentUnsafe(), defaultIndex, defaultType, defaultRouting, null, allowExplicitIndex);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.bulk(bulkRequest, new ActionListener<BulkResponse>() {\n            @Override\n            public void onResponse(BulkResponse response) {\n                try {\n                    XContentBuilder builder = restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(Fields.TOOK, response.getTookInMillis());\n                    builder.field(Fields.ERRORS, response.hasFailures());\n                    builder.startArray(Fields.ITEMS);\n                    for (BulkItemResponse itemResponse : response) {\n                        builder.startObject();\n                        builder.startObject(itemResponse.getOpType());\n                        builder.field(Fields._INDEX, itemResponse.getIndex());\n                        builder.field(Fields._TYPE, itemResponse.getType());\n                        builder.field(Fields._ID, itemResponse.getId());\n                        long version = itemResponse.getVersion();\n                        if (version != -1) {\n                            builder.field(Fields._VERSION, itemResponse.getVersion());\n                        }\n                        if (itemResponse.isFailed()) {\n                            builder.field(Fields.STATUS, itemResponse.getFailure().getStatus().getStatus());\n                            builder.field(Fields.ERROR, itemResponse.getFailure().getMessage());\n                        } else {\n                            builder.field(Fields.OK, true);\n                            if (itemResponse.getResponse() instanceof DeleteResponse) {\n                                DeleteResponse deleteResponse = itemResponse.getResponse();\n                                if (deleteResponse.isNotFound()) {\n                                    builder.field(Fields.STATUS, RestStatus.NOT_FOUND.getStatus());\n                                } else {\n                                    builder.field(Fields.STATUS, RestStatus.OK.getStatus());\n                                }\n                                builder.field(Fields.FOUND, !deleteResponse.isNotFound());\n                            } else if (itemResponse.getResponse() instanceof IndexResponse) {\n                                IndexResponse indexResponse = itemResponse.getResponse();\n                                if (indexResponse.isCreated()) {\n                                    builder.field(Fields.STATUS, RestStatus.CREATED.getStatus());\n                                } else {\n                                    builder.field(Fields.STATUS, RestStatus.OK.getStatus());\n                                }\n                            } else if (itemResponse.getResponse() instanceof UpdateResponse) {\n                                UpdateResponse updateResponse = itemResponse.getResponse();\n                                if (updateResponse.isCreated()) {\n                                    builder.field(Fields.STATUS, RestStatus.CREATED.getStatus());\n                                } else {\n                                    builder.field(Fields.STATUS, RestStatus.OK.getStatus());\n                                }\n                            }\n                        }\n                        builder.endObject();\n                        builder.endObject();\n                    }\n                    builder.endArray();\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Throwable e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"a3f1c428c24663838cd0ee64cfdaeff3b65d449f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void executeBulk(final BulkRequest bulkRequest, final long startTime, final ActionListener<BulkResponse> listener) {\n        ClusterState clusterState = clusterService.state();\n        // TODO use timeout to wait here if its blocked...\n        clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.WRITE);\n\n        MetaData metaData = clusterState.metaData();\n        for (ActionRequest request : bulkRequest.requests) {\n            if (request instanceof IndexRequest) {\n                IndexRequest indexRequest = (IndexRequest) request;\n                String aliasOrIndex = indexRequest.index();\n                indexRequest.index(clusterState.metaData().concreteIndex(indexRequest.index()));\n\n                MappingMetaData mappingMd = null;\n                if (metaData.hasIndex(indexRequest.index())) {\n                    mappingMd = metaData.index(indexRequest.index()).mappingOrDefault(indexRequest.type());\n                }\n                indexRequest.process(metaData, aliasOrIndex, mappingMd, allowIdGeneration);\n            } else if (request instanceof DeleteRequest) {\n                DeleteRequest deleteRequest = (DeleteRequest) request;\n                deleteRequest.routing(clusterState.metaData().resolveIndexRouting(deleteRequest.routing(), deleteRequest.index()));\n                deleteRequest.index(clusterState.metaData().concreteIndex(deleteRequest.index()));\n            } else if (request instanceof UpdateRequest) {\n                UpdateRequest updateRequest = (UpdateRequest) request;\n                updateRequest.routing(clusterState.metaData().resolveIndexRouting(updateRequest.routing(), updateRequest.index()));\n                updateRequest.index(clusterState.metaData().concreteIndex(updateRequest.index()));\n            }\n        }\n        final AtomicArray<BulkItemResponse> responses = new AtomicArray<BulkItemResponse>(bulkRequest.requests.size());\n\n\n        // first, go over all the requests and create a ShardId -> Operations mapping\n        Map<ShardId, List<BulkItemRequest>> requestsByShard = Maps.newHashMap();\n\n        for (int i = 0; i < bulkRequest.requests.size(); i++) {\n            ActionRequest request = bulkRequest.requests.get(i);\n            if (request instanceof IndexRequest) {\n                IndexRequest indexRequest = (IndexRequest) request;\n                ShardId shardId = clusterService.operationRouting().indexShards(clusterState, indexRequest.index(), indexRequest.type(), indexRequest.id(), indexRequest.routing()).shardId();\n                List<BulkItemRequest> list = requestsByShard.get(shardId);\n                if (list == null) {\n                    list = Lists.newArrayList();\n                    requestsByShard.put(shardId, list);\n                }\n                list.add(new BulkItemRequest(i, request));\n            } else if (request instanceof DeleteRequest) {\n                DeleteRequest deleteRequest = (DeleteRequest) request;\n                MappingMetaData mappingMd = clusterState.metaData().index(deleteRequest.index()).mappingOrDefault(deleteRequest.type());\n                if (mappingMd != null && mappingMd.routing().required() && deleteRequest.routing() == null) {\n                    // if routing is required, and no routing on the delete request, we need to broadcast it....\n                    GroupShardsIterator groupShards = clusterService.operationRouting().broadcastDeleteShards(clusterState, deleteRequest.index());\n                    for (ShardIterator shardIt : groupShards) {\n                        List<BulkItemRequest> list = requestsByShard.get(shardIt.shardId());\n                        if (list == null) {\n                            list = Lists.newArrayList();\n                            requestsByShard.put(shardIt.shardId(), list);\n                        }\n                        list.add(new BulkItemRequest(i, new DeleteRequest(deleteRequest)));\n                    }\n                } else {\n                    ShardId shardId = clusterService.operationRouting().deleteShards(clusterState, deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), deleteRequest.routing()).shardId();\n                    List<BulkItemRequest> list = requestsByShard.get(shardId);\n                    if (list == null) {\n                        list = Lists.newArrayList();\n                        requestsByShard.put(shardId, list);\n                    }\n                    list.add(new BulkItemRequest(i, request));\n                }\n            } else if (request instanceof UpdateRequest) {\n                UpdateRequest updateRequest = (UpdateRequest) request;\n                MappingMetaData mappingMd = clusterState.metaData().index(updateRequest.index()).mappingOrDefault(updateRequest.type());\n                if (mappingMd != null && mappingMd.routing().required() && updateRequest.routing() == null) {\n                    continue; // What to do?\n                }\n                ShardId shardId = clusterService.operationRouting().indexShards(clusterState, updateRequest.index(), updateRequest.type(), updateRequest.id(), updateRequest.routing()).shardId();\n                List<BulkItemRequest> list = requestsByShard.get(shardId);\n                if (list == null) {\n                    list = Lists.newArrayList();\n                    requestsByShard.put(shardId, list);\n                }\n                list.add(new BulkItemRequest(i, request));\n            }\n        }\n\n        if (requestsByShard.isEmpty()) {\n            listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), System.currentTimeMillis() - startTime));\n            return;\n        }\n\n        final AtomicInteger counter = new AtomicInteger(requestsByShard.size());\n        for (Map.Entry<ShardId, List<BulkItemRequest>> entry : requestsByShard.entrySet()) {\n            final ShardId shardId = entry.getKey();\n            final List<BulkItemRequest> requests = entry.getValue();\n            BulkShardRequest bulkShardRequest = new BulkShardRequest(shardId.index().name(), shardId.id(), bulkRequest.refresh(), requests.toArray(new BulkItemRequest[requests.size()]));\n            bulkShardRequest.replicationType(bulkRequest.replicationType());\n            bulkShardRequest.consistencyLevel(bulkRequest.consistencyLevel());\n            bulkShardRequest.timeout(bulkRequest.timeout());\n            shardBulkAction.execute(bulkShardRequest, new ActionListener<BulkShardResponse>() {\n                @Override\n                public void onResponse(BulkShardResponse bulkShardResponse) {\n                    for (BulkItemResponse bulkItemResponse : bulkShardResponse.getResponses()) {\n                        responses.set(bulkItemResponse.getItemId(), bulkItemResponse);\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    // create failures for all relevant requests\n                    String message = ExceptionsHelper.detailedMessage(e);\n                    for (BulkItemRequest request : requests) {\n                        if (request.request() instanceof IndexRequest) {\n                            IndexRequest indexRequest = (IndexRequest) request.request();\n                            responses.set(request.id(), new BulkItemResponse(request.id(), indexRequest.opType().toString().toLowerCase(Locale.ENGLISH),\n                                    new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), message)));\n                        } else if (request.request() instanceof DeleteRequest) {\n                            DeleteRequest deleteRequest = (DeleteRequest) request.request();\n                            responses.set(request.id(), new BulkItemResponse(request.id(), \"delete\",\n                                    new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), message)));\n                        } else if (request.request() instanceof UpdateRequest) {\n                            UpdateRequest updateRequest = (UpdateRequest) request.request();\n                            responses.set(request.id(), new BulkItemResponse(request.id(), \"update\",\n                                    new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), message)));\n                        }\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                private void finishHim() {\n                    listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), System.currentTimeMillis() - startTime));\n                }\n            });\n        }\n    }","id":81305,"modified_method":"private void executeBulk(final BulkRequest bulkRequest, final long startTime, final ActionListener<BulkResponse> listener) {\n        ClusterState clusterState = clusterService.state();\n        // TODO use timeout to wait here if its blocked...\n        clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.WRITE);\n\n        MetaData metaData = clusterState.metaData();\n        for (ActionRequest request : bulkRequest.requests) {\n            if (request instanceof IndexRequest) {\n                IndexRequest indexRequest = (IndexRequest) request;\n                String aliasOrIndex = indexRequest.index();\n                indexRequest.index(clusterState.metaData().concreteIndex(indexRequest.index()));\n\n                MappingMetaData mappingMd = null;\n                if (metaData.hasIndex(indexRequest.index())) {\n                    mappingMd = metaData.index(indexRequest.index()).mappingOrDefault(indexRequest.type());\n                }\n                indexRequest.process(metaData, aliasOrIndex, mappingMd, allowIdGeneration);\n            } else if (request instanceof DeleteRequest) {\n                DeleteRequest deleteRequest = (DeleteRequest) request;\n                deleteRequest.routing(clusterState.metaData().resolveIndexRouting(deleteRequest.routing(), deleteRequest.index()));\n                deleteRequest.index(clusterState.metaData().concreteIndex(deleteRequest.index()));\n            } else if (request instanceof UpdateRequest) {\n                UpdateRequest updateRequest = (UpdateRequest) request;\n                updateRequest.routing(clusterState.metaData().resolveIndexRouting(updateRequest.routing(), updateRequest.index()));\n                updateRequest.index(clusterState.metaData().concreteIndex(updateRequest.index()));\n            }\n        }\n        final AtomicArray<BulkItemResponse> responses = new AtomicArray<BulkItemResponse>(bulkRequest.requests.size());\n\n\n        // first, go over all the requests and create a ShardId -> Operations mapping\n        Map<ShardId, List<BulkItemRequest>> requestsByShard = Maps.newHashMap();\n\n        for (int i = 0; i < bulkRequest.requests.size(); i++) {\n            ActionRequest request = bulkRequest.requests.get(i);\n            if (request instanceof IndexRequest) {\n                IndexRequest indexRequest = (IndexRequest) request;\n                ShardId shardId = clusterService.operationRouting().indexShards(clusterState, indexRequest.index(), indexRequest.type(), indexRequest.id(), indexRequest.routing()).shardId();\n                List<BulkItemRequest> list = requestsByShard.get(shardId);\n                if (list == null) {\n                    list = Lists.newArrayList();\n                    requestsByShard.put(shardId, list);\n                }\n                list.add(new BulkItemRequest(i, request));\n            } else if (request instanceof DeleteRequest) {\n                DeleteRequest deleteRequest = (DeleteRequest) request;\n                MappingMetaData mappingMd = clusterState.metaData().index(deleteRequest.index()).mappingOrDefault(deleteRequest.type());\n                if (mappingMd != null && mappingMd.routing().required() && deleteRequest.routing() == null) {\n                    // if routing is required, and no routing on the delete request, we need to broadcast it....\n                    GroupShardsIterator groupShards = clusterService.operationRouting().broadcastDeleteShards(clusterState, deleteRequest.index());\n                    for (ShardIterator shardIt : groupShards) {\n                        List<BulkItemRequest> list = requestsByShard.get(shardIt.shardId());\n                        if (list == null) {\n                            list = Lists.newArrayList();\n                            requestsByShard.put(shardIt.shardId(), list);\n                        }\n                        list.add(new BulkItemRequest(i, new DeleteRequest(deleteRequest)));\n                    }\n                } else {\n                    ShardId shardId = clusterService.operationRouting().deleteShards(clusterState, deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), deleteRequest.routing()).shardId();\n                    List<BulkItemRequest> list = requestsByShard.get(shardId);\n                    if (list == null) {\n                        list = Lists.newArrayList();\n                        requestsByShard.put(shardId, list);\n                    }\n                    list.add(new BulkItemRequest(i, request));\n                }\n            } else if (request instanceof UpdateRequest) {\n                UpdateRequest updateRequest = (UpdateRequest) request;\n                MappingMetaData mappingMd = clusterState.metaData().index(updateRequest.index()).mappingOrDefault(updateRequest.type());\n                if (mappingMd != null && mappingMd.routing().required() && updateRequest.routing() == null) {\n                    continue; // What to do?\n                }\n                ShardId shardId = clusterService.operationRouting().indexShards(clusterState, updateRequest.index(), updateRequest.type(), updateRequest.id(), updateRequest.routing()).shardId();\n                List<BulkItemRequest> list = requestsByShard.get(shardId);\n                if (list == null) {\n                    list = Lists.newArrayList();\n                    requestsByShard.put(shardId, list);\n                }\n                list.add(new BulkItemRequest(i, request));\n            }\n        }\n\n        if (requestsByShard.isEmpty()) {\n            listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), System.currentTimeMillis() - startTime));\n            return;\n        }\n\n        final AtomicInteger counter = new AtomicInteger(requestsByShard.size());\n        for (Map.Entry<ShardId, List<BulkItemRequest>> entry : requestsByShard.entrySet()) {\n            final ShardId shardId = entry.getKey();\n            final List<BulkItemRequest> requests = entry.getValue();\n            BulkShardRequest bulkShardRequest = new BulkShardRequest(shardId.index().name(), shardId.id(), bulkRequest.refresh(), requests.toArray(new BulkItemRequest[requests.size()]));\n            bulkShardRequest.replicationType(bulkRequest.replicationType());\n            bulkShardRequest.consistencyLevel(bulkRequest.consistencyLevel());\n            bulkShardRequest.timeout(bulkRequest.timeout());\n            shardBulkAction.execute(bulkShardRequest, new ActionListener<BulkShardResponse>() {\n                @Override\n                public void onResponse(BulkShardResponse bulkShardResponse) {\n                    for (BulkItemResponse bulkItemResponse : bulkShardResponse.getResponses()) {\n                        responses.set(bulkItemResponse.getItemId(), bulkItemResponse);\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    // create failures for all relevant requests\n                    String message = ExceptionsHelper.detailedMessage(e);\n                    RestStatus status = ExceptionsHelper.status(e);\n                    for (BulkItemRequest request : requests) {\n                        if (request.request() instanceof IndexRequest) {\n                            IndexRequest indexRequest = (IndexRequest) request.request();\n                            responses.set(request.id(), new BulkItemResponse(request.id(), indexRequest.opType().toString().toLowerCase(Locale.ENGLISH),\n                                    new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), message, status)));\n                        } else if (request.request() instanceof DeleteRequest) {\n                            DeleteRequest deleteRequest = (DeleteRequest) request.request();\n                            responses.set(request.id(), new BulkItemResponse(request.id(), \"delete\",\n                                    new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), message, status)));\n                        } else if (request.request() instanceof UpdateRequest) {\n                            UpdateRequest updateRequest = (UpdateRequest) request.request();\n                            responses.set(request.id(), new BulkItemResponse(request.id(), \"update\",\n                                    new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), message, status)));\n                        }\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                private void finishHim() {\n                    listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), System.currentTimeMillis() - startTime));\n                }\n            });\n        }\n    }","commit_id":"a3f1c428c24663838cd0ee64cfdaeff3b65d449f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected PrimaryResponse<BulkShardResponse, BulkShardRequest> shardOperationOnPrimary(ClusterState clusterState, PrimaryOperationRequest shardRequest) {\n        final BulkShardRequest request = shardRequest.request;\n        IndexShard indexShard = indicesService.indexServiceSafe(shardRequest.request.index()).shardSafe(shardRequest.shardId);\n        Engine.IndexingOperation[] ops = null;\n        Set<Tuple<String, String>> mappingsToUpdate = null;\n\n        BulkItemResponse[] responses = new BulkItemResponse[request.items().length];\n        long[] preVersions = new long[request.items().length];\n        for (int requestIndex = 0; requestIndex < request.items().length; requestIndex++) {\n            BulkItemRequest item = request.items()[requestIndex];\n            if (item.request() instanceof IndexRequest) {\n                IndexRequest indexRequest = (IndexRequest) item.request();\n                try {\n                    WriteResult result = shardIndexOperation(request, indexRequest, clusterState, indexShard, true);\n                    // add the response\n                    IndexResponse indexResponse = result.response();\n                    responses[requestIndex] = new BulkItemResponse(item.id(), indexRequest.opType().lowercase(), indexResponse);\n                    preVersions[requestIndex] = result.preVersion;\n                    if (result.mappingToUpdate != null) {\n                        if (mappingsToUpdate == null) {\n                            mappingsToUpdate = Sets.newHashSet();\n                        }\n                        mappingsToUpdate.add(result.mappingToUpdate);\n                    }\n                    if (result.op != null) {\n                        if (ops == null) {\n                            ops = new Engine.IndexingOperation[request.items().length];\n                        }\n                        ops[requestIndex] = result.op;\n                    }\n                } catch (Throwable e) {\n                    // rethrow the failure if we are going to retry on primary and let parent failure to handle it\n                    if (retryPrimaryException(e)) {\n                        // restore updated versions...\n                        for (int j = 0; j < requestIndex; j++) {\n                            applyVersion(request.items()[j], preVersions[j]);\n                        }\n                        throw (ElasticSearchException) e;\n                    }\n                    if (e instanceof ElasticSearchException && ((ElasticSearchException) e).status() == RestStatus.CONFLICT) {\n                        logger.trace(\"[{}][{}] failed to execute bulk item (index) {}\", e, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                    } else {\n                        logger.debug(\"[{}][{}] failed to execute bulk item (index) {}\", e, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                    }\n                    responses[requestIndex] = new BulkItemResponse(item.id(), indexRequest.opType().lowercase(),\n                            new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), ExceptionsHelper.detailedMessage(e)));\n                    // nullify the request so it won't execute on the replicas\n                    request.items()[requestIndex] = null;\n                }\n            } else if (item.request() instanceof DeleteRequest) {\n                DeleteRequest deleteRequest = (DeleteRequest) item.request();\n                try {\n                    // add the response\n                    DeleteResponse deleteResponse = shardDeleteOperation(deleteRequest, indexShard).response();\n                    responses[requestIndex] = new BulkItemResponse(item.id(), \"delete\", deleteResponse);\n                } catch (Throwable e) {\n                    // rethrow the failure if we are going to retry on primary and let parent failure to handle it\n                    if (retryPrimaryException(e)) {\n                        // restore updated versions...\n                        for (int j = 0; j < requestIndex; j++) {\n                            applyVersion(request.items()[j], preVersions[j]);\n                        }\n                        throw (ElasticSearchException) e;\n                    }\n                    if (e instanceof ElasticSearchException && ((ElasticSearchException) e).status() == RestStatus.CONFLICT) {\n                        logger.trace(\"[{}][{}] failed to execute bulk item (delete) {}\", e, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                    } else {\n                        logger.debug(\"[{}][{}] failed to execute bulk item (delete) {}\", e, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                    }\n                    responses[requestIndex] = new BulkItemResponse(item.id(), \"delete\",\n                            new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), ExceptionsHelper.detailedMessage(e)));\n                    // nullify the request so it won't execute on the replicas\n                    request.items()[requestIndex] = null;\n                }\n            } else if (item.request() instanceof UpdateRequest) {\n                UpdateRequest updateRequest = (UpdateRequest) item.request();\n                //  We need to do the requested retries plus the initial attempt. We don't do < 1+retry_on_conflict because retry_on_conflict may be Integer.MAX_VALUE\n                for (int updateAttemptsCount = 0; updateAttemptsCount <= updateRequest.retryOnConflict(); updateAttemptsCount++) {\n                    UpdateResult updateResult;\n                    try {\n                        updateResult = shardUpdateOperation(clusterState, request, updateRequest, indexShard);\n                    } catch (Throwable t) {\n                        updateResult = new UpdateResult(null, null, false, t, null);\n                    }\n                    if (updateResult.success()) {\n\n                        switch (updateResult.result.operation()) {\n                            case UPSERT:\n                            case INDEX:\n                                WriteResult result = updateResult.writeResult;\n                                IndexRequest indexRequest = updateResult.request();\n                                BytesReference indexSourceAsBytes = indexRequest.source();\n                                // add the response\n                                IndexResponse indexResponse = result.response();\n                                UpdateResponse updateResponse = new UpdateResponse(indexResponse.getIndex(), indexResponse.getType(), indexResponse.getId(), indexResponse.getVersion(), indexResponse.isCreated());\n                                if (updateRequest.fields() != null && updateRequest.fields().length > 0) {\n                                    Tuple<XContentType, Map<String, Object>> sourceAndContent = XContentHelper.convertToMap(indexSourceAsBytes, true);\n                                    updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, indexResponse.getVersion(), sourceAndContent.v2(), sourceAndContent.v1(), indexSourceAsBytes));\n                                }\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", updateResponse);\n                                preVersions[requestIndex] = result.preVersion;\n                                if (result.mappingToUpdate != null) {\n                                    if (mappingsToUpdate == null) {\n                                        mappingsToUpdate = Sets.newHashSet();\n                                    }\n                                    mappingsToUpdate.add(result.mappingToUpdate);\n                                }\n                                if (result.op != null) {\n                                    if (ops == null) {\n                                        ops = new Engine.IndexingOperation[request.items().length];\n                                    }\n                                    ops[requestIndex] = result.op;\n                                }\n                                // Replace the update request to the translated index request to execute on the replica.\n                                request.items()[requestIndex] = new BulkItemRequest(request.items()[requestIndex].id(), indexRequest);\n                                break;\n                            case DELETE:\n                                DeleteResponse response = updateResult.writeResult.response();\n                                DeleteRequest deleteRequest = updateResult.request();\n                                updateResponse = new UpdateResponse(response.getIndex(), response.getType(), response.getId(), response.getVersion(), false);\n                                updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, response.getVersion(), updateResult.result.updatedSourceAsMap(), updateResult.result.updateSourceContentType(), null));\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", updateResponse);\n                                // Replace the update request to the translated delete request to execute on the replica.\n                                request.items()[requestIndex] = new BulkItemRequest(request.items()[requestIndex].id(), deleteRequest);\n                                break;\n                            case NONE:\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", updateResult.noopResult);\n                                request.items()[requestIndex] = null; // No need to go to the replica\n                                break;\n                        }\n                        // NOTE: Breaking out of the retry_on_conflict loop!\n                        break;\n                    } else if (updateResult.failure()) {\n                        Throwable t = updateResult.error;\n                        if (updateResult.retry) {\n                            // updateAttemptCount is 0 based and marks current attempt, if it's equal to retryOnConflict we are going out of the iteration\n                            if (updateAttemptsCount >= updateRequest.retryOnConflict()) {\n                                // we can't try any more\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\",\n                                        new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), ExceptionsHelper.detailedMessage(t)));\n                                ;\n\n                                request.items()[requestIndex] = null; // do not send to replicas\n                            }\n                        } else {\n                            // rethrow the failure if we are going to retry on primary and let parent failure to handle it\n                            if (retryPrimaryException(t)) {\n                                // restore updated versions...\n                                for (int j = 0; j < requestIndex; j++) {\n                                    applyVersion(request.items()[j], preVersions[j]);\n                                }\n                                throw (ElasticSearchException) t;\n                            }\n                            if (updateResult.result == null) {\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), ExceptionsHelper.detailedMessage(t)));\n                            } else {\n                                switch (updateResult.result.operation()) {\n                                    case UPSERT:\n                                    case INDEX:\n                                        IndexRequest indexRequest = updateResult.request();\n                                        if (t instanceof ElasticSearchException && ((ElasticSearchException) t).status() == RestStatus.CONFLICT) {\n                                            logger.trace(\"[{}][{}] failed to execute bulk item (index) {}\", t, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                                        } else {\n                                            logger.debug(\"[{}][{}] failed to execute bulk item (index) {}\", t, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                                        }\n                                        responses[requestIndex] = new BulkItemResponse(item.id(), indexRequest.opType().lowercase(),\n                                                new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), ExceptionsHelper.detailedMessage(t)));\n                                        break;\n                                    case DELETE:\n                                        DeleteRequest deleteRequest = updateResult.request();\n                                        if (t instanceof ElasticSearchException && ((ElasticSearchException) t).status() == RestStatus.CONFLICT) {\n                                            logger.trace(\"[{}][{}] failed to execute bulk item (delete) {}\", t, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                                        } else {\n                                            logger.debug(\"[{}][{}] failed to execute bulk item (delete) {}\", t, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                                        }\n                                        responses[requestIndex] = new BulkItemResponse(item.id(), \"delete\",\n                                                new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), ExceptionsHelper.detailedMessage(t)));\n                                        break;\n                                }\n                            }\n                            // nullify the request so it won't execute on the replicas\n                            request.items()[requestIndex] = null;\n                            // NOTE: Breaking out of the retry_on_conflict loop!\n                            break;\n                        }\n\n                    }\n                }\n            }\n\n            assert responses[requestIndex] != null; // we must have set a response somewhere.\n\n        }\n\n        if (mappingsToUpdate != null) {\n            for (Tuple<String, String> mappingToUpdate : mappingsToUpdate) {\n                updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2());\n            }\n        }\n\n        if (request.refresh()) {\n            try {\n                indexShard.refresh(new Engine.Refresh(\"refresh_flag_bulk\").force(false));\n            } catch (Throwable e) {\n                // ignore\n            }\n        }\n        BulkShardResponse response = new BulkShardResponse(new ShardId(request.index(), request.shardId()), responses);\n        return new PrimaryResponse<BulkShardResponse, BulkShardRequest>(shardRequest.request, response, ops);\n    }","id":81306,"modified_method":"@Override\n    protected PrimaryResponse<BulkShardResponse, BulkShardRequest> shardOperationOnPrimary(ClusterState clusterState, PrimaryOperationRequest shardRequest) {\n        final BulkShardRequest request = shardRequest.request;\n        IndexShard indexShard = indicesService.indexServiceSafe(shardRequest.request.index()).shardSafe(shardRequest.shardId);\n        Engine.IndexingOperation[] ops = null;\n        Set<Tuple<String, String>> mappingsToUpdate = null;\n\n        BulkItemResponse[] responses = new BulkItemResponse[request.items().length];\n        long[] preVersions = new long[request.items().length];\n        for (int requestIndex = 0; requestIndex < request.items().length; requestIndex++) {\n            BulkItemRequest item = request.items()[requestIndex];\n            if (item.request() instanceof IndexRequest) {\n                IndexRequest indexRequest = (IndexRequest) item.request();\n                try {\n                    WriteResult result = shardIndexOperation(request, indexRequest, clusterState, indexShard, true);\n                    // add the response\n                    IndexResponse indexResponse = result.response();\n                    responses[requestIndex] = new BulkItemResponse(item.id(), indexRequest.opType().lowercase(), indexResponse);\n                    preVersions[requestIndex] = result.preVersion;\n                    if (result.mappingToUpdate != null) {\n                        if (mappingsToUpdate == null) {\n                            mappingsToUpdate = Sets.newHashSet();\n                        }\n                        mappingsToUpdate.add(result.mappingToUpdate);\n                    }\n                    if (result.op != null) {\n                        if (ops == null) {\n                            ops = new Engine.IndexingOperation[request.items().length];\n                        }\n                        ops[requestIndex] = result.op;\n                    }\n                } catch (Throwable e) {\n                    // rethrow the failure if we are going to retry on primary and let parent failure to handle it\n                    if (retryPrimaryException(e)) {\n                        // restore updated versions...\n                        for (int j = 0; j < requestIndex; j++) {\n                            applyVersion(request.items()[j], preVersions[j]);\n                        }\n                        throw (ElasticSearchException) e;\n                    }\n                    if (e instanceof ElasticSearchException && ((ElasticSearchException) e).status() == RestStatus.CONFLICT) {\n                        logger.trace(\"[{}][{}] failed to execute bulk item (index) {}\", e, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                    } else {\n                        logger.debug(\"[{}][{}] failed to execute bulk item (index) {}\", e, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                    }\n                    responses[requestIndex] = new BulkItemResponse(item.id(), indexRequest.opType().lowercase(),\n                            new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), e));\n                    // nullify the request so it won't execute on the replicas\n                    request.items()[requestIndex] = null;\n                }\n            } else if (item.request() instanceof DeleteRequest) {\n                DeleteRequest deleteRequest = (DeleteRequest) item.request();\n                try {\n                    // add the response\n                    DeleteResponse deleteResponse = shardDeleteOperation(deleteRequest, indexShard).response();\n                    responses[requestIndex] = new BulkItemResponse(item.id(), \"delete\", deleteResponse);\n                } catch (Throwable e) {\n                    // rethrow the failure if we are going to retry on primary and let parent failure to handle it\n                    if (retryPrimaryException(e)) {\n                        // restore updated versions...\n                        for (int j = 0; j < requestIndex; j++) {\n                            applyVersion(request.items()[j], preVersions[j]);\n                        }\n                        throw (ElasticSearchException) e;\n                    }\n                    if (e instanceof ElasticSearchException && ((ElasticSearchException) e).status() == RestStatus.CONFLICT) {\n                        logger.trace(\"[{}][{}] failed to execute bulk item (delete) {}\", e, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                    } else {\n                        logger.debug(\"[{}][{}] failed to execute bulk item (delete) {}\", e, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                    }\n                    responses[requestIndex] = new BulkItemResponse(item.id(), \"delete\",\n                            new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), e));\n                    // nullify the request so it won't execute on the replicas\n                    request.items()[requestIndex] = null;\n                }\n            } else if (item.request() instanceof UpdateRequest) {\n                UpdateRequest updateRequest = (UpdateRequest) item.request();\n                //  We need to do the requested retries plus the initial attempt. We don't do < 1+retry_on_conflict because retry_on_conflict may be Integer.MAX_VALUE\n                for (int updateAttemptsCount = 0; updateAttemptsCount <= updateRequest.retryOnConflict(); updateAttemptsCount++) {\n                    UpdateResult updateResult;\n                    try {\n                        updateResult = shardUpdateOperation(clusterState, request, updateRequest, indexShard);\n                    } catch (Throwable t) {\n                        updateResult = new UpdateResult(null, null, false, t, null);\n                    }\n                    if (updateResult.success()) {\n\n                        switch (updateResult.result.operation()) {\n                            case UPSERT:\n                            case INDEX:\n                                WriteResult result = updateResult.writeResult;\n                                IndexRequest indexRequest = updateResult.request();\n                                BytesReference indexSourceAsBytes = indexRequest.source();\n                                // add the response\n                                IndexResponse indexResponse = result.response();\n                                UpdateResponse updateResponse = new UpdateResponse(indexResponse.getIndex(), indexResponse.getType(), indexResponse.getId(), indexResponse.getVersion(), indexResponse.isCreated());\n                                if (updateRequest.fields() != null && updateRequest.fields().length > 0) {\n                                    Tuple<XContentType, Map<String, Object>> sourceAndContent = XContentHelper.convertToMap(indexSourceAsBytes, true);\n                                    updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, indexResponse.getVersion(), sourceAndContent.v2(), sourceAndContent.v1(), indexSourceAsBytes));\n                                }\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", updateResponse);\n                                preVersions[requestIndex] = result.preVersion;\n                                if (result.mappingToUpdate != null) {\n                                    if (mappingsToUpdate == null) {\n                                        mappingsToUpdate = Sets.newHashSet();\n                                    }\n                                    mappingsToUpdate.add(result.mappingToUpdate);\n                                }\n                                if (result.op != null) {\n                                    if (ops == null) {\n                                        ops = new Engine.IndexingOperation[request.items().length];\n                                    }\n                                    ops[requestIndex] = result.op;\n                                }\n                                // Replace the update request to the translated index request to execute on the replica.\n                                request.items()[requestIndex] = new BulkItemRequest(request.items()[requestIndex].id(), indexRequest);\n                                break;\n                            case DELETE:\n                                DeleteResponse response = updateResult.writeResult.response();\n                                DeleteRequest deleteRequest = updateResult.request();\n                                updateResponse = new UpdateResponse(response.getIndex(), response.getType(), response.getId(), response.getVersion(), false);\n                                updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, response.getVersion(), updateResult.result.updatedSourceAsMap(), updateResult.result.updateSourceContentType(), null));\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", updateResponse);\n                                // Replace the update request to the translated delete request to execute on the replica.\n                                request.items()[requestIndex] = new BulkItemRequest(request.items()[requestIndex].id(), deleteRequest);\n                                break;\n                            case NONE:\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", updateResult.noopResult);\n                                request.items()[requestIndex] = null; // No need to go to the replica\n                                break;\n                        }\n                        // NOTE: Breaking out of the retry_on_conflict loop!\n                        break;\n                    } else if (updateResult.failure()) {\n                        Throwable t = updateResult.error;\n                        if (updateResult.retry) {\n                            // updateAttemptCount is 0 based and marks current attempt, if it's equal to retryOnConflict we are going out of the iteration\n                            if (updateAttemptsCount >= updateRequest.retryOnConflict()) {\n                                // we can't try any more\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\",\n                                        new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), t));\n                                ;\n\n                                request.items()[requestIndex] = null; // do not send to replicas\n                            }\n                        } else {\n                            // rethrow the failure if we are going to retry on primary and let parent failure to handle it\n                            if (retryPrimaryException(t)) {\n                                // restore updated versions...\n                                for (int j = 0; j < requestIndex; j++) {\n                                    applyVersion(request.items()[j], preVersions[j]);\n                                }\n                                throw (ElasticSearchException) t;\n                            }\n                            if (updateResult.result == null) {\n                                responses[requestIndex] = new BulkItemResponse(item.id(), \"update\", new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), t));\n                            } else {\n                                switch (updateResult.result.operation()) {\n                                    case UPSERT:\n                                    case INDEX:\n                                        IndexRequest indexRequest = updateResult.request();\n                                        if (t instanceof ElasticSearchException && ((ElasticSearchException) t).status() == RestStatus.CONFLICT) {\n                                            logger.trace(\"[{}][{}] failed to execute bulk item (index) {}\", t, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                                        } else {\n                                            logger.debug(\"[{}][{}] failed to execute bulk item (index) {}\", t, shardRequest.request.index(), shardRequest.shardId, indexRequest);\n                                        }\n                                        responses[requestIndex] = new BulkItemResponse(item.id(), indexRequest.opType().lowercase(),\n                                                new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), t));\n                                        break;\n                                    case DELETE:\n                                        DeleteRequest deleteRequest = updateResult.request();\n                                        if (t instanceof ElasticSearchException && ((ElasticSearchException) t).status() == RestStatus.CONFLICT) {\n                                            logger.trace(\"[{}][{}] failed to execute bulk item (delete) {}\", t, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                                        } else {\n                                            logger.debug(\"[{}][{}] failed to execute bulk item (delete) {}\", t, shardRequest.request.index(), shardRequest.shardId, deleteRequest);\n                                        }\n                                        responses[requestIndex] = new BulkItemResponse(item.id(), \"delete\",\n                                                new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), t));\n                                        break;\n                                }\n                            }\n                            // nullify the request so it won't execute on the replicas\n                            request.items()[requestIndex] = null;\n                            // NOTE: Breaking out of the retry_on_conflict loop!\n                            break;\n                        }\n\n                    }\n                }\n            }\n\n            assert responses[requestIndex] != null; // we must have set a response somewhere.\n\n        }\n\n        if (mappingsToUpdate != null) {\n            for (Tuple<String, String> mappingToUpdate : mappingsToUpdate) {\n                updateMappingOnMaster(mappingToUpdate.v1(), mappingToUpdate.v2());\n            }\n        }\n\n        if (request.refresh()) {\n            try {\n                indexShard.refresh(new Engine.Refresh(\"refresh_flag_bulk\").force(false));\n            } catch (Throwable e) {\n                // ignore\n            }\n        }\n        BulkShardResponse response = new BulkShardResponse(new ShardId(request.index(), request.shardId()), responses);\n        return new PrimaryResponse<BulkShardResponse, BulkShardRequest>(shardRequest.request, response, ops);\n    }","commit_id":"a3f1c428c24663838cd0ee64cfdaeff3b65d449f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void addDLFileVersion(\n\t\t\tlong fileVersionId, long groupId, long companyId, long userId,\n\t\t\tString userName, Timestamp createDate, long repositoryId,\n\t\t\tlong folderId, long fileEntryId, String extension, String mimeType,\n\t\t\tString title, long size)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tStringBundler sb = new StringBundler(8);\n\n\t\t\tsb.append(\"insert into DLFileVersion (fileVersionId, groupId, \");\n\t\t\tsb.append(\"companyId, userId, userName, createDate, \");\n\t\t\tsb.append(\"modifiedDate, repositoryId, folderId, fileEntryId, \");\n\t\t\tsb.append(\"extension, mimeType, title, description, changeLog, \");\n\t\t\tsb.append(\"extraSettings, fileEntryTypeId, version, size_, \");\n\t\t\tsb.append(\"status, statusByUserId, statusByUserName, statusDate) \");\n\t\t\tsb.append(\"values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \");\n\t\t\tsb.append(\"?, ?, ?, ?, ?, ?, ?, ?)\");\n\n\t\t\tString sql = sb.toString();\n\n\t\t\tps = con.prepareStatement(sql);\n\n\t\t\tps.setLong(1, fileVersionId);\n\t\t\tps.setLong(2, groupId);\n\t\t\tps.setLong(3, companyId);\n\t\t\tps.setLong(4, userId);\n\t\t\tps.setString(5, userName);\n\t\t\tps.setTimestamp(6, createDate);\n\t\t\tps.setTimestamp(7, createDate);\n\t\t\tps.setLong(8, repositoryId);\n\t\t\tps.setLong(9, folderId);\n\t\t\tps.setLong(10, fileEntryId);\n\t\t\tps.setString(11, extension);\n\t\t\tps.setString(12, mimeType);\n\t\t\tps.setString(13, title);\n\t\t\tps.setString(14, StringPool.BLANK);\n\t\t\tps.setString(15, StringPool.BLANK);\n\t\t\tps.setString(16, StringPool.BLANK);\n\t\t\tps.setLong(17, 0);\n\t\t\tps.setString(18, \"1.0\");\n\t\t\tps.setLong(19, size);\n\t\t\tps.setInt(20, 0);\n\t\t\tps.setLong(21, userId);\n\t\t\tps.setString(22, userName);\n\t\t\tps.setTimestamp(23, createDate);\n\n\t\t\tps.executeUpdate();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to add file version 1.0 for file entry \" + title,\n\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","id":81307,"modified_method":"protected void addDLFileVersion(\n\t\t\tlong fileVersionId, long groupId, long companyId, long userId,\n\t\t\tString userName, Timestamp createDate, long repositoryId,\n\t\t\tlong folderId, long fileEntryId, String extension, String mimeType,\n\t\t\tString title, long size)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tStringBundler sb = new StringBundler(8);\n\n\t\t\tsb.append(\"insert into DLFileVersion (uuid_, fileVersionId,\");\n\t\t\tsb.append(\"groupId, companyId, userId, userName, createDate, \");\n\t\t\tsb.append(\"modifiedDate, repositoryId, folderId, fileEntryId, \");\n\t\t\tsb.append(\"extension, mimeType, title, description, changeLog, \");\n\t\t\tsb.append(\"extraSettings, fileEntryTypeId, version, size_, \");\n\t\t\tsb.append(\"status, statusByUserId, statusByUserName, statusDate) \");\n\t\t\tsb.append(\"values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \");\n\t\t\tsb.append(\"?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n\n\t\t\tString sql = sb.toString();\n\n\t\t\tps = con.prepareStatement(sql);\n\n\t\t\tps.setString(1, PortalUUIDUtil.generate());\n\t\t\tps.setLong(2, fileVersionId);\n\t\t\tps.setLong(3, groupId);\n\t\t\tps.setLong(4, companyId);\n\t\t\tps.setLong(5, userId);\n\t\t\tps.setString(6, userName);\n\t\t\tps.setTimestamp(7, createDate);\n\t\t\tps.setTimestamp(8, createDate);\n\t\t\tps.setLong(9, repositoryId);\n\t\t\tps.setLong(10, folderId);\n\t\t\tps.setLong(11, fileEntryId);\n\t\t\tps.setString(12, extension);\n\t\t\tps.setString(13, mimeType);\n\t\t\tps.setString(14, title);\n\t\t\tps.setString(15, StringPool.BLANK);\n\t\t\tps.setString(16, StringPool.BLANK);\n\t\t\tps.setString(17, StringPool.BLANK);\n\t\t\tps.setLong(18, 0);\n\t\t\tps.setString(19, \"1.0\");\n\t\t\tps.setLong(20, size);\n\t\t\tps.setInt(21, 0);\n\t\t\tps.setLong(22, userId);\n\t\t\tps.setString(23, userName);\n\t\t\tps.setTimestamp(24, createDate);\n\n\t\t\tps.executeUpdate();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to add file version 1.0 for file entry \" + title,\n\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","commit_id":"e57997a83e83a275bd14101421ed51e1097b6c53","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * @see org.opencms.db.I_CmsVfsDriver#replaceResource(com.opencms.file.CmsUser, com.opencms.file.CmsProject, com.opencms.file.CmsResource, java.util.Map, byte[])\n     */\n    public CmsResource replaceResource(CmsUser currentUser, CmsProject currentProject, CmsResource res, byte[] resContent, I_CmsResourceType newResType) throws CmsException {\n        Connection conn = null;\n        PreparedStatement stmt = null;   \n        long dateModified = res.isTouched() ? res.getDateLastModified() : System.currentTimeMillis();\n        \n        try {\n            // write the file content\n            if (resContent!=null) {\n                writeFileContent(res.getFileId(), resContent, currentProject.getId(), false);\n            }\n            \n            // update the resource and structure\n            conn = m_sqlManager.getConnection(currentProject);\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_REPLACE\"); \n            stmt.setInt(1, newResType.getResourceType());\n            stmt.setTimestamp(2, new Timestamp(dateModified));\n            stmt.setString(3, currentUser.getId().toString());\n            int state = res.getState();\n            if ((state == I_CmsConstants.C_STATE_NEW) || (state == I_CmsConstants.C_STATE_CHANGED)) {\n                stmt.setInt(4, state);\n            } else if (state == I_CmsConstants.C_STATE_UNCHANGED) {\n                stmt.setInt(4, I_CmsConstants.C_STATE_CHANGED);\n            } else {\n                stmt.setInt(4, state);\n            }    \n            stmt.setString(5, res.getId().toString());\n            stmt.executeUpdate();            \n        } catch (SQLException e) {\n            throw m_sqlManager.getCmsException(this, null, CmsException.C_SQL_ERROR, e, false);\n        } finally {\n            m_sqlManager.closeAll(conn, stmt, null);\n        }   \n\n        return null;     \n    }","id":81308,"modified_method":"/**\n     * @see org.opencms.db.I_CmsVfsDriver#replaceResource(com.opencms.file.CmsUser, com.opencms.file.CmsProject, com.opencms.file.CmsResource, java.util.Map, byte[])\n     */\n    public CmsResource replaceResource(CmsUser currentUser, CmsProject currentProject, CmsResource res, byte[] resContent, I_CmsResourceType newResType) throws CmsException {\n        Connection conn = null;\n        PreparedStatement stmt = null;   \n        long dateModified = res.isTouched() ? res.getDateLastModified() : System.currentTimeMillis();\n        \n        try {\n            // write the file content\n            if (resContent!=null) {\n                writeFileContent(res.getFileId(), resContent, currentProject.getId(), false);\n            }\n            \n            // update the resource and structure\n            conn = m_sqlManager.getConnection(currentProject);\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_REPLACE\"); \n            stmt.setInt(1, newResType.getResourceType());\n            stmt.setTimestamp(2, new Timestamp(dateModified));\n            stmt.setString(3, res.getResourceId().toString());\n            stmt.executeUpdate(); \n            \n            // TODO: remove this later\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_STRUCTURE_SETSTATELASTMODIFIED\");\n\t\t\tint state = res.getState();\n\t\t\tif ((state == I_CmsConstants.C_STATE_NEW) || (state == I_CmsConstants.C_STATE_CHANGED)) {\n\t\t\t\tstmt.setInt(1, state);\n\t\t\t} else if (state == I_CmsConstants.C_STATE_UNCHANGED) {\n\t\t\t\tstmt.setInt(1, I_CmsConstants.C_STATE_CHANGED);\n\t\t\t} else {\n\t\t\t\tstmt.setInt(1, state);\n\t\t\t} \n\t\t\tstmt.setString(2, currentUser.getId().toString());\n\t\t\tstmt.setString(3, res.getId().toString());\n\t\t\tstmt.executeUpdate(); \n\t\t\t                      \n        } catch (SQLException e) {\n            throw m_sqlManager.getCmsException(this, null, CmsException.C_SQL_ERROR, e, false);\n        } finally {\n            m_sqlManager.closeAll(conn, stmt, null);\n        }   \n\n        return null;     \n    }","commit_id":"b0cbd2a8e53e6de7afb16c53e869157e47f56f29","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Renames the file to the new name.\n     *\n     * @param project The prect in which the resource will be used.\n     * @param onlineProject The online project of the OpenCms.\n     * @param userId The user id\n     * @param oldfileID The id of the resource which will be renamed.\n     * @param newname The new name of the resource.\n     *\n     * @throws CmsException Throws CmsException if operation was not succesful.\n     */\n    public int renameResource(CmsUser currentUser, CmsProject currentProject, CmsResource resource, String newname) throws CmsException {\n        PreparedStatement stmt = null;\n        Connection conn = null;\n        int count = 0;\n        long dateModified = resource.isTouched() ? resource.getDateLastModified() : System.currentTimeMillis();\n        \n        try {\n            conn = m_sqlManager.getConnection(currentProject);\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_RENAME\");\n            stmt.setString(1, newname);\n            stmt.setTimestamp(2, new Timestamp(dateModified));\n            stmt.setString(3, currentUser.getId().toString());\n            int state = resource.getState();\n            if ((state == I_CmsConstants.C_STATE_NEW) || (state == I_CmsConstants.C_STATE_CHANGED)) {\n                stmt.setInt(4, state);\n            } else if (state == I_CmsConstants.C_STATE_UNCHANGED) {\n                stmt.setInt(4, I_CmsConstants.C_STATE_CHANGED);\n            } else {\n                stmt.setInt(4, state);\n            }\n            stmt.setString(5, resource.getId().toString());\n            count = stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw m_sqlManager.getCmsException(this, null, CmsException.C_SQL_ERROR, e, false);\n        } finally {\n            m_sqlManager.closeAll(conn, stmt, null);\n        }\n        \n        return count;\n    }","id":81309,"modified_method":"/**\n     * Renames the file to the new name.\n     *\n     * @param project The prect in which the resource will be used.\n     * @param onlineProject The online project of the OpenCms.\n     * @param userId The user id\n     * @param oldfileID The id of the resource which will be renamed.\n     * @param newname The new name of the resource.\n     *\n     * @throws CmsException Throws CmsException if operation was not succesful.\n     */\n    public int renameResource(CmsUser currentUser, CmsProject currentProject, CmsResource resource, String newname) throws CmsException {\n        PreparedStatement stmt = null;\n        Connection conn = null;\n        int count = 0;\n        long dateModified = resource.isTouched() ? resource.getDateLastModified() : System.currentTimeMillis();\n        \n        try {\n            conn = m_sqlManager.getConnection(currentProject);\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_RENAME\");\n            stmt.setString(1, newname);\n            // stmt.setTimestamp(2, new Timestamp(dateModified));\n            stmt.setString(2, currentUser.getId().toString());\n            int state = resource.getState();\n            if ((state == I_CmsConstants.C_STATE_NEW) || (state == I_CmsConstants.C_STATE_CHANGED)) {\n                stmt.setInt(3, state);\n            } else if (state == I_CmsConstants.C_STATE_UNCHANGED) {\n                stmt.setInt(3, I_CmsConstants.C_STATE_CHANGED);\n            } else {\n                stmt.setInt(3, state);\n            }\n            stmt.setString(4, resource.getId().toString());\n            count = stmt.executeUpdate();\n            \n            // TODO: remove this later\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_SETLASTMODIFIED\");\n\t\t\tstmt.setTimestamp(1, new Timestamp(dateModified));\n\t\t\tstmt.setString(2,resource.getResourceId().toString());\n\t\t\tstmt.executeUpdate();\n            \n        } catch (SQLException e) {\n            throw m_sqlManager.getCmsException(this, null, CmsException.C_SQL_ERROR, e, false);\n        } finally {\n            m_sqlManager.closeAll(conn, stmt, null);\n        }\n        \n        return count;\n    }","commit_id":"b0cbd2a8e53e6de7afb16c53e869157e47f56f29","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.db.I_CmsVfsDriver#moveResourcemoveFile(com.opencms.file.CmsUser, com.opencms.file.CmsProject, com.opencms.file.CmsResource, com.opencms.file.CmsResource)\n     */\n    public int moveResource(CmsUser currentUser, CmsProject currentProject, CmsResource resource, CmsResource destinationFolder, String resourceName) throws CmsException {\n        Connection conn = null;\n        PreparedStatement stmt = null;   \n        long dateModified = resource.isTouched() ? resource.getDateLastModified() : System.currentTimeMillis();\n        int count = 0;\n        \n        try {\n            conn = m_sqlManager.getConnection(currentProject);\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_MOVE\");\n            stmt.setString(1, destinationFolder.getId().toString());\n            stmt.setTimestamp(2, new Timestamp(dateModified));\n            stmt.setString(3, currentUser.getId().toString());\n            int state = resource.getState();\n            if ((state == I_CmsConstants.C_STATE_NEW) || (state == I_CmsConstants.C_STATE_CHANGED)) {\n                stmt.setInt(4, state);\n            } else if (state == I_CmsConstants.C_STATE_UNCHANGED) {\n                stmt.setInt(4, I_CmsConstants.C_STATE_CHANGED);\n            } else {\n                stmt.setInt(4, state);\n            }\n            stmt.setString(5, resourceName);              \n            stmt.setString(6, resource.getId().toString());\n            count = stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw m_sqlManager.getCmsException(this, null, CmsException.C_SQL_ERROR, e, false);\n        } finally {\n            m_sqlManager.closeAll(conn, stmt, null);\n        } \n        \n        return count;       \n    }","id":81310,"modified_method":"/**\n     * @see org.opencms.db.I_CmsVfsDriver#moveResourcemoveFile(com.opencms.file.CmsUser, com.opencms.file.CmsProject, com.opencms.file.CmsResource, com.opencms.file.CmsResource)\n     */\n    public int moveResource(CmsUser currentUser, CmsProject currentProject, CmsResource resource, CmsResource destinationFolder, String resourceName) throws CmsException {\n        Connection conn = null;\n        PreparedStatement stmt = null;   \n        long dateModified = resource.isTouched() ? resource.getDateLastModified() : System.currentTimeMillis();\n        int count = 0;\n        \n        try {\n            conn = m_sqlManager.getConnection(currentProject);\n            stmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_MOVE\");\n            stmt.setString(1, destinationFolder.getId().toString());\n            // stmt.setTimestamp(2, new Timestamp(dateModified));\n            stmt.setString(2, currentUser.getId().toString());\n            int state = resource.getState();\n            if ((state == I_CmsConstants.C_STATE_NEW) || (state == I_CmsConstants.C_STATE_CHANGED)) {\n                stmt.setInt(3, state);\n            } else if (state == I_CmsConstants.C_STATE_UNCHANGED) {\n                stmt.setInt(3, I_CmsConstants.C_STATE_CHANGED);\n            } else {\n                stmt.setInt(3, state);\n            }\n            stmt.setString(4, resourceName);              \n            stmt.setString(5, resource.getId().toString());\n            count = stmt.executeUpdate();\n            \n\t\t\t// TODO: remove this later\n\t\t\tstmt = m_sqlManager.getPreparedStatement(conn, currentProject, \"C_RESOURCE_SETLASTMODIFIED\");\n\t\t\tstmt.setTimestamp(1, new Timestamp(dateModified));\n\t\t\tstmt.setString(2,resource.getResourceId().toString());\n\t\t\tstmt.executeUpdate();\n\t\t\t\n        } catch (SQLException e) {\n            throw m_sqlManager.getCmsException(this, null, CmsException.C_SQL_ERROR, e, false);\n        } finally {\n            m_sqlManager.closeAll(conn, stmt, null);\n        } \n        \n        return count;       \n    }","commit_id":"b0cbd2a8e53e6de7afb16c53e869157e47f56f29","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a DisttributedHashtable. Optionally the contents can be saved to\n     * persistemt storage using the {@link PersistenceManager}.\n     * @param groupname Name of the group to join\n     * @param factory Instance of a ChannelFactory to create the channel\n     * @param properties Protocol stack properties\n     * @param persistent Whether the contents should be persisted\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory, String properties,\n                                boolean persistent, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        this.persistent=persistent;\n        initMethods();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","id":81311,"modified_method":"/**\n     * Creates a DisttributedHashtable. Optionally the contents can be saved to\n     * persistemt storage using the {@link PersistenceManager}.\n     * @param groupname Name of the group to join\n     * @param factory Instance of a ChannelFactory to create the channel\n     * @param properties Protocol stack properties\n     * @param persistent Whether the contents should be persisted\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory, String properties,\n                                boolean persistent, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        this.persistent=persistent;\n        initSignatures();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void init(long state_timeout) throws ChannelClosedException, ChannelNotConnectedException {\n        initMethods();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n\n        // Changed by bela (jan 20 2003): start() has to be called by user (only when providing\n        // own channel). First, Channel.connect() has to be called, then start().\n        // start(state_timeout);\n    }","id":81312,"modified_method":"protected void init(long state_timeout) throws ChannelClosedException, ChannelNotConnectedException {\n        initSignatures();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n\n        // Changed by bela (jan 20 2003): start() has to be called by user (only when providing\n        // own channel). First, Channel.connect() has to be called, then start().\n        // start(state_timeout);\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"public DistributedHashtable(PullPushAdapter adapter, Serializable id) {\n        initMethods();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n    }","id":81313,"modified_method":"public DistributedHashtable(PullPushAdapter adapter, Serializable id) {\n        initSignatures();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Removes the key (and its corresponding value) from the Hashtable.\n\t * @param key - the key to be removed.\n\t * @return the value to which the key had been mapped in this hashtable, or null if the key did not have a mapping.\n\t */\n\tpublic Object remove(Object key) {\n\t\tObject retval = get(key);\n\n\t\t//Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                remove_method.setArgs(new Object[]{key});\n                disp.callRemoteMethods(\n                        null,\n                        remove_method,\n                        GroupRequest.GET_ALL,\n                        0);\n                //return retval;\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _remove(key);\n            //don't have to do retval = super.remove(..) as is done at the beginning\n        }\n        return retval;\n    }","id":81314,"modified_method":"/**\n\t * Removes the key (and its corresponding value) from the Hashtable.\n\t * @param key - the key to be removed.\n\t * @return the value to which the key had been mapped in this hashtable, or null if the key did not have a mapping.\n\t */\n\tpublic Object remove(Object key) {\n\t\tObject retval = get(key);\n\n\t\t//Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_remove\", new Object[]{key},\n                        remove_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n                //return retval;\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _remove(key);\n            //don't have to do retval = super.remove(..) as is done at the beginning\n        }\n        return retval;\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n     * used to register under that id. This is typically used when another building block is already using\n     * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n     * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n     * first block created on PullPushAdapter.\n     * @param adapter The PullPushAdapter which to use as underlying transport\n     * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n     *           requests/responses for different building blocks on top of PullPushAdapter.\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(PullPushAdapter adapter, Serializable id, long state_timeout)\n        throws ChannelNotConnectedException, ChannelClosedException {\n        initMethods();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n        start(state_timeout);\n    }","id":81315,"modified_method":"/**\n     * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n     * used to register under that id. This is typically used when another building block is already using\n     * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n     * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n     * first block created on PullPushAdapter.\n     * @param adapter The PullPushAdapter which to use as underlying transport\n     * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n     *           requests/responses for different building blocks on top of PullPushAdapter.\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(PullPushAdapter adapter, Serializable id, long state_timeout)\n        throws ChannelNotConnectedException, ChannelClosedException {\n        initSignatures();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n        start(state_timeout);\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a DistributedHashtable\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory,\n                                String properties, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        initMethods();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","id":81316,"modified_method":"/**\n     * Creates a DistributedHashtable\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory,\n                                String properties, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        initSignatures();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Copies all of the mappings from the specified Map to this Hashtable These mappings will replace any mappings that this Hashtable had for any of the keys currently in the specified Map.\n\t * @param m - Mappings to be stored in this map\n\t */\n\tpublic void putAll(Map m) {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                putAll_method.setArgs(new Object[]{m});\n                disp.callRemoteMethods(\n                        null,\n                        putAll_method,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Throwable t) {\n            }\n        }\n        else {\n            _putAll(m);\n        }\n    }","id":81317,"modified_method":"/**\n\t * Copies all of the mappings from the specified Map to this Hashtable These mappings will replace any mappings that this Hashtable had for any of the keys currently in the specified Map.\n\t * @param m - Mappings to be stored in this map\n\t */\n\tpublic void putAll(Map m) {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_putAll\", new Object[]{m}, \n                        putAll_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Throwable t) {\n            }\n        }\n        else {\n            _putAll(m);\n        }\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Maps the specified key to the specified value in the hashtable. Neither of both parameters can be null\n\t * @param key - the hashtable key\n\t * @param value - the value\n\t * @return the previous value of the specified key in this hashtable, or null if it did not have one\n\t */\n    public Object put(Object key, Object value) {\n        Object prev_val=get(key);\n\n        //Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                put_method.setArgs(new Object[]{key,value});\n                disp.callRemoteMethods(\n                        null,\n                        put_method,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _put(key, value);\n            //don't have to do prev_val = super.put(..) as is done at the beginning\n        }\n        return prev_val;\n\t}","id":81318,"modified_method":"/**\n\t * Maps the specified key to the specified value in the hashtable. Neither of both parameters can be null\n\t * @param key - the hashtable key\n\t * @param value - the value\n\t * @return the previous value of the specified key in this hashtable, or null if it did not have one\n\t */\n    public Object put(Object key, Object value) {\n        Object prev_val=get(key);\n\n        //Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_put\", new Object[]{key,value},\n                        put_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _put(key, value);\n            //don't have to do prev_val = super.put(..) as is done at the beginning\n        }\n        return prev_val;\n\t}","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Clears this hashtable so that it contains no keys\n\t */\n\tpublic void clear() {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null,\n                        clear_method,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception=\" + e);\n            }\n        }\n        else {\n            _clear();\n        }\n    }","id":81319,"modified_method":"/**\n\t * Clears this hashtable so that it contains no keys\n\t */\n\tpublic void clear() {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_clear\", null,\n                        clear_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception=\" + e);\n            }\n        }\n        else {\n            _clear();\n        }\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a DistributedQueue\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedQueue(String groupname, ChannelFactory factory, String properties, long state_timeout)\n                     throws ChannelException\n    {\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"DistributedQueue(\" + groupname + ',' + properties + ',' + state_timeout);\n        }\n\n        this.groupname = groupname;\n        initMethods();\n        internalQueue = new LinkedList();\n        channel = (factory != null) ? factory.createChannel(properties) : new JChannel(properties);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","id":81320,"modified_method":"/**\n     * Creates a DistributedQueue\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedQueue(String groupname, ChannelFactory factory, String properties, long state_timeout)\n                     throws ChannelException\n    {\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"DistributedQueue(\" + groupname + ',' + properties + ',' + state_timeout);\n        }\n\n        this.groupname = groupname;\n        initSignatures();\n        internalQueue = new LinkedList();\n        channel = (factory != null) ? factory.createChannel(properties) : new JChannel(properties);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"public void reset()\n    {\n        try\n        {\n            disp.callRemoteMethods(null, reset_method, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"DistributedQueue.reset(\" + groupname + ')', e);\n        }\n    }","id":81321,"modified_method":"public void reset()\n    {\n        try\n        {\n            disp.callRemoteMethods(null, \"_reset\", null, reset_signature, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"DistributedQueue.reset(\" + groupname + ')', e);\n        }\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Try to return the first objet in the queue.It does not wait for an object.\n     * @return the first object in the queue or null if none were found.\n     */\n    public Object remove()\n    {\n        Object retval = null;\n        RspList rsp = disp.callRemoteMethods(null, remove_method, GroupRequest.GET_ALL, internal_timeout);\n        Vector results = rsp.getResults();\n\n        if (results.size() > 0)\n        {\n            retval = results.elementAt(0);\n\n            if (logger.isDebugEnabled())\n            {\n                checkResult(rsp, retval);\n            }\n        }\n\n        return retval;\n    }","id":81322,"modified_method":"/**\n     * Try to return the first objet in the queue.It does not wait for an object.\n     * @return the first object in the queue or null if none were found.\n     */\n    public Object remove()\n    {\n        Object retval = null;\n        RspList rsp = disp.callRemoteMethods(null, \"_remove\", null, remove_signature, GroupRequest.GET_ALL, internal_timeout);\n        Vector results = rsp.getResults();\n\n        if (results.size() > 0)\n        {\n            retval = results.elementAt(0);\n\n            if (logger.isDebugEnabled())\n            {\n                checkResult(rsp, retval);\n            }\n        }\n\n        return retval;\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void init()\n    {\n        initMethods();\n        internalQueue = new LinkedList();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","id":81323,"modified_method":"protected void init()\n    {\n        initSignatures();\n        internalQueue = new LinkedList();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n      * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n      * used to register under that id. This is typically used when another building block is already using\n      * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n      * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n      * first block created on PullPushAdapter.\n      * The caller needs to call start(), before using the this block. It gives the opportunity for the caller\n      * to register as a lessoner for Notifications events.\n      * @param adapter The PullPushAdapter which to use as underlying transport\n      * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n      *           requests/responses for different building blocks on top of PullPushAdapter.\n      */\n    public DistributedQueue(PullPushAdapter adapter, Serializable id)\n    {\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n\n        initMethods();\n        internalQueue = new LinkedList();\n\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(adapter, id, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","id":81324,"modified_method":"/**\n      * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n      * used to register under that id. This is typically used when another building block is already using\n      * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n      * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n      * first block created on PullPushAdapter.\n      * The caller needs to call start(), before using the this block. It gives the opportunity for the caller\n      * to register as a lessoner for Notifications events.\n      * @param adapter The PullPushAdapter which to use as underlying transport\n      * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n      *           requests/responses for different building blocks on top of PullPushAdapter.\n      */\n    public DistributedQueue(PullPushAdapter adapter, Serializable id)\n    {\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n\n        initSignatures();\n        internalQueue = new LinkedList();\n\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(adapter, id, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the speficied element at the top of the queue\n     * @param value\n     */\n    public void addAtHead(Object value)\n    {\n        try\n        {\n            addAtHead_method.setArgs(new Object[]{value});\n            disp.callRemoteMethods(null, addAtHead_method, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAtHead value \" + value, e);\n        }\n\n        return;\n    }","id":81325,"modified_method":"/**\n     * Add the speficied element at the top of the queue\n     * @param value\n     */\n    public void addAtHead(Object value)\n    {\n        try\n        {\n            disp.callRemoteMethods(null, \"_addAtHead\", new Object[]{value}, addAtHead_signature, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAtHead value \" + value, e);\n        }\n\n        return;\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the speficied element at the bottom of the queue\n     * @param value\n     */\n    public void add(Object value)\n    {\n        try\n        {\n            Object retval = null;\n            add_method.setArgs(new Object[]{value});\n\n            RspList rsp = disp.callRemoteMethods(null, add_method, GroupRequest.GET_ALL, 0);\n            Vector results = rsp.getResults();\n\n            if (results.size() > 0)\n            {\n                retval = results.elementAt(0);\n\n                if (logger.isDebugEnabled())\n                {\n                    checkResult(rsp, retval);\n                }\n            }\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to add value \" + value, e);\n        }\n\n        return;\n    }","id":81326,"modified_method":"/**\n     * Add the speficied element at the bottom of the queue\n     * @param value\n     */\n    public void add(Object value)\n    {\n        try\n        {\n            Object retval = null;\n\n            RspList rsp = disp.callRemoteMethods(null, \"_add\", new Object[]{value}, add_signature, GroupRequest.GET_ALL, 0);\n            Vector results = rsp.getResults();\n\n            if (results.size() > 0)\n            {\n                retval = results.elementAt(0);\n\n                if (logger.isDebugEnabled())\n                {\n                    checkResult(rsp, retval);\n                }\n            }\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to add value \" + value, e);\n        }\n\n        return;\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the speficied collection to the top of the queue.\n     * Elements are added in the order that they are returned by the specified\n     * collection's iterator.\n     * @param values\n     */\n    public void addAll(Collection values)\n    {\n        try\n        {\n            addAll_method.setArgs(new Object[]{values});\n            disp.callRemoteMethods(null, addAll_method, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAll value: \" + values, e);\n        }\n\n        return;\n    }","id":81327,"modified_method":"/**\n     * Add the speficied collection to the top of the queue.\n     * Elements are added in the order that they are returned by the specified\n     * collection's iterator.\n     * @param values\n     */\n    public void addAll(Collection values)\n    {\n        try\n        {\n            disp.callRemoteMethods(null, \"_addAll\", new Object[]{values}, addAll_signature, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAll value: \" + values, e);\n        }\n\n        return;\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @param timeout The time to wait until an entry is retrieved in milliseconds. A value of 0 means wait forever.\n     * @return the first object in the queue or null if none were found\n     */\n    public Object remove(long timeout)\n    {\n        Object retval = null;\n        long start = System.currentTimeMillis();\n\n        if (timeout <= 0)\n        {\n            while (!stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, remove_method, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        synchronized (mutex)\n                        {\n                            mutex.wait();\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n        else\n        {\n            while (((System.currentTimeMillis() - start) < timeout) && !stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, remove_method, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        long delay = timeout - (System.currentTimeMillis() - start);\n\n                        synchronized (mutex)\n                        {\n                            if (delay > 0)\n                            {\n                                mutex.wait(delay);\n                            }\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n\n        return retval;\n    }","id":81328,"modified_method":"/**\n     * @param timeout The time to wait until an entry is retrieved in milliseconds. A value of 0 means wait forever.\n     * @return the first object in the queue or null if none were found\n     */\n    public Object remove(long timeout)\n    {\n        Object retval = null;\n        long start = System.currentTimeMillis();\n\n        if (timeout <= 0)\n        {\n            while (!stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, \"_remove\", null, remove_signature, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        synchronized (mutex)\n                        {\n                            mutex.wait();\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n        else\n        {\n            while (((System.currentTimeMillis() - start) < timeout) && !stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, \"_remove\", null, remove_signature, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        long delay = timeout - (System.currentTimeMillis() - start);\n\n                        synchronized (mutex)\n                        {\n                            if (delay > 0)\n                            {\n                                mutex.wait(delay);\n                            }\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n\n        return retval;\n    }","commit_id":"944dca521119aecc8d3b5d362988b35ea40c3635","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Maps the specified key to the specified value in the hashtable. Neither of both parameters can be null\n\t * @param key - the hashtable key\n\t * @param value - the value\n\t * @return the previous value of the specified key in this hashtable, or null if it did not have one\n\t */\n    public Object put(Object key, Object value) {\n        Object prev_val=get(key);\n\n        //Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                put_method.setArgs(new Object[]{key,value});\n                disp.callRemoteMethods(\n                        null,\n                        put_method,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _put(key, value);\n            //don't have to do prev_val = super.put(..) as is done at the beginning\n        }\n        return prev_val;\n\t}","id":81329,"modified_method":"/**\n\t * Maps the specified key to the specified value in the hashtable. Neither of both parameters can be null\n\t * @param key - the hashtable key\n\t * @param value - the value\n\t * @return the previous value of the specified key in this hashtable, or null if it did not have one\n\t */\n    public Object put(Object key, Object value) {\n        Object prev_val=get(key);\n\n        //Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_put\", new Object[]{key,value},\n                        put_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _put(key, value);\n            //don't have to do prev_val = super.put(..) as is done at the beginning\n        }\n        return prev_val;\n\t}","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void init(long state_timeout) throws ChannelClosedException, ChannelNotConnectedException {\n        initMethods();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n\n        // Changed by bela (jan 20 2003): start() has to be called by user (only when providing\n        // own channel). First, Channel.connect() has to be called, then start().\n        // start(state_timeout);\n    }","id":81330,"modified_method":"protected void init(long state_timeout) throws ChannelClosedException, ChannelNotConnectedException {\n        initSignatures();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n\n        // Changed by bela (jan 20 2003): start() has to be called by user (only when providing\n        // own channel). First, Channel.connect() has to be called, then start().\n        // start(state_timeout);\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Removes the key (and its corresponding value) from the Hashtable.\n\t * @param key - the key to be removed.\n\t * @return the value to which the key had been mapped in this hashtable, or null if the key did not have a mapping.\n\t */\n\tpublic Object remove(Object key) {\n\t\tObject retval = get(key);\n\n\t\t//Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                remove_method.setArgs(new Object[]{key});\n                disp.callRemoteMethods(\n                        null,\n                        remove_method,\n                        GroupRequest.GET_ALL,\n                        0);\n                //return retval;\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _remove(key);\n            //don't have to do retval = super.remove(..) as is done at the beginning\n        }\n        return retval;\n    }","id":81331,"modified_method":"/**\n\t * Removes the key (and its corresponding value) from the Hashtable.\n\t * @param key - the key to be removed.\n\t * @return the value to which the key had been mapped in this hashtable, or null if the key did not have a mapping.\n\t */\n\tpublic Object remove(Object key) {\n\t\tObject retval = get(key);\n\n\t\t//Changes done by <aos>\n        //if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_remove\", new Object[]{key},\n                        remove_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n                //return retval;\n            }\n            catch(Exception e) {\n                //return null;\n            }\n        }\n        else {\n            _remove(key);\n            //don't have to do retval = super.remove(..) as is done at the beginning\n        }\n        return retval;\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Clears this hashtable so that it contains no keys\n\t */\n\tpublic void clear() {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null,\n                        clear_method,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception=\" + e);\n            }\n        }\n        else {\n            _clear();\n        }\n    }","id":81332,"modified_method":"/**\n\t * Clears this hashtable so that it contains no keys\n\t */\n\tpublic void clear() {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_clear\", null,\n                        clear_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception=\" + e);\n            }\n        }\n        else {\n            _clear();\n        }\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Copies all of the mappings from the specified Map to this Hashtable These mappings will replace any mappings that this Hashtable had for any of the keys currently in the specified Map.\n\t * @param m - Mappings to be stored in this map\n\t */\n\tpublic void putAll(Map m) {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                putAll_method.setArgs(new Object[]{m});\n                disp.callRemoteMethods(\n                        null,\n                        putAll_method,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Throwable t) {\n            }\n        }\n        else {\n            _putAll(m);\n        }\n    }","id":81333,"modified_method":"/**\n\t * Copies all of the mappings from the specified Map to this Hashtable These mappings will replace any mappings that this Hashtable had for any of the keys currently in the specified Map.\n\t * @param m - Mappings to be stored in this map\n\t */\n\tpublic void putAll(Map m) {\n\t\t//Changes done by <aos>\n\t\t//if true, propagate action to the group\n        if(send_message == true) {\n            try {\n                disp.callRemoteMethods(\n                        null, \"_putAll\", new Object[]{m}, \n                        putAll_signature,\n                        GroupRequest.GET_ALL,\n                        0);\n            }\n            catch(Throwable t) {\n            }\n        }\n        else {\n            _putAll(m);\n        }\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n     * used to register under that id. This is typically used when another building block is already using\n     * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n     * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n     * first block created on PullPushAdapter.\n     * @param adapter The PullPushAdapter which to use as underlying transport\n     * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n     *           requests/responses for different building blocks on top of PullPushAdapter.\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(PullPushAdapter adapter, Serializable id, long state_timeout)\n        throws ChannelNotConnectedException, ChannelClosedException {\n        initMethods();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n        start(state_timeout);\n    }","id":81334,"modified_method":"/**\n     * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n     * used to register under that id. This is typically used when another building block is already using\n     * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n     * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n     * first block created on PullPushAdapter.\n     * @param adapter The PullPushAdapter which to use as underlying transport\n     * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n     *           requests/responses for different building blocks on top of PullPushAdapter.\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(PullPushAdapter adapter, Serializable id, long state_timeout)\n        throws ChannelNotConnectedException, ChannelClosedException {\n        initSignatures();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n        start(state_timeout);\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a DisttributedHashtable. Optionally the contents can be saved to\n     * persistemt storage using the {@link PersistenceManager}.\n     * @param groupname Name of the group to join\n     * @param factory Instance of a ChannelFactory to create the channel\n     * @param properties Protocol stack properties\n     * @param persistent Whether the contents should be persisted\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory, String properties,\n                                boolean persistent, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        this.persistent=persistent;\n        initMethods();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","id":81335,"modified_method":"/**\n     * Creates a DisttributedHashtable. Optionally the contents can be saved to\n     * persistemt storage using the {@link PersistenceManager}.\n     * @param groupname Name of the group to join\n     * @param factory Instance of a ChannelFactory to create the channel\n     * @param properties Protocol stack properties\n     * @param persistent Whether the contents should be persisted\n     * @param state_timeout Max number of milliseconds to wait until state is\n     * retrieved\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory, String properties,\n                                boolean persistent, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        this.persistent=persistent;\n        initSignatures();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"public DistributedHashtable(PullPushAdapter adapter, Serializable id) {\n        initMethods();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n    }","id":81336,"modified_method":"public DistributedHashtable(PullPushAdapter adapter, Serializable id) {\n        initSignatures();\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n        disp=new RpcDispatcher(adapter, id, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.valueOf(true));\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a DistributedHashtable\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory,\n                                String properties, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        initMethods();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","id":81337,"modified_method":"/**\n     * Creates a DistributedHashtable\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedHashtable(String groupname, ChannelFactory factory,\n                                String properties, long state_timeout)\n            throws ChannelException {\n        this.groupname=groupname;\n        initSignatures();\n        channel=factory != null ? factory.createChannel(properties) : new JChannel(properties);\n        disp=new RpcDispatcher(channel, this, this, this);\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void init()\n    {\n        initMethods();\n        internalQueue = new LinkedList();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","id":81338,"modified_method":"protected void init()\n    {\n        initSignatures();\n        internalQueue = new LinkedList();\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Try to return the first objet in the queue.It does not wait for an object.\n     * @return the first object in the queue or null if none were found.\n     */\n    public Object remove()\n    {\n        Object retval = null;\n        RspList rsp = disp.callRemoteMethods(null, remove_method, GroupRequest.GET_ALL, internal_timeout);\n        Vector results = rsp.getResults();\n\n        if (results.size() > 0)\n        {\n            retval = results.elementAt(0);\n\n            if (logger.isDebugEnabled())\n            {\n                checkResult(rsp, retval);\n            }\n        }\n\n        return retval;\n    }","id":81339,"modified_method":"/**\n     * Try to return the first objet in the queue.It does not wait for an object.\n     * @return the first object in the queue or null if none were found.\n     */\n    public Object remove()\n    {\n        Object retval = null;\n        RspList rsp = disp.callRemoteMethods(null, \"_remove\", null, remove_signature, GroupRequest.GET_ALL, internal_timeout);\n        Vector results = rsp.getResults();\n\n        if (results.size() > 0)\n        {\n            retval = results.elementAt(0);\n\n            if (logger.isDebugEnabled())\n            {\n                checkResult(rsp, retval);\n            }\n        }\n\n        return retval;\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n      * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n      * used to register under that id. This is typically used when another building block is already using\n      * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n      * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n      * first block created on PullPushAdapter.\n      * The caller needs to call start(), before using the this block. It gives the opportunity for the caller\n      * to register as a lessoner for Notifications events.\n      * @param adapter The PullPushAdapter which to use as underlying transport\n      * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n      *           requests/responses for different building blocks on top of PullPushAdapter.\n      */\n    public DistributedQueue(PullPushAdapter adapter, Serializable id)\n    {\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n\n        initMethods();\n        internalQueue = new LinkedList();\n\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(adapter, id, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","id":81340,"modified_method":"/**\n      * Uses a user-provided PullPushAdapter to create the dispatcher rather than a Channel. If id is non-null, it will be\n      * used to register under that id. This is typically used when another building block is already using\n      * PullPushAdapter, and we want to add this building block in addition. The id is the used to discriminate\n      * between messages for the various blocks on top of PullPushAdapter. If null, we will assume we are the\n      * first block created on PullPushAdapter.\n      * The caller needs to call start(), before using the this block. It gives the opportunity for the caller\n      * to register as a lessoner for Notifications events.\n      * @param adapter The PullPushAdapter which to use as underlying transport\n      * @param id A serializable object (e.g. an Integer) used to discriminate (multiplex/demultiplex) between\n      *           requests/responses for different building blocks on top of PullPushAdapter.\n      */\n    public DistributedQueue(PullPushAdapter adapter, Serializable id)\n    {\n        this.channel = (Channel)adapter.getTransport();\n        this.groupname = this.channel.getChannelName();\n\n        initSignatures();\n        internalQueue = new LinkedList();\n\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        disp = new RpcDispatcher(adapter, id, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the speficied element at the top of the queue\n     * @param value\n     */\n    public void addAtHead(Object value)\n    {\n        try\n        {\n            addAtHead_method.setArgs(new Object[]{value});\n            disp.callRemoteMethods(null, addAtHead_method, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAtHead value \" + value, e);\n        }\n\n        return;\n    }","id":81341,"modified_method":"/**\n     * Add the speficied element at the top of the queue\n     * @param value\n     */\n    public void addAtHead(Object value)\n    {\n        try\n        {\n            disp.callRemoteMethods(null, \"_addAtHead\", new Object[]{value}, addAtHead_signature, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAtHead value \" + value, e);\n        }\n\n        return;\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"public void reset()\n    {\n        try\n        {\n            disp.callRemoteMethods(null, reset_method, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"DistributedQueue.reset(\" + groupname + ')', e);\n        }\n    }","id":81342,"modified_method":"public void reset()\n    {\n        try\n        {\n            disp.callRemoteMethods(null, \"_reset\", null, reset_signature, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"DistributedQueue.reset(\" + groupname + ')', e);\n        }\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the speficied collection to the top of the queue.\n     * Elements are added in the order that they are returned by the specified\n     * collection's iterator.\n     * @param values\n     */\n    public void addAll(Collection values)\n    {\n        try\n        {\n            addAll_method.setArgs(new Object[]{values});\n            disp.callRemoteMethods(null, addAll_method, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAll value: \" + values, e);\n        }\n\n        return;\n    }","id":81343,"modified_method":"/**\n     * Add the speficied collection to the top of the queue.\n     * Elements are added in the order that they are returned by the specified\n     * collection's iterator.\n     * @param values\n     */\n    public void addAll(Collection values)\n    {\n        try\n        {\n            disp.callRemoteMethods(null, \"_addAll\", new Object[]{values}, addAll_signature, GroupRequest.GET_ALL, 0);\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to addAll value: \" + values, e);\n        }\n\n        return;\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a DistributedQueue\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedQueue(String groupname, ChannelFactory factory, String properties, long state_timeout)\n                     throws ChannelException\n    {\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"DistributedQueue(\" + groupname + ',' + properties + ',' + state_timeout);\n        }\n\n        this.groupname = groupname;\n        initMethods();\n        internalQueue = new LinkedList();\n        channel = (factory != null) ? factory.createChannel(properties) : new JChannel(properties);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","id":81344,"modified_method":"/**\n     * Creates a DistributedQueue\n     * @param groupname The name of the group to join\n     * @param factory The ChannelFactory which will be used to create a channel\n     * @param properties The property string to be used to define the channel\n     * @param state_timeout The time to wait until state is retrieved in milliseconds. A value of 0 means wait forever.\n     */\n    public DistributedQueue(String groupname, ChannelFactory factory, String properties, long state_timeout)\n                     throws ChannelException\n    {\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"DistributedQueue(\" + groupname + ',' + properties + ',' + state_timeout);\n        }\n\n        this.groupname = groupname;\n        initSignatures();\n        internalQueue = new LinkedList();\n        channel = (factory != null) ? factory.createChannel(properties) : new JChannel(properties);\n        disp = new RpcDispatcher(channel, this, this, this);\n        disp.setDeadlockDetection(false); // To ensure strict FIFO MethodCall\n        channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n        channel.connect(groupname);\n        start(state_timeout);\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the speficied element at the bottom of the queue\n     * @param value\n     */\n    public void add(Object value)\n    {\n        try\n        {\n            Object retval = null;\n            add_method.setArgs(new Object[]{value});\n\n            RspList rsp = disp.callRemoteMethods(null, add_method, GroupRequest.GET_ALL, 0);\n            Vector results = rsp.getResults();\n\n            if (results.size() > 0)\n            {\n                retval = results.elementAt(0);\n\n                if (logger.isDebugEnabled())\n                {\n                    checkResult(rsp, retval);\n                }\n            }\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to add value \" + value, e);\n        }\n\n        return;\n    }","id":81345,"modified_method":"/**\n     * Add the speficied element at the bottom of the queue\n     * @param value\n     */\n    public void add(Object value)\n    {\n        try\n        {\n            Object retval = null;\n\n            RspList rsp = disp.callRemoteMethods(null, \"_add\", new Object[]{value}, add_signature, GroupRequest.GET_ALL, 0);\n            Vector results = rsp.getResults();\n\n            if (results.size() > 0)\n            {\n                retval = results.elementAt(0);\n\n                if (logger.isDebugEnabled())\n                {\n                    checkResult(rsp, retval);\n                }\n            }\n        }\n         catch (Exception e)\n        {\n            logger.error(\"Unable to add value \" + value, e);\n        }\n\n        return;\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @param timeout The time to wait until an entry is retrieved in milliseconds. A value of 0 means wait forever.\n     * @return the first object in the queue or null if none were found\n     */\n    public Object remove(long timeout)\n    {\n        Object retval = null;\n        long start = System.currentTimeMillis();\n\n        if (timeout <= 0)\n        {\n            while (!stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, remove_method, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        synchronized (mutex)\n                        {\n                            mutex.wait();\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n        else\n        {\n            while (((System.currentTimeMillis() - start) < timeout) && !stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, remove_method, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        long delay = timeout - (System.currentTimeMillis() - start);\n\n                        synchronized (mutex)\n                        {\n                            if (delay > 0)\n                            {\n                                mutex.wait(delay);\n                            }\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n\n        return retval;\n    }","id":81346,"modified_method":"/**\n     * @param timeout The time to wait until an entry is retrieved in milliseconds. A value of 0 means wait forever.\n     * @return the first object in the queue or null if none were found\n     */\n    public Object remove(long timeout)\n    {\n        Object retval = null;\n        long start = System.currentTimeMillis();\n\n        if (timeout <= 0)\n        {\n            while (!stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, \"_remove\", null, remove_signature, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        synchronized (mutex)\n                        {\n                            mutex.wait();\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n        else\n        {\n            while (((System.currentTimeMillis() - start) < timeout) && !stopped && (retval == null))\n            {\n                RspList rsp = disp.callRemoteMethods(null, \"_remove\", null, remove_signature, GroupRequest.GET_ALL, internal_timeout);\n                Vector results = rsp.getResults();\n\n                if (results.size() > 0)\n                {\n                    retval = results.elementAt(0);\n\n                    if (logger.isDebugEnabled())\n                    {\n                        checkResult(rsp, retval);\n                    }\n                }\n\n                if (retval == null)\n                {\n                    try\n                    {\n                        long delay = timeout - (System.currentTimeMillis() - start);\n\n                        synchronized (mutex)\n                        {\n                            if (delay > 0)\n                            {\n                                mutex.wait(delay);\n                            }\n                        }\n                    }\n                     catch (InterruptedException e)\n                    {\n                    }\n                }\n            }\n        }\n\n        return retval;\n    }","commit_id":"9dc5ab054afcfd71fd77544a2d059ddb60d3dc03","url":"https://github.com/belaban/JGroups"},{"original_method":"private NodeTypesComponent getNodeTypesComponent(SNode node) {\n    NodeTypesComponent typesComponent =\n      NodeTypesComponentsRepository.getInstance().createTypeCheckingContext(node.getContainingRoot()).getBaseNodeTypesComponent();\n    return typesComponent;\n  }","id":81347,"modified_method":"@Nullable\n  private NodeTypesComponent getNodeTypesComponent(SNode node) {\n    if (node == null) {\n      return null;\n    }\n    TypeCheckingContext context = NodeTypesComponentsRepository.getInstance().createTypeCheckingContext(node.getContainingRoot());\n    if (context == null) {\n      return null;\n    }\n    NodeTypesComponent typesComponent =\n      context.getBaseNodeTypesComponent();\n    return typesComponent;\n  }","commit_id":"12e8cd197cfb19699e97a7a44519cd44441b82bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public NodeTypesComponent createNodeTypesComponent(SNode node) {\n    return createTypeCheckingContext(node).getNodeTypesComponent();\n  }","id":81348,"modified_method":"@Deprecated\n  public NodeTypesComponent createNodeTypesComponent(SNode node) {\n    TypeCheckingContext context = createTypeCheckingContext(node);\n    return context == null ? null : context.getNodeTypesComponent();\n  }","commit_id":"1c1b04175d5446a693bf934781076ddeba5b79f7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public SNode getTypeOf(SNode node) {\n    if (node == null) return null;\n    if (NodeTypesComponentsRepository.getInstance().createTypeCheckingContext(node).isInEditorQueries()) {\n      return getTypeOf_resolveMode(node, true);\n    } else if (myIsGeneration && TypesystemPreferencesComponent.getInstance().isGenerationOptimizationEnabled()) {\n      return getTypeOf_generationMode(node);\n    } else {\n      return getTypeOf_normalMode(node);\n    }\n  }","id":81349,"modified_method":"@Nullable\n  public SNode getTypeOf(SNode node) {\n    if (node == null) return null;\n    TypeCheckingContext context = NodeTypesComponentsRepository.getInstance().createTypeCheckingContext(node);\n    if (context != null && context.isInEditorQueries()) {\n      return getTypeOf_resolveMode(node, true);\n    } else if (myIsGeneration && TypesystemPreferencesComponent.getInstance().isGenerationOptimizationEnabled()) {\n      return getTypeOf_generationMode(node);\n    } else {\n      return getTypeOf_normalMode(node);\n    }\n  }","commit_id":"f93c0449a2c764f9920f94c230510df6d364c86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,\n                                        BeanDefinitionRegistry registry) {\n        for (Method method : REFLECTIONS.getMethodsAnnotatedWith(Factory.class)) {\n            String methodName = method.getName();\n            Class sourceType = getSourceType(method);\n            Class targetType = method.getReturnType();\n            Class beanType = method.getDeclaringClass();\n            BeanDefinitionHolder holder = createConverterBean(beanType, methodName, sourceType, targetType);\n            BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);\n        }\n\n        for (Field field : REFLECTIONS.getFieldsAnnotatedWith(ServiceName.class)) {\n            Alias alias = field.getAnnotation(Alias.class);\n            ServiceName name = field.getAnnotation(ServiceName.class);\n            Protocol protocol = field.getAnnotation(Protocol.class);\n            External external = field.getAnnotation(External.class);\n\n            String serviceProtocol = protocol != null ? protocol.value() : DEFAULT_PROTOCOL;\n            String serviceAlias = alias != null ? alias.value() : name.value();\n            Boolean serviceExternal = external != null && external.value();\n\n            Service serviceInstance = getService(name.value());\n\n            //Add annotation info as additional properties\n            serviceInstance.getAdditionalProperties().put(ALIAS, serviceAlias);\n            serviceInstance.getAdditionalProperties().put(PROTOCOL, serviceProtocol);\n            serviceInstance.getAdditionalProperties().put(EXTERNAL, serviceExternal);\n\n            Class targetClass = field.getType();\n            BeanDefinitionHolder holder = createServiceDefinition(serviceInstance, serviceAlias, serviceProtocol, targetClass);\n            BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);\n        }\n    }","id":81350,"modified_method":"@Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,\n                                        BeanDefinitionRegistry registry) {\n\n        for (Method method : REFLECTIONS.getMethodsAnnotatedWith(Factory.class)) {\n            String methodName = method.getName();\n            Class sourceType = getSourceType(method);\n            Class targetType = method.getReturnType();\n            Class beanType = method.getDeclaringClass();\n            BeanDefinitionHolder holder = createConverterBean(beanType, methodName, sourceType, targetType);\n            BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);\n        }\n\n        for (Field field : REFLECTIONS.getFieldsAnnotatedWith(ServiceName.class)) {\n            Class targetClass = field.getType();\n            Alias alias = field.getAnnotation(Alias.class);\n            ServiceName name = field.getAnnotation(ServiceName.class);\n            PortName port = field.getAnnotation(PortName.class);\n            Protocol protocol = field.getAnnotation(Protocol.class);\n            External external = field.getAnnotation(External.class);\n\n            String serviceName = name != null ? name.value() : null;\n\n            //We copy the service since we are going to add properties to it.\n            Service serviceInstance = new ServiceBuilder(getService(serviceName)).build();\n            String servicePort = port != null ? port.value() : null;\n            String serviceProtocol = protocol != null ? protocol.value() : DEFAULT_PROTOCOL;\n            Boolean serviceExternal = external != null && external.value();\n            String serviceAlias = alias != null ? alias.value() : createAlias(serviceName, targetClass, serviceProtocol, servicePort, serviceExternal);\n\n            //Add annotation info as additional properties\n            serviceInstance.getAdditionalProperties().put(ALIAS, serviceAlias);\n            serviceInstance.getAdditionalProperties().put(PROTOCOL, serviceProtocol);\n            serviceInstance.getAdditionalProperties().put(EXTERNAL, serviceExternal);\n\n            //We don't want to add a fallback value to the attributes.\n            if (port != null) {\n                serviceInstance.getAdditionalProperties().put(PORT, servicePort);\n            }\n\n            BeanDefinitionHolder holder = createServiceDefinition(serviceInstance, serviceAlias, serviceProtocol, servicePort, targetClass);\n            BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);\n        }\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private BeanDefinitionHolder createServiceDefinition(Service service, String alias, String protocol, Class type) {\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder\n                .genericBeanDefinition(KubernetesServiceFactoryBean.class);\n\n        builder.addPropertyValue(\"name\", alias);\n        builder.addPropertyValue(\"service\", service);\n        builder.addPropertyValue(\"type\", type.getCanonicalName());\n        builder.setAutowireMode(Autowire.BY_TYPE.value());\n        //Add protocol qualifier\n        builder.getBeanDefinition().addQualifier(new AutowireCandidateQualifier(Protocol.class, protocol));\n        return new BeanDefinitionHolder(builder.getBeanDefinition(), alias);\n    }","id":81351,"modified_method":"private BeanDefinitionHolder createServiceDefinition(Service service, String alias, String protocol, String port, Class type) {\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder\n                .genericBeanDefinition(KubernetesServiceFactoryBean.class);\n\n        builder.addPropertyValue(\"name\", alias);\n        builder.addPropertyValue(\"service\", service);\n        builder.addPropertyValue(\"port\", port);\n        builder.addPropertyValue(\"type\", type.getCanonicalName());\n        builder.setAutowireMode(Autowire.BY_TYPE.value());\n        //Add protocol qualifier\n        builder.getBeanDefinition().addQualifier(new AutowireCandidateQualifier(ServiceName.class, KubernetesHelper.getName(service)));\n        builder.getBeanDefinition().addQualifier(new AutowireCandidateQualifier(Protocol.class, protocol));\n        builder.getBeanDefinition().addQualifier(new AutowireCandidateQualifier(PortName.class, port != null ? port : \"\"));\n        return new BeanDefinitionHolder(builder.getBeanDefinition(), alias);\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Bean\n    public KubernetesClient getKubernetesClient(OpenShiftClient openShiftClient) throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n\n        mock.getMasterUrl().andReturn(new URL(\"https://kubernetes.default.svc\")).anyTimes();\n        mock.rootPaths().andReturn(new RootPathsBuilder()\n                .addToPaths(\"/api\",\n                        \"/api/v1beta3\",\n                        \"/api/v1\",\n                        \"/controllers\",\n                        \"/healthz\",\n                        \"/healthz/ping\",\n                        \"/logs/\",\n                        \"/metrics\",\n                        \"/ready\",\n                        \"/osapi\",\n                        \"/osapi/v1beta3\",\n                        \"/oapi\",\n                        \"/oapi/v1\",\n                        \"/swaggerapi/\")\n                .build()).anyTimes();\n\n        Service service1 = new ServiceBuilder()\n                .withNewMetadata().withName(\"service1\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withProtocol(\"TCP\")\n                .withPort(80)\n                .withNewTargetPort(9090)\n                .endPort()\n                .endSpec()\n                .build();\n\n        Service service2 = new ServiceBuilder()\n                .withNewMetadata().withName(\"service2\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withProtocol(\"TCP\")\n                .withPort(80)\n                .withNewTargetPort(8080)\n                .endPort()\n                .endSpec()\n                .build();\n\n        Service service3 = new ServiceBuilder()\n                .withNewMetadata().withName(\"service3\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withProtocol(\"TCP\")\n                .withPort(443)\n                .withNewTargetPort(443)\n                .endPort()\n                .withPortalIP(\"172.30.17.2\")\n                .endSpec()\n                .build();\n\n        mock.services().inNamespace(\"default\").withName(\"service1\").get().andReturn(service1).anyTimes();\n        mock.services().inNamespace(\"default\").withName(\"service2\").get().andReturn(service2).anyTimes();\n        mock.services().inNamespace(\"default\").withName(\"service3\").get().andReturn(service3).anyTimes();\n\n        mock.services().list().andReturn(new ServiceListBuilder().addToItems(service3, service1, service2).build()).anyTimes();\n\n        mock.endpoints().inNamespace(\"default\").list().andReturn(new EndpointsListBuilder().build()).anyTimes();\n        mock.adapt(OpenShiftClient.class).andReturn(getOpenshiftClient()).anyTimes();\n        return mock.replay();\n    }","id":81352,"modified_method":"@Bean\n    public KubernetesClient getKubernetesClient(OpenShiftClient openShiftClient) throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n\n        mock.getMasterUrl().andReturn(new URL(\"https://kubernetes.default.svc\")).anyTimes();\n        mock.rootPaths().andReturn(new RootPathsBuilder()\n                .addToPaths(\"/api\",\n                        \"/api/v1beta3\",\n                        \"/api/v1\",\n                        \"/controllers\",\n                        \"/healthz\",\n                        \"/healthz/ping\",\n                        \"/logs/\",\n                        \"/metrics\",\n                        \"/ready\",\n                        \"/osapi\",\n                        \"/osapi/v1beta3\",\n                        \"/oapi\",\n                        \"/oapi/v1\",\n                        \"/swaggerapi/\")\n                .build()).anyTimes();\n\n        Service service1 = new ServiceBuilder()\n                .withNewMetadata().withName(\"service1\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withProtocol(\"TCP\")\n                .withPort(80)\n                .withNewTargetPort(9090)\n                .endPort()\n                .endSpec()\n                .build();\n\n        Service service2 = new ServiceBuilder()\n                .withNewMetadata().withName(\"service2\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withProtocol(\"TCP\")\n                .withPort(80)\n                .withNewTargetPort(8080)\n                .endPort()\n                .endSpec()\n                .build();\n\n        Service service3 = new ServiceBuilder()\n                .withNewMetadata().withName(\"service3\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withProtocol(\"TCP\")\n                .withPort(443)\n                .withNewTargetPort(443)\n                .endPort()\n                .withPortalIP(\"172.30.17.2\")\n                .endSpec()\n                .build();\n\n\n        Service multiport = new ServiceBuilder()\n                .withNewMetadata().withName(\"multiport\").endMetadata()\n                .withNewSpec()\n                .addNewPort()\n                .withName(\"port1\")\n                .withProtocol(\"TCP\")\n                .withPort(8081)\n                .withNewTargetPort(8081)\n                .endPort()\n                .addNewPort()\n                .withName(\"port2\")\n                .withProtocol(\"TCP\")\n                .withPort(8082)\n                .withNewTargetPort(8082)\n                .endPort()\n                .addNewPort()\n                .withName(\"port3\")\n                .withProtocol(\"TCP\")\n                .withPort(8083)\n                .withNewTargetPort(8083)\n                .endPort()\n                .withPortalIP(\"172.30.17.2\")\n                .endSpec()\n                .build();\n\n        mock.services().withName(\"service1\").get().andReturn(service1).anyTimes();\n        mock.services().withName(\"service2\").get().andReturn(service2).anyTimes();\n        mock.services().withName(\"service3\").get().andReturn(service3).anyTimes();\n        mock.services().withName(\"multiport\").get().andReturn(multiport).anyTimes();\n\n        mock.services().list().andReturn(new ServiceListBuilder().addToItems(service1, service2, service3, multiport).build()).anyTimes();\n\n        mock.endpoints().list().andReturn(new EndpointsListBuilder().build()).anyTimes();\n        mock.adapt(OpenShiftClient.class).andReturn(getOpenshiftClient()).anyTimes();\n        return mock.replay();\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Bean\n    public OpenShiftClient getOpenshiftClient() {\n        OpenshiftMockClient mock = new OpenshiftMockClient();\n        mock.routes().inNamespace(\"default\").list().andReturn(new RouteListBuilder().build()).anyTimes();\n        return mock.replay();\n    }","id":81353,"modified_method":"@Bean\n    public OpenShiftClient getOpenshiftClient() {\n        OpenshiftMockClient mock = new OpenshiftMockClient();\n        mock.routes().list().andReturn(new RouteListBuilder().build()).anyTimes();\n        mock.routes().inNamespace(\"default\").list().andReturn(new RouteListBuilder().build()).anyTimes();\n        return mock.replay();\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Service getService(String name) {\n        String serviceNamespace = KubernetesHelper.defaultNamespace();\n        if (kubernetesClient == null) {\n            kubernetesClient = beanFactory.getBean(KubernetesClient.class);\n        }\n        return kubernetesClient.services().inNamespace(serviceNamespace).withName(name).get();\n    }","id":81354,"modified_method":"@Override\n    public Service getService(String serviceName) {\n        if (kubernetesClient == null) {\n            kubernetesClient = beanFactory.getBean(KubernetesClient.class);\n        }\n        return kubernetesClient.services().withName(serviceName).get();\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Service getService(String name) {\n        String prefix = name.toUpperCase();\n        Map<String, String> env = System.getenv();\n        String serviceHost = env.get(prefix + HOST_SUFFIX);\n        String port = env.get(prefix + PORT_SUFFIX);\n        String protocol = env.get(prefix + PORT_SUFFIX + \"_\" + port + PROTO_SUFFIX);\n\n        return new ServiceBuilder()\n                .withNewMetadata()\n                .withName(name)\n                .endMetadata()\n                .withNewSpec()\n                .withClusterIP(serviceHost)\n                .addNewPort()\n                .withPort(Integer.parseInt(port))\n                .withProtocol(protocol)\n                .endPort()\n                .endSpec()\n                .build();\n    }","id":81355,"modified_method":"@Override\n    public Service getService(String serviceName) {\n        Map<String, String> env = System.getenv();\n        String prefix = serviceName.toUpperCase();\n        String serviceHost = env.get(prefix + HOST_SUFFIX);\n\n        String defaultPortName = prefix + SERVICE_PORT;\n        String namedPortPrefix = defaultPortName + \"_\";\n\n        List<ServicePort> servicePorts = new ArrayList<>();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            String key = entry.getKey();\n            if (key.startsWith(namedPortPrefix)) {\n                String name = key.substring(namedPortPrefix.length());\n                String portValue = entry.getValue();\n                String protocolValue = env.get(key + \"_\" + PROTO_SUFFIX);\n                servicePorts.add(new ServicePortBuilder()\n                        .withName(name.toLowerCase())\n                        .withPort(Integer.parseInt(portValue))\n                        .withProtocol(protocolValue != null ? protocolValue : \"TCP\")\n                        .build());\n            }\n        }\n\n        //Check if we need to fallback to single port.\n        if (servicePorts.isEmpty()) {\n            String portValue = env.get(defaultPortName);\n            String protocolValue = env.get(defaultPortName + PROTO_SUFFIX);\n\n            servicePorts.add(new ServicePortBuilder()\n                    .withPort(Integer.parseInt(portValue))\n                    .withProtocol(protocolValue != null ? protocolValue : \"TCP\")\n                    .build());\n        }\n\n        return new ServiceBuilder()\n                .withNewMetadata()\n                    .withName(serviceName)\n                .endMetadata()\n                .withNewSpec()\n                .withPortalIP(serviceHost)\n                .withPorts(servicePorts)\n                .endSpec()\n                .build();\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object convert(Object o, TypeDescriptor sourceType, TypeDescriptor targetType) {\n        Service source = (Service) o;\n        String serviceName = KubernetesHelper.getName(source);\n        String serviceNamespace = KubernetesHelper.getNamespace(source);\n        String serviceProtocol = getProtocolOfService(source);\n        Boolean serviceExternal = isServiceExternal(source);\n        serviceNamespace = serviceNamespace != null ? serviceNamespace : KubernetesHelper.defaultNamespace();\n        String str = KubernetesHelper.getServiceURL(kubernetesClient, serviceName, serviceNamespace, serviceProtocol, serviceExternal);\n        try {\n            if (String.class.equals(targetType.getObjectType())) {\n                return str;\n            } else if (URL.class.equals(targetType.getObjectType())) {\n                return new URL(str);\n            }\n        } catch (Throwable t) {\n            throw new RuntimeException(\"Failed to convert from: \" + sourceType.getObjectType() + \" to: \" + targetType.getObjectType());\n        }\n        throw new IllegalStateException(\"Invalid target type: \" + targetType.getObjectType());\n    }","id":81356,"modified_method":"@Override\n    public Object convert(Object o, TypeDescriptor sourceType, TypeDescriptor targetType) {\n        Service source = (Service) o;\n        String serviceProtocol = getProtocolOfService(source);\n        String servicePort = getPortOfService(source);\n\n        String str = getServiceURL(kubernetesClient, source, serviceProtocol, servicePort);\n        try {\n            if (String.class.equals(targetType.getObjectType())) {\n                return str;\n            } else if (URL.class.equals(targetType.getObjectType())) {\n                return new URL(str);\n            }\n        } catch (Throwable t) {\n            throw new RuntimeException(\"Failed to convert from: \" + sourceType.getObjectType() + \" to: \" + targetType.getObjectType());\n        }\n        throw new IllegalStateException(\"Invalid target type: \" + targetType.getObjectType());\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Factory\n    @ServiceName\n    public URLConnection toUrlConnection(@ServiceName Service srv) throws IOException {\n        URL url = new URL( \"http://\" + srv.getSpec().getClusterIP() + \":\" + srv.getSpec().getPorts().iterator().next().getPort());\n        return url.openConnection();\n    }","id":81357,"modified_method":"@Factory\n    @ServiceName\n    public URLConnection toUrlConnection(@ServiceName Service srv) throws IOException {\n        URL url = new URL( \"http://\" + srv.getSpec().getPortalIP() + \":\" + srv.getSpec().getPorts().iterator().next().getPort());\n        return url.openConnection();\n    }","commit_id":"18fb212e2fb1e739a968fb291ce834dfc2aa248b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected String getDefaultViewName(ServerWebExchange exchange, HandlerResult result) {\n\t\treturn null;\n\t}","id":81358,"modified_method":"protected String getDefaultViewName(ServerWebExchange exchange, HandlerResult result) {\n\t\tString path = this.pathHelper.getLookupPathForRequest(exchange);\n\t\tif (path.startsWith(\"/\")) {\n\t\t\tpath = path.substring(1);\n\t\t}\n\t\tif (path.endsWith(\"/\")) {\n\t\t\tpath = path.substring(0, path.length() - 1);\n\t\t}\n\t\treturn StringUtils.stripFilenameExtension(path);\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewNameWithNoMatch() throws Exception {\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\tTestSubscriber<Void> subscriber = handle(handler, \"account\", ResolvableType.forClass(String.class));\n\n\t\tsubscriber.assertNoValues();\n\t}","id":81359,"modified_method":"@Test\n\tpublic void viewNameWithNoMatch() throws Exception {\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\tTestSubscriber<Void> subscriber = handle(this.exchange, handler, \"account\", ResolvableType.forClass(String.class));\n\n\t\tsubscriber.assertNoValues();\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private TestSubscriber<Void> handle(HandlerResultHandler handler, Object value, ResolvableType type) {\n\t\tHandlerResult result = new HandlerResult(new Object(), value, type, this.model);\n\t\tMono<Void> mono = handler.handleResult(this.exchange, result);\n\t\tTestSubscriber<Void> subscriber = new TestSubscriber<>();\n\t\treturn subscriber.bindTo(mono).await(Duration.ofSeconds(1));\n\t}","id":81360,"modified_method":"private TestSubscriber<Void> handle(ServerWebExchange exchange, HandlerResultHandler handler,\n\t\t\tObject value, ResolvableType type) {\n\n\t\tHandlerResult result = new HandlerResult(new Object(), value, type, this.model);\n\t\tMono<Void> mono = handler.handleResult(exchange, result);\n\t\tTestSubscriber<Void> subscriber = new TestSubscriber<>();\n\t\treturn subscriber.bindTo(mono).await(Duration.ofSeconds(1));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewNameMono() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(handler, Mono.just(\"account\"), methodReturnType(\"handleMonoString\"));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","id":81361,"modified_method":"@Test\n\tpublic void viewNameMono() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(this.exchange, handler, Mono.just(\"account\"), methodReturnType(\"handleMonoString\"));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewNameWithMultipleResolvers() throws Exception {\n\t\tTestView view1 = new TestView(\"account\");\n\t\tTestView view2 = new TestView(\"profile\");\n\t\tTestViewResolver resolver1 = new TestViewResolver().addView(view1);\n\t\tTestViewResolver resolver2 = new TestViewResolver().addView(view2);\n\t\tList<ViewResolver> resolvers = Arrays.asList(resolver1, resolver2);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(handler, \"profile\", ResolvableType.forClass(String.class));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"profile: {id=123}\", asString(buf)));\n\t}","id":81362,"modified_method":"@Test\n\tpublic void viewNameWithMultipleResolvers() throws Exception {\n\t\tTestView view1 = new TestView(\"account\");\n\t\tTestView view2 = new TestView(\"profile\");\n\t\tTestViewResolver resolver1 = new TestViewResolver().addView(view1);\n\t\tTestViewResolver resolver2 = new TestViewResolver().addView(view2);\n\t\tList<ViewResolver> resolvers = Arrays.asList(resolver1, resolver2);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(this.exchange, handler, \"profile\", ResolvableType.forClass(String.class));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"profile: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewReference() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(handler, view, ResolvableType.forClass(View.class));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","id":81363,"modified_method":"@Test\n\tpublic void viewReference() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(this.exchange, handler, view, ResolvableType.forClass(View.class));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewNameNotSpecified() throws Exception {\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\tTestSubscriber<Void> subscriber = handle(handler, null, ResolvableType.forClass(String.class));\n\n\t\tsubscriber.assertErrorWith(ex ->\n\t\t\t\tassertThat(ex.getMessage(), endsWith(\"neither returned a view name nor a View object\")));\n\t}","id":81364,"modified_method":"@Test\n\tpublic void viewNameNotSpecified() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\n\t\tServerWebExchange exchange = createExchange(\"/account\");\n\t\thandle(exchange, handler, null, ResolvableType.forClass(String.class));\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\n\t\texchange = createExchange(\"/account/\");\n\t\thandle(exchange, handler, null, ResolvableType.forClass(String.class));\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\n\t\texchange = createExchange(\"/account.123\");\n\t\thandle(exchange, handler, null, ResolvableType.forClass(String.class));\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tServerHttpRequest request = new MockServerHttpRequest(HttpMethod.GET, new URI(\"/path\"));\n\t\tthis.response = new MockServerHttpResponse();\n\t\tWebSessionManager sessionManager = new DefaultWebSessionManager();\n\t\tthis.exchange = new DefaultServerWebExchange(request, this.response, sessionManager);\n\t\tthis.model = new ExtendedModelMap().addAttribute(\"id\", \"123\");\n\t\tthis.conversionService = new DefaultConversionService();\n\t\tthis.conversionService.addConverter(new ReactiveStreamsToRxJava1Converter());\n\t}","id":81365,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.exchange = createExchange(\"/path\");\n\t\tthis.model = new ExtendedModelMap().addAttribute(\"id\", \"123\");\n\t\tthis.conversionService = new DefaultConversionService();\n\t\tthis.conversionService.addConverter(new ReactiveStreamsToRxJava1Converter());\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewNameMonoEmpty() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tHandlerResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService) {\n\t\t\t@Override\n\t\t\tprotected String getDefaultViewName(ServerWebExchange exchange, HandlerResult result) {\n\t\t\t\treturn \"account\";\n\t\t\t}\n\t\t};\n\t\thandle(handler, Mono.empty(), methodReturnType(\"handleMonoString\"));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","id":81366,"modified_method":"@Test\n\tpublic void viewNameMonoEmpty() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tHandlerResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\tServerWebExchange exchange = createExchange(\"/account\");\n\t\thandle(exchange, handler, Mono.empty(), methodReturnType(\"handleMonoString\"));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewName() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(handler, \"account\", ResolvableType.forClass(String.class));\n\n\t\tTestSubscriber<DataBuffer> subscriber = new TestSubscriber<>();\n\t\tsubscriber.bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","id":81367,"modified_method":"@Test\n\tpublic void viewName() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tTestViewResolver resolver = new TestViewResolver().addView(view);\n\t\tList<ViewResolver> resolvers = Collections.singletonList(resolver);\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(this.exchange, handler, \"account\", ResolvableType.forClass(String.class));\n\n\t\tTestSubscriber<DataBuffer> subscriber = new TestSubscriber<>();\n\t\tsubscriber.bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void viewReferenceMono() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(handler, Mono.just(view), methodReturnType(\"handleMonoView\"));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","id":81368,"modified_method":"@Test\n\tpublic void viewReferenceMono() throws Exception {\n\t\tTestView view = new TestView(\"account\");\n\t\tList<ViewResolver> resolvers = Collections.singletonList(mock(ViewResolver.class));\n\t\tViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, this.conversionService);\n\t\thandle(this.exchange, handler, Mono.just(view), methodReturnType(\"handleMonoView\"));\n\n\t\tnew TestSubscriber<DataBuffer>().bindTo(this.response.getBody())\n\t\t\t\t.assertValuesWith(buf -> assertEquals(\"account: {id=123}\", asString(buf)));\n\t}","commit_id":"f0c8c4e7a44f75cfed97a22fdec95df590204026","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tAsyncContext context = request.startAsync();\n\t\tfinal AsyncContextSynchronizer contextSynchronizer =\n\t\t\t\tnew AsyncContextSynchronizer(context);\n\n\t\tRequestBodyPublisher requestPublisher = new RequestBodyPublisher(contextSynchronizer, BUFFER_SIZE);\n\t\trequest.getInputStream().setReadListener(requestPublisher);\n\n\t\tResponseBodySubscriber responseSubscriber = new ResponseBodySubscriber(contextSynchronizer);\n\t\tresponse.getOutputStream().setWriteListener(responseSubscriber);\n\n\t\tPublisher<byte[]> responsePublisher = this.handler.handle(requestPublisher);\n\n\t\tresponsePublisher.subscribe(responseSubscriber);\n\t}","id":81369,"modified_method":"@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tAsyncContext context = request.startAsync();\n\t\tAsyncContextSynchronizer contextSynchronizer = new AsyncContextSynchronizer(context);\n\n\t\tRequestBodyPublisher requestPublisher = new RequestBodyPublisher(contextSynchronizer, BUFFER_SIZE);\n\t\trequest.getInputStream().setReadListener(requestPublisher);\n\t\tServletServerHttpRequest httpRequest = new ServletServerHttpRequest(request, requestPublisher);\n\n\t\tResponseBodySubscriber responseSubscriber = new ResponseBodySubscriber(contextSynchronizer);\n\t\tresponse.getOutputStream().setWriteListener(responseSubscriber);\n\t\tServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response, responseSubscriber);\n\n\t\tHandlerResultSubscriber resultSubscriber = new HandlerResultSubscriber(contextSynchronizer);\n\t\tthis.handler.handle(httpRequest, httpResponse).subscribe(resultSubscriber);\n\t}","commit_id":"2cb32a0fd69c528d55d3d53ae98bf886dcb4a5f9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\r\n    public void doScope(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException\r\n    {\r\n        if (!target.startsWith(getContextPath())) return;\r\n\r\n        JettyHttpExchange jettyHttpExchange = new JettyHttpExchange(_httpContext, req, resp);\r\n\r\n        // TODO: add filters processing\r\n\r\n        try\r\n        {\r\n            Authenticator auth = _httpContext.getAuthenticator();\r\n            if (auth != null)\r\n                handleAuthentication(resp, jettyHttpExchange, auth);\r\n            else\r\n                _httpHandler.handle(jettyHttpExchange);\r\n        }\r\n        catch(Exception ex)\r\n        {\r\n            PrintWriter writer = new PrintWriter(jettyHttpExchange.getResponseBody());\r\n            \r\n            resp.setStatus(500);\r\n            writer.println(\"<h2>HTTP ERROR: 500<\/h2>\");\r\n            writer.println(\"<pre>INTERNAL_SERVER_ERROR<\/pre>\");\r\n            writer.println(\"<p>RequestURI=\" + req.getRequestURI() + \"<\/p>\");\r\n            \r\n            writer.println(\"<pre>\");\r\n            ex.printStackTrace(writer);\r\n            writer.println(\"<\/pre>\");\r\n            \r\n            writer.println(\"<p><i><small><a href=\\\"http://jetty.mortbay.org\\\">Powered by jetty://<\/a><\/small><\/i><\/p>\");\r\n            \r\n            writer.close();\r\n        }\r\n        finally\r\n        {\r\n            baseRequest.setHandled(true);\r\n        }\r\n        \r\n    }","id":81370,"modified_method":"@Override\r\n    public void doScope(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException\r\n    {\r\n        if (!target.startsWith(getContextPath()))\r\n        {\r\n            return;\r\n        }\r\n\r\n        HttpExchange jettyHttpExchange;\r\n        if (baseRequest.isSecure())\r\n        {\r\n            jettyHttpExchange = new JettyHttpsExchange(_httpContext,req,resp);\r\n        }\r\n        else\r\n        {\r\n            jettyHttpExchange = new JettyHttpExchange(_httpContext,req,resp);\r\n        }\r\n\r\n        // TODO: add filters processing\r\n\r\n        try\r\n        {\r\n            Authenticator auth = _httpContext.getAuthenticator();\r\n            if (auth != null)\r\n            {\r\n                handleAuthentication(resp,jettyHttpExchange,auth);\r\n            }\r\n            else\r\n            {\r\n                _httpHandler.handle(jettyHttpExchange);\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            PrintWriter writer = new PrintWriter(jettyHttpExchange.getResponseBody());\r\n\r\n            resp.setStatus(500);\r\n            writer.println(\"<h2>HTTP ERROR: 500<\/h2>\");\r\n            writer.println(\"<pre>INTERNAL_SERVER_ERROR<\/pre>\");\r\n            writer.println(\"<p>RequestURI=\" + req.getRequestURI() + \"<\/p>\");\r\n\r\n            writer.println(\"<pre>\");\r\n            ex.printStackTrace(writer);\r\n            writer.println(\"<\/pre>\");\r\n\r\n            writer.println(\"<p><i><small><a href=\\\"http://jetty.mortbay.org\\\">Powered by jetty://<\/a><\/small><\/i><\/p>\");\r\n\r\n            writer.close();\r\n        }\r\n        finally\r\n        {\r\n            baseRequest.setHandled(true);\r\n        }\r\n\r\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void handleAuthentication(HttpServletResponse resp, JettyHttpExchange jettyHttpExchange, Authenticator auth) throws IOException\r\n    {\r\n        Result result = auth.authenticate(jettyHttpExchange);\r\n        if (result instanceof Authenticator.Failure)\r\n        {\r\n            int rc = ((Authenticator.Failure)result).getResponseCode();\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Retry)\r\n        {\r\n            int rc = ((Authenticator.Retry)result).getResponseCode();\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Success)\r\n        {\r\n            HttpPrincipal principal = ((Authenticator.Success)result).getPrincipal();\r\n            jettyHttpExchange.setPrincipal(principal);\r\n            _httpHandler.handle(jettyHttpExchange);\r\n        }\r\n    }","id":81371,"modified_method":"private void handleAuthentication(HttpServletResponse resp, HttpExchange httpExchange, Authenticator auth) throws IOException\r\n    {\r\n        Result result = auth.authenticate(httpExchange);\r\n        if (result instanceof Authenticator.Failure)\r\n        {\r\n            int rc = ((Authenticator.Failure)result).getResponseCode();\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Retry)\r\n        {\r\n            int rc = ((Authenticator.Retry)result).getResponseCode();\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Success)\r\n        {\r\n            HttpPrincipal principal = ((Authenticator.Success)result).getPrincipal();\r\n            ((JettyExchange)httpExchange).setPrincipal(principal);\r\n            _httpHandler.handle(httpExchange);\r\n        }\r\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public void sendResponseHeaders(int rCode, long responseLength)\r\n            throws IOException\r\n    {\r\n        this._responseCode = rCode;\r\n\r\n        for (Map.Entry<String, List<String>> stringListEntry : _responseHeaders.entrySet())\r\n        {\r\n            String name = stringListEntry.getKey();\r\n            List<String> values = stringListEntry.getValue();\r\n\r\n            for (String value : values)\r\n            {\r\n                _resp.setHeader(name, value);\r\n            }\r\n        }\r\n        if (responseLength > 0)\r\n            _resp.setHeader(\"content-length\", \"\" + responseLength);\r\n        _resp.setStatus(rCode);\r\n    }","id":81372,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#sendResponseHeaders(int, long)\n     */\n    @Override\n    public void sendResponseHeaders(int rCode, long responseLength) throws IOException\n    {\n        _delegate.sendResponseHeaders(rCode,responseLength);\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public void close()\r\n    {\r\n        try\r\n        {\r\n            _resp.getOutputStream().close();\r\n        }\r\n        catch (IOException ex)\r\n        {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }","id":81373,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#close()\n     */\n    @Override\n    public void close()\n    {\n        _delegate.close();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public InputStream getRequestBody()\r\n    {\r\n        return _is;\r\n    }","id":81374,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getRequestBody()\n     */\n    @Override\n    public InputStream getRequestBody()\n    {\n        return _delegate.getRequestBody();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public InetSocketAddress getRemoteAddress()\r\n    {\r\n        return new InetSocketAddress(_req.getRemoteAddr(), _req.getRemotePort());\r\n    }","id":81375,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getRemoteAddress()\n     */\n    @Override\n    public InetSocketAddress getRemoteAddress()\n    {\n        return _delegate.getRemoteAddress();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public String getRequestMethod()\r\n    {\r\n        return _req.getMethod();\r\n    }","id":81376,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getRequestMethod()\n     */\n    @Override\n    public String getRequestMethod()\n    {\n        return _delegate.getRequestMethod();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public InetSocketAddress getLocalAddress()\r\n    {\r\n        return new InetSocketAddress(_req.getLocalAddr(), _req.getLocalPort());\r\n    }","id":81377,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getLocalAddress()\n     */\n    @Override\n    public InetSocketAddress getLocalAddress()\n    {\n        return _delegate.getLocalAddress();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public URI getRequestURI()\r\n    {\r\n        try\r\n        {\r\n        \tString uriAsString = _req.getRequestURI();\r\n        \tif (_req.getQueryString() != null)\r\n        \t\turiAsString += \"?\" + _req.getQueryString();\r\n        \t\r\n            return new URI(uriAsString);\r\n        }\r\n        catch (URISyntaxException ex)\r\n        {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }","id":81378,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getRequestURI()\n     */\n    @Override\n    public URI getRequestURI()\n    {\n        return _delegate.getRequestURI();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public int getResponseCode()\r\n    {\r\n        return _responseCode;\r\n    }","id":81379,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getResponseCode()\n     */\n    @Override\n    public int getResponseCode()\n    {\n        return _delegate.getResponseCode();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public Headers getResponseHeaders()\r\n    {\r\n        return _responseHeaders;\r\n    }","id":81380,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getResponseHeaders()\n     */\n    @Override\n    public Headers getResponseHeaders()\n    {\n        return _delegate.getResponseHeaders();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public String getProtocol()\r\n    {\r\n        return _req.getProtocol();\r\n    }","id":81381,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getProtocol()\n     */\n    @Override\n    public String getProtocol()\n    {\n        return _delegate.getProtocol();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public void setStreams(InputStream i, OutputStream o)\r\n    {\r\n        _is = i;\r\n        _os = o;\r\n    }","id":81382,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#setStreams(java.io.InputStream, java.io.OutputStream)\n     */\n    @Override\n    public void setStreams(InputStream i, OutputStream o)\n    {\n        _delegate.setStreams(i,o);\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public Object getAttribute(String name)\r\n    {\r\n        return _req.getAttribute(name);\r\n    }","id":81383,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getAttribute(java.lang.String)\n     */\n    @Override\n    public Object getAttribute(String name)\n    {\n        return _delegate.getAttribute(name);\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public HttpPrincipal getPrincipal()\r\n    {\r\n    \treturn _httpPrincipal;\r\n    }","id":81384,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getPrincipal()\n     */\n    @Override\n    public HttpPrincipal getPrincipal()\n    {\n        return _delegate.getPrincipal();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public HttpContext getHttpContext()\r\n    {\r\n        return _httpContext;\r\n    }","id":81385,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getHttpContext()\n     */\n    @Override\n    public HttpContext getHttpContext()\n    {\n        return _delegate.getHttpContext();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public Headers getRequestHeaders()\r\n    {\r\n        Headers headers = new Headers();\r\n        Enumeration<?> en = _req.getHeaderNames();\r\n        while (en.hasMoreElements())\r\n        {\r\n            String name = (String) en.nextElement();\r\n            Enumeration<?> en2 = _req.getHeaders(name);\r\n            while (en2.hasMoreElements())\r\n            {\r\n                String value = (String) en2.nextElement();\r\n                headers.add(name, value);\r\n            }\r\n        }\r\n        return headers;\r\n    }","id":81386,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getRequestHeaders()\n     */\n    @Override\n    public Headers getRequestHeaders()\n    {\n        return _delegate.getRequestHeaders();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void setPrincipal(HttpPrincipal principal)\r\n    {\r\n    \tthis._httpPrincipal = principal;\r\n    }","id":81387,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#setPrincipal(com.sun.net.httpserver.HttpPrincipal)\n     */\n    public void setPrincipal(HttpPrincipal principal)\n    {\n        _delegate.setPrincipal(principal);\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public void setAttribute(String name, Object value)\r\n    {\r\n        _req.setAttribute(name, value);\r\n    }","id":81388,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#setAttribute(java.lang.String, java.lang.Object)\n     */\n    @Override\n    public void setAttribute(String name, Object value)\n    {\n        _delegate.setAttribute(name,value);\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    public OutputStream getResponseBody()\r\n    {\r\n        return _os;\r\n    }","id":81389,"modified_method":"/**\n     * @see org.eclipse.jetty.http.spi.JettyExchange#getResponseBody()\n     */\n    @Override\n    public OutputStream getResponseBody()\n    {\n        return _delegate.getResponseBody();\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public JettyHttpExchange(HttpContext jaxWsContext , HttpServletRequest req,\r\n            HttpServletResponse resp)\r\n    {\r\n        this._httpContext = jaxWsContext;\r\n        this._req = req;\r\n        this._resp = resp;\r\n        try\r\n        {\r\n            this._is = req.getInputStream();\r\n            this._os = resp.getOutputStream();\r\n        }\r\n        catch (IOException ex)\r\n        {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }","id":81390,"modified_method":"public JettyHttpExchange(HttpContext jaxWsContext, HttpServletRequest req, HttpServletResponse resp)\n    {\n        super();\n        _delegate = new JettyHttpExchangeDelegate(jaxWsContext,req,resp);\n    }","commit_id":"c1dac27886c606110856bdf9f685c8f7dd6b6724","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void flush() throws IOException {\n        synchronized (persistedHead) {\n            RecordId before = persistedHead.get();\n            RecordId after = head.get();\n            if (!after.equals(before)) {\n                // needs to happen outside the synchronization block below to\n                // avoid a deadlock with another thread flushing the writer\n                tracker.getWriter().flush();\n\n                // needs to happen outside the synchronization block below to\n                // prevent the flush from stopping concurrent reads and writes\n                writer.flush();\n\n                synchronized (this) {\n                    journalFile.writeBytes(after + \" root\\n\");\n                    journalFile.getChannel().force(false);\n                    persistedHead.set(after);\n                }\n            }\n        }\n    }","id":81391,"modified_method":"public void flush() throws IOException {\n        synchronized (persistedHead) {\n            RecordId before = persistedHead.get();\n            RecordId after = head.get();\n            if (!after.equals(before)) {\n                // needs to happen outside the synchronization block below to\n                // avoid a deadlock with another thread flushing the writer\n                tracker.getWriter().flush();\n\n                // needs to happen outside the synchronization block below to\n                // prevent the flush from stopping concurrent reads and writes\n                writer.flush();\n\n                synchronized (this) {\n                    journalFile.writeBytes(after + \" root\\n\");\n                    journalFile.getChannel().force(false);\n                    persistedHead.set(after);\n\n                    if (cleanupNeeded.getAndSet(false)) {\n                        Set<UUID> ids = newHashSet();\n                        for (SegmentId id : tracker.getReferencedSegmentIds()) {\n                            ids.add(new UUID(\n                                    id.getMostSignificantBits(),\n                                    id.getLeastSignificantBits()));\n                        }\n\n                        List<TarReader> list =\n                                newArrayListWithCapacity(readers.size());\n                        for (TarReader reader : readers) {\n                            TarReader cleaned = reader.cleanup(ids);\n                            if (cleaned == reader) {\n                                list.add(reader);\n                            } else {\n                                if (cleaned != null) {\n                                    list.add(cleaned);\n                                }\n                                toBeRemoved.addLast(reader.close());\n                            }\n                        }\n                        readers = list;\n                    }\n                }\n\n                // remove all obsolete tar generations\n                Iterator<File> iterator = toBeRemoved.iterator();\n                while (iterator.hasNext()) {\n                    File file = iterator.next();\n                    if (!file.exists() || file.delete()) {\n                        iterator.remove();\n                    }\n                }\n            }\n        }\n    }","commit_id":"f2aa3052c98dc566d614025317a9d4dfe27621f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public synchronized void writeSegment(\n            SegmentId id, byte[] data, int offset, int length) {\n        try {\n            long size = writer.writeEntry(\n                    id.getMostSignificantBits(),\n                    id.getLeastSignificantBits(),\n                    data, offset, length);\n            if (size >= maxFileSize) {\n                writer.close();\n\n                List<TarReader> list =\n                        newArrayListWithCapacity(1 + readers.size());\n                list.add(new TarReader(writeFile, memoryMapping));\n                list.addAll(readers);\n                readers = list;\n\n                writeNumber++;\n                writeFile = new File(\n                        directory,\n                        String.format(FILE_NAME_FORMAT, writeNumber, \"a\"));\n                writer = new TarWriter(writeFile);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":81392,"modified_method":"@Override\n    public synchronized void writeSegment(\n            SegmentId id, byte[] data, int offset, int length) {\n        try {\n            long size = writer.writeEntry(\n                    id.getMostSignificantBits(),\n                    id.getLeastSignificantBits(),\n                    data, offset, length);\n            if (size >= maxFileSize) {\n                writer.close();\n\n                List<TarReader> list =\n                        newArrayListWithCapacity(1 + readers.size());\n                list.add(new TarReader(writeFile, memoryMapping));\n                list.addAll(readers);\n                readers = list;\n\n                // trigger revision cleanup after next flush\n                cleanupNeeded.set(true);\n\n                writeNumber++;\n                writeFile = new File(\n                        directory,\n                        String.format(FILE_NAME_FORMAT, writeNumber, \"a\"));\n                writer = new TarWriter(writeFile);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"f2aa3052c98dc566d614025317a9d4dfe27621f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void gc() {\n        System.gc();\n        Set<SegmentId> ids = tracker.getReferencedSegmentIds();\n        // TODO reclaim unreferenced segments\n    }","id":81393,"modified_method":"@Override\n    public void gc() {\n        System.gc();\n        cleanupNeeded.set(true);\n    }","commit_id":"f2aa3052c98dc566d614025317a9d4dfe27621f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"synchronized TarReader cleanup(Set<UUID> referencedIds) throws IOException {\n        TarEntry[] sorted = new TarEntry[index.remaining() / 24];\n        int position = index.position();\n        for (int i = 0; position < index.limit(); i++) {\n            sorted[i]  = new TarEntry(\n                    index.getLong(position),\n                    index.getLong(position + 8),\n                    index.getInt(position + 16),\n                    index.getInt(position + 20));\n            position += 24;\n        }\n        Arrays.sort(sorted, TarEntry.OFFSET_ORDER);\n\n        int size = 0;\n        int count = 0;\n        for (int i = sorted.length - 1; i >= 0; i--) {\n            TarEntry entry = sorted[i];\n            UUID id = new UUID(entry.msb(), entry.lsb());\n            if (!referencedIds.remove(id)) {\n                // this segment is not referenced anywhere\n                sorted[i] = null;\n            } else {\n                size += getEntrySize(entry.size());\n                count += 1;\n\n                if (isDataSegmentId(entry.lsb())) {\n                    // this is a referenced data segment, so follow the graph\n                    ByteBuffer segment = access.read(\n                            entry.offset(),\n                            Math.min(entry.size(), 16 * 256));\n                    int pos = segment.position();\n                    int refcount = segment.get(pos + REF_COUNT_OFFSET) & 0xff;\n                    int refend = pos + 16 * (refcount + 1);\n                    for (int refpos = pos + 16; refpos < refend; refpos += 16) {\n                        referencedIds.add(new UUID(\n                                segment.getLong(refpos),\n                                segment.getLong(refpos + 8)));\n                    }\n                }\n            }\n        }\n        size += getEntrySize(24 * count + 16);\n        size += 2 * BLOCK_SIZE;\n\n        if (size >= access.length() * 3 / 4) {\n            // the space savings are not worth it at less than 25%\n            return this;\n        }\n\n        String name = file.getName();\n        int pos = name.length() - \"a.tar\".length();\n        char generation = name.charAt(pos);\n        if (generation == 'z') {\n            // no garbage collection after reaching generation z\n            return this;\n        }\n\n        File newFile = new File(\n                file.getParentFile(),\n                name.substring(0, pos) + (char) (generation + 1) + \".tar\");\n        TarWriter writer = new TarWriter(newFile);\n        for (int i = 0; i < sorted.length; i++) {\n            TarEntry entry = sorted[i];\n            if (entry != null) {\n                byte[] data = new byte[entry.size()];\n                access.read(entry.offset(), entry.size()).get(data);\n                writer.writeEntry(\n                        entry.msb(), entry.lsb(), data, 0, entry.size());\n            }\n        }\n        writer.close();\n\n        return new TarReader(newFile, access.isMemoryMapped());\n    }","id":81394,"modified_method":"synchronized TarReader cleanup(Set<UUID> referencedIds) throws IOException {\n        TarEntry[] sorted = new TarEntry[index.remaining() / 24];\n        int position = index.position();\n        for (int i = 0; position < index.limit(); i++) {\n            sorted[i]  = new TarEntry(\n                    index.getLong(position),\n                    index.getLong(position + 8),\n                    index.getInt(position + 16),\n                    index.getInt(position + 20));\n            position += 24;\n        }\n        Arrays.sort(sorted, TarEntry.OFFSET_ORDER);\n\n        int size = 0;\n        int count = 0;\n        for (int i = sorted.length - 1; i >= 0; i--) {\n            TarEntry entry = sorted[i];\n            UUID id = new UUID(entry.msb(), entry.lsb());\n            if (!referencedIds.remove(id)) {\n                // this segment is not referenced anywhere\n                sorted[i] = null;\n            } else {\n                size += getEntrySize(entry.size());\n                count += 1;\n\n                if (isDataSegmentId(entry.lsb())) {\n                    // this is a referenced data segment, so follow the graph\n                    ByteBuffer segment = access.read(\n                            entry.offset(),\n                            Math.min(entry.size(), 16 * 256));\n                    int pos = segment.position();\n                    int refcount = segment.get(pos + REF_COUNT_OFFSET) & 0xff;\n                    int refend = pos + 16 * (refcount + 1);\n                    for (int refpos = pos + 16; refpos < refend; refpos += 16) {\n                        referencedIds.add(new UUID(\n                                segment.getLong(refpos),\n                                segment.getLong(refpos + 8)));\n                    }\n                }\n            }\n        }\n        size += getEntrySize(24 * count + 16);\n        size += 2 * BLOCK_SIZE;\n\n        if (count == 0) {\n            // none of the entries within this tar file are referenceable\n            return null;\n        } else if (size >= access.length() * 3 / 4) {\n            // the space savings are not worth it at less than 25%\n            return this;\n        }\n\n        String name = file.getName();\n        int pos = name.length() - \"a.tar\".length();\n        char generation = name.charAt(pos);\n        if (generation == 'z') {\n            // no garbage collection after reaching generation z\n            return this;\n        }\n\n        File newFile = new File(\n                file.getParentFile(),\n                name.substring(0, pos) + (char) (generation + 1) + \".tar\");\n        TarWriter writer = new TarWriter(newFile);\n        for (int i = 0; i < sorted.length; i++) {\n            TarEntry entry = sorted[i];\n            if (entry != null) {\n                byte[] data = new byte[entry.size()];\n                access.read(entry.offset(), entry.size()).get(data);\n                writer.writeEntry(\n                        entry.msb(), entry.lsb(), data, 0, entry.size());\n            }\n        }\n        writer.close();\n\n        return new TarReader(newFile, access.isMemoryMapped());\n    }","commit_id":"f2aa3052c98dc566d614025317a9d4dfe27621f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"void close() throws IOException {\n        access.close();\n    }","id":81395,"modified_method":"File close() throws IOException {\n        access.close();\n        return file;\n    }","commit_id":"f2aa3052c98dc566d614025317a9d4dfe27621f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"synchronized ByteBuffer readEntry(long msb, long lsb) throws IOException {\n        checkState(!closed);\n        TarEntry entry = index.get(new UUID(msb, lsb));\n        if (entry != null) {\n            if (buffer == null\n                    || buffer.remaining() < entry.offset() + entry.size()) {\n                checkState(access != null); // implied by entry != null\n                buffer = access.getChannel().map(\n                        MapMode.READ_ONLY, 0, access.getFilePointer());\n            }\n            ByteBuffer data = buffer.asReadOnlyBuffer();\n            data.position(entry.offset());\n            data.limit(data.position() + entry.size());\n            return data.slice();\n        } else {\n            return null;\n        }\n    }","id":81396,"modified_method":"synchronized ByteBuffer readEntry(long msb, long lsb) throws IOException {\n        checkState(!closed);\n        TarEntry entry = index.get(new UUID(msb, lsb));\n        if (entry != null) {\n            checkState(access != null); // implied by entry != null\n            ByteBuffer data = ByteBuffer.allocate(entry.size());\n            access.seek(entry.offset());\n            access.readFully(data.array());\n            access.seek(access.length());\n            return data;\n        } else {\n            return null;\n        }\n    }","commit_id":"f2aa3052c98dc566d614025317a9d4dfe27621f9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public ByteBuffer getInputByteBuffer(int streamId, int payloadSize) throws Http2Exception {\n        Stream stream = getStream(streamId, true);\n        if (stream == null) {\n            return null;\n        }\n        stream.checkState(FrameType.DATA);\n        return stream.getInputByteBuffer();\n    }","id":81397,"modified_method":"@Override\n    public ByteBuffer getInputByteBuffer(int streamId, int payloadSize) throws Http2Exception {\n        Stream stream = getStream(streamId, true);\n        stream.checkState(FrameType.DATA);\n        return stream.getInputByteBuffer();\n    }","commit_id":"9d85c135562e08dca2f6f04b5b1f89c4d64f7f47","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void goaway(int lastStreamId, long errorCode, String debugData) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.goaway.debug\", connectionId,\n                    Integer.toString(lastStreamId), Long.toHexString(errorCode), debugData));\n        }\n\n        // TODO: Do more than just record this\n        maxStreamId = lastStreamId;\n    }","id":81398,"modified_method":"@Override\n    public void goaway(int lastStreamId, long errorCode, String debugData) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.goaway.debug\", connectionId,\n                    Integer.toString(lastStreamId), Long.toHexString(errorCode), debugData));\n        }\n    }","commit_id":"9d85c135562e08dca2f6f04b5b1f89c4d64f7f47","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void receiveEndOfStream(int streamId) throws ConnectionException {\n        Stream stream = getStream(streamId, true);\n        if (stream != null) {\n            stream.receivedEndOfStream();\n        }\n    }","id":81399,"modified_method":"@Override\n    public void receiveEndOfStream(int streamId) throws ConnectionException {\n        Stream stream = getStream(streamId, true);\n        if (stream.isActive()) {\n            activeRemoteStreamCount--;\n        }\n        stream.receivedEndOfStream();\n    }","commit_id":"9d85c135562e08dca2f6f04b5b1f89c4d64f7f47","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public HeaderEmitter headersStart(int streamId) throws Http2Exception {\n        Stream stream = getStream(streamId, false);\n        if (stream == null) {\n            stream = createRemoteStream(streamId);\n        }\n        stream.checkState(FrameType.HEADERS);\n        stream.receivedStartOfHeaders();\n        return stream;\n    }","id":81400,"modified_method":"@Override\n    public HeaderEmitter headersStart(int streamId) throws Http2Exception {\n        Stream stream = getStream(streamId, false);\n        if (stream == null) {\n            stream = createRemoteStream(streamId);\n        }\n        stream.checkState(FrameType.HEADERS);\n        stream.receivedStartOfHeaders();\n        closeIdleStreams(streamId);\n        if (localSettings.getMaxConcurrentStreams() > activeRemoteStreamCount) {\n            activeRemoteStreamCount++;\n        } else {\n            throw new StreamException(sm.getString(\"upgradeHandler.tooManyRemoteStreams\",\n                    Long.toString(localSettings.getMaxConcurrentStreams())),\n                    Http2Error.REFUSED_STREAM, streamId);\n        }\n        return stream;\n    }","commit_id":"9d85c135562e08dca2f6f04b5b1f89c4d64f7f47","url":"https://github.com/apache/tomcat"},{"original_method":"public Http2UpgradeHandler(Adapter adapter, Request coyoteRequest) {\n        super (STREAM_ID_ZERO);\n        this.adapter = adapter;\n        this.connectionId = Integer.toString(connectionIdGenerator.getAndIncrement());\n\n        // Initial HTTP request becomes stream 1.\n        if (coyoteRequest != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"upgradeHandler.upgrade\", connectionId));\n            }\n            Integer key = Integer.valueOf(1);\n            Stream stream = new Stream(key, this, coyoteRequest);\n            streams.put(key, stream);\n            maxRemoteStreamId = 1;\n        }\n    }","id":81401,"modified_method":"public Http2UpgradeHandler(Adapter adapter, Request coyoteRequest) {\n        super (STREAM_ID_ZERO);\n        this.adapter = adapter;\n        this.connectionId = Integer.toString(connectionIdGenerator.getAndIncrement());\n\n        // Initial HTTP request becomes stream 1.\n        if (coyoteRequest != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"upgradeHandler.upgrade\", connectionId));\n            }\n            Integer key = Integer.valueOf(1);\n            Stream stream = new Stream(key, this, coyoteRequest);\n            streams.put(key, stream);\n            maxRemoteStreamId = 1;\n            activeRemoteStreamCount = 1;\n        }\n    }","commit_id":"9d85c135562e08dca2f6f04b5b1f89c4d64f7f47","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void reset(int streamId, long errorCode) throws Http2Exception  {\n        Stream stream = getStream(streamId, true);\n        if (stream != null) {\n            stream.checkState(FrameType.RST);\n            stream.reset(errorCode);\n        }\n    }","id":81402,"modified_method":"@Override\n    public void reset(int streamId, long errorCode) throws Http2Exception  {\n        Stream stream = getStream(streamId, true);\n        stream.checkState(FrameType.RST);\n        stream.reset(errorCode);\n    }","commit_id":"9d85c135562e08dca2f6f04b5b1f89c4d64f7f47","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    if (flowletContext.isAsyncMode()) {\n      ThreadFactory threadFactory = new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"tx-executor-%d\").build();\n\n      // Thread pool of size max TX_EXECUTOR_POOL_SIZE.\n      // 60 seconds wait time before killing idle threads.\n      // Keep no idle threads more than 60 seconds.\n      // If max thread pool size reached, execute the task in the submitter thread\n      // (basically fallback to sync mode if things comes too fast\n      transactionExecutor = new ThreadPoolExecutor(0, TX_EXECUTOR_POOL_SIZE,\n                                    60L, TimeUnit.SECONDS,\n                                    new SynchronousQueue<Runnable>(),\n                                    threadFactory, new ThreadPoolExecutor.CallerRunsPolicy());\n    } else {\n      transactionExecutor = MoreExecutors.sameThreadExecutor();\n    }\n    runnerThread = Thread.currentThread();\n  }","id":81403,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    if (flowletContext.isAsyncMode()) {\n      ThreadFactory threadFactory = new ThreadFactory() {\n        private final ThreadGroup threadGroup = new ThreadGroup(\"tx-thread\");\n        private final AtomicLong count = new AtomicLong(0);\n\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(threadGroup, r, String.format(\"tx-executor-%d\", count.getAndIncrement()));\n          t.setDaemon(true);\n          return t;\n        }\n      };\n\n      // Thread pool of size max TX_EXECUTOR_POOL_SIZE.\n      // 60 seconds wait time before killing idle threads.\n      // Keep no idle threads more than 60 seconds.\n      // If max thread pool size reached, execute the task in the submitter thread\n      // (basically fallback to sync mode if things comes too fast\n      transactionExecutor = new ThreadPoolExecutor(0, TX_EXECUTOR_POOL_SIZE,\n                                    60L, TimeUnit.SECONDS,\n                                    new SynchronousQueue<Runnable>(),\n                                    threadFactory, new ThreadPoolExecutor.CallerRunsPolicy());\n    } else {\n      transactionExecutor = MoreExecutors.sameThreadExecutor();\n    }\n    runnerThread = Thread.currentThread();\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void run() {\n    LoggingContextAccessor.setLoggingContext(loggingContext);\n\n    initFlowlet();\n\n    // Insert all into priority queue, ordered by next deque time.\n    PriorityBlockingQueue<ProcessEntry> processQueue = new PriorityBlockingQueue<ProcessEntry>(processSpecs.size());\n    for (ProcessSpecification spec : processSpecs) {\n      processQueue.offer(new ProcessEntry(spec));\n    }\n    List<ProcessEntry> processList = Lists.newArrayListWithExpectedSize(processSpecs.size() * 2);\n\n    while (isRunning()) {\n      CountDownLatch suspendLatch = suspension.get();\n      if (suspendLatch != null) {\n        try {\n          // Use a spin loop to wait for all inflight to be done\n          while (inflight.get() != 0) {\n            TimeUnit.MILLISECONDS.sleep(10);\n          }\n          suspendBarrier.await();\n          suspendLatch.await();\n        } catch (Exception e) {\n          // Simply continue and let the isRunning() check to deal with that.\n          continue;\n        }\n      }\n\n      try {\n        // If the queue head need to wait, we had to wait.\n        processQueue.peek().await();\n      } catch (InterruptedException e) {\n        // Triggered by shutdown, simply continue and let the isRunning() check to deal with that.\n        continue;\n      }\n\n      processList.clear();\n      processQueue.drainTo(processList);\n\n      for (ProcessEntry entry : processList) {\n        try {\n          if (!entry.shouldProcess()) {\n            continue;\n          }\n          InputDatum input = entry.processSpec.getQueueReader().dequeue();\n          if (input != null && input.isEmpty()) {\n            entry.backOff();\n            continue;\n          }\n          entry.nextDeque = 0;\n          inflight.getAndIncrement();\n\n          try {\n            // Call the process method and commit the transaction\n            ProcessMethod processMethod = entry.processSpec.getProcessMethod();\n            processMethod.invoke(input)\n              .commit(transactionExecutor, processMethodCallback(processQueue, entry, input));\n\n          } catch (Throwable t) {\n            LOG.error(String.format(\"Fail to invoke process method: %s, %s\", entry.processSpec, flowletContext), t);\n          }\n        } catch (OperationException e) {\n          LOG.error(\"Queue operation failure: \" + flowletContext, e);\n        } finally {\n          // If it is not a retry entry, always put it back to the queue, otherwise let the committer do the job.\n          if (!entry.isRetry()) {\n            processQueue.offer(entry);\n          }\n        }\n      }\n    }\n\n    destroyFlowlet();\n  }","id":81404,"modified_method":"@Override\n  protected void run() {\n    LoggingContextAccessor.setLoggingContext(loggingContext);\n\n    initFlowlet();\n\n    // Insert all into priority queue, ordered by next deque time.\n    PriorityBlockingQueue<ProcessEntry> processQueue = new PriorityBlockingQueue<ProcessEntry>(processSpecs.size());\n    for (ProcessSpecification spec : processSpecs) {\n      processQueue.offer(new ProcessEntry(spec));\n    }\n    List<ProcessEntry> processList = Lists.newArrayListWithExpectedSize(processSpecs.size() * 2);\n\n    while (isRunning()) {\n      CountDownLatch suspendLatch = suspension.get();\n      if (suspendLatch != null) {\n        try {\n          // Use a spin loop to wait for all inflight to be done\n          while (inflight.get() != 0) {\n            TimeUnit.MILLISECONDS.sleep(10);\n          }\n          suspendBarrier.await();\n          suspendLatch.await();\n        } catch (Exception e) {\n          // Simply continue and let the isRunning() check to deal with that.\n          continue;\n        }\n      }\n\n      try {\n        // If the queue head need to wait, we had to wait.\n        processQueue.peek().await();\n      } catch (InterruptedException e) {\n        // Triggered by shutdown, simply continue and let the isRunning() check to deal with that.\n        continue;\n      }\n\n      processList.clear();\n      processQueue.drainTo(processList);\n\n      for (ProcessEntry entry : processList) {\n        try {\n          if (!entry.shouldProcess()) {\n            continue;\n          }\n          InputDatum input = entry.processSpec.getQueueReader().dequeue();\n          if (!input.needProcess()) {\n            entry.backOff();\n            continue;\n          }\n          entry.nextDeque = 0;\n          inflight.getAndIncrement();\n\n          try {\n            // Call the process method and commit the transaction\n            ProcessMethod processMethod = entry.processSpec.getProcessMethod();\n            processMethod.invoke(input)\n              .commit(transactionExecutor, processMethodCallback(processQueue, entry, input));\n\n          } catch (Throwable t) {\n            LOG.error(String.format(\"Fail to invoke process method: %s, %s\", entry.processSpec, flowletContext), t);\n          }\n        } catch (OperationException e) {\n          LOG.error(\"Queue operation failure: \" + flowletContext, e);\n        } finally {\n          // If it is not a retry entry, always put it back to the queue, otherwise let the committer do the job.\n          if (!entry.isRetry()) {\n            processQueue.offer(entry);\n          }\n        }\n      }\n    }\n\n    destroyFlowlet();\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Creates all {@link ProcessSpecification} for the process methods of the flowlet class.\n   *\n   * @param flowletType Type of the flowlet class represented by {@link TypeToken}.\n   * @param processMethodFactory A {@link ProcessMethodFactory} for creating {@link ProcessMethod}.\n   * @param processSpecFactory A {@link ProcessSpecificationFactory} for creating {@link ProcessSpecification}.\n   * @param result A {@link Collection} for storing newly created {@link ProcessSpecification}.\n   * @return The same {@link Collection} as the {@code result} parameter.\n   */\n  private Collection<ProcessSpecification> createProcessSpecification(TypeToken<? extends Flowlet> flowletType,\n                                                                      ProcessMethodFactory processMethodFactory,\n                                                                      ProcessSpecificationFactory processSpecFactory,\n                                                                      Collection<ProcessSpecification> result)\n                                                                                  throws NoSuchMethodException {\n\n    if (GeneratorFlowlet.class.isAssignableFrom(flowletType.getRawType())) {\n      Method method = flowletType.getRawType().getMethod(\"generate\");\n      ProcessMethod generatorMethod = processMethodFactory.create(method, null, null);\n      return ImmutableList.of(processSpecFactory.create(ImmutableSet.<String>of(), null, generatorMethod));\n    }\n\n    // Walk up the hierarchy of flowlet class to get all process methods\n    // It needs to be traverse twice because process method needs to know all output emitters.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n      // Extracts all process methods\n      for (Method method : type.getRawType().getDeclaredMethods()) {\n        Process processAnnotation = method.getAnnotation(Process.class);\n        if (!method.getName().startsWith(FlowletDefinition.PROCESS_METHOD_PREFIX) && processAnnotation == null) {\n          continue;\n        }\n\n        Set<String> inputNames;\n        if (processAnnotation == null || processAnnotation.value().length == 0) {\n          inputNames = ImmutableSet.of(FlowletDefinition.ANY_INPUT);\n        } else {\n          inputNames = ImmutableSet.copyOf(processAnnotation.value());\n        }\n\n        try {\n          TypeToken<?> dataType = TypeToken.of(method.getGenericParameterTypes()[0]);\n          Schema schema = schemaGenerator.generate(dataType.getType());\n\n          ProcessMethod processMethod = processMethodFactory.create(method, dataType, schema);\n          result.add(processSpecFactory.create(inputNames, schema, processMethod));\n        } catch (UnsupportedTypeException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    }\n    return result;\n  }","id":81405,"modified_method":"/**\n   * Creates all {@link ProcessSpecification} for the process methods of the flowlet class.\n   *\n   * @param flowletType Type of the flowlet class represented by {@link TypeToken}.\n   * @param processMethodFactory A {@link ProcessMethodFactory} for creating {@link ProcessMethod}.\n   * @param processSpecFactory A {@link ProcessSpecificationFactory} for creating {@link ProcessSpecification}.\n   * @param result A {@link Collection} for storing newly created {@link ProcessSpecification}.\n   * @return The same {@link Collection} as the {@code result} parameter.\n   */\n  private Collection<ProcessSpecification> createProcessSpecification(TypeToken<? extends Flowlet> flowletType,\n                                                                      ProcessMethodFactory processMethodFactory,\n                                                                      ProcessSpecificationFactory processSpecFactory,\n                                                                      Collection<ProcessSpecification> result)\n                                                                                  throws NoSuchMethodException {\n\n    if (GeneratorFlowlet.class.isAssignableFrom(flowletType.getRawType())) {\n      Method method = flowletType.getRawType().getMethod(\"generate\");\n      ProcessMethod generatorMethod = processMethodFactory.create(method,\n                                                                  TypeToken.of(void.class),\n                                                                  Schema.of(Schema.Type.NULL));\n      return ImmutableList.of(processSpecFactory.create(ImmutableSet.<String>of(),\n                                                        Schema.of(Schema.Type.NULL),\n                                                        generatorMethod));\n    }\n\n    // Walk up the hierarchy of flowlet class to get all process methods\n    // It needs to be traverse twice because process method needs to know all output emitters.\n    for (TypeToken<?> type : flowletType.getTypes().classes()) {\n      if (type.getRawType().equals(Object.class)) {\n        break;\n      }\n      // Extracts all process methods\n      for (Method method : type.getRawType().getDeclaredMethods()) {\n        Process processAnnotation = method.getAnnotation(Process.class);\n        if (!method.getName().startsWith(FlowletDefinition.PROCESS_METHOD_PREFIX) && processAnnotation == null) {\n          continue;\n        }\n\n        Set<String> inputNames;\n        if (processAnnotation == null || processAnnotation.value().length == 0) {\n          inputNames = ImmutableSet.of(FlowletDefinition.ANY_INPUT);\n        } else {\n          inputNames = ImmutableSet.copyOf(processAnnotation.value());\n        }\n\n        try {\n          TypeToken<?> dataType = TypeToken.of(method.getGenericParameterTypes()[0]);\n          Schema schema = schemaGenerator.generate(dataType.getType());\n\n          ProcessMethod processMethod = processMethodFactory.create(method, dataType, schema);\n          result.add(processSpecFactory.create(inputNames, schema, processMethod));\n        } catch (UnsupportedTypeException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void ack() throws OperationException {\n      if (input != null) {\n        TransactionAgent txAgent = txAgentSupplier.get();\n        txAgent.start();\n        txAgent.submit(input.asAck());\n        txAgent.finish();\n      }\n    }","id":81406,"modified_method":"@Override\n    public void ack() throws OperationException {\n      TransactionAgent txAgent = txAgentSupplier.get();\n      txAgent.start();\n      input.submitAck(txAgent);\n      txAgent.finish();\n    }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"private PostProcess getPostProcess(final TransactionAgent txAgent,\n                                     final InputDatum input,\n                                     final T event,\n                                     final InputContext inputContext) {\n    return new PostProcess() {\n      @Override\n      public void commit(Executor executor, final Callback callback) {\n        executor.execute(new Runnable() {\n\n          @Override\n          public void run() {\n            try {\n              if (input != null) {\n                txAgent.submit(input.asAck());\n              }\n              txAgent.finish();\n              callback.onSuccess(event, inputContext);\n            } catch (Throwable t) {\n              LOGGER.error(\"Fail to commit transction.\", t);\n              callback.onFailure(event, inputContext,\n                                 new FailureReason(FailureReason.Type.IO_ERROR, t.getMessage()),\n                                 new SimpleInputAcknowledger(txAgentSupplier, input));\n            }\n          }\n        });\n      }\n    };\n  }","id":81407,"modified_method":"private PostProcess getPostProcess(final TransactionAgent txAgent,\n                                     final InputDatum input,\n                                     final T event,\n                                     final InputContext inputContext) {\n    return new PostProcess() {\n      @Override\n      public void commit(Executor executor, final Callback callback) {\n        executor.execute(new Runnable() {\n\n          @Override\n          public void run() {\n            try {\n              input.submitAck(txAgent);\n              txAgent.finish();\n              callback.onSuccess(event, inputContext);\n            } catch (Throwable t) {\n              LOGGER.error(\"Fail to commit transction.\", t);\n              callback.onFailure(event, inputContext,\n                                 new FailureReason(FailureReason.Type.IO_ERROR, t.getMessage()),\n                                 new SimpleInputAcknowledger(txAgentSupplier, input));\n            }\n          }\n        });\n      }\n    };\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"private PostProcess doInvoke(final InputDatum input) {\n    final TransactionAgent txAgent = txAgentSupplier.get();\n\n    try {\n      txAgent.start();\n\n      // TODO: This is for generator. Need to refactor to get rid of null things\n      if (input == null) {\n        Preconditions.checkState(!hasParam, \"null input not allowed\");\n        try {\n          method.invoke(flowlet);\n          outputSubmitter.submit(txAgent);\n          return getPostProcess(txAgent, input, null, null);\n        } catch (Throwable t) {\n          return getFailurePostProcess(t, txAgent, input, null, null);\n        }\n      }\n\n      ByteBuffer data = input.getData();\n      Schema sourceSchema = schemaCache.get(data);\n      Preconditions.checkNotNull(sourceSchema, \"Fail to find source schema.\");\n\n      byteBufferInput.reset(data);\n      final T event = datumReader.read(decoder, sourceSchema);\n      final InputContext inputContext = input.getInputContext();\n\n      try {\n        if(needContext) {\n          method.invoke(flowlet, event, inputContext);\n        } else if (hasParam) {\n          method.invoke(flowlet, event);\n        }\n        outputSubmitter.submit(txAgent);\n\n        return getPostProcess(txAgent, input, event, inputContext);\n\n      } catch(Throwable t) {\n        return getFailurePostProcess(t, txAgent, input, event, inputContext);\n      }\n    } catch (Exception e) {\n      // If it reaches here, something very wrong.\n      LOGGER.error(\"Fail to process input.\", e);\n      throw Throwables.propagate(e);\n    }\n  }","id":81408,"modified_method":"private PostProcess doInvoke(final InputDatum input) {\n    final TransactionAgent txAgent = txAgentSupplier.get();\n\n    try {\n      txAgent.start();\n      Preconditions.checkState(!hasParam || input.needProcess(), \"Empty input provided to method that needs input.\");\n\n      T event = null;\n      if (hasParam) {\n        ByteBuffer data = input.getData();\n        Schema sourceSchema = schemaCache.get(data);\n        Preconditions.checkNotNull(sourceSchema, \"Fail to find source schema.\");\n\n        byteBufferInput.reset(data);\n        event = datumReader.read(decoder, sourceSchema);\n\n      }\n      InputContext inputContext = input.getInputContext();\n\n      try {\n        if (hasParam) {\n          if(needContext) {\n            method.invoke(flowlet, event, inputContext);\n          } else if (hasParam) {\n            method.invoke(flowlet, event);\n          }\n        } else {\n          method.invoke(flowlet);\n        }\n        outputSubmitter.submit(txAgent);\n\n        return getPostProcess(txAgent, input, event, inputContext);\n\n      } catch(Throwable t) {\n        return getFailurePostProcess(t, txAgent, input, event, inputContext);\n      }\n    } catch (Exception e) {\n      // If it reaches here, something very wrong.\n      LOGGER.error(\"Fail to process input.\", e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"private ReflectionProcessMethod(Flowlet flowlet, Method method,\n                                  TypeToken<T> dataType,\n                                  Schema schema, SchemaCache schemaCache,\n                                  TransactionAgentSupplier txAgentSupplier,\n                                  OutputSubmitter outputSubmitter) {\n    this.flowlet = flowlet;\n    this.method = method;\n    this.schemaCache = schemaCache;\n    this.txAgentSupplier = txAgentSupplier;\n    this.outputSubmitter = outputSubmitter;\n\n    this.hasParam = method.getGenericParameterTypes().length > 0;\n    this.needContext = method.getGenericParameterTypes().length == 2;\n    this.datumReader = (schema == null || dataType == null) ? null : new ReflectionDatumReader<T>(schema, dataType);\n    this.byteBufferInput = new ByteBufferInputStream(null);\n    this.decoder = new BinaryDecoder(byteBufferInput);\n\n    if(!this.method.isAccessible()) {\n      this.method.setAccessible(true);\n    }\n  }","id":81409,"modified_method":"private ReflectionProcessMethod(Flowlet flowlet, Method method,\n                                  TypeToken<T> dataType,\n                                  Schema schema, SchemaCache schemaCache,\n                                  TransactionAgentSupplier txAgentSupplier,\n                                  OutputSubmitter outputSubmitter) {\n    this.flowlet = flowlet;\n    this.method = method;\n    this.schemaCache = schemaCache;\n    this.txAgentSupplier = txAgentSupplier;\n    this.outputSubmitter = outputSubmitter;\n\n    this.hasParam = method.getGenericParameterTypes().length > 0;\n    this.needContext = method.getGenericParameterTypes().length == 2;\n    this.datumReader = new ReflectionDatumReader<T>(schema, dataType);\n    this.byteBufferInput = new ByteBufferInputStream(null);\n    this.decoder = new BinaryDecoder(byteBufferInput);\n\n    if(!this.method.isAccessible()) {\n      this.method.setAccessible(true);\n    }\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public InputDatum dequeue() throws OperationException {\n    if (!readers.hasNext()) {\n      return null;\n    }\n\n    // Read an input from the underlying QueueReader\n    QueueReader begin = readers.next();\n    InputDatum input = begin.dequeue();\n\n    // While the input is empty, keep trying to read from subsequent readers,\n    // until a non-empty input is read or it loop back to the beginning reader.\n    while (input.isEmpty()) {\n      QueueReader reader = readers.next();\n      if (reader == begin) {\n        return input;\n      }\n      input = reader.dequeue();\n    }\n    return input;\n  }","id":81410,"modified_method":"@Override\n  public InputDatum dequeue() throws OperationException {\n    if (!readers.hasNext()) {\n      return NULL_INPUT;\n    }\n\n    // Read an input from the underlying QueueReader\n    QueueReader begin = readers.next();\n    InputDatum input = begin.dequeue();\n\n    // While the input is empty, keep trying to read from subsequent readers,\n    // until a non-empty input is read or it loop back to the beginning reader.\n    while (input.needProcess()) {\n      QueueReader reader = readers.next();\n      if (reader == begin) {\n        return input;\n      }\n      input = reader.dequeue();\n    }\n    return input;\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public InputDatum dequeue() throws OperationException {\n    QueueConsumer consumer = queueConsumer.get();\n    byte[] queueNameBytes = queueName.toBytes();\n    QueueDequeue dequeue = new QueueDequeue(queueNameBytes, consumer, consumer.getQueueConfig());\n    return new InputDatum(consumer, queueName, opex.execute(operationCtx, dequeue));\n  }","id":81411,"modified_method":"@Override\n  public InputDatum dequeue() throws OperationException {\n    QueueConsumer consumer = queueConsumer.get();\n    byte[] queueNameBytes = queueName.toBytes();\n    QueueDequeue dequeue = new QueueDequeue(queueNameBytes, consumer, consumer.getQueueConfig());\n    return new QueueInputDatum(consumer, queueName, opex.execute(operationCtx, dequeue));\n  }","commit_id":"68288c7569fcbec69467c9be210b5ec1ffbc95d3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * \n     * @param file\n     * @return True if a video file that can be displayed \n     */\n    private boolean isVideoSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n        \n        if ((containsExt(name, AUDIO_EXTENSIONS) || containsExt(name, videoExtensions)) && \n                (!videoMimes.isEmpty() && file.isMimeType(videoMimes) == MimeMatchEnum.TRUE)) {\n            return true;\n        }\n        return false;\n    }","id":81412,"modified_method":"/**\n     * is the given file a video we can display?\n     *\n     * @param file\n     *\n     * @return True if a video file that can be displayed\n     */\n    private boolean isVideoSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n\n        //TODO: is this what we want, to require both extension and mimetype support?\n        if (AUDIO_EXTENSIONS.contains(\".\" + name) || videoExtensions.contains(\".\" + name)) {\n            try {\n                String mimeType = new FileTypeDetector().detect(file);\n                if (nonNull(mimeType) && videoMimes.contains(mimeType)) {\n                    return true;\n                }\n            } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n                logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n                if (!videoMimes.isEmpty() && file.isMimeType(videoMimes) == MimeMatchEnum.TRUE) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"f5eec81d50efd26b74e8fe400f87141854e37316","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * \n     * @param file\n     * @return  True if an image file that can be displayed\n     */\n    private boolean isImageSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n        \n        // blackboard\n        if (!imageMimes.isEmpty()) {\n            MimeMatchEnum mimeMatch = file.isMimeType(imageMimes);\n            if (mimeMatch == MimeMatchEnum.TRUE) {\n                return true;\n            }\n            else if (mimeMatch == MimeMatchEnum.FALSE) {\n                return false;\n            }\n        }\n        \n        // extension\n        if (containsExt(name, imageExtensions)) {\n            return true;\n        }\n        // our own signature checks for important types\n        else if (ImageUtils.isJpegFileHeader(file)) {\n            return true;\n        }\n        else if (ImageUtils.isPngFileHeader(file)) {\n            return true;\n        }\n        \n        //for gstreamer formats, check if initialized first, then\n        //support audio formats, and video formats\n        return false;\n    }","id":81413,"modified_method":"/**\n     * is the given file an image that we can display?\n     *\n     * @param file\n     *\n     * @return True if an image file that can be displayed\n     */\n    private boolean isImageSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n\n        // blackboard\n        try {\n            String mimeType = new FileTypeDetector().detect(file);\n            if (nonNull(mimeType) && imageMimes.contains(mimeType)) {\n                return true;\n            }\n        } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n            logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n            if (!imageMimes.isEmpty()) {\n                MimeMatchEnum mimeMatch = file.isMimeType(imageMimes);\n                if (mimeMatch == MimeMatchEnum.TRUE) {\n                    return true;\n                } else if (mimeMatch == MimeMatchEnum.FALSE) {\n                    return false;\n                }\n            }\n        }\n\n        // extension\n        if (imageExtensions.contains(\".\" + name)) {\n            return true;\n        }\n\n        // our own signature checks for important types\n        if (ImageUtils.isJpegFileHeader(file)) {\n            return true;\n        }\n        return ImageUtils.isPngFileHeader(file);\n    }","commit_id":"f5eec81d50efd26b74e8fe400f87141854e37316","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public int isPreferred(Node node) {\n        //special case, check if deleted video, then do not make it preferred\n        AbstractFile file = node.getLookup().lookup(AbstractFile.class);\n        if (file == null) {\n            return 0;\n        }\n        String name = file.getName().toLowerCase();\n        boolean deleted = file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC);\n\n        if (containsExt(name, videoExtensions) && deleted) {\n            return 0;\n        } \n        else {\n            return 7;\n        }\n        \n    }","id":81414,"modified_method":"@Override\n    public int isPreferred(Node node) {\n        //special case, check if deleted video, then do not make it preferred\n        AbstractFile file = node.getLookup().lookup(AbstractFile.class);\n        if (file == null) {\n            return 0;\n        }\n        String extension = file.getNameExtension();\n        boolean deleted = file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC);\n\n        if (videoExtensions.contains(\".\" + extension) && deleted) {\n            return 0;\n        } else {\n            return 7;\n        }\n    }","commit_id":"f5eec81d50efd26b74e8fe400f87141854e37316","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * is the given file an image that we can display?\n     *\n     * @param file\n     *\n     * @return True if an image file that can be displayed\n     */\n    private boolean isImageSupported(AbstractFile file) {\n        String name = file.getNameExtension();\n\n        // blackboard\n        try {\n            String mimeType = new FileTypeDetector().detect(file);\n            if (nonNull(mimeType) && imageMimes.contains(mimeType)) {\n                return true;\n            }\n        } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n            logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n            if (!imageMimes.isEmpty()) {\n                MimeMatchEnum mimeMatch = file.isMimeType(imageMimes);\n                if (mimeMatch == MimeMatchEnum.TRUE) {\n                    return true;\n                } else if (mimeMatch == MimeMatchEnum.FALSE) {\n                    return false;\n                }\n            }\n        }\n\n        // extension\n        if (imageExtensions.contains(\".\" + name)) {\n            return true;\n        }\n\n        // our own signature checks for important types\n        if (ImageUtils.isJpegFileHeader(file)) {\n            return true;\n        }\n        return ImageUtils.isPngFileHeader(file);\n    }","id":81415,"modified_method":"/**\n     * is the given file an image that we can display?\n     *\n     * @param file\n     *\n     * @return True if an image file that can be displayed\n     */\n    private boolean isImageSupported(AbstractFile file) {\n        String name = file.getNameExtension();\n\n        // blackboard\n        try {\n            String mimeType = new FileTypeDetector().getFileType(file);\n            if (nonNull(mimeType)) {\n                return imageMimes.contains(mimeType);\n            }\n        } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n            logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n            if (!imageMimes.isEmpty()) {\n                MimeMatchEnum mimeMatch = file.isMimeType(imageMimes);\n                if (mimeMatch == MimeMatchEnum.TRUE) {\n                    return true;\n                } else if (mimeMatch == MimeMatchEnum.FALSE) {\n                    return false;\n                }\n            }\n        }\n\n        // extension\n        if (imageExtensions.contains(\".\" + name)) {\n            return true;\n        }\n\n        // our own signature checks for important types\n        return ImageUtils.isJpegFileHeader(file) || ImageUtils.isPngFileHeader(file);\n    }","commit_id":"c9bcf48acc4551d47edaa7ad42236025423de88b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * is the given file a video we can display?\n     *\n     * @param file\n     *\n     * @return True if a video file that can be displayed\n     */\n    private boolean isVideoSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n\n        //TODO: is this what we want, to require both extension and mimetype support?\n        if (AUDIO_EXTENSIONS.contains(\".\" + name) || videoExtensions.contains(\".\" + name)) {\n            try {\n                String mimeType = new FileTypeDetector().detect(file);\n                if (nonNull(mimeType) && videoMimes.contains(mimeType)) {\n                    return true;\n                }\n            } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n                logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n                if (!videoMimes.isEmpty() && file.isMimeType(videoMimes) == MimeMatchEnum.TRUE) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":81416,"modified_method":"/**\n     * is the given file a video we can display?\n     *\n     * @param file\n     *\n     * @return True if a video file that can be displayed\n     */\n    private boolean isVideoSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n\n        //TODO: is this what we want, to require both extension and mimetype support?\n        if (AUDIO_EXTENSIONS.contains(\".\" + name) || videoExtensions.contains(\".\" + name)) {\n            try {\n                String mimeType = new FileTypeDetector().getFileType(file);\n                if (nonNull(mimeType)) {\n                    return videoMimes.contains(mimeType);\n                }\n            } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n                logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n                if (!videoMimes.isEmpty() && file.isMimeType(videoMimes) == MimeMatchEnum.TRUE) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"c9bcf48acc4551d47edaa7ad42236025423de88b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public boolean isSupported(Node node) {\n        if (node == null) {\n            return false;\n        }\n\n        AbstractFile file = node.getLookup().lookup(AbstractFile.class);\n        if (file == null) {\n            return false;\n        }\n\n        if (file.getSize() == 0) {\n            return false;\n        }\n\n        if (imagePanelInited) {\n            if (isImageSupported(file)) {\n                return true;\n            }\n        }\n\n        if (videoPanelInited && videoPanel.isInited()) {\n            if (isVideoSupported(file)) {\n                return true;\n            }\n        }\n\n        return false;\n    }","id":81417,"modified_method":"@Override\n    public boolean isSupported(Node node) {\n        if (node == null) {\n            return false;\n        }\n\n        AbstractFile file = node.getLookup().lookup(AbstractFile.class);\n        if (file == null) {\n            return false;\n        }\n\n        if (file.getSize() == 0) {\n            return false;\n        }\n\n        if (imagePanelInited && isImageSupported(file)) {\n            return true;\n        }\n\n        return videoPanelInited && isVideoSupported(file);\n    }","commit_id":"c9bcf48acc4551d47edaa7ad42236025423de88b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * \n     * @param file\n     * @return True if a video file that can be displayed \n     */\n    private boolean isVideoSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n        \n        if ((containsExt(name, AUDIO_EXTENSIONS) || containsExt(name, videoExtensions)) && \n                (!videoMimes.isEmpty() && file.isMimeType(videoMimes) == MimeMatchEnum.TRUE)) {\n            return true;\n        }\n        return false;\n    }","id":81418,"modified_method":"/**\n     * is the given file a video we can display?\n     *\n     * @param file\n     *\n     * @return True if a video file that can be displayed\n     */\n    private boolean isVideoSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n\n        //TODO: is this what we want, to require both extension and mimetype support?\n        if (AUDIO_EXTENSIONS.contains(\".\" + name) || videoExtensions.contains(\".\" + name)) {\n            try {\n                String mimeType = new FileTypeDetector().detect(file);\n                if (nonNull(mimeType) && videoMimes.contains(mimeType)) {\n                    return true;\n                }\n            } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n                logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n                if (!videoMimes.isEmpty() && file.isMimeType(videoMimes) == MimeMatchEnum.TRUE) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * \n     * @param file\n     * @return  True if an image file that can be displayed\n     */\n    private boolean isImageSupported(AbstractFile file) {\n        String name = file.getName().toLowerCase();\n        \n        // blackboard\n        if (!imageMimes.isEmpty()) {\n            MimeMatchEnum mimeMatch = file.isMimeType(imageMimes);\n            if (mimeMatch == MimeMatchEnum.TRUE) {\n                return true;\n            }\n            else if (mimeMatch == MimeMatchEnum.FALSE) {\n                return false;\n            }\n        }\n        \n        // extension\n        if (containsExt(name, imageExtensions)) {\n            return true;\n        }\n        // our own signature checks for important types\n        else if (ImageUtils.isJpegFileHeader(file)) {\n            return true;\n        }\n        else if (ImageUtils.isPngFileHeader(file)) {\n            return true;\n        }\n        \n        //for gstreamer formats, check if initialized first, then\n        //support audio formats, and video formats\n        return false;\n    }","id":81419,"modified_method":"/**\n     * is the given file an image that we can display?\n     *\n     * @param file\n     *\n     * @return True if an image file that can be displayed\n     */\n    private boolean isImageSupported(AbstractFile file) {\n        String name = file.getNameExtension();\n\n        // blackboard\n        try {\n            String mimeType = new FileTypeDetector().detect(file);\n            if (nonNull(mimeType) && imageMimes.contains(mimeType)) {\n                return true;\n            }\n        } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n            logger.log(Level.WARNING, \"Failed to look up mimetype for \" + file.getName() + \" using FileTypeDetector.  Fallingback on AbstractFile.isMimeType\", ex);\n            if (!imageMimes.isEmpty()) {\n                MimeMatchEnum mimeMatch = file.isMimeType(imageMimes);\n                if (mimeMatch == MimeMatchEnum.TRUE) {\n                    return true;\n                } else if (mimeMatch == MimeMatchEnum.FALSE) {\n                    return false;\n                }\n            }\n        }\n\n        // extension\n        if (imageExtensions.contains(\".\" + name)) {\n            return true;\n        }\n\n        // our own signature checks for important types\n        if (ImageUtils.isJpegFileHeader(file)) {\n            return true;\n        }\n        return ImageUtils.isPngFileHeader(file);\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public int isPreferred(Node node) {\n        //special case, check if deleted video, then do not make it preferred\n        AbstractFile file = node.getLookup().lookup(AbstractFile.class);\n        if (file == null) {\n            return 0;\n        }\n        String name = file.getName().toLowerCase();\n        boolean deleted = file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC);\n\n        if (containsExt(name, videoExtensions) && deleted) {\n            return 0;\n        } \n        else {\n            return 7;\n        }\n        \n    }","id":81420,"modified_method":"@Override\n    public int isPreferred(Node node) {\n        //special case, check if deleted video, then do not make it preferred\n        AbstractFile file = node.getLookup().lookup(AbstractFile.class);\n        if (file == null) {\n            return 0;\n        }\n        String extension = file.getNameExtension();\n        boolean deleted = file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC);\n\n        if (videoExtensions.contains(\".\" + extension) && deleted) {\n            return 0;\n        } else {\n            return 7;\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Get a thumbnail of a specified size. Generates the image if it is \n     * not already cached. \n     * \n     * @param content\n     * @param iconSize\n     * @return \n     */\n    public static Image getIcon(Content content, int iconSize) {\n        Image icon;\n        // If a thumbnail file is already saved locally\n        // @@@ Bug here in that we do not refer to size in the cache. \n        File file = getFile(content.getId());\n        if (file.exists()) {\n            try {\n                BufferedImage bicon = ImageIO.read(file);\n                if (bicon == null) {\n                    icon = DEFAULT_ICON;\n                } else if (bicon.getWidth() != iconSize) {\n                    icon = generateAndSaveIcon(content, iconSize, file);    \n                } else {\n                    icon = bicon;    \n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Error while reading image.\", ex); //NON-NLS\n                icon = DEFAULT_ICON;\n            }\n        } else { // Make a new icon\n            icon = generateAndSaveIcon(content, iconSize, file);\n        }\n        return icon;\n    }","id":81421,"modified_method":"/**\n     * Get a thumbnail of a specified size. Generates the image if it is\n     * not already cached.\n     *\n     * @param content\n     * @param iconSize\n     *\n     * @return a thumbnail for the given image or a default one if there was a\n     *         problem making a thumbnail.\n     */\n    @Nonnull\n    public static Image getIcon(Content content, int iconSize) {\n        // If a thumbnail file is already saved locally\n        File cacheFile = getCachedThumnailLocation(content.getId());\n        if (cacheFile.exists()) {\n            try {\n                BufferedImage thumbnail = ImageIO.read(cacheFile);\n                if (isNull(thumbnail) || thumbnail.getWidth() != iconSize) {\n                    return generateAndSaveThumbnail(content, iconSize, cacheFile);\n                } else {\n                    return thumbnail;\n                }\n            } catch (IOException ex) {\n                LOGGER.log(Level.WARNING, \"Error while reading image.\", ex); //NON-NLS\n                return generateAndSaveThumbnail(content, iconSize, cacheFile);\n            }\n        } else {\n            return generateAndSaveThumbnail(content, iconSize, cacheFile);\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Get a file object for where the cached icon should exist.  The returned file may not exist.\n     * \n     * @param id\n     * @return \n     */\n    // TODO: This should be private and be renamed to something like  getCachedThumbnailLocation().\n    public static File getFile(long id) {\n        return new File(Case.getCurrentCase().getCacheDirectory() + File.separator + id + \".png\");\n    }","id":81422,"modified_method":"/**\n     * Get a file object for where the cached icon should exist. The returned\n     * file may not exist.\n     *\n     * @param id\n     *\n     * @return\n     *\n     * @deprecated this should never have been public\n     */\n    @Deprecated\n    public static File getFile(long id) {\n        return getCachedThumnailLocation(id);\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Get a thumbnail of a specified size. Generates the image if it is \n     * not already cached. \n     * @param content\n     * @param iconSize\n     * @return File object for cached image. Is guaranteed to exist. \n     */\n    public static File getIconFile(Content content, int iconSize) {\n        if (getIcon(content, iconSize) != null) {\n            return getFile(content.getId());\n        }\n        return null;\n    }","id":81423,"modified_method":"/**\n     * Get a thumbnail of a specified size. Generates the image if it is\n     * not already cached.\n     *\n     * @param content\n     * @param iconSize\n     *\n     * @return File object for cached image. Is guaranteed to exist, as long as\n     *         there was not an error generating or saving the thumbnail.\n     */\n    @Nullable\n    public static File getIconFile(Content content, int iconSize) {\n        getIcon(content, iconSize);\n        return getCachedThumnailLocation(content.getId());\n\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static boolean isPngFileHeader(AbstractFile file) {\n        if (file.getSize() < 10) {\n            return false;\n        }\n\n        byte[] fileHeaderBuffer = new byte[8];\n        int bytesRead;\n        try {\n            bytesRead = file.read(fileHeaderBuffer, 0, 8);\n        } catch (TskCoreException ex) {\n            //ignore if can't read the first few bytes, not an image\n            return false;\n        }\n        if (bytesRead != 8) {\n            return false;\n        }\n        /*\n         * Check for the header. Since Java bytes are signed, we cast them\n         * to an int first.\n         */\n        return (((fileHeaderBuffer[1] & 0xff) == 0x50) && ((fileHeaderBuffer[2] & 0xff) == 0x4E) &&\n                ((fileHeaderBuffer[3] & 0xff) == 0x47) && ((fileHeaderBuffer[4] & 0xff) == 0x0D) &&\n                ((fileHeaderBuffer[5] & 0xff) == 0x0A) && ((fileHeaderBuffer[6] & 0xff) == 0x1A) &&\n                ((fileHeaderBuffer[7] & 0xff) == 0x0A));\n    }","id":81424,"modified_method":"/**\n     * Check if the given file is a png based on header.\n     *\n     * @param file\n     *\n     * @return true if png file, false otherwise\n     */\n    public static boolean isPngFileHeader(AbstractFile file) {\n        if (file.getSize() < 10) {\n            return false;\n        }\n\n        try {\n            byte[] fileHeaderBuffer = readHeader(file, 8);\n            /* Check for the png header. Since Java bytes are signed, we cast\n             * them to an int first. */\n            return (((fileHeaderBuffer[1] & 0xff) == 0x50) && ((fileHeaderBuffer[2] & 0xff) == 0x4E)\n                    && ((fileHeaderBuffer[3] & 0xff) == 0x47) && ((fileHeaderBuffer[4] & 0xff) == 0x0D)\n                    && ((fileHeaderBuffer[5] & 0xff) == 0x0A) && ((fileHeaderBuffer[6] & 0xff) == 0x1A)\n                    && ((fileHeaderBuffer[7] & 0xff) == 0x0A));\n\n        } catch (TskCoreException ex) {\n            //ignore if can't read the first few bytes, not an png\n            return false;\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Check if is jpeg file based on header\n     *\n     * @param file\n     *\n     * @return true if jpeg file, false otherwise\n     */\n    public static boolean isJpegFileHeader(AbstractFile file) {\n        if (file.getSize() < 100) {\n            return false;\n        }\n\n        byte[] fileHeaderBuffer = new byte[2];\n        int bytesRead;\n        try {\n            bytesRead = file.read(fileHeaderBuffer, 0, 2);\n        } catch (TskCoreException ex) {\n            //ignore if can't read the first few bytes, not a JPEG\n            return false;\n        }\n        if (bytesRead != 2) {\n            return false;\n        }\n        /*\n         * Check for the JPEG header. Since Java bytes are signed, we cast them\n         * to an int first.\n         */\n        return (((fileHeaderBuffer[0] & 0xff) == 0xff) && ((fileHeaderBuffer[1] & 0xff) == 0xd8));\n    }","id":81425,"modified_method":"/**\n     * Check if the given file is a jpeg based on header.\n     *\n     * @param file\n     *\n     * @return true if jpeg file, false otherwise\n     */\n    public static boolean isJpegFileHeader(AbstractFile file) {\n        if (file.getSize() < 100) {\n            return false;\n        }\n\n        try {\n            byte[] fileHeaderBuffer = readHeader(file, 2);\n            /* Check for the JPEG header. Since Java bytes are signed, we cast\n             * them to an int first. */\n            return (((fileHeaderBuffer[0] & 0xff) == 0xff) && ((fileHeaderBuffer[1] & 0xff) == 0xd8));\n        } catch (TskCoreException ex) {\n            //ignore if can't read the first few bytes, not a JPEG\n            return false;\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static BufferedImage generateIcon(Content content, int iconSize) {\n\n        InputStream inputStream = null;\n        BufferedImage bi = null;\n        try {\n            inputStream = new ReadContentInputStream(content);\n            bi = ImageIO.read(inputStream);\n            if (bi == null) {\n                logger.log(Level.WARNING, \"No image reader for file: \" + content.getName()); //NON-NLS\n                return null;\n            }\n            BufferedImage biScaled = ScalrWrapper.resizeFast(bi, iconSize);\n\n            return biScaled;\n        } catch (IllegalArgumentException e) {\n            // if resizing does not work due to extremely small height/width ratio,\n            // crop the image instead.\n            BufferedImage biCropped = ScalrWrapper.cropImage(bi, Math.min(iconSize, bi.getWidth()), Math.min(iconSize, bi.getHeight()));\n            return biCropped;\n        }\n        catch (OutOfMemoryError e) {\n            logger.log(Level.WARNING, \"Could not scale image (too large): \" + content.getName(), e); //NON-NLS\n            return null;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Could not scale image: \" + content.getName(), e); //NON-NLS\n            return null;\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (IOException ex) {\n                    logger.log(Level.WARNING, \"Could not close input stream after resizing thumbnail: \" + content.getName(), ex); //NON-NLS\n                }\n            }\n\n        }\n    }","id":81426,"modified_method":"/**\n     * Generate and return a scaled image\n     *\n     * @param content\n     * @param iconSize\n     *\n     * @return a Thumbnail of the given content at the given size, or null if\n     *         there was a problem.\n     */\n    @Nullable\n    private static BufferedImage generateThumbnail(Content content, int iconSize) {\n\n        try (InputStream inputStream = new ReadContentInputStream(content);) {\n\n            BufferedImage bi = ImageIO.read(inputStream);\n            if (bi == null) {\n                LOGGER.log(Level.WARNING, \"No image reader for file: {0}\", content.getName()); //NON-NLS\n                return null;\n            }\n            try {\n                return ScalrWrapper.resizeFast(bi, iconSize);\n            } catch (IllegalArgumentException e) {\n                // if resizing does not work due to extremely small height/width ratio,\n                // crop the image instead.\n                return ScalrWrapper.cropImage(bi, Math.min(iconSize, bi.getWidth()), Math.min(iconSize, bi.getHeight()));\n            }\n        } catch (OutOfMemoryError e) {\n            LOGGER.log(Level.WARNING, \"Could not scale image (too large): \" + content.getName(), e); //NON-NLS\n            return null;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Could not scale image: \" + content.getName(), e); //NON-NLS\n            return null;\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Can a thumbnail be generated for the content?\n     * \n     * @param content\n     * @return \n     */\n    public static boolean thumbnailSupported(Content content) {\n        if (content instanceof AbstractFile == false) {\n            return false;\n        }\n        \n        AbstractFile f = (AbstractFile) content;\n        if (f.getSize() == 0) {\n            return false;\n        }\n\n        // check the blackboard for a file type attribute\n        try {\n            ArrayList <BlackboardAttribute> attributes = f.getGenInfoAttributes(ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG);\n            for (BlackboardAttribute attribute : attributes) { \n                if (SUPP_MIME_TYPES.contains(attribute.getValueString())) {\n                    return true;\n                }\n            }\n            // if the file type is known and we don't support it, bail\n            if (attributes.size() > 0) {\n                return false;\n            }\n        } \n        catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Error while getting file signature from blackboard.\", ex); //NON-NLS\n        }\n        \n        // if we have an extension, check it\n        final String extension = f.getNameExtension();\n        if (extension.equals(\"\") == false) {\n            // Note: thumbnail generator only supports JPG, GIF, and PNG for now\n            if (SUPP_EXTENSIONS.contains(extension)) {\n                return true;\n            }\n        }\n        \n        // if no extension or one that is not for an image, then read the content\n        return isJpegFileHeader(f);    \n    }","id":81427,"modified_method":"/**\n     * Can a thumbnail be generated for the content?\n     *\n     * @param content\n     *\n     * @return\n     */\n    public static boolean thumbnailSupported(Content content) {\n        if (content instanceof AbstractFile == false) {\n            return false;\n        }\n\n        AbstractFile file = (AbstractFile) content;\n        if (file.getSize() == 0) {\n            return false;\n        }\n\n        try {\n            String mimeType = new FileTypeDetector().getFileType(file);\n            if (Objects.nonNull(mimeType)) {\n                return SUPP_MIME_TYPES.contains(mimeType);\n            }\n        } catch (FileTypeDetector.FileTypeDetectorInitException | TskCoreException ex) {\n            LOGGER.log(Level.WARNING, \"Error while getting file signature from blackboard.\", ex); //NON-NLS\n        }\n\n        // if we have an extension, check it\n        final String extension = file.getNameExtension();\n        if (StringUtils.isNotBlank(extension)) {\n            if (SUPP_EXTENSIONS.contains(extension)) {\n                return true;\n            }\n        }\n        // if no extension or one that is not for an image, then read the content\n        return isJpegFileHeader(file) || isPngFileHeader(file);\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Generate an icon and save it to specified location. \n     * @param content File to generate icon for\n     * @param iconSize\n     * @param saveFile Location to save thumbnail to\n     * @return Generated icon or null on error\n     */\n    private static Image generateAndSaveIcon(Content content, int iconSize, File saveFile) { \n        Image icon = null;\n        try {\n            icon = generateIcon(content, iconSize);\n            if (icon == null) {\n                return DEFAULT_ICON;\n            } else {\n                if (saveFile.exists()) {\n                    saveFile.delete();\n                }\n                ImageIO.write((BufferedImage) icon, \"png\", saveFile); //NON-NLS\n            }         \n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Could not write cache thumbnail: \" + content, ex); //NON-NLS\n        }   \n        return icon;        \n    }","id":81428,"modified_method":"/**\n     * Generate a thumbnail and save it to specified location.\n     *\n     * @param content  File to generate icon for\n     * @param size     the size of thumbnail to generate in pixels\n     * @param saveFile Location to save thumbnail to\n     *\n     * @return Generated icon or a default icon if a thumbnail could not be\n     *         made.\n     */\n    private static Image generateAndSaveThumbnail(Content content, int size, File saveFile) {\n        BufferedImage thumbNail = generateThumbnail(content, size);\n        if (Objects.nonNull(thumbNail)) {\n            imageSaver.execute(() -> {\n\n                saveThumbnail(content, thumbNail, saveFile);\n            });\n            return thumbNail;\n        } else {\n            return getDefaultIcon();\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Show image\n     *\n     * @param file image file to show\n     * @param dims dimension of the parent window\n     */\n    void showImageFx(final AbstractFile file, final Dimension dims) {\n        if (!fxInited) {\n            return;\n        }\n\n        final String fileName = file.getName();\n\n        //hide the panel during loading/transformations\n        fxPanel.setVisible(false);\n\n        // load the image\n        Platform.runLater(new Runnable() {\n            @Override\n            public void run() {\n                if (!Case.isCaseOpen()) {\n                    //handle in-between condition when case is being closed\n                    //and an image was previously selected\n                    return;\n                }\n\n                final InputStream inputStream = new ReadContentInputStream(file);\n\n                final Image fxImage;\n                try {\n                    //original input stream\n                    BufferedImage bi = ImageIO.read(inputStream);\n                    if (bi == null) {\n                        logger.log(Level.WARNING, \"Could image reader not found for file: \" + fileName); //NON-NLS\n                        return;\n                    }\n                    //scale image using Scalr\n                    BufferedImage biScaled = ScalrWrapper.resizeHighQuality(bi, (int) dims.getWidth(), (int) dims.getHeight());\n                    //convert from awt imageto fx image\n                    fxImage = SwingFXUtils.toFXImage(biScaled, null);\n                } catch (IOException ex) {\n                    logger.log(Level.WARNING, \"Could not load image file into media view: \" + fileName, ex); //NON-NLS\n                    return;\n                } catch (OutOfMemoryError ex) {\n                    logger.log(Level.WARNING, \"Could not load image file into media view (too large): \" + fileName, ex); //NON-NLS\n                    MessageNotifyUtil.Notify.warn(\n                            NbBundle.getMessage(this.getClass(), \"MediaViewImagePanel.imgFileTooLarge.msg\", file.getName()),\n                            ex.getMessage());\n                    return;\n                } finally {\n                    try {\n                        inputStream.close();\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Could not close input stream after loading image in media view: \" + fileName, ex); //NON-NLS\n                    }\n                }\n\n                if (fxImage == null || fxImage.isError()) {\n                    logger.log(Level.WARNING, \"Could not load image file into media view: \" + fileName); //NON-NLS\n                    return;\n                }\n\n                //use border pane to center the image in the scene\n                BorderPane borderpane = new BorderPane();\n                borderpane.setCenter(fxImageView);\n\n                fxImageView.setImage(fxImage);\n                fxImageView.setFitWidth(dims.getWidth());\n                fxImageView.setFitHeight(dims.getHeight());\n\n                //Group fxRoot = new Group();\n\n                //Scene fxScene = new Scene(fxRoot, dims.getWidth(), dims.getHeight(), javafx.scene.paint.Color.BLACK);\n                Scene fxScene = new Scene(borderpane, javafx.scene.paint.Color.BLACK);\n                // borderpane.getChildren().add(fxImageView);\n\n                fxPanel.setScene(fxScene);\n\n                SwingUtilities.invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        //show the panel after fully loaded\n                        fxPanel.setVisible(true);\n                    }\n                });\n\n            }\n        });\n\n    }","id":81429,"modified_method":"/**\n     * Show image\n     *\n     * @param file image file to show\n     * @param dims dimension of the parent window\n     */\n    void showImageFx(final AbstractFile file, final Dimension dims) {\n        if (!fxInited) {\n            return;\n        }\n\n        final String fileName = file.getName();\n\n        //hide the panel during loading/transformations\n        //TODO: repalce this with a progress indicator\n        fxPanel.setVisible(false);\n\n        // load the image\n        Platform.runLater(new Runnable() {\n            @Override\n            public void run() {\n                if (!Case.isCaseOpen()) {\n                    //handle in-between condition when case is being closed\n                    //and an image was previously selected\n                    return;\n                }\n\n                final Image fxImage;\n                try (InputStream inputStream = new ReadContentInputStream(file);) {\n\n//                    fxImage = new Image(inputStream);\n                    //original input stream\n                    BufferedImage bi = ImageIO.read(inputStream);\n                    if (bi == null) {\n                        logger.log(Level.WARNING, \"Could image reader not found for file: \" + fileName); //NON-NLS\n                        return;\n                    }\n                    //convert from awt imageto fx image\n                    fxImage = SwingFXUtils.toFXImage(bi, null);\n                } catch (IllegalArgumentException | IOException ex) {\n                    logger.log(Level.WARNING, \"Could not load image file into media view: \" + fileName, ex); //NON-NLS\n                    return;\n                } catch (OutOfMemoryError ex) {\n                    logger.log(Level.WARNING, \"Could not load image file into media view (too large): \" + fileName, ex); //NON-NLS\n                    MessageNotifyUtil.Notify.warn(\n                            NbBundle.getMessage(this.getClass(), \"MediaViewImagePanel.imgFileTooLarge.msg\", file.getName()),\n                            ex.getMessage());\n                    return;\n                }\n\n                if (fxImage.isError()) {\n                    logger.log(Level.WARNING, \"Could not load image file into media view: \" + fileName, fxImage.getException()); //NON-NLS\n                    return;\n                }\n                fxImageView.setImage(fxImage);\n                borderpane.setCenter(fxImageView);\n\n                SwingUtilities.invokeLater(() -> {\n                    //show the panel after fully loaded\n                    fxPanel.setVisible(true);\n                });\n            }\n        });\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void reset() {\n        Platform.runLater(new Runnable() {\n            @Override\n            public void run() {\n                fxImageView.setImage(null);\n            }\n        });\n    }","id":81430,"modified_method":"public void reset() {\n        Platform.runLater(() -> {\n            fxImageView.setImage(null);\n        });\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * returns supported extensions (each starting with .)\n     * @return \n     */\n    public List<String> getExtensions() {\n        return supportedExtensions;\n    }","id":81431,"modified_method":"/**\n     * returns supported extensions (each starting with .)\n     *\n     * @return\n     */\n    public List<String> getExtensions() {\n        return Collections.unmodifiableList(supportedExtensions);\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Creates new form MediaViewImagePanel\n     */\n    public MediaViewImagePanel() {\n        initComponents();\n        fxInited = org.sleuthkit.autopsy.core.Installer.isJavaFxInited();\n        if (fxInited) {\n            setupFx();\n        }\n        \n        supportedExtensions = new ArrayList<>();\n        //logger.log(Level.INFO, \"Supported image formats by javafx image viewer: \");\n        for (String suffix : ImageIO.getReaderFileSuffixes()) {\n            //logger.log(Level.INFO, \"suffix: \" + suffix);\n            supportedExtensions.add(\".\" + suffix);\n        }\n    }","id":81432,"modified_method":"/**\n     * Creates new form MediaViewImagePanel\n     */\n    public MediaViewImagePanel() {\n        initComponents();\n        fxInited = org.sleuthkit.autopsy.core.Installer.isJavaFxInited();\n        if (fxInited) {\n            Platform.runLater(() -> {\n                fxImageView = new ImageView();\n                borderpane = new BorderPane(fxImageView);\n                borderpane.setBackground(new Background(new BackgroundFill(javafx.scene.paint.Color.BLACK, CornerRadii.EMPTY, Insets.EMPTY)));\n                fxPanel = new JFXPanel();\n                Scene scene = new Scene(borderpane, javafx.scene.paint.Color.BLACK);\n\n                fxImageView.fitWidthProperty().bind(scene.widthProperty());\n                fxImageView.fitHeightProperty().bind(scene.heightProperty());\n                fxPanel.setScene(scene);\n\n                // resizes the image to have width of 100 while preserving the ratio and using\n                // higher quality filtering method; this ImageView is also cached to\n                // improve performance\n                fxImageView.setPreserveRatio(true);\n                fxImageView.setSmooth(true);\n                fxImageView.setCache(true);\n\n                EventQueue.invokeLater(() -> {\n                    add(fxPanel);\n                });\n            });\n        }\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * returns supported mime types\n     * @return \n     */\n    public List<String> getMimeTypes() {\n        return supportedMimes;\n    }","id":81433,"modified_method":"/**\n     * returns supported mime types\n     *\n     * @return\n     */\n    public List<String> getMimeTypes() {\n        return Collections.unmodifiableList(supportedMimes);\n    }","commit_id":"76546045266bda51511e24c389e3926a58446ebb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public String getType() {\n    return ((String) getField(ActivityIndexDefinition.FIELD_TYPE));\n  }","id":81434,"modified_method":"public String getType() {\n    return (String) getField(ActivityIndexDefinition.FIELD_TYPE);\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  public Map<String, String> getDetails() {\n    return this.getNullableField(ActivityIndexDefinition.FIELD_DETAILS);\n  }","id":81435,"modified_method":"public Map<String, String> getDetails() {\n    return this.getField(ActivityIndexDefinition.FIELD_DETAILS);\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  public BatchReport.Component readComponent(int componentRef) {\n    File file = fileStructure.fileFor(FileStructure.Domain.COMPONENT, componentRef);\n    if (file.exists() && file.isFile()) {\n      return ProtobufUtil.readFile(file, BatchReport.Component.PARSER);\n    }\n    return null;\n  }","id":81436,"modified_method":"public BatchReport.Component readComponent(int componentRef) {\n    File file = fileStructure.fileFor(FileStructure.Domain.COMPONENT, componentRef);\n    if (!file.exists() || !file.isFile()) {\n      throw new IllegalStateException(\"Unable to find report for component #\" + componentRef + \". File does not exist: \" + file);\n    }\n    return ProtobufUtil.readFile(file, BatchReport.Component.PARSER);\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_dir_if_does_not_exist() throws Exception {\n    File dir = temp.newFolder();\n\n    initFiles(dir);\n\n    BatchReportReader reader = new BatchReportReader(dir);\n    Metadata readMetadata = reader.readMetadata();\n    assertThat(readMetadata.getAnalysisDate()).isEqualTo(15000000L);\n    assertThat(readMetadata.getDeletedComponentsCount()).isEqualTo(1);\n    assertThat(reader.readComponentIssues(1)).hasSize(1);\n    assertThat(reader.readComponentIssues(200)).isEmpty();\n    assertThat(reader.readComponent(1).getUuid()).isEqualTo(\"UUID_A\");\n    assertThat(reader.readComponent(200)).isNull();\n    Issues deletedComponentIssues = reader.readDeletedComponentIssues(1);\n    assertThat(deletedComponentIssues.getComponentUuid()).isEqualTo(\"compUuid\");\n    assertThat(deletedComponentIssues.getListList()).hasSize(1);\n\n  }","id":81437,"modified_method":"@Test\n  public void create_dir_if_does_not_exist() throws Exception {\n    File dir = temp.newFolder();\n\n    initFiles(dir);\n\n    BatchReportReader reader = new BatchReportReader(dir);\n    Metadata readMetadata = reader.readMetadata();\n    assertThat(readMetadata.getAnalysisDate()).isEqualTo(15000000L);\n    assertThat(readMetadata.getDeletedComponentsCount()).isEqualTo(1);\n    assertThat(reader.readComponentIssues(1)).hasSize(1);\n    assertThat(reader.readComponentIssues(200)).isEmpty();\n    assertThat(reader.readComponent(1).getUuid()).isEqualTo(\"UUID_A\");\n    Issues deletedComponentIssues = reader.readDeletedComponentIssues(1);\n    assertThat(deletedComponentIssues.getComponentUuid()).isEqualTo(\"compUuid\");\n    assertThat(deletedComponentIssues.getListList()).hasSize(1);\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initFiles(File dir) {\n    BatchOutputWriter writer = new BatchOutputWriter(dir);\n\n    BatchReport.Metadata.Builder metadata = BatchReport.Metadata.newBuilder()\n      .setAnalysisDate(15000000L)\n      .setProjectKey(\"PROJECT_A\")\n      .setRootComponentRef(1)\n      .setDeletedComponentsCount(1);\n    writer.writeMetadata(metadata.build());\n\n    BatchReport.Component.Builder component = BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setUuid(\"UUID_A\");\n    writer.writeComponent(component.build());\n\n    BatchReport.Issue issue = BatchReport.Issue.newBuilder()\n      .setUuid(\"ISSUE_A\")\n      .setLine(50)\n      .build();\n\n    writer.writeComponentIssues(1, Arrays.asList(issue));\n\n    writer.writeDeletedComponentIssues(1, \"compUuid\", Arrays.asList(issue));\n  }","id":81438,"modified_method":"private void initFiles(File dir) {\n    BatchReportWriter writer = new BatchReportWriter(dir);\n\n    BatchReport.Metadata.Builder metadata = BatchReport.Metadata.newBuilder()\n      .setAnalysisDate(15000000L)\n      .setProjectKey(\"PROJECT_A\")\n      .setRootComponentRef(1)\n      .setDeletedComponentsCount(1);\n    writer.writeMetadata(metadata.build());\n\n    BatchReport.Component.Builder component = BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setUuid(\"UUID_A\");\n    writer.writeComponent(component.build());\n\n    BatchReport.Issue issue = BatchReport.Issue.newBuilder()\n      .setUuid(\"ISSUE_A\")\n      .setLine(50)\n      .build();\n\n    writer.writeComponentIssues(1, Arrays.asList(issue));\n\n    writer.writeDeletedComponentIssues(1, \"compUuid\", Arrays.asList(issue));\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void recursiveWriteComponent(BatchResource batchResource, BatchOutputWriter writer) {\n    Resource r = batchResource.resource();\n    BatchReport.Component.Builder builder = BatchReport.Component.newBuilder();\n\n    // non-null fields\n    builder.setRef(batchResource.batchId());\n    builder.setType(getType(r));\n\n    // protocol buffers does not accept null values\n\n    String uuid = r.getUuid();\n    if (uuid != null) {\n      builder.setUuid(uuid);\n    }\n    Integer sid = batchResource.snapshotId();\n    if (sid != null) {\n      builder.setSnapshotId(sid);\n    }\n    if (ResourceUtils.isFile(r)) {\n      builder.setIsTest(ResourceUtils.isUnitTestClass(r));\n    }\n    String name = getName(r);\n    if (name != null) {\n      builder.setName(name);\n    }\n    String path = r.getPath();\n    if (path != null) {\n      builder.setPath(path);\n    }\n    String lang = getLanguageKey(r);\n    if (lang != null) {\n      builder.setLanguage(lang);\n    }\n    for (BatchResource child : batchResource.children()) {\n      builder.addChildRefs(child.batchId());\n    }\n    writer.writeComponent(builder.build());\n\n    for (BatchResource child : batchResource.children()) {\n      recursiveWriteComponent(child, writer);\n    }\n  }","id":81439,"modified_method":"private void recursiveWriteComponent(BatchResource batchResource, BatchReportWriter writer) {\n    Resource r = batchResource.resource();\n    BatchReport.Component.Builder builder = BatchReport.Component.newBuilder();\n\n    // non-null fields\n    builder.setRef(batchResource.batchId());\n    builder.setType(getType(r));\n\n    // protocol buffers does not accept null values\n\n    String uuid = r.getUuid();\n    if (uuid != null) {\n      builder.setUuid(uuid);\n    }\n    Integer sid = batchResource.snapshotId();\n    if (sid != null) {\n      builder.setSnapshotId(sid);\n    }\n    if (ResourceUtils.isFile(r)) {\n      builder.setIsTest(ResourceUtils.isUnitTestClass(r));\n    }\n    String name = getName(r);\n    if (name != null) {\n      builder.setName(name);\n    }\n    String path = r.getPath();\n    if (path != null) {\n      builder.setPath(path);\n    }\n    String lang = getLanguageKey(r);\n    if (lang != null) {\n      builder.setLanguage(lang);\n    }\n    for (BatchResource child : batchResource.children()) {\n      builder.addChildRefs(child.batchId());\n    }\n    writer.writeComponent(builder.build());\n\n    for (BatchResource child : batchResource.children()) {\n      recursiveWriteComponent(child, writer);\n    }\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void publish(BatchOutputWriter writer) {\n    BatchResource rootProject = resourceCache.get(reactor.getRoot().getKeyWithBranch());\n    recursiveWriteComponent(rootProject, writer);\n  }","id":81440,"modified_method":"@Override\n  public void publish(BatchReportWriter writer) {\n    BatchResource rootProject = resourceCache.get(reactor.getRoot().getKeyWithBranch());\n    recursiveWriteComponent(rootProject, writer);\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void add_components_to_report() throws Exception {\n    // inputs\n    Project root = new Project(\"foo\").setName(\"Root project\")\n      .setAnalysisDate(DateUtils.parseDate((\"2012-12-12\")));\n    root.setId(1).setUuid(\"PROJECT_UUID\");\n    resourceCache.add(root, null).setSnapshot(new Snapshot().setId(11));\n\n    Project module1 = new Project(\"module1\").setName(\"Module1\");\n    module1.setParent(root);\n    module1.setId(2).setUuid(\"MODULE_UUID\");\n    resourceCache.add(module1, root).setSnapshot(new Snapshot().setId(12));\n\n    Directory dir = Directory.create(\"src\");\n    dir.setEffectiveKey(\"foo:src\");\n    dir.setId(3).setUuid(\"DIR_UUID\");\n    resourceCache.add(dir, module1).setSnapshot(new Snapshot().setId(13));\n\n    org.sonar.api.resources.File file = org.sonar.api.resources.File.create(\"src/Foo.java\", Java.INSTANCE, false);\n    file.setEffectiveKey(\"foo:src/Foo.java\");\n    file.setId(4).setUuid(\"FILE_UUID\");\n    resourceCache.add(file, dir).setSnapshot(new Snapshot().setId(14));\n\n    org.sonar.api.resources.File fileWithoutLang = org.sonar.api.resources.File.create(\"src/make\", null, false);\n    fileWithoutLang.setEffectiveKey(\"foo:src/make\");\n    fileWithoutLang.setId(5).setUuid(\"FILE_WITHOUT_LANG_UUID\");\n    resourceCache.add(fileWithoutLang, dir).setSnapshot(new Snapshot().setId(15));\n\n    org.sonar.api.resources.File testFile = org.sonar.api.resources.File.create(\"test/FooTest.java\", Java.INSTANCE, true);\n    testFile.setEffectiveKey(\"foo:test/FooTest.java\");\n    testFile.setId(6).setUuid(\"TEST_FILE_UUID\");\n    resourceCache.add(testFile, dir).setSnapshot(new Snapshot().setId(16));\n\n    BatchOutputWriter writer = new BatchOutputWriter(temp.newFolder());\n    publisher.publish(writer);\n\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 1)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 2)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 3)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 4)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 5)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 6)).isTrue();\n\n    // no such reference\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 7)).isFalse();\n  }","id":81441,"modified_method":"@Test\n  public void add_components_to_report() throws Exception {\n    // inputs\n    Project root = new Project(\"foo\").setName(\"Root project\")\n      .setAnalysisDate(DateUtils.parseDate((\"2012-12-12\")));\n    root.setId(1).setUuid(\"PROJECT_UUID\");\n    resourceCache.add(root, null).setSnapshot(new Snapshot().setId(11));\n\n    Project module1 = new Project(\"module1\").setName(\"Module1\");\n    module1.setParent(root);\n    module1.setId(2).setUuid(\"MODULE_UUID\");\n    resourceCache.add(module1, root).setSnapshot(new Snapshot().setId(12));\n\n    Directory dir = Directory.create(\"src\");\n    dir.setEffectiveKey(\"foo:src\");\n    dir.setId(3).setUuid(\"DIR_UUID\");\n    resourceCache.add(dir, module1).setSnapshot(new Snapshot().setId(13));\n\n    org.sonar.api.resources.File file = org.sonar.api.resources.File.create(\"src/Foo.java\", Java.INSTANCE, false);\n    file.setEffectiveKey(\"foo:src/Foo.java\");\n    file.setId(4).setUuid(\"FILE_UUID\");\n    resourceCache.add(file, dir).setSnapshot(new Snapshot().setId(14));\n\n    org.sonar.api.resources.File fileWithoutLang = org.sonar.api.resources.File.create(\"src/make\", null, false);\n    fileWithoutLang.setEffectiveKey(\"foo:src/make\");\n    fileWithoutLang.setId(5).setUuid(\"FILE_WITHOUT_LANG_UUID\");\n    resourceCache.add(fileWithoutLang, dir).setSnapshot(new Snapshot().setId(15));\n\n    org.sonar.api.resources.File testFile = org.sonar.api.resources.File.create(\"test/FooTest.java\", Java.INSTANCE, true);\n    testFile.setEffectiveKey(\"foo:test/FooTest.java\");\n    testFile.setId(6).setUuid(\"TEST_FILE_UUID\");\n    resourceCache.add(testFile, dir).setSnapshot(new Snapshot().setId(16));\n\n    BatchReportWriter writer = new BatchReportWriter(temp.newFolder());\n    publisher.publish(writer);\n\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 1)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 2)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 3)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 4)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 5)).isTrue();\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 6)).isTrue();\n\n    // no such reference\n    assertThat(writer.hasComponentData(FileStructure.Domain.COMPONENT, 7)).isFalse();\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private File generateZip() throws IOException {\n    File dir = tempFolder.newDir();\n    BatchOutputWriter writer = new BatchOutputWriter(dir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setAnalysisDate(150000000L)\n      .build());\n    File zip = tempFolder.newFile();\n    ZipUtils.zipDir(dir, zip);\n    return zip;\n  }","id":81442,"modified_method":"private File generateZip() throws IOException {\n    File dir = tempFolder.newDir();\n    BatchReportWriter writer = new BatchReportWriter(dir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setAnalysisDate(150000000L)\n      .build());\n    File zip = tempFolder.newFile();\n    ZipUtils.zipDir(dir, zip);\n    return zip;\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void publish(BatchOutputWriter writer) {\n    Collection<Object> deletedComponentKeys = issueCache.componentKeys();\n    for (BatchResource resource : resourceCache.all()) {\n      String componentKey = resource.resource().getEffectiveKey();\n      Iterable<DefaultIssue> issues = issueCache.byComponent(componentKey);\n      writer.writeComponentIssues(resource.batchId(), Iterables.transform(issues, new Function<DefaultIssue, BatchReport.Issue>() {\n        @Override\n        public BatchReport.Issue apply(DefaultIssue input) {\n          return toReportIssue(input);\n        }\n      }));\n      deletedComponentKeys.remove(componentKey);\n    }\n\n    int count = exportIssuesOfDeletedComponents(deletedComponentKeys, writer);\n\n    exportMetadata(writer, count);\n  }","id":81443,"modified_method":"@Override\n  public void publish(BatchReportWriter writer) {\n    Collection<Object> deletedComponentKeys = issueCache.componentKeys();\n    for (BatchResource resource : resourceCache.all()) {\n      String componentKey = resource.resource().getEffectiveKey();\n      Iterable<DefaultIssue> issues = issueCache.byComponent(componentKey);\n      writer.writeComponentIssues(resource.batchId(), Iterables.transform(issues, new Function<DefaultIssue, BatchReport.Issue>() {\n        @Override\n        public BatchReport.Issue apply(DefaultIssue input) {\n          return toReportIssue(input);\n        }\n      }));\n      deletedComponentKeys.remove(componentKey);\n    }\n\n    int count = exportIssuesOfDeletedComponents(deletedComponentKeys, writer);\n\n    exportMetadata(writer, count);\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private int exportIssuesOfDeletedComponents(Collection<Object> deletedComponentKeys, BatchOutputWriter writer) {\n    int deletedComponentCount = 0;\n    for (Object componentKey : deletedComponentKeys) {\n      deletedComponentCount++;\n      Iterable<DefaultIssue> issues = issueCache.byComponent(componentKey.toString());\n      Iterator<DefaultIssue> iterator = issues.iterator();\n      if (iterator.hasNext()) {\n        String componentUuid = iterator.next().componentUuid();\n        writer.writeDeletedComponentIssues(deletedComponentCount, componentUuid, Iterables.transform(issues, new Function<DefaultIssue, BatchReport.Issue>() {\n          @Override\n          public BatchReport.Issue apply(DefaultIssue input) {\n            return toReportIssue(input);\n          }\n        }));\n      }\n    }\n    return deletedComponentCount;\n  }","id":81444,"modified_method":"private int exportIssuesOfDeletedComponents(Collection<Object> deletedComponentKeys, BatchReportWriter writer) {\n    int deletedComponentCount = 0;\n    for (Object componentKey : deletedComponentKeys) {\n      deletedComponentCount++;\n      Iterable<DefaultIssue> issues = issueCache.byComponent(componentKey.toString());\n      Iterator<DefaultIssue> iterator = issues.iterator();\n      if (iterator.hasNext()) {\n        String componentUuid = iterator.next().componentUuid();\n        writer.writeDeletedComponentIssues(deletedComponentCount, componentUuid, Iterables.transform(issues, new Function<DefaultIssue, BatchReport.Issue>() {\n          @Override\n          public BatchReport.Issue apply(DefaultIssue input) {\n            return toReportIssue(input);\n          }\n        }));\n      }\n    }\n    return deletedComponentCount;\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void exportMetadata(BatchOutputWriter writer, int count) {\n    BatchResource rootProject = resourceCache.get(reactor.getRoot().getKeyWithBranch());\n    BatchReport.Metadata.Builder builder = BatchReport.Metadata.newBuilder()\n      .setAnalysisDate(((Project) rootProject.resource()).getAnalysisDate().getTime())\n      .setProjectKey(((Project) rootProject.resource()).key())\n      .setRootComponentRef(rootProject.batchId())\n      .setDeletedComponentsCount(count);\n    Integer sid = rootProject.snapshotId();\n    if (sid != null) {\n      builder.setSnapshotId(sid);\n    }\n    writer.writeMetadata(builder.build());\n  }","id":81445,"modified_method":"private void exportMetadata(BatchReportWriter writer, int count) {\n    BatchResource rootProject = resourceCache.get(reactor.getRoot().getKeyWithBranch());\n    BatchReport.Metadata.Builder builder = BatchReport.Metadata.newBuilder()\n      .setAnalysisDate(((Project) rootProject.resource()).getAnalysisDate().getTime())\n      .setProjectKey(((Project) rootProject.resource()).key())\n      .setRootComponentRef(rootProject.batchId())\n      .setDeletedComponentsCount(count);\n    Integer sid = rootProject.snapshotId();\n    if (sid != null) {\n      builder.setSnapshotId(sid);\n    }\n    writer.writeMetadata(builder.build());\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void publishIssuesAndMetadata() throws Exception {\n\n    DefaultIssue issue1 = new DefaultIssue();\n    issue1.setKey(\"uuid\");\n    issue1.setSeverity(\"MAJOR\");\n    issue1.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    DefaultIssue issue2 = new DefaultIssue();\n    issue2.setKey(\"uuid2\");\n    issue2.setSeverity(\"MAJOR\");\n    issue2.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    issue2.setLine(2);\n    issue2.setMessage(\"msg\");\n    issue2.setEffortToFix(2d);\n    issue2.setDebt(Duration.create(2));\n    issue2.setResolution(\"FIXED\");\n    issue2.setStatus(\"RESOLVED\");\n    issue2.setChecksum(\"checksum\");\n    issue2.setReporter(\"reporter\");\n    issue2.setAssignee(\"assignee\");\n    issue2.setActionPlanKey(\"action\");\n    issue2.setAuthorLogin(\"author\");\n    issue2.setCurrentChange(new FieldDiffs().setUserLogin(\"foo\"));\n    issue2.setCreationDate(new Date());\n    issue2.setUpdateDate(new Date());\n    issue2.setCloseDate(new Date());\n    issue2.setSelectedAt(1234L);\n    when(issueCache.byComponent(\"foo:src/Foo.php\")).thenReturn(Arrays.asList(issue1, issue2));\n\n    File outputDir = temp.newFolder();\n    BatchOutputWriter writer = new BatchOutputWriter(outputDir);\n\n    publisher.publish(writer);\n\n    BatchReportReader reader = new BatchReportReader(outputDir);\n    Metadata metadata = reader.readMetadata();\n    assertThat(metadata.getAnalysisDate()).isEqualTo(1234567L);\n    assertThat(metadata.getProjectKey()).isEqualTo(\"foo\");\n    assertThat(metadata.getDeletedComponentsCount()).isEqualTo(0);\n    assertThat(metadata.getSnapshotId()).isEqualTo(2);\n\n    assertThat(reader.readComponentIssues(1)).hasSize(0);\n    assertThat(reader.readComponentIssues(2)).hasSize(2);\n\n  }","id":81446,"modified_method":"@Test\n  public void publishIssuesAndMetadata() throws Exception {\n\n    DefaultIssue issue1 = new DefaultIssue();\n    issue1.setKey(\"uuid\");\n    issue1.setSeverity(\"MAJOR\");\n    issue1.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    DefaultIssue issue2 = new DefaultIssue();\n    issue2.setKey(\"uuid2\");\n    issue2.setSeverity(\"MAJOR\");\n    issue2.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    issue2.setLine(2);\n    issue2.setMessage(\"msg\");\n    issue2.setEffortToFix(2d);\n    issue2.setDebt(Duration.create(2));\n    issue2.setResolution(\"FIXED\");\n    issue2.setStatus(\"RESOLVED\");\n    issue2.setChecksum(\"checksum\");\n    issue2.setReporter(\"reporter\");\n    issue2.setAssignee(\"assignee\");\n    issue2.setActionPlanKey(\"action\");\n    issue2.setAuthorLogin(\"author\");\n    issue2.setCurrentChange(new FieldDiffs().setUserLogin(\"foo\"));\n    issue2.setCreationDate(new Date());\n    issue2.setUpdateDate(new Date());\n    issue2.setCloseDate(new Date());\n    issue2.setSelectedAt(1234L);\n    when(issueCache.byComponent(\"foo:src/Foo.php\")).thenReturn(Arrays.asList(issue1, issue2));\n\n    File outputDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(outputDir);\n\n    publisher.publish(writer);\n\n    BatchReportReader reader = new BatchReportReader(outputDir);\n    Metadata metadata = reader.readMetadata();\n    assertThat(metadata.getAnalysisDate()).isEqualTo(1234567L);\n    assertThat(metadata.getProjectKey()).isEqualTo(\"foo\");\n    assertThat(metadata.getDeletedComponentsCount()).isEqualTo(0);\n    assertThat(metadata.getSnapshotId()).isEqualTo(2);\n\n    assertThat(reader.readComponentIssues(1)).hasSize(0);\n    assertThat(reader.readComponentIssues(2)).hasSize(2);\n\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void publishIssuesOfDeletedComponents() throws Exception {\n\n    DefaultIssue issue1 = new DefaultIssue();\n    issue1.setKey(\"uuid\");\n    issue1.setComponentUuid(\"deletedUuid\");\n    issue1.setSeverity(\"MAJOR\");\n    issue1.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    DefaultIssue issue2 = new DefaultIssue();\n    issue2.setKey(\"uuid2\");\n    issue2.setComponentUuid(\"deletedUuid\");\n    issue2.setSeverity(\"MAJOR\");\n    issue2.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    issue2.setLine(2);\n    issue2.setMessage(\"msg\");\n    issue2.setEffortToFix(2d);\n    issue2.setDebt(Duration.create(2));\n    issue2.setResolution(\"FIXED\");\n    issue2.setStatus(\"RESOLVED\");\n    issue2.setChecksum(\"checksum\");\n    issue2.setReporter(\"reporter\");\n    issue2.setAssignee(\"assignee\");\n    issue2.setActionPlanKey(\"action\");\n    issue2.setAuthorLogin(\"author\");\n    issue2.setCurrentChange(new FieldDiffs().setUserLogin(\"foo\"));\n    issue2.setCreationDate(new Date());\n    issue2.setUpdateDate(new Date());\n    issue2.setCloseDate(new Date());\n    issue2.setSelectedAt(1234L);\n\n    when(issueCache.byComponent(\"foo:deleted.php\")).thenReturn(Arrays.asList(issue1, issue2));\n\n    when(issueCache.componentKeys()).thenReturn(Arrays.<Object>asList(\"foo:deleted.php\"));\n\n    File outputDir = temp.newFolder();\n    BatchOutputWriter writer = new BatchOutputWriter(outputDir);\n\n    publisher.publish(writer);\n\n    BatchReportReader reader = new BatchReportReader(outputDir);\n    Metadata metadata = reader.readMetadata();\n    assertThat(metadata.getDeletedComponentsCount()).isEqualTo(1);\n\n    assertThat(reader.readComponentIssues(1)).hasSize(0);\n    assertThat(reader.readComponentIssues(2)).hasSize(0);\n    assertThat(reader.readDeletedComponentIssues(1).getComponentUuid()).isEqualTo(\"deletedUuid\");\n    assertThat(reader.readDeletedComponentIssues(1).getListList()).hasSize(2);\n\n  }","id":81447,"modified_method":"@Test\n  public void publishIssuesOfDeletedComponents() throws Exception {\n\n    DefaultIssue issue1 = new DefaultIssue();\n    issue1.setKey(\"uuid\");\n    issue1.setComponentUuid(\"deletedUuid\");\n    issue1.setSeverity(\"MAJOR\");\n    issue1.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    DefaultIssue issue2 = new DefaultIssue();\n    issue2.setKey(\"uuid2\");\n    issue2.setComponentUuid(\"deletedUuid\");\n    issue2.setSeverity(\"MAJOR\");\n    issue2.setRuleKey(RuleKey.of(\"repo\", \"rule\"));\n    issue2.setLine(2);\n    issue2.setMessage(\"msg\");\n    issue2.setEffortToFix(2d);\n    issue2.setDebt(Duration.create(2));\n    issue2.setResolution(\"FIXED\");\n    issue2.setStatus(\"RESOLVED\");\n    issue2.setChecksum(\"checksum\");\n    issue2.setReporter(\"reporter\");\n    issue2.setAssignee(\"assignee\");\n    issue2.setActionPlanKey(\"action\");\n    issue2.setAuthorLogin(\"author\");\n    issue2.setCurrentChange(new FieldDiffs().setUserLogin(\"foo\"));\n    issue2.setCreationDate(new Date());\n    issue2.setUpdateDate(new Date());\n    issue2.setCloseDate(new Date());\n    issue2.setSelectedAt(1234L);\n\n    when(issueCache.byComponent(\"foo:deleted.php\")).thenReturn(Arrays.asList(issue1, issue2));\n\n    when(issueCache.componentKeys()).thenReturn(Arrays.<Object>asList(\"foo:deleted.php\"));\n\n    File outputDir = temp.newFolder();\n    BatchReportWriter writer = new BatchReportWriter(outputDir);\n\n    publisher.publish(writer);\n\n    BatchReportReader reader = new BatchReportReader(outputDir);\n    Metadata metadata = reader.readMetadata();\n    assertThat(metadata.getDeletedComponentsCount()).isEqualTo(1);\n\n    assertThat(reader.readComponentIssues(1)).hasSize(0);\n    assertThat(reader.readComponentIssues(2)).hasSize(0);\n    assertThat(reader.readDeletedComponentIssues(1).getComponentUuid()).isEqualTo(\"deletedUuid\");\n    assertThat(reader.readDeletedComponentIssues(1).getListList()).hasSize(2);\n\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void recursivelyProcessComponent(ComputationContext context, int componentRef) {\n    BatchReportReader reportReader = context.getReportReader();\n    BatchReport.Component component = reportReader.readComponent(componentRef);\n    if (component != null) {\n      List<BatchReport.Issue> issues = reportReader.readComponentIssues(componentRef);\n      issueComputation.processComponentIssues(context, component.getUuid(), issues);\n      for (Integer childRef : component.getChildRefsList()) {\n        recursivelyProcessComponent(context, childRef);\n      }\n    }\n  }","id":81448,"modified_method":"private void recursivelyProcessComponent(ComputationContext context, int componentRef) {\n    BatchReportReader reportReader = context.getReportReader();\n    BatchReport.Component component = reportReader.readComponent(componentRef);\n    List<BatchReport.Issue> issues = reportReader.readComponentIssues(componentRef);\n    issueComputation.processComponentIssues(context, component.getUuid(), issues);\n    for (Integer childRef : component.getChildRefsList()) {\n      recursivelyProcessComponent(context, childRef);\n    }\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private File generateReport() throws IOException {\n    File dir = temp.newFolder();\n    // project and 2 files\n    BatchOutputWriter writer = new BatchOutputWriter(dir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setAnalysisDate(150000000L)\n      .setDeletedComponentsCount(1)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setUuid(\"PROJECT_UUID\")\n      .addChildRefs(2)\n      .addChildRefs(3)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"FILE1_UUID\")\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"FILE2_UUID\")\n      .build());\n\n    // deleted components\n    writer.writeDeletedComponentIssues(1, \"DELETED_UUID\", ISSUES_ON_DELETED_COMPONENT);\n    return dir;\n  }","id":81449,"modified_method":"private File generateReport() throws IOException {\n    File dir = temp.newFolder();\n    // project and 2 files\n    BatchReportWriter writer = new BatchReportWriter(dir);\n    writer.writeMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setProjectKey(\"PROJECT_KEY\")\n      .setAnalysisDate(150000000L)\n      .setDeletedComponentsCount(1)\n      .build());\n\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setUuid(\"PROJECT_UUID\")\n      .addChildRefs(2)\n      .addChildRefs(3)\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"FILE1_UUID\")\n      .build());\n    writer.writeComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.FILE)\n      .setUuid(\"FILE2_UUID\")\n      .build());\n\n    // deleted components\n    writer.writeDeletedComponentIssues(1, \"DELETED_UUID\", ISSUES_ON_DELETED_COMPONENT);\n    return dir;\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private File prepareReport() {\n    try {\n      long startTime = System.currentTimeMillis();\n      File reportDir = temp.newDir(\"batch-report\");\n      BatchOutputWriter writer = new BatchOutputWriter(reportDir);\n      for (ReportPublisher publisher : publishers) {\n        publisher.publish(writer);\n      }\n      long stopTime = System.currentTimeMillis();\n      LOG.info(\"Analysis reports generated in \" + (stopTime - startTime) + \"ms, dir size=\" + FileUtils.byteCountToDisplaySize(FileUtils.sizeOfDirectory(reportDir)));\n\n      startTime = System.currentTimeMillis();\n      File reportZip = temp.newFile(\"batch-report\", \".zip\");\n      ZipUtils.zipDir(reportDir, reportZip);\n      FileUtils.deleteDirectory(reportDir);\n      stopTime = System.currentTimeMillis();\n      LOG.info(\"Analysis reports compressed in \" + (stopTime - startTime) + \"ms, zip size=\" + FileUtils.byteCountToDisplaySize(FileUtils.sizeOf(reportZip)));\n      return reportZip;\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Unable to prepare batch report\", e);\n    }\n  }","id":81450,"modified_method":"private File prepareReport() {\n    try {\n      long startTime = System.currentTimeMillis();\n      File reportDir = temp.newDir(\"batch-report\");\n      BatchReportWriter writer = new BatchReportWriter(reportDir);\n      for (ReportPublisher publisher : publishers) {\n        publisher.publish(writer);\n      }\n      long stopTime = System.currentTimeMillis();\n      LOG.info(\"Analysis reports generated in \" + (stopTime - startTime) + \"ms, dir size=\" + FileUtils.byteCountToDisplaySize(FileUtils.sizeOfDirectory(reportDir)));\n\n      startTime = System.currentTimeMillis();\n      File reportZip = temp.newFile(\"batch-report\", \".zip\");\n      ZipUtils.zipDir(reportDir, reportZip);\n      FileUtils.deleteDirectory(reportDir);\n      stopTime = System.currentTimeMillis();\n      LOG.info(\"Analysis reports compressed in \" + (stopTime - startTime) + \"ms, zip size=\" + FileUtils.byteCountToDisplaySize(FileUtils.sizeOf(reportZip)));\n      return reportZip;\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Unable to prepare batch report\", e);\n    }\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QProfileActivityQuery setQprofileKey(@Nullable String qprofileKey) {\n    addDataOrFilter(\"profileKey\", qprofileKey);\n    return this;\n  }","id":81451,"modified_method":"public QProfileActivityQuery setQprofileKey(@Nullable String qprofileKey) {\n    if (qprofileKey != null) {\n      addDataOrFilter(\"profileKey\", qprofileKey);\n    }\n    return this;\n  }","commit_id":"33e7b484acb9b0cda2e638dd5356b5e33c0ec1b4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@NotNull\n  protected S getInitialSettings() {\n    return myInitialSettings;\n  }","id":81452,"modified_method":"@NotNull\n  public S getInitialSettings() {\n    return myInitialSettings;\n  }","commit_id":"33a7e6cccbf805f3678adea2f8c606301ae29fd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected String applyExtraSettings(@NotNull GradleProjectSettings settings) {\n    String gradleHomePath = myGradleHomePathField.getText();\n    if (myGradleHomeModifiedByUser) {\n      if (StringUtil.isEmpty(gradleHomePath)) {\n        settings.setGradleHome(null);\n      }\n      else {\n        settings.setGradleHome(gradleHomePath);\n        GradleUtil.storeLastUsedGradleHome(gradleHomePath);\n      }\n    }\n    else {\n      settings.setGradleHome(getInitialSettings().getGradleHome());\n    }\n\n    if (myUseLocalDistributionButton.isSelected()) {\n      if (StringUtil.isEmpty(gradleHomePath)) {\n        myGradleHomeSettingType = LocationSettingType.UNKNOWN;\n      }\n      else if (!myInstallationManager.isGradleSdkHome(new File(gradleHomePath))) {\n        myGradleHomeSettingType = LocationSettingType.EXPLICIT_INCORRECT;\n        new DelayedBalloonInfo(MessageType.ERROR, myGradleHomeSettingType, 0).run();\n        return GradleBundle.message(\"gradle.home.setting.type.explicit.incorrect\");\n      }\n    }\n    settings.setPreferLocalInstallationToWrapper(myUseLocalDistributionButton.isSelected());\n    return null;\n  }","id":81453,"modified_method":"@Override\n  @Nullable\n  protected String applyExtraSettings(@NotNull GradleProjectSettings settings) {\n    String gradleHomePath = myGradleHomePathField.getText();\n    if (myGradleHomeModifiedByUser) {\n      if (StringUtil.isEmpty(gradleHomePath)) {\n        settings.setGradleHome(null);\n      }\n      else {\n        settings.setGradleHome(gradleHomePath);\n        GradleUtil.storeLastUsedGradleHome(gradleHomePath);\n      }\n    }\n    else {\n      settings.setGradleHome(getInitialSettings().getGradleHome());\n    }\n\n    if (myUseLocalDistributionButton.isSelected()) {\n      if (StringUtil.isEmpty(gradleHomePath)) {\n        myGradleHomeSettingType = LocationSettingType.UNKNOWN;\n      }\n      else if (!myInstallationManager.isGradleSdkHome(new File(gradleHomePath))) {\n        myGradleHomeSettingType = LocationSettingType.EXPLICIT_INCORRECT;\n        new DelayedBalloonInfo(MessageType.ERROR, myGradleHomeSettingType, 0).run();\n        return GradleBundle.message(\"gradle.home.setting.type.explicit.incorrect\", gradleHomePath);\n      }\n    }\n    settings.setPreferLocalInstallationToWrapper(myUseLocalDistributionButton.isSelected());\n    return null;\n  }","commit_id":"33a7e6cccbf805f3678adea2f8c606301ae29fd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Tries to parse what gradle version should be used with gradle wrapper for the gradle project located at the given path. \n   *\n   * @param gradleProjectPath  target gradle project path\n   * @return gradle version should be used with gradle wrapper for the gradle project located at the given path\n   *                           if any; <code>null<\/code> otherwise\n   */\n  @Nullable\n  public static String getWrapperDistribution(@Nullable String gradleProjectPath) {\n    if (gradleProjectPath == null) {\n      return null;\n    }\n    File file = new File(gradleProjectPath);\n    if (!file.isFile()) {\n      return null;\n    }\n\n    File gradleDir = new File(file.getParentFile(), \"gradle\");\n    if (!gradleDir.isDirectory()) {\n      return null;\n    }\n\n    File wrapperDir = new File(gradleDir, \"wrapper\");\n    if (!wrapperDir.isDirectory()) {\n      return null;\n    }\n\n    File[] candidates = wrapperDir.listFiles(new FileFilter() {\n      @Override\n      public boolean accept(File candidate) {\n        return candidate.isFile() && candidate.getName().endsWith(\".properties\");\n      }\n    });\n    if (candidates == null) {\n      GradleLog.LOG.warn(\"No *.properties file is found at the gradle wrapper directory \" + wrapperDir.getAbsolutePath());\n      return null;\n    }\n    else if (candidates.length != 1) {\n      GradleLog.LOG.warn(String.format(\n        \"%d *.properties files instead of one have been found at the wrapper directory (%s): %s\",\n        candidates.length, wrapperDir.getAbsolutePath(), Arrays.toString(candidates)\n      ));\n      return null;\n    }\n\n    Properties props = new Properties();\n    BufferedReader reader = null;\n    try {\n      //noinspection IOResourceOpenedButNotSafelyClosed\n      reader = new BufferedReader(new FileReader(candidates[0]));\n      props.load(reader);\n      String distribution = props.getProperty(WRAPPER_VERSION_PROPERTY_KEY);\n      if (StringUtil.isEmpty(distribution)) {\n        return null;\n      }\n      String shortName = StringUtil.getShortName(distribution, '/');\n      return StringUtil.trimEnd(shortName, \".zip\");\n    }\n    catch (IOException e) {\n      GradleLog.LOG.warn(\n        String.format(\"I/O exception on reading gradle wrapper properties file at '%s'\", candidates[0].getAbsolutePath()),\n        e\n      );\n    }\n    finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        }\n        catch (IOException e) {\n          // Ignore\n        }\n      }\n    }\n    return null;\n  }","id":81454,"modified_method":"/**\n   * Tries to parse what gradle version should be used with gradle wrapper for the gradle project located at the given path. \n   *\n   * @param gradleProjectPath  target gradle project config's (*.gradle) path or config file's directory path.\n   * @return                   gradle version should be used with gradle wrapper for the gradle project located at the given path\n   *                           if any; <code>null<\/code> otherwise\n   */\n  @Nullable\n  public static String getWrapperDistribution(@Nullable String gradleProjectPath) {\n    if (gradleProjectPath == null) {\n      return null;\n    }\n    File file = new File(gradleProjectPath);\n\n    // There is a possible case that given path points to a gradle script (*.gradle) but it's also possible that\n    // it references script's directory. We want to provide flexibility here.\n    File gradleDir;\n    if (file.isFile()) {\n      gradleDir = new File(file.getParentFile(), \"gradle\");\n    }\n    else {\n      gradleDir = file;\n    }\n    if (!gradleDir.isDirectory()) {\n      return null;\n    }\n\n    File wrapperDir = new File(gradleDir, \"wrapper\");\n    if (!wrapperDir.isDirectory()) {\n      return null;\n    }\n\n    File[] candidates = wrapperDir.listFiles(new FileFilter() {\n      @Override\n      public boolean accept(File candidate) {\n        return candidate.isFile() && candidate.getName().endsWith(\".properties\");\n      }\n    });\n    if (candidates == null) {\n      GradleLog.LOG.warn(\"No *.properties file is found at the gradle wrapper directory \" + wrapperDir.getAbsolutePath());\n      return null;\n    }\n    else if (candidates.length != 1) {\n      GradleLog.LOG.warn(String.format(\n        \"%d *.properties files instead of one have been found at the wrapper directory (%s): %s\",\n        candidates.length, wrapperDir.getAbsolutePath(), Arrays.toString(candidates)\n      ));\n      return null;\n    }\n\n    Properties props = new Properties();\n    BufferedReader reader = null;\n    try {\n      //noinspection IOResourceOpenedButNotSafelyClosed\n      reader = new BufferedReader(new FileReader(candidates[0]));\n      props.load(reader);\n      String distribution = props.getProperty(WRAPPER_VERSION_PROPERTY_KEY);\n      if (StringUtil.isEmpty(distribution)) {\n        return null;\n      }\n      String shortName = StringUtil.getShortName(distribution, '/');\n      return StringUtil.trimEnd(shortName, \".zip\");\n    }\n    catch (IOException e) {\n      GradleLog.LOG.warn(\n        String.format(\"I/O exception on reading gradle wrapper properties file at '%s'\", candidates[0].getAbsolutePath()),\n        e\n      );\n    }\n    finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        }\n        catch (IOException e) {\n          // Ignore\n        }\n      }\n    }\n    return null;\n  }","commit_id":"33a7e6cccbf805f3678adea2f8c606301ae29fd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PaintAwarePanel() {\n  }","id":81455,"modified_method":"public PaintAwarePanel() {\n    this(new GridBagLayout());\n  }","commit_id":"33a7e6cccbf805f3678adea2f8c606301ae29fd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void should_create_database() throws IOException, SQLException {\n    setupData(\"should_create_database\");\n\n    when(serverFileSystem.getTempDir()).thenReturn(temporaryFolder.getRoot());\n\n    byte[] database = localDatabaseFactory.createDatabaseForDryRun(123L);\n    dataSource = createDatabase(database);\n\n    assertThat(rowCount(\"metrics\")).isEqualTo(2);\n    assertThat(rowCount(\"projects\")).isZero();\n  }","id":81456,"modified_method":"@Test\n  public void should_create_database() throws IOException, SQLException {\n    setupData(\"should_create_database\");\n\n    when(serverFileSystem.getTempDir()).thenReturn(temporaryFolder.getRoot());\n\n    byte[] database = localDatabaseFactory.createDatabaseForDryRun(null);\n    dataSource = createDatabase(database);\n\n    assertThat(rowCount(\"metrics\")).isEqualTo(2);\n    assertThat(rowCount(\"projects\")).isZero();\n  }","commit_id":"6578ee0c423dc248adf62319d22f6a6b647f00df","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean isIgnored(Resource resource) {\n    if (ResourceUtils.isFile(resource)) {\n      return isIgnoredFileResource(resource);\n    }\n    return false;\n  }","id":81457,"modified_method":"public boolean isIgnored(Resource resource) {\n    if (ResourceUtils.isFile(resource)) {\n      PathPattern[] inclusionPatterns = (ResourceUtils.isUnitTestClass(resource) ? testInclusions : sourceInclusions);\n      if (isIgnoredByInclusions(resource, inclusionPatterns)) {\n        return true;\n      }\n      PathPattern[] exclusionPatterns = (ResourceUtils.isUnitTestClass(resource) ? testExclusions : sourceExclusions);\n      return isIgnoredByExclusions(resource, exclusionPatterns);\n    }\n    return false;\n  }","commit_id":"6578ee0c423dc248adf62319d22f6a6b647f00df","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private RuntimeException handleHttpException(String uri, HttpDownloader.HttpException he) {\n    if (he.getResponseCode() == 401) {\n      return new SonarException(String.format(getMessageWhenNotAuthorized(), CoreProperties.LOGIN, CoreProperties.PASSWORD));\n    }\n    return new SonarException(String.format(\"Fail to execute request [code=%s, url=%s]\", he.getResponseCode(), he.getUri()), he);\n  }","id":81458,"modified_method":"private RuntimeException handleHttpException(HttpDownloader.HttpException he) {\n    if (he.getResponseCode() == 401) {\n      return new SonarException(String.format(getMessageWhenNotAuthorized(), CoreProperties.LOGIN, CoreProperties.PASSWORD));\n    }\n    return new SonarException(String.format(\"Fail to execute request [code=%s, url=%s]\", he.getResponseCode(), he.getUri()), he);\n  }","commit_id":"6578ee0c423dc248adf62319d22f6a6b647f00df","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String request(String pathStartingWithSlash, boolean wrapHttpException) {\n    InputSupplier<InputStream> inputSupplier = doRequest(pathStartingWithSlash);\n    try {\n      return IOUtils.toString(inputSupplier.getInput(), \"UTF-8\");\n    } catch (HttpDownloader.HttpException e) {\n      throw (wrapHttpException ? handleHttpException(pathStartingWithSlash, e) : e);\n    } catch (IOException e) {\n      throw new SonarException(String.format(\"Unable to request: %s\", pathStartingWithSlash), e);\n    }\n  }","id":81459,"modified_method":"public String request(String pathStartingWithSlash, boolean wrapHttpException) {\n    InputSupplier<InputStream> inputSupplier = doRequest(pathStartingWithSlash);\n    try {\n      return IOUtils.toString(inputSupplier.getInput(), \"UTF-8\");\n    } catch (HttpDownloader.HttpException e) {\n      throw (wrapHttpException ? handleHttpException(e) : e);\n    } catch (IOException e) {\n      throw new SonarException(String.format(\"Unable to request: %s\", pathStartingWithSlash), e);\n    }\n  }","commit_id":"6578ee0c423dc248adf62319d22f6a6b647f00df","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void download(String pathStartingWithSlash, File toFile) {\n    try {\n      InputSupplier<InputStream> inputSupplier = doRequest(pathStartingWithSlash);\n      Files.copy(inputSupplier, toFile);\n    } catch (HttpDownloader.HttpException he) {\n      throw handleHttpException(pathStartingWithSlash, he);\n    } catch (IOException e) {\n      throw new SonarException(String.format(\"Unable to download '%s' to: %s\", pathStartingWithSlash, toFile), e);\n    }\n  }","id":81460,"modified_method":"public void download(String pathStartingWithSlash, File toFile) {\n    try {\n      InputSupplier<InputStream> inputSupplier = doRequest(pathStartingWithSlash);\n      Files.copy(inputSupplier, toFile);\n    } catch (HttpDownloader.HttpException he) {\n      throw handleHttpException(he);\n    } catch (IOException e) {\n      throw new SonarException(String.format(\"Unable to download '%s' to: %s\", pathStartingWithSlash, toFile), e);\n    }\n  }","commit_id":"6578ee0c423dc248adf62319d22f6a6b647f00df","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n    public void shouldNotAllowDataAccess() throws Exception\n    {\n        // Given\n        startServerWithConfiguredUser();\n\n        // When & then\n        assertAuthorizationRequired( \"POST\", \"db/data/node\", RawPayload.quotedJson( \"{'name':'jake'}\" ), 201 );\n        assertAuthorizationRequired( \"GET\",  \"db/data/node/1234\", 404 );\n        assertAuthorizationRequired( \"POST\", \"db/data/transaction/commit\", RawPayload.quotedJson(\n                \"{'statements':[{'statement':'MATCH (n) RETURN n'}]}\" ), 200 );\n\n        assertEquals(200, HTTP.GET( server.baseUri().resolve( \"browser\" ).toString() ).status());\n        assertEquals(200, HTTP.GET( server.baseUri().resolve( \"\" ).toString() ).status() );\n    }","id":81461,"modified_method":"@Test\n    public void shouldNotAllowDataAccess() throws Exception\n    {\n        // Given\n        startServerWithConfiguredUser();\n\n        // When & then\n        assertAuthorizationRequired( \"POST\", \"db/data/node\", RawPayload.quotedJson( \"{'name':'jake'}\" ), 201 );\n        assertAuthorizationRequired( \"GET\",  \"db/data/node/1234\", 404 );\n        assertAuthorizationRequired( \"POST\", \"db/data/transaction/commit\", RawPayload.quotedJson(\n                \"{'statements':[{'statement':'MATCH (n) RETURN n'}]}\" ), 200 );\n\n        assertEquals(200, HTTP.GET( server.baseUri().resolve( \"\" ).toString() ).status() );\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldWhitelistBrowser() throws Exception\n    {\n        // Given\n        server = CommunityServerBuilder.server().withProperty( ServerSettings.auth_enabled.name(), \"true\" ).build();\n\n        // When\n        server.start();\n\n        // Then I should be able to access the browser\n        HTTP.Response response = HTTP.GET( server.baseUri().resolve( \"browser/index.html\" ).toString() );\n        assertThat( response.status(), equalTo( 200 ) );\n    }","id":81462,"modified_method":"@Test\n    public void shouldWhitelistBrowser() throws Exception\n    {\n        // Given\n        assumeTrue( browserIsLoaded() );\n        server = CommunityServerBuilder.server().withProperty( ServerSettings.auth_enabled.name(), \"true\" ).build();\n\n        // When\n        server.start();\n\n        // Then I should be able to access the browser\n        HTTP.Response response = HTTP.GET( server.baseUri().resolve( \"browser/index.html\" ).toString() );\n        assertThat( response.status(), equalTo( 200 ) );\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotWhitelistDB() throws Exception\n    {\n        // Given\n        server = CommunityServerBuilder.server().withProperty( ServerSettings.auth_enabled.name(), \"true\" ).build();\n\n        // When\n        server.start();\n\n        // Then I should get a unauthorized response for access to the DB\n        HTTP.Response response = HTTP.GET( server.baseUri().resolve( \"db/data\" ).toString() );\n        assertThat( response.status(), equalTo( 401 ) );\n    }","id":81463,"modified_method":"@Test\n    public void shouldNotWhitelistDB() throws Exception\n    {\n        // Given\n        server = CommunityServerBuilder.server().withProperty( ServerSettings.auth_enabled.name(), \"true\" ).build();\n\n        // When\n        server.start();\n\n        // Then I should get a unauthorized response for access to the DB\n        HTTP.Response response = HTTP.GET(HTTP.GET( server.baseUri().resolve( \"db/data\" ).toString()).location() );\n        assertThat( response.status(), equalTo( 401 ) );\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testMyExtension() throws Exception\n    {\n        // Given\n        try ( ServerControls server = getServerBuilder()\n                .withExtension( \"/myExtension\", MyUnmanagedExtension.class )\n                .newServer() )\n        {\n            // When\n            HTTP.Response response = HTTP.GET( server.httpURI().resolve( \"myExtension\" ).toString() );\n\n            // Then\n            assertEquals( 200, response.status() );\n        }\n    }","id":81464,"modified_method":"@Test\n    public void testMyExtension() throws Exception\n    {\n        // Given\n        try ( ServerControls server = getServerBuilder()\n                .withExtension( \"/myExtension\", MyUnmanagedExtension.class )\n                .newServer() )\n        {\n            // When\n            HTTP.Response response = HTTP.GET(\n                    HTTP.GET( server.httpURI().resolve( \"myExtension\" ).toString() ).location() );\n\n            // Then\n            assertEquals( 200, response.status() );\n        }\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testMyExtension() throws Exception\n    {\n        // Given\n        try ( ServerControls server = getServerBuilder()\n                .withExtension( \"/myExtension\", MyUnmanagedExtension.class )\n                .newServer() )\n        {\n            // When\n            HTTP.Response response = HTTP.GET( server.httpURI().resolve( \"myExtension\" ).toString() );\n\n            // Then\n            assertEquals( 200, response.status() );\n        }\n    }","id":81465,"modified_method":"@Test\n    public void testMyExtension() throws Exception\n    {\n        // Given\n        try ( ServerControls server = getServerBuilder()\n                .withExtension( \"/myExtension\", MyUnmanagedExtension.class )\n                .newServer() )\n        {\n            // When\n            HTTP.Response response = HTTP.GET(\n                    HTTP.GET( server.httpURI().resolve( \"myExtension\" ).toString() ).location() );\n\n            // Then\n            assertEquals( 200, response.status() );\n        }\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRedirectRootToWebadmin() throws Exception\n    {\n        assertFalse( server().baseUri()\n                .toString()\n                .contains( \"browser\" ) );\n        JaxRsResponse response = RestRequest.req().get( server().baseUri().toString(), MediaType.TEXT_HTML_TYPE );\n        assertThat( response.getStatus(), is( 200 ) );\n        assertThat( response.getEntity(), containsString( \"Neo4j\" ) );\n    }","id":81466,"modified_method":"@Test\n    public void shouldRedirectRootToWebadmin() throws Exception\n    {\n        assertFalse( server().baseUri()\n                .toString()\n                .contains( \"browser\" ) );\n\n        HTTP.Response res = HTTP.withHeaders( HttpHeaders.ACCEPT, MediaType.TEXT_HTML ).GET( server().baseUri().toString() );\n        assertThat( res.header( \"Location\" ), containsString( \"browser\") );\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldDisallowDirectoryListings() throws Exception\n    {\n        // Given\n        server = CommunityServerBuilder.server().build();\n        server.start();\n\n        // When\n        HTTP.Response okResource = HTTP.GET( server.baseUri().resolve( \"/browser/content/help/create.html\" ).toString() );\n        HTTP.Response illegalResource = HTTP.GET( server.baseUri().resolve( \"/browser/content/help/\" ).toString() );\n\n        // Then\n        // Depends on specific resources exposed by the browser module; if this test starts to fail,\n        // check whether the structure of the browser module has changed and adjust accordingly.\n        assertEquals( 200, okResource.status() );\n        assertEquals( 403, illegalResource.status() );\n    }","id":81467,"modified_method":"@Test\n    public void shouldDisallowDirectoryListings() throws Exception\n    {\n        // Given\n        server = CommunityServerBuilder.server().build();\n        server.start();\n\n        // When\n        HTTP.Response okResource = HTTP.GET( server.baseUri().resolve( \"/webadmin/index.html\" ).toString() );\n        HTTP.Response illegalResource = HTTP.GET( server.baseUri().resolve( \"/webadmin/css/\" ).toString() );\n\n        // Then\n        // Depends on specific resources exposed by the browser module; if this test starts to fail,\n        // check whether the structure of the browser module has changed and adjust accordingly.\n        assertEquals( 200, okResource.status() );\n        assertEquals( 403, illegalResource.status() );\n    }","commit_id":"ad56ca12c5e61433e25f25fd27c729361453e599","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void zoomToFit(final BoundingRect rect) {\n        if(!rect.isEmpty()) {\n            SVGElement svg = getSVGElement().cast();\n            final int svgWidth = svg.getParentElement().getOffsetWidth(); \n            final int svgHeight = svg.getParentElement().getOffsetHeight();\n            \n            final double scale = Math.min(svgWidth/(double)rect.getWidth(), svgHeight/(double)rect.getHeight());\n            \n            double svgCenterX = svgWidth/2;\n            double svgCenterY = svgHeight/2;\n            \n            double translateX = (svgCenterX - rect.getCenterX());\n            double translateY = (svgCenterY - rect.getCenterY());\n            \n            \n            SVGMatrix transform = svg.createSVGMatrix()\n                .translate(translateX, translateY)\n                .translate(-rect.getCenterX()*(scale-1), -rect.getCenterY()*(scale-1)) \n                .scale(scale);\n                       \n            String transformVal = ((TopologyViewImpl)this).matrixTransform(transform);\n            \n            D3.d3().select(getSVGViewPort()).transition().duration(2000).attr(\"transform\", transformVal).each(\"end\", new AnonymousFunc() {\n                \n                @Override\n                public void call() {\n                    m_presenter.onScaleUpdate(scale);\n                }\n            });\n        }\n    }","id":81468,"modified_method":"public SVGMatrix calculateZoomToFit(final BoundingRect rect) {\n        SVGElement svg = getSVGElement().cast();\n        final int svgWidth = svg.getParentElement().getOffsetWidth(); \n        final int svgHeight = svg.getParentElement().getOffsetHeight();\n        \n        final double scale = Math.min(svgWidth/(double)rect.getWidth(), svgHeight/(double)rect.getHeight());\n        \n        double svgCenterX = svgWidth/2;\n        double svgCenterY = svgHeight/2;\n        \n        double translateX = (svgCenterX - rect.getCenterX());\n        double translateY = (svgCenterY - rect.getCenterY());\n        \n        \n        SVGMatrix transform = svg.createSVGMatrix()\n            .translate(translateX, translateY)\n            .translate(-rect.getCenterX()*(scale-1), -rect.getCenterY()*(scale-1)) \n            .scale(scale);\n                   \n        return transform;\n    }","commit_id":"62fc69701bc2c6bc392b1285708a55d6ede1b874","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void centerD3Selection(JsArray<GWTVertex> vertices, boolean fitToView) {\n        \n        final BoundingRect rect = new BoundingRect();\n\n        for(int i = 0; i < vertices.length(); i++) {\n            GWTVertex vertex = vertices.get(i);\n            \n            if(fitToView || vertex.isSelected()) {\n                double vertexX = vertex.getX();\n                double vertexY = vertex.getY();\n                rect.addPoint(new Point(vertexX, vertexY));\n            }\n        }\n        \n        m_topologyView.zoomToFit(rect);\n    }","id":81469,"modified_method":"private BoundingRect createBoundingRect(JsArray<GWTVertex> vertices, boolean fitToView) {\n        final BoundingRect rect = new BoundingRect();\n\n        for(int i = 0; i < vertices.length(); i++) {\n            GWTVertex vertex = vertices.get(i);\n            \n            if(fitToView || vertex.isSelected()) {\n                double vertexX = vertex.getX();\n                double vertexY = vertex.getY();\n                rect.addPoint(new Point(vertexX, vertexY));\n            }\n        }\n        return rect;\n    }","commit_id":"62fc69701bc2c6bc392b1285708a55d6ede1b874","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void draw(GWTGraph graph, final TopologyView<TopologyViewRenderer> topologyView) {\n\t\t\tD3 edgeSelection = getEdgeSelection(graph, topologyView);\n\n\t\t\tD3 vertexSelection = getVertexSelection(graph, topologyView);\n\n\t\t\tvertexSelection.enter().create(GWTVertex.create()).call(setupEventHandlers())\n\t\t\t.attr(\"transform\", new Func<String, GWTVertex>() {\n\n\t\t\t\tpublic String call(GWTVertex vertex, int index) {\n\t\t\t\t\treturn \"translate(\" + vertex.getInitialX() + \",\" +  vertex.getInitialY() + \")\";\n\t\t\t\t}\n\n\t\t\t}).attr(\"opacity\", 1);\n\n\t\t\t//Exits\n\t\t\tedgeSelection.exit().with(exitTransition()).remove();\n\t\t\tvertexSelection.exit().with(new D3Behavior() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic D3 run(D3 selection) {\n\t\t\t\t\treturn selection.transition().delay(0).duration(500);\n\t\t\t\t}\n\t\t\t}).attr(\"transform\", new Func<String, GWTVertex>(){\n\n\t\t\t\tpublic String call(GWTVertex vertex, int index) {\n\t\t\t\t\treturn \"translate(\" + vertex.getInitialX() + \",\" +  vertex.getInitialY() + \")\";\n\t\t\t\t}\n\n\t\t\t}).attr(\"opacity\", 0).remove();\n\n\n\t\t\t//Updates\n\t\t\tedgeSelection.with(updateTransition()).call(GWTEdge.draw()).attr(\"opacity\", 1)\n\t\t\t    //.transition().styleTween(\"stroke-width\", edgeStrokeWidthTween(topologyView))\n\t\t\t    ;\n\n\t\t\tvertexSelection.with(updateTransition()).call(GWTVertex.draw()).attr(\"opacity\", 1);\n\n\n\t\t\t//Enters\n\t\t\tedgeSelection.enter().create(GWTEdge.create()).call(setupEdgeEventHandlers()).with(enterTransition())\n\t\t\t    //.transition().styleTween(\"stroke-width\", edgeStrokeWidthTween(topologyView));\n\t\t\t    .transition().style(\"stroke-width\", \"7px\");\n\t\t\t\n\t\t\t\n\t\t\tD3.d3().select(topologyView.getSVGViewPort())\n\t\t\t    .transition().duration(30000)\n\t\t\t    .attr(\"transform\", topologyView.getViewportTransform() );\n\t\t\t//vertexSelection.enter().create(GWTVertex.create()).call(setupEventHandlers()).with(enterTransition());\n\t\t\t\n\t\t}","id":81470,"modified_method":"public void draw(GWTGraph graph, final TopologyView<TopologyViewRenderer> topologyView) {\n\t\t\tD3 edgeSelection = getEdgeSelection(graph, topologyView);\n\n\t\t\tD3 vertexSelection = getVertexSelection(graph, topologyView);\n\n\t\t\tvertexSelection.enter().create(GWTVertex.create()).call(setupEventHandlers())\n\t\t\t.attr(\"transform\", new Func<String, GWTVertex>() {\n\n\t\t\t\tpublic String call(GWTVertex vertex, int index) {\n\t\t\t\t\treturn \"translate(\" + vertex.getInitialX() + \",\" +  vertex.getInitialY() + \")\";\n\t\t\t\t}\n\n\t\t\t}).attr(\"opacity\", 1);\n\n\t\t\t\n\t\t\t//Exits\n\t\t\tedgeSelection.exit().remove();\n\t\t\tvertexSelection.exit().with(new D3Behavior() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic D3 run(D3 selection) {\n\t\t\t\t\treturn selection.transition().delay(0).duration(0);\n\t\t\t\t}\n\t\t\t}).attr(\"transform\", new Func<String, GWTVertex>(){\n\n\t\t\t\tpublic String call(GWTVertex vertex, int index) {\n\t\t\t\t\treturn \"translate(\" + vertex.getInitialX() + \",\" +  vertex.getInitialY() + \")\";\n\t\t\t\t}\n\n\t\t\t}).attr(\"opacity\", 0).remove();\n\n\n\t\t\t//Updates\n\t\t\tedgeSelection.call(GWTEdge.draw()).attr(\"opacity\", 1);\n\t\t\t\n\t\t\tvertexSelection.with(updateTransition()).call(GWTVertex.draw()).attr(\"opacity\", 1);\n\n\n\t\t\t//Enters\n\t\t\tedgeSelection.enter().create(GWTEdge.create()).call(setupEdgeEventHandlers());\n\t\t\t\n\t\t\tconsoleLog(\"isFitToView(): \" + graph.isFitToView() + \" isPanToSelection(): \" + graph.isPanToSelection());\n            //Scaling and Fit to Zoom transitions\n            if(!graph.isFitToView() && !graph.isPanToSelection()) {\n                \n                SVGMatrix transform = topologyView.calculateNewTransform(graph.getOldScale(), graph.getScale(), graph.getClientX(), graph.getClientY());\n                \n                D3.d3().select(topologyView.getSVGViewPort())\n                .transition().duration(1000)\n                .attr(\"transform\", matrixTransform(transform) )\n                .selectAll(GWTEdge.SVG_EDGE_ELEMENT).attr(\"opacity\", \"1\").transition().style(\"stroke-width\", 5/transform.getA() + \"px\");\n            \n            } else if(graph.isPanToSelection()) {\n                \n                final BoundingRect rect = createBoundingRect(graph.getVertices(), false);\n                SVGMatrix transform = topologyView.calculateZoomToFit(rect);\n                final double scale = transform.getA();\n                graph.setScale(scale);\n                \n                D3.d3().select(topologyView.getSVGViewPort()).transition().duration(2000).attr(\"transform\", matrixTransform(transform)).each(\"end\", new AnonymousFunc() {\n                    \n                    @Override\n                    public void call() {\n                        onScaleUpdate(scale);\n                    }\n                });\n                \n                D3.d3().selectAll(GWTEdge.SVG_EDGE_ELEMENT).transition().delay(500).duration(1500).attr(\"opacity\", \"1\").style(\"stroke-width\", 5 / scale + \"px\");\n            }else if(graph.isFitToView()) {\n                \n                final BoundingRect rect = createBoundingRect(graph.getVertices(), true);\n                SVGMatrix transform = topologyView.calculateZoomToFit(rect);\n                final double scale = transform.getA();\n                graph.setScale(scale);\n                \n                D3.d3().select(topologyView.getSVGViewPort()).transition().delay(500).duration(2000).attr(\"transform\", matrixTransform(transform)).each(\"end\", new AnonymousFunc() {\n                    \n                    @Override\n                    public void call() {\n                        onScaleUpdate(scale);\n                    }\n                });\n                \n                D3.d3().selectAll(GWTEdge.SVG_EDGE_ELEMENT).transition().duration(2000).attr(\"opacity\", \"1\").style(\"stroke-width\", 5 / scale + \"px\");\n            }\n\t\t}","commit_id":"62fc69701bc2c6bc392b1285708a55d6ede1b874","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Sets the graph, updates the ViewRenderer if need be and \n\t * updates all graphUpdateListeners\n\t * @param graph\n\t */\n\tprivate void setGraph(GWTGraph graph) {\n\t\tm_graph = graph;\n\t\tupdateGraphUpdateListeners();\n\t\t\n\t\tif(m_graph.isPanToSelection()) {\n\t\t    centerSelection(m_graph.getVertices());\n\t\t} else if(m_graph.isFitToView()) {\n\t\t    fitMapToView(m_graph.getVertices());\n\t\t}\n        \n\t\t//Set the ViewRenderer to the Animated one if it isn't already\n\t\tif(getViewRenderer() != m_graphDrawer) {\n\t\t    setTopologyViewRenderer(m_graphDrawer);\n\t\t}\n        \n        final D3 selectedVertices = D3.d3().selectAll(GWTVertex.SELECTED_VERTEX_CLASS_NAME);\n        selectedVertices.each(new Handler<GWTVertex>() {\n        \n            @Override\n            public void call(GWTVertex gwtVertex, int index) {\n                SVGGElement vertex = D3.getElement(selectedVertices, index).cast();\n                vertex.getParentElement().appendChild(vertex);\n            }\n        });\n\t\t\n        \n\t}","id":81471,"modified_method":"/**\n\t * Sets the graph, updates the ViewRenderer if need be and \n\t * updates all graphUpdateListeners\n\t * @param graph\n\t */\n\tprivate void setGraph(GWTGraph graph) {\n\t\tm_graph = graph;\n        \n\t\t//Set the ViewRenderer to the Animated one if it isn't already\n\t\tif(getViewRenderer() != m_graphDrawer) {\n\t\t    setTopologyViewRenderer(m_graphDrawer);\n\t\t}\n        \n        final D3 selectedVertices = D3.d3().selectAll(GWTVertex.SELECTED_VERTEX_CLASS_NAME);\n        selectedVertices.each(new Handler<GWTVertex>() {\n        \n            @Override\n            public void call(GWTVertex gwtVertex, int index) {\n                SVGGElement vertex = D3.getElement(selectedVertices, index).cast();\n                vertex.getParentElement().appendChild(vertex);\n            }\n        });\n\t\t\n        updateGraphUpdateListeners();\n\t}","commit_id":"62fc69701bc2c6bc392b1285708a55d6ede1b874","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void updateFromUIDL(UIDL uidl, ApplicationConnection client) {\n\t    \n\t\tif(client.updateComponent(this, uidl, true)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tGWTGraph graph = GWTGraph.create();\n\t\t\n\t\tm_client = client;\n\t\tm_paintableId = uidl.getId();\n\t\tsetActiveTool(uidl.getStringAttribute(\"activeTool\"));\n        \n\t\tUIDL graphUIDL = uidl.getChildByTagName(\"graph\");\n\t\tIterator<?> children = graphUIDL.getChildIterator();\n\t\t\n\t\tGWTVertex.setBackgroundImage(client.translateVaadinUri(\"theme://images/vertex_circle_selector.png\"));\n\t\twhile(children.hasNext()) {\n\t\t\tUIDL child = (UIDL) children.next();\n\n\t\t\tif(child.getTag().equals(\"vertex\")) {\n\t\t\t\tString vertexKey = child.getStringAttribute(\"key\");\n\t\t\t\t//consoleLog(\"UIDL vertex: \" + vertexKey);\n\n\t\t\t\tGWTVertex vertex = GWTVertex.create(vertexKey, child.getIntAttribute(\"x\"), child.getIntAttribute(\"y\"));\n\t\t\t\t\n\t\t\t\tvertex.setInitialX(child.getIntAttribute(\"initialX\"));\n\t\t\t\tvertex.setInitialY(child.getIntAttribute(\"initialY\"));\n\t\t\t\t\n\t\t\t\tboolean selected = child.getBooleanAttribute(\"selected\");\n\t\t\t\tvertex.setSelected(selected);\n\n\t\t\t\tvertex.setIconUrl(client.translateVaadinUri(child.getStringAttribute(\"iconUrl\")));\n\n\t\t\t\tif (child.hasAttribute(\"label\")) {\n\t\t\t\t\tvertex.setLabel(child.getStringAttribute(\"label\"));\n\t\t\t\t}\n\n\t\t\t\tgraph.addVertex(vertex);\n\n\t\t\t\tif(m_client != null) {\n\t\t\t\t\tTooltipInfo ttInfo = new TooltipInfo(child.getStringAttribute(\"tooltipText\"));\n\t\t\t\t\tm_client.registerTooltip(this, vertex, ttInfo);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(child.getTag().equals(\"edge\")) {\n\t\t\t\tString edgeKey = child.getStringAttribute(\"key\");\n\t\t\t\tString sourceKey = child.getStringAttribute(\"source\");\n\t\t\t\tString targetKey = child.getStringAttribute(\"target\");\n\t\t\t\t//consoleLog(\"UIDL edge: \" + edgeKey + \"(\" + sourceKey +\",\" + targetKey +\")\");\n\t\t\t\t\n\t\t\t\tGWTVertex source = graph.findVertexById(sourceKey);\n\t\t\t\tGWTVertex target = graph.findVertexById( targetKey );\n\t\t\t\tGWTEdge edge = GWTEdge.create(edgeKey, source, target);\n\t\t\t\tboolean selected = child.getBooleanAttribute(\"selected\");\n\t\t\t\tString cssClass = child.getStringAttribute(\"cssClass\");\n\t\t\t\tedge.setSelected(selected);\n\t\t\t\tedge.setCssClass(cssClass);\n\t\t\t\tString ttText = child.getStringAttribute(\"tooltipText\");\n\t\t\t\tedge.setTooltipText(ttText);\n\t\t\t\tgraph.addEdge(edge);\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tJsArray<GWTEdge> edges = graph.getEdges();\n        for( int i = 0; i < edges.length(); i++) {\n\t\t    if(i != 0) {\n\t\t        GWTEdge edge1 = edges.get(i-1);\n\t\t        GWTEdge edge2 = edges.get(i);\n\t\t        \n\t\t        if((edge1.getSource() == edge2.getSource() && edge1.getTarget() == edge2.getTarget()) || (edge1.getSource() == edge2.getTarget() && edge1.getTarget() == edge2.getSource())) {\n\t\t            edge2.setLinkNum(edge1.getLinkNum() + 1);\n\t\t        }else {\n\t\t            edge2.setLinkNum(1);\n\t\t        }\n\t\t    }\n\t\t}\n        \n        graph.setScale(uidl.getDoubleAttribute(\"scale\"));\n        graph.setClientX(uidl.getIntAttribute(\"clientX\"));\n        graph.setClientY(uidl.getIntAttribute(\"clientY\"));\n        graph.setPanToSelection(uidl.getBooleanAttribute(\"panToSelection\"));\n        graph.setFitToView(uidl.getBooleanAttribute(\"fitToView\"));\n        \n        if(m_scale != graph.getScale()) {\n            m_scale = uidl.getDoubleAttribute(\"scale\");\n            updateScale(m_graph.getScale(), graph.getScale(), graph.getClientX(), graph.getClientY());\n            graph.setViewportTransform(m_topologyView.getViewportTransform());\n        }\n        \n        \n\t\tsetGraph(graph);\n        \n\t\t\n\t}","id":81472,"modified_method":"public void updateFromUIDL(UIDL uidl, ApplicationConnection client) {\n\t    \n\t\tif(client.updateComponent(this, uidl, true)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tGWTGraph graph = GWTGraph.create();\n\t\t\n\t\tm_client = client;\n\t\tm_paintableId = uidl.getId();\n\t\tsetActiveTool(uidl.getStringAttribute(\"activeTool\"));\n        \n\t\tUIDL graphUIDL = uidl.getChildByTagName(\"graph\");\n\t\tIterator<?> children = graphUIDL.getChildIterator();\n\t\t\n\t\tGWTVertex.setBackgroundImage(client.translateVaadinUri(\"theme://images/vertex_circle_selector.png\"));\n\t\twhile(children.hasNext()) {\n\t\t\tUIDL child = (UIDL) children.next();\n\n\t\t\tif(child.getTag().equals(\"vertex\")) {\n\t\t\t\tString vertexKey = child.getStringAttribute(\"key\");\n\t\t\t\t//consoleLog(\"UIDL vertex: \" + vertexKey);\n\n\t\t\t\tGWTVertex vertex = GWTVertex.create(vertexKey, child.getIntAttribute(\"x\"), child.getIntAttribute(\"y\"));\n\t\t\t\t\n\t\t\t\tvertex.setInitialX(child.getIntAttribute(\"initialX\"));\n\t\t\t\tvertex.setInitialY(child.getIntAttribute(\"initialY\"));\n\t\t\t\t\n\t\t\t\tboolean selected = child.getBooleanAttribute(\"selected\");\n\t\t\t\tvertex.setSelected(selected);\n\n\t\t\t\tvertex.setIconUrl(client.translateVaadinUri(child.getStringAttribute(\"iconUrl\")));\n\n\t\t\t\tif (child.hasAttribute(\"label\")) {\n\t\t\t\t\tvertex.setLabel(child.getStringAttribute(\"label\"));\n\t\t\t\t}\n\n\t\t\t\tgraph.addVertex(vertex);\n\n\t\t\t\tif(m_client != null) {\n\t\t\t\t\tTooltipInfo ttInfo = new TooltipInfo(child.getStringAttribute(\"tooltipText\"));\n\t\t\t\t\tm_client.registerTooltip(this, vertex, ttInfo);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(child.getTag().equals(\"edge\")) {\n\t\t\t\tString edgeKey = child.getStringAttribute(\"key\");\n\t\t\t\tString sourceKey = child.getStringAttribute(\"source\");\n\t\t\t\tString targetKey = child.getStringAttribute(\"target\");\n\t\t\t\t//consoleLog(\"UIDL edge: \" + edgeKey + \"(\" + sourceKey +\",\" + targetKey +\")\");\n\t\t\t\t\n\t\t\t\tGWTVertex source = graph.findVertexById(sourceKey);\n\t\t\t\tGWTVertex target = graph.findVertexById( targetKey );\n\t\t\t\tGWTEdge edge = GWTEdge.create(edgeKey, source, target);\n\t\t\t\tboolean selected = child.getBooleanAttribute(\"selected\");\n\t\t\t\tString cssClass = child.getStringAttribute(\"cssClass\");\n\t\t\t\tedge.setSelected(selected);\n\t\t\t\tedge.setCssClass(cssClass);\n\t\t\t\tString ttText = child.getStringAttribute(\"tooltipText\");\n\t\t\t\tedge.setTooltipText(ttText);\n\t\t\t\tgraph.addEdge(edge);\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tJsArray<GWTEdge> edges = graph.getEdges();\n        for( int i = 0; i < edges.length(); i++) {\n\t\t    if(i != 0) {\n\t\t        GWTEdge edge1 = edges.get(i-1);\n\t\t        GWTEdge edge2 = edges.get(i);\n\t\t        \n\t\t        if((edge1.getSource() == edge2.getSource() && edge1.getTarget() == edge2.getTarget()) || (edge1.getSource() == edge2.getTarget() && edge1.getTarget() == edge2.getSource())) {\n\t\t            edge2.setLinkNum(edge1.getLinkNum() + 1);\n\t\t        }else {\n\t\t            edge2.setLinkNum(1);\n\t\t        }\n\t\t    }\n\t\t}\n        \n        graph.setScale(uidl.getDoubleAttribute(\"scale\"));\n        graph.setOldScale(m_graph.getScale());\n        graph.setClientX(uidl.getIntAttribute(\"clientX\"));\n        graph.setClientY(uidl.getIntAttribute(\"clientY\"));\n        graph.setPanToSelection(uidl.getBooleanAttribute(\"panToSelection\"));\n        graph.setFitToView(uidl.getBooleanAttribute(\"fitToView\"));\n        consoleLog(\"graph.oldScale(): \" + graph.getOldScale() + \" graph.getScale(): \" + graph.getScale());\n\t\tsetGraph(graph);\n        \n\t\t\n\t}","commit_id":"62fc69701bc2c6bc392b1285708a55d6ede1b874","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setSize(int wide, int high) {\n//    System.out.format(\"frame visible %b, setSize(%d, %d) %n\", frame.isVisible(), wide, high);\n//    new Exception().printStackTrace(System.out);\n\n    sketchWidth = wide;\n    sketchHeight = high;\n\n//    canvas.setSize(wide, high);\n//    frame.setSize(wide, high);\n    setFrameSize(); //wide, high);\n    setCanvasSize();\n    frame.setLocationRelativeTo(null);\n//    if (frame != null) {\n//      frame.setLocationRelativeTo(null);\n//    }\n\n    GraphicsConfiguration gc = canvas.getGraphicsConfiguration();\n    // If not realized (off-screen, i.e the Color Selector Tool), gc will be null.\n    if (gc == null) {\n      System.err.println(\"GraphicsConfiguration null in setSize()\");\n      GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n      gc = ge.getDefaultScreenDevice().getDefaultConfiguration();\n    }\n\n    // Formerly this was broken into separate versions based on offscreen or\n    // not, but we may as well create a compatible image; it won't hurt, right?\n    int factor = graphics.pixelFactor;\n    graphics.image = gc.createCompatibleImage(wide * factor, high * factor);\n\n    //throw new RuntimeException(\"implement me, see readme.md\");\n    sketch.width = wide;\n    sketch.height = high;\n\n    // sets internal variables for width/height/pixelWidth/pixelHeight\n    graphics.setSize(wide, high);\n  }","id":81473,"modified_method":"public void setSize(int wide, int high) {\n//    System.out.format(\"frame visible %b, setSize(%d, %d) %n\", frame.isVisible(), wide, high);\n//    new Exception().printStackTrace(System.out);\n\n    sketchWidth = wide;\n    sketchHeight = high;\n\n//    canvas.setSize(wide, high);\n//    frame.setSize(wide, high);\n    if (frame != null) {\n      frame.setLocationRelativeTo(null);\n    }\n    setCanvasSize();\n\n    GraphicsConfiguration gc = canvas.getGraphicsConfiguration();\n    // If not realized (off-screen, i.e the Color Selector Tool), gc will be null.\n    if (gc == null) {\n      System.err.println(\"GraphicsConfiguration null in setSize()\");\n      GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n      gc = ge.getDefaultScreenDevice().getDefaultConfiguration();\n    }\n\n    // Formerly this was broken into separate versions based on offscreen or\n    // not, but we may as well create a compatible image; it won't hurt, right?\n    int factor = graphics.pixelFactor;\n    graphics.image = gc.createCompatibleImage(wide * factor, high * factor);\n\n    //throw new RuntimeException(\"implement me, see readme.md\");\n    sketch.width = wide;\n    sketch.height = high;\n\n    // sets internal variables for width/height/pixelWidth/pixelHeight\n    graphics.setSize(wide, high);\n  }","commit_id":"e4435291f23c296d4e4084cdbe0553878a275e9c","url":"https://github.com/processing/processing"},{"original_method":"public LwjglFrame (ApplicationListener listener, String title, int width, int height, boolean useGL2) {\r\n\t\tsuper(title);\r\n\r\n\t\tlwjglCanvas = new LwjglCanvas(listener, useGL2) {\r\n\t\t\tprotected void stopped () {\r\n\t\t\t\tLwjglFrame.this.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tprotected void setTitle (String title) {\r\n\t\t\t\tLwjglFrame.this.setTitle(title);\r\n\t\t\t}\r\n\r\n\t\t\tprotected void setDisplayMode (int width, int height) {\r\n\t\t\t\tLwjglFrame.this.getContentPane().setPreferredSize(new Dimension(width, height));\r\n\t\t\t\tLwjglFrame.this.getContentPane().invalidate();\r\n\t\t\t\tLwjglFrame.this.pack();\r\n\t\t\t\tLwjglFrame.this.setLocationRelativeTo(null);\r\n\t\t\t\tupdateSize(width, height);\r\n\t\t\t}\r\n\r\n\t\t\tprotected void resize (int width, int height) {\r\n\t\t\t\tupdateSize(width, height);\r\n\t\t\t}\r\n\t\t};\r\n\t\tgetContentPane().add(lwjglCanvas.getCanvas());\r\n\r\n\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tRuntime.getRuntime().halt(0); // Because fuck you, Swing shutdown hooks.\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\r\n\t\tgetContentPane().setPreferredSize(new Dimension(width, height));\r\n\t\tinitialize();\r\n\t\tpack();\r\n\t\tsetLocationRelativeTo(null);\r\n\t\tsetVisible(true);\r\n\t\tlwjglCanvas.getCanvas().requestFocus();\r\n\t}","id":81474,"modified_method":"public LwjglFrame (ApplicationListener listener, String title, int width, int height, boolean useGL2) {\r\n\t\tsuper(title);\r\n\r\n\t\tlwjglCanvas = new LwjglCanvas(listener, useGL2) {\r\n\t\t\tprotected void stopped () {\r\n\t\t\t\tLwjglFrame.this.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tprotected void setTitle (String title) {\r\n\t\t\t\tLwjglFrame.this.setTitle(title);\r\n\t\t\t}\r\n\r\n\t\t\tprotected void setDisplayMode (int width, int height) {\r\n\t\t\t\tLwjglFrame.this.getContentPane().setPreferredSize(new Dimension(width, height));\r\n\t\t\t\tLwjglFrame.this.getContentPane().invalidate();\r\n\t\t\t\tLwjglFrame.this.pack();\r\n\t\t\t\tLwjglFrame.this.setLocationRelativeTo(null);\r\n\t\t\t\tupdateSize(width, height);\r\n\t\t\t}\r\n\r\n\t\t\tprotected void resize (int width, int height) {\r\n\t\t\t\tupdateSize(width, height);\r\n\t\t\t}\r\n\t\t};\r\n\t\tgetContentPane().add(lwjglCanvas.getCanvas());\r\n\r\n\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tRuntime.getRuntime().halt(0); // Because fuck you, Swing shutdown hooks.\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\r\n\t\tgetContentPane().setPreferredSize(new Dimension(width, height));\r\n\t\tinitialize();\r\n\t\tDimension size = getSize();\r\n\t\tif (size.width == 0 && size.height == 0) pack();\r\n\t\tPoint location = getLocation();\r\n\t\tif (location.x == 0 && location.y == 0) setLocationRelativeTo(null);\r\n\t\tsetVisible(true);\r\n\t\tlwjglCanvas.getCanvas().requestFocus();\r\n\t}","commit_id":"10f8256020a17f97dd00938c85c2dc40d9cb42c2","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setSize(int wide, int high) {\n//    System.out.format(\"frame visible %b, setSize(%d, %d) %n\", frame.isVisible(), wide, high);\n//    new Exception().printStackTrace(System.out);\n\n    sketchWidth = wide;\n    sketchHeight = high;\n\n//    canvas.setSize(wide, high);\n//    frame.setSize(wide, high);\n    setFrameSize(); //wide, high);\n    setCanvasSize();\n    frame.setLocationRelativeTo(null);\n\n    GraphicsConfiguration gc = canvas.getGraphicsConfiguration();\n    // If not realized (off-screen, i.e the Color Selector Tool), gc will be null.\n    if (gc == null) {\n      System.err.println(\"GraphicsConfiguration null in setSize()\");\n      GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n      gc = ge.getDefaultScreenDevice().getDefaultConfiguration();\n    }\n\n    // Formerly this was broken into separate versions based on offscreen or\n    // not, but we may as well create a compatible image; it won't hurt, right?\n    int factor = graphics.pixelFactor;\n    graphics.image = gc.createCompatibleImage(wide * factor, high * factor);\n\n    //throw new RuntimeException(\"implement me, see readme.md\");\n    sketch.width = wide;\n    sketch.height = high;\n\n    // sets internal variables for width/height/pixelWidth/pixelHeight\n    graphics.setSize(wide, high);\n  }","id":81475,"modified_method":"public void setSize(int wide, int high) {\n//    System.out.format(\"frame visible %b, setSize(%d, %d) %n\", frame.isVisible(), wide, high);\n//    new Exception().printStackTrace(System.out);\n\n    sketchWidth = wide;\n    sketchHeight = high;\n\n//    canvas.setSize(wide, high);\n//    frame.setSize(wide, high);\n    if (frame != null) {  // canvas only\n      setFrameSize(); //wide, high);\n    }\n    setCanvasSize();\n    if (frame != null) {\n      frame.setLocationRelativeTo(null);\n    }\n\n    GraphicsConfiguration gc = canvas.getGraphicsConfiguration();\n    // If not realized (off-screen, i.e the Color Selector Tool), gc will be null.\n    if (gc == null) {\n      System.err.println(\"GraphicsConfiguration null in setSize()\");\n      GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n      gc = ge.getDefaultScreenDevice().getDefaultConfiguration();\n    }\n\n    // Formerly this was broken into separate versions based on offscreen or\n    // not, but we may as well create a compatible image; it won't hurt, right?\n    int factor = graphics.pixelFactor;\n    graphics.image = gc.createCompatibleImage(wide * factor, high * factor);\n\n    //throw new RuntimeException(\"implement me, see readme.md\");\n    sketch.width = wide;\n    sketch.height = high;\n\n    // sets internal variables for width/height/pixelWidth/pixelHeight\n    graphics.setSize(wide, high);\n  }","commit_id":"15ca459dd8be652333c85c55d724469a657ec2a4","url":"https://github.com/processing/processing"},{"original_method":"protected Object resolve(ELContext ctx, Object base, Object property) {\n\t\tVariableResolver resolver = _ctx.getVariableResolver();\n\t\tif (resolver != null) {\n\t\t\tif (resolver instanceof VariableResolverX) {\n\t\t\t\tfinal Object o = ((VariableResolverX)resolver)\n\t\t\t\t\t.resolveVariable(_ctx, base, property);\n\t\t\t\tctx.setPropertyResolved(true);\n\t\t\t\treturn o;\n\t\t\t} else if (base == null && property != null) {\n\t\t\t\tfinal Object o = resolver.resolveVariable(property.toString());\n\t\t\t\tctx.setPropertyResolved(true);\n\t\t\t\treturn o;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":81476,"modified_method":"protected Object resolve(ELContext ctx, Object base, Object property) {\n\t\tVariableResolver resolver = _ctx.getVariableResolver();\n\t\tif (resolver != null) {\n\t\t\tif (resolver instanceof VariableResolverX) {\n\t\t\t\tfinal Object o = ((VariableResolverX)resolver)\n\t\t\t\t\t.resolveVariable(_ctx, base, property);\n\n\t\t\t\t// Bug ZK-3021\n\t\t\t\tif (REFERENCE_BINDING != null && o != null) {\n\t\t\t\t\tif (REFERENCE_BINDING.isAssignableFrom(o.getClass())) {\n\t\t\t\t\t\tctx.setPropertyResolved(true);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn GET_VALUE.invoke(o, new Object[]{null});\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t// do nothing.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.setPropertyResolved(true);\n\t\t\t\treturn o;\n\t\t\t} else if (base == null && property != null) {\n\t\t\t\tfinal Object o = resolver.resolveVariable(property.toString());\n\t\t\t\tctx.setPropertyResolved(true);\n\t\t\t\treturn o;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"8f46c61e57dcce6036f00f892974deb5e459cd2f","url":"https://github.com/zkoss/zk"},{"original_method":"public static ArrayList<MediaSnippet> computeMediaSnippets(final Document document, final TreeSet<byte[]> queryhashes, final ContentDomain mediatype) {\r\n        \r\n        if (document == null) return new ArrayList<MediaSnippet>();\r\n        Map<DigestURI, String> media = null;\r\n        if (mediatype == ContentDomain.AUDIO) media = document.getAudiolinks();\r\n        else if (mediatype == ContentDomain.VIDEO) media = document.getVideolinks();\r\n        else if (mediatype == ContentDomain.APP) media = document.getApplinks();\r\n        if (media == null) return null;\r\n        \r\n        final Iterator<Map.Entry<DigestURI, String>> i = media.entrySet().iterator();\r\n        Map.Entry<DigestURI, String> entry;\r\n        DigestURI url;\r\n        String desc;\r\n        TreeSet<byte[]> s;\r\n        final ArrayList<MediaSnippet> result = new ArrayList<MediaSnippet>();\r\n        while (i.hasNext()) {\r\n            entry = i.next();\r\n            url = entry.getKey();\r\n            desc = entry.getValue();\r\n            s = TextSnippet.removeAppearanceHashes(url.toNormalform(false, false), queryhashes);\r\n            if (s.size() == 0) {\r\n                result.add(new MediaSnippet(mediatype, url, desc, null, 0, document.dc_source()));\r\n                continue;\r\n            }\r\n            s = TextSnippet.removeAppearanceHashes(desc, s);\r\n            if (s.size() == 0) {\r\n                result.add(new MediaSnippet(mediatype, url, desc, null, 0, document.dc_source()));\r\n                continue;\r\n            }\r\n        }\r\n        return result;\r\n    }","id":81477,"modified_method":"public static ArrayList<MediaSnippet> computeMediaSnippets(final Document document, final TreeSet<byte[]> queryhashes, final ContentDomain mediatype) {\r\n        \r\n        if (document == null) return new ArrayList<MediaSnippet>();\r\n        Map<DigestURI, String> media = null;\r\n        if (mediatype == ContentDomain.AUDIO) media = document.getAudiolinks();\r\n        else if (mediatype == ContentDomain.VIDEO) media = document.getVideolinks();\r\n        else if (mediatype == ContentDomain.APP) media = document.getApplinks();\r\n        if (media == null) return null;\r\n        \r\n        final Iterator<Map.Entry<DigestURI, String>> i = media.entrySet().iterator();\r\n        Map.Entry<DigestURI, String> entry;\r\n        DigestURI url;\r\n        String desc;\r\n        final ArrayList<MediaSnippet> result = new ArrayList<MediaSnippet>();\r\n        while (i.hasNext()) {\r\n            entry = i.next();\r\n            url = entry.getKey();\r\n            desc = entry.getValue();\r\n            int ranking =  TextSnippet.removeAppearanceHashes(url.toNormalform(false, false), queryhashes).size() +\r\n                           TextSnippet.removeAppearanceHashes(desc, queryhashes).size();\r\n            if (ranking < 2 * queryhashes.size()) {\r\n                result.add(new MediaSnippet(mediatype, url, desc, null, ranking, document.dc_source()));\r\n            }\r\n        }\r\n        return result;\r\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static ArrayList<MediaSnippet> computeImageSnippets(final Document document, final TreeSet<byte[]> queryhashes) {\r\n        \r\n        final TreeSet<ImageEntry> images = new TreeSet<ImageEntry>();\r\n        images.addAll(document.getImages().values()); // iterates images in descending size order!\r\n        // a measurement for the size of the images can be retrieved using the htmlFilterImageEntry.hashCode()\r\n        \r\n        final Iterator<ImageEntry> i = images.iterator();\r\n        ImageEntry ientry;\r\n        DigestURI url;\r\n        String desc;\r\n        TreeSet<byte[]> s;\r\n        final ArrayList<MediaSnippet> result = new ArrayList<MediaSnippet>();\r\n        while (i.hasNext()) {\r\n            ientry = i.next();\r\n            url = ientry.url();\r\n            String u = url.toString();\r\n            if (u.indexOf(\".ico\") >= 0 || u.indexOf(\"favicon\") >= 0) continue;\r\n            if (ientry.height() > 0 && ientry.height() < 64) continue;\r\n            if (ientry.width() > 0 && ientry.width() < 64) continue;\r\n            desc = ientry.alt();\r\n            int appcount = 0;\r\n            s = TextSnippet.removeAppearanceHashes(url.toNormalform(false, false), queryhashes);\r\n            appcount += queryhashes.size() - s.size();\r\n            // if the resulting set is empty, then _all_ words from the query appeared in the url\r\n            s = TextSnippet.removeAppearanceHashes(desc, s);\r\n            appcount += queryhashes.size() - s.size();\r\n            // if the resulting set is empty, then _all_ search words appeared in the description\r\n            final int ranking = /*(ientry.hashCode() / queryhashes.size() / 2) */ ientry.height() * ientry.width() * appcount * 10000 /* 0x7FFF0000)*/;\r\n            result.add(new MediaSnippet(ContentDomain.IMAGE, url, desc, ientry.width() + \" x \" + ientry.height(), ranking, document.dc_source()));\r\n        }\r\n        return result;\r\n    }","id":81478,"modified_method":"public static ArrayList<MediaSnippet> computeImageSnippets(final Document document, final TreeSet<byte[]> queryhashes) {\r\n        \r\n        final TreeSet<ImageEntry> images = new TreeSet<ImageEntry>();\r\n        images.addAll(document.getImages().values()); // iterates images in descending size order!\r\n        // a measurement for the size of the images can be retrieved using the htmlFilterImageEntry.hashCode()\r\n        \r\n        final Iterator<ImageEntry> i = images.iterator();\r\n        ImageEntry ientry;\r\n        DigestURI url;\r\n        String desc;\r\n        final ArrayList<MediaSnippet> result = new ArrayList<MediaSnippet>();\r\n        while (i.hasNext()) {\r\n            ientry = i.next();\r\n            url = ientry.url();\r\n            String u = url.toString();\r\n            if (u.indexOf(\".ico\") >= 0 || u.indexOf(\"favicon\") >= 0) continue;\r\n            if (ientry.height() > 0 && ientry.height() < 64) continue;\r\n            if (ientry.width() > 0 && ientry.width() < 64) continue;\r\n            desc = ientry.alt();\r\n            int appcount = queryhashes.size()  * 2 - \r\n                           TextSnippet.removeAppearanceHashes(url.toNormalform(false, false), queryhashes).size() -\r\n                           TextSnippet.removeAppearanceHashes(desc, queryhashes).size();\r\n            final int ranking = Integer.MAX_VALUE - (ientry.height() + 1) * (ientry.width() + 1) * (appcount + 1);\r\n            result.add(new MediaSnippet(ContentDomain.IMAGE, url, desc, ientry.width() + \" x \" + ientry.height(), ranking, document.dc_source()));\r\n        }\r\n        return result;\r\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * put a elememt on the stack using a order of the weight\n     * @param element\n     * @param weight\n     */\n    public synchronized void push(final E element, Long weight) {\n        if (this.instack.contains(element)) return;\n        \n        // put the element on the stack\n        List<E> l = this.onstack.get(weight);\n        if (l == null) {\n            l = new LinkedList<E>();\n            l.add(element);\n            this.onstack.put(weight, l);\n        } else {\n            l.add(element);\n        }\n        \n        // register it for double-check\n        this.instack.add(element);\n\n        // check maximum size of the stack an remove elements if the stack gets too large\n        if (this.maxsize <= 0) return;\n        while ((this.onstack.size() > 0) && (this.onstack.size() > this.maxsize)) {\n            this.onstack.remove(this.onstack.lastKey());\n        }\n    }","id":81479,"modified_method":"/**\n     * put a elememt on the stack using a order of the weight\n     * @param element\n     * @param weight\n     */\n    public void push(final E element, Long weight) {\n        if (!this.instack.add(element)) return;\n        \n        // put the element on the stack\n        synchronized (this.onstack) {\n            List<E> l = this.onstack.get(weight);\n            if (l == null) {\n                l = new LinkedList<E>();\n                l.add(element);\n                this.onstack.put(weight, l);\n            } else {\n                l.add(element);\n            }\n        }\n\n        // check maximum size of the stack an remove elements if the stack gets too large\n        if (this.maxsize <= 0) return;\n        while ((this.onstack.size() > 0) && (this.onstack.size() > this.maxsize)) synchronized (this.onstack) {\n            if ((this.onstack.size() > 0) && (this.onstack.size() > this.maxsize)) {\n                this.onstack.remove(this.onstack.lastKey());\n            }\n        }\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * return the element with the smallest weight\n     * @return\n     */\n    public synchronized stackElement top() {\n        // returns the element that is currently on top of the stack\n        if (this.onstack.isEmpty()) return null;\n        final Long w = this.onstack.firstKey();\n        final List<E> l = this.onstack.get(w);\n        final E element = l.get(0);\n        return new stackElement(element, w);\n    }","id":81480,"modified_method":"/**\n     * return the element with the smallest weight\n     * @return\n     */\n    public stackElement top() {\n        // returns the element that is currently on top of the stack\n        final E element;\n        final Long w;\n        synchronized (this.onstack) {\n            if (this.onstack.isEmpty()) return null;\n            w = this.onstack.firstKey();\n            final List<E> l = this.onstack.get(w);\n            element = l.get(0);\n        }\n        return new stackElement(element, w);\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized void remove(final E element) {\n        if (!this.instack.contains(element)) return;\n        \n        for (Map.Entry<Long,List<E>> entry: this.onstack.entrySet()) {\n            Iterator<E> i = entry.getValue().iterator();\n            while (i.hasNext()) {\n                if (i.next().equals(element)) {\n                    i.remove();\n                    if (entry.getValue().size() == 0) {\n                        this.onstack.remove(entry.getKey());\n                    }\n                    return;\n                }\n            }\n        }\n    }","id":81481,"modified_method":"public void remove(final E element) {\n        if (!this.instack.contains(element)) return;\n        \n        synchronized (this.onstack) {\n            for (Map.Entry<Long,List<E>> entry: this.onstack.entrySet()) {\n                Iterator<E> i = entry.getValue().iterator();\n                while (i.hasNext()) {\n                    if (i.next().equals(element)) {\n                        i.remove();\n                        if (entry.getValue().size() == 0) {\n                            this.onstack.remove(entry.getKey());\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized boolean bottom(final long weight) {\n        // returns true if the element with that weight would be on the bottom of the stack after inserting\n        return weight > this.onstack.lastKey().longValue();\n    }","id":81482,"modified_method":"public boolean bottom(final long weight) {\n        // returns true if the element with that weight would be on the bottom of the stack after inserting\n        Long l;\n        synchronized (this.onstack) {\n            l = this.onstack.lastKey();\n        }\n        return weight > l.longValue();\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * return the element with the smallest weight and remove it from the stack\n     * @return\n     */\n    public synchronized stackElement pop() {\n        // returns the element that is currently on top of the stack\n        // it is removed and added to the offstack list\n        // this is exactly the same as element(offstack.size())\n        if (this.onstack.isEmpty()) return null;\n        final Long w = this.onstack.firstKey();\n        final List<E> l = this.onstack.get(w);\n        final E element = l.remove(0);\n        if (l.size() == 0) this.onstack.remove(w);\n        this.instack.remove(element);\n        return new stackElement(element, w);\n    }","id":81483,"modified_method":"/**\n     * return the element with the smallest weight and remove it from the stack\n     * @return\n     */\n    public stackElement pop() {\n        // returns the element that is currently on top of the stack\n        // it is removed and added to the offstack list\n        final E element;\n        final Long w;\n        synchronized (this.onstack) {\n            if (this.onstack.isEmpty()) return null;\n            w = this.onstack.firstKey();\n            final List<E> l = this.onstack.get(w);\n            element = l.remove(0);\n            this.instack.remove(element);\n            if (l.size() == 0) this.onstack.remove(w);\n        }\n        return new stackElement(element, w);\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized boolean exists(final E element) {\n        // uses the hashCode of the element to find out of the element had been on the list or the stack\n        return this.instack.contains(element);\n    }","id":81484,"modified_method":"public boolean exists(final E element) {\n        // uses the hashCode of the element to find out of the element had been on the list or the stack\n        return this.instack.contains(element);\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized boolean bottom(final long weight) {\n        if (super.bottom(weight)) return true;\n        return weight >= this.largest;\n    }","id":81485,"modified_method":"public synchronized boolean bottom(final long weight) {\n        if (super.bottom(weight)) return true;\n        return weight > this.largest;\n    }","commit_id":"7b1f5b04305208428d4d55e8f1ad07b5f2468fe8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected String replaceContent(String content, Locale locale)\n\t\tthrows Exception {\n\n\t\tString articleAttachments = getEmailArticleAttachments(locale);\n\t\tString articleURL = getEmailArticleURL();\n\t\tString articleVersion = LanguageUtil.format(\n\t\t\tlocale, \"version-x\", String.valueOf(_article.getVersion()));\n\t\tString categoryTitle = LanguageUtil.get(locale, \"category.kb\");\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent,\n\t\t\tnew String[] {\n\t\t\t\t\"[$ARTICLE_ATTACHMENTS$]\",\n\t\t\t\t\"[$ARTICLE_URL$]\",\n\t\t\t\t\"[$ARTICLE_VERSION$]\",\n\t\t\t\t\"[$CATEGORY_TITLE$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tarticleAttachments,\n\t\t\t\tarticleURL,\n\t\t\t\tarticleVersion,\n\t\t\t\tcategoryTitle\n\t\t\t});\n\n\t\treturn super.replaceContent(content, locale);\n\t}","id":81486,"modified_method":"protected String replaceContent(String content, Locale locale)\n\t\tthrows Exception {\n\n\t\tString articleAttachments = getEmailArticleAttachments(locale);\n\t\tString articleVersion = LanguageUtil.format(\n\t\t\tlocale, \"version-x\", String.valueOf(_article.getVersion()));\n\t\tString categoryTitle = LanguageUtil.get(locale, \"category.kb\");\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent,\n\t\t\tnew String[] {\n\t\t\t\t\"[$ARTICLE_ATTACHMENTS$]\",\n\t\t\t\t\"[$ARTICLE_VERSION$]\",\n\t\t\t\t\"[$CATEGORY_TITLE$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tarticleAttachments,\n\t\t\t\tarticleVersion,\n\t\t\t\tcategoryTitle\n\t\t\t});\n\n\t\tSubscription subscription = (Subscription)_context.get(\"subscription\");\n\n\t\tif (subscription == null) {\n\t\t\treturn super.replaceContent(content, locale);\n\t\t}\n\n\t\tString[] portletPrimKeys = ExpandoValueLocalServiceUtil.getData(\n\t\t\tsubscription.getCompanyId(), Subscription.class.getName(), \"KB\",\n\t\t\t\"portletPrimKeys\", subscription.getSubscriptionId(), new String[0]);\n\t\tString portletId = ArticleConstants.getPortletId(portletPrimKeys[0]);\n\n\t\tString articleURL = KnowledgeBaseUtil.getArticleURL(\n\t\t\tportletId, _article.getResourcePrimKey(), _portalURL);\n\t\tString portletTitle = PortalUtil.getPortletTitle(portletId, locale);\n\n\t\tcontent = StringUtil.replace(\n\t\t\tcontent,\n\t\t\tnew String[] {\n\t\t\t\t\"[$ARTICLE_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tarticleURL,\n\t\t\t\tportletTitle\n\t\t\t});\n\n\t\treturn super.replaceContent(content, locale);\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void notifySubscriber(Subscription subscription)\n\t\tthrows Exception {\n\n\t\t_subscription = subscription;\n\n\t\tsuper.notifySubscriber(subscription);\n\t}","id":81487,"modified_method":"protected void notifySubscriber(Subscription subscription)\n\t\tthrows Exception {\n\n\t\t_context.put(\"subscription\", subscription);\n\n\t\tsuper.notifySubscriber(subscription);\n\n\t\t_context.remove(\"subscription\");\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void onBeforeRemove(Group group) throws ModelListenerException {\n\t\ttry {\n\t\t\tList<Subscription> subscriptions =\n\t\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\t\tgroup.getCompanyId(), Article.class.getName(),\n\t\t\t\t\tgroup.getGroupId());\n\n\t\t\tfor (Subscription subscription : subscriptions) {\n\t\t\t\tArticleLocalServiceUtil.unsubscribeAllPortlets(\n\t\t\t\t\tsubscription.getCompanyId(),\n\t\t\t\t\tsubscription.getSubscriptionId());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ModelListenerException(e);\n\t\t}\n\t}","id":81488,"modified_method":"public void onBeforeRemove(Group group) throws ModelListenerException {\n\t\ttry {\n\t\t\tdoOnBeforeRemove(group);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ModelListenerException(e);\n\t\t}\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doUpgrade() throws Exception {\n\t\tif (tableHasColumn(\"KB_Article\", \"latest\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tupgradeArticles();\n\t}","id":81489,"modified_method":"protected void doUpgrade() throws Exception {\n\t\tif (!tableHasColumn(\"KB_Article\", \"latest\")) {\n\t\t\tupgradeArticles();\n\t\t}\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doUpgrade() throws Exception {\n\t\tif (tableHasColumn(\"KB_Article\", \"status\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tupgradeArticles();\n\t}","id":81490,"modified_method":"protected void doUpgrade() throws Exception {\n\t\tif (!tableHasColumn(\"KB_Article\", \"status\")) {\n\t\t\tupgradeArticles();\n\t\t}\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doUpgrade() throws Exception {\n\t\tExpandoTable expandoTable = getExpandoTable(\"KB\");\n\n\t\tif (expandoTable == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasExpandoColumn(expandoTable, \"portletPrimKeys\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tupgradeExpandoValues(expandoTable);\n\t}","id":81491,"modified_method":"protected void doUpgrade() throws Exception {\n\t\tExpandoTable expandoTable = getExpandoTable(\"KB\");\n\n\t\tif (expandoTable == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasExpandoColumn(expandoTable, \"portletPrimKeys\")) {\n\t\t\tupgradeExpandoValues(expandoTable);\n\t\t}\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void upgradeExpandoValues(ExpandoTable expandoTable)\n\t\tthrows Exception {\n\n\t\tExpandoColumnLocalServiceUtil.addColumn(\n\t\t\texpandoTable.getTableId(), \"portletPrimKeys\",\n\t\t\tExpandoColumnConstants.STRING_ARRAY);\n\n\t\tList<ExpandoValue> expandoValues =\n\t\t\tExpandoValueLocalServiceUtil.getColumnValues(\n\t\t\t\texpandoTable.getCompanyId(), Subscription.class.getName(),\n\t\t\t\t\"KB\", \"portletIds\", QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ExpandoValue expandoValue : expandoValues) {\n\t\t\tSubscription subscription = null;\n\n\t\t\ttry {\n\t\t\t\tsubscription = SubscriptionLocalServiceUtil.getSubscription(\n\t\t\t\t\texpandoValue.getClassPK());\n\t\t\t}\n\t\t\tcatch (NoSuchSubscriptionException nsse) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong groupId = 0;\n\n\t\t\ttry {\n\t\t\t\tArticle article = ArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\t\tsubscription.getClassPK(), WorkflowConstants.STATUS_ANY);\n\n\t\t\t\tgroupId = article.getGroupId();\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tgroupId = subscription.getClassPK();\n\t\t\t}\n\n\t\t\tString[] portletIds = ExpandoValueLocalServiceUtil.getData(\n\t\t\t\tsubscription.getCompanyId(), Subscription.class.getName(), \"KB\",\n\t\t\t\t\"portletIds\", subscription.getSubscriptionId(), new String[0]);\n\n\t\t\tString[] portletPrimKeys = new String[0];\n\n\t\t\tfor (int i = 0; i < portletIds.length; i++) {\n\t\t\t\tString portletId = portletIds[i];\n\t\t\t\tlong plid = PortalUtil.getPlidFromPortletId(groupId, portletId);\n\n\t\t\t\tif (plid == LayoutConstants.DEFAULT_PLID) {\n\t\t\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\t\tsubscription.getCompanyId(),\n\t\t\t\t\t\tGroupConstants.CONTROL_PANEL);\n\n\t\t\t\t\tplid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\t\t\t\t}\n\n\t\t\t\tString portletPrimKey = ArticleConstants.getPortletPrimKey(\n\t\t\t\t\tplid, portletId);\n\n\t\t\t\tportletPrimKeys = ArrayUtil.append(\n\t\t\t\t\tportletPrimKeys, portletPrimKey);\n\t\t\t}\n\n\t\t\tExpandoValueLocalServiceUtil.addValue(\n\t\t\t\tsubscription.getCompanyId(), Subscription.class.getName(), \"KB\",\n\t\t\t\t\"portletPrimKeys\", subscription.getSubscriptionId(),\n\t\t\t\tportletPrimKeys);\n\t\t}\n\n\t\tExpandoColumnLocalServiceUtil.deleteColumn(\n\t\t\texpandoTable.getTableId(), \"portletIds\");\n\t}","id":81492,"modified_method":"protected void upgradeExpandoValues(ExpandoTable expandoTable)\n\t\tthrows Exception {\n\n\t\tExpandoColumnLocalServiceUtil.addColumn(\n\t\t\texpandoTable.getTableId(), \"portletPrimKeys\",\n\t\t\tExpandoColumnConstants.STRING_ARRAY);\n\n\t\tList<ExpandoValue> expandoValues =\n\t\t\tExpandoValueLocalServiceUtil.getColumnValues(\n\t\t\t\texpandoTable.getCompanyId(), Subscription.class.getName(),\n\t\t\t\t\"KB\", \"portletIds\", QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ExpandoValue expandoValue : expandoValues) {\n\t\t\tSubscription subscription = null;\n\n\t\t\ttry {\n\t\t\t\tsubscription = SubscriptionLocalServiceUtil.getSubscription(\n\t\t\t\t\texpandoValue.getClassPK());\n\t\t\t}\n\t\t\tcatch (NoSuchSubscriptionException nsse) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong groupId = 0;\n\n\t\t\ttry {\n\t\t\t\tArticle article = ArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\t\tsubscription.getClassPK(), WorkflowConstants.STATUS_ANY);\n\n\t\t\t\tgroupId = article.getGroupId();\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tgroupId = subscription.getClassPK();\n\t\t\t}\n\n\t\t\tString[] portletPrimKeys = new String[0];\n\n\t\t\tString[] portletIds = expandoValue.getStringArray();\n\n\t\t\tfor (int i = 0; i < portletIds.length; i++) {\n\t\t\t\tString portletId = portletIds[i];\n\t\t\t\tlong plid = PortalUtil.getPlidFromPortletId(groupId, portletId);\n\n\t\t\t\tif (plid == LayoutConstants.DEFAULT_PLID) {\n\t\t\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\t\tsubscription.getCompanyId(),\n\t\t\t\t\t\tGroupConstants.CONTROL_PANEL);\n\n\t\t\t\t\tplid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\t\t\t\t}\n\n\t\t\t\tString portletPrimKey = ArticleConstants.getPortletPrimKey(\n\t\t\t\t\tplid, portletId);\n\n\t\t\t\tportletPrimKeys = ArrayUtil.append(\n\t\t\t\t\tportletPrimKeys, portletPrimKey);\n\t\t\t}\n\n\t\t\tExpandoValueLocalServiceUtil.addValue(\n\t\t\t\tsubscription.getCompanyId(), Subscription.class.getName(), \"KB\",\n\t\t\t\t\"portletPrimKeys\", subscription.getSubscriptionId(),\n\t\t\t\tportletPrimKeys);\n\t\t}\n\n\t\tExpandoColumnLocalServiceUtil.deleteColumn(\n\t\t\texpandoTable.getTableId(), \"portletIds\");\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doUpgrade() throws Exception {\n\t\tif (!tableHasData(\"KB_Article\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateRatingsEntries();\n\t\tupdateRatingsStats();\n\t}","id":81493,"modified_method":"protected void doUpgrade() throws Exception {\n\t\tif (tableHasData(\"KB_Article\")) {\n\t\t\tupdateRatingsEntries();\n\t\t\tupdateRatingsStats();\n\t\t}\n\t}","commit_id":"3a0338a4ec5150a7605587172b987b16d67d57a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n   * It sums up the value returned from various regions. In case qualifier is\n   * null, summation of all the column qualifiers in the given family is done.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return sum <S>\n   * @throws Throwable\n   */\n  public <R, S> S sum(final byte[] tableName, final ColumnInterpreter<R, S> ci,\n      final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class SumCallBack implements Batch.Callback<S> {\n      S sumVal = null;\n\n      public S getSumResult() {\n        return sumVal;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, S result) {\n        sumVal = ci.add(sumVal, result);\n      }\n    }\n    SumCallBack sumCallBack = new SumCallBack();\n    HTable table = new HTable(conf, tableName);\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(), new Batch.Call<AggregateProtocol, S>() {\n      @Override\n      public S call(AggregateProtocol instance) throws IOException {\n        return instance.getSum(ci, scan);\n      }\n    }, sumCallBack);\n    return sumCallBack.getSumResult();\n  }","id":81494,"modified_method":"/**\n   * It sums up the value returned from various regions. In case qualifier is\n   * null, summation of all the column qualifiers in the given family is done.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return sum <S>\n   * @throws Throwable\n   */\n  public <R, S> S sum(final byte[] tableName, final ColumnInterpreter<R, S> ci,\n      final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class SumCallBack implements Batch.Callback<S> {\n      S sumVal = null;\n\n      public S getSumResult() {\n        return sumVal;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, S result) {\n        sumVal = ci.add(sumVal, result);\n      }\n    }\n    SumCallBack sumCallBack = new SumCallBack();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(), new Batch.Call<AggregateProtocol, S>() {\n            @Override\n            public S call(AggregateProtocol instance) throws IOException {\n              return instance.getSum(ci, scan);\n            }\n          }, sumCallBack);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    return sumCallBack.getSumResult();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * It computes average while fetching sum and row count from all the\n   * corresponding regions. Approach is to compute a global sum of region level\n   * sum and rowcount and then compute the average.\n   * @param tableName\n   * @param scan\n   * @throws Throwable\n   */\n  private <R, S> Pair<S, Long> getAvgArgs(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class AvgCallBack implements Batch.Callback<Pair<S, Long>> {\n      S sum = null;\n      Long rowCount = 0l;\n\n      public Pair<S, Long> getAvgArgs() {\n        return new Pair<S, Long>(sum, rowCount);\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, Pair<S, Long> result) {\n        sum = ci.add(sum, result.getFirst());\n        rowCount += result.getSecond();\n      }\n    }\n    AvgCallBack avgCallBack = new AvgCallBack();\n    HTable table = new HTable(conf, tableName);\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(), new Batch.Call<AggregateProtocol, Pair<S, Long>>() {\n      @Override\n      public Pair<S, Long> call(AggregateProtocol instance) throws IOException {\n        return instance.getAvg(ci, scan);\n      }\n    }, avgCallBack);\n    return avgCallBack.getAvgArgs();\n  }","id":81495,"modified_method":"/**\n   * It computes average while fetching sum and row count from all the\n   * corresponding regions. Approach is to compute a global sum of region level\n   * sum and rowcount and then compute the average.\n   * @param tableName\n   * @param scan\n   * @throws Throwable\n   */\n  private <R, S> Pair<S, Long> getAvgArgs(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class AvgCallBack implements Batch.Callback<Pair<S, Long>> {\n      S sum = null;\n      Long rowCount = 0l;\n\n      public Pair<S, Long> getAvgArgs() {\n        return new Pair<S, Long>(sum, rowCount);\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, Pair<S, Long> result) {\n        sum = ci.add(sum, result.getFirst());\n        rowCount += result.getSecond();\n      }\n    }\n    AvgCallBack avgCallBack = new AvgCallBack();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(),\n          new Batch.Call<AggregateProtocol, Pair<S, Long>>() {\n            @Override\n            public Pair<S, Long> call(AggregateProtocol instance)\n                throws IOException {\n              return instance.getAvg(ci, scan);\n            }\n          }, avgCallBack);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    return avgCallBack.getAvgArgs();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * It gives the maximum value of a column for a given column family for the\n   * given range. In case qualifier is null, a max of all values for the given\n   * family is returned.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return max val <R>\n   * @throws Throwable\n   *           The caller is supposed to handle the exception as they are thrown\n   *           & propagated to it.\n   */\n  public <R, S> R max(final byte[] tableName, final ColumnInterpreter<R, S> ci,\n      final Scan scan) throws Throwable {\n    validateParameters(scan);\n    HTable table = new HTable(conf, tableName);\n\n    class MaxCallBack implements Batch.Callback<R> {\n      R max = null;\n\n      R getMax() {\n        return max;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, R result) {\n        max = (max == null || (result != null && ci.compare(max, result) < 0)) ? result : max;\n      }\n    }\n    MaxCallBack aMaxCallBack = new MaxCallBack();\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(), new Batch.Call<AggregateProtocol, R>() {\n      @Override\n      public R call(AggregateProtocol instance) throws IOException {\n        return instance.getMax(ci, scan);\n      }\n    }, aMaxCallBack);\n    return aMaxCallBack.getMax();\n  }","id":81496,"modified_method":"/**\n   * It gives the maximum value of a column for a given column family for the\n   * given range. In case qualifier is null, a max of all values for the given\n   * family is returned.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return max val <R>\n   * @throws Throwable\n   *           The caller is supposed to handle the exception as they are thrown\n   *           & propagated to it.\n   */\n  public <R, S> R max(final byte[] tableName, final ColumnInterpreter<R, S> ci,\n      final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class MaxCallBack implements Batch.Callback<R> {\n      R max = null;\n\n      R getMax() {\n        return max;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, R result) {\n        max = (max == null || (result != null && ci.compare(max, result) < 0)) ? result : max;\n      }\n    }\n    MaxCallBack aMaxCallBack = new MaxCallBack();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(), new Batch.Call<AggregateProtocol, R>() {\n            @Override\n            public R call(AggregateProtocol instance) throws IOException {\n              return instance.getMax(ci, scan);\n            }\n          }, aMaxCallBack);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    return aMaxCallBack.getMax();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * It helps locate the region with median for a given column whose weight \n   * is specified in an optional column.\n   * From individual regions, it obtains sum of values and sum of weights.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return pair whose first element is a map between start row of the region\n   *  and (sum of values, sum of weights) for the region, the second element is\n   *  (sum of values, sum of weights) for all the regions chosen\n   * @throws Throwable\n   */\n  private <R, S> Pair<NavigableMap<byte[], List<S>>, List<S>>\n  getMedianArgs(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    final NavigableMap<byte[], List<S>> map =\n      new TreeMap<byte[], List<S>>(Bytes.BYTES_COMPARATOR);\n    class StdCallback implements Batch.Callback<List<S>> {\n      S sumVal = null, sumWeights = null;\n\n      public Pair<NavigableMap<byte[], List<S>>, List<S>> getMedianParams() {\n        List<S> l = new ArrayList<S>();\n        l.add(sumVal);\n        l.add(sumWeights);\n        Pair<NavigableMap<byte[], List<S>>, List<S>> p =\n          new Pair<NavigableMap<byte[], List<S>>, List<S>>(map, l);\n        return p;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, List<S> result) {\n        map.put(row, result);\n        sumVal = ci.add(sumVal, result.get(0));\n        sumWeights = ci.add(sumWeights, result.get(1));\n      }\n    }\n    StdCallback stdCallback = new StdCallback();\n    HTable table = new HTable(conf, tableName);\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(),\n        new Batch.Call<AggregateProtocol, List<S>>() {\n          @Override\n          public List<S> call(AggregateProtocol instance)\n              throws IOException {\n            return instance.getMedian(ci, scan);\n          }\n\n        }, stdCallback);\n    return stdCallback.getMedianParams();\n  }","id":81497,"modified_method":"/**\n   * It helps locate the region with median for a given column whose weight \n   * is specified in an optional column.\n   * From individual regions, it obtains sum of values and sum of weights.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return pair whose first element is a map between start row of the region\n   *  and (sum of values, sum of weights) for the region, the second element is\n   *  (sum of values, sum of weights) for all the regions chosen\n   * @throws Throwable\n   */\n  private <R, S> Pair<NavigableMap<byte[], List<S>>, List<S>>\n  getMedianArgs(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    final NavigableMap<byte[], List<S>> map =\n      new TreeMap<byte[], List<S>>(Bytes.BYTES_COMPARATOR);\n    class StdCallback implements Batch.Callback<List<S>> {\n      S sumVal = null, sumWeights = null;\n\n      public Pair<NavigableMap<byte[], List<S>>, List<S>> getMedianParams() {\n        List<S> l = new ArrayList<S>();\n        l.add(sumVal);\n        l.add(sumWeights);\n        Pair<NavigableMap<byte[], List<S>>, List<S>> p =\n          new Pair<NavigableMap<byte[], List<S>>, List<S>>(map, l);\n        return p;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, List<S> result) {\n        map.put(row, result);\n        sumVal = ci.add(sumVal, result.get(0));\n        sumWeights = ci.add(sumWeights, result.get(1));\n      }\n    }\n    StdCallback stdCallback = new StdCallback();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(), new Batch.Call<AggregateProtocol, List<S>>() {\n            @Override\n            public List<S> call(AggregateProtocol instance) throws IOException {\n              return instance.getMedian(ci, scan);\n            }\n\n          }, stdCallback);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    return stdCallback.getMedianParams();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * It computes a global standard deviation for a given column and its value.\n   * Standard deviation is square root of (average of squares -\n   * average*average). From individual regions, it obtains sum, square sum and\n   * number of rows. With these, the above values are computed to get the global\n   * std.\n   * @param tableName\n   * @param scan\n   * @return\n   * @throws Throwable\n   */\n  private <R, S> Pair<List<S>, Long> getStdArgs(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class StdCallback implements Batch.Callback<Pair<List<S>, Long>> {\n      long rowCountVal = 0l;\n      S sumVal = null, sumSqVal = null;\n\n      public Pair<List<S>, Long> getStdParams() {\n        List<S> l = new ArrayList<S>();\n        l.add(sumVal);\n        l.add(sumSqVal);\n        Pair<List<S>, Long> p = new Pair<List<S>, Long>(l, rowCountVal);\n        return p;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, Pair<List<S>, Long> result) {\n        sumVal = ci.add(sumVal, result.getFirst().get(0));\n        sumSqVal = ci.add(sumSqVal, result.getFirst().get(1));\n        rowCountVal += result.getSecond();\n      }\n    }\n    StdCallback stdCallback = new StdCallback();\n    HTable table = new HTable(conf, tableName);\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(),\n        new Batch.Call<AggregateProtocol, Pair<List<S>, Long>>() {\n          @Override\n          public Pair<List<S>, Long> call(AggregateProtocol instance)\n              throws IOException {\n            return instance.getStd(ci, scan);\n          }\n\n        }, stdCallback);\n    return stdCallback.getStdParams();\n  }","id":81498,"modified_method":"/**\n   * It computes a global standard deviation for a given column and its value.\n   * Standard deviation is square root of (average of squares -\n   * average*average). From individual regions, it obtains sum, square sum and\n   * number of rows. With these, the above values are computed to get the global\n   * std.\n   * @param tableName\n   * @param scan\n   * @return\n   * @throws Throwable\n   */\n  private <R, S> Pair<List<S>, Long> getStdArgs(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class StdCallback implements Batch.Callback<Pair<List<S>, Long>> {\n      long rowCountVal = 0l;\n      S sumVal = null, sumSqVal = null;\n\n      public Pair<List<S>, Long> getStdParams() {\n        List<S> l = new ArrayList<S>();\n        l.add(sumVal);\n        l.add(sumSqVal);\n        Pair<List<S>, Long> p = new Pair<List<S>, Long>(l, rowCountVal);\n        return p;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, Pair<List<S>, Long> result) {\n        sumVal = ci.add(sumVal, result.getFirst().get(0));\n        sumSqVal = ci.add(sumSqVal, result.getFirst().get(1));\n        rowCountVal += result.getSecond();\n      }\n    }\n    StdCallback stdCallback = new StdCallback();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(),\n          new Batch.Call<AggregateProtocol, Pair<List<S>, Long>>() {\n            @Override\n            public Pair<List<S>, Long> call(AggregateProtocol instance)\n                throws IOException {\n              return instance.getStd(ci, scan);\n            }\n\n          }, stdCallback);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    return stdCallback.getStdParams();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * It gives the minimum value of a column for a given column family for the\n   * given range. In case qualifier is null, a min of all values for the given\n   * family is returned.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return min val <R>\n   * @throws Throwable\n   */\n  public <R, S> R min(final byte[] tableName, final ColumnInterpreter<R, S> ci,\n      final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class MinCallBack implements Batch.Callback<R> {\n\n      private R min = null;\n\n      public R getMinimum() {\n        return min;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, R result) {\n        min = (min == null || (result != null && ci.compare(result, min) < 0)) ? result : min;\n      }\n    }\n    HTable table = new HTable(conf, tableName);\n    MinCallBack minCallBack = new MinCallBack();\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(), new Batch.Call<AggregateProtocol, R>() {\n\n      @Override\n      public R call(AggregateProtocol instance) throws IOException {\n        return instance.getMin(ci, scan);\n      }\n    }, minCallBack);\n    log.debug(\"Min fom all regions is: \" + minCallBack.getMinimum());\n    return minCallBack.getMinimum();\n  }","id":81499,"modified_method":"/**\n   * It gives the minimum value of a column for a given column family for the\n   * given range. In case qualifier is null, a min of all values for the given\n   * family is returned.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return min val <R>\n   * @throws Throwable\n   */\n  public <R, S> R min(final byte[] tableName, final ColumnInterpreter<R, S> ci,\n      final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class MinCallBack implements Batch.Callback<R> {\n\n      private R min = null;\n\n      public R getMinimum() {\n        return min;\n      }\n\n      @Override\n      public synchronized void update(byte[] region, byte[] row, R result) {\n        min = (min == null || (result != null && ci.compare(result, min) < 0)) ? result : min;\n      }\n    }\n    MinCallBack minCallBack = new MinCallBack();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(), new Batch.Call<AggregateProtocol, R>() {\n\n            @Override\n            public R call(AggregateProtocol instance) throws IOException {\n              return instance.getMin(ci, scan);\n            }\n          }, minCallBack);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    log.debug(\"Min fom all regions is: \" + minCallBack.getMinimum());\n    return minCallBack.getMinimum();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * This is the client side interface/handler for calling the median method for a\n   * given cf-cq combination. This method collects the necessary parameters\n   * to compute the median and returns the median.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return R the median\n   * @throws Throwable\n   */\n  public <R, S> R median(final byte[] tableName, ColumnInterpreter<R, S> ci,\n      Scan scan) throws Throwable {\n    Pair<NavigableMap<byte[], List<S>>, List<S>> p = getMedianArgs(tableName, ci, scan);\n    byte[] startRow = null;\n    byte[] colFamily = scan.getFamilies()[0];\n    NavigableSet<byte[]> quals = scan.getFamilyMap().get(colFamily);\n    NavigableMap<byte[], List<S>> map = p.getFirst();\n    S sumVal = p.getSecond().get(0);\n    S sumWeights = p.getSecond().get(1);\n    double halfSumVal = ci.divideForAvg(sumVal, 2L);\n    double movingSumVal = 0;\n    boolean weighted = false;\n    if (quals.size() > 1) {\n      weighted = true;\n      halfSumVal = ci.divideForAvg(sumWeights, 2L);\n    }\n    \n    for (Map.Entry<byte[], List<S>> entry : map.entrySet()) {\n      S s = weighted ? entry.getValue().get(1) : entry.getValue().get(0);\n      double newSumVal = movingSumVal + ci.divideForAvg(s, 1L);\n      if (newSumVal > halfSumVal) break;  // we found the region with the median\n      movingSumVal = newSumVal;\n      startRow = entry.getKey();\n    }\n    // scan the region with median and find it\n    Scan scan2 = new Scan(scan);\n    // inherit stop row from method parameter\n    if (startRow != null) scan2.setStartRow(startRow);\n    HTable table = new HTable(conf, tableName);\n    int cacheSize = scan2.getCaching();\n    if (!scan2.getCacheBlocks() || scan2.getCaching() < 2) {\n      scan2.setCacheBlocks(true);\n      cacheSize = 5;\n      scan2.setCaching(cacheSize);\n    }\n    ResultScanner scanner = table.getScanner(scan2);\n    Result[] results = null;\n    byte[] qualifier = quals.pollFirst();\n    // qualifier for the weight column\n    byte[] weightQualifier = weighted ? quals.pollLast() : qualifier;\n    R value = null;\n    try {\n      do {\n        results = scanner.next(cacheSize);\n        if (results != null && results.length > 0) {\n          for (int i = 0; i < results.length; i++) {\n            Result r = results[i];\n            // retrieve weight\n            KeyValue kv = r.getColumnLatest(colFamily, weightQualifier);\n            R newValue = ci.getValue(colFamily, weightQualifier, kv);\n            S s = ci.castToReturnType(newValue);\n            double newSumVal = movingSumVal + ci.divideForAvg(s, 1L);\n            // see if we have moved past the median\n            if (newSumVal > halfSumVal) {\n              return value;\n            }\n            movingSumVal = newSumVal;\n            kv = r.getColumnLatest(colFamily, qualifier);\n            value = ci.getValue(colFamily, qualifier, kv);\n          }\n        }\n      } while (results != null && results.length > 0);\n    } finally {\n      scanner.close();\n    }\n    return null;\n  }","id":81500,"modified_method":"/**\n   * This is the client side interface/handler for calling the median method for a\n   * given cf-cq combination. This method collects the necessary parameters\n   * to compute the median and returns the median.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return R the median\n   * @throws Throwable\n   */\n  public <R, S> R median(final byte[] tableName, ColumnInterpreter<R, S> ci,\n      Scan scan) throws Throwable {\n    Pair<NavigableMap<byte[], List<S>>, List<S>> p = getMedianArgs(tableName, ci, scan);\n    byte[] startRow = null;\n    byte[] colFamily = scan.getFamilies()[0];\n    NavigableSet<byte[]> quals = scan.getFamilyMap().get(colFamily);\n    NavigableMap<byte[], List<S>> map = p.getFirst();\n    S sumVal = p.getSecond().get(0);\n    S sumWeights = p.getSecond().get(1);\n    double halfSumVal = ci.divideForAvg(sumVal, 2L);\n    double movingSumVal = 0;\n    boolean weighted = false;\n    if (quals.size() > 1) {\n      weighted = true;\n      halfSumVal = ci.divideForAvg(sumWeights, 2L);\n    }\n    \n    for (Map.Entry<byte[], List<S>> entry : map.entrySet()) {\n      S s = weighted ? entry.getValue().get(1) : entry.getValue().get(0);\n      double newSumVal = movingSumVal + ci.divideForAvg(s, 1L);\n      if (newSumVal > halfSumVal) break;  // we found the region with the median\n      movingSumVal = newSumVal;\n      startRow = entry.getKey();\n    }\n    // scan the region with median and find it\n    Scan scan2 = new Scan(scan);\n    // inherit stop row from method parameter\n    if (startRow != null) scan2.setStartRow(startRow);\n    HTable table = null;\n    ResultScanner scanner = null;\n    try {\n      table = new HTable(conf, tableName);\n      int cacheSize = scan2.getCaching();\n      if (!scan2.getCacheBlocks() || scan2.getCaching() < 2) {\n        scan2.setCacheBlocks(true);\n        cacheSize = 5;\n        scan2.setCaching(cacheSize);\n      }\n      scanner = table.getScanner(scan2);\n      Result[] results = null;\n      byte[] qualifier = quals.pollFirst();\n      // qualifier for the weight column\n      byte[] weightQualifier = weighted ? quals.pollLast() : qualifier;\n      R value = null;\n      do {\n        results = scanner.next(cacheSize);\n        if (results != null && results.length > 0) {\n          for (int i = 0; i < results.length; i++) {\n            Result r = results[i];\n            // retrieve weight\n            KeyValue kv = r.getColumnLatest(colFamily, weightQualifier);\n            R newValue = ci.getValue(colFamily, weightQualifier, kv);\n            S s = ci.castToReturnType(newValue);\n            double newSumVal = movingSumVal + ci.divideForAvg(s, 1L);\n            // see if we have moved past the median\n            if (newSumVal > halfSumVal) {\n              return value;\n            }\n            movingSumVal = newSumVal;\n            kv = r.getColumnLatest(colFamily, qualifier);\n            value = ci.getValue(colFamily, qualifier, kv);\n            }\n          }\n      } while (results != null && results.length > 0);\n    } finally {\n      if (scanner != null) {\n        scanner.close();\n      }\n      if (table != null) {\n        table.close();\n      }\n    }\n    return null;\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * It gives the row count, by summing up the individual results obtained from\n   * regions. In case the qualifier is null, FirstKEyValueFilter is used to\n   * optimised the operation. In case qualifier is provided, I can't use the\n   * filter as it may set the flag to skip to next row, but the value read is\n   * not of the given filter: in this case, this particular row will not be\n   * counted ==> an error.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return <R, S>\n   * @throws Throwable\n   */\n  public <R, S> long rowCount(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class RowNumCallback implements Batch.Callback<Long> {\n      private final AtomicLong rowCountL = new AtomicLong(0);\n\n      public long getRowNumCount() {\n        return rowCountL.get();\n      }\n\n      @Override\n      public void update(byte[] region, byte[] row, Long result) {\n        rowCountL.addAndGet(result.longValue());\n      }\n    }\n    RowNumCallback rowNum = new RowNumCallback();\n    HTable table = new HTable(conf, tableName);\n    table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(), scan\n        .getStopRow(), new Batch.Call<AggregateProtocol, Long>() {\n      @Override\n      public Long call(AggregateProtocol instance) throws IOException {\n        return instance.getRowNum(ci, scan);\n      }\n    }, rowNum);\n    return rowNum.getRowNumCount();\n  }","id":81501,"modified_method":"/**\n   * It gives the row count, by summing up the individual results obtained from\n   * regions. In case the qualifier is null, FirstKEyValueFilter is used to\n   * optimised the operation. In case qualifier is provided, I can't use the\n   * filter as it may set the flag to skip to next row, but the value read is\n   * not of the given filter: in this case, this particular row will not be\n   * counted ==> an error.\n   * @param tableName\n   * @param ci\n   * @param scan\n   * @return <R, S>\n   * @throws Throwable\n   */\n  public <R, S> long rowCount(final byte[] tableName,\n      final ColumnInterpreter<R, S> ci, final Scan scan) throws Throwable {\n    validateParameters(scan);\n    class RowNumCallback implements Batch.Callback<Long> {\n      private final AtomicLong rowCountL = new AtomicLong(0);\n\n      public long getRowNumCount() {\n        return rowCountL.get();\n      }\n\n      @Override\n      public void update(byte[] region, byte[] row, Long result) {\n        rowCountL.addAndGet(result.longValue());\n      }\n    }\n    RowNumCallback rowNum = new RowNumCallback();\n    HTable table = null;\n    try {\n      table = new HTable(conf, tableName);\n      table.coprocessorExec(AggregateProtocol.class, scan.getStartRow(),\n          scan.getStopRow(), new Batch.Call<AggregateProtocol, Long>() {\n            @Override\n            public Long call(AggregateProtocol instance) throws IOException {\n              return instance.getRowNum(ci, scan);\n            }\n          }, rowNum);\n    } finally {\n      if (table != null) {\n        table.close();\n      }\n    }\n    return rowNum.getRowNumCount();\n  }","commit_id":"bbe0d87f8f674835d71ae25816c4278a7b4785b3","url":"https://github.com/apache/hbase"},{"original_method":"public AddWMSLayerPanel() {\n        JPanel imageryAddPanel = new JPanel(new GridBagLayout());\n        imageryAddPanel.add(new JLabel(tr(\"Menu Name\")), GBC.std().insets(0,0,5,0));\n        menuName = new JTextField(40);\n        menuName.setText(tr(\"Unnamed Imagery Layer\"));\n        imageryAddPanel.add(menuName, GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n\n        final JTabbedPane tabbedPane = new JTabbedPane();\n\n        final JPanel wmsFetchPanel = new JPanel(new GridBagLayout());\n        tabbedPane.addTab(tr(\"WMS\"), wmsFetchPanel);\n        imageryAddPanel.add(tabbedPane, GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n\n        final JTextArea serviceUrlText = new JTextArea(3, 40);\n        serviceUrlText.setLineWrap(true);\n        serviceUrlText.setText(\"http://sample.com/wms?\");\n        wmsFetchPanel.add(new JLabel(tr(\"Service URL\")), GBC.std().insets(0,0,5,0));\n        JScrollPane scrollPane = new JScrollPane(serviceUrlText,\n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        wmsFetchPanel.add(scrollPane, GBC.eop().insets(5,0,0,0));\n        JButton getLayersButton = new JButton(tr(\"Get Layers\"));\n        getLayersButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                Cursor beforeCursor = getCursor();\n                try {\n                    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                    attemptGetCapabilities(sanitize(serviceUrlText.getText()));\n                } finally {\n                    setCursor(beforeCursor);\n                }\n            }\n        });\n        wmsFetchPanel.add(getLayersButton, GBC.eop().anchor(GridBagConstraints.EAST));\n\n        treeRootNode = new DefaultMutableTreeNode();\n        treeData = new DefaultTreeModel(treeRootNode);\n        layerTree = new JTree(treeData);\n        layerTree.setCellRenderer(new LayerTreeCellRenderer());\n        layerTree.addTreeSelectionListener(new TreeSelectionListener() {\n\n            @Override\n            public void valueChanged(TreeSelectionEvent e) {\n                TreePath[] selectionRows = layerTree.getSelectionPaths();\n                if(selectionRows == null) {\n                    showBoundsButton.setEnabled(false);\n                    selectedLayer = null;\n                    return;\n                }\n\n                selectedLayers = new LinkedList<LayerDetails>();\n                for (TreePath i : selectionRows) {\n                    Object userObject = ((DefaultMutableTreeNode) i.getLastPathComponent()).getUserObject();\n                    if(userObject instanceof LayerDetails) {\n                        LayerDetails detail = (LayerDetails) userObject;\n                        if(!detail.isSupported()) {\n                            layerTree.removeSelectionPath(i);\n                            if(!previouslyShownUnsupportedCrsError) {\n                                JOptionPane.showMessageDialog(null, tr(\"That layer does not support any of JOSM''s projections,\\n\" +\n                                \"so you can not use it. This message will not show again.\"),\n                                tr(\"WMS Error\"), JOptionPane.ERROR_MESSAGE);\n                                previouslyShownUnsupportedCrsError = true;\n                            }\n                        } else if(detail.ident != null) {\n                            selectedLayers.add(detail);\n                        }\n                    }\n                }\n\n                if (!selectedLayers.isEmpty()) {\n                    resultingLayerField.setText(buildGetMapUrl());\n\n                    if(selectedLayers.size() == 1) {\n                        showBoundsButton.setEnabled(true);\n                        selectedLayer = selectedLayers.get(0);\n                    }\n                } else {\n                    showBoundsButton.setEnabled(false);\n                    selectedLayer = null;\n                }\n            }\n        });\n        wmsFetchPanel.add(new JScrollPane(layerTree), GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n\n        JPanel layerManipulationButtons = new JPanel();\n        showBoundsButton = new JButton(tr(\"Show Bounds\"));\n        showBoundsButton.setEnabled(false);\n        showBoundsButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if(selectedLayer.bounds != null) {\n                    SlippyMapBBoxChooser mapPanel = new SlippyMapBBoxChooser();\n                    mapPanel.setBoundingBox(selectedLayer.bounds);\n                    JOptionPane.showMessageDialog(null, mapPanel, tr(\"Show Bounds\"), JOptionPane.PLAIN_MESSAGE);\n                } else {\n                    JOptionPane.showMessageDialog(null, tr(\"No bounding box was found for this layer.\"),\n                            tr(\"WMS Error\"), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n        });\n        layerManipulationButtons.add(showBoundsButton);\n\n        wmsFetchPanel.add(layerManipulationButtons, GBC.eol().insets(0,0,5,0));\n\n        final JPanel tmsView = new JPanel(new GridBagLayout());\n        tmsView.add(new JLabel(tr(\"TMS URL\")), GBC.std().insets(0,0,5,0));\n        tmsURL = new JTextArea(3, 40);\n        tmsURL.setLineWrap(true);\n        tmsURL.setText(\"http://sample.com/tms/{zoom}/{x}/{y}.jpg\");\n        tmsURL.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyReleased(KeyEvent e) {\n                resultingLayerField.setText(buildTMSUrl());\n            }\n        });\n        JScrollPane tmsUrlScrollPane = new JScrollPane(tmsURL,\n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        tmsView.add(tmsUrlScrollPane, GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n        tmsView.add(new JLabel(trc(\"layer\", \"Zoom\")), GBC.std().insets(0,0,5,0));\n        tmsZoom = new JTextField(3);\n        tmsZoom.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyReleased(KeyEvent e) {\n                resultingLayerField.setText(buildTMSUrl());\n            }\n        });\n        tmsView.add(tmsZoom, GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n        tabbedPane.addTab(tr(\"TMS\"), tmsView);\n\n        imageryAddPanel.add(new JLabel(tr(\"Imagery URL\")), GBC.std().insets(0,0,5,0));\n        resultingLayerField = new JTextArea(3, 40);\n        resultingLayerField.setLineWrap(true);\n        imageryAddPanel.add(new JScrollPane(resultingLayerField, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER), GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n\n        tabbedPane.addChangeListener(new ChangeListener() {\n            @Override\n            public void stateChanged(ChangeEvent e) {\n                Component sel = tabbedPane.getSelectedComponent();\n                if(tmsView == sel) {\n                    resultingLayerField.setText(buildTMSUrl());\n                } else if(wmsFetchPanel == sel) {\n                    if(serviceUrl != null) {\n                        resultingLayerField.setText(buildGetMapUrl());\n                    }\n                }\n            }\n        });\n\n        add(imageryAddPanel);\n    }","id":81502,"modified_method":"public AddWMSLayerPanel() {\n        super(new GridBagLayout());\n        add(new JLabel(tr(\"Menu Name\")), GBC.std().insets(0,0,5,0));\n        menuName = new JTextField(40);\n        menuName.setText(tr(\"Unnamed Imagery Layer\"));\n        add(menuName, GBC.eop().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n\n        final JTabbedPane tabbedPane = new JTabbedPane();\n\n        final JPanel wmsFetchPanel = new JPanel(new GridBagLayout());\n        tabbedPane.addTab(tr(\"WMS\"), wmsFetchPanel);\n        add(tabbedPane, GBC.eop().insets(5,0,0,0).weight(1.0, 1.0).fill(GridBagConstraints.BOTH));\n\n        final JTextArea serviceUrlText = new JTextArea(3, 40);\n        serviceUrlText.setLineWrap(true);\n        serviceUrlText.setText(\"http://sample.com/wms?\");\n        wmsFetchPanel.add(new JLabel(tr(\"Service URL\")), GBC.std().insets(0,0,5,0));\n        JScrollPane scrollPane = new JScrollPane(serviceUrlText,\n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        scrollPane.setMinimumSize(new Dimension(60, 60));\n        wmsFetchPanel.add(scrollPane, GBC.eol().weight(1.0, 0.0).insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n        JButton getLayersButton = new JButton(tr(\"Get Layers\"));\n        getLayersButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                Cursor beforeCursor = getCursor();\n                try {\n                    setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                    attemptGetCapabilities(sanitize(serviceUrlText.getText()));\n                } finally {\n                    setCursor(beforeCursor);\n                }\n            }\n        });\n        wmsFetchPanel.add(getLayersButton, GBC.eop().anchor(GridBagConstraints.EAST));\n\n        treeRootNode = new DefaultMutableTreeNode();\n        treeData = new DefaultTreeModel(treeRootNode);\n        layerTree = new JTree(treeData);\n        layerTree.setCellRenderer(new LayerTreeCellRenderer());\n        layerTree.addTreeSelectionListener(new TreeSelectionListener() {\n\n            @Override\n            public void valueChanged(TreeSelectionEvent e) {\n                TreePath[] selectionRows = layerTree.getSelectionPaths();\n                if(selectionRows == null) {\n                    showBoundsButton.setEnabled(false);\n                    selectedLayer = null;\n                    return;\n                }\n\n                selectedLayers = new LinkedList<LayerDetails>();\n                for (TreePath i : selectionRows) {\n                    Object userObject = ((DefaultMutableTreeNode) i.getLastPathComponent()).getUserObject();\n                    if(userObject instanceof LayerDetails) {\n                        LayerDetails detail = (LayerDetails) userObject;\n                        if(!detail.isSupported()) {\n                            layerTree.removeSelectionPath(i);\n                            if(!previouslyShownUnsupportedCrsError) {\n                                JOptionPane.showMessageDialog(null, tr(\"That layer does not support any of JOSM''s projections,\\n\" +\n                                \"so you can not use it. This message will not show again.\"),\n                                tr(\"WMS Error\"), JOptionPane.ERROR_MESSAGE);\n                                previouslyShownUnsupportedCrsError = true;\n                            }\n                        } else if(detail.ident != null) {\n                            selectedLayers.add(detail);\n                        }\n                    }\n                }\n\n                if (!selectedLayers.isEmpty()) {\n                    resultingLayerField.setText(buildGetMapUrl());\n\n                    if(selectedLayers.size() == 1) {\n                        showBoundsButton.setEnabled(true);\n                        selectedLayer = selectedLayers.get(0);\n                    }\n                } else {\n                    showBoundsButton.setEnabled(false);\n                    selectedLayer = null;\n                }\n            }\n        });\n        wmsFetchPanel.add(new JScrollPane(layerTree), GBC.eol().weight(1.0, 1.0).insets(5,0,0,0).fill(GridBagConstraints.BOTH));\n\n        JPanel layerManipulationButtons = new JPanel();\n        showBoundsButton = new JButton(tr(\"Show Bounds\"));\n        showBoundsButton.setEnabled(false);\n        showBoundsButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if(selectedLayer.bounds != null) {\n                    SlippyMapBBoxChooser mapPanel = new SlippyMapBBoxChooser();\n                    mapPanel.setBoundingBox(selectedLayer.bounds);\n                    JOptionPane.showMessageDialog(null, mapPanel, tr(\"Show Bounds\"), JOptionPane.PLAIN_MESSAGE);\n                } else {\n                    JOptionPane.showMessageDialog(null, tr(\"No bounding box was found for this layer.\"),\n                            tr(\"WMS Error\"), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n        });\n        layerManipulationButtons.add(showBoundsButton);\n\n        wmsFetchPanel.add(layerManipulationButtons, GBC.eol().insets(0,0,5,0));\n\n        final JPanel tmsView = new JPanel(new GridBagLayout());\n        tmsView.add(new JLabel(tr(\"TMS URL\")), GBC.std().insets(0,0,5,0));\n        tmsURL = new JTextArea(3, 40);\n        tmsURL.setLineWrap(true);\n        tmsURL.setText(\"http://sample.com/tms/{zoom}/{x}/{y}.jpg\");\n        tmsURL.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyReleased(KeyEvent e) {\n                resultingLayerField.setText(buildTMSUrl());\n            }\n        });\n        JScrollPane tmsUrlScrollPane = new JScrollPane(tmsURL,\n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        tmsUrlScrollPane.setMinimumSize(new Dimension(60, 60));\n        tmsView.add(tmsUrlScrollPane, GBC.eol().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n        tmsView.add(new JLabel(trc(\"layer\", \"Zoom\")), GBC.std().insets(0,0,5,0));\n        tmsZoom = new JTextField(3);\n        tmsZoom.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyReleased(KeyEvent e) {\n                resultingLayerField.setText(buildTMSUrl());\n            }\n        });\n        tmsView.add(tmsZoom, GBC.eol().insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n        tmsView.add(new JLabel(), GBC.eop().weight(1.0, 1.0).fill(GridBagConstraints.BOTH));\n        tabbedPane.addTab(tr(\"TMS\"), tmsView);\n\n        add(new JLabel(tr(\"Imagery URL\")), GBC.std().insets(0,0,5,0));\n        resultingLayerField = new JTextArea(3, 40);\n        resultingLayerField.setLineWrap(true);\n        JScrollPane bottomScrollPane = new JScrollPane(resultingLayerField, \n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n        bottomScrollPane.setMinimumSize(new Dimension(60, 60));\n        add(bottomScrollPane, GBC.eol().weight(1.0, 0.0).insets(5,0,0,0).fill(GridBagConstraints.HORIZONTAL));\n\n        tabbedPane.addChangeListener(new ChangeListener() {\n            @Override\n            public void stateChanged(ChangeEvent e) {\n                Component sel = tabbedPane.getSelectedComponent();\n                if(tmsView == sel) {\n                    resultingLayerField.setText(buildTMSUrl());\n                } else if(wmsFetchPanel == sel) {\n                    if(serviceUrl != null) {\n                        resultingLayerField.setText(buildGetMapUrl());\n                    }\n                }\n            }\n        });\n    }","commit_id":"8fb969e2d2eacc4111bfc96c75fe5b9bc92ff98c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent evt) {\n                AddWMSLayerPanel p = new AddWMSLayerPanel();\n                int answer = JOptionPane.showConfirmDialog(\n                        gui, p,\n                        tr(\"Add Imagery URL\"),\n                        JOptionPane.OK_CANCEL_OPTION);\n                if (answer == JOptionPane.OK_OPTION) {\n                    model.addRow(new ImageryInfo(p.getUrlName(), p.getUrl()));\n                }\n            }","id":81503,"modified_method":"public void actionPerformed(ActionEvent evt) {\n                final AddWMSLayerPanel p = new AddWMSLayerPanel();\n                // This code snippet allows to resize the JOptionPane (fix #6090)\n                p.addHierarchyListener(new HierarchyListener() {\n                    public void hierarchyChanged(HierarchyEvent e) {\n                        Window window = SwingUtilities.getWindowAncestor(p);\n                        if (window instanceof Dialog) {\n                            Dialog dialog = (Dialog)window;\n                            if (!dialog.isResizable()) {\n                                dialog.setResizable(true);\n                                dialog.setMinimumSize(new Dimension(250, 350));\n                            }\n                        }\n                    }\n                });\n                int answer = JOptionPane.showConfirmDialog(\n                        gui, p,\n                        tr(\"Add Imagery URL\"),\n                        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);\n                if (answer == JOptionPane.OK_OPTION) {\n                    model.addRow(new ImageryInfo(p.getUrlName(), p.getUrl()));\n                }\n            }","commit_id":"8fb969e2d2eacc4111bfc96c75fe5b9bc92ff98c","url":"https://github.com/openstreetmap/josm"},{"original_method":"private static void askForBugReport(final Throwable e) {\n        try {\n            final int maxlen = 6000;\n            StringWriter stack = new StringWriter();\n            e.printStackTrace(new PrintWriter(stack));\n\n            String text = ShowStatusReportAction.getReportHeader() + stack.getBuffer().toString();\n            String urltext = text.replaceAll(\"\\r\",\"\");\n            if (urltext.length() > maxlen) {\n                urltext = urltext.substring(0,maxlen);\n                int idx = urltext.lastIndexOf('\\n');\n                // cut whole line when not loosing too much\n                if (maxlen-idx < 200) {\n                    urltext = urltext.substring(0,idx+1);\n                }\n                urltext += \"...<snip>...\\n\";\n            }\n\n            JPanel p = new JPanel(new GridBagLayout());\n            p.add(new JMultilineLabel(\n                    tr(\"You have encountered an error in JOSM. Before you file a bug report \" +\n                            \"make sure you have updated to the latest version of JOSM here:\")), GBC.eol());\n            p.add(new UrlLabel(Main.getJOSMWebsite(),2), GBC.eop().insets(8,0,0,0));\n            p.add(new JMultilineLabel(\n                    tr(\"You should also update your plugins. If neither of those help please \" +\n                            \"file a bug report in our bugtracker using this link:\")), GBC.eol());\n            p.add(getBugReportUrlLabel(urltext), GBC.eop().insets(8,0,0,0));\n            p.add(new JMultilineLabel(\n                    tr(\"There the error information provided below should already be \" +\n                            \"filled in for you. Please include information on how to reproduce \" +\n                            \"the error and try to supply as much detail as possible.\")), GBC.eop());\n            p.add(new JMultilineLabel(\n                    tr(\"Alternatively, if that does not work you can manually fill in the information \" +\n                            \"below at this URL:\")), GBC.eol());\n            p.add(new UrlLabel(Main.getJOSMWebsite()+\"/newticket\",2), GBC.eop().insets(8,0,0,0));\n            if (Utils.copyToClipboard(text)) {\n                p.add(new JLabel(tr(\"(The text has already been copied to your clipboard.)\")), GBC.eop());\n            }\n\n            JosmTextArea info = new JosmTextArea(text, 18, 60);\n            info.setCaretPosition(0);\n            info.setEditable(false);\n            p.add(new JScrollPane(info), GBC.eop().fill());\n\n            for (Component c: p.getComponents()) {\n                if (c instanceof JMultilineLabel) {\n                    ((JMultilineLabel)c).setMaxWidth(400);\n                }\n            }\n\n            JOptionPane.showMessageDialog(Main.parent, p, tr(\"You have encountered a bug in JOSM\"), JOptionPane.ERROR_MESSAGE);\n        } catch (Exception e1) {\n            Main.error(e1);\n        }\n    }","id":81504,"modified_method":"private static void askForBugReport(final Throwable e) {\n        try {\n            final int maxlen = 6000;\n            StringWriter stack = new StringWriter();\n            e.printStackTrace(new PrintWriter(stack));\n\n            String text = ShowStatusReportAction.getReportHeader() + stack.getBuffer().toString();\n            String urltext = text.replaceAll(\"\\r\",\"\");\n            if (urltext.length() > maxlen) {\n                urltext = urltext.substring(0,maxlen);\n                int idx = urltext.lastIndexOf('\\n');\n                // cut whole line when not loosing too much\n                if (maxlen-idx < 200) {\n                    urltext = urltext.substring(0,idx+1);\n                }\n                urltext += \"...<snip>...\\n\";\n            }\n\n            JPanel p = new JPanel(new GridBagLayout());\n            p.add(new JMultilineLabel(\n                    tr(\"You have encountered an error in JOSM. Before you file a bug report \" +\n                            \"make sure you have updated to the latest version of JOSM here:\")),\n                            GBC.eol().fill(GridBagConstraints.HORIZONTAL));\n            p.add(new UrlLabel(Main.getJOSMWebsite(),2), GBC.eop().insets(8,0,0,0));\n            p.add(new JMultilineLabel(\n                    tr(\"You should also update your plugins. If neither of those help please \" +\n                            \"file a bug report in our bugtracker using this link:\")),\n                            GBC.eol().fill(GridBagConstraints.HORIZONTAL));\n            p.add(getBugReportUrlLabel(urltext), GBC.eop().insets(8,0,0,0));\n            p.add(new JMultilineLabel(\n                    tr(\"There the error information provided below should already be \" +\n                            \"filled in for you. Please include information on how to reproduce \" +\n                            \"the error and try to supply as much detail as possible.\")),\n                            GBC.eop().fill(GridBagConstraints.HORIZONTAL));\n            p.add(new JMultilineLabel(\n                    tr(\"Alternatively, if that does not work you can manually fill in the information \" +\n                            \"below at this URL:\")), GBC.eol().fill(GridBagConstraints.HORIZONTAL));\n            p.add(new UrlLabel(Main.getJOSMWebsite()+\"/newticket\",2), GBC.eop().insets(8,0,0,0));\n            if (Utils.copyToClipboard(text)) {\n                p.add(new JLabel(tr(\"(The text has already been copied to your clipboard.)\")),\n                        GBC.eop().fill(GridBagConstraints.HORIZONTAL));\n            }\n\n            JosmTextArea info = new JosmTextArea(text, 18, 60);\n            info.setCaretPosition(0);\n            info.setEditable(false);\n            p.add(new JScrollPane(info), GBC.eop().fill());\n\n            for (Component c: p.getComponents()) {\n                if (c instanceof JMultilineLabel) {\n                    ((JMultilineLabel)c).setMaxWidth(400);\n                }\n            }\n\n            JOptionPane.showMessageDialog(Main.parent, p, tr(\"You have encountered a bug in JOSM\"), JOptionPane.ERROR_MESSAGE);\n        } catch (Exception e1) {\n            Main.error(e1);\n        }\n    }","commit_id":"5c78bcd5035adbe23167c3a4e6d934025011148a","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected int execute() {\n        final boolean TEST_ROD = false;\n        List<ReferenceOrderedData<? extends ReferenceOrderedDatum> > rods = new ArrayList<ReferenceOrderedData<? extends ReferenceOrderedDatum> >();\n\n        //\n        // please don't use these in the future, use the new syntax\n        //\n        if ( DBSNP_FILE != null )               bindConvenienceRods(\"dbSNP\", \"dbsnp\", DBSNP_FILE);\n        if ( HAPMAP_FILE != null )              bindConvenienceRods(\"hapmap\", \"HapMapAlleleFrequencies\", HAPMAP_FILE);\n        if ( HAPMAP_CHIP_FILE != null )         bindConvenienceRods(\"hapmap-chip\", \"GFF\", HAPMAP_CHIP_FILE);\n\n        ReferenceOrderedData.parseBindings(logger, ROD_BINDINGS, rods);\n        \n        initializeOutputStreams();\n\n        Walker<?,?> my_walker = null;\n        try {\n            my_walker = walkerManager.createWalkerByName( Analysis_Name );\n        }\n        catch( InstantiationException ex ) {\n            throw new RuntimeException( \"Unable to instantiate walker.\", ex );\n        }\n        catch( IllegalAccessException ex ) {\n            throw new RuntimeException( \"Unable to access walker\", ex );\n        }\n\n        MicroManager microManager = null;\n\n        // Get the walker specified\n        if ( my_walker instanceof LocusWalker ) {\n            LocusWalker<?, ?> walker = (LocusWalker<?, ?>) my_walker;\n\n            if ( REF_FILE_ARG == null )\n                Utils.scareUser(String.format(\"Locus-based traversals require a reference file but none was given\"));\n\n            if ( INPUT_FILES == null || INPUT_FILES.size() == 0 ) {\n                if ( walker.requiresReads() )\n                    Utils.scareUser(String.format(\"Analysis %s requires reads, but none were given\", Analysis_Name));\n                this.engine = new TraverseByReference(null, REF_FILE_ARG, rods);\n            } else {\n                if ( walker.cannotHandleReads() )\n                    Utils.scareUser(String.format(\"Analysis %s doesn't support SAM/BAM reads, but a read file %s was provided\", Analysis_Name, INPUT_FILES));\n\n                if ( WALK_ALL_LOCI ) {\n                    // TODO: Temporary debugging code.  Activate the new debugging code only when the MicroManager\n                    //                                  is not filtered.\n                    if( !DISABLE_THREADING ) {\n                        logger.warn(\"Preliminary threading support ENABLED\");\n                        microManager = new MicroManager( INPUT_FILES, REF_FILE_ARG, numThreads );\n                        this.engine = microManager.getTraversalEngine();\n                    }\n                    else {\n                        logger.warn(\"Preliminary threading support DISABLED\");                        \n                        this.engine = new TraverseByLociByReference(INPUT_FILES, REF_FILE_ARG, rods);\n                    }\n                }\n                else\n                \tthis.engine = new TraverseByLoci(INPUT_FILES, REF_FILE_ARG, rods);\n            }\n        } else if ( my_walker instanceof LocusWindowWalker ) {\n            this.engine = new TraverseByLocusWindows(INPUT_FILES, REF_FILE_ARG, rods);\n        } else {\n            // we're a read walker\n            this.engine = new TraverseByReads(INPUT_FILES, REF_FILE_ARG, rods);\n        }\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        if (REF_FILE_ARG != null) {\n            final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(REF_FILE_ARG);\n            GenomeLoc.setupRefContigOrdering(refFile);\n        }\n\n        // Determine the validation stringency.  Default to ValidationStringency.STRICT.\n        ValidationStringency strictness;\n        try {\n            strictness = Enum.valueOf(ValidationStringency.class, STRICTNESS_ARG);\n        }\n        catch( IllegalArgumentException ex ) {\n            strictness = ValidationStringency.STRICT;\n        }\n\n        logger.info(\"Strictness is \" + strictness);\n        engine.setStrictness(strictness);\n\n        engine.setDebugging(!(DEBUGGING_STR == null || DEBUGGING_STR.toLowerCase().equals(\"true\")));\n        engine.setMaxReads(Integer.parseInt(MAX_READS_ARG));\n\n        if (REGION_STR != null) {\n            engine.setLocation(REGION_STR);\n        }\n\n        if (INTERVALS_FILE != null) {\n            engine.setLocationFromFile(INTERVALS_FILE);\n        }\n\n        if (MAX_ON_FLY_SORTS != null) {\n            engine.setSortOnFly(Integer.parseInt(MAX_ON_FLY_SORTS));\n        }\n\n        if (DOWNSAMPLE_FRACTION != null) {\n            engine.setDownsampleByFraction(Double.parseDouble(DOWNSAMPLE_FRACTION));\n        }\n\n        if (DOWNSAMPLE_COVERAGE != null) {\n            engine.setDownsampleByCoverage(Integer.parseInt(DOWNSAMPLE_COVERAGE));\n        }\n\n        engine.setSafetyChecking(!UNSAFE);\n        engine.setThreadedIO(ENABLED_THREADED_IO);\n        engine.setWalkOverAllSites(WALK_ALL_LOCI);\n        engine.initialize();\n\n        if( microManager != null ) {\n            List<GenomeLoc> locs;\n            if (INTERVALS_FILE != null) {\n                locs = GenomeLoc.IntervalFileToList(INTERVALS_FILE);\n                microManager.setIntervalList(locs);\n            } else {\n                locs = GenomeLoc.parseGenomeLocs( REGION_STR );\n            }\n            microManager.execute( my_walker, locs );\n        }\n        else\n            engine.traverse(my_walker);\n\n        return 0;\n    }","id":81505,"modified_method":"protected int execute() {\n        final boolean TEST_ROD = false;\n        List<ReferenceOrderedData<? extends ReferenceOrderedDatum> > rods = new ArrayList<ReferenceOrderedData<? extends ReferenceOrderedDatum> >();\n\n        //\n        // please don't use these in the future, use the new syntax\n        //\n        if ( DBSNP_FILE != null )               bindConvenienceRods(\"dbSNP\", \"dbsnp\", DBSNP_FILE);\n        if ( HAPMAP_FILE != null )              bindConvenienceRods(\"hapmap\", \"HapMapAlleleFrequencies\", HAPMAP_FILE);\n        if ( HAPMAP_CHIP_FILE != null )         bindConvenienceRods(\"hapmap-chip\", \"GFF\", HAPMAP_CHIP_FILE);\n\n        ReferenceOrderedData.parseBindings(logger, ROD_BINDINGS, rods);\n        \n        initializeOutputStreams();\n\n        Walker<?,?> my_walker = null;\n        try {\n            my_walker = walkerManager.createWalkerByName( Analysis_Name );\n        }\n        catch( InstantiationException ex ) {\n            throw new RuntimeException( \"Unable to instantiate walker.\", ex );\n        }\n        catch( IllegalAccessException ex ) {\n            throw new RuntimeException( \"Unable to access walker\", ex );\n        }\n\n        MicroScheduler microScheduler = null;\n\n        // Get the walker specified\n        if ( my_walker instanceof LocusWalker ) {\n            LocusWalker<?, ?> walker = (LocusWalker<?, ?>) my_walker;\n\n            if ( REF_FILE_ARG == null )\n                Utils.scareUser(String.format(\"Locus-based traversals require a reference file but none was given\"));\n\n            if ( INPUT_FILES == null || INPUT_FILES.size() == 0 ) {\n                if ( walker.requiresReads() )\n                    Utils.scareUser(String.format(\"Analysis %s requires reads, but none were given\", Analysis_Name));\n                this.engine = new TraverseByReference(null, REF_FILE_ARG, rods);\n            } else {\n                if ( walker.cannotHandleReads() )\n                    Utils.scareUser(String.format(\"Analysis %s doesn't support SAM/BAM reads, but a read file %s was provided\", Analysis_Name, INPUT_FILES));\n\n                if ( WALK_ALL_LOCI ) {\n                    // TODO: Temporary debugging code.  Activate the new debugging code only when the MicroManager\n                    //                                  is not filtered.\n                    if( !DISABLE_THREADING ) {\n                        logger.warn(\"Preliminary threading support ENABLED\");\n                        microScheduler = new LinearMicroManager( INPUT_FILES, REF_FILE_ARG, numThreads );\n                        this.engine = microScheduler.getTraversalEngine();\n                    }\n                    else {\n                        logger.warn(\"Preliminary threading support DISABLED\");                        \n                        this.engine = new TraverseByLociByReference(INPUT_FILES, REF_FILE_ARG, rods);\n                    }\n                }\n                else\n                \tthis.engine = new TraverseByLoci(INPUT_FILES, REF_FILE_ARG, rods);\n            }\n        } else if ( my_walker instanceof LocusWindowWalker ) {\n            this.engine = new TraverseByLocusWindows(INPUT_FILES, REF_FILE_ARG, rods);\n        } else {\n            // we're a read walker\n            this.engine = new TraverseByReads(INPUT_FILES, REF_FILE_ARG, rods);\n        }\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        if (REF_FILE_ARG != null) {\n            final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(REF_FILE_ARG);\n            GenomeLoc.setupRefContigOrdering(refFile);\n        }\n\n        // Determine the validation stringency.  Default to ValidationStringency.STRICT.\n        ValidationStringency strictness;\n        try {\n            strictness = Enum.valueOf(ValidationStringency.class, STRICTNESS_ARG);\n        }\n        catch( IllegalArgumentException ex ) {\n            strictness = ValidationStringency.STRICT;\n        }\n\n        logger.info(\"Strictness is \" + strictness);\n        engine.setStrictness(strictness);\n\n        engine.setDebugging(!(DEBUGGING_STR == null || DEBUGGING_STR.toLowerCase().equals(\"true\")));\n        engine.setMaxReads(Integer.parseInt(MAX_READS_ARG));\n\n        if (REGION_STR != null) {\n            engine.setLocation(REGION_STR);\n        }\n\n        if (INTERVALS_FILE != null) {\n            engine.setLocationFromFile(INTERVALS_FILE);\n        }\n\n        if (MAX_ON_FLY_SORTS != null) {\n            engine.setSortOnFly(Integer.parseInt(MAX_ON_FLY_SORTS));\n        }\n\n        if (DOWNSAMPLE_FRACTION != null) {\n            engine.setDownsampleByFraction(Double.parseDouble(DOWNSAMPLE_FRACTION));\n        }\n\n        if (DOWNSAMPLE_COVERAGE != null) {\n            engine.setDownsampleByCoverage(Integer.parseInt(DOWNSAMPLE_COVERAGE));\n        }\n\n        engine.setSafetyChecking(!UNSAFE);\n        engine.setThreadedIO(ENABLED_THREADED_IO);\n        engine.setWalkOverAllSites(WALK_ALL_LOCI);\n        engine.initialize();\n\n        if( microScheduler != null ) {\n            List<GenomeLoc> locs = GenomeLoc.parseGenomeLocs( REGION_STR );\n            microScheduler.execute( my_walker, locs );\n        }\n        else\n            engine.traverse(my_walker);\n\n        return 0;\n    }","commit_id":"4036f2490913b9afa2c8a88ddbcdd68300df93b5","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Load the intervals directly from the command-line or from file, as appropriate.\n     * Merge overlapping intervals.\n     * @param intervalsSource Source of intervals.\n     * @return a queue of sorted, merged intervals.\n     */\n    private Queue parseIntervals( String intervalsSource ) {\n        List<GenomeLoc> parsedIntervals = GenomeAnalysisEngine.parseIntervalRegion(intervalsSource,false);\n        GenomeLocSortedSet intervalSortedSet = new GenomeLocSortedSet();\n        for( GenomeLoc parsedInterval: parsedIntervals )\n            intervalSortedSet.addRegion(parsedInterval);\n\n        return new LinkedList<GenomeLoc>( intervalSortedSet );        \n    }","id":81506,"modified_method":"/**\n     * Load the intervals directly from the command-line or from file, as appropriate.\n     * Merge overlapping intervals.\n     * @param intervalsSource Source of intervals.\n     * @return a queue of sorted, merged intervals.\n     */\n    private Queue parseIntervals( List<String> intervalsSource ) {\n        List<GenomeLoc> parsedIntervals = GenomeAnalysisEngine.parseIntervalRegion(intervalsSource);\n        GenomeLocSortedSet intervalSortedSet = new GenomeLocSortedSet();\n        for( GenomeLoc parsedInterval: parsedIntervals )\n            intervalSortedSet.addRegion(parsedInterval);\n\n        return new LinkedList<GenomeLoc>( intervalSortedSet );        \n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"private CleanedReadInjector createWalker( String intervals, ArtificialSAMFileReader cleanedReads, ArtificialSAMFileWriter output ) {\n        CleanedReadInjector walker = new CleanedReadInjector();\n\n        walker.intervalsSource = intervals;        \n        walker.cleanedReadsSource = cleanedReads;\n        walker.outputBAM = output;\n\n        walker.initializeOutputStreams( new OutputTracker(null,null) );\n\n        return walker;\n    }","id":81507,"modified_method":"private CleanedReadInjector createWalker( String intervals, ArtificialSAMFileReader cleanedReads, ArtificialSAMFileWriter output ) {\n        CleanedReadInjector walker = new CleanedReadInjector();\n\n        walker.intervalsSource = Collections.singletonList(intervals);        \n        walker.cleanedReadsSource = cleanedReads;\n        walker.outputBAM = output;\n\n        walker.initializeOutputStreams( new OutputTracker(null,null) );\n\n        return walker;\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void setupCollection() {\n        // parameters and their defaults\n        Map<String, String> wArgs = new HashMap<String, String>();\n        wArgs.put(\"wArgType1\", \"Arg1\");\n        wArgs.put(\"wArgType2\", \"Arg2\");\n        wArgs.put(\"wArgType3\", \"Arg3\");\n        collect.walkerArgs = wArgs;\n\n        List<File> input = new ArrayList<File>();\n        input.add(new File(\"test.file\"));\n        collect.samFiles = input;\n        collect.maximumEngineIterations = -1;\n        collect.strictnessLevel = \"strict\";\n        collect.referenceFile = new File(\"referenceFile\".toLowerCase());\n        collect.analysisName = \"analysisName\".toLowerCase();\n        collect.DBSNPFile = \"DBSNPFile\".toLowerCase();\n        collect.HAPMAPFile = \"HAPMAPFile\".toLowerCase();\n        collect.HAPMAPChipFile = \"HAPMAPChipFile\".toLowerCase();\n        collect.enabledThreadedIO = true;\n        collect.unsafe = false;\n        collect.maximumReadSorts = null;\n        collect.downsampleFraction = null;\n        collect.downsampleCoverage = null;\n        collect.intervals = \"intervals\".toLowerCase();\n        collect.walkAllLoci = true;\n        collect.disableThreading = false;\n        collect.outFileName = \"outFileName\".toLowerCase();\n        collect.errFileName = \"errFileName\".toLowerCase();\n        collect.outErrFileName = \"outErrFileName\".toLowerCase();\n        collect.numberOfThreads = 1;\n\n        // make some rod bindings up\n        ArrayList<String> fakeBindings = new ArrayList<String>();\n        fakeBindings.add(\"Bind1\");\n        fakeBindings.add(\"Bind2\");\n        fakeBindings.add(\"Bind3\");\n\n        collect.RODBindings = fakeBindings;\n    }","id":81508,"modified_method":"private void setupCollection() {\n        // parameters and their defaults\n        Map<String, String> wArgs = new HashMap<String, String>();\n        wArgs.put(\"wArgType1\", \"Arg1\");\n        wArgs.put(\"wArgType2\", \"Arg2\");\n        wArgs.put(\"wArgType3\", \"Arg3\");\n        collect.walkerArgs = wArgs;\n\n        List<File> input = new ArrayList<File>();\n        input.add(new File(\"test.file\"));\n        collect.samFiles = input;\n        collect.maximumEngineIterations = -1;\n        collect.strictnessLevel = \"strict\";\n        collect.referenceFile = new File(\"referenceFile\".toLowerCase());\n        collect.analysisName = \"analysisName\".toLowerCase();\n        collect.DBSNPFile = \"DBSNPFile\".toLowerCase();\n        collect.HAPMAPFile = \"HAPMAPFile\".toLowerCase();\n        collect.HAPMAPChipFile = \"HAPMAPChipFile\".toLowerCase();\n        collect.enabledThreadedIO = true;\n        collect.unsafe = false;\n        collect.maximumReadSorts = null;\n        collect.downsampleFraction = null;\n        collect.downsampleCoverage = null;\n        collect.intervals = new ArrayList<String>();\n        collect.intervals.add(\"intervals\".toLowerCase());\n        collect.walkAllLoci = true;\n        collect.disableThreading = false;\n        collect.outFileName = \"outFileName\".toLowerCase();\n        collect.errFileName = \"errFileName\".toLowerCase();\n        collect.outErrFileName = \"outErrFileName\".toLowerCase();\n        collect.numberOfThreads = 1;\n\n        // make some rod bindings up\n        ArrayList<String> fakeBindings = new ArrayList<String>();\n        fakeBindings.add(\"Bind1\");\n        fakeBindings.add(\"Bind2\");\n        fakeBindings.add(\"Bind3\");\n\n        collect.RODBindings = fakeBindings;\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * our constructor, where all the work is done\n     * <p/>\n     * legacy traversal types are sent to legacyTraversal function; as we move more of the traversals to the\n     * new MicroScheduler class we'll be able to delete that function.\n     *\n     * @param args      the argument collection, where we get all our setup information from\n     * @param my_walker the walker we're running with\n     */\n    public GenomeAnalysisEngine(GATKArgumentCollection args, Walker my_walker) {\n\n        // validate our parameters\n        if (args == null || my_walker == null) {\n            throw new StingException(\"Neither the GATKArgumentCollection or the Walker passed to GenomeAnalysisEngine can be null.\");\n        }\n\n        // save our argument parameter\n        this.argCollection = args;\n\n        // make sure our instance variable points to this analysis engine\n        instance = this;\n\n        // our reference ordered data collection\n        List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods = new ArrayList<ReferenceOrderedData<? extends ReferenceOrderedDatum>>();\n\n        //\n        // please don't use these in the future, use the new syntax <- if we're not using these please remove them\n        //\n        if (argCollection.DBSNPFile != null) bindConvenienceRods(\"dbSNP\", \"dbsnp\", argCollection.DBSNPFile);\n        if (argCollection.HAPMAPFile != null)\n            bindConvenienceRods(\"hapmap\", \"HapMapAlleleFrequencies\", argCollection.HAPMAPFile);\n        if (argCollection.HAPMAPChipFile != null)\n            bindConvenienceRods(\"hapmap-chip\", \"GFF\", argCollection.HAPMAPChipFile);\n        if ( argCollection.intervals != null )\n            bindConvenienceRods(\"interval\", \"Intervals\", argCollection.intervals.replaceAll(\",\", \"\"));\n\n        // parse out the rod bindings\n        ReferenceOrderedData.parseBindings(logger, argCollection.RODBindings, rods);\n\n        // Validate the walker inputs against the walker.\n        validateInputsAgainstWalker(my_walker, argCollection, rods);\n\n        // create the output streams\n        initializeOutputStreams( my_walker );\n\n        // our microscheduler, which is in charge of running everything\n        MicroScheduler microScheduler = null;\n\n        // if we're a read or a locus walker, we use the new system.  Right now we have complicated\n        // branching based on the input data, but this should disapear when all the traversals are switched over\n        if (!(my_walker instanceof LocusWindowWalker) && !args.useNewTraverseByLocusWindow) {\n            microScheduler = createMicroscheduler(my_walker, rods);\n        } else { // we have an old style traversal, once we're done return\n            legacyTraversal(my_walker, rods);\n            return;\n        }\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        if (argCollection.referenceFile != null) {\n            final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(argCollection.referenceFile);\n            GenomeLocParser.setupRefContigOrdering(refFile);\n        }\n\n        // Determine the validation stringency.  Default to ValidationStringency.STRICT.\n        ValidationStringency strictness = getValidationStringency();\n\n        logger.info(\"Strictness is \" + strictness);\n\n        // perform validation steps that are common to all the engines\n        genericEngineSetup();\n\n        // parse out any genomic location they've provided\n        //List<GenomeLoc> locationsList = setupIntervalRegion();\n        List<GenomeLoc> locationsList = engine.getLocations();        \n        GenomeLocSortedSet locs = null;\n        if (locationsList != null)\n            locs = GenomeLocSortedSet.createSetFromList(locationsList);\n\n        // excute the microscheduler, storing the results\n        walkerReturn = microScheduler.execute(my_walker, locs, argCollection.maximumEngineIterations);\n    }","id":81509,"modified_method":"/**\n     * our constructor, where all the work is done\n     * <p/>\n     * legacy traversal types are sent to legacyTraversal function; as we move more of the traversals to the\n     * new MicroScheduler class we'll be able to delete that function.\n     *\n     * @param args      the argument collection, where we get all our setup information from\n     * @param my_walker the walker we're running with\n     */\n    public GenomeAnalysisEngine(GATKArgumentCollection args, Walker my_walker) {\n\n        // validate our parameters\n        if (args == null || my_walker == null) {\n            throw new StingException(\"Neither the GATKArgumentCollection or the Walker passed to GenomeAnalysisEngine can be null.\");\n        }\n\n        // save our argument parameter\n        this.argCollection = args;\n\n        // make sure our instance variable points to this analysis engine\n        instance = this;\n\n        // our reference ordered data collection\n        List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods = new ArrayList<ReferenceOrderedData<? extends ReferenceOrderedDatum>>();\n\n        //\n        // please don't use these in the future, use the new syntax <- if we're not using these please remove them\n        //\n        if (argCollection.DBSNPFile != null) bindConvenienceRods(\"dbSNP\", \"dbsnp\", argCollection.DBSNPFile);\n        if (argCollection.HAPMAPFile != null)\n            bindConvenienceRods(\"hapmap\", \"HapMapAlleleFrequencies\", argCollection.HAPMAPFile);\n        if (argCollection.HAPMAPChipFile != null)\n            bindConvenienceRods(\"hapmap-chip\", \"GFF\", argCollection.HAPMAPChipFile);\n        // TODO: The ROD iterator currently does not understand multiple intervals file.  Fix this by cleaning the ROD system.\n        if ( argCollection.intervals != null && argCollection.intervals.size() == 1) {\n            bindConvenienceRods(\"interval\", \"Intervals\", argCollection.intervals.get(0).replaceAll(\",\", \"\"));\n        }\n\n        // parse out the rod bindings\n        ReferenceOrderedData.parseBindings(logger, argCollection.RODBindings, rods);\n\n        // Validate the walker inputs against the walker.\n        validateInputsAgainstWalker(my_walker, argCollection, rods);\n\n        // create the output streams\n        initializeOutputStreams( my_walker );\n\n        // our microscheduler, which is in charge of running everything\n        MicroScheduler microScheduler = null;\n\n        // if we're a read or a locus walker, we use the new system.  Right now we have complicated\n        // branching based on the input data, but this should disapear when all the traversals are switched over\n        if (!(my_walker instanceof LocusWindowWalker) && !args.useNewTraverseByLocusWindow) {\n            microScheduler = createMicroscheduler(my_walker, rods);\n        } else { // we have an old style traversal, once we're done return\n            legacyTraversal(my_walker, rods);\n            return;\n        }\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        if (argCollection.referenceFile != null) {\n            final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(argCollection.referenceFile);\n            GenomeLocParser.setupRefContigOrdering(refFile);\n        }\n\n        // Determine the validation stringency.  Default to ValidationStringency.STRICT.\n        ValidationStringency strictness = getValidationStringency();\n\n        logger.info(\"Strictness is \" + strictness);\n\n        // perform validation steps that are common to all the engines\n        genericEngineSetup();\n\n        // parse out any genomic location they've provided\n        //List<GenomeLoc> locationsList = setupIntervalRegion();\n        List<GenomeLoc> locationsList = engine.getLocations();        \n        GenomeLocSortedSet locs = null;\n        if (locationsList != null)\n            locs = GenomeLocSortedSet.createSetFromList(locationsList);\n\n        // excute the microscheduler, storing the results\n        walkerReturn = microScheduler.execute(my_walker, locs, argCollection.maximumEngineIterations);\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * setup the interval regions, from either the interval file of the genome region string\n     *\n     * @return a list of genomeLoc representing the interval file\n     */\n    public static List<GenomeLoc> parseIntervalRegion(final String intervalsString, boolean quiet ) {\n        List<GenomeLoc> locs = null;\n        if ( intervalsString != null) {\n            if (new File(intervalsString).exists()) {\n                if (! quiet) logger.info(\"Intervals argument specifies a file.  Loading intervals from file.\");\n                locs = GenomeLocParser.intervalFileToList(intervalsString);\n            } else {\n                if (! quiet) logger.info(\"Intervals argument does not specify a file.  Trying to parse it as a simple string.\");\n                locs = GenomeLocParser.parseGenomeLocs(intervalsString);\n            }\n        }\n        return locs;\n    }","id":81510,"modified_method":"/**\n     * setup the interval regions, from either the interval file of the genome region string\n     *\n     * @return a list of genomeLoc representing the interval file\n     */\n    public static List<GenomeLoc> parseIntervalRegion(final List<String> intervals ) {\n        List<GenomeLoc> locs = new ArrayList<GenomeLoc>();\n        for( String interval: intervals ) {\n            if (new File(interval).exists()) {\n                locs.addAll(GenomeLocParser.intervalFileToList(interval));\n            } else {\n                locs.addAll(GenomeLocParser.parseGenomeLocs(interval));\n            }\n\n        }\n        return locs;\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * commands that get executed for each engine, regardless of the type\n     */\n    private void genericEngineSetup() {\n        Reads sourceInfo = extractSourceInfoFromArguments(argCollection);\n\n        engine.setStrictness(sourceInfo.getValidationStringency());\n\n        engine.setMaxReads(argCollection.maximumEngineIterations);\n        engine.setFilterZeroMappingQualityReads(argCollection.filterZeroMappingQualityReads);\n\n        // we default interval files over the genome region string\n        if (argCollection.intervals != null) {\n            engine.setLocation(parseIntervalRegion(argCollection.intervals, false));\n        }\n\n        engine.setReadFilters(sourceInfo);\n\n        engine.setThreadedIO(argCollection.enabledThreadedIO);\n        engine.setWalkOverAllSites(argCollection.walkAllLoci);\n        engine.initialize();\n    }","id":81511,"modified_method":"/**\n     * commands that get executed for each engine, regardless of the type\n     */\n    private void genericEngineSetup() {\n        Reads sourceInfo = extractSourceInfoFromArguments(argCollection);\n\n        engine.setStrictness(sourceInfo.getValidationStringency());\n\n        engine.setMaxReads(argCollection.maximumEngineIterations);\n        engine.setFilterZeroMappingQualityReads(argCollection.filterZeroMappingQualityReads);\n\n        // we default interval files over the genome region string\n        if (argCollection.intervals != null) {\n            engine.setLocation(parseIntervalRegion(argCollection.intervals));\n        }\n\n        engine.setReadFilters(sourceInfo);\n\n        engine.setThreadedIO(argCollection.enabledThreadedIO);\n        engine.setWalkOverAllSites(argCollection.walkAllLoci);\n        engine.initialize();\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Load the intervals directly from the command-line or from file, as appropriate.\n     * Merge overlapping intervals.\n     * @param intervalsSource Source of intervals.\n     * @return a linked list of sorted, merged intervals.\n     */\n    private LinkedList<GenomeLoc> parseIntervals(String intervalsSource) {\n        List<GenomeLoc> parsedIntervals = GenomeAnalysisEngine.parseIntervalRegion(intervalsSource,false);\n        GenomeLocSortedSet intervalSortedSet = new GenomeLocSortedSet();\n        for ( GenomeLoc parsedInterval : parsedIntervals )\n            intervalSortedSet.addRegion(parsedInterval);\n\n        return new LinkedList<GenomeLoc>( intervalSortedSet );\n    }","id":81512,"modified_method":"/**\n     * Load the intervals directly from the command-line or from file, as appropriate.\n     * Merge overlapping intervals.\n     * @param intervalsSource Source of intervals.\n     * @return a linked list of sorted, merged intervals.\n     */\n    private LinkedList<GenomeLoc> parseIntervals(List<String> intervalsSource) {\n        List<GenomeLoc> parsedIntervals = GenomeAnalysisEngine.parseIntervalRegion(intervalsSource);\n        GenomeLocSortedSet intervalSortedSet = new GenomeLocSortedSet();\n        for ( GenomeLoc parsedInterval : parsedIntervals )\n            intervalSortedSet.addRegion(parsedInterval);\n\n        return new LinkedList<GenomeLoc>( intervalSortedSet );\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static IntervalRodIterator IntervalRodIteratorFromLocsFile(final String trackName, final File file) {\n        //System.out.printf(\"Parsing %s for intervals %s%n\", file, trackName);\n        List<GenomeLoc> locs = GenomeAnalysisEngine.parseIntervalRegion(file.getPath(), true);\n        //System.out.printf(\" => got %d entries %n\", locs.size());\n        return new IntervalRodIterator(trackName, locs);\n    }","id":81513,"modified_method":"public static IntervalRodIterator IntervalRodIteratorFromLocsFile(final String trackName, final File file) {\n        //System.out.printf(\"Parsing %s for intervals %s%n\", file, trackName);\n        List<GenomeLoc> locs = GenomeAnalysisEngine.parseIntervalRegion(Collections.singletonList(file.getPath()));\n        //System.out.printf(\" => got %d entries %n\", locs.size());\n        return new IntervalRodIterator(trackName, locs);\n    }","commit_id":"ad3a3aa35005aa6bfb7fb2450230860d2d8dc0c7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * test equality between two arg collections.  This function defines the statement:\n     * \"not fun to write\"\n     * @param other the other collection\n     * @return true if they're equal\n     */\n    public boolean equals(GATKArgumentCollection other) {        \n        if (other.samFiles.size() != samFiles.size()) {\n            return false;\n        }\n        for (int x = 0; x < samFiles.size(); x++) {\n            if (!samFiles.get(x).equals(other.samFiles.get(x))) {\n                return false;\n            }\n        }\n        if (other.walkerArgs.size() != walkerArgs.size()) {\n            return false;\n        }\n        for (String s : walkerArgs.keySet()) {\n            if (!other.walkerArgs.containsKey(s)) {\n                return false;\n            }\n        }\n        if (other.RODBindings.size() != RODBindings.size()) {\n            return false;\n        }\n        for (int x = 0; x < RODBindings.size(); x++) {\n            if (!RODBindings.get(x).equals(other.RODBindings.get(x))) {\n                return false;\n            }\n        }\n        if (!other.samFiles.equals(this.samFiles)) {\n            return false;\n        }\n        if (!other.maximumReads.equals(this.maximumReads)) {\n            return false;\n        }\n        if (!other.strictnessLevel.equals(this.strictnessLevel)) {\n            return false;\n        }\n        if (!other.referenceFile.equals(this.referenceFile)) {\n            return false;\n        }\n        if (!other.genomeRegion.equals(this.genomeRegion)) {\n            return false;\n        }\n        if (!other.analysisName.equals(this.analysisName)) {\n            return false;\n        }\n        if (!other.DBSNPFile.equals(this.DBSNPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPFile.equals(this.HAPMAPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPChipFile.equals(this.HAPMAPChipFile)) {\n            return false;\n        }\n        if (!other.enabledThreadedIO.equals(this.enabledThreadedIO)) {\n            return false;\n        }\n        if (!other.unsafe.equals(this.unsafe)) {\n            return false;\n        }\n        if (!other.maximumReadSorts.equals(this.maximumReadSorts)) {\n            return false;\n        }\n        if (!other.downsampleFraction.equals(this.downsampleFraction)) {\n            return false;\n        }\n        if (!other.downsampleCoverage.equals(this.downsampleCoverage)) {\n            return false;\n        }\n        if (!other.intervalsFile.equals(this.intervalsFile)) {\n            return false;\n        }\n        if (!other.walkAllLoci.equals(this.walkAllLoci)) {\n            return false;\n        }\n        if (!other.outFileName.equals(this.outFileName)) {\n            return false;\n        }\n        if (!other.errFileName.equals(this.errFileName)) {\n            return false;\n        }\n        if (!other.outErrFileName.equals(this.outErrFileName)) {\n            return false;\n        }\n        if (other.numberOfThreads != this.numberOfThreads) {\n            return false;\n        }\n        return true;\n    }","id":81514,"modified_method":"/**\n     * test equality between two arg collections.  This function defines the statement:\n     * \"not fun to write\"\n     * @param other the other collection\n     * @return true if they're equal\n     */\n    public boolean equals(GATKArgumentCollection other) {        \n        if (other.samFiles.size() != samFiles.size()) {\n            return false;\n        }\n        for (int x = 0; x < samFiles.size(); x++) {\n            if (!samFiles.get(x).equals(other.samFiles.get(x))) {\n                return false;\n            }\n        }\n        if (other.walkerArgs.size() != walkerArgs.size()) {\n            return false;\n        }\n        for (String s : walkerArgs.keySet()) {\n            if (!other.walkerArgs.containsKey(s)) {\n                return false;\n            }\n        }\n        if (other.RODBindings.size() != RODBindings.size()) {\n            return false;\n        }\n        for (int x = 0; x < RODBindings.size(); x++) {\n            if (!RODBindings.get(x).equals(other.RODBindings.get(x))) {\n                return false;\n            }\n        }\n        if (!other.samFiles.equals(this.samFiles)) {\n            return false;\n        }\n        if (!other.maximumReads.equals(this.maximumReads)) {\n            return false;\n        }\n        if (!other.strictnessLevel.equals(this.strictnessLevel)) {\n            return false;\n        }\n        if (!other.referenceFile.equals(this.referenceFile)) {\n            return false;\n        }\n        if (!other.intervals.equals(this.intervals)) {\n            return false;\n        }\n        if (!other.analysisName.equals(this.analysisName)) {\n            return false;\n        }\n        if (!other.DBSNPFile.equals(this.DBSNPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPFile.equals(this.HAPMAPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPChipFile.equals(this.HAPMAPChipFile)) {\n            return false;\n        }\n        if (!other.enabledThreadedIO.equals(this.enabledThreadedIO)) {\n            return false;\n        }\n        if (!other.unsafe.equals(this.unsafe)) {\n            return false;\n        }\n        if (!other.maximumReadSorts.equals(this.maximumReadSorts)) {\n            return false;\n        }\n        if (!other.downsampleFraction.equals(this.downsampleFraction)) {\n            return false;\n        }\n        if (!other.downsampleCoverage.equals(this.downsampleCoverage)) {\n            return false;\n        }\n        if (!other.walkAllLoci.equals(this.walkAllLoci)) {\n            return false;\n        }\n        if (!other.outFileName.equals(this.outFileName)) {\n            return false;\n        }\n        if (!other.errFileName.equals(this.errFileName)) {\n            return false;\n        }\n        if (!other.outErrFileName.equals(this.outErrFileName)) {\n            return false;\n        }\n        if (other.numberOfThreads != this.numberOfThreads) {\n            return false;\n        }\n        return true;\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void setupCollection() {\n        // parameters and their defaults\n        Map<String, String> wArgs = new HashMap<String, String>();\n        wArgs.put(\"wArgType1\", \"Arg1\");\n        wArgs.put(\"wArgType2\", \"Arg2\");\n        wArgs.put(\"wArgType3\", \"Arg3\");\n        collect.walkerArgs = wArgs;\n\n        List<File> input = new ArrayList<File>();\n        input.add(new File(\"test.file\"));\n        collect.samFiles = input;\n        collect.maximumReads = \"-1\";\n        collect.strictnessLevel = \"strict\";\n        collect.referenceFile = new File(\"referenceFile\".toLowerCase());\n        collect.genomeRegion = \"genomeRegion\".toLowerCase();\n        collect.analysisName = \"analysisName\".toLowerCase();\n        collect.DBSNPFile = \"DBSNPFile\".toLowerCase();\n        collect.HAPMAPFile = \"HAPMAPFile\".toLowerCase();\n        collect.HAPMAPChipFile = \"HAPMAPChipFile\".toLowerCase();\n        collect.enabledThreadedIO = true;\n        collect.unsafe = false;\n        collect.maximumReadSorts = \"maximumReadSorts\".toLowerCase();\n        collect.downsampleFraction = \"downsampleFraction\".toLowerCase();\n        collect.downsampleCoverage = \"downsampleCoverage\".toLowerCase();\n        collect.intervalsFile = \"intervalsFile\".toLowerCase();\n        collect.walkAllLoci = true;\n        collect.disableThreading = false;\n        collect.outFileName = \"outFileName\".toLowerCase();\n        collect.errFileName = \"errFileName\".toLowerCase();\n        collect.outErrFileName = \"outErrFileName\".toLowerCase();\n        collect.numberOfThreads = 1;\n\n        // make some rod bindings up\n        ArrayList<String> fakeBindings = new ArrayList<String>();\n        fakeBindings.add(\"Bind1\");\n        fakeBindings.add(\"Bind2\");\n        fakeBindings.add(\"Bind3\");\n\n        collect.RODBindings = fakeBindings;\n    }","id":81515,"modified_method":"private void setupCollection() {\n        // parameters and their defaults\n        Map<String, String> wArgs = new HashMap<String, String>();\n        wArgs.put(\"wArgType1\", \"Arg1\");\n        wArgs.put(\"wArgType2\", \"Arg2\");\n        wArgs.put(\"wArgType3\", \"Arg3\");\n        collect.walkerArgs = wArgs;\n\n        List<File> input = new ArrayList<File>();\n        input.add(new File(\"test.file\"));\n        collect.samFiles = input;\n        collect.maximumReads = \"-1\";\n        collect.strictnessLevel = \"strict\";\n        collect.referenceFile = new File(\"referenceFile\".toLowerCase());\n        collect.analysisName = \"analysisName\".toLowerCase();\n        collect.DBSNPFile = \"DBSNPFile\".toLowerCase();\n        collect.HAPMAPFile = \"HAPMAPFile\".toLowerCase();\n        collect.HAPMAPChipFile = \"HAPMAPChipFile\".toLowerCase();\n        collect.enabledThreadedIO = true;\n        collect.unsafe = false;\n        collect.maximumReadSorts = \"maximumReadSorts\".toLowerCase();\n        collect.downsampleFraction = \"downsampleFraction\".toLowerCase();\n        collect.downsampleCoverage = \"downsampleCoverage\".toLowerCase();\n        collect.intervals = \"intervals\".toLowerCase();\n        collect.walkAllLoci = true;\n        collect.disableThreading = false;\n        collect.outFileName = \"outFileName\".toLowerCase();\n        collect.errFileName = \"errFileName\".toLowerCase();\n        collect.outErrFileName = \"outErrFileName\".toLowerCase();\n        collect.numberOfThreads = 1;\n\n        // make some rod bindings up\n        ArrayList<String> fakeBindings = new ArrayList<String>();\n        fakeBindings.add(\"Bind1\");\n        fakeBindings.add(\"Bind2\");\n        fakeBindings.add(\"Bind3\");\n\n        collect.RODBindings = fakeBindings;\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * setup the interval regions, from either the interval file of the genome region string\n     *\n     * @return a list of genomeLoc representing the interval file\n     */\n    private List<GenomeLoc> setupIntervalRegion() {\n        List<GenomeLoc> locs;\n        if (argCollection.intervalsFile != null)\n            locs = GenomeLoc.IntervalFileToList(argCollection.intervalsFile);\n        else\n            locs = GenomeLoc.parseGenomeLocs(argCollection.genomeRegion);\n        return locs;\n    }","id":81516,"modified_method":"/**\n     * setup the interval regions, from either the interval file of the genome region string\n     *\n     * @return a list of genomeLoc representing the interval file\n     */\n    private List<GenomeLoc> setupIntervalRegion() {\n        List<GenomeLoc> locs;\n        if( new File(argCollection.intervals).exists() ) {\n            logger.info(\"Intervals argument specifies a file.  Loading intervals from file.\");\n            return GenomeLoc.IntervalFileToList(argCollection.intervals);\n        }\n        else {\n            logger.info(\"Intervals argument does not specify a file.  Trying to parse it as a simple string.\");\n            return GenomeLoc.parseGenomeLocs(argCollection.intervals);\n        }\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Initialize the output streams as specified by the user. */\n    private void initializeOutputStreams() {\n        outputTracker = (argCollection.outErrFileName != null) ? new OutputTracker(argCollection.outErrFileName, argCollection.outErrFileName)\n                : new OutputTracker(argCollection.outFileName, argCollection.errFileName);\n    }","id":81517,"modified_method":"/** Initialize the output streams as specified by the user. */\n    private void initializeOutputStreams( Walker walker ) {\n        outputTracker = (argCollection.outErrFileName != null) ? new OutputTracker(argCollection.outErrFileName, argCollection.outErrFileName)\n                : new OutputTracker(argCollection.outFileName, argCollection.errFileName);\n        walker.initializeOutputStreams(outputTracker);\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * commands that get executed for each engine, regardless of the type\n     *\n     * @param strictness our current strictness level\n     */\n    private void genericEngineSetup(ValidationStringency strictness) {\n        engine.setStrictness(strictness);\n\n        engine.setMaxReads(Integer.parseInt(argCollection.maximumReads));\n\n        if (argCollection.genomeRegion != null) {\n            engine.setLocation(argCollection.genomeRegion);\n        }\n        // we default interval files over the genome region strin\n        if (argCollection.intervalsFile != null) {\n            engine.setLocationFromFile(argCollection.intervalsFile);\n        }\n        // hmm...\n        if (argCollection.maximumReadSorts != null) {\n            engine.setSortOnFly(Integer.parseInt(argCollection.maximumReadSorts));\n        }\n\n        if (argCollection.downsampleFraction != null) {\n            engine.setDownsampleByFraction(Double.parseDouble(argCollection.downsampleFraction));\n        }\n\n        if (argCollection.downsampleCoverage != null) {\n            engine.setDownsampleByCoverage(Integer.parseInt(argCollection.downsampleCoverage));\n        }\n\n        engine.setSafetyChecking(!argCollection.unsafe);\n        engine.setThreadedIO(argCollection.enabledThreadedIO);\n        engine.setWalkOverAllSites(argCollection.walkAllLoci);\n        engine.initialize();\n    }","id":81518,"modified_method":"/**\n     * commands that get executed for each engine, regardless of the type\n     *\n     * @param strictness our current strictness level\n     */\n    private void genericEngineSetup(ValidationStringency strictness) {\n        engine.setStrictness(strictness);\n\n        engine.setMaxReads(Integer.parseInt(argCollection.maximumReads));\n\n        // we default interval files over the genome region strin\n        if (argCollection.intervals != null) {\n            engine.setLocation(setupIntervalRegion());\n        }\n        // hmm...\n        if (argCollection.maximumReadSorts != null) {\n            engine.setSortOnFly(Integer.parseInt(argCollection.maximumReadSorts));\n        }\n\n        if (argCollection.downsampleFraction != null) {\n            engine.setDownsampleByFraction(Double.parseDouble(argCollection.downsampleFraction));\n        }\n\n        if (argCollection.downsampleCoverage != null) {\n            engine.setDownsampleByCoverage(Integer.parseInt(argCollection.downsampleCoverage));\n        }\n\n        engine.setSafetyChecking(!argCollection.unsafe);\n        engine.setThreadedIO(argCollection.enabledThreadedIO);\n        engine.setWalkOverAllSites(argCollection.walkAllLoci);\n        engine.initialize();\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * our constructor, where all the work is done\n     * <p/>\n     * legacy traversal types are sent to legacyTraversal function; as we move more of the traversals to the\n     * new MicroScheduler class we'll be able to delete that function.\n     *\n     * @param args      the argument collection, where we get all our setup information from\n     * @param my_walker the walker we're running with\n     */\n    public GenomeAnalysisEngine(GATKArgumentCollection args, Walker my_walker) {\n\n        // validate our parameters\n        if (args == null || my_walker == null) {\n            throw new StingException(\"Neither the GATKArgumentCollection or the Walker passed to GenomeAnalysisEngine can be null.\");\n        }\n\n        // save our argument parameter\n        this.argCollection = args;\n\n        // make sure our instance variable points to this analysis engine\n        instance = this;\n\n        // our reference ordered data collection\n        List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods = new ArrayList<ReferenceOrderedData<? extends ReferenceOrderedDatum>>();\n\n        //\n        // please don't use these in the future, use the new syntax <- if we're not using these please remove them\n        //\n        if (argCollection.DBSNPFile != null) bindConvenienceRods(\"dbSNP\", \"dbsnp\", argCollection.DBSNPFile);\n        if (argCollection.HAPMAPFile != null)\n            bindConvenienceRods(\"hapmap\", \"HapMapAlleleFrequencies\", argCollection.HAPMAPFile);\n        if (argCollection.HAPMAPChipFile != null)\n            bindConvenienceRods(\"hapmap-chip\", \"GFF\", argCollection.HAPMAPChipFile);\n\n        // parse out the rod bindings\n        ReferenceOrderedData.parseBindings(logger, argCollection.RODBindings, rods);\n\n        // create the output streams\n        initializeOutputStreams();\n\n        // our microscheduler, which is in charge of running everything\n        MicroScheduler microScheduler = null;\n\n        // if we're a read or a locus walker, we use the new system.  Right now we have complicated\n        // branching based on the input data, but this should disapear when all the traversals are switched over\n        if ((my_walker instanceof LocusWalker && argCollection.walkAllLoci && !(argCollection.samFiles == null || argCollection.samFiles.size() == 0)) ||\n                my_walker instanceof ReadWalker) {\n            microScheduler = createMicroscheduler(my_walker, rods);\n        } else { // we have an old style traversal, once we're done return\n            legacyTraversal(my_walker, rods);\n            return;\n        }\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        if (argCollection.referenceFile != null) {\n            final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(argCollection.referenceFile);\n            GenomeLoc.setupRefContigOrdering(refFile);\n        }\n\n        // Determine the validation stringency.  Default to ValidationStringency.STRICT.\n        ValidationStringency strictness = getValidationStringency();\n\n        logger.info(\"Strictness is \" + strictness);\n\n        // perform validation steps that are common to all the engines\n        genericEngineSetup(strictness);\n\n        // parse out any genomic location they've provided\n        List<GenomeLoc> locs = setupIntervalRegion();\n\n        // excute the microscheduler\n        microScheduler.execute(my_walker, locs);\n    }","id":81519,"modified_method":"/**\n     * our constructor, where all the work is done\n     * <p/>\n     * legacy traversal types are sent to legacyTraversal function; as we move more of the traversals to the\n     * new MicroScheduler class we'll be able to delete that function.\n     *\n     * @param args      the argument collection, where we get all our setup information from\n     * @param my_walker the walker we're running with\n     */\n    public GenomeAnalysisEngine(GATKArgumentCollection args, Walker my_walker) {\n\n        // validate our parameters\n        if (args == null || my_walker == null) {\n            throw new StingException(\"Neither the GATKArgumentCollection or the Walker passed to GenomeAnalysisEngine can be null.\");\n        }\n\n        // save our argument parameter\n        this.argCollection = args;\n\n        // make sure our instance variable points to this analysis engine\n        instance = this;\n\n        // our reference ordered data collection\n        List<ReferenceOrderedData<? extends ReferenceOrderedDatum>> rods = new ArrayList<ReferenceOrderedData<? extends ReferenceOrderedDatum>>();\n\n        //\n        // please don't use these in the future, use the new syntax <- if we're not using these please remove them\n        //\n        if (argCollection.DBSNPFile != null) bindConvenienceRods(\"dbSNP\", \"dbsnp\", argCollection.DBSNPFile);\n        if (argCollection.HAPMAPFile != null)\n            bindConvenienceRods(\"hapmap\", \"HapMapAlleleFrequencies\", argCollection.HAPMAPFile);\n        if (argCollection.HAPMAPChipFile != null)\n            bindConvenienceRods(\"hapmap-chip\", \"GFF\", argCollection.HAPMAPChipFile);\n\n        // parse out the rod bindings\n        ReferenceOrderedData.parseBindings(logger, argCollection.RODBindings, rods);\n\n        // create the output streams\n        initializeOutputStreams( my_walker );\n\n        // our microscheduler, which is in charge of running everything\n        MicroScheduler microScheduler = null;\n\n        // if we're a read or a locus walker, we use the new system.  Right now we have complicated\n        // branching based on the input data, but this should disapear when all the traversals are switched over\n        if ((my_walker instanceof LocusWalker && argCollection.walkAllLoci && !(argCollection.samFiles == null || argCollection.samFiles.size() == 0)) ||\n                my_walker instanceof ReadWalker) {\n            microScheduler = createMicroscheduler(my_walker, rods);\n        } else { // we have an old style traversal, once we're done return\n            legacyTraversal(my_walker, rods);\n            return;\n        }\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        if (argCollection.referenceFile != null) {\n            final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(argCollection.referenceFile);\n            GenomeLoc.setupRefContigOrdering(refFile);\n        }\n\n        // Determine the validation stringency.  Default to ValidationStringency.STRICT.\n        ValidationStringency strictness = getValidationStringency();\n\n        logger.info(\"Strictness is \" + strictness);\n\n        // perform validation steps that are common to all the engines\n        genericEngineSetup(strictness);\n\n        // parse out any genomic location they've provided\n        List<GenomeLoc> locs = setupIntervalRegion();\n\n        // excute the microscheduler\n        microScheduler.execute(my_walker, locs);\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"public <M, T> T traverse(Walker<M, T> walker) {\n        T sum = null;\n        if ( hasLocations() && walker.isReduceByInterval() ) {\n            logger.info(\"Doing reduce by interval processing\");\n            if ( ! hasLocations() )\n                Utils.scareUser(\"ReduceByInterval requested by no interval was provided\");\n            List<Pair<GenomeLoc, T>> map = new ArrayList<Pair<GenomeLoc, T>>(locs.size());\n            for ( GenomeLoc loc : locs ) {\n                ArrayList<GenomeLoc> l = new ArrayList<GenomeLoc>();\n                l.add(loc);\n                T intervalSum = traverse(walker, l);\n                sum = intervalSum;\n                map.add(new Pair<GenomeLoc, T>(loc, intervalSum));\n            }\n            walker.onTraversalDone(map);\n        } else {\n            ArrayList<GenomeLoc> l = new ArrayList<GenomeLoc>();\n            if ( hasLocations() )\n                l = locs;\n            sum = traverse(walker, l);\n        }\n\n        printOnTraversalDone(\"elements\", sum);\n        return sum;\n    }","id":81520,"modified_method":"public <M, T> T traverse(Walker<M, T> walker) {\n        T sum = null;\n        if ( hasLocations() && walker.isReduceByInterval() ) {\n            logger.info(\"Doing reduce by interval processing\");\n            if ( ! hasLocations() )\n                Utils.scareUser(\"ReduceByInterval requested by no interval was provided\");\n            List<Pair<GenomeLoc, T>> map = new ArrayList<Pair<GenomeLoc, T>>(locs.size());\n            for ( GenomeLoc loc : locs ) {\n                ArrayList<GenomeLoc> l = new ArrayList<GenomeLoc>();\n                l.add(loc);\n                T intervalSum = traverse(walker, l);\n                sum = intervalSum;\n                map.add(new Pair<GenomeLoc, T>(loc, intervalSum));\n            }\n            walker.onTraversalDone(map);\n        } else {\n            List<GenomeLoc> l = new ArrayList<GenomeLoc>();\n            if ( hasLocations() )\n                l = locs;\n            sum = traverse(walker, l);\n        }\n\n        printOnTraversalDone(\"elements\", sum);\n        return sum;\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"public <M, T> T traverse(Walker<M, T> walker, ArrayList<GenomeLoc> locations) {\n        return null;\n    }","id":81521,"modified_method":"public <M, T> T traverse(Walker<M, T> walker, List<GenomeLoc> locations) {\n        return null;\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected Walker() {\n        if( GenomeAnalysisEngine.instance != null ) {\n            GenomeAnalysisEngine gatk = GenomeAnalysisEngine.instance;\n            out = new PrintStream( gatk.getOutputTracker().getOutStream() );\n            err = new PrintStream( gatk.getOutputTracker().getErrStream() );\n        }\n        else {\n            out = System.out;\n            err = System.err;\n        }\n    }","id":81522,"modified_method":"protected Walker() {\n    }","commit_id":"862b8a6787ef681b28e60fea9ed41270ada86e89","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void doDispatch(final HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        int interceptorIndex = -1;\n        final LocaleResolver localeResolver = (LocaleResolver)request.getAttribute(LOCALE_RESOLVER_ATTRIBUTE);\n\n\n        // Expose current LocaleResolver and request as LocaleContext.\n        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n        LocaleContextHolder.setLocaleContext(new LocaleContext() {\n            public Locale getLocale() {\n\n                return localeResolver.resolveLocale(request);\n            }\n        });\n\n\n        // If the request is an include we need to try to use the original wrapped sitemesh\n        // response, otherwise layouts won't work properly\n        if(WebUtils.isIncludeRequest(request)) {\n            response = useWrappedOrOriginalResponse(response);\n        }\n\n\n        processedRequest = checkMultipart(request);\n        // Expose current RequestAttributes to current thread.\n        GrailsWebRequest previousRequestAttributes = (GrailsWebRequest) RequestContextHolder.currentRequestAttributes();\n        GrailsWebRequest requestAttributes = new GrailsWebRequest(processedRequest, response, getServletContext());\n        copyParamsFromPreviousRequest(previousRequestAttributes, requestAttributes);\n\n        RequestContextHolder.setRequestAttributes(requestAttributes);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Bound request context to thread: \" + request);\n            logger.debug(\"Using response object: \" + response.getClass());\n        }\n\n        try {\n            ModelAndView mv = null;\n            try {\n\n\n\n                // Determine handler for the current request.\n                mappedHandler = getHandler(processedRequest, false);\n                if (mappedHandler == null || mappedHandler.getHandler() == null) {\n                    noHandlerFound(processedRequest, response);\n                    return;\n                }\n\n                // Apply preHandle methods of registered interceptors.\n                if (mappedHandler.getInterceptors() != null) {\n                    for (int i = 0; i < mappedHandler.getInterceptors().length; i++) {\n                        HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];\n                        if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) {\n                            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);\n                            return;\n                        }\n                        interceptorIndex = i;\n                    }\n                }\n\n                // Actually invoke the handler.\n                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n                // Apply postHandle methods of registered interceptors.\n                if (mappedHandler.getInterceptors() != null) {\n                    for (int i = mappedHandler.getInterceptors().length - 1; i >= 0; i--) {\n                        HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];\n                        interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);\n                    }\n                }\n            }\n            catch (ModelAndViewDefiningException ex) {\n                GrailsUtil.deepSanitize(ex);\n                if (logger.isDebugEnabled())\n                    logger.debug(\"ModelAndViewDefiningException encountered\", ex);\n                mv = ex.getModelAndView();\n            }\n            catch (Exception ex) {\n                GrailsUtil.deepSanitize(ex);\n                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n                mv = processHandlerException(request, response, handler, ex);\n            }\n\n            // Did the handler return a view to render?\n            if (mv != null && !mv.wasCleared()) {\n                // If an exception occurs in here, like a bad closing tag,\n                // we have nothing to render.\n\n                try {\n                    render(mv, processedRequest, response);\n                } catch (Exception e) {\n                    mv = super.processHandlerException(processedRequest, response, mappedHandler, e);\n                    render(mv, processedRequest, response);\n                }\n            }\n            else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Null ModelAndView returned to DispatcherServlet with name '\" +\n                            getServletName() + \"': assuming HandlerAdapter completed request handling\");\n                }\n            }\n\n            // Trigger after-completion for successful outcome.\n            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);\n        }\n\n        catch (Exception ex) {\n            // Trigger after-completion for thrown exception.\n            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);\n            throw ex;\n        }\n        catch (Error err) {\n            ServletException ex = new NestedServletException(\"Handler processing failed\", err);\n            // Trigger after-completion for thrown exception.\n            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);\n            throw ex;\n        }\n\n        finally {\n            // Clean up any resources used by a multipart request.\n            if (processedRequest instanceof MultipartHttpServletRequest && processedRequest != request) {\n                if(multipartResolver != null)\n                    this.multipartResolver.cleanupMultipart((MultipartHttpServletRequest) processedRequest);\n            }\n\n            // Reset thread-bound RequestAttributes.\n            requestAttributes.requestCompleted();\n            RequestContextHolder.setRequestAttributes(previousRequestAttributes);\n\n            // Reset thread-bound LocaleContext.\n            LocaleContextHolder.setLocaleContext(previousLocaleContext);\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Cleared thread-bound request context: \" + request);\n            }\n        }\n\n\t}","id":81523,"modified_method":"protected void doDispatch(final HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        int interceptorIndex = -1;\n        final LocaleResolver localeResolver = (LocaleResolver)request.getAttribute(LOCALE_RESOLVER_ATTRIBUTE);\n\n\n        // Expose current LocaleResolver and request as LocaleContext.\n        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n        LocaleContextHolder.setLocaleContext(new LocaleContext() {\n            public Locale getLocale() {\n\n                return localeResolver.resolveLocale(request);\n            }\n        });\n\n\n        // If the request is an include we need to try to use the original wrapped sitemesh\n        // response, otherwise layouts won't work properly\n        if(WebUtils.isIncludeRequest(request)) {\n            response = useWrappedOrOriginalResponse(response);\n        }\n\n        GrailsWebRequest requestAttributes = null;\n        GrailsWebRequest previousRequestAttributes = null;\n        try {\n            ModelAndView mv = null;\n            try {\n                processedRequest = checkMultipart(request);\n                // Expose current RequestAttributes to current thread.\n                previousRequestAttributes = (GrailsWebRequest) RequestContextHolder.currentRequestAttributes();\n                requestAttributes = new GrailsWebRequest(processedRequest, response, getServletContext());\n                copyParamsFromPreviousRequest(previousRequestAttributes, requestAttributes);\n\n                RequestContextHolder.setRequestAttributes(requestAttributes);\n\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Bound request context to thread: \" + request);\n                    logger.debug(\"Using response object: \" + response.getClass());\n                }\n\n\n\n\n                // Determine handler for the current request.\n                mappedHandler = getHandler(processedRequest, false);\n                if (mappedHandler == null || mappedHandler.getHandler() == null) {\n                    noHandlerFound(processedRequest, response);\n                    return;\n                }\n\n                // Apply preHandle methods of registered interceptors.\n                if (mappedHandler.getInterceptors() != null) {\n                    for (int i = 0; i < mappedHandler.getInterceptors().length; i++) {\n                        HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];\n                        if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) {\n                            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);\n                            return;\n                        }\n                        interceptorIndex = i;\n                    }\n                }\n\n                // Actually invoke the handler.\n                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n                // Apply postHandle methods of registered interceptors.\n                if (mappedHandler.getInterceptors() != null) {\n                    for (int i = mappedHandler.getInterceptors().length - 1; i >= 0; i--) {\n                        HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];\n                        interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);\n                    }\n                }\n            }\n            catch (ModelAndViewDefiningException ex) {\n                GrailsUtil.deepSanitize(ex);\n                if (logger.isDebugEnabled())\n                    logger.debug(\"ModelAndViewDefiningException encountered\", ex);\n                mv = ex.getModelAndView();\n            }\n            catch (Exception ex) {\n                GrailsUtil.deepSanitize(ex);\n                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n                mv = processHandlerException(request, response, handler, ex);\n            }\n\n            // Did the handler return a view to render?\n            if (mv != null && !mv.wasCleared()) {\n                // If an exception occurs in here, like a bad closing tag,\n                // we have nothing to render.\n\n                try {\n                    render(mv, processedRequest, response);\n                } catch (Exception e) {\n                    mv = super.processHandlerException(processedRequest, response, mappedHandler, e);\n                    render(mv, processedRequest, response);\n                }\n            }\n            else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Null ModelAndView returned to DispatcherServlet with name '\" +\n                            getServletName() + \"': assuming HandlerAdapter completed request handling\");\n                }\n            }\n\n            // Trigger after-completion for successful outcome.\n            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);\n        }\n\n        catch (Exception ex) {\n            // Trigger after-completion for thrown exception.\n            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);\n            throw ex;\n        }\n        catch (Error err) {\n            ServletException ex = new NestedServletException(\"Handler processing failed\", err);\n            // Trigger after-completion for thrown exception.\n            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);\n            throw ex;\n        }\n\n        finally {\n            // Clean up any resources used by a multipart request.\n            if (processedRequest instanceof MultipartHttpServletRequest && processedRequest != request) {\n                if(multipartResolver != null)\n                    this.multipartResolver.cleanupMultipart((MultipartHttpServletRequest) processedRequest);\n            }\n\n            // Reset thread-bound RequestAttributes.\n            if(requestAttributes != null) {\n\n                requestAttributes.requestCompleted();\n                RequestContextHolder.setRequestAttributes(previousRequestAttributes);\n            }\n            // Reset thread-bound LocaleContext.\n            LocaleContextHolder.setLocaleContext(previousLocaleContext);\n\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Cleared thread-bound request context: \" + request);\n            }\n        }\n    }","commit_id":"859e1daec463b85827918e10f9cf5c80a30dd840","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * The actual event handling is performed by the abstract\n\t * <code>doActionService()<\/code> and <code>doRenderService()<\/code> template methods.\n\t * @see #doActionService\n\t * @see #doRenderService\n\t */\n\tprotected final void processRequest(PortletRequest request, PortletResponse response)\n\t\t\tthrows PortletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\t// Expose current LocaleResolver and request as LocaleContext.\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContextHolder.setLocaleContext(buildLocaleContext(request), this.threadContextInheritable);\n\n\t\t// Expose current RequestAttributes to current thread.\n\t\tRequestAttributes previousRequestAttributes = RequestContextHolder.getRequestAttributes();\n\t\tPortletRequestAttributes requestAttributes = new PortletRequestAttributes(request);\n\t\tRequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Bound request context to thread: \" + request);\n\t\t}\n\n\t\ttry {\n\t\t\tString phase = (String) request.getAttribute(PortletRequest.LIFECYCLE_PHASE);\n\t\t\tif (PortletRequest.ACTION_PHASE.equals(phase)) {\n\t\t\t\tdoActionService((ActionRequest) request, (ActionResponse) response);\n\t\t\t}\n\t\t\telse if (PortletRequest.RENDER_PHASE.equals(phase)) {\n\t\t\t\tdoRenderService((RenderRequest) request, (RenderResponse) response);\n\t\t\t}\n\t\t\telse if (PortletRequest.RESOURCE_PHASE.equals(phase)) {\n\t\t\t\tdoResourceService((ResourceRequest) request, (ResourceResponse) response);\n\t\t\t}\n\t\t\telse if (PortletRequest.EVENT_PHASE.equals(phase)) {\n\t\t\t\tdoEventService((EventRequest) request, (EventResponse) response);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Invalid portlet request phase: \" + phase);\n\t\t\t}\n\t\t}\n\t\tcatch (PortletException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new PortletException(\"Request processing failed\", ex);\n\t\t}\n\n\t\tfinally {\n\t\t\t// Reset thread-bound context.\n\t\t\tRequestContextHolder.setRequestAttributes(previousRequestAttributes, this.threadContextInheritable);\n\t\t\tLocaleContextHolder.setLocaleContext(previousLocaleContext, this.threadContextInheritable);\n\n\t\t\t// Clear request attributes.\n\t\t\trequestAttributes.requestCompleted();\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cleared thread-bound resource request context: \" + request);\n\t\t\t}\n\n\t\t\tif (failureCause != null) {\n\t\t\t\tlogger.error(\"Could not complete request\", failureCause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Successfully completed request\");\n\t\t\t}\n\t\t\tif (this.publishEvents) {\n\t\t\t\t// Whether or not we succeeded, publish an event.\n\t\t\t\tlong processingTime = System.currentTimeMillis() - startTime;\n\t\t\t\tthis.portletApplicationContext.publishEvent(\n\t\t\t\t\t\tnew PortletRequestHandledEvent(this,\n\t\t\t\t\t\t\t\tgetPortletConfig().getPortletName(), request.getPortletMode().toString(),\n\t\t\t\t\t\t\t\t(request instanceof ActionRequest ? \"action\" : \"render\"),\n\t\t\t\t\t\t\t\trequest.getRequestedSessionId(), getUsernameForRequest(request),\n\t\t\t\t\t\t\t\tprocessingTime, failureCause));\n\t\t\t}\n\t\t}\n\t}","id":81524,"modified_method":"/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * The actual event handling is performed by the abstract\n\t * <code>doActionService()<\/code> and <code>doRenderService()<\/code> template methods.\n\t * @see #doActionService\n\t * @see #doRenderService\n\t */\n\tprotected final void processRequest(PortletRequest request, PortletResponse response)\n\t\t\tthrows PortletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\t// Expose current LocaleResolver and request as LocaleContext.\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContextHolder.setLocaleContext(buildLocaleContext(request), this.threadContextInheritable);\n\n\t\t// Expose current RequestAttributes to current thread.\n\t\tRequestAttributes previousRequestAttributes = RequestContextHolder.getRequestAttributes();\n\t\tPortletRequestAttributes requestAttributes = null;\n\t\tif (previousRequestAttributes == null || previousRequestAttributes.getClass().equals(PortletRequestAttributes.class)) {\n\t\t\trequestAttributes = new PortletRequestAttributes(request);\n\t\t\tRequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Bound request context to thread: \" + request);\n\t\t}\n\n\t\ttry {\n\t\t\tString phase = (String) request.getAttribute(PortletRequest.LIFECYCLE_PHASE);\n\t\t\tif (PortletRequest.ACTION_PHASE.equals(phase)) {\n\t\t\t\tdoActionService((ActionRequest) request, (ActionResponse) response);\n\t\t\t}\n\t\t\telse if (PortletRequest.RENDER_PHASE.equals(phase)) {\n\t\t\t\tdoRenderService((RenderRequest) request, (RenderResponse) response);\n\t\t\t}\n\t\t\telse if (PortletRequest.RESOURCE_PHASE.equals(phase)) {\n\t\t\t\tdoResourceService((ResourceRequest) request, (ResourceResponse) response);\n\t\t\t}\n\t\t\telse if (PortletRequest.EVENT_PHASE.equals(phase)) {\n\t\t\t\tdoEventService((EventRequest) request, (EventResponse) response);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Invalid portlet request phase: \" + phase);\n\t\t\t}\n\t\t}\n\t\tcatch (PortletException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new PortletException(\"Request processing failed\", ex);\n\t\t}\n\n\t\tfinally {\n\t\t\t// Clear request attributes and reset thread-bound context.\n\t\t\tLocaleContextHolder.setLocaleContext(previousLocaleContext, this.threadContextInheritable);\n\t\t\tif (requestAttributes != null) {\n\t\t\t\tRequestContextHolder.setRequestAttributes(previousRequestAttributes, this.threadContextInheritable);\n\t\t\t\trequestAttributes.requestCompleted();\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cleared thread-bound resource request context: \" + request);\n\t\t\t}\n\n\t\t\tif (failureCause != null) {\n\t\t\t\tlogger.error(\"Could not complete request\", failureCause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Successfully completed request\");\n\t\t\t}\n\t\t\tif (this.publishEvents) {\n\t\t\t\t// Whether or not we succeeded, publish an event.\n\t\t\t\tlong processingTime = System.currentTimeMillis() - startTime;\n\t\t\t\tthis.portletApplicationContext.publishEvent(\n\t\t\t\t\t\tnew PortletRequestHandledEvent(this,\n\t\t\t\t\t\t\t\tgetPortletConfig().getPortletName(), request.getPortletMode().toString(),\n\t\t\t\t\t\t\t\t(request instanceof ActionRequest ? \"action\" : \"render\"),\n\t\t\t\t\t\t\t\trequest.getRequestedSessionId(), getUsernameForRequest(request),\n\t\t\t\t\t\t\t\tprocessingTime, failureCause));\n\t\t\t}\n\t\t}\n\t}","commit_id":"5ff6191d72489c728d4fa6fbc99af4d0d03643b9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * <p>The actual event handling is performed by the abstract\n\t * {@link #doService} template method.\n\t */\n\tprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\t// Expose current LocaleResolver and request as LocaleContext.\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContextHolder.setLocaleContext(buildLocaleContext(request), this.threadContextInheritable);\n\n\t\t// Expose current RequestAttributes to current thread.\n\t\tRequestAttributes previousRequestAttributes = RequestContextHolder.getRequestAttributes();\n\t\tServletRequestAttributes requestAttributes = new ServletRequestAttributes(request);\n\t\tRequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Bound request context to thread: \" + request);\n\t\t}\n\n\t\ttry {\n\t\t\tdoService(request, response);\n\t\t}\n\t\tcatch (ServletException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new NestedServletException(\"Request processing failed\", ex);\n\t\t}\n\n\t\tfinally {\n\t\t\t// Reset thread-bound context.\n\t\t\tRequestContextHolder.setRequestAttributes(previousRequestAttributes, this.threadContextInheritable);\n\t\t\tLocaleContextHolder.setLocaleContext(previousLocaleContext, this.threadContextInheritable);\n\n\t\t\t// Clear request attributes.\n\t\t\trequestAttributes.requestCompleted();\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cleared thread-bound request context: \" + request);\n\t\t\t}\n\n\t\t\tif (failureCause != null) {\n\t\t\t\tthis.logger.debug(\"Could not complete request\", failureCause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.logger.debug(\"Successfully completed request\");\n\t\t\t}\n\t\t\tif (this.publishEvents) {\n\t\t\t\t// Whether or not we succeeded, publish an event.\n\t\t\t\tlong processingTime = System.currentTimeMillis() - startTime;\n\t\t\t\tthis.webApplicationContext.publishEvent(\n\t\t\t\t\t\tnew ServletRequestHandledEvent(this,\n\t\t\t\t\t\t\t\trequest.getRequestURI(), request.getRemoteAddr(),\n\t\t\t\t\t\t\t\trequest.getMethod(), getServletConfig().getServletName(),\n\t\t\t\t\t\t\t\tWebUtils.getSessionId(request), getUsernameForRequest(request),\n\t\t\t\t\t\t\t\tprocessingTime, failureCause));\n\t\t\t}\n\t\t}\n\t}","id":81525,"modified_method":"/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * <p>The actual event handling is performed by the abstract\n\t * {@link #doService} template method.\n\t */\n\tprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\t// Expose current LocaleResolver and request as LocaleContext.\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContextHolder.setLocaleContext(buildLocaleContext(request), this.threadContextInheritable);\n\n\t\t// Expose current RequestAttributes to current thread.\n\t\tRequestAttributes previousRequestAttributes = RequestContextHolder.getRequestAttributes();\n\t\tServletRequestAttributes requestAttributes = null;\n\t\tif (previousRequestAttributes == null || previousRequestAttributes.getClass().equals(ServletRequestAttributes.class)) {\n\t\t\trequestAttributes = new ServletRequestAttributes(request);\n\t\t\tRequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Bound request context to thread: \" + request);\n\t\t}\n\n\t\ttry {\n\t\t\tdoService(request, response);\n\t\t}\n\t\tcatch (ServletException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new NestedServletException(\"Request processing failed\", ex);\n\t\t}\n\n\t\tfinally {\n\t\t\t// Clear request attributes and reset thread-bound context.\n\t\t\tLocaleContextHolder.setLocaleContext(previousLocaleContext, this.threadContextInheritable);\n\t\t\tif (requestAttributes != null) {\n\t\t\t\tRequestContextHolder.setRequestAttributes(previousRequestAttributes, this.threadContextInheritable);\n\t\t\t\trequestAttributes.requestCompleted();\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cleared thread-bound request context: \" + request);\n\t\t\t}\n\n\t\t\tif (failureCause != null) {\n\t\t\t\tthis.logger.debug(\"Could not complete request\", failureCause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.logger.debug(\"Successfully completed request\");\n\t\t\t}\n\t\t\tif (this.publishEvents) {\n\t\t\t\t// Whether or not we succeeded, publish an event.\n\t\t\t\tlong processingTime = System.currentTimeMillis() - startTime;\n\t\t\t\tthis.webApplicationContext.publishEvent(\n\t\t\t\t\t\tnew ServletRequestHandledEvent(this,\n\t\t\t\t\t\t\t\trequest.getRequestURI(), request.getRemoteAddr(),\n\t\t\t\t\t\t\t\trequest.getMethod(), getServletConfig().getServletName(),\n\t\t\t\t\t\t\t\tWebUtils.getSessionId(request), getUsernameForRequest(request),\n\t\t\t\t\t\t\t\tprocessingTime, failureCause));\n\t\t\t}\n\t\t}\n\t}","commit_id":"5ff6191d72489c728d4fa6fbc99af4d0d03643b9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServletRequestAttributes attributes = new ServletRequestAttributes(request);\n\t\tLocaleContextHolder.setLocale(request.getLocale(), this.threadContextInheritable);\n\t\tRequestContextHolder.setRequestAttributes(attributes, this.threadContextInheritable);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bound request context to thread: \" + request);\n\t\t}\n\t\ttry {\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\tattributes.requestCompleted();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleared thread-bound request context: \" + request);\n\t\t\t}\n\t\t}\n\t}","id":81526,"modified_method":"@Override\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServletRequestAttributes attributes = new ServletRequestAttributes(request);\n\t\tLocaleContextHolder.setLocale(request.getLocale(), this.threadContextInheritable);\n\t\tRequestContextHolder.setRequestAttributes(attributes, this.threadContextInheritable);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bound request context to thread: \" + request);\n\t\t}\n\t\ttry {\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t\tattributes.requestCompleted();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleared thread-bound request context: \" + request);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5ff6191d72489c728d4fa6fbc99af4d0d03643b9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void requestDestroyed(ServletRequestEvent requestEvent) {\n\t\tServletRequestAttributes attributes =\n\t\t\t\t(ServletRequestAttributes) requestEvent.getServletRequest().getAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE);\n\t\tServletRequestAttributes threadAttributes =\n\t\t\t\t(ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n\t\tif (threadAttributes != null) {\n\t\t\t// We're assumably within the original request thread...\n\t\t\tif (attributes == null) {\n\t\t\t\tattributes = threadAttributes;\n\t\t\t}\n\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t}\n\t\tif (attributes != null) {\n\t\t\tattributes.requestCompleted();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleared thread-bound request context: \" + requestEvent.getServletRequest());\n\t\t\t}\n\t\t}\n\t}","id":81527,"modified_method":"public void requestDestroyed(ServletRequestEvent requestEvent) {\n\t\tServletRequestAttributes attributes =\n\t\t\t\t(ServletRequestAttributes) requestEvent.getServletRequest().getAttribute(REQUEST_ATTRIBUTES_ATTRIBUTE);\n\t\tServletRequestAttributes threadAttributes =\n\t\t\t\t(ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n\t\tif (threadAttributes != null) {\n\t\t\t// We're assumably within the original request thread...\n\t\t\tif (attributes == null) {\n\t\t\t\tattributes = threadAttributes;\n\t\t\t}\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\tRequestContextHolder.resetRequestAttributes();\n\t\t}\n\t\tif (attributes != null) {\n\t\t\tattributes.requestCompleted();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleared thread-bound request context: \" + requestEvent.getServletRequest());\n\t\t\t}\n\t\t}\n\t}","commit_id":"5ff6191d72489c728d4fa6fbc99af4d0d03643b9","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tString descriptor = cf.lastDescriptor();\n\t\tif (descriptor == null) {\n\t\t\t// Stack is empty, should use context object\n\t\t\tcf.loadTarget(mv);\n\t\t}\n\n\t\tif (this.indexedType == IndexedType.ARRAY) {\n\t\t\tint insn;\n\t\t\tif (\"D\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[D\");\n\t\t\t\tinsn = DALOAD;\n\t\t\t}\n\t\t\telse if (\"F\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[F\");\n\t\t\t\tinsn = FALOAD;\n\t\t\t}\n\t\t\telse if (\"J\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[J\");\n\t\t\t\tinsn = LALOAD;\n\t\t\t}\n\t\t\telse if (\"I\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[I\");\n\t\t\t\tinsn = IALOAD;\n\t\t\t}\n\t\t\telse if (\"S\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[S\");\n\t\t\t\tinsn = SALOAD;\n\t\t\t}\n\t\t\telse if (\"B\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[B\");\n\t\t\t\tinsn = BALOAD;\n\t\t\t}\n\t\t\telse if (\"C\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[C\");\n\t\t\t\tinsn = CALOAD;\n\t\t\t}\n\t\t\telse { \n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[\"+ this.exitTypeDescriptor +\n\t\t\t\t\t\t(CodeFlow.isPrimitiveArray(this.exitTypeDescriptor) ? \"\" : \";\"));\n\t\t\t\t\t\t//depthPlusOne(exitTypeDescriptor)+\"Ljava/lang/Object;\");\n\t\t\t\tinsn = AALOAD;\n\t\t\t}\n\t\t\tSpelNodeImpl index = this.children[0];\n\t\t\tcf.enterCompilationScope();\n\t\t\tindex.generateCode(mv, cf);\n\t\t\tcf.exitCompilationScope();\n\t\t\tmv.visitInsn(insn);\n\t\t}\n\t\telse if (this.indexedType == IndexedType.LIST) {\n\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/util/List\");\n\t\t\tcf.enterCompilationScope();\n\t\t\tthis.children[0].generateCode(mv, cf);\n\t\t\tcf.exitCompilationScope();\n\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"get\", \"(I)Ljava/lang/Object;\", true);\n\t\t}\n\t\telse if (this.indexedType == IndexedType.MAP) {\n\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/util/Map\");\n\t\t\t// Special case when the key is an unquoted string literal that will be parsed as\n\t\t\t// a property/field reference\n\t\t\tif ((this.children[0] instanceof PropertyOrFieldReference)) {\n\t\t\t\tPropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0];\n\t\t\t\tString mapKeyName = reference.getName();\n\t\t\t\tmv.visitLdcInsn(mapKeyName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcf.enterCompilationScope();\n\t\t\t\tthis.children[0].generateCode(mv, cf);\n\t\t\t\tcf.exitCompilationScope();\n\t\t\t}\n\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n\t\t} \n\t\telse if (this.indexedType == IndexedType.OBJECT) {\n\t\t\tReflectivePropertyAccessor.OptimalPropertyAccessor accessor =\n\t\t\t\t\t(ReflectivePropertyAccessor.OptimalPropertyAccessor) this.cachedReadAccessor;\n\t\t\tMember member = accessor.member;\n\t\t\tboolean isStatic = Modifier.isStatic(member.getModifiers());\n\t\t\tString memberDeclaringClassSlashedDescriptor = member.getDeclaringClass().getName().replace('.', '/');\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, memberDeclaringClassSlashedDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (member instanceof Field) {\n\t\t\t\tmv.visitFieldInsn(isStatic ? GETSTATIC : GETFIELD, memberDeclaringClassSlashedDescriptor,\n\t\t\t\t\t\tmember.getName(), CodeFlow.toJvmDescriptor(((Field) member).getType()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitMethodInsn(isStatic? INVOKESTATIC : INVOKEVIRTUAL, memberDeclaringClassSlashedDescriptor,\n\t\t\t\t\t\tmember.getName(), CodeFlow.createSignatureDescriptor((Method) member), false);\n\t\t\t}\n\t\t} \n\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}","id":81528,"modified_method":"@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tString descriptor = cf.lastDescriptor();\n\t\tif (descriptor == null) {\n\t\t\t// Stack is empty, should use context object\n\t\t\tcf.loadTarget(mv);\n\t\t}\n\n\t\tif (this.indexedType == IndexedType.ARRAY) {\n\t\t\tint insn;\n\t\t\tif (\"D\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[D\");\n\t\t\t\tinsn = DALOAD;\n\t\t\t}\n\t\t\telse if (\"F\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[F\");\n\t\t\t\tinsn = FALOAD;\n\t\t\t}\n\t\t\telse if (\"J\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[J\");\n\t\t\t\tinsn = LALOAD;\n\t\t\t}\n\t\t\telse if (\"I\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[I\");\n\t\t\t\tinsn = IALOAD;\n\t\t\t}\n\t\t\telse if (\"S\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[S\");\n\t\t\t\tinsn = SALOAD;\n\t\t\t}\n\t\t\telse if (\"B\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[B\");\n\t\t\t\tinsn = BALOAD;\n\t\t\t}\n\t\t\telse if (\"C\".equals(this.exitTypeDescriptor)) {\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[C\");\n\t\t\t\tinsn = CALOAD;\n\t\t\t}\n\t\t\telse { \n\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"[\"+ this.exitTypeDescriptor +\n\t\t\t\t\t\t(CodeFlow.isPrimitiveArray(this.exitTypeDescriptor) ? \"\" : \";\"));\n\t\t\t\t\t\t//depthPlusOne(exitTypeDescriptor)+\"Ljava/lang/Object;\");\n\t\t\t\tinsn = AALOAD;\n\t\t\t}\n\t\t\tSpelNodeImpl index = this.children[0];\n\t\t\tcf.enterCompilationScope();\n\t\t\tindex.generateCode(mv, cf);\n\t\t\tcf.exitCompilationScope();\n\t\t\tmv.visitInsn(insn);\n\t\t}\n\n\t\telse if (this.indexedType == IndexedType.LIST) {\n\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/util/List\");\n\t\t\tcf.enterCompilationScope();\n\t\t\tthis.children[0].generateCode(mv, cf);\n\t\t\tcf.exitCompilationScope();\n\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"get\", \"(I)Ljava/lang/Object;\", true);\n\t\t}\n\n\t\telse if (this.indexedType == IndexedType.MAP) {\n\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/util/Map\");\n\t\t\t// Special case when the key is an unquoted string literal that will be parsed as\n\t\t\t// a property/field reference\n\t\t\tif ((this.children[0] instanceof PropertyOrFieldReference)) {\n\t\t\t\tPropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0];\n\t\t\t\tString mapKeyName = reference.getName();\n\t\t\t\tmv.visitLdcInsn(mapKeyName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcf.enterCompilationScope();\n\t\t\t\tthis.children[0].generateCode(mv, cf);\n\t\t\t\tcf.exitCompilationScope();\n\t\t\t}\n\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n\t\t} \n\n\t\telse if (this.indexedType == IndexedType.OBJECT) {\n\t\t\tReflectivePropertyAccessor.OptimalPropertyAccessor accessor =\n\t\t\t\t\t(ReflectivePropertyAccessor.OptimalPropertyAccessor) this.cachedReadAccessor;\n\t\t\tMember member = accessor.member;\n\t\t\tboolean isStatic = Modifier.isStatic(member.getModifiers());\n\t\t\tString classDesc = member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (member instanceof Method) {\n\t\t\t\tmv.visitMethodInsn((isStatic? INVOKESTATIC : INVOKEVIRTUAL), classDesc, member.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor((Method) member), false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) member).getType()));\n\t\t\t}\n\t\t} \n\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic TypedValue getValue() {\n\t\t\tClass<?> targetObjectRuntimeClass = getObjectClass(this.targetObject);\n\t\t\ttry {\n\t\t\t\tif (Indexer.this.cachedReadName != null && Indexer.this.cachedReadName.equals(this.name) &&\n\t\t\t\t\t\tIndexer.this.cachedReadTargetType != null &&\n\t\t\t\t\t\tIndexer.this.cachedReadTargetType.equals(targetObjectRuntimeClass)) {\n\t\t\t\t\t// It is OK to use the cached accessor\n\t\t\t\t\treturn Indexer.this.cachedReadAccessor.read(this.evaluationContext, this.targetObject, this.name);\n\t\t\t\t}\n\t\t\t\tList<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(\n\t\t\t\t\t\ttargetObjectRuntimeClass, this.evaluationContext.getPropertyAccessors());\n\t\t\t\tif (accessorsToTry != null) {\n\t\t\t\t\tfor (PropertyAccessor accessor : accessorsToTry) {\n\t\t\t\t\t\tif (accessor.canRead(this.evaluationContext, this.targetObject, this.name)) {\n\t\t\t\t\t\t\tif (accessor instanceof ReflectivePropertyAccessor) {\n\t\t\t\t\t\t\t\taccessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(\n\t\t\t\t\t\t\t\t\t\tthis.evaluationContext, this.targetObject, this.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIndexer.this.cachedReadAccessor = accessor;\n\t\t\t\t\t\t\tIndexer.this.cachedReadName = this.name;\n\t\t\t\t\t\t\tIndexer.this.cachedReadTargetType = targetObjectRuntimeClass;\n\t\t\t\t\t\t\tif (accessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor) {\n\t\t\t\t\t\t\t\tReflectivePropertyAccessor.OptimalPropertyAccessor optimalAccessor =\n\t\t\t\t\t\t\t\t\t\t(ReflectivePropertyAccessor.OptimalPropertyAccessor) accessor;\n\t\t\t\t\t\t\t\tMember member = optimalAccessor.member;\n\t\t\t\t\t\t\t\tif (member instanceof Field) {\n\t\t\t\t\t\t\t\t\tIndexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(((Field)member).getType());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tIndexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(((Method)member).getReturnType());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn accessor.read(this.evaluationContext, this.targetObject, this.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AccessException ex) {\n\t\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex, SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,\n\t\t\t\t\t\tthis.targetObjectTypeDescriptor.toString());\n\t\t\t}\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,\n\t\t\t\t\tthis.targetObjectTypeDescriptor.toString());\n\t\t}","id":81529,"modified_method":"@Override\n\t\tpublic TypedValue getValue() {\n\t\t\tClass<?> targetObjectRuntimeClass = getObjectClass(this.targetObject);\n\t\t\ttry {\n\t\t\t\tif (Indexer.this.cachedReadName != null && Indexer.this.cachedReadName.equals(this.name) &&\n\t\t\t\t\t\tIndexer.this.cachedReadTargetType != null &&\n\t\t\t\t\t\tIndexer.this.cachedReadTargetType.equals(targetObjectRuntimeClass)) {\n\t\t\t\t\t// It is OK to use the cached accessor\n\t\t\t\t\treturn Indexer.this.cachedReadAccessor.read(this.evaluationContext, this.targetObject, this.name);\n\t\t\t\t}\n\t\t\t\tList<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(\n\t\t\t\t\t\ttargetObjectRuntimeClass, this.evaluationContext.getPropertyAccessors());\n\t\t\t\tif (accessorsToTry != null) {\n\t\t\t\t\tfor (PropertyAccessor accessor : accessorsToTry) {\n\t\t\t\t\t\tif (accessor.canRead(this.evaluationContext, this.targetObject, this.name)) {\n\t\t\t\t\t\t\tif (accessor instanceof ReflectivePropertyAccessor) {\n\t\t\t\t\t\t\t\taccessor = ((ReflectivePropertyAccessor) accessor).createOptimalAccessor(\n\t\t\t\t\t\t\t\t\t\tthis.evaluationContext, this.targetObject, this.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIndexer.this.cachedReadAccessor = accessor;\n\t\t\t\t\t\t\tIndexer.this.cachedReadName = this.name;\n\t\t\t\t\t\t\tIndexer.this.cachedReadTargetType = targetObjectRuntimeClass;\n\t\t\t\t\t\t\tif (accessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor) {\n\t\t\t\t\t\t\t\tReflectivePropertyAccessor.OptimalPropertyAccessor optimalAccessor =\n\t\t\t\t\t\t\t\t\t\t(ReflectivePropertyAccessor.OptimalPropertyAccessor) accessor;\n\t\t\t\t\t\t\t\tMember member = optimalAccessor.member;\n\t\t\t\t\t\t\t\tIndexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(member instanceof Method ?\n\t\t\t\t\t\t\t\t\t\t((Method) member).getReturnType() : ((Field) member).getType());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn accessor.read(this.evaluationContext, this.targetObject, this.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AccessException ex) {\n\t\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex, SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,\n\t\t\t\t\t\tthis.targetObjectTypeDescriptor.toString());\n\t\t\t}\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,\n\t\t\t\t\tthis.targetObjectTypeDescriptor.toString());\n\t\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\n\t\tReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor)executorToCheck.get();\n\t\tMethod method = methodExecutor.getMethod();\n\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tif (descriptor == null) {\n\t\t\tif (!isStaticMethod) {\n\t\t\t\t// Nothing on the stack but something is needed\n\t\t\t\tcf.loadTarget(mv);\n\t\t\t}\n\t\t} else {\n\t\t\tif (isStaticMethod) {\n\t\t\t\t// Something on the stack when nothing is needed\n\t\t\t\tmv.visitInsn(POP);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tboolean itf = method.getDeclaringClass().isInterface();\n\t\tString methodDeclaringClassSlashedDescriptor = null;\n\t\tif (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\tmethodDeclaringClassSlashedDescriptor = method.getDeclaringClass().getName().replace('.', '/');\n\t\t}\n\t\telse {\n\t\t\tmethodDeclaringClassSlashedDescriptor = methodExecutor.getPublicDeclaringClass().getName().replace('.', '/');\t\t\t\n\t\t}\n\t\tif (!isStaticMethod) {\n\t\t\tif (descriptor == null || !descriptor.substring(1).equals(methodDeclaringClassSlashedDescriptor)) {\n\t\t\t\tCodeFlow.insertCheckCast(mv, \"L\"+ methodDeclaringClassSlashedDescriptor);\n\t\t\t}\n\t\t}\n\t\tgenerateCodeForArguments(mv, cf, method, children);\t\t\n\t\tmv.visitMethodInsn(isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL,\n\t\t\t\tmethodDeclaringClassSlashedDescriptor, method.getName(), CodeFlow.createSignatureDescriptor(method), itf);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}","id":81530,"modified_method":"@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\n\t\tReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tMethod method = methodExecutor.getMethod();\n\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tif (descriptor == null) {\n\t\t\tif (!isStaticMethod) {\n\t\t\t\t// Nothing on the stack but something is needed\n\t\t\t\tcf.loadTarget(mv);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (isStaticMethod) {\n\t\t\t\t// Something on the stack when nothing is needed\n\t\t\t\tmv.visitInsn(POP);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tString classDesc = (Modifier.isPublic(method.getDeclaringClass().getModifiers()) ?\n\t\t\t\tmethod.getDeclaringClass().getName().replace('.', '/') :\n\t\t\t\tmethodExecutor.getPublicDeclaringClass().getName().replace('.', '/'));\n\t\tif (!isStaticMethod) {\n\t\t\tif (descriptor == null || !descriptor.substring(1).equals(classDesc)) {\n\t\t\t\tCodeFlow.insertCheckCast(mv, \"L\" + classDesc);\n\t\t\t}\n\t\t}\n\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"OptimalPropertyAccessor(InvokerPair target) {\n\t\t\tthis.member = target.member;\n\t\t\tthis.typeDescriptor = target.typeDescriptor;\n\t\t\tif (this.member instanceof Field) {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\tthis.needsToBeMadeAccessible = (!Modifier.isPublic(field.getModifiers()) ||\n\t\t\t\t\t\t!Modifier.isPublic(field.getDeclaringClass().getModifiers())) && !field.isAccessible();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethod method = (Method) this.member;\n\t\t\t\tthis.needsToBeMadeAccessible = ((!Modifier.isPublic(method.getModifiers()) ||\n\t\t\t\t\t\t!Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible());\n\t\t\t}\n\t\t}","id":81531,"modified_method":"OptimalPropertyAccessor(InvokerPair target) {\n\t\t\tthis.member = target.member;\n\t\t\tthis.typeDescriptor = target.typeDescriptor;\n\t\t\tthis.needsToBeMadeAccessible = (!Modifier.isPublic(this.member.getModifiers()) ||\n\t\t\t\t\t!Modifier.isPublic(this.member.getDeclaringClass().getModifiers()));\n\t\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method) {\n\t\t\t\ttry {\n\t\t\t\t\tif (this.needsToBeMadeAccessible) {\n\t\t\t\t\t\tReflectionUtils.makeAccessible((Method) this.member);\n\t\t\t\t\t}\n\t\t\t\t\tObject value = ((Method) this.member).invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.member instanceof Field) {\n\t\t\t\ttry {\n\t\t\t\t\tif (this.needsToBeMadeAccessible) {\n\t\t\t\t\t\tReflectionUtils.makeAccessible((Field) this.member);\n\t\t\t\t\t}\n\t\t\t\t\tObject value = ((Field) this.member).get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field: \" + name, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AccessException(\"Neither getter nor field found for property '\" + name + \"'\");\n\t\t}","id":81532,"modified_method":"@Override\n\t\tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method) {\n\t\t\t\tMethod method = (Method) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tif (this.needsToBeMadeAccessible && !method.isAccessible()) {\n\t\t\t\t\t\tmethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tif (this.needsToBeMadeAccessible && !field.isAccessible()) {\n\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString memberDeclaringClassSlashedDescriptor = this.member.getDeclaringClass().getName().replace('.', '/');\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, memberDeclaringClassSlashedDescriptor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.member instanceof Field) {\n\t\t\t\tmv.visitFieldInsn(isStatic ? GETSTATIC : GETFIELD, memberDeclaringClassSlashedDescriptor,\n\t\t\t\t\t\tthis.member.getName(), CodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitMethodInsn(isStatic ? INVOKESTATIC : INVOKEVIRTUAL, memberDeclaringClassSlashedDescriptor,\n\t\t\t\t\t\tthis.member.getName(), CodeFlow.createSignatureDescriptor((Method) this.member),false);\n\t\t\t}\n\t\t}","id":81533,"modified_method":"@Override\n\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString classDesc = this.member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method) {\n\t\t\t\tmv.visitMethodInsn((isStatic ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor((Method) this.member), false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException {\n\t\tif (target == null) {\n\t\t\tthrow new AccessException(\"Cannot write property on null target\");\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\n\t\tObject possiblyConvertedNewValue = newValue;\n\t\tTypeDescriptor typeDescriptor = getTypeDescriptor(context, target, name);\n\t\tif (typeDescriptor != null) {\n\t\t\ttry {\n\t\t\t\tpossiblyConvertedNewValue = context.getTypeConverter().convertValue(\n\t\t\t\t\t\tnewValue, TypeDescriptor.forObject(newValue), typeDescriptor);\n\t\t\t}\n\t\t\tcatch (EvaluationException evaluationException) {\n\t\t\t\tthrow new AccessException(\"Type conversion failure\",evaluationException);\n\t\t\t}\n\t\t}\n\t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n\t\tMember cachedMember = this.writerCache.get(cacheKey);\n\n\t\tif (cachedMember == null || cachedMember instanceof Method) {\n\t\t\tMethod method = (Method) cachedMember;\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findSetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tcachedMember = method;\n\t\t\t\t\tthis.writerCache.put(cacheKey, cachedMember);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(target, possiblyConvertedNewValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through setter\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cachedMember == null || cachedMember instanceof Field) {\n\t\t\tField field = (Field) cachedMember;\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tcachedMember = field;\n\t\t\t\t\tthis.writerCache.put(cacheKey, cachedMember);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tfield.set(target, possiblyConvertedNewValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field: \" + name, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new AccessException(\"Neither setter nor field found for property '\" + name + \"'\");\n\t}","id":81534,"modified_method":"@Override\n\tpublic void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException {\n\t\tif (target == null) {\n\t\t\tthrow new AccessException(\"Cannot write property on null target\");\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\n\t\tObject possiblyConvertedNewValue = newValue;\n\t\tTypeDescriptor typeDescriptor = getTypeDescriptor(context, target, name);\n\t\tif (typeDescriptor != null) {\n\t\t\ttry {\n\t\t\t\tpossiblyConvertedNewValue = context.getTypeConverter().convertValue(\n\t\t\t\t\t\tnewValue, TypeDescriptor.forObject(newValue), typeDescriptor);\n\t\t\t}\n\t\t\tcatch (EvaluationException evaluationException) {\n\t\t\t\tthrow new AccessException(\"Type conversion failure\", evaluationException);\n\t\t\t}\n\t\t}\n\t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n\t\tMember cachedMember = this.writerCache.get(cacheKey);\n\n\t\tif (cachedMember == null || cachedMember instanceof Method) {\n\t\t\tMethod method = (Method) cachedMember;\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findSetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tcachedMember = method;\n\t\t\t\t\tthis.writerCache.put(cacheKey, cachedMember);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(target, possiblyConvertedNewValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through setter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cachedMember == null || cachedMember instanceof Field) {\n\t\t\tField field = (Field) cachedMember;\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tcachedMember = field;\n\t\t\t\t\tthis.writerCache.put(cacheKey, cachedMember);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tfield.set(target, possiblyConvertedNewValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new AccessException(\"Neither setter method nor field found for property '\" + name + \"'\");\n\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n\t\tif (target == null) {\n\t\t\tthrow new AccessException(\"Cannot read property of null target\");\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\n\t\tif (type.isArray() && name.equals(\"length\")) {\n\t\t\tif (target instanceof Class) {\n\t\t\t\tthrow new AccessException(\"Cannot access length on array class itself\");\n\t\t\t}\n\t\t\treturn new TypedValue(Array.getLength(target));\n\t\t}\n\n\t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invoker = this.readerCache.get(cacheKey);\n\t\tlastReadInvokerPair = invoker;\n\n\t\tif (invoker == null || invoker.member instanceof Method) {\n\t\t\tMethod method = (Method) (invoker != null ? invoker.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\t// TODO remove the duplication here between canRead and read\n\t\t\t\t\t// Treat it like a property...\n\t\t\t\t\t// The readerCache will only contain gettable properties (let's not worry about setters for now).\n\t\t\t\t\tProperty property = new Property(type, method, null);\n\t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\t\t\t\tinvoker = new InvokerPair(method, typeDescriptor);\n\t\t\t\t\tlastReadInvokerPair = invoker;\n\t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, invoker.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (invoker == null || invoker.member instanceof Field) {\n\t\t\tField field = (Field) (invoker == null ? null : invoker.member);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvoker = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tlastReadInvokerPair = invoker;\n\t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, invoker.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field: \" + name, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new AccessException(\"Neither getter nor field found for property '\" + name + \"'\");\n\t}","id":81535,"modified_method":"@Override\n\tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n\t\tif (target == null) {\n\t\t\tthrow new AccessException(\"Cannot read property of null target\");\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\n\t\tif (type.isArray() && name.equals(\"length\")) {\n\t\t\tif (target instanceof Class) {\n\t\t\t\tthrow new AccessException(\"Cannot access length on array class itself\");\n\t\t\t}\n\t\t\treturn new TypedValue(Array.getLength(target));\n\t\t}\n\n\t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invoker = this.readerCache.get(cacheKey);\n\t\tlastReadInvokerPair = invoker;\n\n\t\tif (invoker == null || invoker.member instanceof Method) {\n\t\t\tMethod method = (Method) (invoker != null ? invoker.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\t// TODO remove the duplication here between canRead and read\n\t\t\t\t\t// Treat it like a property...\n\t\t\t\t\t// The readerCache will only contain gettable properties (let's not worry about setters for now).\n\t\t\t\t\tProperty property = new Property(type, method, null);\n\t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\t\t\t\tinvoker = new InvokerPair(method, typeDescriptor);\n\t\t\t\t\tlastReadInvokerPair = invoker;\n\t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, invoker.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (invoker == null || invoker.member instanceof Field) {\n\t\t\tField field = (Field) (invoker == null ? null : invoker.member);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvoker = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tlastReadInvokerPair = invoker;\n\t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, invoker.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new AccessException(\"Neither getter method nor field found for property '\" + name + \"'\");\n\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic Class<?> getPropertyType() {\n\t\t\tif (this.member instanceof Field) {\n\t\t\t\treturn ((Field) this.member).getType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ((Method) this.member).getReturnType();\n\t\t\t}\n\t\t}","id":81536,"modified_method":"@Override\n\t\tpublic Class<?> getPropertyType() {\n\t\t\tif (this.member instanceof Method) {\n\t\t\t\treturn ((Method) this.member).getReturnType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ((Field) this.member).getType();\n\t\t\t}\n\t\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Attempt to create an optimized property accessor tailored for a property of a particular name on\n\t * a particular class. The general ReflectivePropertyAccessor will always work but is not optimal\n\t * due to the need to lookup which reflective member (method/field) to use each time read() is called.\n\t * This method will just return the ReflectivePropertyAccessor instance if it is unable to build\n\t * something more optimal.\n\t */\n\tpublic PropertyAccessor createOptimalAccessor(EvaluationContext evalContext, Object target, String name) {\n\t\t// Don't be clever for arrays or null target\n\t\tif (target == null) {\n\t\t\treturn this;\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\t\tif (type.isArray()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invocationTarget = this.readerCache.get(cacheKey);\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Method) {\n\t\t\tMethod method = (Method) (invocationTarget==null?null:invocationTarget.member);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tinvocationTarget = new InvokerPair(method,new TypeDescriptor(new MethodParameter(method,-1)));\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Field) {\n\t\t\tField field = (invocationTarget != null ? (Field) invocationTarget.member : null);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target instanceof Class);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvocationTarget = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}","id":81537,"modified_method":"/**\n\t * Attempt to create an optimized property accessor tailored for a property of a particular name on\n\t * a particular class. The general ReflectivePropertyAccessor will always work but is not optimal\n\t * due to the need to lookup which reflective member (method/field) to use each time read() is called.\n\t * This method will just return the ReflectivePropertyAccessor instance if it is unable to build\n\t * something more optimal.\n\t */\n\tpublic PropertyAccessor createOptimalAccessor(EvaluationContext evalContext, Object target, String name) {\n\t\t// Don't be clever for arrays or null target\n\t\tif (target == null) {\n\t\t\treturn this;\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\t\tif (type.isArray()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invocationTarget = this.readerCache.get(cacheKey);\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Method) {\n\t\t\tMethod method = (Method) (invocationTarget != null ? invocationTarget.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tinvocationTarget = new InvokerPair(method, new TypeDescriptor(new MethodParameter(method, -1)));\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Field) {\n\t\t\tField field = (invocationTarget != null ? (Field) invocationTarget.member : null);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target instanceof Class);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvocationTarget = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}","commit_id":"04f765506e6c383fc112613a99c24a0d5fe6d22d","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n    protected void started(TestState state) {\n        TestDescriptorInternal test = state.test;\n        if (test.getName().equals(test.getClassName())) {\n            xmlTestsuite = new XmlTestsuite(testResultsDir, test.getClassName(), state.getStartTime());\n            testSuite = state;\n        }\n    }","id":81538,"modified_method":"@Override\n    protected void started(TestState state) {\n        TestDescriptorInternal test = state.test;\n        if (test.getName().equals(test.getClassName())) {\n            xmlTestsuite = testsuiteFactory.create(testResultsDir, test.getClassName(), state.getStartTime());\n            testSuite = state;\n        }\n    }","commit_id":"1bb3ad1d00d168c4f7d6301b66d556c9d85d7a7b","url":"https://github.com/gradle/gradle"},{"original_method":"public void started(TestDescriptorInternal test, TestStartEvent event) {\n        //it would be nice if we didn't have to maintain the testId->descriptor map\n        tests.put(test.getId(), new TestInfo(test, event.getStartTime()));\n        if (!test.isComposite()) { //test method\n            if (!testSuites.containsKey(test.getClassName())) {\n                testSuites.put(test.getClassName(), new XmlTestsuite(testResultsDir, test.getClassName(), timeProvider.getCurrentTime()));\n            }\n        }\n    }","id":81539,"modified_method":"public void started(TestDescriptorInternal test, TestStartEvent event) {\n        //it would be nice if we didn't have to maintain the testId->descriptor map\n        tests.put(test.getId(), new TestInfo(test, event.getStartTime()));\n        if (!test.isComposite()) { //test method\n            if (!testSuites.containsKey(test.getClassName())) {\n                testSuites.put(test.getClassName(), testsuiteFactory.create(testResultsDir, test.getClassName(), timeProvider.getCurrentTime()));\n            }\n        }\n    }","commit_id":"1bb3ad1d00d168c4f7d6301b66d556c9d85d7a7b","url":"https://github.com/gradle/gradle"},{"original_method":"public XmlTestsuite(File testResultsDir, String className, long startTime) {\n        this.className = className;\n        this.startTime = startTime;\n        this.hostname = getHostname();\n        DocumentBuilder documentBuilder;\n        try {\n            //TODO SF push to the factory so that we don't have to initialize all the time\n            documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n        testSuiteReport = documentBuilder.newDocument();\n        rootElement = testSuiteReport.createElement(\"testsuite\");\n        testSuiteReport.appendChild(rootElement);\n        // Add an empty properties element for compatibility\n        rootElement.appendChild(testSuiteReport.createElement(\"properties\"));\n\n        outputs.put(TestOutputEvent.Destination.StdOut, new StringBuilder());\n        outputs.put(TestOutputEvent.Destination.StdErr, new StringBuilder());\n\n        reportFile = new File(testResultsDir, \"TEST-\" + className + \".xml\");\n    }","id":81540,"modified_method":"public XmlTestsuite(File testResultsDir, String className, long startTime, String hostname, Document document) {\n        this.className = className;\n        this.startTime = startTime;\n        this.hostname = hostname;\n        testSuiteReport = document;\n        rootElement = testSuiteReport.createElement(\"testsuite\");\n        testSuiteReport.appendChild(rootElement);\n        // Add an empty properties element for compatibility\n        rootElement.appendChild(testSuiteReport.createElement(\"properties\"));\n\n        outputs.put(TestOutputEvent.Destination.StdOut, new StringBuilder());\n        outputs.put(TestOutputEvent.Destination.StdErr, new StringBuilder());\n\n        reportFile = new File(testResultsDir, \"TEST-\" + className + \".xml\");\n    }","commit_id":"1bb3ad1d00d168c4f7d6301b66d556c9d85d7a7b","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultCachedMetaData(ModuleDescriptorCacheEntry entry, ModuleDescriptor moduleDescriptor, BuildCommencedTimeProvider timeProvider) {\n        this.moduleSource = entry.moduleSource;\n        this.descriptorHash = entry.moduleDescriptorHash;\n        this.ageMillis = timeProvider.getCurrentTime() - entry.createTimestamp;\n        if (moduleDescriptor == null) {\n            metaData = null;\n        } else {\n            // TODO:DAZ Should use a type field entry rather than relying on packaging != null\n            if (entry.packaging == null) {\n                metaData = new DefaultIvyModuleVersionMetaData(moduleDescriptor);\n            } else {\n                // TODO:DAZ relocation is not cached (not yet used?)\n                metaData = new DefaultMavenModuleVersionMetaData(moduleDescriptor, entry.packaging, false);\n            }\n            metaData.setChanging(entry.isChanging);\n        }\n    }","id":81541,"modified_method":"public DefaultCachedMetaData(ModuleDescriptorCacheEntry entry, MutableModuleVersionMetaData metaData, BuildCommencedTimeProvider timeProvider) {\n        this.moduleSource = entry.moduleSource;\n        this.descriptorHash = entry.moduleDescriptorHash;\n        this.ageMillis = timeProvider.getCurrentTime() - entry.createTimestamp;\n        this.metaData = metaData;\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"public VersionNumber getArtifactCacheLayoutVersion() {\n        if(isSameOrNewer(\"2.0-rc-1\")) {\n            return VersionNumber.parse(\"2.9\");\n        } else if (isSameOrNewer(\"1.12-rc-1\")) {\n            return VersionNumber.parse(\"2.6\");\n        } else if (isSameOrNewer(\"1.11-rc-1\")) {\n            return VersionNumber.parse(\"2.2\");\n        } else if (isSameOrNewer(\"1.9-rc-2\")) {\n            return VersionNumber.parse(\"2.1\");\n        } else if (isSameOrNewer(\"1.9-rc-1\")) {\n            return VersionNumber.parse(\"1.31\");\n        } else if (isSameOrNewer(\"1.7-rc-1\")) {\n            return VersionNumber.parse(\"0.26\");\n        } else if (isSameOrNewer(\"1.6-rc-1\")) {\n            return VersionNumber.parse(\"0.24\");\n        } else if (isSameOrNewer(\"1.4-rc-1\")) {\n            return VersionNumber.parse(\"0.23\");\n        } else if (isSameOrNewer(\"1.3\")) {\n            return VersionNumber.parse(\"0.15\");\n        } else {\n            return VersionNumber.parse(\"0.1\");\n        }\n    }","id":81542,"modified_method":"public VersionNumber getArtifactCacheLayoutVersion() {\n        if(isSameOrNewer(\"2.0-rc-1\")) {\n            return VersionNumber.parse(\"2.10\");\n        } else if (isSameOrNewer(\"1.12-rc-1\")) {\n            return VersionNumber.parse(\"2.6\");\n        } else if (isSameOrNewer(\"1.11-rc-1\")) {\n            return VersionNumber.parse(\"2.2\");\n        } else if (isSameOrNewer(\"1.9-rc-2\")) {\n            return VersionNumber.parse(\"2.1\");\n        } else if (isSameOrNewer(\"1.9-rc-1\")) {\n            return VersionNumber.parse(\"1.31\");\n        } else if (isSameOrNewer(\"1.7-rc-1\")) {\n            return VersionNumber.parse(\"0.26\");\n        } else if (isSameOrNewer(\"1.6-rc-1\")) {\n            return VersionNumber.parse(\"0.24\");\n        } else if (isSameOrNewer(\"1.4-rc-1\")) {\n            return VersionNumber.parse(\"0.23\");\n        } else if (isSameOrNewer(\"1.3\")) {\n            return VersionNumber.parse(\"0.15\");\n        } else {\n            return VersionNumber.parse(\"0.1\");\n        }\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleDescriptorCacheEntry createEntry(boolean changing, String packaging, HashValue moduleDescriptorHash, ModuleSource moduleSource) {\n        return new ModuleDescriptorCacheEntry(changing, packaging, false, timeProvider.getCurrentTime(), moduleDescriptorHash.asBigInteger(), moduleSource);\n    }","id":81543,"modified_method":"private ModuleDescriptorCacheEntry createEntry(ModuleVersionMetaData metaData, HashValue moduleDescriptorHash, ModuleSource moduleSource) {\n        return ModuleDescriptorCacheEntry.forMetaData(metaData, timeProvider.getCurrentTime(), moduleDescriptorHash.asBigInteger(), moduleSource);\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData cacheMetaData(ModuleComponentRepository repository, ModuleVersionMetaData metaData, ModuleSource moduleSource) {\n        ModuleDescriptor moduleDescriptor = metaData.getDescriptor();\n        LOGGER.debug(\"Recording module descriptor in cache: {} [changing = {}]\", moduleDescriptor.getModuleRevisionId(), metaData.isChanging());\n        LocallyAvailableResource resource = moduleDescriptorStore.putModuleDescriptor(repository, moduleDescriptor);\n        ModuleDescriptorCacheEntry entry = createEntry(metaData.isChanging(), getPackaging(metaData), resource.getSha1(), moduleSource);\n        getCache().put(createKey(repository, metaData.getComponentId()), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","id":81544,"modified_method":"public CachedMetaData cacheMetaData(ModuleComponentRepository repository, ModuleVersionMetaData metaData, ModuleSource moduleSource) {\n        ModuleDescriptor moduleDescriptor = metaData.getDescriptor();\n        LOGGER.debug(\"Recording module descriptor in cache: {} [changing = {}]\", moduleDescriptor.getModuleRevisionId(), metaData.isChanging());\n        LocallyAvailableResource resource = moduleDescriptorStore.putModuleDescriptor(repository, moduleDescriptor);\n        ModuleDescriptorCacheEntry entry = createEntry(metaData, resource.getSha1(), moduleSource);\n        getCache().put(createKey(repository, metaData.getComponentId()), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData cacheMissing(ModuleComponentRepository repository, ModuleComponentIdentifier id) {\n        LOGGER.debug(\"Recording absence of module descriptor in cache: {} [changing = {}]\", id, false);\n        ModuleDescriptorCacheEntry entry = createMissingEntry(false);\n        getCache().put(createKey(repository, id), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","id":81545,"modified_method":"public CachedMetaData cacheMissing(ModuleComponentRepository repository, ModuleComponentIdentifier id) {\n        LOGGER.debug(\"Recording absence of module descriptor in cache: {} [changing = {}]\", id, false);\n        ModuleDescriptorCacheEntry entry = ModuleDescriptorCacheEntry.forMissingModule(timeProvider.getCurrentTime());\n        getCache().put(createKey(repository, id), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData getCachedModuleDescriptor(ModuleComponentRepository repository, ModuleComponentIdentifier componentId) {\n        ModuleDescriptorCacheEntry moduleDescriptorCacheEntry = getCache().get(createKey(repository, componentId));\n        if (moduleDescriptorCacheEntry == null) {\n            return null;\n        }\n        if (moduleDescriptorCacheEntry.isMissing) {\n            return new DefaultCachedMetaData(moduleDescriptorCacheEntry, null, timeProvider);\n        }\n        ModuleDescriptor descriptor = moduleDescriptorStore.getModuleDescriptor(repository, componentId);\n        if (descriptor == null) {\n            // Descriptor file has been manually deleted - ignore the entry\n            return null;\n        }\n        return new DefaultCachedMetaData(moduleDescriptorCacheEntry, descriptor, timeProvider);\n    }","id":81546,"modified_method":"public CachedMetaData getCachedModuleDescriptor(ModuleComponentRepository repository, ModuleComponentIdentifier componentId) {\n        ModuleDescriptorCacheEntry entry = getCache().get(createKey(repository, componentId));\n        if (entry == null) {\n            return null;\n        }\n        if (entry.isMissing()) {\n            return new DefaultCachedMetaData(entry, entry.createMetaData(null), timeProvider);\n        }\n        ModuleDescriptor descriptor = moduleDescriptorStore.getModuleDescriptor(repository, componentId);\n        if (descriptor == null) {\n            // Descriptor file has been manually deleted - ignore the entry\n            return null;\n        }\n        return new DefaultCachedMetaData(entry, entry.createMetaData(descriptor), timeProvider);\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"ModuleDescriptorCacheEntry(boolean isChanging, String packaging, boolean isMissing, long createTimestamp, BigInteger moduleDescriptorHash, ModuleSource moduleSource) {\n        this.isChanging = isChanging;\n        this.packaging = packaging;\n        this.isMissing = isMissing;\n        this.createTimestamp = createTimestamp;\n        this.moduleSource = moduleSource;\n        this.moduleDescriptorHash = moduleDescriptorHash;\n    }","id":81547,"modified_method":"ModuleDescriptorCacheEntry(byte type, boolean isChanging, String packaging, long createTimestamp, BigInteger moduleDescriptorHash, ModuleSource moduleSource) {\n        this.type = type;\n        this.isChanging = isChanging;\n        this.packaging = packaging;\n        this.createTimestamp = createTimestamp;\n        this.moduleSource = moduleSource;\n        this.moduleDescriptorHash = moduleDescriptorHash;\n    }","commit_id":"8cc66ebc6fc66deb4092900f046b51eac195522f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void started(TestState state) {\n        TestDescriptorInternal test = state.test;\n        if (test.getName().equals(test.getClassName())) {\n            xmlTestsuite = new XmlTestsuite(testResultsDir, test.getClassName(), state.getStartTime());\n            testSuite = state;\n        }\n    }","id":81548,"modified_method":"@Override\n    protected void started(TestState state) {\n        TestDescriptorInternal test = state.test;\n        if (test.getName().equals(test.getClassName())) {\n            xmlTestsuite = factory.newSuite(testResultsDir, test.getClassName(), state.getStartTime());\n            testSuite = state;\n        }\n    }","commit_id":"0192302d6cfe3e29af51a60318f8a9fcb0ba64c9","url":"https://github.com/gradle/gradle"},{"original_method":"public void started(TestDescriptorInternal test, TestStartEvent event) {\n        //it would be nice if we didn't have to maintain the testId->descriptor map\n        tests.put(test.getId(), new TestInfo(test, event.getStartTime()));\n        if (!test.isComposite()) { //test method\n            if (!testSuites.containsKey(test.getClassName())) {\n                testSuites.put(test.getClassName(), new XmlTestsuite(testResultsDir, test.getClassName(), timeProvider.getCurrentTime()));\n            }\n        }\n    }","id":81549,"modified_method":"public void started(TestDescriptorInternal test, TestStartEvent event) {\n        //it would be nice if we didn't have to maintain the testId->descriptor map\n        tests.put(test.getId(), new TestInfo(test, event.getStartTime()));\n        if (!test.isComposite()) { //test method\n            if (!testSuites.containsKey(test.getClassName())) {\n                testSuites.put(test.getClassName(), xmlTestsuiteFactory.newSuite(testResultsDir, test.getClassName(), timeProvider.getCurrentTime()));\n            }\n        }\n    }","commit_id":"0192302d6cfe3e29af51a60318f8a9fcb0ba64c9","url":"https://github.com/gradle/gradle"},{"original_method":"public XmlTestsuite(File testResultsDir, String className, long startTime) {\n        this.className = className;\n        this.startTime = startTime;\n        this.hostname = getHostname();\n        DocumentBuilder documentBuilder;\n        try {\n            //TODO SF push to the factory so that we don't have to initialize all the time\n            documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n        testSuiteReport = documentBuilder.newDocument();\n        rootElement = testSuiteReport.createElement(\"testsuite\");\n        testSuiteReport.appendChild(rootElement);\n        // Add an empty properties element for compatibility\n        rootElement.appendChild(testSuiteReport.createElement(\"properties\"));\n\n        outputs.put(TestOutputEvent.Destination.StdOut, new StringBuilder());\n        outputs.put(TestOutputEvent.Destination.StdErr, new StringBuilder());\n\n        reportFile = new File(testResultsDir, \"TEST-\" + className + \".xml\");\n    }","id":81550,"modified_method":"XmlTestsuite(Document testSuiteReport, File testResultsDir, String className, long startTime) {\n        this.className = className;\n        this.startTime = startTime;\n        this.hostname = getHostname();\n        this.testSuiteReport = testSuiteReport;\n        rootElement = testSuiteReport.createElement(\"testsuite\");\n        testSuiteReport.appendChild(rootElement);\n        // Add an empty properties element for compatibility\n        rootElement.appendChild(testSuiteReport.createElement(\"properties\"));\n\n        outputs.put(TestOutputEvent.Destination.StdOut, new StringBuilder());\n        outputs.put(TestOutputEvent.Destination.StdErr, new StringBuilder());\n\n        reportFile = new File(testResultsDir, \"TEST-\" + className + \".xml\");\n    }","commit_id":"0192302d6cfe3e29af51a60318f8a9fcb0ba64c9","url":"https://github.com/gradle/gradle"},{"original_method":"C1Chunk( byte[] bs ) { super(0xFF); _mem=bs; _start = -1; _len = _mem.length; }","id":81551,"modified_method":"C1Chunk(byte[] bs) { _mem=bs; _start = -1; _len = _mem.length; }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return 0xFF&_mem[i+OFF]; }","id":81552,"modified_method":"@Override public long   get ( int    i ) {\n    long res = 0xFF&_mem[i+OFF];\n    assert (res == _NA) || !_vec.isNA(res);\n    return (res == _NA)?_vec._iNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) {\n    int res = 0xFF&_mem[i+OFF];\n    return (res == NA())?Double.NaN:res;\n  }","id":81553,"modified_method":"@Override public double getd( int    i ) {\n    long res = 0xFF&_mem[i+OFF];\n    assert (res == _NA) || !_vec.isNA((double)res);\n    return (res == _NA)?_vec._fNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { return        ((0xFF&_mem[i+OFF])+_bias)*_scale ; }","id":81554,"modified_method":"@Override public double getd( int    i ) {\n    long res = 0xFF&_mem[i+OFF];\n    assert res == _NA || !_vec.isNA((res+_bias)*_scale);\n    return (res == _NA)?_vec._fNA:(res+_bias)*_scale;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return (long)(((0xFF&_mem[i+OFF])+_bias)*_scale); }","id":81555,"modified_method":"@Override public long   get ( int    i ) {\n    long res = 0xFF&_mem[i+OFF];\n    assert (res == _NA) || !_vec.isNA((long)((res+_bias)*_scale));\n    return res == _NA?_vec._iNA:(long)((res+_bias)*_scale);\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C1SChunk( byte[] bs, int bias, double scale ) { super(0xFF); _mem=bs; _start = -1; _len = _mem.length;\n    _bias = bias; _scale = scale;\n    UDP.set8d(_mem,0,scale);\n    UDP.set4 (_mem,8,bias );\n  }","id":81556,"modified_method":"C1SChunk( byte[] bs, int bias, double scale ) { _mem=bs; _start = -1; _len = _mem.length;\n    _bias = bias; _scale = scale;\n    UDP.set8d(_mem,0,scale);\n    UDP.set4 (_mem,8,bias );\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C2Chunk( byte[] bs ) { super(Short.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>1; }","id":81557,"modified_method":"C2Chunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>1; }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) {\n    int res = UDP.get2(_mem,(i<<1)+OFF);\n    return res == NA()?Double.NaN:res;\n  }","id":81558,"modified_method":"@Override public double getd( int    i ) {\n    int res = UDP.get2(_mem,(i<<1)+OFF);\n    return res == _NA?_vec._fNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return UDP.get2(_mem,(i<<1)+OFF);}","id":81559,"modified_method":"@Override public long   get ( int    i ) {\n    int res = UDP.get2(_mem,(i<<1)+OFF);\n    return res == _NA?_vec._iNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return (UDP.get2(_mem,(i<<1)+OFF) == NA())?NA():(long)((UDP.get2(_mem,(i<<1)+OFF)+_bias)*_scale); }","id":81560,"modified_method":"@Override public long   get ( int    i ) {\n    long res = UDP.get2(_mem,(i<<1)+OFF);\n    return (res == _NA)?_vec._iNA:(long)((res + _bias)*_scale);\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C2SChunk( byte[] bs, int bias, double scale ) {super(Short.MIN_VALUE); _mem=bs; _start = -1; _len = (_mem.length-OFF)>>1;\n    _bias = bias; _scale = scale;\n    UDP.set8d(_mem,0,scale);\n    UDP.set4 (_mem,8,bias );\n  }","id":81561,"modified_method":"C2SChunk( byte[] bs, int bias, double scale ) { _mem=bs; _start = -1; _len = (_mem.length-OFF)>>1;\n    _bias = bias; _scale = scale;\n    UDP.set8d(_mem,0,scale);\n    UDP.set4 (_mem,8,bias );\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { return (UDP.get2(_mem,(i<<1)+OFF) == NA())?Double.NaN:((UDP.get2(_mem,(i<<1)+OFF)+_bias)*_scale); }","id":81562,"modified_method":"@Override public double getd( int    i ) {\n    long res = UDP.get2(_mem,(i<<1)+OFF);\n    return (res == _NA)?_vec._fNA:(res + _bias)*_scale;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C4Chunk( byte[] bs ) {super(Integer.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>2; }","id":81563,"modified_method":"C4Chunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>2; }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return UDP.get4(_mem,i<<2); }","id":81564,"modified_method":"@Override public long   get ( int    i ) {\n    long res = UDP.get4(_mem,i<<2);\n    return res == _NA?_vec._iNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { long res = UDP.get4(_mem,i<<2); return res == NA()?Double.NaN:res;}","id":81565,"modified_method":"@Override public double getd( int    i ) {\n    long res = UDP.get4(_mem,i<<2);\n    return res == _NA?_vec._fNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { float res = UDP.get4f(_mem,i<<2); return Float.isNaN(res)?NA():(long)res;}","id":81566,"modified_method":"@Override public long   get ( int    i ) {\n    float res = UDP.get4f(_mem,i<<2);\n    return Float.isNaN(res)?_vec._iNA:(long)res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C4FChunk( byte[] bs ) { super(Long.MIN_VALUE);_mem=bs; _start = -1; _len = _mem.length>>2; }","id":81567,"modified_method":"C4FChunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>2; }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { return       UDP.get4f(_mem,i<<2); }","id":81568,"modified_method":"@Override public double getd( int    i ) {\n    float res = UDP.get4f(_mem,i<<2);\n    return Float.isNaN(res)?_vec._fNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C8Chunk( byte[] bs ) {super(Long.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>3; }","id":81569,"modified_method":"C8Chunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>3; }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return UDP.get8(_mem,i<<3); }","id":81570,"modified_method":"@Override public long   get ( int i ) {\n    long res = UDP.get8(_mem,i<<3);\n    return  res == _NA?_vec._iNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { long res = get(i); return res == NA()?Double.NaN:UDP.get8(_mem,i<<3); }","id":81571,"modified_method":"@Override public double getd( int    i ) {\n    long res = get(i);\n    return res == _NA?_vec._fNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C8DChunk( byte[] bs ) {super(Long.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>3; }","id":81572,"modified_method":"C8DChunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>3; }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { return       UDP.get8d(_mem,i<<3); }","id":81573,"modified_method":"@Override public double getd( int    i ) {\n    double res = UDP.get8d(_mem,i<<3);\n    return Double.isNaN(res)?_vec._fNA:res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { double res = UDP.get8d(_mem,i<<3); return Double.isNaN(res)?NA():(long)res;}","id":81574,"modified_method":"@Override public long   get ( int    i ) {\n    double res = UDP.get8d(_mem,i<<3);\n    return Double.isNaN(res)?_vec._iNA:(long)res;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public final Vec vec() { return _vec; }","id":81575,"modified_method":"public final Vec vec() {\n    if(_vec == null)\n      _vec = DKV.get(_vecKey).get();\n    return _vec;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public final boolean isNA( long i ) {\n    long x = i-_start;\n    if( 0 <= x && x < _len ) return isNA0((int)x);\n    return _vec.isNA(i);\n  }","id":81576,"modified_method":"public final boolean valueIsNA(long val){return val == _vec._iNA;}","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void map( Chunk xs, Chunk ys ) {\n      for( int i=0; i<xs._len; i++ ) {\n        if( !xs.isNA(i) && !ys.isNA(i) ) {\n          double Xa = (xs.at0(i)-_meanX);\n          double Ya = (ys.at0(i)-_meanY);\n          _XXbar += Xa*Xa;\n          _YYbar += Ya*Ya;\n          _XYbar += Xa*Ya;\n        }\n      }\n    }","id":81577,"modified_method":"@Override public void map( Chunk xs, Chunk ys ) {\n      for( int i=0; i<xs._len; i++ ) {\n        double Xa = xs.getd(i);\n        double Ya = ys.getd(i);\n        if(!Double.isNaN(Xa) && !Double.isNaN(Ya)) {\n          Xa -= _meanX;\n          Ya -= _meanY;\n          _XXbar += Xa*Xa;\n          _YYbar += Ya*Ya;\n          _XYbar += Xa*Ya;\n        }\n      }\n    }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void map( Chunk xs, Chunk ys ) {\n      for( int i=0; i<xs._len; i++ ) {\n        if( !xs.isNA(i) && !ys.isNA(i) ) {\n          double fit = _beta1*xs.at(i) + _beta0;\n          double rs = fit-ys.at(i);\n          _rss += rs*rs;\n          double sr = fit-_meanY;\n          _ssr += sr*sr;\n        }\n      }\n    }","id":81578,"modified_method":"@Override public void map( Chunk xs, Chunk ys ) {\n      for( int i=0; i<xs._len; i++ ) {\n        double X = xs.getd(i); double Y = ys.getd(i);\n        if( !Double.isNaN(X) && !Double.isNaN(Y) ) {\n          double fit = _beta1*X + _beta0;\n          double rs = fit-Y;\n          _rss += rs*rs;\n          double sr = fit-_meanY;\n          _ssr += sr*sr;\n        }\n      }\n    }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void map( Chunk xs, Chunk ys ) {\n      for( int i=0; i<xs._len; i++ ) {\n        if( !xs.isNA(i) && !ys.isNA(i) ) {\n          double X = xs.at0(i);\n          _sumX += X;\n          _sumY += ys.at0(i);\n          _sumX2+= X*X;\n          _n++;\n        }\n      }\n    }","id":81579,"modified_method":"@Override public void map( Chunk xs, Chunk ys ) {\n      for( int i=0; i<xs._len; i++ ) {\n        double X = xs.getd(i);\n        double Y = ys.getd(i);\n        if( !Double.isNaN(X) && !Double.isNaN(Y)) {\n          _sumX += X;\n          _sumY += Y;\n          _sumX2+= X*X;\n          _n++;\n        }\n      }\n    }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"NewChunk( AppendableVec vec, int cidx ) {\n    super(Long.MIN_VALUE);\n    _vec = vec;                 // Owning AppendableVec\n    _cidx = cidx;               // This chunk#\n    _ls = new long[4];          // A little room for data\n    _xs = new int [4];\n    _min = Double.MAX_VALUE;\n    _max = Double.MIN_VALUE;\n    _sum = 0;\n  }","id":81580,"modified_method":"NewChunk( AppendableVec vec, int cidx ) {\n    _vec = vec;\n    _cidx = cidx;               // This chunk#\n    _ls = new long[4];          // A little room for data\n    _xs = new int [4];\n    _min = Double.MAX_VALUE;\n    _max = Double.MIN_VALUE;\n    _sum = 0;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void testImpl( long[] ls, int[] xs, Class C ) {\n    NewChunk nv = new NewChunk(null,0);\n    nv._ls = ls;\n    nv._xs = xs;\n    nv._len= ls.length;\n\n    Chunk bv = nv.compress();\n    // Compression returns the expected compressed-type:\n    assertTrue( C.isInstance(bv) );\n    // Also, we can decompress correctly\n    for( int i=0; i<ls.length; i++ )\n      assertEquals(ls[i]*DParseTask.pow10(xs[i]), bv.getd(i), bv.getd(i)*EPSILON);\n  }","id":81581,"modified_method":"private void testImpl( long[] ls, int[] xs, Class C ) {\n    AppendableVec av = new AppendableVec(Vec.newKey());\n    NewChunk nv = new NewChunk(av,0);\n    nv._ls = ls;\n    nv._xs = xs;\n    nv._len= ls.length;\n    Chunk bv = nv.compress();\n    bv._vec = av.close();\n    // Compression returns the expected compressed-type:\n    assertTrue( C.isInstance(bv) );\n    // Also, we can decompress correctly\n    for( int i=0; i<ls.length; i++ )\n      assertEquals(ls[i]*DParseTask.pow10(xs[i]), bv.getd(i), bv.getd(i)*EPSILON);\n    UKV.remove(av._key);\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public boolean isNA( long i ) { return elem2BV(elem2ChunkIdx(i)).isNA(i); }","id":81582,"modified_method":"public final boolean isNA(long l){\n    return !_replaceNAs && l == _iNA;\n  }","commit_id":"46fdb81288c3d9564b0579c5823e39feb767ee1a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override NewChunk inflate_impl(NewChunk nc) {\n    //nothing to inflate - just copy\n    nc.alloc_doubles(len());\n    for( int i=0; i< len(); i++ )\n      nc.doubles()[i] = UnsafeUtils.get4f(_mem, (i << 2));\n    nc.set_len(nc.set_len2(len()));\n    return nc;\n  }","id":81583,"modified_method":"@Override NewChunk inflate_impl(NewChunk nc) {\n    nc.set_len(0);\n    nc.set_len2(0);\n    final int len = len();\n    for( int i=0; i<len; i++ ) {\n      float res = UnsafeUtils.get4f(_mem,(i<<2));\n      if( Float.isNaN(res) ) nc.addNum(Double.NaN);\n      else nc.addNum(res);\n    }\n    return nc;\n  }","commit_id":"c29ee10bfc1267aadba603a438cab67611f7195a","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public double getd( int    i ) {\n    int res = UDP.get2(_mem,(i<<1)+OFF);\n    System.out.println(\"res = \" + res + \" NA = \" + NA());\n    return res == NA()?Double.NaN:res;\n  }","id":81584,"modified_method":"@Override public double getd( int    i ) {\n    int res = UDP.get2(_mem,(i<<1)+OFF);\n    return res == NA()?Double.NaN:res;\n  }","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { return UDP.get4(_mem,i<<2); }","id":81585,"modified_method":"@Override public double getd( int    i ) { long res = UDP.get4(_mem,i<<2); return res == NA()?Double.NaN:res;}","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C4Chunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>2; }","id":81586,"modified_method":"C4Chunk( byte[] bs ) {super(Integer.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>2; }","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return (long)UDP.get4f(_mem,i<<2); }","id":81587,"modified_method":"@Override public long   get ( int    i ) { float res = UDP.get4f(_mem,i<<2); return Float.isNaN(res)?NA():(long)res;}","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C4FChunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>2; }","id":81588,"modified_method":"C4FChunk( byte[] bs ) { super(Long.MIN_VALUE);_mem=bs; _start = -1; _len = _mem.length>>2; }","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public double getd( int    i ) { return UDP.get8(_mem,i<<3); }","id":81589,"modified_method":"@Override public double getd( int    i ) { long res = get(i); return res == NA()?Double.NaN:UDP.get8(_mem,i<<3); }","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C8Chunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>3; }","id":81590,"modified_method":"C8Chunk( byte[] bs ) {super(Long.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>3; }","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"C8DChunk( byte[] bs ) { _mem=bs; _start = -1; _len = _mem.length>>3; }","id":81591,"modified_method":"C8DChunk( byte[] bs ) {super(Long.MIN_VALUE); _mem=bs; _start = -1; _len = _mem.length>>3; }","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public long   get ( int    i ) { return (long)UDP.get8d(_mem,i<<3); }","id":81592,"modified_method":"@Override public long   get ( int    i ) { double res = UDP.get8d(_mem,i<<3); return Double.isNaN(res)?NA():(long)res;}","commit_id":"a89b6892ffd9f5a344b1fb74aca83a4a7b696bfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"boolean processZipEntries(File f, ZipElementHandler handler) {\n        if (!f.exists()) {\n            System.out.println(\"file not found: '\" + f + \"'\");\n            return false;\n        }\n        if (!f.canRead() || f.isDirectory()) {\n            System.out.println(\"not readable: '\" + f + \"'\");\n            return false;\n        }\n        ZipFile zipInputFile;\n        try {\n            zipInputFile = new ZipFile(f);\n            for (Enumeration<? extends ZipEntry> e = zipInputFile.entries(); e.hasMoreElements();) {\n                ZipEntry ze = e.nextElement();\n                if (!ze.isDirectory() && ze.getName().endsWith(\".class\") && ze.getSize() != 0)\n                    handler.handle(zipInputFile, ze);\n\n            }\n            zipInputFile.close();\n        } catch (ClassFileNameMismatch e) {\n            return false;\n        } catch (IOException e) {\n            System.out.println(\"Error processing '\" + f + \"'\");\n            e.printStackTrace(System.out);\n            return false;\n        }\n        return true;\n\n    }","id":81593,"modified_method":"boolean processZipEntries(File f, ZipElementHandler handler) {\n        if (!f.exists()) {\n            System.out.println(\"file not found: '\" + f + \"'\");\n            return false;\n        }\n        if (!f.canRead() || f.isDirectory()) {\n            System.out.println(\"not readable: '\" + f + \"'\");\n            return false;\n        }\n        if (!f.canRead() || f.isDirectory()) {\n            System.out.println(\"not readable: '\" + f + \"'\");\n            return false;\n        }\n        if (f.length() == 0) {\n            System.out.println(\"empty zip file: '\" + f + \"'\");\n            return false;\n        }\n        ZipFile zipInputFile;\n        try {\n            zipInputFile = new ZipFile(f);\n            for (Enumeration<? extends ZipEntry> e = zipInputFile.entries(); e.hasMoreElements();) {\n                ZipEntry ze = e.nextElement();\n                if (!ze.isDirectory() && ze.getName().endsWith(\".class\") && ze.getSize() != 0)\n                    handler.handle(zipInputFile, ze);\n\n            }\n            zipInputFile.close();\n        } catch (ClassFileNameMismatch e) {\n            return false;\n        } catch (IOException e) {\n            System.out.println(\"Error processing '\" + f + \"'\");\n            return false;\n        }\n        return true;\n\n    }","commit_id":"0ec293eedc0aced8b6b8ab1511ac254cf239a8b1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static void testMigrationParse(String[] args) throws Exception {\n    isTest = true;\n    new DataMigration().doMain(args);\n  }","id":81594,"modified_method":"public static boolean testMigrationParse(String[] args) throws Exception {\n    isTest = true;\n    return new DataMigration().doMain(args);\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"public void doMain(String[] args) throws Exception {\n    System.out.println(String.format(\"%s - version %s.\", getClass().getSimpleName(), ProjectInfo.getVersion()));\n    System.out.println();\n\n    if (args.length < 1) {\n      printHelp();\n      return;\n    }\n\n    Action action = parseAction(args[0]);\n    if (action == null) {\n      printMessage(String.format(\"Unsupported action : %s\", args[0]));\n      printHelp(true);\n      return;\n    }\n\n    if (action.equals(Action.METRICS)) {\n      if (args.length > 2) {\n        printMessage(\"invalid number of arguments\");\n        printHelp(true);\n        return;\n      } else if (args.length == 2) {\n        if (parseArgument(args[1])) {\n          keepOldMetricsData = true;\n        } else {\n          printMessage(\"invalid argument, expected argument \" + KEEP_OLD_METRICS_DATA);\n          printHelp(true);\n          return;\n        }\n      }\n    }\n    if (isTest) {\n      // return if we are only testing parsing.\n      return;\n    }\n\n    try {\n      CConfiguration cConf = CConfiguration.create();\n      Configuration hConf = HBaseConfiguration.create();\n\n      Injector injector = Guice.createInjector(\n        new ConfigModule(cConf, hConf),\n        new LocationRuntimeModule().getDistributedModules(),\n        new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(HBaseTableUtil.class).toProvider(HBaseTableUtilFactory.class);\n            bind(QueueAdmin.class).to(HBaseQueueAdmin.class).in(Singleton.class);\n            install(new FactoryModuleBuilder()\n                      .implement(DatasetDefinitionRegistry.class, DefaultDatasetDefinitionRegistry.class)\n                      .build(DatasetDefinitionRegistryFactory.class));\n          }\n        });\n\n      switch (action) {\n        case METRICS:\n          migrateMetricsData(injector, keepOldMetricsData);\n          break;\n        case HELP:\n          printHelp();\n          break;\n      }\n    } catch (Exception e) {\n      System.out.println(String.format(\"Failed to perform action '%s'. Reason: '%s'.\", action, e.getMessage()));\n      e.printStackTrace(System.out);\n      throw e;\n    }\n  }","id":81595,"modified_method":"public boolean doMain(String[] args) throws Exception {\n    System.out.println(String.format(\"%s - version %s.\", getClass().getSimpleName(), ProjectInfo.getVersion()));\n    System.out.println();\n\n    if (args.length < 1) {\n      printHelp();\n      return false;\n    }\n\n    Action action = parseAction(args[0]);\n    if (action == null) {\n      System.out.println(String.format(\"Unsupported action : %s\", args[0]));\n      printHelp(true);\n      return false;\n    }\n\n    if (action.equals(Action.METRICS)) {\n      if (args.length > 2) {\n        System.out.println(\"invalid number of arguments\");\n        printHelp(true);\n        return false;\n      } else if (args.length == 2) {\n        if (args[1].equals(KEEP_OLD_METRICS_DATA)) {\n          keepOldMetricsData = true;\n        } else {\n          System.out.println(\"invalid argument, expected argument \" + KEEP_OLD_METRICS_DATA);\n          printHelp(true);\n          return false;\n        }\n      }\n    }\n\n    if (isTest) {\n      return true;\n    }\n\n    CConfiguration cConf = CConfiguration.create();\n    Configuration hConf = HBaseConfiguration.create();\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new LocationRuntimeModule().getDistributedModules(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(HBaseTableUtil.class).toProvider(HBaseTableUtilFactory.class);\n          bind(QueueAdmin.class).to(HBaseQueueAdmin.class).in(Singleton.class);\n          install(new FactoryModuleBuilder()\n                    .implement(DatasetDefinitionRegistry.class, DefaultDatasetDefinitionRegistry.class)\n                    .build(DatasetDefinitionRegistryFactory.class));\n        }\n      });\n\n    switch (action) {\n      case METRICS:\n        migrateMetricsData(injector, keepOldMetricsData);\n        break;\n      case HELP:\n        printHelp();\n        break;\n    }\n    return true;\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"private void migrateMetricsData(Injector injector, boolean keepOldTables) throws Exception {\n    CConfiguration cConf = injector.getInstance(CConfiguration.class);\n    Configuration hConf = injector.getInstance(Configuration.class);\n\n    System.out.println(\"Starting metrics data migration\");\n    // find version to migrate\n    MetricHBaseTableUtil metricHBaseTableUtil = new MetricHBaseTableUtil(injector.getInstance(HBaseTableUtil.class));\n    Version version = findMetricsTableVersion(cConf, hConf, metricHBaseTableUtil);\n\n    if (version != null) {\n      System.out.println(\"Migrating Metrics Data from \" + version.name());\n      DatasetFramework framework = createRegisteredDatasetFramework(injector);\n\n      // migrate metrics data\n      DefaultMetricDatasetFactory.migrateData(cConf, hConf, framework, version, keepOldTables);\n      System.out.println(\"Successfully Migrated Metrics Data from \" + version.name());\n    } else {\n      System.out.println(\"Did not find compatible CDAP Version to migrate Metrics data from\");\n    }\n  }","id":81596,"modified_method":"private void migrateMetricsData(Injector injector, boolean keepOldTables) {\n    CConfiguration cConf = injector.getInstance(CConfiguration.class);\n    Configuration hConf = injector.getInstance(Configuration.class);\n\n    System.out.println(\"Starting metrics data migration\");\n    // find version to migrate\n    MetricHBaseTableUtil metricHBaseTableUtil = new MetricHBaseTableUtil(injector.getInstance(HBaseTableUtil.class));\n    Version version = findMetricsTableVersion(cConf, hConf, metricHBaseTableUtil);\n\n    if (version != null) {\n      System.out.println(\"Migrating Metrics Data from \" + version.name());\n      try {\n        DatasetFramework framework = createRegisteredDatasetFramework(injector);\n        // migrate metrics data\n        DefaultMetricDatasetFactory.migrateData(cConf, hConf, framework, version, keepOldTables);\n      } catch (DataMigrationException e) {\n        System.out.println(\n          String.format(\"Exception encountered during metrics migration : %s , Aborting metrics data migration\",\n                        e.getMigrationExceptionMessage()));\n      } catch (Exception e) {\n        System.out.println(String.format(\n          \"Exception encountered : %s , Aborting metrics migration\", e));\n      }\n      System.out.println(\"Successfully Migrated Metrics Data from \" + version.name());\n    } else {\n      System.out.println(\"Did not find compatible CDAP Version to migrate Metrics data from\");\n    }\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testArgumentsParsing() throws Exception {\n    // in testMigrationParse, we emit logs if there are any issues with arguments and\n    // no message is emitted if the arguments are valid\n    AtomicBoolean logs = resetLogging();\n    // valid case\n    DataMigration.testMigrationParse(new String[] {\"metrics\", \"--keep-old-metrics-data\"});\n    Assert.assertFalse(resetLogging().get());\n\n    List<String[]> validArgumentList = ImmutableList.of(new String[] {\"metrics\", \"--keep-old-metrics-data\"},\n                                                        new String[] {\"metrics\"},\n                                                        new String[] {\"help\"});\n\n    List<String[]> invalidArgumentList = ImmutableList.of(new String[] {\"metrics\", \"--keep-all-data\"},\n                                                          new String[] {\"metrics\", \"-1\", \"-2\", \"-3\"}\n                                                          );\n\n    // no logs on valid cases\n    for (String[] arguments : validArgumentList) {\n      logs = resetLogging();\n      DataMigration.testMigrationParse(arguments);\n      Assert.assertFalse(logs.get());\n    }\n\n    // logs with invalid cases\n    for (String[] arguments : invalidArgumentList) {\n      logs = resetLogging();\n      DataMigration.testMigrationParse(arguments);\n      Assert.assertTrue(logs.get());\n    }\n\n  }","id":81597,"modified_method":"@Test\n  public void testArgumentsParsing() throws Exception {\n    // in testMigrationParse, we return false if there are any issues with arguments and true if the arguments are valid\n    List<String[]> validArgumentList = ImmutableList.of(new String[] {\"metrics\", \"--keep-old-metrics-data\"},\n                                                        new String[] {\"metrics\"},\n                                                        new String[] {\"help\"});\n\n    List<String[]> invalidArgumentList = ImmutableList.of(new String[] {\"metrics\", \"--keep-all-data\"},\n                                                          new String[] {\"metrics\", \"-1\", \"-2\", \"-3\"}\n                                                          );\n    // valid cases\n    for (String[] arguments : validArgumentList) {\n      Assert.assertTrue(DataMigration.testMigrationParse(arguments));\n    }\n    // invalid cases\n    for (String[] arguments : invalidArgumentList) {\n      Assert.assertFalse(DataMigration.testMigrationParse(arguments));\n    }\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Migrates metrics data from version 2.7 and older to 2.8\n   * @param conf CConfiguration\n   * @param hConf Configuration\n   * @param datasetFramework framework to add types and datasets to\n   * @param version - version we are migrating the data from\n   * @param keepOldData - boolean flag to specify if we have to keep old metrics data\n   * @throws IOException\n   * @throws DatasetManagementException\n   */\n  public static void migrateData(CConfiguration conf, Configuration hConf, DatasetFramework datasetFramework,\n                                 MetricHBaseTableUtil.Version version, boolean keepOldData)\n    throws Exception {\n    DefaultMetricDatasetFactory factory = new DefaultMetricDatasetFactory(conf, datasetFramework);\n    MetricsDataMigrator migrator = new MetricsDataMigrator(conf, hConf, datasetFramework, factory);\n    // delete existing destination tables\n    migrator.cleanupDestinationTables();\n    setupDatasets(factory);\n    migrator.migrateMetricsTables(version, keepOldData);\n  }","id":81598,"modified_method":"/**\n   * Migrates metrics data from version 2.7 and older to 2.8\n   * @param conf CConfiguration\n   * @param hConf Configuration\n   * @param datasetFramework framework to add types and datasets to\n   * @param version - version we are migrating the data from\n   * @param keepOldData - boolean flag to specify if we have to keep old metrics data\n   * @throws DataMigrationException\n   */\n  public static void migrateData(CConfiguration conf, Configuration hConf, DatasetFramework datasetFramework,\n                                 MetricHBaseTableUtil.Version version,\n                                 boolean keepOldData) throws DataMigrationException {\n    DefaultMetricDatasetFactory factory = new DefaultMetricDatasetFactory(conf, datasetFramework);\n    MetricsDataMigrator migrator = new MetricsDataMigrator(conf, hConf, datasetFramework, factory);\n    // delete existing destination tables\n    migrator.cleanupDestinationTables();\n    try {\n      setupDatasets(factory);\n    } catch (Exception e) {\n      String msg = \"Exception creating destination tables\";\n      LOG.error(msg, e);\n      throw new DataMigrationException(msg);\n    }\n    migrator.migrateMetricsTables(version, keepOldData);\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"private MetricsTable getOrCreateMetricsTable(String tableName, DatasetProperties empty) {\n    MetricsTable table = null;\n    // for default namespace, we have to provide the complete table name.\n    tableName = \"system.\" + tableName;\n    // metrics tables are in the system namespace\n    Id.DatasetInstance metricsDatasetInstanceId = Id.DatasetInstance.from(Constants.DEFAULT_NAMESPACE, tableName);\n    try {\n      table = DatasetsUtil.getOrCreateDataset(dsFramework, metricsDatasetInstanceId,\n                                              MetricsTable.class.getName(), empty, null, null);\n    } catch (DatasetManagementException e) {\n      LOG.error(\"Cannot access or create table {}.\", tableName);\n    } catch (IOException e) {\n      LOG.error(\"Exception while creating table {}.\", tableName, e);\n      throw Throwables.propagate(e);\n    }\n    return table;\n  }","id":81599,"modified_method":"private MetricsTable getOrCreateMetricsTable(String tableName, DatasetProperties empty)\n    throws DataMigrationException {\n    MetricsTable table = null;\n    // for default namespace, we have to provide the complete table name.\n    tableName = \"system.\" + tableName;\n    // metrics tables are in the system namespace\n    Id.DatasetInstance metricsDatasetInstanceId = Id.DatasetInstance.from(Constants.DEFAULT_NAMESPACE, tableName);\n    try {\n      table = DatasetsUtil.getOrCreateDataset(dsFramework, metricsDatasetInstanceId,\n                                              MetricsTable.class.getName(), empty, null, null);\n    } catch (DatasetManagementException e) {\n      String msg = String.format(\"Cannot access or create table %s.\", tableName);\n      LOG.error(msg);\n      throw new DataMigrationException(msg);\n    } catch (IOException e) {\n      String msg = String.format(\"Exception while creating table %s\", tableName);\n      LOG.error(msg, e);\n      throw new DataMigrationException(msg);\n    }\n    return table;\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"public void migrateMetricsTables(Version cdapVersion, boolean keepOldData) throws Exception {\n    if (cdapVersion == Version.VERSION_2_6_OR_LOWER) {\n      migrateMetricsTableFromVersion26(cdapVersion);\n    } else if (cdapVersion == Version.VERSION_2_7) {\n      migrateMetricsTableFromVersion27(cdapVersion);\n    } else {\n      System.out.println(\"Unsupported version\" + cdapVersion);\n      return;\n    }\n    if (!keepOldData) {\n      System.out.println(\"Performing cleanup of old metrics tables\");\n      cleanUpOldTables(cdapVersion);\n    }\n  }","id":81600,"modified_method":"public void migrateMetricsTables(Version cdapVersion, boolean keepOldData) throws DataMigrationException {\n    if (cdapVersion == Version.VERSION_2_6_OR_LOWER) {\n      migrateMetricsTableFromVersion26(cdapVersion);\n    } else if (cdapVersion == Version.VERSION_2_7) {\n      migrateMetricsTableFromVersion27(cdapVersion);\n    } else {\n      System.out.println(\"Unsupported version\" + cdapVersion);\n      return;\n    }\n    if (!keepOldData) {\n      System.out.println(\"Performing cleanup of old metrics tables\");\n      cleanUpOldTables(cdapVersion);\n    }\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"private void deleteTables(Configuration hConf, Set<String> tablesToDelete) {\n    HBaseAdmin hAdmin = null;\n    try {\n      hAdmin = new HBaseAdmin(hConf);\n      for (HTableDescriptor desc : hAdmin.listTables()) {\n        if (tablesToDelete.contains(desc.getNameAsString())) {\n          // disable the table\n          hAdmin.disableTable(desc.getName());\n          // delete the table\n          hAdmin.deleteTable(desc.getName());\n        }\n      }\n    } catch (Exception e) {\n      System.out.println(\"Exception while deleting old tables: \" + e);\n    }\n  }","id":81601,"modified_method":"private void deleteTables(Configuration hConf, Set<String> tablesToDelete) throws DataMigrationException {\n    HBaseAdmin hAdmin = null;\n    try {\n      hAdmin = new HBaseAdmin(hConf);\n      for (HTableDescriptor desc : hAdmin.listTables()) {\n        if (tablesToDelete.contains(desc.getNameAsString())) {\n          // disable the table\n          hAdmin.disableTable(desc.getName());\n          // delete the table\n          hAdmin.deleteTable(desc.getName());\n        }\n      }\n    } catch (Exception e) {\n      LOG.error(\"Exception while trying to delete old metrics tables\", e);\n      throw new DataMigrationException(\"Failed deleting old metrics tables\");\n    }\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"public void cleanupDestinationTables() {\n    System.out.println(\"Cleaning up destination tables\");\n    String rootPrefix = cConf.get(Constants.Dataset.TABLE_PREFIX) + \"_\";\n    String destEntityTableName =  cConf.get(MetricsConstants.ConfigKeys.ENTITY_TABLE_NAME,\n                                            MetricsConstants.DEFAULT_ENTITY_TABLE_NAME);\n    destEntityTableName = getTableName(rootPrefix, Id.DatasetInstance.from(\n      Id.Namespace.from(Constants.SYSTEM_NAMESPACE), destEntityTableName));\n    String destMetricsTablePrefix =  cConf.get(MetricsConstants.ConfigKeys.METRICS_TABLE_PREFIX,\n                                               MetricsConstants.DEFAULT_METRIC_TABLE_PREFIX);\n    destMetricsTablePrefix = getTableName(rootPrefix, Id.DatasetInstance.from(\n      Id.Namespace.from(Constants.SYSTEM_NAMESPACE), destMetricsTablePrefix));\n    try {\n      HBaseAdmin hAdmin = new HBaseAdmin(hConf);\n      for (HTableDescriptor desc : hAdmin.listTables()) {\n        if (desc.getNameAsString().equals(destEntityTableName) ||\n          desc.getNameAsString().startsWith(destMetricsTablePrefix)) {\n          System.out.println(String.format(\"Deleting table %s before upgrade\", desc.getNameAsString()));\n          //disable the table\n          hAdmin.disableTable(desc.getName());\n          //delete the table\n          hAdmin.deleteTable(desc.getName());\n        }\n      }\n    } catch (Exception e) {\n      System.out.println(\"Exception during cleanup of destination tables \" + e);\n    }\n  }","id":81602,"modified_method":"public void cleanupDestinationTables() throws DataMigrationException {\n    System.out.println(\"Cleaning up destination tables\");\n    String rootPrefix = cConf.get(Constants.Dataset.TABLE_PREFIX) + \"_\";\n    String destEntityTableName =  cConf.get(MetricsConstants.ConfigKeys.ENTITY_TABLE_NAME,\n                                            MetricsConstants.DEFAULT_ENTITY_TABLE_NAME);\n    destEntityTableName = getTableName(rootPrefix, Id.DatasetInstance.from(\n      Id.Namespace.from(Constants.SYSTEM_NAMESPACE), destEntityTableName));\n    String destMetricsTablePrefix =  cConf.get(MetricsConstants.ConfigKeys.METRICS_TABLE_PREFIX,\n                                               MetricsConstants.DEFAULT_METRIC_TABLE_PREFIX);\n    destMetricsTablePrefix = getTableName(rootPrefix, Id.DatasetInstance.from(\n      Id.Namespace.from(Constants.SYSTEM_NAMESPACE), destMetricsTablePrefix));\n    try {\n      HBaseAdmin hAdmin = new HBaseAdmin(hConf);\n      for (HTableDescriptor desc : hAdmin.listTables()) {\n        if (desc.getNameAsString().equals(destEntityTableName) ||\n          desc.getNameAsString().startsWith(destMetricsTablePrefix)) {\n          System.out.println(String.format(\"Deleting table %s before upgrade\", desc.getNameAsString()));\n          //disable the table\n          hAdmin.disableTable(desc.getName());\n          //delete the table\n          hAdmin.deleteTable(desc.getName());\n        }\n      }\n    } catch (Exception e) {\n      LOG.error(\"Exception during cleanup of destination tables \" + e);\n      throw new DataMigrationException(\"Failed Cleaning up destination tables\");\n    }\n  }","commit_id":"67a6fca2b82ba3542769d87b439f8236dce76c31","url":"https://github.com/caskdata/cdap"},{"original_method":"public KVThread(CloseableHttpClient httpClient, HttpPost httpPost) {\n                m_httpClient = httpClient;\n                m_httpPost = httpPost;\n                m_context = new BasicHttpContext();\n        }","id":81603,"modified_method":"public KVThread(CloseableHttpClient httpClient, HttpPost httpPost) {\n                m_httpClient = httpClient;\n                m_context = new BasicHttpContext();\n                m_httpPost = httpPost;\n        }","commit_id":"c99a05b85a9a9bdc2b5740d5401820984094c498","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static String callProcOverJSON(String procName, ParameterSet pset,\n            String username, String password, boolean preHash, boolean admin,\n            int expectedCode, CloseableHttpClient httpclient, HttpPost httppost, HttpContext context) throws Exception {\n        // Call insert\n        String paramsInJSON = pset.toJSONString();\n        // System.out.println(paramsInJSON);\n        HashMap<String,String> params = new HashMap<String,String>();\n        params.put(\"Procedure\", procName);\n        params.put(\"Parameters\", paramsInJSON);\n        if (username != null) {\n            params.put(\"User\", username);\n        }\n        if (password != null) {\n            if (preHash) {\n                params.put(\"Hashedpassword\", getHashedPasswordForHTTPVar(password));\n            } else {\n                params.put(\"Password\", password);\n            }\n        }\n        if (admin) {\n            params.put(\"admin\", \"true\");\n        }\n\n        String varString = getHTTPVarString(params);\n\n        varString = getHTTPVarString(params);\n\n        return callProcOverJSONRaw(varString, expectedCode, httpclient, httppost, context);\n    }","id":81604,"modified_method":"public static String callProcOverJSON(String procName, ParameterSet pset,\n            String username, String password, boolean preHash, boolean admin,\n            int expectedCode, CloseableHttpClient httpclient, HttpPost httppost, HttpContext context) throws Exception {\n        // Call insert\n        String paramsInJSON = pset.toJSONString();\n\n        // System.out.println(paramsInJSON);\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"Procedure\", procName));\n        params.add(new BasicNameValuePair(\"Parameters\", paramsInJSON));\n        if (username != null) {\n            params.add(new BasicNameValuePair(\"User\", username));\n        }\n        if (password != null) {\n            if (preHash) {\n                params.add(new BasicNameValuePair(\"Hashedpassword\", getHashedPasswordForHTTPVar(password)));\n            } else {\n                params.add(new BasicNameValuePair(\"Password\", password));\n            }\n        }\n        if (admin) {\n            params.add(new BasicNameValuePair(\"admin\", \"true\"));\n        }\n\n        //String varString = getHTTPVarString(params);\n\n        //varString = getHTTPVarString(params);\n\n        return callProcOverJSONRaw(params, expectedCode, httpclient, httppost, context);\n    }","commit_id":"c99a05b85a9a9bdc2b5740d5401820984094c498","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static String callProcOverJSONRaw(String varString, int expectedCode, CloseableHttpClient httpclient,\n            HttpPost httppost, HttpContext context) throws Exception {\n        HttpEntity entity;\n        try {\n            System.out.println(\"About to send request: \" + httppost.getURI());\n            CloseableHttpResponse response = httpclient.execute(httppost, context);\n            try {\n                entity = response.getEntity();\n                if (entity != null) {\n                    long len = entity.getContentLength();\n                    if (len != -1 && len < 2048) {\n                        System.out.println(EntityUtils.toString(entity));\n                    }\n                }\n            } finally {\n                    response.close();\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error in callProcOverJSONRaw\");\n            e.printStackTrace(System.out);\n        }\n\n\n//        BufferedReader in = null;\n//        try {\n//            if(conn.getInputStream()!=null){\n//                in = new BufferedReader(\n//                        new InputStreamReader(\n//                        conn.getInputStream(), \"UTF-8\"));\n//            }\n//        } catch(IOException e){\n//            if(conn.getErrorStream()!=null){\n//                in = new BufferedReader(\n//                        new InputStreamReader(\n//                        conn.getErrorStream(), \"UTF-8\"));\n//            }\n//        }\n//        if(in==null) {\n//            throw new Exception(\"Unable to read response from server\");\n//        }\n//\n//        StringBuffer decodedString = new StringBuffer();\n//        String line;\n//        while ((line = in.readLine()) != null) {\n//            decodedString.append(line);\n//        }\n//        in.close();\n//        in = null;\n//        // get result code\n//        int responseCode = conn.getResponseCode();\n//\n//        String response = decodedString.toString();\n//\n//        try {\n//            conn.getInputStream().close();\n//            conn.disconnect();\n//        }\n//        // ignore closing problems here\n//        catch (Exception e) {}\n//        conn = null;\n\n        //System.err.println(response);\n\n        return EntityUtils.toString(entity);\n        //return response;\n    }","id":81605,"modified_method":"public static String callProcOverJSONRaw(List<NameValuePair> vals, int expectedCode, CloseableHttpClient httpclient,\n            HttpPost httppost, HttpContext context) throws Exception {\n\n        HttpEntity entity = null;\n        String entityStr = null;\n        // StringEntity jsonentity = new StringEntity(varString);\n        //httppost.setEntity(new UrlEncodedFormEntity(varList));\n\n        System.out.println(\"About to send request: \" + httppost.getURI());\n        System.out.println(\"varString: \" + vals.toString());\n\n        httppost.setEntity(new UrlEncodedFormEntity(vals));\n        CloseableHttpResponse httpResponse = httpclient.execute(httppost, context);\n        // entity = httpResponse.getEntity();\n        // if (entity != null) {\n            //long len = entity.getContentLength();\n            //System.out.println(\"Entity length: \" + len);\n            //System.out.println(EntityUtils.toString(entity));\n            //\n        System.out.println(\"POST Response Status:: \"\n            + httpResponse.getStatusLine().getStatusCode());\n         \n            BufferedReader reader = new BufferedReader(new InputStreamReader(httpResponse.getEntity().getContent()));\n             \n            String inputLine;\n            StringBuffer response = new StringBuffer();\n     \n            while ((inputLine = reader.readLine()) != null) {\n                response.append(inputLine);\n            }\n        //} else\n        //    System.out.println(\"Entity is null\");\n\n\n        return response.toString();\n        //return response;\n    }","commit_id":"c99a05b85a9a9bdc2b5740d5401820984094c498","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Same as execute() but do not log error if exception occurred. */\n  @NotNull\n  public final RunResult<T> executeSilently() {\n    mySilentExecution = true;\n    return execute();\n  }","id":81606,"modified_method":"/**\n   * Same as {@link #execute()}, but does not log an error if an exception occurs.\n   */\n  @NotNull\n  public final RunResult<T> executeSilently() {\n    mySilentExecution = true;\n    return execute();\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Application getApplication() {\n    return ApplicationManager.getApplication();\n  }","id":81607,"modified_method":"/** @deprecated use {@link ApplicationManager#getApplication()} (to be removed in IDEA 2018) */\n  protected Application getApplication() {\n    return ApplicationManager.getApplication();\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static AccessToken start() {\n    // get useful information about the write action\n    Class aClass = ObjectUtils.notNull(ReflectionUtil.getGrandCallerClass(), WriteAction.class);\n    return start(aClass);\n  }","id":81608,"modified_method":"@NotNull\n  public static AccessToken start() {\n    // get useful information about the write action\n    return start(ObjectUtils.notNull(ReflectionUtil.getGrandCallerClass(), WriteAction.class));\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public RunResult<T> execute() {\n    final RunResult<T> result = new RunResult<T>(this);\n\n    final Application application = ApplicationManager.getApplication();\n    boolean dispatchThread = application.isDispatchThread();\n    if (dispatchThread) {\n      AccessToken token = start(getClass());\n      try {\n        result.run();\n      }\n      finally {\n        token.finish();\n      }\n      return result;\n    }\n\n    if (application.isReadAccessAllowed()) {\n      LOG.error(\"Must not start write action from within read action in the other thread - deadlock is coming\");\n    }\n\n    TransactionGuard.getInstance().submitTransactionAndWait(new Runnable() {\n      @Override\n      public void run() {\n        AccessToken token = start(WriteAction.this.getClass());\n        try {\n          result.run();\n        }\n        finally {\n          token.finish();\n        }\n      }\n    });\n\n    result.throwException();\n    return result;\n  }","id":81609,"modified_method":"@NotNull\n  @Override\n  public RunResult<T> execute() {\n    final RunResult<T> result = new RunResult<T>(this);\n\n    Application application = ApplicationManager.getApplication();\n    if (application.isDispatchThread()) {\n      AccessToken token = start(getClass());\n      try {\n        result.run();\n      }\n      finally {\n        token.finish();\n      }\n      return result;\n    }\n\n    if (application.isReadAccessAllowed()) {\n      LOG.error(\"Must not start write action from within read action in the other thread - deadlock is coming\");\n    }\n\n    TransactionGuard.getInstance().submitTransactionAndWait(new Runnable() {\n      @Override\n      public void run() {\n        AccessToken token = start(WriteAction.this.getClass());\n        try {\n          result.run();\n        }\n        finally {\n          token.finish();\n        }\n      }\n    });\n\n    result.throwException();\n    return result;\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void performWriteCommandAction(@NotNull RunResult<T> result) {\n    if (!FileModificationService.getInstance().preparePsiElementsForWrite(Arrays.asList(myPsiFiles))) return;\n\n    // this is needed to prevent memory leak, since the command is put into undo queue\n    final RunResult[] results = {result};\n\n    doExecuteCommand(new Runnable() {\n      @Override\n      public void run() {\n        AccessToken token = getApplication().acquireWriteActionLock(WriteCommandAction.this.getClass());\n        try {\n          results[0].run();\n          results[0] = null;\n        }\n        finally {\n          token.finish();\n        }\n      }\n    });\n  }","id":81610,"modified_method":"private void performWriteCommandAction(@NotNull RunResult<T> result) {\n    if (!FileModificationService.getInstance().preparePsiElementsForWrite(Arrays.asList(myPsiFiles))) return;\n\n    // this is needed to prevent memory leak, since the command is put into undo queue\n    final RunResult[] results = {result};\n\n    doExecuteCommand(new Runnable() {\n      @Override\n      public void run() {\n        AccessToken token = ApplicationManager.getApplication().acquireWriteActionLock(WriteCommandAction.this.getClass());\n        try {\n          results[0].run();\n          results[0] = null;\n        }\n        finally {\n          token.finish();\n        }\n      }\n    });\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public RunResult<T> execute() {\n    Application application = ApplicationManager.getApplication();\n    final boolean dispatchThread = application.isDispatchThread();\n    if (!dispatchThread && application.isReadAccessAllowed()) {\n      LOG.error(\"Must not start write action from within read action in the other thread - deadlock is coming\");\n      throw new IllegalStateException();\n    }\n    final RunResult<T> result = new RunResult<T>(this);\n\n    if (dispatchThread) {\n      performWriteCommandAction(result);\n    } else {\n      try {\n        TransactionGuard.getInstance().submitTransactionAndWait(new Runnable() {\n          @Override\n          public void run() {\n            performWriteCommandAction(result);\n          }\n        });\n      }\n      catch (ProcessCanceledException ignored) { }\n    }\n    return result;\n  }","id":81611,"modified_method":"@NotNull\n  @Override\n  public RunResult<T> execute() {\n    Application application = ApplicationManager.getApplication();\n    boolean dispatchThread = application.isDispatchThread();\n\n    if (!dispatchThread && application.isReadAccessAllowed()) {\n      LOG.error(\"Must not start write action from within read action in the other thread - deadlock is coming\");\n      throw new IllegalStateException();\n    }\n\n    final RunResult<T> result = new RunResult<T>(this);\n    if (dispatchThread) {\n      performWriteCommandAction(result);\n    }\n    else {\n      try {\n        TransactionGuard.getInstance().submitTransactionAndWait(new Runnable() {\n          @Override\n          public void run() {\n            performWriteCommandAction(result);\n          }\n        });\n      }\n      catch (ProcessCanceledException ignored) { }\n    }\n    return result;\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T, E extends Throwable> T runWriteCommandAction(Project project, @NotNull final ThrowableComputable<T, E> computable) throws E {\n    RunResult<T> result = new WriteCommandAction<T>(project,\"\") {\n      @Override\n      protected void run(@NotNull Result<T> result) throws Throwable {\n        result.setResult(computable.compute());\n      }\n    }.execute();\n    if (result.getThrowable() != null) throw (E)result.getThrowable();\n    return result.throwException().getResultObject();\n  }","id":81612,"modified_method":"@SuppressWarnings(\"LambdaUnfriendlyMethodOverload\")\n  public static <T, E extends Throwable> T runWriteCommandAction(Project project, @NotNull final ThrowableComputable<T, E> computable) throws E {\n    RunResult<T> result = new WriteCommandAction<T>(project, \"\") {\n      @Override\n      protected void run(@NotNull Result<T> result) throws Throwable {\n        result.setResult(computable.compute());\n      }\n    }.execute();\n    Throwable t = result.getThrowable();\n    if (t != null) { @SuppressWarnings(\"unchecked\") E e = (E)t; throw e; }\n    return result.throwException().getResultObject();\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean ensureFilesWritable(@NotNull Project project, @NotNull Collection<PsiFile> psiFiles) {\n    return FileModificationService.getInstance().preparePsiElementsForWrite(psiFiles);\n  }","id":81613,"modified_method":"/** @deprecated use {@link FileModificationService#preparePsiElementsForWrite(Collection)} (to be removed in IDEA 2018) */\n  @SuppressWarnings(\"unused\")\n  public static boolean ensureFilesWritable(@NotNull Project project, @NotNull Collection<PsiFile> psiFiles) {\n    return FileModificationService.getInstance().preparePsiElementsForWrite(psiFiles);\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * See {@link CommandProcessor#executeCommand(com.intellij.openapi.project.Project, java.lang.Runnable, java.lang.String, java.lang.Object, com.intellij.openapi.command.UndoConfirmationPolicy, boolean)} for details.\n   * \n   */\n  protected boolean shouldRecordActionForActiveDocument() {\n    return true;\n  }","id":81614,"modified_method":"/**\n   * See {@link CommandProcessor#executeCommand(Project, Runnable, String, Object, UndoConfirmationPolicy, boolean)} for details.\n   */\n  protected boolean shouldRecordActionForActiveDocument() {\n    return true;\n  }","commit_id":"1bf7cacf5272429df8d63d28f239fcfecf1a03d6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static Object getValue(Packet response) {\n        if (response.getValue() != null) {\n            Object result = toObject(response.getValue());\n            if (result instanceof ClientServiceException) {\n            \tfinal ClientServiceException ex = (ClientServiceException) result;\n            \tif(ex.getThrowable() instanceof RuntimeException) {\n            \t\tthrow (RuntimeException) ex.getThrowable();\n            \t} else {\n            \t\tthrow new RuntimeException(ex.getThrowable());\n            \t}\n            }\n            return result;\n        }\n        return null;\n    }","id":81615,"modified_method":"static Object getValue(Packet response) {\n        if (response.getValue() != null) {\n            Object result = toObject(response.getValue());\n            if (result instanceof ClientServiceException) {\n            \tfinal ClientServiceException ex = (ClientServiceException) result;\n            \tUtil.throwUncheckedException(ex.getThrowable());\n            }\n            return result;\n        }\n        return null;\n    }","commit_id":"d7650f2cbff0a65f319b9a6e595336a05c6cadac","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private\n    @CheckForNull\n    RuntimeException injectElement(final InjectableElement element, final Object adaptable,\n                                   final @Nonnull DisposalCallbackRegistry registry, final InjectCallback callback) {\n\n        InjectAnnotationProcessor annotationProcessor = null;\n        String source = element.getSource();\n        boolean wasInjectionSuccessful = false;\n\n        // find an appropriate annotation processor\n        for (InjectAnnotationProcessorFactory2 factory : injectAnnotationProcessorFactories2) {\n            annotationProcessor = factory.createAnnotationProcessor(adaptable, element.getAnnotatedElement());\n            if (annotationProcessor != null) {\n                break;\n            }\n        }\n        if (annotationProcessor == null) {\n            for (InjectAnnotationProcessorFactory factory : injectAnnotationProcessorFactories) {\n                annotationProcessor = factory.createAnnotationProcessor(adaptable, element.getAnnotatedElement());\n                if (annotationProcessor != null) {\n                    break;\n                }\n            }\n        }\n\n        String name = getName(element, annotationProcessor);\n        Object injectionAdaptable = getAdaptable(adaptable, element, annotationProcessor);\n\n        RuntimeException lastInjectionException = null;\n        if (injectionAdaptable != null) {\n            \n            // prepare the set of injectors to process. if a source is given only use injectors with this name.\n            final RankedServices<Injector> injectorsToProcess;\n            if (StringUtils.isEmpty(source)) {\n                injectorsToProcess = sortedInjectors;\n            }\n            else {\n                injectorsToProcess = injectors.get(source);\n            }\n            \n            // find the right injector\n            for (Injector injector : injectorsToProcess) {\n                if (name != null || injector instanceof AcceptsNullName) {\n                    Object value = injector.getValue(injectionAdaptable, name, element.getType(), element.getAnnotatedElement(), registry);\n                    if (value != null) {\n                        lastInjectionException = callback.inject(element, value);\n                        if (lastInjectionException == null) {\n                            wasInjectionSuccessful = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // if injection failed, use default\n        if (!wasInjectionSuccessful) {\n            Result<Boolean> defaultInjectionResult = injectDefaultValue(element, annotationProcessor, callback);\n            if (defaultInjectionResult.wasSuccessfull()) {\n                // log previous injection error, if there was any\n                if (lastInjectionException != null) {\n                    // treat post-construct and validation exceptions differently, because they are sometimes used for flow-control or validation purposes\n                    if (lastInjectionException instanceof PostConstructException || lastInjectionException instanceof InvalidModelException) {\n                        log.debug(\"Although falling back to default value worked, injection into {} failed because of: \" + lastInjectionException.getMessage(), element.getAnnotatedElement(), lastInjectionException);\n                    } else {\n                        log.warn(\"Although falling back to default value worked, injection into {} failed because of: \" + lastInjectionException.getMessage(), element.getAnnotatedElement(), lastInjectionException);\n                    }\n                }\n                wasInjectionSuccessful = defaultInjectionResult.getValue();\n            } else {\n                return defaultInjectionResult.getThrowable();\n            }\n        }\n\n        // if default is not set, check if mandatory\n        if (!wasInjectionSuccessful) {\n            if (element.isOptional(annotationProcessor)) {\n                if (element.isPrimitive()) {\n                    RuntimeException throwable = injectPrimitiveInitialValue(element, callback);\n                    if (throwable != null) {\n                        return throwable;\n                    }\n                }\n            } else {\n                if (lastInjectionException != null) {\n                    return lastInjectionException;\n                } else {\n                    return new ModelClassException(\"No injector returned a non-null value!\");\n                }\n            }\n        }\n        return null;\n    }","id":81616,"modified_method":"private\n    @CheckForNull\n    RuntimeException injectElement(final InjectableElement element, final Object adaptable,\n                                   final @Nonnull DisposalCallbackRegistry registry, final InjectCallback callback) {\n\n        InjectAnnotationProcessor annotationProcessor = null;\n        String source = element.getSource();\n        boolean wasInjectionSuccessful = false;\n\n        // find an appropriate annotation processor\n        for (InjectAnnotationProcessorFactory2 factory : injectAnnotationProcessorFactories2) {\n            annotationProcessor = factory.createAnnotationProcessor(adaptable, element.getAnnotatedElement());\n            if (annotationProcessor != null) {\n                break;\n            }\n        }\n        if (annotationProcessor == null) {\n            for (InjectAnnotationProcessorFactory factory : injectAnnotationProcessorFactories) {\n                annotationProcessor = factory.createAnnotationProcessor(adaptable, element.getAnnotatedElement());\n                if (annotationProcessor != null) {\n                    break;\n                }\n            }\n        }\n\n        String name = getName(element, annotationProcessor);\n        Object injectionAdaptable = getAdaptable(adaptable, element, annotationProcessor);\n\n        RuntimeException lastInjectionException = null;\n        if (injectionAdaptable != null) {\n            \n            // prepare the set of injectors to process. if a source is given only use injectors with this name.\n            final RankedServices<Injector> injectorsToProcess;\n            if (StringUtils.isEmpty(source)) {\n                injectorsToProcess = sortedInjectors;\n            }\n            else {\n                injectorsToProcess = injectors.get(source);\n            }\n            \n            // find the right injector\n            for (Injector injector : injectorsToProcess) {\n                if (name != null || injector instanceof AcceptsNullName) {\n                    Object value = injector.getValue(injectionAdaptable, name, element.getType(), element.getAnnotatedElement(), registry);\n                    if (value != null) {\n                        lastInjectionException = callback.inject(element, value);\n                        if (lastInjectionException == null) {\n                            wasInjectionSuccessful = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // if injection failed, use default\n        if (!wasInjectionSuccessful) {\n            Result<Boolean> defaultInjectionResult = injectDefaultValue(element, annotationProcessor, callback);\n            if (defaultInjectionResult.wasSuccessfull()) {\n                // log previous injection error, if there was any\n                if (lastInjectionException != null) {\n                    log.debug(\"Although falling back to default value worked, injection into {} failed because of: \" + lastInjectionException.getMessage(), element.getAnnotatedElement(), lastInjectionException);\n                }\n                wasInjectionSuccessful = defaultInjectionResult.getValue();\n            } else {\n                return defaultInjectionResult.getThrowable();\n            }\n        }\n\n        // if default is not set, check if mandatory\n        if (!wasInjectionSuccessful) {\n            if (element.isOptional(annotationProcessor)) {\n                if (element.isPrimitive()) {\n                    RuntimeException throwable = injectPrimitiveInitialValue(element, callback);\n                    if (throwable != null) {\n                        return throwable;\n                    }\n                }\n            } else {\n                if (lastInjectionException != null) {\n                    return lastInjectionException;\n                } else {\n                    return new ModelClassException(\"No injector returned a non-null value!\");\n                }\n            }\n        }\n        return null;\n    }","commit_id":"fa2d5935325b634e76e237dd2cb3f933e21ff53e","url":"https://github.com/apache/sling"},{"original_method":"public <AdapterType> AdapterType getAdapter(Object adaptable, Class<AdapterType> type) {\n        Result<AdapterType> result = internalCreateModel(adaptable, type);\n        if (!result.wasSuccessfull()) {\n            // treat post-construct and validation exceptions differently, because they are sometimes used for flow-control or validation purposes\n            if (result.getThrowable() instanceof PostConstructException || result.getThrowable() instanceof InvalidModelException) {\n                log.debug(\"Could not adapt to model\", result.getThrowable());\n            } else {\n                log.error(\"Could not adapt to model\", result.getThrowable());\n            }\n            return null;\n        } else {\n            return result.getValue();\n        }\n    }","id":81617,"modified_method":"public <AdapterType> AdapterType getAdapter(Object adaptable, Class<AdapterType> type) {\n        Result<AdapterType> result = internalCreateModel(adaptable, type);\n        if (!result.wasSuccessfull()) {\n            log.warn(\"Could not adapt to model\", result.getThrowable());\n            return null;\n        } else {\n            return result.getValue();\n        }\n    }","commit_id":"fa2d5935325b634e76e237dd2cb3f933e21ff53e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Describe the <code>cmd<\/code> parameter\n     *\n     * @param descriptionBuffer not null\n     * @return <code>true<\/code> if it implies to describe a plugin, <code>false<\/code> otherwise.\n     * @throws MojoFailureException if any reflection exceptions occur or missing components.\n     * @throws MojoExecutionException if any\n     */\n    private boolean describeCommand( StringBuffer descriptionBuffer )\n        throws MojoFailureException, MojoExecutionException\n    {\n        if ( cmd.indexOf( \":\" ) == -1 )\n        {\n            // phase\n            try\n            {\n                DefaultLifecycleExecutor lifecycleExecutor =\n                    (DefaultLifecycleExecutor) session.lookup( LifecycleExecutor.ROLE );\n\n                Lifecycle lifecycle = (Lifecycle) lifecycleExecutor.getPhaseToLifecycleMap().get( cmd );\n\n                LifecycleMapping lifecycleMapping =\n                    (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, project.getPackaging() );\n                if ( lifecycle.getDefaultPhases() == null )\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a phase corresponding to this plugin:\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        if ( !key.equals( cmd ) )\n                        {\n                            continue;\n                        }\n\n                        if ( lifecycleMapping.getPhases( \"default\" ).get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycleMapping.getPhases( \"default\" ).get( key ) ).append(\n                                                                                                                   \"\\n\" );\n                        }\n                    }\n\n                    descriptionBuffer.append( \"\\n\" );\n                    descriptionBuffer.append(\n                                              \"It is a part of the lifecycle for the POM packaging '\"\n                                                  + project.getPackaging()\n                                                  + \"'. This lifecycle includes the following phases:\" ).append(\n                                                                                                                 \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \" );\n                        String value = (String) lifecycleMapping.getPhases( \"default\" ).get( key );\n                        if ( value != null )\n                        {\n                            for ( StringTokenizer tok = new StringTokenizer( value, \",\" ); tok.hasMoreTokens(); )\n                            {\n                                descriptionBuffer.append( tok.nextToken().trim() );\n\n                                if ( !tok.hasMoreTokens() )\n                                {\n                                    descriptionBuffer.append( \"\\n\" );\n                                }\n                                else\n                                {\n                                    descriptionBuffer.append( \", \" );\n                                }\n                            }\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n                else\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a lifecycle with the following phases: \" ).append(\n                                                                                                                   \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \" );\n                        if ( lifecycle.getDefaultPhases().get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycle.getDefaultPhases().get( key ) ).append( \"\\n\" );\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new MojoFailureException( \"ComponentLookupException: \" + e.getMessage() );\n            }\n            catch ( LifecycleExecutionException e )\n            {\n                throw new MojoFailureException( \"LifecycleExecutionException: \" + e.getMessage() );\n            }\n\n            return false;\n        }\n\n        // goals\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( cmd, session, project, cmd, true, false );\n\n        descriptionBuffer.append( \"'\" + cmd + \"' is a plugin\" ).append( \".\\n\" );\n        plugin = mojoDescriptor.getPluginDescriptor().getId();\n\n        return true;\n    }","id":81618,"modified_method":"/**\n     * Describe the <code>cmd<\/code> parameter\n     *\n     * @param descriptionBuffer not null\n     * @return <code>true<\/code> if it implies to describe a plugin, <code>false<\/code> otherwise.\n     * @throws MojoFailureException if any reflection exceptions occur or missing components.\n     * @throws MojoExecutionException if any\n     */\n    private boolean describeCommand( StringBuffer descriptionBuffer )\n        throws MojoFailureException, MojoExecutionException\n    {\n        if ( cmd.indexOf( \":\" ) == -1 )\n        {\n            // phase\n            try\n            {\n                DefaultLifecycleExecutor lifecycleExecutor =\n                    (DefaultLifecycleExecutor) session.lookup( LifecycleExecutor.ROLE );\n\n                Lifecycle lifecycle = (Lifecycle) lifecycleExecutor.getPhaseToLifecycleMap().get( cmd );\n\n                LifecycleMapping lifecycleMapping =\n                    (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, project.getPackaging() );\n                if ( lifecycle.getDefaultPhases() == null )\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a phase corresponding to this plugin:\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        if ( !key.equals( cmd ) )\n                        {\n                            continue;\n                        }\n\n                        if ( lifecycleMapping.getPhases( \"default\" ).get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycleMapping.getPhases( \"default\" ).get( key ) ).append(\n                                                                                                                   \"\\n\" );\n                        }\n                    }\n\n                    descriptionBuffer.append( \"\\n\" );\n                    descriptionBuffer.append(\n                                              \"It is a part of the lifecycle for the POM packaging '\"\n                                                  + project.getPackaging()\n                                                  + \"'. This lifecycle includes the following phases:\" ).append(\n                                                                                                                 \"\\n\" );\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \" );\n                        String value = (String) lifecycleMapping.getPhases( \"default\" ).get( key );\n                        if ( StringUtils.isNotEmpty( value ) )\n                        {\n                            for ( StringTokenizer tok = new StringTokenizer( value, \",\" ); tok.hasMoreTokens(); )\n                            {\n                                descriptionBuffer.append( tok.nextToken().trim() );\n\n                                if ( !tok.hasMoreTokens() )\n                                {\n                                    descriptionBuffer.append( \"\\n\" );\n                                }\n                                else\n                                {\n                                    descriptionBuffer.append( \", \" );\n                                }\n                            }\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n                else\n                {\n                    descriptionBuffer.append( \"'\" + cmd + \"' is a lifecycle with the following phases: \" );\n                    descriptionBuffer.append( \"\\n\" );\n\n                    for ( Iterator it = lifecycle.getPhases().iterator(); it.hasNext(); )\n                    {\n                        String key = (String) it.next();\n\n                        descriptionBuffer.append( \"* \" + key + \": \" );\n                        if ( lifecycle.getDefaultPhases().get( key ) != null )\n                        {\n                            descriptionBuffer.append( lifecycle.getDefaultPhases().get( key ) ).append( \"\\n\" );\n                        }\n                        else\n                        {\n                            descriptionBuffer.append( \"NOT DEFINED\" ).append( \"\\n\" );\n                        }\n                    }\n                }\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new MojoFailureException( \"ComponentLookupException: \" + e.getMessage() );\n            }\n            catch ( LifecycleExecutionException e )\n            {\n                throw new MojoFailureException( \"LifecycleExecutionException: \" + e.getMessage() );\n            }\n\n            return false;\n        }\n\n        // goals\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( cmd, session, project, cmd, true, false );\n\n        descriptionBuffer.append( \"'\" + cmd + \"' is a plugin\" ).append( \".\\n\" );\n        plugin = mojoDescriptor.getPluginDescriptor().getId();\n\n        return true;\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method for displaying the component requirements of the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer contains information to be printed or displayed\n     */\n    private void describeMojoRequirements( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"\\n\" );\n\n        List reqs = md.getRequirements();\n\n        if ( reqs == null || reqs.isEmpty() )\n        {\n            buffer.append( \"\\nThis mojo doesn't have any component requirements.\" );\n        }\n        else\n        {\n            buffer.append( \"\\nComponent Requirements:\\n\" );\n\n            String line = \"\\n\" + StringUtils.repeat( \"=\", LINE_LENGTH );\n\n            int idx = 0;\n            for ( Iterator it = reqs.iterator(); it.hasNext(); idx++ )\n            {\n                ComponentRequirement req = (ComponentRequirement) it.next();\n\n                buffer.append( line );\n\n                buffer.append( \"\\n[\" ).append( idx ).append( \"] \" );\n                buffer.append( \"Role: \" ).append( req.getRole() );\n\n                String hint = req.getRoleHint();\n                if ( hint != null )\n                {\n                    buffer.append( \"\\nRole-Hint: \" ).append( hint );\n                }\n\n                buffer.append( \"\\n\" );\n            }\n\n            buffer.append( line );\n        }\n    }","id":81619,"modified_method":"/**\n     * Method for displaying the component requirements of the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer contains information to be printed or displayed\n     */\n    private void describeMojoRequirements( MojoDescriptor md, StringBuffer buffer )\n    {\n        List reqs = md.getRequirements();\n\n        if ( reqs == null || reqs.isEmpty() )\n        {\n            append( buffer, \"This mojo doesn't have any component requirements.\", 1 );\n            return;\n        }\n\n        append( buffer, \"Component Requirements:\", 1 );\n\n        // indent 2\n        int idx = 0;\n        for ( Iterator it = reqs.iterator(); it.hasNext(); idx++ )\n        {\n            ComponentRequirement req = (ComponentRequirement) it.next();\n\n            buffer.append( \"\\n\" );\n\n            append( buffer, \"[\" + idx + \"] Role\", req.getRole(), 2 );\n\n            String hint = req.getRoleHint();\n            if ( StringUtils.isNotEmpty( hint ) )\n            {\n                append( buffer, \"Role-Hint\", hint, 2 );\n            }\n        }\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method for retrieving the plugin description\n     *\n     * @param pd        contains the plugin description\n     * @param buffer    contains the information to be displayed or printed\n     */\n    private void describePlugin( PluginDescriptor pd, StringBuffer buffer )\n    {\n        String name = pd.getName();\n        if ( name == null )\n        {\n            name = pd.getId();\n        }\n\n        buffer.append( \"Plugin: \\'\" ).append( name ).append( '\\'' );\n        buffer.append( \"\\n\" ).append( StringUtils.repeat( \"-\", LINE_LENGTH ) );\n        buffer.append( \"\\nGroup Id:  \" ).append( pd.getGroupId() );\n        buffer.append( \"\\nArtifact Id: \" ).append( pd.getArtifactId() );\n        buffer.append( \"\\nVersion:     \" ).append( pd.getVersion() );\n        buffer.append( \"\\nGoal Prefix: \" ).append( pd.getGoalPrefix() );\n\n        buffer.append( \"\\nDescription:\\n\\n\" );\n        prettyAppend( formatDescription( pd.getDescription() ), buffer );\n        buffer.append( \"\\n\" );\n\n        if ( full || medium )\n        {\n            buffer.append( \"\\nMojos:\\n\" );\n\n            String line = \"\\n\" + StringUtils.repeat( \"=\", LINE_LENGTH );\n\n            for ( Iterator it = pd.getMojos().iterator(); it.hasNext(); )\n            {\n                MojoDescriptor md = (MojoDescriptor) it.next();\n\n                if ( full )\n                {\n                    buffer.append( line );\n                    buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( '\\'' );\n                    buffer.append( line );\n\n                    describeMojoGuts( md, buffer, true );\n\n                    buffer.append( line );\n                    buffer.append( \"\\n\\n\" );\n                }\n                else\n                {\n                    buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( '\\'' );\n\n                    describeMojoGuts( md, buffer, false );\n\n                    buffer.append( \"\\n\" );\n                }\n            }\n        }\n        else\n        {\n            buffer.append( \"\\n\" );\n            buffer.append( \"For more information, use 'mvn help:describe [...] -Dfull'\" );\n            buffer.append( \"\\n\" );\n        }\n    }","id":81620,"modified_method":"/**\n     * Method for retrieving the plugin description\n     *\n     * @param pd        contains the plugin description\n     * @param buffer    contains the information to be displayed or printed\n     */\n    private void describePlugin( PluginDescriptor pd, StringBuffer buffer )\n    {\n        String name = pd.getName();\n        if ( name == null )\n        {\n            name = pd.getId();\n        }\n\n        append( buffer, name, 0 );\n        append( buffer, \"Group Id\", pd.getGroupId(), 0 );\n        append( buffer, \"Artifact Id\", pd.getArtifactId(), 0 );\n        append( buffer, \"Version\", pd.getVersion(), 0 );\n        append( buffer, \"Goal Prefix\", pd.getGoalPrefix(), 0 );\n        appendAsParagraph( buffer, \"Description\", toDescription( pd.getDescription() ), 0 );\n        buffer.append( \"\\n\" );\n\n        if ( full || medium )\n        {\n            append( buffer, \"This plugin has \" + pd.getMojos().size() + \" goals:\", 0 );\n            buffer.append( \"\\n\" );\n\n            for ( Iterator it = pd.getMojos().iterator(); it.hasNext(); )\n            {\n                MojoDescriptor md = (MojoDescriptor) it.next();\n\n                if ( full )\n                {\n                    describeMojoGuts( md, buffer, true );\n                }\n                else\n                {\n                    describeMojoGuts( md, buffer, false );\n                }\n\n                buffer.append( \"\\n\" );\n            }\n        }\n        else\n        {\n            buffer.append( \"For more information, run 'mvn help:describe [...] -Dfull'\" );\n            buffer.append( \"\\n\" );\n        }\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method for retrieving the description of the plugin\n     *\n     * @param pi    holds information of the plugin whose description is to be retrieved\n     * @return  a PluginDescriptor where the plugin description is to be retrieved\n     * @throws MojoExecutionException\n     * @throws MojoFailureException\n     */\n    private PluginDescriptor lookupPluginDescriptor( PluginInfo pi )\n        throws MojoExecutionException, MojoFailureException\n    {\n        PluginDescriptor descriptor = null;\n\n        Plugin forLookup = null;\n\n        if ( pi.prefix != null )\n        {\n            descriptor = pluginManager.getPluginDescriptorForPrefix( pi.prefix );\n\n            if ( descriptor == null )\n            {\n                forLookup = pluginManager.getPluginDefinitionForPrefix( pi.prefix, session, project );\n            }\n        }\n        else if ( pi.groupId != null && pi.artifactId != null )\n        {\n            forLookup = new Plugin();\n\n            forLookup.setGroupId( pi.groupId );\n            forLookup.setArtifactId( pi.artifactId );\n\n            if ( pi.version != null )\n            {\n                forLookup.setVersion( pi.version );\n            }\n        }\n        else\n        {\n            StringBuffer msg = new StringBuffer();\n            msg.append( \"You must either specify 'groupId' and 'artifactId' both parameters, or a valid 'plugin' \" +\n                    \"parameter. For instance:\\n\" );\n            msg.append( \"  # mvn help:describe -Dplugin=org.apache.maven.plugins:maven-help-plugin\\n\" );\n            msg.append( \"or\\n\" );\n            msg.append( \"  # mvn help:describe -DgroupId=org.apache.maven.plugins -DartifactId=maven-help-plugin\\n\\n\" );\n            msg.append( \"Try 'mvn help:help -Ddetail=true' for more informations.\" );\n\n            throw new MojoFailureException( msg.toString() );\n        }\n\n        if ( descriptor == null && forLookup != null )\n        {\n            try\n            {\n                descriptor = pluginManager.verifyPlugin( forLookup, project, settings, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\"\n                    + groupId + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\"\n                    + groupId + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\"\n                    + groupId + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                throw new MojoExecutionException( \"Plugin dependency does not exist: \" + e.getMessage(), e );\n            }\n            catch ( InvalidVersionSpecificationException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\"\n                    + groupId + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( InvalidPluginException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: \\'\"\n                    + groupId + \"\\'\\nartifactId: \\'\" + artifactId + \"\\'\\nversion: \\'\" + version + \"\\'\\n\\n\", e );\n            }\n            catch ( PluginNotFoundException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Unable to find plugin\", e );\n                }\n                throw new MojoFailureException( \"Plugin does not exist: \" + e.getMessage() );\n            }\n            catch ( PluginVersionNotFoundException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Unable to find plugin version\", e );\n                }\n                throw new MojoFailureException( e.getMessage() );\n            }\n        }\n\n        if ( descriptor == null )\n        {\n            throw new MojoFailureException( \"Plugin could not be found. If you believe it is correct,\"\n                + \" check your pluginGroups setting, and run with -U to update the remote configuration\" );\n        }\n\n        return descriptor;\n    }","id":81621,"modified_method":"/**\n     * Method for retrieving the description of the plugin\n     *\n     * @param pi    holds information of the plugin whose description is to be retrieved\n     * @return  a PluginDescriptor where the plugin description is to be retrieved\n     * @throws MojoExecutionException\n     * @throws MojoFailureException\n     */\n    private PluginDescriptor lookupPluginDescriptor( PluginInfo pi )\n        throws MojoExecutionException, MojoFailureException\n    {\n        PluginDescriptor descriptor = null;\n\n        Plugin forLookup = null;\n\n        if ( StringUtils.isNotEmpty( pi.prefix ) )\n        {\n            descriptor = pluginManager.getPluginDescriptorForPrefix( pi.prefix );\n            if ( descriptor == null )\n            {\n                forLookup = pluginManager.getPluginDefinitionForPrefix( pi.prefix, session, project );\n            }\n        }\n        else if ( StringUtils.isNotEmpty( pi.groupId ) && StringUtils.isNotEmpty( pi.artifactId ) )\n        {\n            forLookup = new Plugin();\n\n            forLookup.setGroupId( pi.groupId );\n            forLookup.setArtifactId( pi.artifactId );\n\n            if ( StringUtils.isNotEmpty( pi.version ) )\n            {\n                forLookup.setVersion( pi.version );\n            }\n        }\n        else\n        {\n            StringBuffer msg = new StringBuffer();\n            msg.append( \"You must either specify 'groupId' and 'artifactId' both parameters, or a valid 'plugin' \" +\n                    \"parameter. For instance:\\n\" );\n            msg.append( \"  # mvn help:describe -Dplugin=org.apache.maven.plugins:maven-help-plugin\\n\" );\n            msg.append( \"or\\n\" );\n            msg.append( \"  # mvn help:describe -DgroupId=org.apache.maven.plugins -DartifactId=maven-help-plugin\\n\\n\" );\n            msg.append( \"Try 'mvn help:help -Ddetail=true' for more informations.\" );\n\n            throw new MojoFailureException( msg.toString() );\n        }\n\n        if ( descriptor == null && forLookup != null )\n        {\n            try\n            {\n                descriptor = pluginManager.verifyPlugin( forLookup, project, settings, localRepository );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: '\"\n                    + groupId + \"'\\nartifactId: '\" + artifactId + \"'\\nversion: '\" + version + \"'\\n\\n\", e );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: '\"\n                    + groupId + \"'\\nartifactId: '\" + artifactId + \"'\\nversion: '\" + version + \"'\\n\\n\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: '\"\n                    + groupId + \"'\\nartifactId: '\" + artifactId + \"'\\nversion: '\" + version + \"'\\n\\n\", e );\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                throw new MojoExecutionException( \"Plugin dependency does not exist: \" + e.getMessage(), e );\n            }\n            catch ( InvalidVersionSpecificationException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: '\"\n                    + groupId + \"'\\nartifactId: '\" + artifactId + \"'\\nversion: '\" + version + \"'\\n\\n\", e );\n            }\n            catch ( InvalidPluginException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving plugin descriptor for:\\n\\ngroupId: '\"\n                    + groupId + \"'\\nartifactId: '\" + artifactId + \"'\\nversion: '\" + version + \"'\\n\\n\", e );\n            }\n            catch ( PluginNotFoundException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Unable to find plugin\", e );\n                }\n                throw new MojoFailureException( \"Plugin does not exist: \" + e.getMessage() );\n            }\n            catch ( PluginVersionNotFoundException e )\n            {\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"Unable to find plugin version\", e );\n                }\n                throw new MojoFailureException( e.getMessage() );\n            }\n        }\n\n        if ( descriptor == null )\n        {\n            throw new MojoFailureException( \"Plugin could not be found. If you believe it is correct,\"\n                + \" check your pluginGroups setting, and run with -U to update the remote configuration\" );\n        }\n\n        return descriptor;\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( project == null )\n        {\n            try\n            {\n                project = projectBuilder.buildStandaloneSuperProject( localRepository );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new MojoExecutionException( \"Error while retrieving the super-project.\", e );\n            }\n        }\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        boolean describePlugin = true;\n        if ( StringUtils.isNotEmpty( cmd ) )\n        {\n            describePlugin = describeCommand( descriptionBuffer );\n        }\n\n        if ( describePlugin )\n        {\n            PluginInfo pi = new PluginInfo();\n\n            parsePluginLookupInfo( pi );\n\n            PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n            if ( mojo != null && mojo.length() > 0 )\n            {\n                describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n            }\n            else\n            {\n                describePlugin( descriptor, descriptionBuffer );\n            }\n        }\n\n        writeDescription( descriptionBuffer );\n    }","id":81622,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( project == null )\n        {\n            try\n            {\n                project = projectBuilder.buildStandaloneSuperProject( localRepository );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new MojoExecutionException( \"Error while retrieving the super-project.\", e );\n            }\n        }\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        boolean describePlugin = true;\n        if ( StringUtils.isNotEmpty( cmd ) )\n        {\n            describePlugin = describeCommand( descriptionBuffer );\n        }\n\n        if ( describePlugin )\n        {\n            PluginInfo pi = new PluginInfo();\n\n            parsePluginLookupInfo( pi );\n\n            PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n            if ( StringUtils.isNotEmpty( mojo ) )\n            {\n                describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n            }\n            else\n            {\n                describePlugin( descriptor, descriptionBuffer );\n            }\n        }\n\n        writeDescription( descriptionBuffer );\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method for parsing the plugin parameter\n     *\n     * @param pi    contains information about the plugin whose description is to be retrieved\n     * @throws MojoFailureException\n     */\n    private void parsePluginLookupInfo( PluginInfo pi )\n        throws MojoFailureException\n    {\n        if ( plugin != null && plugin.length() > 0 )\n        {\n            if ( plugin.indexOf( \":\" ) > -1 )\n            {\n                String[] pluginParts = plugin.split( \":\" );\n\n                switch ( pluginParts.length )\n                {\n                    case ( 1 ):\n                        pi.prefix = pluginParts[0];\n                        break;\n                    case ( 2 ):\n                        pi.groupId = pluginParts[0];\n                        pi.artifactId = pluginParts[1];\n                        break;\n                    case ( 3 ):\n                        pi.groupId = pluginParts[0];\n                        pi.artifactId = pluginParts[1];\n                        pi.version = pluginParts[2];\n                        break;\n                    default:\n                        throw new MojoFailureException(\n                                                        \"plugin parameter must be a plugin prefix, or conform to: 'groupId:artifactId[:version].\" );\n                }\n            }\n            else\n            {\n                pi.prefix = plugin;\n            }\n        }\n        else\n        {\n            pi.groupId = groupId;\n            pi.artifactId = artifactId;\n            pi.version = version;\n        }\n    }","id":81623,"modified_method":"/**\n     * Method for parsing the plugin parameter\n     *\n     * @param pi    contains information about the plugin whose description is to be retrieved\n     * @throws MojoFailureException\n     */\n    private void parsePluginLookupInfo( PluginInfo pi )\n        throws MojoFailureException\n    {\n        if ( StringUtils.isNotEmpty( plugin ) )\n        {\n            if ( plugin.indexOf( \":\" ) > -1 )\n            {\n                String[] pluginParts = plugin.split( \":\" );\n\n                switch ( pluginParts.length )\n                {\n                    case ( 1 ):\n                        pi.prefix = pluginParts[0];\n                        break;\n                    case ( 2 ):\n                        pi.groupId = pluginParts[0];\n                        pi.artifactId = pluginParts[1];\n                        break;\n                    case ( 3 ):\n                        pi.groupId = pluginParts[0];\n                        pi.artifactId = pluginParts[1];\n                        pi.version = pluginParts[2];\n                        break;\n                    default:\n                        throw new MojoFailureException(\n                                                        \"plugin parameter must be a plugin prefix, or conform to: 'groupId:artifactId[:version].\" );\n                }\n            }\n            else\n            {\n                pi.prefix = plugin;\n            }\n        }\n        else\n        {\n            pi.groupId = groupId;\n            pi.artifactId = artifactId;\n            pi.version = version;\n        }\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Displays parameter information of the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer contains information to be printed or displayed\n     */\n    private void describeMojoParameters( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"\\n\" );\n\n        List params = md.getParameters();\n\n        if ( params == null || params.isEmpty() )\n        {\n            buffer.append( \"\\nThis mojo doesn't use any parameters.\" );\n        }\n        else\n        {\n            buffer.append( \"\\nParameters:\" );\n\n            String line = \"\\n\" + StringUtils.repeat( \"=\", LINE_LENGTH );\n\n            int idx = 0;\n            for ( Iterator it = params.iterator(); it.hasNext(); )\n            {\n                Parameter parameter = (Parameter) it.next();\n\n                buffer.append( line );\n                buffer.append( \"\\n\\n[\" ).append( idx++ ).append( \"] \" );\n                buffer.append( \"Name: \" );\n                prettyAppend( parameter.getName(), buffer );\n\n                String alias = parameter.getAlias();\n                if ( alias != null )\n                {\n                    buffer.append( \" (Alias: \" ).append( alias ).append( \")\" );\n                }\n\n                buffer.append( \"\\nType: \" );\n                prettyAppend( parameter.getType(), buffer );\n\n                String expression = parameter.getExpression();\n                if ( expression != null )\n                {\n                    buffer.append( \"\\nExpression: \" ).append( expression );\n                }\n\n                String defaultVal = parameter.getDefaultValue();\n                if ( defaultVal != null )\n                {\n                    buffer.append( \"\\nDefault value: \\'\" ).append( defaultVal );\n                }\n\n                buffer.append( \"\\nRequired: \" ).append( parameter.isRequired() );\n                buffer.append( \"\\nDirectly editable: \" ).append( parameter.isEditable() );\n\n                buffer.append( \"\\nDescription:\\n\" );\n                prettyAppend( formatDescription( parameter.getDescription() ), buffer );\n\n                String deprecation = parameter.getDeprecated();\n\n                if ( deprecation != null )\n                {\n                    buffer.append( \"\\n\\nNOTE: This parameter is deprecated.\\n\" ).append( deprecation ).append(\n                                                                                                               \"\\n\" );\n                }\n\n                buffer.append( \"\\n\" );\n            }\n\n            buffer.append( line );\n        }\n    }","id":81624,"modified_method":"/**\n     * Displays parameter information of the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer contains information to be printed or displayed\n     */\n    private void describeMojoParameters( MojoDescriptor md, StringBuffer buffer )\n    {\n        List params = md.getParameters();\n\n        if ( params == null || params.isEmpty() )\n        {\n            append( buffer, \"This mojo doesn't use any parameters.\", 1 );\n            return;\n        }\n\n        append( buffer, \"Parameters:\", 1 );\n\n        // indent 2\n        int idx = 0;\n        for ( Iterator it = params.iterator(); it.hasNext(); )\n        {\n            Parameter parameter = (Parameter) it.next();\n\n            buffer.append( \"\\n\" );\n\n            append( buffer, \"[\" + idx++ + \"] Name\", parameter.getName()\n                + ( StringUtils.isEmpty( parameter.getAlias() ) ? \"\" : \" (Alias: \" + parameter.getAlias() + \")\" ),\n                    2 );\n\n            append( buffer, \"Type\", parameter.getType(), 2 );\n\n            String expression = parameter.getExpression();\n            if ( StringUtils.isNotEmpty( expression ) )\n            {\n                append( buffer, \"Expression\", expression, 2 );\n            }\n\n            String defaultVal = parameter.getDefaultValue();\n            if ( StringUtils.isNotEmpty( defaultVal ) )\n            {\n                append( buffer, \"Default value\", \"'\" + defaultVal + \"'\", 2 );\n            }\n\n            append( buffer, \"Required\", parameter.isRequired() + \"\", 2 );\n            append( buffer, \"Directly editable\", parameter.isEditable() + \"\", 2 );\n\n            appendAsParagraph( buffer, \"Description\", toDescription( parameter.getDescription() ), 2 );\n\n            String deprecation = parameter.getDeprecated();\n            if ( StringUtils.isNotEmpty( deprecation ) )\n            {\n                append( buffer, \"NOTE: This parameter is deprecated.\" + deprecation, 2 );\n            }\n        }\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method for putting the appropriate value to the plugin description\n     *\n     * @param messagePart   the plugin description\n     * @param buffer        contains information to be printed or displayed\n     */\n    private void prettyAppend( String messagePart, StringBuffer buffer )\n    {\n        if ( messagePart != null && messagePart.length() > 0 )\n        {\n            buffer.append( messagePart );\n        }\n        else\n        {\n            buffer.append( \"Unknown\" );\n        }\n    }","id":81625,"modified_method":"/**\n     * Append a description to the buffer by respecting the indentSize and lineLength parameters.\n     * <b>Note<\/b>: The last character is always a new line.\n     *\n     * @param sb The buffer to append the description, not <code>null<\/code>.\n     * @param description The description, not <code>null<\/code>.\n     * @param indent The base indentation level of each line, must not be negative.\n     */\n    private static void append( StringBuffer sb, String description, int indent )\n    {\n        if ( StringUtils.isEmpty( description ) )\n        {\n            sb.append( \"Unknown\" ).append( '\\n' );\n            return;\n        }\n\n        for ( Iterator it = HelpMojo.toLines( description, indent, INDENT_SIZE, LINE_LENGTH ).iterator(); it.hasNext(); )\n        {\n            sb.append( it.next().toString() ).append( '\\n' );\n        }\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Displays detailed information about the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer contains information to be printed or displayed\n     * @param fullDescription specifies whether all the details about the Plugin Mojo is to  be displayed\n     */\n    private void describeMojoGuts( MojoDescriptor md, StringBuffer buffer, boolean fullDescription )\n    {\n        buffer.append( \"\\nDescription:\\n\" );\n        prettyAppend( formatDescription( md.getDescription() ), buffer );\n        if ( fullDescription )\n        {\n            buffer.append( \"\\n\" );\n        }\n\n        String deprecation = md.getDeprecated();\n\n        if ( deprecation != null )\n        {\n            buffer.append( \"\\n\\nNOTE: This mojo is deprecated.\\n\" ).append( deprecation ).append( \"\\n\" );\n        }\n\n        if ( fullDescription )\n        {\n            buffer.append( \"\\nImplementation: \" ).append( md.getImplementation() );\n            buffer.append( \"\\nLanguage: \" ).append( md.getLanguage() );\n\n            String phase = md.getPhase();\n            if ( phase != null )\n            {\n                buffer.append( \"\\nBound to Phase: \" ).append( phase );\n            }\n\n            String eGoal = md.getExecuteGoal();\n            String eLife = md.getExecuteLifecycle();\n            String ePhase = md.getExecutePhase();\n\n            if ( eGoal != null || ePhase != null )\n            {\n                buffer.append( \"\\n\\nBefore this mojo executes, it will call:\\n\" );\n\n                if ( eGoal != null )\n                {\n                    buffer.append( \"\\nSingle mojo: \\'\" ).append( eGoal ).append( \"\\'\" );\n                }\n\n                if ( ePhase != null )\n                {\n                    buffer.append( \"\\nPhase: \\'\" ).append( ePhase ).append( \"\\'\" );\n\n                    if ( eLife != null )\n                    {\n                        buffer.append( \" in Lifecycle Overlay: \\'\" ).append( eLife ).append( \"\\'\" );\n                    }\n                }\n            }\n\n            describeMojoParameters( md, buffer );\n\n            describeMojoRequirements( md, buffer );\n        }\n    }","id":81626,"modified_method":"/**\n     * Displays detailed information about the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer contains information to be printed or displayed\n     * @param fullDescription specifies whether all the details about the Plugin Mojo is to  be displayed\n     */\n    private void describeMojoGuts( MojoDescriptor md, StringBuffer buffer, boolean fullDescription )\n    {\n        append( buffer, \"Goal\", \"'\" + md.getGoal() + \"'\", 0 );\n\n        // indent 1\n        append( buffer, \"Full Goal Name\", \"'\" + md.getFullGoalName() + \"'\", 1 );\n        appendAsParagraph( buffer, \"Description\", toDescription( md.getDescription() ), 1 );\n\n        String deprecation = md.getDeprecated();\n        if ( StringUtils.isNotEmpty( deprecation ) )\n        {\n            append( buffer, \"NOTE: This mojo is deprecated. \" + deprecation, 1 );\n        }\n\n        if ( !fullDescription )\n        {\n            return;\n        }\n\n        append( buffer, \"Implementation\", md.getImplementation(), 1 );\n        append( buffer, \"Language\", md.getLanguage(), 1 );\n\n        String phase = md.getPhase();\n        if ( StringUtils.isNotEmpty( phase ) )\n        {\n            append( buffer, \"Bound to phase\", phase, 1 );\n        }\n\n        String eGoal = md.getExecuteGoal();\n        String eLife = md.getExecuteLifecycle();\n        String ePhase = md.getExecutePhase();\n\n        if ( StringUtils.isNotEmpty( eGoal ) || StringUtils.isNotEmpty( ePhase ) )\n        {\n            append( buffer, \"Before this mojo executes, it will call:\", 1);\n\n            if ( StringUtils.isNotEmpty( eGoal ) )\n            {\n                append( buffer, \"Single mojo\", \"'\" + eGoal + \"'\", 2 );\n            }\n\n            if ( StringUtils.isNotEmpty( ePhase ) )\n            {\n                String s = \"Phase: '\" + ePhase + \"'\";\n\n                if ( StringUtils.isNotEmpty( eLife ) )\n                {\n                    s += \" in Lifecycle Overlay: '\" + eLife + \"'\";\n                }\n\n                append( buffer, s, 2 );\n            }\n        }\n\n        buffer.append( \"\\n\" );\n\n        describeMojoParameters( md, buffer );\n\n        buffer.append( \"\\n\" );\n\n        describeMojoRequirements( md, buffer );\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method for formatting the description.\n     *\n     * @param description   the plugin description\n     * @return a String of the formatted plugin description\n     */\n    private String formatDescription( String description )\n    {\n        if ( description == null )\n        {\n            return null;\n        }\n\n        String result = description.replaceAll( \" ?\\\\<br\\\\/?\\\\> ?\", \"\\n\" );\n\n        result = result.replaceAll( \" ?\\\\<p\\\\> ?\", \"\" );\n        result = result.replaceAll( \" ?\\\\<\/p\\\\> ?\", \"\\n\\n\" );\n\n        return result;\n    }","id":81627,"modified_method":"/**\n     * Gets the effective string to use for the plugin/mojo/parameter description.\n     *\n     * @param description The description of the element, may be <code>null<\/code>.\n     * @return The effective description string, never <code>null<\/code>.\n     */\n    private static String toDescription( String description )\n    {\n        if ( StringUtils.isNotEmpty( description ) )\n        {\n            return PluginUtils.toText( description );\n        }\n\n        return \"(no description available)\";\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Displays information about the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer the displayed output\n     */\n    private void describeMojo( MojoDescriptor md, StringBuffer buffer )\n    {\n        String line = \"\\n\" + StringUtils.repeat( \"=\", LINE_LENGTH );\n\n        buffer.append( \"Mojo: \\'\" ).append( md.getFullGoalName() ).append( '\\'' );\n        buffer.append( line );\n        buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( \"\\'\" );\n\n        describeMojoGuts( md, buffer, full );\n\n        buffer.append( line );\n        buffer.append( \"\\n\\n\" );\n    }","id":81628,"modified_method":"/**\n     * Displays information about the Plugin Mojo\n     *\n     * @param md contains the description of the Plugin Mojo\n     * @param buffer the displayed output\n     */\n    private void describeMojo( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"Mojo: '\" ).append( md.getFullGoalName() ).append( \"'\" );\n        buffer.append( '\\n' );\n\n        describeMojoGuts( md, buffer, full );\n        buffer.append( \"\\n\" );\n\n        if ( !( full || medium ) )\n        {\n            buffer.append( \"For more information, run 'mvn help:describe [...] -Dfull'\" );\n            buffer.append( \"\\n\" );\n        }\n    }","commit_id":"56d124841f3c710248d37003edf2a80fa7625577","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public Query get(QueryParserSettings queryString) {\n        return cache.getIfPresent(queryString);\n    }","id":81629,"modified_method":"@Override\n    public Query get(QueryParserSettings queryString) {\n        Query value =  cache.getIfPresent(queryString);\n        if (value != null) {\n            return value.clone();\n        } else {\n            return null;\n        }\n    }","commit_id":"730b83c03cf4cafa0c9fe27a63408af967c9bc12","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void store(TransientConfigurationResults object) {\n            cache.put(configuration, object);\n        }","id":81630,"modified_method":"public TransientConfigurationResults load(Factory<TransientConfigurationResults> createIfNotPresent) {\n            TransientConfigurationResults out = cache.getIfPresent(configuration);\n            if (out != null) {\n                stats.readFromCache();\n                return out;\n            }\n            long start = System.currentTimeMillis();\n            TransientConfigurationResults value = createIfNotPresent.create();\n            stats.readFromDisk(start);\n            cache.put(configuration, value);\n            return value;\n        }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"public SimpleStore(Cache<Configuration, TransientConfigurationResults> cache, Configuration configuration) {\n            this.cache = cache;\n            this.configuration = configuration;\n        }","id":81631,"modified_method":"public SimpleStore(Cache<ConfigurationInternal, TransientConfigurationResults> cache, ConfigurationInternal configuration, Stats stats) {\n            this.cache = cache;\n            this.configuration = configuration;\n            this.stats = stats;\n        }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedStoreFactory(int maxItems) {\n        cache = CacheBuilder.newBuilder().maximumSize(maxItems).build();\n    }","id":81632,"modified_method":"public CachedStoreFactory(int maxItems) {\n        cache = CacheBuilder.newBuilder().maximumSize(maxItems).build();\n        stats = new Stats();\n    }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"public void close() {\n        cache.cleanUp();\n    }","id":81633,"modified_method":"public void close() {\n        LOG.info(\"Resolved configuration cache: cache reads: \"\n                + stats.readsFromCache + \", disk reads: \"\n                + stats.readsFromDisk + \" (avg: \" + stats.getDiskReadsAvgMs() + \", total: \" + stats.diskReadsTotalMs + \")\");\n    }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"public Store<TransientConfigurationResults> createCachedStore(final Configuration configuration) {\n        return new SimpleStore(cache, configuration);\n    }","id":81634,"modified_method":"public Store<TransientConfigurationResults> createCachedStore(final ConfigurationInternal configuration) {\n        return new SimpleStore(cache, configuration, stats);\n    }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"public Store<TransientConfigurationResults> createCachedStore(final Configuration configuration) {\n        return cachedStoreFactory.createCachedStore(configuration);\n    }","id":81635,"modified_method":"public Store<TransientConfigurationResults> createCachedStore(final ConfigurationInternal configuration) {\n        return cachedStoreFactory.createCachedStore(configuration);\n    }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"public TransientConfigurationResults load(ResolvedContentsMapping mapping) {\n        synchronized (lock) {\n            TransientConfigurationResults cached = cache.load();\n            if (cached != null) {\n                return cached;\n            }\n\n            Clock clock = new Clock();\n            DefaultTransientConfigurationResults results = new DefaultTransientConfigurationResults();\n            DataInputStream input = binaryStore.getInput();\n            int valuesRead = 0;\n            short lastValue = -1;\n            try {\n                while (true) {\n                    ResolvedConfigurationIdentifierSerializer s = new ResolvedConfigurationIdentifierSerializer();\n                    short type = input.readShort();\n                    ResolvedConfigurationIdentifier id;\n                    valuesRead++;\n                    lastValue = type;\n                    switch (type) {\n                        case NEW_DEP:\n                            id = s.read((DataInput) input);\n                            results.allDependencies.put(id, new DefaultResolvedDependency(id.getId(), id.getConfiguration()));\n                            break;\n                        case ROOT:\n                            id = s.read((DataInput) input);\n                            results.root = results.allDependencies.get(id);\n                            //root should be the last\n                            cache.store(results);\n                            LOG.info(\"Loaded dependency resolution results ({}) from {}\", clock.getTime(), binaryStore);\n                            return results;\n                        case FIRST_LVL:\n                            id = s.read((DataInput) input);\n                            results.firstLevelDependencies.put(mapping.getModuleDependency(id), results.allDependencies.get(id));\n                            break;\n                        case PARENT_CHILD:\n                            DefaultResolvedDependency parent = results.allDependencies.get(s.read((DataInput) input));\n                            DefaultResolvedDependency child = results.allDependencies.get(s.read((DataInput) input));\n                            parent.addChild(child);\n                            break;\n                        case PARENT_ARTIFACT:\n                            DefaultResolvedDependency c = results.allDependencies.get(s.read((DataInput) input));\n                            DefaultResolvedDependency p = results.allDependencies.get(s.read((DataInput) input));\n                            c.addParentSpecificArtifacts(p, newHashSet(mapping.getArtifact(input.readLong())));\n                            break;\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Problems loading the resolution result (\" + clock.getTime() + \") from \" + binaryStore.diagnose() + \". Read \" + valuesRead + \" values, last was: \" + lastValue, e);\n            }\n        }\n    }","id":81636,"modified_method":"public TransientConfigurationResults load(final ResolvedContentsMapping mapping) {\n        synchronized (lock) {\n            TransientConfigurationResults value = cache.load(new Factory<TransientConfigurationResults>() {\n                public TransientConfigurationResults create() {\n                    return deserialize(mapping);\n                }\n            });\n            return value;\n        }\n    }","commit_id":"78b0265b47567ed80606139485bdad2ae2b3aabf","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Updates the cache with all the documents that:\n     *\n     * (1) currently have their older versions in the cache or\n     * (2) have been neither put nor invalidated during the tracker lifetime.\n     *\n     * We can't cache documents that has been invalidated during the tracker\n     * lifetime, as it's possible that the invalidated version was newer than\n     * the one passed in the docs parameter.\n     *\n     * If the document has been added during the tracker lifetime, but it is not\n     * present in the cache anymore, it means it may have been evicted, so we\n     * can't re-add it for the same reason as above.\n     *\n     * @param tracker\n     *            used to decide whether the docs should be put into cache\n     * @param docs\n     *            to put into cache\n     */\n    public void putNonConflictingDocs(CacheChangesTracker tracker, Iterable<NodeDocument> docs) {\n        for (NodeDocument d : docs) {\n            if (d == null || d == NodeDocument.NULL) {\n                continue;\n            }\n            String id = d.getId();\n            Lock lock = locks.acquire(id);\n            try {\n                // if an old document is present in the cache, we can simply update it\n                if (getIfPresent(id) != null) {\n                    putIfNewer(d);\n                // if the document hasn't been invalidated or added during the tracker lifetime,\n                // we can put it as well\n                } else if (!tracker.mightBeenAffected(id)) {\n                    putIfNewer(d);\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }","id":81637,"modified_method":"/**\n     * Updates the cache with all the documents that:\n     *\n     * (1) currently have their older versions in the cache or\n     * (2) have been neither put nor invalidated during the tracker lifetime.\n     *\n     * We can't cache documents that has been invalidated during the tracker\n     * lifetime, as it's possible that the invalidated version was newer than\n     * the one passed in the docs parameter.\n     *\n     * If the document has been added during the tracker lifetime, but it is not\n     * present in the cache anymore, it means it may have been evicted, so we\n     * can't re-add it for the same reason as above.\n     *\n     * @param tracker\n     *            used to decide whether the docs should be put into cache\n     * @param docs\n     *            to put into cache\n     */\n    public void putNonConflictingDocs(CacheChangesTracker tracker, Iterable<NodeDocument> docs) {\n        for (NodeDocument d : docs) {\n            if (d == null || d == NodeDocument.NULL) {\n                continue;\n            }\n            String id = d.getId();\n            Lock lock = locks.acquire(id);\n            try {\n                NodeDocument cachedDoc = getIfPresent(id);\n                // if an old document is present in the cache, we can simply update it\n                if (cachedDoc != null && isNewer(cachedDoc, d)) {\n                    putInternal(d);\n                // if the document hasn't been invalidated or added during the tracker lifetime,\n                // we can put it as well\n                } else if (cachedDoc == null && !tracker.mightBeenAffected(id)) {\n                    putInternal(d);\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }","commit_id":"cfa2aacedfe421b1eea3e07220b0d17cce8106e1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Puts document into cache iff no entry with the given key is cached\n     * already or the cached document is older (has smaller {@link Document#MOD_COUNT}).\n     *\n     * @param doc the document to add to the cache\n     * @return either the given <code>doc<\/code> or the document already present\n     *         in the cache if it's newer\n     */\n    @Nonnull\n    public NodeDocument putIfNewer(@Nonnull final NodeDocument doc) {\n        if (doc == NodeDocument.NULL) {\n            throw new IllegalArgumentException(\"doc must not be NULL document\");\n        }\n        doc.seal();\n\n        NodeDocument newerDoc;\n\n        String id = doc.getId();\n        Lock lock = locks.acquire(id);\n        try {\n            NodeDocument cachedDoc = getIfPresent(id);\n            if (cachedDoc == null || cachedDoc == NodeDocument.NULL) {\n                newerDoc = doc;\n                putInternal(doc);\n            } else {\n                Long cachedModCount = cachedDoc.getModCount();\n                Long modCount = doc.getModCount();\n\n                if (cachedModCount == null || modCount == null) {\n                    throw new IllegalStateException(\"Missing \" + Document.MOD_COUNT);\n                }\n\n                if (modCount > cachedModCount) {\n                    newerDoc = doc;\n                    putInternal(doc);\n                } else {\n                    newerDoc = cachedDoc;\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        return newerDoc;\n    }","id":81638,"modified_method":"/**\n     * Puts document into cache iff no entry with the given key is cached\n     * already or the cached document is older (has smaller {@link Document#MOD_COUNT}).\n     *\n     * @param doc the document to add to the cache\n     * @return either the given <code>doc<\/code> or the document already present\n     *         in the cache if it's newer\n     */\n    @Nonnull\n    public NodeDocument putIfNewer(@Nonnull final NodeDocument doc) {\n        if (doc == NodeDocument.NULL) {\n            throw new IllegalArgumentException(\"doc must not be NULL document\");\n        }\n        doc.seal();\n\n        NodeDocument newerDoc;\n\n        String id = doc.getId();\n        Lock lock = locks.acquire(id);\n        try {\n            NodeDocument cachedDoc = getIfPresent(id);\n            if (isNewer(cachedDoc, doc)) {\n                newerDoc = doc;\n                putInternal(doc);\n            } else {\n                newerDoc = cachedDoc;\n            }\n        } finally {\n            lock.unlock();\n        }\n        return newerDoc;\n    }","commit_id":"cfa2aacedfe421b1eea3e07220b0d17cce8106e1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean handleDslError(Throwable e) {\n    if (project.isDisposed() || ApplicationManager.getApplication().isUnitTestMode()) {\n      return true;\n    }\n    if (file != null) {\n      GroovyDslFileIndex.invokeDslErrorPopup(e, project, file);\n    }\n    return false;\n  }","id":81639,"modified_method":"public boolean handleDslError(Throwable e) {\n    if (project.isDisposed() || ApplicationManager.getApplication().isUnitTestMode()) {\n      return true;\n    }\n    if (file != null) {\n      GroovyDslFileIndex.invokeDslErrorPopup(e, project, file);\n    }\n    return false;\n  }","commit_id":"7aadd5876d51b8713daf238cc071c153298bd1e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiClassType[] getExtendsListTypes() {\n    return new PsiClassType[]{ TypesUtil.createTypeByFQClassName(GroovyCommonClassNames.GROOVY_LANG_SCRIPT, this)};\n  }","id":81640,"modified_method":"@NotNull\n  public PsiClassType[] getExtendsListTypes() {\n    final PsiClassType superClassFromDSL = GroovyDslFileIndex.pocessScriptSuperClasses(myFile);\n    return new PsiClassType[]{ superClassFromDSL != null ? superClassFromDSL : TypesUtil.createTypeByFQClassName(GroovyCommonClassNames.GROOVY_LANG_SCRIPT, this)};\n  }","commit_id":"7aadd5876d51b8713daf238cc071c153298bd1e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiMethod[] getMethods() {\n    return CachedValuesManager.getCachedValue(this, new CachedValueProvider<PsiMethod[]>() {\n      @Nullable\n      @Override\n      public Result<PsiMethod[]> compute() {\n        if (!myInitialized) {\n          initMethods();\n        }\n\n        PsiMethod[] methods = myFile.getMethods();\n\n        byte hasMain = 1;\n        byte hasRun = 1;\n        for (PsiMethod method : methods) {\n          if (method.isEquivalentTo(myMainMethod)) {\n            hasMain = 0;\n          }\n          else if (method.isEquivalentTo(myRunMethod)) hasRun = 0;\n        }\n        if (hasMain + hasRun == 0) return Result.create(methods, myFile);\n\n        PsiMethod[] result = new PsiMethod[methods.length + hasMain + hasRun];\n        if (hasMain == 1) result[0] = myMainMethod;\n        if (hasRun == 1) result[hasMain] = myRunMethod;\n        System.arraycopy(methods, 0, result, hasMain + hasRun, methods.length);\n\n        return Result.create(result, myFile);\n      }\n    });\n  }","id":81641,"modified_method":"@NotNull\n  public PsiMethod[] getMethods() {\n    return CachedValuesManager.getCachedValue(this, new CachedValueProvider<PsiMethod[]>() {\n      @Nullable\n      @Override\n      public Result<PsiMethod[]> compute() {\n        if (!myInitialized) {\n          initMethods();\n        }\n\n        PsiMethod[] methods = myFile.getMethods();\n\n        int addMain = hasMain(methods) ? 0 : 1;\n        int addRun = hasRun(methods) ? 0 : 1;\n\n        PsiMethod[] result = initMethods(methods, addMain, addRun);\n        return Result.create(result, myFile);\n      }\n    });\n  }","commit_id":"4e1ade32f5676a28f2daa2f37f146fea3c83c84d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiClassType[] getExtendsListTypes() {\n    final PsiClassType superClassFromDSL = GroovyDslFileIndex.pocessScriptSuperClasses(myFile);\n    PsiClassType superClass = superClassFromDSL != null ? superClassFromDSL\n                                                        : TypesUtil.createTypeByFQClassName(GroovyCommonClassNames.GROOVY_LANG_SCRIPT, this);\n    return new PsiClassType[]{superClass};\n  }","id":81642,"modified_method":"@NotNull\n  public PsiClassType[] getExtendsListTypes() {\n    PsiClassType type = getSuperClassTypeFromBaseScriptAnnotatedVariable();\n    if (type != null) {\n      return new PsiClassType[]{type};\n    }\n\n    final PsiClassType superClassFromDSL = GroovyDslFileIndex.pocessScriptSuperClasses(myFile);\n    if (superClassFromDSL != null) {\n      return new PsiClassType[]{superClassFromDSL};\n    }\n\n    PsiClassType superClass = TypesUtil.createTypeByFQClassName(GroovyCommonClassNames.GROOVY_LANG_SCRIPT, this);\n    return new PsiClassType[]{superClass};\n  }","commit_id":"4e1ade32f5676a28f2daa2f37f146fea3c83c84d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IPortletEntity createPortletEntity(IPortletDefinitionId portletDefinitionId, String channelSubscribeId, int userId) {\n        Validate.notNull(portletDefinitionId, \"portletDefinitionId can not be null\");\n        Validate.notNull(channelSubscribeId, \"channelSubscribeId can not be null\");\n        \n        return this.portletEntityDao.createPortletEntity(portletDefinitionId, channelSubscribeId, userId);\n    }","id":81643,"modified_method":"public IPortletEntity createPortletEntity(IPortletDefinitionId portletDefinitionId, String channelSubscribeId, int userId) {\n        Validate.notNull(portletDefinitionId, \"portletDefinitionId can not be null\");\n        Validate.notNull(channelSubscribeId, \"channelSubscribeId can not be null\");\n        \n        return new InterimPortletEntityImpl(portletDefinitionId, channelSubscribeId, userId);\n    }","commit_id":"854e90857d5ea48380a9897fd7cea794329dbfcb","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IPortletEntity getPortletEntity(String portletEntityIdString) {\n        Validate.notNull(portletEntityIdString, \"portletEntityId can not be null\");\n        \n        final long portletEntityIdLong;\n        try {\n            portletEntityIdLong = Long.parseLong(portletEntityIdString);\n        }\n        catch (NumberFormatException nfe) {\n            throw new IllegalArgumentException(\"PortletEntityId must parsable as a long\", nfe);\n        }\n        \n        final PortletEntityIdImpl portletEntityId = new PortletEntityIdImpl(portletEntityIdLong);\n        return this.portletEntityDao.getPortletEntity(portletEntityId);\n    }","id":81644,"modified_method":"public IPortletEntity getPortletEntity(String portletEntityIdString) {\n        Validate.notNull(portletEntityIdString, \"portletEntityId can not be null\");\n        \n        IPortletEntity portletEntity = null;\n\n        if (InterimPortletEntityImpl.isInterimPortletEntityId(portletEntityIdString)) {\n            portletEntity = new InterimPortletEntityImpl(portletEntityIdString);\n        } else {\n            final long portletEntityIdLong;\n            try {\n                portletEntityIdLong = Long.parseLong(portletEntityIdString);\n            } catch (NumberFormatException nfe) {\n                throw new IllegalArgumentException(\n                        \"PortletEntityId must parsable as a long\", nfe);\n            }\n\n            final PortletEntityIdImpl portletEntityId = new PortletEntityIdImpl(portletEntityIdLong);\n            portletEntity = this.portletEntityDao.getPortletEntity(portletEntityId);\n        }\n        \n        return portletEntity;\n    }","commit_id":"854e90857d5ea48380a9897fd7cea794329dbfcb","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IPortletDefinition getParentPortletDefinition(IPortletEntityId portletEntityId) {\n        Validate.notNull(portletEntityId, \"portletEntityId can not be null\");\n        \n        final IPortletEntity portletEntity = this.getPortletEntity(portletEntityId);\n        final IPortletDefinitionId portletDefinitionId = portletEntity.getPortletDefinitionId();\n        return this.portletDefinitionRegistry.getPortletDefinition(portletDefinitionId);\n    }","id":81645,"modified_method":"public IPortletDefinition getParentPortletDefinition(IPortletEntityId portletEntityId) {\n        Validate.notNull(portletEntityId, \"portletEntityId can not be null\");\n        \n        IPortletDefinitionId portletDefinitionId = null;\n        if (InterimPortletEntityImpl.isInterimPortletEntityId(portletEntityId)) {\n            IPortletEntity portletEntity = new InterimPortletEntityImpl(portletEntityId);\n            portletDefinitionId = portletEntity.getPortletDefinitionId();\n        } else {\n            final IPortletEntity portletEntity = this.getPortletEntity(portletEntityId);\n            portletDefinitionId = portletEntity.getPortletDefinitionId();\n        }\n\n        return this.portletDefinitionRegistry.getPortletDefinition(portletDefinitionId);\n    }","commit_id":"854e90857d5ea48380a9897fd7cea794329dbfcb","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void storePortletEntity(IPortletEntity portletEntity) {\n        Validate.notNull(portletEntity, \"portletEntity can not be null\");\n        \n        this.portletEntityDao.updatePortletEntity(portletEntity);\n    }","id":81646,"modified_method":"public void storePortletEntity(IPortletEntity portletEntity) {\n        Validate.notNull(portletEntity, \"portletEntity can not be null\");\n        \n        // only persist IF preferences exist.\n        if (portletEntity.getPortletPreferences().getPortletPreferences()\n                .size() > 0) {\n            if (InterimPortletEntityImpl.isInterimPortletEntityId(portletEntity.getPortletEntityId())) {\n                IPortletEntity persistantEntity = this.portletEntityDao\n                        .createPortletEntity(portletEntity\n                                .getPortletDefinitionId(), portletEntity\n                                .getChannelSubscribeId(), portletEntity\n                                .getUserId());\n\n                persistantEntity.setPortletPreferences(portletEntity\n                        .getPortletPreferences());\n                this.portletEntityDao.updatePortletEntity(persistantEntity);\n            } else {\n                this.portletEntityDao.updatePortletEntity(portletEntity);\n            }\n        }\n        \n    }","commit_id":"854e90857d5ea48380a9897fd7cea794329dbfcb","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void deletePortletEntity(IPortletEntity portletEntity) {\n        Validate.notNull(portletEntity, \"portletEntity can not be null\");\n        \n        this.portletEntityDao.deletePortletEntity(portletEntity);\n    }","id":81647,"modified_method":"public void deletePortletEntity(IPortletEntity portletEntity) {\n        Validate.notNull(portletEntity, \"portletEntity can not be null\");\n        \n        if ((portletEntity != null) && (!InterimPortletEntityImpl\n                .isInterimPortletEntityId(portletEntity.getPortletEntityId()))) {\n            this.portletEntityDao.deletePortletEntity(portletEntity);\n        }\n    }","commit_id":"854e90857d5ea48380a9897fd7cea794329dbfcb","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IPortletEntity getPortletEntity(IPortletEntityId portletEntityId) {\n        Validate.notNull(portletEntityId, \"portletEntityId can not be null\");\n        \n        return this.portletEntityDao.getPortletEntity(portletEntityId);\n    }","id":81648,"modified_method":"public IPortletEntity getPortletEntity(IPortletEntityId portletEntityId) {\n        Validate.notNull(portletEntityId, \"portletEntityId can not be null\");\n        IPortletEntity portletEntity = null;\n\n        if (InterimPortletEntityImpl.isInterimPortletEntityId(portletEntityId)) {\n            portletEntity = new InterimPortletEntityImpl(portletEntityId);\n        } else {\n            portletEntity = this.portletEntityDao.getPortletEntity(portletEntityId);\n        }\n\n        return portletEntity;\n    }","commit_id":"854e90857d5ea48380a9897fd7cea794329dbfcb","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected Class< ? > resolveClass(ObjectStreamClass desc) throws IOException,\n                                                             ClassNotFoundException {\n        String name = desc.getName();\n        try {\n            return Class.forName( name, false, (this.ruleBase == null) ? null : this.ruleBase.getRootClassLoader() );\n        } catch ( ClassNotFoundException ex ) {\n            return super.resolveClass( desc );\n        }\n    }","id":81649,"modified_method":"@Override\n    protected Class< ? > resolveClass(ObjectStreamClass desc) throws IOException,\n                                                             ClassNotFoundException {\n        String name = desc.getName();\n        try {\n\t    if(this.classLoader == null){\n              if(this.ruleBase != null){\n                  this.classLoader = this.ruleBase.getRootClassLoader();\n              }\n            }\n            return Class.forName( name, false, this.classLoader );\n        } catch ( ClassNotFoundException ex ) {\n            return super.resolveClass( desc );\n        }\n    }","commit_id":"4e7c80ae24908d08a01650c5af05f0cd5080d479","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static void loadStrategiesIndex(MarshallerReaderContext context,\n                                            ProtobufMessages.Header _header) throws IOException, ClassNotFoundException {\n        for ( ProtobufMessages.Header.StrategyIndex _entry : _header.getStrategyList() ) {\n            ObjectMarshallingStrategy strategyObject = context.resolverStrategyFactory.getStrategyObject( _entry.getName() );\n            if ( strategyObject == null ) {\n                throw new IllegalStateException( \"No strategy of type \" + _entry.getName() + \" available.\" );\n            }\n            context.usedStrategies.put( _entry.getId(), strategyObject );\n            Context ctx = strategyObject.createContext();\n            context.strategyContexts.put( strategyObject, ctx );\n            if( _entry.hasData() && ctx != null ) {\n                ctx.read( new DroolsObjectInputStream( _entry.getData().newInput(), context.ruleBase.getRootClassLoader() ) );\n            }\n        }\n    }","id":81650,"modified_method":"private static void loadStrategiesIndex(MarshallerReaderContext context,\n                                            ProtobufMessages.Header _header) throws IOException, ClassNotFoundException {\n        for ( ProtobufMessages.Header.StrategyIndex _entry : _header.getStrategyList() ) {\n            ObjectMarshallingStrategy strategyObject = context.resolverStrategyFactory.getStrategyObject( _entry.getName() );\n            if ( strategyObject == null ) {\n                throw new IllegalStateException( \"No strategy of type \" + _entry.getName() + \" available.\" );\n            }\n            context.usedStrategies.put( _entry.getId(), strategyObject );\n            Context ctx = strategyObject.createContext();\n            context.strategyContexts.put( strategyObject, ctx );\n            if( _entry.hasData() && ctx != null ) {\n\t\tClassLoader classLoader = null;\n                if (context.classLoader != null ){\n                    classLoader = context.classLoader;\n                } \n                if(context.ruleBase != null){\n                    classLoader = context.ruleBase.getRootClassLoader();\n                }\n                ctx.read( new DroolsObjectInputStream( _entry.getData().newInput(), classLoader) );\n            }\n        }\n    }","commit_id":"4e7c80ae24908d08a01650c5af05f0cd5080d479","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\r\n    protected Class< ? > resolveClass(ObjectStreamClass desc) throws IOException,\r\n                                                             ClassNotFoundException {\r\n        String name = desc.getName();\r\n        try {\r\n            return Class.forName(name, false, this.ruleBase.getRootClassLoader());\r\n        } catch (ClassNotFoundException ex) {\r\n            return super.resolveClass( desc );\r\n        }        \r\n    }","id":81651,"modified_method":"@Override\r\n    protected Class< ? > resolveClass(ObjectStreamClass desc) throws IOException,\r\n                                                             ClassNotFoundException {\r\n        String name = desc.getName();\r\n        try {\r\n            return Class.forName(name, false, (this.ruleBase == null)?null:this.ruleBase.getRootClassLoader());\r\n        } catch (ClassNotFoundException ex) {\r\n            return super.resolveClass( desc );\r\n        }        \r\n    }","commit_id":"dd0db8cb027050b84ecd40eaa10fbf2417c88f5d","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n   * Finds all measure names of the facts that match given {@link TagValue}s and time range.\n   * @param allTagNames list of all tag names to be present in the fact record\n   * @param tagSlice tag values to filter by, {@code null} means any non-null value.\n   * @param startTs start timestamp, in sec\n   * @param endTs end timestamp, in sec\n   * @return {@link Set} of measure names\n   * @throws Exception\n   */\n  // todo: pass a limit on number of measures returned\n  public Set<String> findMeasureNames(List<String> allTagNames, Map<String, String> tagSlice,\n                                      long startTs, long endTs) throws Exception {\n\n    List<TagValue> allTags = Lists.newArrayList();\n    for (String tagName : allTagNames) {\n      allTags.add(new TagValue(tagName, tagSlice.get(tagName)));\n    }\n\n    byte[] startRow = codec.createStartRowKey(allTags, null, startTs, false);\n    byte[] endRow = codec.createEndRowKey(allTags, null, endTs, false);\n    endRow = Bytes.stopKeyForPrefix(endRow);\n    FuzzyRowFilter fuzzyRowFilter = createFuzzyRowFilter(new FactScan(startTs, endTs, null, allTags), startRow);\n\n    Set<String> measureNames = Sets.newHashSet();\n    int scannedRecords = 0;\n    // todo: make configurable\n    Scanner scanner = timeSeriesTable.scan(startRow, endRow, null, fuzzyRowFilter);\n    try {\n      Row rowResult;\n      while ((rowResult = scanner.next()) != null) {\n        scannedRecords++;\n        if (scannedRecords > MAX_RECORDS_TO_SCAN_DURING_SEARCH) {\n          break;\n        }\n        byte[] rowKey = rowResult.getRow();\n        // filter out columns by time range (scan configuration only filters whole rows)\n        if (codec.getTimestamp(rowKey, codec.createColumn(startTs)) < startTs) {\n          continue;\n        }\n        if (codec.getTimestamp(rowKey, codec.createColumn(endTs)) > endTs) {\n          // we're done with scanner\n          break;\n        }\n        measureNames.add(codec.getMeasureName(rowResult.getRow()));\n      }\n    } finally {\n      scanner.close();\n    }\n\n    LOG.trace(\"search for metrics completed, scanned records: {}\", scannedRecords);\n\n    return measureNames;\n  }","id":81652,"modified_method":"/**\n   * Finds all measure names of the facts that match given {@link TagValue}s and time range.\n   * @param allTagNames list of all tag names to be present in the fact record\n   * @param tagSlice tag values to filter by, {@code null} means any non-null value.\n   * @param startTs start timestamp, in sec\n   * @param endTs end timestamp, in sec\n   * @return {@link Set} of measure names\n   * @throws Exception\n   */\n  // todo: pass a limit on number of measures returned\n  public Set<String> findMeasureNames(List<String> allTagNames, Map<String, String> tagSlice,\n                                      long startTs, long endTs) throws Exception {\n\n    List<TagValue> allTags = Lists.newArrayList();\n    for (String tagName : allTagNames) {\n      allTags.add(new TagValue(tagName, tagSlice.get(tagName)));\n    }\n\n    byte[] startRow = codec.createStartRowKey(allTags, null, startTs, false);\n    byte[] endRow = codec.createEndRowKey(allTags, null, endTs, false);\n    endRow = Bytes.stopKeyForPrefix(endRow);\n    FuzzyRowFilter fuzzyRowFilter = createFuzzyRowFilter(new FactScan(startTs, endTs, null, allTags), startRow);\n\n    Set<String> measureNames = Sets.newHashSet();\n    int scannedRecords = 0;\n    // todo: make configurable\n    Scanner scanner = timeSeriesTable.scan(startRow, endRow, fuzzyRowFilter);\n    try {\n      Row rowResult;\n      while ((rowResult = scanner.next()) != null) {\n        scannedRecords++;\n        if (scannedRecords > MAX_RECORDS_TO_SCAN_DURING_SEARCH) {\n          break;\n        }\n        byte[] rowKey = rowResult.getRow();\n        // filter out columns by time range (scan configuration only filters whole rows)\n        if (codec.getTimestamp(rowKey, codec.createColumn(startTs)) < startTs) {\n          continue;\n        }\n        if (codec.getTimestamp(rowKey, codec.createColumn(endTs)) > endTs) {\n          // we're done with scanner\n          break;\n        }\n        measureNames.add(codec.getMeasureName(rowResult.getRow()));\n      }\n    } finally {\n      scanner.close();\n    }\n\n    LOG.trace(\"search for metrics completed, scanned records: {}\", scannedRecords);\n\n    return measureNames;\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"private Scanner getScanner(FactScan scan) throws Exception {\n    byte[] startRow = codec.createStartRowKey(scan.getTagValues(), scan.getMeasureName(), scan.getStartTs(), false);\n    byte[] endRow = codec.createEndRowKey(scan.getTagValues(), scan.getMeasureName(), scan.getEndTs(), false);\n    byte[][] columns;\n    if (Arrays.equals(startRow, endRow)) {\n      // If on the same timebase, we only need subset of columns\n      long timeBase = scan.getStartTs() / rollTime * rollTime;\n      int startCol = (int) (scan.getStartTs() - timeBase) / resolution;\n      int endCol = (int) (scan.getEndTs() - timeBase) / resolution;\n      columns = new byte[endCol - startCol + 1][];\n      for (int i = 0; i < columns.length; i++) {\n        columns[i] = Bytes.toBytes((short) (startCol + i));\n      }\n    }\n    endRow = Bytes.stopKeyForPrefix(endRow);\n    FuzzyRowFilter fuzzyRowFilter = createFuzzyRowFilter(scan, startRow);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Scanning fact table {} with scan: {}; constructed startRow: {}, endRow: {}, fuzzyRowFilter: {}\",\n                timeSeriesTable, scan, toPrettyLog(startRow), toPrettyLog(endRow), fuzzyRowFilter);\n    }\n\n    return timeSeriesTable.scan(startRow, endRow, null, fuzzyRowFilter);\n  }","id":81653,"modified_method":"private Scanner getScanner(FactScan scan) throws Exception {\n    byte[] startRow = codec.createStartRowKey(scan.getTagValues(), scan.getMeasureName(), scan.getStartTs(), false);\n    byte[] endRow = codec.createEndRowKey(scan.getTagValues(), scan.getMeasureName(), scan.getEndTs(), false);\n    byte[][] columns;\n    if (Arrays.equals(startRow, endRow)) {\n      // If on the same timebase, we only need subset of columns\n      long timeBase = scan.getStartTs() / rollTime * rollTime;\n      int startCol = (int) (scan.getStartTs() - timeBase) / resolution;\n      int endCol = (int) (scan.getEndTs() - timeBase) / resolution;\n      columns = new byte[endCol - startCol + 1][];\n      for (int i = 0; i < columns.length; i++) {\n        columns[i] = Bytes.toBytes((short) (startCol + i));\n      }\n    }\n    endRow = Bytes.stopKeyForPrefix(endRow);\n    FuzzyRowFilter fuzzyRowFilter = createFuzzyRowFilter(scan, startRow);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Scanning fact table {} with scan: {}; constructed startRow: {}, endRow: {}, fuzzyRowFilter: {}\",\n                timeSeriesTable, scan, toPrettyLog(startRow), toPrettyLog(endRow), fuzzyRowFilter);\n    }\n\n    return timeSeriesTable.scan(startRow, endRow, fuzzyRowFilter);\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Searches for first non-null valued tags in records that contain given list of tags and match given tag values in\n   * given time range. Returned tag values are those that are not defined in given tag values.\n   * @param allTagNames list of all tag names to be present in the record\n   * @param tagSlice tag values to filter by, {@code null} means any non-null value.\n   * @param startTs start of the time range, in seconds\n   * @param endTs end of the time range, in seconds\n   * @return {@link Set} of {@link TagValue}s\n   * @throws Exception\n   */\n  // todo: pass a limit on number of tagValues returned\n  // todo: kinda not cool API when we expect null values in a map...\n  public Set<TagValue> findSingleTagValue(List<String> allTagNames, Map<String, String> tagSlice,\n                                          long startTs, long endTs) throws Exception {\n    // Algorithm, briefly:\n    // We scan in the records which have given allTagNames. We use tagSlice as a criteria for scan.\n    // If record from the scan has non-null values in the tags which are not specified in tagSlice, we use first of\n    // such tag as a value to return.\n    // When we find value to return, since we only fill a single tag, we are not interested in drilling down further\n    // and instead attempt to fast-forward (jump) to a record that has different value in that tag.\n    // Thus we find all results.\n\n    List<TagValue> allTags = Lists.newArrayList();\n    List<TagValue> filledTags = Lists.newArrayList();\n    List<Integer> tagToFillIndexes = Lists.newArrayList();\n    for (int i = 0; i < allTagNames.size(); i++) {\n      String tagName = allTagNames.get(i);\n      if (!tagSlice.containsKey(tagName)) {\n        tagToFillIndexes.add(i);\n        allTags.add(new TagValue(tagName, null));\n      } else {\n        TagValue tagValue = new TagValue(tagName, tagSlice.get(tagName));\n        filledTags.add(tagValue);\n        allTags.add(tagValue);\n      }\n    }\n\n    // If provided tags contain all values filled in, there's nothing to look for\n    if (tagToFillIndexes.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    Set<TagValue> result = Sets.newHashSet();\n    int scans = 0;\n    int scannedRecords = 0;\n\n    // build a scan\n    byte[] startRow = codec.createStartRowKey(allTags, null, startTs, false);\n    byte[] endRow = codec.createEndRowKey(allTags, null, endTs, false);\n    endRow = Bytes.stopKeyForPrefix(endRow);\n    FuzzyRowFilter fuzzyRowFilter = createFuzzyRowFilter(new FactScan(startTs, endTs, null, allTags), startRow);\n    Scanner scanner = timeSeriesTable.scan(startRow, endRow, null, fuzzyRowFilter);\n    scans++;\n    try {\n      Row rowResult;\n      while ((rowResult = scanner.next()) != null) {\n        scannedRecords++;\n        // todo: make configurable\n        if (scannedRecords > MAX_RECORDS_TO_SCAN_DURING_SEARCH) {\n          break;\n        }\n        byte[] rowKey = rowResult.getRow();\n        // filter out columns by time range (scan configuration only filters whole rows)\n        if (codec.getTimestamp(rowKey, codec.createColumn(startTs)) < startTs) {\n          continue;\n        }\n        if (codec.getTimestamp(rowKey, codec.createColumn(endTs)) > endTs) {\n          // we're done with scanner\n          break;\n        }\n\n        List<TagValue> tagValues = codec.getTagValues(rowResult.getRow());\n        // At this point, we know that the record is in right time range and its tags matches given.\n        // We try find first non-null valued tag in the record that was not in given tags: we use it to form\n        // next drill down suggestion\n        int filledIndex = -1;\n        for (int index : tagToFillIndexes) {\n          // todo: it may be not efficient, if tagValues is not array-backed list: i.e. if access by index is not fast\n          TagValue tagValue = tagValues.get(index);\n          if (tagValue.getValue() != null) {\n            result.add(tagValue);\n            filledIndex = index;\n            break;\n          }\n        }\n\n        // Ss soon as we find tag to fill, we are not interested into drilling down further (by contract, we fill\n        // single tag value). Thus, we try to jump to the record that has greater value in that tag.\n        // todo: fast-forwarding (jumping) should be done on server-side (CDAP-1421)\n        if (filledIndex >= 0) {\n          scanner.close();\n          scanner = null;\n          scans++;\n          if (scans > MAX_SCANS_DURING_SEARCH) {\n            break;\n          }\n          startRow = codec.getNextRowKey(rowResult.getRow(), filledIndex);\n          scanner = timeSeriesTable.scan(startRow, endRow, null, fuzzyRowFilter);\n        }\n      }\n    } finally {\n      if (scanner != null) {\n        scanner.close();\n      }\n    }\n\n    LOG.trace(\"search for tags completed, scans performed: {}, scanned records: {}\", scans, scannedRecords);\n\n    return result;\n  }","id":81654,"modified_method":"/**\n   * Searches for first non-null valued tags in records that contain given list of tags and match given tag values in\n   * given time range. Returned tag values are those that are not defined in given tag values.\n   * @param allTagNames list of all tag names to be present in the record\n   * @param tagSlice tag values to filter by, {@code null} means any non-null value.\n   * @param startTs start of the time range, in seconds\n   * @param endTs end of the time range, in seconds\n   * @return {@link Set} of {@link TagValue}s\n   * @throws Exception\n   */\n  // todo: pass a limit on number of tagValues returned\n  // todo: kinda not cool API when we expect null values in a map...\n  public Set<TagValue> findSingleTagValue(List<String> allTagNames, Map<String, String> tagSlice,\n                                          long startTs, long endTs) throws Exception {\n    // Algorithm, briefly:\n    // We scan in the records which have given allTagNames. We use tagSlice as a criteria for scan.\n    // If record from the scan has non-null values in the tags which are not specified in tagSlice, we use first of\n    // such tag as a value to return.\n    // When we find value to return, since we only fill a single tag, we are not interested in drilling down further\n    // and instead attempt to fast-forward (jump) to a record that has different value in that tag.\n    // Thus we find all results.\n\n    List<TagValue> allTags = Lists.newArrayList();\n    List<TagValue> filledTags = Lists.newArrayList();\n    List<Integer> tagToFillIndexes = Lists.newArrayList();\n    for (int i = 0; i < allTagNames.size(); i++) {\n      String tagName = allTagNames.get(i);\n      if (!tagSlice.containsKey(tagName)) {\n        tagToFillIndexes.add(i);\n        allTags.add(new TagValue(tagName, null));\n      } else {\n        TagValue tagValue = new TagValue(tagName, tagSlice.get(tagName));\n        filledTags.add(tagValue);\n        allTags.add(tagValue);\n      }\n    }\n\n    // If provided tags contain all values filled in, there's nothing to look for\n    if (tagToFillIndexes.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    Set<TagValue> result = Sets.newHashSet();\n    int scans = 0;\n    int scannedRecords = 0;\n\n    // build a scan\n    byte[] startRow = codec.createStartRowKey(allTags, null, startTs, false);\n    byte[] endRow = codec.createEndRowKey(allTags, null, endTs, false);\n    endRow = Bytes.stopKeyForPrefix(endRow);\n    FuzzyRowFilter fuzzyRowFilter = createFuzzyRowFilter(new FactScan(startTs, endTs, null, allTags), startRow);\n    Scanner scanner = timeSeriesTable.scan(startRow, endRow, fuzzyRowFilter);\n    scans++;\n    try {\n      Row rowResult;\n      while ((rowResult = scanner.next()) != null) {\n        scannedRecords++;\n        // todo: make configurable\n        if (scannedRecords > MAX_RECORDS_TO_SCAN_DURING_SEARCH) {\n          break;\n        }\n        byte[] rowKey = rowResult.getRow();\n        // filter out columns by time range (scan configuration only filters whole rows)\n        if (codec.getTimestamp(rowKey, codec.createColumn(startTs)) < startTs) {\n          continue;\n        }\n        if (codec.getTimestamp(rowKey, codec.createColumn(endTs)) > endTs) {\n          // we're done with scanner\n          break;\n        }\n\n        List<TagValue> tagValues = codec.getTagValues(rowResult.getRow());\n        // At this point, we know that the record is in right time range and its tags matches given.\n        // We try find first non-null valued tag in the record that was not in given tags: we use it to form\n        // next drill down suggestion\n        int filledIndex = -1;\n        for (int index : tagToFillIndexes) {\n          // todo: it may be not efficient, if tagValues is not array-backed list: i.e. if access by index is not fast\n          TagValue tagValue = tagValues.get(index);\n          if (tagValue.getValue() != null) {\n            result.add(tagValue);\n            filledIndex = index;\n            break;\n          }\n        }\n\n        // Ss soon as we find tag to fill, we are not interested into drilling down further (by contract, we fill\n        // single tag value). Thus, we try to jump to the record that has greater value in that tag.\n        // todo: fast-forwarding (jumping) should be done on server-side (CDAP-1421)\n        if (filledIndex >= 0) {\n          scanner.close();\n          scanner = null;\n          scans++;\n          if (scans > MAX_SCANS_DURING_SEARCH) {\n            break;\n          }\n          startRow = codec.getNextRowKey(rowResult.getRow(), filledIndex);\n          scanner = timeSeriesTable.scan(startRow, endRow, fuzzyRowFilter);\n        }\n      }\n    } finally {\n      if (scanner != null) {\n        scanner.close();\n      }\n    }\n\n    LOG.trace(\"search for tags completed, scans performed: {}, scanned records: {}\", scans, scannedRecords);\n\n    return result;\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Scanner scan(@Nullable byte[] startRow, @Nullable byte[] stopRow,\n                      @Nullable byte[][] columns, @Nullable FuzzyRowFilter filter) throws IOException {\n    Scan scan = new Scan();\n    configureRangeScan(scan, startRow, stopRow, columns, filter);\n    ResultScanner resultScanner = hTable.getScanner(scan);\n    return new HBaseScanner(resultScanner, columnFamily);\n  }","id":81655,"modified_method":"@Override\n  public Scanner scan(@Nullable byte[] startRow, @Nullable byte[] stopRow,\n                      @Nullable FuzzyRowFilter filter) throws IOException {\n    Scan scan = new Scan();\n    configureRangeScan(scan, startRow, stopRow, filter);\n    ResultScanner resultScanner = hTable.getScanner(scan);\n    return new HBaseScanner(resultScanner, columnFamily);\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"private Scan configureRangeScan(Scan scan, @Nullable byte[] startRow, @Nullable byte[] stopRow,\n                                  @Nullable byte[][] columns, @Nullable FuzzyRowFilter filter) {\n    // todo: should be configurable\n    scan.setCaching(1000);\n\n    if (startRow != null) {\n      scan.setStartRow(startRow);\n    }\n    if (stopRow != null) {\n      scan.setStopRow(stopRow);\n    }\n    if (columns != null) {\n      for (byte[] column : columns) {\n        scan.addColumn(columnFamily, column);\n      }\n    } else {\n      scan.addFamily(columnFamily);\n    }\n    if (filter != null) {\n      List<Pair<byte[], byte[]>> fuzzyPairs = Lists.newArrayListWithExpectedSize(filter.getFuzzyKeysData().size());\n      for (ImmutablePair<byte[], byte[]> pair : filter.getFuzzyKeysData()) {\n        fuzzyPairs.add(Pair.newPair(pair.getFirst(), pair.getSecond()));\n      }\n      scan.setFilter(new org.apache.hadoop.hbase.filter.FuzzyRowFilter(fuzzyPairs));\n    }\n    return scan;\n  }","id":81656,"modified_method":"private Scan configureRangeScan(Scan scan, @Nullable byte[] startRow, @Nullable byte[] stopRow,\n                                  @Nullable FuzzyRowFilter filter) {\n    // todo: should be configurable\n    scan.setCaching(1000);\n\n    if (startRow != null) {\n      scan.setStartRow(startRow);\n    }\n    if (stopRow != null) {\n      scan.setStopRow(stopRow);\n    }\n    scan.addFamily(columnFamily);\n    if (filter != null) {\n      List<Pair<byte[], byte[]>> fuzzyPairs = Lists.newArrayListWithExpectedSize(filter.getFuzzyKeysData().size());\n      for (ImmutablePair<byte[], byte[]> pair : filter.getFuzzyKeysData()) {\n        fuzzyPairs.add(Pair.newPair(pair.getFirst(), pair.getSecond()));\n      }\n      scan.setFilter(new org.apache.hadoop.hbase.filter.FuzzyRowFilter(fuzzyPairs));\n    }\n    return scan;\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Scanner scan(@Nullable byte[] start, @Nullable byte[] stop, @Nullable byte[][] columns,\n                      @Nullable FuzzyRowFilter filter) {\n\n    // todo: a lot of inefficient copying from one map to another\n    NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> rowRange =\n      InMemoryTableService.getRowRange(tableName, start, stop, null);\n    NavigableMap<byte[], NavigableMap<byte[], byte[]>> rows = getLatest(rowRange);\n\n    return new InMemoryScanner(rows.entrySet().iterator(), filter, columns);\n  }","id":81657,"modified_method":"@Override\n  public Scanner scan(@Nullable byte[] start, @Nullable byte[] stop,\n                      @Nullable FuzzyRowFilter filter) {\n\n    // todo: a lot of inefficient copying from one map to another\n    NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> rowRange =\n      InMemoryTableService.getRowRange(tableName, start, stop, null);\n    NavigableMap<byte[], NavigableMap<byte[], byte[]>> rows = getLatest(rowRange);\n\n    return new InMemoryScanner(rows.entrySet().iterator(), filter, null);\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Scanner scan(@Nullable byte[] start, @Nullable byte[] stop, @Nullable byte[][] columns,\n                      @Nullable FuzzyRowFilter filter) throws IOException {\n    return core.scan(start, stop, filter, columns, null);\n  }","id":81658,"modified_method":"@Override\n  public Scanner scan(@Nullable byte[] start, @Nullable byte[] stop,\n                      @Nullable FuzzyRowFilter filter) throws IOException {\n    return core.scan(start, stop, filter, null, null);\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"private void migrateMetricsData(EntityTable entityTable, MetricsTable metricsTable, String scope,\n                                  Version version) {\n    MetricsEntityCodec codec = getEntityCodec(entityTable);\n    int idSize = getIdSize(version);\n    Row row;\n    long rowCount = 0;\n    try {\n      Scanner scanner = metricsTable.scan(null, null, null, null);\n      while ((row = scanner.next()) != null) {\n        byte[] rowKey = row.getRow();\n        int offset = 0;\n        String context = codec.decode(MetricsEntityType.CONTEXT, rowKey, offset, idSize);\n        context = getContextBasedOnVersion(context, version);\n        offset += codec.getEncodedSize(MetricsEntityType.CONTEXT, idSize);\n        String metricName = codec.decode(MetricsEntityType.METRIC, rowKey, offset, idSize);\n        offset += codec.getEncodedSize(MetricsEntityType.METRIC, idSize);\n        scope = getScopeBasedOnVersion(scope, metricName, version);\n        metricName = getMetricNameBasedOnVersion(metricName, version);\n        String runId = codec.decode(MetricsEntityType.RUN, rowKey, offset, idSize);\n        parseAndAddNewMetricValue(scope, context, metricName, runId, row.getColumns());\n        rowCount++;\n        printStatus(rowCount);\n      }\n      System.out.println(\"Migrated \" + rowCount + \" records\");\n   } catch (Exception e) {\n      LOG.warn(\"Exception during data-transfer in aggregates table\", e);\n      //no-op\n   }\n  }","id":81659,"modified_method":"private void migrateMetricsData(EntityTable entityTable, MetricsTable metricsTable, String scope,\n                                  Version version) {\n    MetricsEntityCodec codec = getEntityCodec(entityTable);\n    int idSize = getIdSize(version);\n    Row row;\n    long rowCount = 0;\n    try {\n      Scanner scanner = metricsTable.scan(null, null, null);\n      while ((row = scanner.next()) != null) {\n        byte[] rowKey = row.getRow();\n        int offset = 0;\n        String context = codec.decode(MetricsEntityType.CONTEXT, rowKey, offset, idSize);\n        context = getContextBasedOnVersion(context, version);\n        offset += codec.getEncodedSize(MetricsEntityType.CONTEXT, idSize);\n        String metricName = codec.decode(MetricsEntityType.METRIC, rowKey, offset, idSize);\n        offset += codec.getEncodedSize(MetricsEntityType.METRIC, idSize);\n        scope = getScopeBasedOnVersion(scope, metricName, version);\n        metricName = getMetricNameBasedOnVersion(metricName, version);\n        String runId = codec.decode(MetricsEntityType.RUN, rowKey, offset, idSize);\n        parseAndAddNewMetricValue(scope, context, metricName, runId, row.getColumns());\n        rowCount++;\n        printStatus(rowCount);\n      }\n      System.out.println(\"Migrated \" + rowCount + \" records\");\n   } catch (Exception e) {\n      LOG.warn(\"Exception during data-transfer in aggregates table\", e);\n      //no-op\n   }\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDeleteIncrements() throws Exception {\n    // note: this is pretty important test case for tables with counters, e.g. metrics\n    MetricsTable table = getTable(\"testDeleteIncrements\");\n    // delete increment and increment again\n    table.increment(A, ImmutableMap.of(B, 5L));\n    table.increment(A, ImmutableMap.of(B, 2L));\n    table.increment(P, ImmutableMap.of(Q, 15L));\n    table.increment(P, ImmutableMap.of(Q, 12L));\n    Assert.assertEquals(7L, Bytes.toLong(table.get(A, B)));\n    Assert.assertEquals(27L, Bytes.toLong(table.get(P, Q)));\n    table.delete(A, new byte[][]{B});\n    table.deleteAll(P);\n    Assert.assertNull(table.get(A, B));\n    Assert.assertNull(table.get(P, Q));\n    table.increment(A, ImmutableMap.of(B, 3L));\n    table.increment(P, ImmutableMap.of(Q, 13L));\n    Assert.assertEquals(3L, Bytes.toLong(table.get(A, B)));\n    Assert.assertEquals(13L, Bytes.toLong(table.get(P, Q)));\n  }","id":81660,"modified_method":"@Test\n  public void testDeleteIncrements() throws Exception {\n    // note: this is pretty important test case for tables with counters, e.g. metrics\n    MetricsTable table = getTable(\"testDeleteIncrements\");\n    // delete increment and increment again\n    table.increment(A, ImmutableMap.of(B, 5L));\n    table.increment(A, ImmutableMap.of(B, 2L));\n    Assert.assertEquals(7L, Bytes.toLong(table.get(A, B)));\n    table.delete(A, new byte[][]{B});\n    Assert.assertNull(table.get(A, B));\n    table.increment(A, ImmutableMap.of(B, 3L));\n    Assert.assertEquals(3L, Bytes.toLong(table.get(A, B)));\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFuzzyScan() throws Exception {\n    MetricsTable table = getTable(\"testFuzzyScan\");\n    NavigableMap<byte[], NavigableMap<byte[], Long>> writes = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n    byte[] abc = { 'a', 'b', 'c' };\n    for (byte b1 : abc) {\n      for (byte b2 : abc) {\n        for (byte b3 : abc) {\n          for (byte b4 : abc) {\n            // we put two columns, but will scan only one column\n            writes.put(new byte[] { b1, b2, b3, b4 }, Bytes.immutableSortedMapOf(A, Bytes.toLong(X), B,\n                                                                                 Bytes.toLong(Y)));\n          }\n        }\n      }\n    }\n    table.put(writes);\n    // we should have 81 (3^4) rows now\n    Assert.assertEquals(81, countRange(table, null, null));\n\n    // now do a fuzzy scan of the table\n    FuzzyRowFilter filter = new FuzzyRowFilter(\n      ImmutableList.of(ImmutablePair.of(new byte[] { '*', 'b', '*', 'b' }, new byte[] { 0x01, 0x00, 0x01, 0x00 })));\n    Scanner scanner = table.scan(null, null, new byte[][] { A }, filter);\n    int count = 0;\n    while (true) {\n      Row entry = scanner.next();\n      if (entry == null) {\n        break;\n      }\n      Assert.assertTrue(entry.getRow()[1] == 'b' && entry.getRow()[3] == 'b');\n      Assert.assertEquals(1, entry.getColumns().size());\n      Assert.assertTrue(entry.getColumns().containsKey(A));\n      Assert.assertFalse(entry.getColumns().containsKey(B));\n      count++;\n    }\n    Assert.assertEquals(9, count);\n  }","id":81661,"modified_method":"@Test\n  public void testFuzzyScan() throws Exception {\n    MetricsTable table = getTable(\"testFuzzyScan\");\n    NavigableMap<byte[], NavigableMap<byte[], Long>> writes = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n    byte[] abc = { 'a', 'b', 'c' };\n    for (byte b1 : abc) {\n      for (byte b2 : abc) {\n        for (byte b3 : abc) {\n          for (byte b4 : abc) {\n            // we put two columns, but will scan only one column\n            writes.put(new byte[] { b1, b2, b3, b4 }, Bytes.immutableSortedMapOf(A, Bytes.toLong(X)));\n          }\n        }\n      }\n    }\n    table.put(writes);\n    // we should have 81 (3^4) rows now\n    Assert.assertEquals(81, countRange(table, null, null));\n\n    // now do a fuzzy scan of the table\n    FuzzyRowFilter filter = new FuzzyRowFilter(\n      ImmutableList.of(ImmutablePair.of(new byte[] { '*', 'b', '*', 'b' }, new byte[] { 0x01, 0x00, 0x01, 0x00 })));\n    Scanner scanner = table.scan(null, null, filter);\n    int count = 0;\n    while (true) {\n      Row entry = scanner.next();\n      if (entry == null) {\n        break;\n      }\n      Assert.assertTrue(entry.getRow()[1] == 'b' && entry.getRow()[3] == 'b');\n      Assert.assertEquals(1, entry.getColumns().size());\n      Assert.assertTrue(entry.getColumns().containsKey(A));\n      count++;\n    }\n    Assert.assertEquals(9, count);\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDelete() throws Exception {\n    MetricsTable table = getTable(\"testDelete\");\n    NavigableMap<byte[], NavigableMap<byte[], Long>> writes = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n    for (int i = 0; i < 1024; i++) {\n      writes.put(Bytes.toBytes(i << 22), Bytes.immutableSortedMapOf(A, Bytes.toLong(X)));\n    }\n    table.put(writes);\n    // verify the first and last are there (sanity test for correctness of test logic)\n    Assert.assertArrayEquals(X, table.get(Bytes.toBytes(0x00000000), A));\n    Assert.assertArrayEquals(X, table.get(Bytes.toBytes(0xffc00000), A));\n\n    List<byte[]> toDelete = ImmutableList.of(\n      Bytes.toBytes(0xa1000000), Bytes.toBytes(0xb2000000), Bytes.toBytes(0xc3000000));\n    // verify these three are there, we will soon delete them\n    for (byte[] row : toDelete) {\n      Assert.assertArrayEquals(X, table.get(row, A));\n    }\n    // delete these three\n    table.delete(toDelete);\n    // verify these three are now gone.\n    for (byte[] row : toDelete) {\n      Assert.assertNull(table.get(row, A));\n    }\n    // verify nothing else is gone by counting all entries in a scan\n    Assert.assertEquals(1021, countRange(table, null, null));\n\n    // delete a range by prefix\n    table.deleteAll(new byte[] { 0x11 });\n    // verify that they are gone\n    Assert.assertEquals(0, countRange(table, 0x11000000, 0x12000000));\n    // verify nothing else is gone by counting all entries in a scan (deleted 4)\n    Assert.assertEquals(1017, countRange(table, null, null));\n\n    // delete all with prefix 0xff (it a border case because it has no upper bound)\n    table.deleteAll(new byte[] { (byte) 0xff });\n    // verify that they are gone\n    Assert.assertEquals(0, countRange(table, 0xff000000, null));\n    // verify nothing else is gone by counting all entries in a scan (deleted another 4)\n    Assert.assertEquals(1013, countRange(table, null, null));\n\n    // delete with empty prefix, should clear table\n    // delete all with prefix 0xff (it a border case because it has no upper bound)\n    table.deleteAll(new byte[0]);\n    // verify everything is gone by counting all entries in a scan\n    Assert.assertEquals(0, countRange(table, null, null));\n  }","id":81662,"modified_method":"@Test\n  public void testDelete() throws Exception {\n    MetricsTable table = getTable(\"testDelete\");\n    NavigableMap<byte[], NavigableMap<byte[], Long>> writes = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n    for (int i = 0; i < 1024; i++) {\n      writes.put(Bytes.toBytes(i << 22), Bytes.immutableSortedMapOf(A, Bytes.toLong(X)));\n    }\n    table.put(writes);\n    // verify the first and last are there (sanity test for correctness of test logic)\n    Assert.assertArrayEquals(X, table.get(Bytes.toBytes(0x00000000), A));\n    Assert.assertArrayEquals(X, table.get(Bytes.toBytes(0xffc00000), A));\n\n    List<byte[]> toDelete = ImmutableList.of(\n      Bytes.toBytes(0xa1000000), Bytes.toBytes(0xb2000000), Bytes.toBytes(0xc3000000));\n    // verify these three are there, and delete them\n    for (byte[] row : toDelete) {\n      Assert.assertArrayEquals(X, table.get(row, A));\n      table.delete(row, new byte[][] {A});\n    }\n    // verify these three are now gone.\n    for (byte[] row : toDelete) {\n      Assert.assertNull(table.get(row, A));\n    }\n    // verify nothing else is gone by counting all entries in a scan\n    Assert.assertEquals(1021, countRange(table, null, null));\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"private static int countRange(MetricsTable table, Integer start, Integer stop) throws Exception {\n    Scanner scanner = table.scan(start == null ? null : Bytes.toBytes(start),\n                                 stop == null ? null : Bytes.toBytes(stop), null, null);\n    int count = 0;\n    while (scanner.next() != null) {\n      count++;\n    }\n    return count;\n  }","id":81663,"modified_method":"private static int countRange(MetricsTable table, Integer start, Integer stop) throws Exception {\n    Scanner scanner = table.scan(start == null ? null : Bytes.toBytes(start),\n                                 stop == null ? null : Bytes.toBytes(stop), null);\n    int count = 0;\n    while (scanner.next() != null) {\n      count++;\n    }\n    return count;\n  }","commit_id":"65083f718e9ca4c8da34634075161bcea212ad4c","url":"https://github.com/caskdata/cdap"},{"original_method":"public Canary() {\n    this(new StdOutSink());\n  }","id":81664,"modified_method":"public Canary() {\n    this(new RegionServerStdOutSink());\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Canary entry point for specified table.\n   * @param admin\n   * @param tableName\n   * @throws Exception\n   */\n  public static void sniff(final HBaseAdmin admin, TableName tableName)\n  throws Exception {\n    sniff(admin, new StdOutSink(), tableName);\n  }","id":81665,"modified_method":"/**\n   * Canary entry point for specified table.\n   * @param admin\n   * @param tableName\n   * @throws Exception\n   */\n  public static void sniff(final HBaseAdmin admin, TableName tableName) throws Exception {\n    sniff(admin, new StdOutSink(), tableName.getNameAsString());\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"private static void sniffRegion(final HBaseAdmin admin, final Sink sink, HRegionInfo region,\n      HTable table)\n  throws Exception {\n    HTableDescriptor tableDesc = table.getTableDescriptor();\n    StopWatch stopWatch = new StopWatch();\n    for (HColumnDescriptor column : tableDesc.getColumnFamilies()) {\n      stopWatch.reset();\n      byte [] startKey = region.getStartKey();\n      if (startKey ==  null || startKey.length <= 0) {\n        // Can't do a get on empty start row so do a Scan of first element if any instead.\n        Scan scan = new Scan();\n        scan.addFamily(column.getName());\n        scan.setBatch(1);\n        ResultScanner scanner = null;\n        try {\n          stopWatch.start();\n          scanner = table.getScanner(scan);\n          scanner.next();\n          stopWatch.stop();\n          sink.publishReadTiming(region, column, stopWatch.getTime());\n        } catch (Exception e) {\n          sink.publishReadFailure(region, column, e);\n        } finally {\n          if (scanner != null) scanner.close();\n        }\n      } else {\n        Get get = new Get(region.getStartKey());\n        get.addFamily(column.getName());\n        try {\n          stopWatch.start();\n          table.get(get);\n          stopWatch.stop();\n          sink.publishReadTiming(region, column, stopWatch.getTime());\n        } catch (Exception e) {\n          sink.publishReadFailure(region, column, e);\n        }\n      }\n    }\n  }","id":81666,"modified_method":"private static void\n      sniffRegion(final HBaseAdmin admin, final Sink sink, HRegionInfo region, HTable table)\n          throws Exception {\n    HTableDescriptor tableDesc = table.getTableDescriptor();\n    byte[] startKey = null;\n    Get get = null;\n    Scan scan = null;\n    ResultScanner rs = null;\n    StopWatch stopWatch = new StopWatch();\n    for (HColumnDescriptor column : tableDesc.getColumnFamilies()) {\n      stopWatch.reset();\n      startKey = region.getStartKey();\n      // Can't do a get on empty start row so do a Scan of first element if any instead.\n      if (startKey.length > 0) {\n        get = new Get(startKey);\n        get.addFamily(column.getName());\n      } else {\n        scan = new Scan();\n        scan.setCaching(1);\n        scan.addFamily(column.getName());\n        scan.setMaxResultSize(1L);\n      }\n\n      try {\n        if (startKey.length > 0) {\n          stopWatch.start();\n          table.get(get);\n          stopWatch.stop();\n          sink.publishReadTiming(region, column, stopWatch.getTime());\n        } else {\n          stopWatch.start();\n          rs = table.getScanner(scan);\n          stopWatch.stop();\n          sink.publishReadTiming(region, column, stopWatch.getTime());\n        }\n      } catch (Exception e) {\n        sink.publishReadFailure(region, column, e);\n      } finally {\n        if (rs != null) {\n          rs.close();\n        }\n        scan = null;\n        get = null;\n        startKey = null;\n      }\n    }\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Canary entry point for specified table.\n   * @param admin\n   * @param sink\n   * @param tableName\n   * @throws Exception\n   */\n  private static void sniff(final HBaseAdmin admin, final Sink sink, TableName tableName)\n  throws Exception {\n    if (admin.isTableAvailable(tableName)) {\n      sniff(admin, sink, admin.getTableDescriptor(tableName));\n    } else {\n      LOG.warn(String.format(\"Table %s is not available\", tableName));\n    }\n  }","id":81667,"modified_method":"/**\n   * Canary entry point for specified table.\n   * @param admin\n   * @param sink\n   * @param tableName\n   * @throws Exception\n   */\n  private static void sniff(final HBaseAdmin admin, final Sink sink, String tableName)\n      throws Exception {\n    if (admin.isTableAvailable(tableName)) {\n      sniff(admin, sink, admin.getTableDescriptor(tableName.getBytes()));\n    } else {\n      LOG.warn(String.format(\"Table %s is not available\", tableName));\n    }\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int run(String[] args) throws Exception {\n    int tables_index = -1;\n\n    // Process command line args\n    for (int i = 0; i < args.length; i++) {\n      String cmd = args[i];\n\n      if (cmd.startsWith(\"-\")) {\n        if (tables_index >= 0) {\n          // command line args must be in the form: [opts] [table 1 [table 2 ...]]\n          System.err.println(\"Invalid command line options\");\n          printUsageAndExit();\n        }\n\n        if (cmd.equals(\"-help\")) {\n          // user asked for help, print the help and quit.\n          printUsageAndExit();\n        } else if (cmd.equals(\"-daemon\") && interval == 0) {\n          // user asked for daemon mode, set a default interval between checks\n          interval = DEFAULT_INTERVAL;\n        } else if (cmd.equals(\"-interval\")) {\n          // user has specified an interval for canary breaths (-interval N)\n          i++;\n\n          if (i == args.length) {\n            System.err.println(\"-interval needs a numeric value argument.\");\n            printUsageAndExit();\n          }\n\n          try {\n            interval = Long.parseLong(args[i]) * 1000;\n          } catch (NumberFormatException e) {\n            System.err.println(\"-interval needs a numeric value argument.\");\n            printUsageAndExit();\n          }\n        } else {\n          // no options match\n          System.err.println(cmd + \" options is invalid.\");\n          printUsageAndExit();\n        }\n      } else if (tables_index < 0) {\n        // keep track of first table name specified by the user\n        tables_index = i;\n      }\n    }\n\n    // initialize HBase conf and admin\n    if (conf == null) conf = HBaseConfiguration.create();\n    admin = new HBaseAdmin(conf);\n    try {\n      // lets the canary monitor the cluster\n      do {\n        if (admin.isAborted()) {\n          LOG.error(\"HBaseAdmin aborted\");\n          return(1);\n        }\n\n        if (tables_index >= 0) {\n          for (int i = tables_index; i < args.length; i++) {\n            sniff(admin, sink, TableName.valueOf(args[i]));\n          }\n        } else {\n          sniff();\n        }\n\n        Thread.sleep(interval);\n      } while (interval > 0);\n    } finally {\n      this.admin.close();\n    }\n\n    return(0);\n  }","id":81668,"modified_method":"@Override\n  public int run(String[] args) throws Exception {\n    int index = -1;\n\n    // Process command line args\n    for (int i = 0; i < args.length; i++) {\n      String cmd = args[i];\n\n      if (cmd.startsWith(\"-\")) {\n        if (index >= 0) {\n          // command line args must be in the form: [opts] [table 1 [table 2 ...]]\n          System.err.println(\"Invalid command line options\");\n          printUsageAndExit();\n        }\n\n        if (cmd.equals(\"-help\")) {\n          // user asked for help, print the help and quit.\n          printUsageAndExit();\n        } else if (cmd.equals(\"-daemon\") && interval == 0) {\n          // user asked for daemon mode, set a default interval between checks\n          interval = DEFAULT_INTERVAL;\n        } else if (cmd.equals(\"-interval\")) {\n          // user has specified an interval for canary breaths (-interval N)\n          i++;\n\n          if (i == args.length) {\n            System.err.println(\"-interval needs a numeric value argument.\");\n            printUsageAndExit();\n          }\n\n          try {\n            interval = Long.parseLong(args[i]) * 1000;\n          } catch (NumberFormatException e) {\n            System.err.println(\"-interval needs a numeric value argument.\");\n            printUsageAndExit();\n          }\n        } else if(cmd.equals(\"-regionserver\")) {\n          this.regionServerMode = true;\n        } else if (cmd.equals(\"-e\")) {\n          this.useRegExp = true;\n        } else if (cmd.equals(\"-t\")) {\n          i++;\n\n          if (i == args.length) {\n            System.err.println(\"-t needs a numeric value argument.\");\n            printUsageAndExit();\n          }\n\n          try {\n            this.timeout = Long.parseLong(args[i]);\n          } catch (NumberFormatException e) {\n            System.err.println(\"-t needs a numeric value argument.\");\n            printUsageAndExit();\n          }\n\n        } else if (cmd.equals(\"-f\")) {\n          i++;\n\n          if (i == args.length) {\n            System.err\n                .println(\"-f needs a boolean value argument (true|false).\");\n            printUsageAndExit();\n          }\n\n          this.failOnError = Boolean.parseBoolean(args[i]);\n        } else {\n          // no options match\n          System.err.println(cmd + \" options is invalid.\");\n          printUsageAndExit();\n        }\n      } else if (index < 0) {\n        // keep track of first table name specified by the user\n        index = i;\n      }\n    }\n\n    // start to prepare the stuffs\n    Monitor monitor = null;\n    Thread monitorThread = null;\n    long startTime = 0;\n    long currentTimeLength = 0;\n\n    do {\n      // do monitor !!\n      monitor = this.newMonitor(index, args);\n      monitorThread = new Thread(monitor);\n      startTime = System.currentTimeMillis();\n      monitorThread.start();\n      while (!monitor.isDone()) {\n        // wait for 1 sec\n        Thread.sleep(1000);\n        // exit if any error occurs\n        if (this.failOnError && monitor.hasError()) {\n          monitorThread.interrupt();\n          System.exit(1);\n        }\n        currentTimeLength = System.currentTimeMillis() - startTime;\n        if (currentTimeLength > this.timeout) {\n          LOG.error(\"The monitor is running too long (\" + currentTimeLength\n              + \") after timeout limit:\" + this.timeout\n              + \" will be killed itself !!\");\n          monitorThread.interrupt();\n          monitor.setError(true);\n          break;\n        }\n      }\n\n      if (this.failOnError && monitor.hasError()) {\n        monitorThread.interrupt();\n        System.exit(1);\n      }\n\n        Thread.sleep(interval);\n    } while (interval > 0);\n\n    return(monitor.hasError()? 1: 0);\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"private static void sniff(final HBaseAdmin admin, final Sink sink, HTableDescriptor tableDesc)\n  throws Exception {\n    HTable table = null;\n\n    try {\n      table = new HTable(admin.getConfiguration(), tableDesc.getTableName());\n    } catch (TableNotFoundException e) {\n      return;\n    }\n\n    for (HRegionInfo region : admin.getTableRegions(tableDesc.getTableName())) {\n      try {\n        sniffRegion(admin, sink, region, table);\n      } catch (Exception e) {\n        sink.publishReadFailure(region, e);\n      }\n    }\n  }","id":81669,"modified_method":"private static void sniff(final HBaseAdmin admin, final Sink sink, HTableDescriptor tableDesc)\n      throws Exception {\n    HTable table = null;\n\n    try {\n      table = new HTable(admin.getConfiguration(), tableDesc.getName());\n    } catch (TableNotFoundException e) {\n      return;\n    }\n\n    for (HRegionInfo region : admin.getTableRegions(tableDesc.getName())) {\n      try {\n        sniffRegion(admin, sink, region, table);\n      } catch (Exception e) {\n        sink.publishReadFailure(region, e);\n        LOG.debug(\"sniffRegion failed\", e);\n      }\n    }\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"private void printUsageAndExit() {\n    System.err.printf(\"Usage: bin/hbase %s [opts] [table 1 [table 2...]]%n\", getClass().getName());\n    System.err.println(\" where [opts] are:\");\n    System.err.println(\"   -help          Show this help and exit.\");\n    System.err.println(\"   -daemon        Continuous check at defined intervals.\");\n    System.err.println(\"   -interval <N>  Interval between checks (sec)\");\n    System.exit(1);\n  }","id":81670,"modified_method":"private void printUsageAndExit() {\n    System.err.printf(\n      \"Usage: bin/hbase %s [opts] [table1 [table2]...] | [regionserver1 [regionserver2]..]%n\",\n        getClass().getName());\n    System.err.println(\" where [opts] are:\");\n    System.err.println(\"   -help          Show this help and exit.\");\n    System.err.println(\"   -regionserver  replace the table argument to regionserver,\");\n    System.err.println(\"      which means to enable regionserver mode\");\n    System.err.println(\"   -daemon        Continuous check at defined intervals.\");\n    System.err.println(\"   -interval <N>  Interval between checks (sec)\");\n    System.err.println(\"   -e             Use region/regionserver as regular expression\");\n    System.err.println(\"      which means the region/regionserver is regular expression pattern\");\n    System.err.println(\"   -f <B>         stop whole program if first error occurs,\" +\n        \" default is true\");\n    System.err.println(\"   -t <N>         timeout for a check, default is 600000 (milisecs)\");\n    System.exit(1);\n  }","commit_id":"fcfefd81b451035db86a11e7de0438834a4dd471","url":"https://github.com/apache/hbase"},{"original_method":"@Nullable\n  public static <T extends PsiLanguageInjectionHost> List<Pair<PsiElement, TextRange>> getInjectedPsiFiles(@NotNull T host,\n                                                                                                           @Nullable LiteralTextEscaper<T> textEscaper) {\n    if (!host.isPhysical()) {\n      return new InjectedPsiProvider<T>(host, textEscaper).compute().getValue();\n    }\n    \n    CachedValue<List<Pair<PsiElement, TextRange>>> cachedPsi = host.getUserData(INJECTED_PSI);\n    if (cachedPsi == null) {\n      CachedValueProvider<List<Pair<PsiElement, TextRange>>> provider = new InjectedPsiProvider<T>(host, textEscaper);\n      cachedPsi = host.getManager().getCachedValuesManager().createCachedValue(provider, false);\n      host.putUserData(INJECTED_PSI, cachedPsi);\n    }\n    return cachedPsi.getValue();\n  }","id":81671,"modified_method":"@Nullable\n  public static <T extends PsiLanguageInjectionHost> List<Pair<PsiElement, TextRange>> getInjectedPsiFiles(@NotNull T host,\n                                                                                                           @Nullable LiteralTextEscaper<T> textEscaper) {\n    if (!host.isPhysical()) {\n      CachedValueProvider.Result<List<Pair<PsiElement, TextRange>>> result = new InjectedPsiProvider<T>(host, textEscaper).compute();\n      return result == null ? null : result.getValue();\n    }\n    \n    CachedValue<List<Pair<PsiElement, TextRange>>> cachedPsi = host.getUserData(INJECTED_PSI);\n    if (cachedPsi == null) {\n      CachedValueProvider<List<Pair<PsiElement, TextRange>>> provider = new InjectedPsiProvider<T>(host, textEscaper);\n      cachedPsi = host.getManager().getCachedValuesManager().createCachedValue(provider, false);\n      host.putUserData(INJECTED_PSI, cachedPsi);\n    }\n    return cachedPsi.getValue();\n  }","commit_id":"6e41ed4d4769555d03eeb5ae0c26fc2aed26bca9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException\n        {\n            ByteBuffer[] buffers = type.split(selected.compute(rs));\n            return field < buffers.length ? buffers[field] : null;\n        }","id":81672,"modified_method":"public ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException\n        {\n            ByteBuffer value = selected.compute(rs);\n            if (value == null)\n                return null;\n            ByteBuffer[] buffers = type.split(value);\n            return field < buffers.length ? buffers[field] : null;\n        }","commit_id":"1adc39f1713a826e833b393798b4eea4a64f9e3a","url":"https://github.com/apache/cassandra"},{"original_method":"public ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException\n        {\n            ByteBuffer[] buffers = type.split(selected.compute(rs));\n            return field < buffers.length ? buffers[field] : null;\n        }","id":81673,"modified_method":"public ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException\n        {\n            ByteBuffer value = selected.compute(rs);\n            if (value == null)\n                return null;\n            ByteBuffer[] buffers = type.split(value);\n            return field < buffers.length ? buffers[field] : null;\n        }","commit_id":"fa8e5158a56b37caf7f2507256992e776ef1afa8","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Shows this modal dialog.\n     * @return the result code, which shows what was the choice of the user\n     */\n    public int showDialog() {\n        this.setVisible(true);\n        \n        return result;\n    }","id":81674,"modified_method":"/**\n     * Shows this modal dialog.\n     * @return the result code, which shows what was the choice of the user\n     */\n    public int showDialog() {\n        this.setVisible(true);\n        \n        synchronized (lock) {\n            try {                    \n                lock.wait();\n            }\n            catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        \n        return result;\n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> triggered when one user clicks\n     * on one of the buttons.\n     */\n    public void actionPerformed(ActionEvent e) {\n        JButton button = (JButton)e.getSource();\n        String name = button.getName();\n        \n        if (name.equals(\"accept\")) {\n            this.result = ACCEPT_CODE;\n        }\n        else if (name.equals(\"reject\")) {\n            this.result = REJECT_CODE;\n        }\n        else if (name.equals(\"ignore\")) {\n            this.result = IGNORE_CODE;\n        }\n        else {\n            this.result = ERROR_CODE;\n        }        \n        this.dispose();\n    }","id":81675,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> triggered when one user clicks\n     * on one of the buttons.\n     */\n    public void actionPerformed(ActionEvent e) {\n        JButton button = (JButton)e.getSource();\n        String name = button.getName();\n        \n        if (name.equals(\"accept\")) {\n            this.result = ACCEPT_CODE;\n        }\n        else if (name.equals(\"reject\")) {\n            this.result = REJECT_CODE;\n        }\n        else if (name.equals(\"ignore\")) {\n            this.result = IGNORE_CODE;\n        }\n        else {\n            this.result = ERROR_CODE;\n        }        \n        \n        synchronized (lock) {\n            lock.notify();\n        }\n        \n        this.dispose();\n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the <tt>RequestAuthorisationDialog<\/tt>.\n     * \n     * @param contact The <tt>Contact<\/tt>, which requires authorisation.\n     * @param request The <tt>AuthorizationRequest<\/tt> that will be sent.\n     */\n    public AuthorizationRequestedDialog(MainFrame mainFrame, Contact contact,\n            AuthorizationRequest request) {\n        \n        super(mainFrame);\n        \n        this.setModal(false);\n        \n        this.setTitle(title);\n\n        titleLabel.setHorizontalAlignment(JLabel.CENTER);\n        titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD, 18f));\n        titleLabel.setText(title);\n        \n        infoTextArea.setText(Messages.getString(\"authorizationRequestedInfo\", \n                contact.getDisplayName()));\n        this.infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD, 12f));\n        this.infoTextArea.setLineWrap(true);\n        this.infoTextArea.setWrapStyleWord(true);\n        this.infoTextArea.setOpaque(false);\n        this.infoTextArea.setEditable(false);\n        \n        this.titlePanel.add(titleLabel);\n        this.titlePanel.add(infoTextArea);\n        \n        this.northPanel.add(iconLabel, BorderLayout.WEST);\n        this.northPanel.add(titlePanel, BorderLayout.CENTER);\n        \n        this.requestScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n        this.requestPane.setEditable(false);\n        this.requestPane.setOpaque(false);\n        this.requestPane.setText(request.getReason());\n                \n        this.requestScrollPane.getViewport().add(requestPane);\n        \n        this.responseScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n        this.responseScrollPane.getViewport().add(responsePane);\n        \n        this.reasonsPanel.add(requestScrollPane);\n        this.reasonsPanel.add(responseScrollPane);\n        \n        this.acceptButton.setName(\"accept\");\n        this.rejectButton.setName(\"reject\");\n        this.ignoreButton.setName(\"ignore\");\n        \n        this.getRootPane().setDefaultButton(acceptButton);\n        this.acceptButton.addActionListener(this);\n        this.rejectButton.addActionListener(this);\n        this.ignoreButton.addActionListener(this);\n                \n        this.acceptButton.setMnemonic(\n                Messages.getString(\"mnemonic.acceptButton\").charAt(0));\n        this.rejectButton.setMnemonic(\n                Messages.getString(\"mnemonic.rejectButton\").charAt(0));\n        this.ignoreButton.setMnemonic(\n                Messages.getString(\"mnemonic.ignoreButton\").charAt(0));\n        \n        this.buttonsPanel.add(acceptButton);\n        this.buttonsPanel.add(rejectButton);\n        this.buttonsPanel.add(ignoreButton);\n        \n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(reasonsPanel, BorderLayout.CENTER);\n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);\n        \n        this.setSize(new Dimension(550, 400));        \n    }","id":81676,"modified_method":"/**\n     * Constructs the <tt>RequestAuthorisationDialog<\/tt>.\n     * \n     * @param contact The <tt>Contact<\/tt>, which requires authorisation.\n     * @param request The <tt>AuthorizationRequest<\/tt> that will be sent.\n     */\n    public AuthorizationRequestedDialog(MainFrame mainFrame, Contact contact,\n            AuthorizationRequest request) {\n        \n        super(mainFrame);\n        \n        this.setModal(false);\n        \n        this.setTitle(title);\n\n        titleLabel.setHorizontalAlignment(JLabel.CENTER);\n        titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD, 18f));\n        titleLabel.setText(title);\n        \n        infoTextArea.setText(Messages.getString(\"authorizationRequestedInfo\", \n                contact.getDisplayName()));\n        this.infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD, 12f));\n        this.infoTextArea.setLineWrap(true);\n        this.infoTextArea.setWrapStyleWord(true);\n        this.infoTextArea.setOpaque(false);\n        this.infoTextArea.setEditable(false);\n        \n        this.titlePanel.add(titleLabel);\n        this.titlePanel.add(infoTextArea);\n        \n        this.northPanel.add(iconLabel, BorderLayout.WEST);\n        this.northPanel.add(titlePanel, BorderLayout.CENTER);\n        \n        if(request.getReason() != null && request.getReason() != \"\") {\n            this.requestScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n            this.requestPane.setEditable(false);\n            this.requestPane.setOpaque(false);\n            this.requestPane.setText(request.getReason());\n                    \n            this.requestScrollPane.getViewport().add(requestPane);\n            \n            this.reasonsPanel.add(requestScrollPane);\n            \n            this.mainPanel.setPreferredSize(new Dimension(550, 400));            \n        }\n        else {\n            this.mainPanel.setPreferredSize(new Dimension(550, 300));\n        }\n        \n        this.responseScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n        this.responseScrollPane.getViewport().add(responsePane);\n        \n        this.reasonsPanel.add(responseScrollPane);\n        \n        this.acceptButton.setName(\"accept\");\n        this.rejectButton.setName(\"reject\");\n        this.ignoreButton.setName(\"ignore\");\n        \n        this.getRootPane().setDefaultButton(acceptButton);\n        this.acceptButton.addActionListener(this);\n        this.rejectButton.addActionListener(this);\n        this.ignoreButton.addActionListener(this);\n                \n        this.acceptButton.setMnemonic(\n                Messages.getString(\"mnemonic.acceptButton\").charAt(0));\n        this.rejectButton.setMnemonic(\n                Messages.getString(\"mnemonic.rejectButton\").charAt(0));\n        this.ignoreButton.setMnemonic(\n                Messages.getString(\"mnemonic.ignoreButton\").charAt(0));\n        \n        this.buttonsPanel.add(acceptButton);\n        this.buttonsPanel.add(rejectButton);\n        this.buttonsPanel.add(ignoreButton);\n        \n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(reasonsPanel, BorderLayout.CENTER);\n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);\n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the <tt>RequestAuthorisationDialog<\/tt>.\n     * \n     * @param contact The <tt>Contact<\/tt>, which requires authorisation.\n     * @param response The <tt>AuthorizationResponse<\/tt> that has been\n     * received.\n     */\n    public AuthorizationResponseDialog(MainFrame mainFrame, Contact contact,\n            AuthorizationResponse response) {\n        super(mainFrame);\n        \n        this.setModal(false);\n        \n        this.setTitle(title);\n        \n        titleLabel.setHorizontalAlignment(JLabel.CENTER);\n        titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD, 18f));\n        titleLabel.setText(title);\n        \n        this.mainPanel.setPreferredSize(new Dimension(400, 250));\n                \n        AuthorizationResponse.AuthorizationResponseCode responseCode\n            = response.getResponseCode();\n        \n        if(responseCode.equals(AuthorizationResponse.ACCEPT)) {\n            infoTextArea.setText(contact.getDisplayName() + \" \"\n                    + Messages.getString(\"authAccepted\"));\n        }\n        else if(responseCode.equals(AuthorizationResponse.REJECT)) {\n            infoTextArea.setText(contact.getDisplayName() + \" \"\n                    + Messages.getString(\"authRejected\"));\n        }\n        \n        this.responseScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n        this.responseArea.setText(response.getReason());\n        this.responseArea.setLineWrap(true);\n        this.responseArea.setWrapStyleWord(true);\n        this.responseArea.setEditable(false);\n        this.responseArea.setOpaque(false);\n        \n        this.responseScrollPane.getViewport().add(responseArea);\n        \n        this.infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD, 12f));\n        this.infoTextArea.setLineWrap(true);\n        this.infoTextArea.setWrapStyleWord(true);\n        this.infoTextArea.setEditable(false);\n        this.infoTextArea.setOpaque(false);\n        \n        this.titlePanel.add(titleLabel);\n        this.titlePanel.add(infoTextArea);\n        \n        this.northPanel.add(iconLabel, BorderLayout.WEST);\n        this.northPanel.add(titlePanel, BorderLayout.CENTER);\n        \n        this.okButton.requestFocus();\n        this.okButton.setName(\"ok\");\n        this.getRootPane().setDefaultButton(okButton);\n        \n        this.okButton.addActionListener(this);\n        \n        this.buttonsPanel.add(okButton);\n        \n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(responseScrollPane, BorderLayout.CENTER);\n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);\n        \n        this.setSize(new Dimension(400, 200));        \n    }","id":81677,"modified_method":"/**\n     * Constructs the <tt>RequestAuthorisationDialog<\/tt>.\n     * \n     * @param contact The <tt>Contact<\/tt>, which requires authorisation.\n     * @param response The <tt>AuthorizationResponse<\/tt> that has been\n     * received.\n     */\n    public AuthorizationResponseDialog(MainFrame mainFrame, Contact contact,\n            AuthorizationResponse response) {\n        super(mainFrame);\n        \n        this.setModal(false);\n        \n        this.setTitle(title);\n        \n        titleLabel.setHorizontalAlignment(JLabel.CENTER);\n        titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD, 18f));\n        titleLabel.setText(title);\n        \n        this.mainPanel.setPreferredSize(new Dimension(400, 250));\n                \n        AuthorizationResponse.AuthorizationResponseCode responseCode\n            = response.getResponseCode();\n        \n        if(responseCode.equals(AuthorizationResponse.ACCEPT)) {\n            infoTextArea.setText(contact.getDisplayName() + \" \"\n                    + Messages.getString(\"authAccepted\"));\n        }\n        else if(responseCode.equals(AuthorizationResponse.REJECT)) {\n            infoTextArea.setText(contact.getDisplayName() + \" \"\n                    + Messages.getString(\"authRejected\"));\n        }\n        \n        if(response.getReason() != null && response.getReason() != \"\") {\n            this.responseScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n            this.responseArea.setText(response.getReason());\n            this.responseArea.setLineWrap(true);\n            this.responseArea.setWrapStyleWord(true);\n            this.responseArea.setEditable(false);\n            this.responseArea.setOpaque(false);\n            \n            this.responseScrollPane.getViewport().add(responseArea);\n            \n            this.mainPanel.add(responseScrollPane, BorderLayout.CENTER);\n            \n            this.mainPanel.setPreferredSize(new Dimension(400, 250));\n        }\n        else {\n            this.mainPanel.setPreferredSize(new Dimension(400, 200));\n        }\n                \n        this.infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD, 12f));\n        this.infoTextArea.setLineWrap(true);\n        this.infoTextArea.setWrapStyleWord(true);\n        this.infoTextArea.setEditable(false);\n        this.infoTextArea.setOpaque(false);\n        \n        this.titlePanel.add(titleLabel);\n        this.titlePanel.add(infoTextArea);\n        \n        this.northPanel.add(iconLabel, BorderLayout.WEST);\n        this.northPanel.add(titlePanel, BorderLayout.CENTER);\n        \n        this.okButton.requestFocus();\n        this.okButton.setName(\"ok\");\n        this.getRootPane().setDefaultButton(okButton);\n        \n        this.okButton.addActionListener(this);\n        \n        this.buttonsPanel.add(okButton);\n        \n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);        \n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows this modal dialog and returns the result of the user choice.\n     * @return if the \"Request\" button was pressed returns OK_RETURN_CODE,\n     * otherwise CANCEL_RETURN_CODE is returned\n     */\n    public int showDialog()\n    {\n        this.setVisible(true);\n        \n        return returnCode;\n    }","id":81678,"modified_method":"/**\n     * Shows this modal dialog and returns the result of the user choice.\n     * @return if the \"Request\" button was pressed returns OK_RETURN_CODE,\n     * otherwise CANCEL_RETURN_CODE is returned\n     */\n    public int showDialog()\n    {\n        this.setVisible(true);\n        \n        this.requestPane.requestFocus();\n        \n        synchronized (lock) {\n            try {                    \n                lock.wait();\n            }\n            catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        \n        return returnCode;\n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the <tt>RequestAuthorisationDialog<\/tt>.\n     * \n     * @param contact The <tt>Contact<\/tt>, which requires authorisation.\n     * @param request The <tt>AuthorizationRequest<\/tt> that will be sent.\n     */\n    public RequestAuthorizationDialog(MainFrame mainFrame, Contact contact,\n            AuthorizationRequest request)\n    {\n        super(mainFrame);\n        \n        this.setModal(false);\n        \n        this.setTitle(title);\n    \n        titleLabel.setHorizontalAlignment(JLabel.CENTER);\n        titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD, 18f));\n        titleLabel.setText(title);\n        \n        this.mainPanel.setPreferredSize(new Dimension(350, 150));\n        \n        this.request = request;\n        \n        infoTextArea.setText(Messages.getString(\"requestAuthorizationInfo\", \n                contact.getDisplayName()));\n        \n        this.requestScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n        this.requestScrollPane.getViewport().add(requestPane);\n        \n        this.infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD, 12f));\n        this.infoTextArea.setLineWrap(true);\n        this.infoTextArea.setOpaque(false);\n        this.infoTextArea.setWrapStyleWord(true);\n        this.infoTextArea.setEditable(false);\n        \n        this.titlePanel.add(titleLabel);\n        this.titlePanel.add(infoTextArea);\n        \n        this.northPanel.add(iconLabel, BorderLayout.WEST);\n        this.northPanel.add(titlePanel, BorderLayout.CENTER);\n        \n        this.requestButton.setName(\"request\");\n        this.cancelButton.setName(\"cancel\");\n        \n        this.requestButton.addActionListener(this);\n        this.cancelButton.addActionListener(this);\n        \n        this.buttonsPanel.add(requestButton);\n        this.buttonsPanel.add(cancelButton);\n        \n        this.getRootPane().setDefaultButton(requestButton);\n        this.requestButton.setMnemonic(\n                Messages.getString(\"mnemonic.requestButton\").charAt(0));\n        this.cancelButton.setMnemonic(\n                Messages.getString(\"mnemonic.cancel\").charAt(0));\n        \n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(requestScrollPane, BorderLayout.CENTER);\n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);\n        \n        this.setSize(new Dimension(400, 300));        \n    }","id":81679,"modified_method":"/**\n     * Constructs the <tt>RequestAuthorisationDialog<\/tt>.\n     * \n     * @param contact The <tt>Contact<\/tt>, which requires authorisation.\n     * @param request The <tt>AuthorizationRequest<\/tt> that will be sent.\n     */\n    public RequestAuthorizationDialog(MainFrame mainFrame, Contact contact,\n            AuthorizationRequest request)\n    {\n        super(mainFrame);\n        \n        this.setModal(false);\n        \n        this.setTitle(title);\n    \n        titleLabel.setHorizontalAlignment(JLabel.CENTER);\n        titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD, 18f));\n        titleLabel.setText(title);\n        \n        this.mainPanel.setPreferredSize(new Dimension(400, 300));\n        \n        this.request = request;\n        \n        infoTextArea.setText(Messages.getString(\"requestAuthorizationInfo\", \n                contact.getDisplayName()));\n        \n        this.requestScrollPane.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createEmptyBorder(3, 3, 3, 3),\n                SIPCommBorders.getBoldRoundBorder()));\n        \n        this.requestScrollPane.getViewport().add(requestPane);\n        \n        this.infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD, 12f));\n        this.infoTextArea.setLineWrap(true);\n        this.infoTextArea.setOpaque(false);\n        this.infoTextArea.setWrapStyleWord(true);\n        this.infoTextArea.setEditable(false);\n                \n        this.titlePanel.add(titleLabel);\n        this.titlePanel.add(infoTextArea);\n        \n        this.northPanel.add(iconLabel, BorderLayout.WEST);\n        this.northPanel.add(titlePanel, BorderLayout.CENTER);\n        \n        this.requestButton.setName(\"request\");\n        this.cancelButton.setName(\"cancel\");\n        \n        this.requestButton.addActionListener(this);\n        this.cancelButton.addActionListener(this);\n        \n        this.buttonsPanel.add(requestButton);\n        this.buttonsPanel.add(cancelButton);\n        \n        this.getRootPane().setDefaultButton(requestButton);\n        this.requestButton.setMnemonic(\n                Messages.getString(\"mnemonic.requestButton\").charAt(0));\n        this.cancelButton.setMnemonic(\n                Messages.getString(\"mnemonic.cancel\").charAt(0));\n        \n        this.mainPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        this.mainPanel.add(northPanel, BorderLayout.NORTH);\n        this.mainPanel.add(requestScrollPane, BorderLayout.CENTER);\n        this.mainPanel.add(buttonsPanel, BorderLayout.SOUTH);\n        \n        this.getContentPane().add(mainPanel);                   \n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> triggered when one user clicks\n     * on one of the buttons.\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JButton button = (JButton)e.getSource();\n        String name = button.getName();\n        \n        if(name.equals(\"request\")) {\n            returnCode = OK_RETURN_CODE;\n        }\n        else if(name.equals(\"cancel\")) {\n            returnCode = CANCEL_RETURN_CODE;\n        }\n        this.dispose();\n    }","id":81680,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> triggered when one user clicks\n     * on one of the buttons.\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JButton button = (JButton)e.getSource();\n        String name = button.getName();\n        \n        if(name.equals(\"request\")) {\n            returnCode = OK_RETURN_CODE;\n        }\n        else if(name.equals(\"cancel\")) {\n            returnCode = CANCEL_RETURN_CODE;\n        }\n        \n        synchronized (lock) {\n            lock.notify();\n        }\n        \n        this.dispose();\n    }","commit_id":"f5fb7c6a12a6ead29f6f459cf3eea560ff728926","url":"https://github.com/jitsi/jitsi"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","id":81681,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"langModule\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"langModule\") == null) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      FindInstancesDialog testDialog = new FindInstancesDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))), SNodeOperations.getModel(((SNode) MapSequence.fromMap(_params).get(\"node\"))).getModule());\n      testDialog.showDialog();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindInstancesByCondition\", t);\n      }\n    }\n  }","id":81682,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      FindInstancesDialog testDialog = new FindInstancesDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))), (Language) ((SModule) MapSequence.fromMap(_params).get(\"langModule\")));\n      testDialog.show();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindInstancesByCondition\", t);\n      }\n    }\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FindInstancesDialog(final SNode concept, final IOperationContext context, final SModule module) {\n    super(ProjectHelper.toMainFrame(context.getProject()), \"Find Instances by condition\");\n    this.myContext = context;\n    this.myModelAccess = context.getProject().getRepository().getModelAccess();\n    this.setSize(new Dimension(500, 500));\n    this.setModal(false);\n\n    myModelAccess.executeCommand(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myNode = _quotation_createNode_vfh0rq_a0a0a0a6a9((concept == null ?\n          SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\") :\n          concept\n        ));\n        FindInstancesDialog.this.myEditor = new EmbeddableEditor(context.getProject(), new _FunctionTypes._void_P1_E0<SModel>() {\n          public void invoke(SModel m) {\n            m.addRootNode(myNode);\n            ((SModelInternal) m).addLanguage(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"d745e97c-8235-4470-b086-ba3da1f4c03c\")).getModuleReference());\n            ((SModelInternal) m).addDevKit(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"fbc25dd2-5da4-483a-8b19-70928e1b62d7\")).getModuleReference());\n          }\n        }, true) {\n          @Override\n          protected void processClassesData(IClassesData cd) {\n            doProcessClassesData(cd);\n          }\n        };\n\n        myEditor.editNode(myNode);\n      }\n    });\n    if (module instanceof Language) {\n      final Set<Language> languageList = SetSequence.fromSet(new HashSet<Language>());\n      myModelAccess.runReadAction(new Runnable() {\n        public void run() {\n          new LanguageDependenciesManager((Language) module).collectAllExtendedLanguages(languageList);\n        }\n      });\n      for (Language extendedLanguage : languageList) {\n        this.myEditor.addLanguageStructureModel(extendedLanguage);\n      }\n    }\n    this.myPanel.add(this.myEditor.getComponenet(), BorderLayout.CENTER);\n    this.myEditor.addLanguageStructureModel(BootstrapLanguages.collectionsLanguage());\n    if (module instanceof Language) {\n      this.myEditor.addLanguageStructureModel((Language) module);\n    }\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myScope = new ScopeEditor(new ScopeOptions());\n        FindInstancesDialog.this.myPanel.add(FindInstancesDialog.this.myScope.getComponent(), BorderLayout.SOUTH);\n      }\n    });\n  }","id":81683,"modified_method":"public FindInstancesDialog(final SNode concept, final IOperationContext context, final SModule module) {\n    super(ProjectHelper.toIdeaProject(context.getProject()));\n    this.setTitle(\"Find Instances by condition\");\n    this.myContext = context;\n    this.myModelAccess = context.getProject().getRepository().getModelAccess();\n    this.setModal(false);\n    this.setOKButtonText(\"&Find\");\n    this.setCancelButtonText(\"&Cancel\");\n\n    myModelAccess.executeCommand(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myNode = _quotation_createNode_vfh0rq_a0a0a0a8a9((concept == null ?\n          SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\") :\n          concept\n        ));\n        FindInstancesDialog.this.myEditor = new EmbeddableEditor(context.getProject(), new _FunctionTypes._void_P1_E0<SModel>() {\n          public void invoke(SModel m) {\n            m.addRootNode(myNode);\n            ((SModelInternal) m).addLanguage(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"d745e97c-8235-4470-b086-ba3da1f4c03c\")).getModuleReference());\n            ((SModelInternal) m).addDevKit(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"fbc25dd2-5da4-483a-8b19-70928e1b62d7\")).getModuleReference());\n          }\n        }, true) {\n          @Override\n          protected void processClassesData(IClassesData cd) {\n            doProcessClassesData(cd);\n          }\n        };\n\n        myEditor.editNode(myNode);\n      }\n    });\n    if (module instanceof Language) {\n      final Set<Language> languageList = SetSequence.fromSet(new HashSet<Language>());\n      myModelAccess.runReadAction(new Runnable() {\n        public void run() {\n          new LanguageDependenciesManager((Language) module).collectAllExtendedLanguages(languageList);\n        }\n      });\n      for (Language extendedLanguage : languageList) {\n        this.myEditor.addLanguageStructureModel(extendedLanguage);\n      }\n    }\n    this.myPanel.add(this.myEditor.getComponenet(), BorderLayout.CENTER);\n    this.myEditor.addLanguageStructureModel(BootstrapLanguages.collectionsLanguage());\n    if (module instanceof Language) {\n      this.myEditor.addLanguageStructureModel((Language) module);\n    }\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myScope = new ScopeEditor(new ScopeOptions());\n        FindInstancesDialog.this.myPanel.add(FindInstancesDialog.this.myScope.getComponent(), BorderLayout.SOUTH);\n      }\n    });\n    myPanel.setPreferredSize(new Dimension(500, 500));\n\n    init();\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_vfh0rq_a0a0a0a6a9(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.ModelQuery\", null, null, GlobalScope.getInstance(), false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_2, \"conceptDeclaration\", (SNode) parameter_1);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.QueryCondition\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_3.addChild(\"body\", quotedNode_4);\n    quotedNode_2.addChild(\"condition\", quotedNode_3);\n    return quotedNode_2;\n  }","id":81684,"modified_method":"private static SNode _quotation_createNode_vfh0rq_a0a0a0a8a9(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.ModelQuery\", null, null, GlobalScope.getInstance(), false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_2, \"conceptDeclaration\", (SNode) parameter_1);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.QueryCondition\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_3.addChild(\"body\", quotedNode_4);\n    quotedNode_2.addChild(\"condition\", quotedNode_3);\n    return quotedNode_2;\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_bs6rum_a0a0a0a4a7(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.ReplaceModelQuery\", null, null, GlobalScope.getInstance(), false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_2, \"conceptDeclaration\", (SNode) parameter_1);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.QueryReplace\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_3.addChild(\"body\", quotedNode_5);\n    quotedNode_2.addChild(\"replace\", quotedNode_3);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.QueryCondition\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null, null, GlobalScope.getInstance(), false);\n    SNodeAccessUtil.setProperty(quotedNode_8, \"value\", \"true\");\n    quotedNode_7.addChild(\"expression\", quotedNode_8);\n    quotedNode_6.addChild(\"statement\", quotedNode_7);\n    quotedNode_4.addChild(\"body\", quotedNode_6);\n    quotedNode_2.addChild(\"condition\", quotedNode_4);\n    return quotedNode_2;\n  }","id":81685,"modified_method":"private static SNode _quotation_createNode_bs6rum_a0a0a0a7a7(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.ReplaceModelQuery\", null, null, GlobalScope.getInstance(), false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_2, \"conceptDeclaration\", (SNode) parameter_1);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.QueryReplace\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_3.addChild(\"body\", quotedNode_5);\n    quotedNode_2.addChild(\"replace\", quotedNode_3);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.quickQueryLanguage.structure.QueryCondition\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.StatementList\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null, null, GlobalScope.getInstance(), false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null, null, GlobalScope.getInstance(), false);\n    SNodeAccessUtil.setProperty(quotedNode_8, \"value\", \"true\");\n    quotedNode_7.addChild(\"expression\", quotedNode_8);\n    quotedNode_6.addChild(\"statement\", quotedNode_7);\n    quotedNode_4.addChild(\"body\", quotedNode_6);\n    quotedNode_2.addChild(\"condition\", quotedNode_4);\n    return quotedNode_2;\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ReplaceDialog(final SNode concept, final IOperationContext context, final Language language) {\n    super(ProjectHelper.toMainFrame(context.getProject()), \"Modify Instances by condition\");\n    this.myContext = context;\n    this.myModelAccess = context.getProject().getRepository().getModelAccess();\n\n    myModelAccess.executeCommand(new Runnable() {\n      public void run() {\n        ReplaceDialog.this.myNode = _quotation_createNode_bs6rum_a0a0a0a4a7((concept == null ?\n          SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\") :\n          concept\n        ));\n        ReplaceDialog.this.myEditor = new EmbeddableEditor(context.getProject(), new _FunctionTypes._void_P1_E0<SModel>() {\n          public void invoke(SModel m) {\n            m.addRootNode(myNode);\n            ((SModelInternal) m).addLanguage(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"d745e97c-8235-4470-b086-ba3da1f4c03c\")).getModuleReference());\n            ((SModelInternal) m).addDevKit(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"fbc25dd2-5da4-483a-8b19-70928e1b62d7\")).getModuleReference());\n          }\n        }, true) {\n          @Override\n          protected void processClassesData(IClassesData cd) {\n            doProcessClassesData(cd);\n          }\n        };\n        myEditor.editNode(myNode);\n        ReplaceDialog.this.myScope = new ScopeEditor(new ScopeOptions());\n        ReplaceDialog.this.myPanel.add(ReplaceDialog.this.myScope.getComponent(), BorderLayout.SOUTH);\n      }\n    });\n    this.myEditor.addLanguageStructureModel(language);\n    final Set<Language> languageList = SetSequence.fromSet(new HashSet<Language>());\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n        new LanguageDependenciesManager(language).collectAllExtendedLanguages(languageList);\n      }\n    });\n\n    for (Language extendedLanguage : languageList) {\n      this.myEditor.addLanguageStructureModel(extendedLanguage);\n    }\n    this.myEditor.addLanguageStructureModel(BootstrapLanguages.collectionsLanguage());\n    this.myPanel.add(this.myEditor.getComponenet(), BorderLayout.CENTER);\n    this.setSize(new Dimension(500, 500));\n    this.setModal(false);\n  }","id":81686,"modified_method":"public ReplaceDialog(final SNode concept, final IOperationContext context, final Language language) {\n    super(ProjectHelper.toIdeaProject(context.getProject()));\n    this.setTitle(\"Modify Instances by condition\");\n    this.myContext = context;\n    this.myModelAccess = context.getProject().getRepository().getModelAccess();\n    this.setOKButtonText(\"&Modify\");\n    this.setCancelButtonText(\"&Cancel\");\n\n    myModelAccess.executeCommand(new Runnable() {\n      public void run() {\n        ReplaceDialog.this.myNode = _quotation_createNode_bs6rum_a0a0a0a7a7((concept == null ?\n          SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\") :\n          concept\n        ));\n        ReplaceDialog.this.myEditor = new EmbeddableEditor(context.getProject(), new _FunctionTypes._void_P1_E0<SModel>() {\n          public void invoke(SModel m) {\n            m.addRootNode(myNode);\n            ((SModelInternal) m).addLanguage(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"d745e97c-8235-4470-b086-ba3da1f4c03c\")).getModuleReference());\n            ((SModelInternal) m).addDevKit(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"fbc25dd2-5da4-483a-8b19-70928e1b62d7\")).getModuleReference());\n          }\n        }, true) {\n          @Override\n          protected void processClassesData(IClassesData cd) {\n            doProcessClassesData(cd);\n          }\n        };\n        myEditor.editNode(myNode);\n        ReplaceDialog.this.myScope = new ScopeEditor(new ScopeOptions());\n        ReplaceDialog.this.myPanel.add(ReplaceDialog.this.myScope.getComponent(), BorderLayout.SOUTH);\n      }\n    });\n    this.myEditor.addLanguageStructureModel(language);\n    final Set<Language> languageList = SetSequence.fromSet(new HashSet<Language>());\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n        new LanguageDependenciesManager(language).collectAllExtendedLanguages(languageList);\n      }\n    });\n\n    for (Language extendedLanguage : languageList) {\n      this.myEditor.addLanguageStructureModel(extendedLanguage);\n    }\n    this.myEditor.addLanguageStructureModel(BootstrapLanguages.collectionsLanguage());\n    this.myPanel.add(this.myEditor.getComponenet(), BorderLayout.CENTER);\n    this.myPanel.setPreferredSize(new Dimension(500, 500));\n    this.setModal(false);\n\n    init();\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ReplaceDialog dialog = new ReplaceDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))), (Language) ((SModule) MapSequence.fromMap(_params).get(\"langModule\")));\n      dialog.showDialog();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ReplacementQueryAction\", t);\n      }\n    }\n  }","id":81687,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ReplaceDialog dialog = new ReplaceDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))), (Language) ((SModule) MapSequence.fromMap(_params).get(\"langModule\")));\n      dialog.show();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ReplacementQueryAction\", t);\n      }\n    }\n  }","commit_id":"2bab754800bed74589824f92642e803755036800","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ByteBuffer fromString(String source) throws MarshalException\n    {\n        UUID uuid = null;\n        try\n        {\n            uuid = UUID.fromString(source);\n        }\n        catch (IllegalArgumentException e)\n        {\n            throw new MarshalException(String.format(\"unable to make UUID from '%s'\", source), e);\n        }\n\n        if (uuid.version() != 1)\n            throw new MarshalException(\"TimeUUID supports only version 1 UUIDs\");\n\n        return ByteBuffer.wrap(UUIDGen.decompose(uuid));\n    }","id":81688,"modified_method":"public ByteBuffer fromString(String source) throws MarshalException\n    {\n        ByteBuffer idBytes = null;\n        \n        // ffffffff-ffff-ffff-ffff-ffffffffff\n        if (regexPattern.matcher(source).matches())\n        {\n            UUID uuid = null;\n            try\n            {\n                uuid = UUID.fromString(source);\n                idBytes = ByteBuffer.wrap(UUIDGen.decompose(uuid));\n            }\n            catch (IllegalArgumentException e)\n            {\n                throw new MarshalException(String.format(\"unable to make UUID from '%s'\", source), e);\n            }\n            \n            if (uuid.version() != 1)\n                throw new MarshalException(\"TimeUUID supports only version 1 UUIDs\");\n        }\n        else if (source.equals(\"\") || source.toLowerCase().equals(\"now\"))\n        {\n            idBytes = ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress())));\n        }\n        // Milliseconds since epoch?\n        else if (source.matches(\"^\\\\d+$\"))\n        {\n            try\n            {\n                idBytes = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(Long.parseLong(source)));\n            }\n            catch (NumberFormatException e)\n            {\n                throw new MarshalException(String.format(\"unable to make version 1 UUID from '%s'\"), e);\n            }\n        }\n        // Last chance, attempt to parse as date-time string\n        else\n        {\n            try\n            {\n                long timestamp = DateUtils.parseDate(source, iso8601Patterns).getTime();\n                idBytes = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(timestamp));\n            }\n            catch (ParseException e1)\n            {\n                throw new MarshalException(String.format(\"unable to coherce '%s' to version 1 UUID\"), e1);\n            }\n        }\n            \n        return idBytes;\n    }","commit_id":"189133ec9a57a11476fb556afce11559c26cb74e","url":"https://github.com/apache/cassandra"},{"original_method":"public void executed() throws SQLException\n   {\n      if (streamingResultSetOpen)\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET);\n      }\n   }","id":81689,"modified_method":"public void executed() throws SQLException\n   {\n      if (streamingResultSetOpened != null)\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET, streamingResultSetOpened);\n      }\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void streamingResultSetClosed()\n   {\n      streamingResultSetOpen = false;\n   }","id":81690,"modified_method":"public void streamingResultSetClosed()\n   {\n      streamingResultSetOpened = null;\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void resultSetOpened() throws SQLException\n   {\n      if (streamingResultSetOpen)\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET);\n      }\n      ++resultSetsOpen;\n   }","id":81691,"modified_method":"public void resultSetOpened(Throwable throwable) throws SQLException\n   {\n      if (streamingResultSetOpened != null)\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET, streamingResultSetOpened);\n      }\n      resultSetsOpened.add(throwable);\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void streamingResultSetOpened() throws SQLException\n   {\n      if (streamingResultSetOpen || resultSetsOpen != 0)\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET);\n      }\n      streamingResultSetOpen = true;\n   }","id":81692,"modified_method":"public void streamingResultSetOpened(Throwable throwable) throws SQLException\n   {\n      if (streamingResultSetOpened != null)\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET, streamingResultSetOpened);\n      }\n      else if (!resultSetsOpened.isEmpty())\n      {\n         throw new StreamingResultSetSQLException(CONCURRENT_RESULTSET, resultSetsOpened.iterator().next());\n      }\n      streamingResultSetOpened = throwable;\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void resultSetClosed()\n   {\n      --resultSetsOpen;\n   }","id":81693,"modified_method":"public void resultSetClosed(Throwable throwable)\n   {\n      resultSetsOpened.remove(throwable);\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n   {\n      if (method.getName().equals(\"toString\"))\n      {\n         return \"ConnectionWrapper->\"+connection.toString();\n      }\n      try\n      {\n         Object result = method.invoke(connection, args);\n         if (result instanceof Statement)\n         {\n            Statement statement = (Statement) result;\n            return StatementWrapper.wrap(statement, (Connection) proxy);\n         }\n         return result;\n      }\n      catch (InvocationTargetException e)\n      {\n         throw e.getTargetException();\n      }\n   }","id":81694,"modified_method":"@Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n   {\n      if (method.getName().equals(\"toString\"))\n      {\n         return \"ConnectionWrapper->\"+connection.toString();\n      }\n      if (method.getName().equals(\"close\"))\n      {\n         if (streamingResultSetOpened != null)\n         {\n            log.error(\"Connection.close: streaming ResultSet still open\", streamingResultSetOpened);\n         }\n         if (!resultSetsOpened.isEmpty())\n         {\n            log.error(\"Connection.close: ResultSet still open\", resultSetsOpened.iterator().next());\n         }\n      }\n      try\n      {\n         Object result = method.invoke(connection, args);\n         if (result instanceof Statement)\n         {\n            Statement statement = (Statement) result;\n            return StatementWrapper.wrap(statement, (Connection) proxy);\n         }\n         return result;\n      }\n      catch (InvocationTargetException e)\n      {\n         throw e.getTargetException();\n      }\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n   {\n      if (method.getName().equals(\"toString\"))\n      {\n         return \"ResultSetWrapper->\"+resultSet.toString();\n      }\n      try\n      {\n         Object result = method.invoke(resultSet, args);\n         if (method.getName().equals(\"close\"))\n         {\n            ConnectionWrapper connectionWrapper = (ConnectionWrapper) Proxy.getInvocationHandler(connection);\n            if (streaming)\n            {\n               connectionWrapper.streamingResultSetClosed();\n            }\n            else\n            {\n               connectionWrapper.resultSetClosed();\n            }\n         }\n         return result;\n      }\n      catch (InvocationTargetException e)\n      {\n         throw e.getTargetException();\n      }\n   }","id":81695,"modified_method":"@Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n   {\n      if (method.getName().equals(\"toString\"))\n      {\n         return \"ResultSetWrapper->\"+resultSet.toString();\n      }\n      try\n      {\n         Object result = method.invoke(resultSet, args);\n         if (method.getName().equals(\"close\"))\n         {\n            ConnectionWrapper connectionWrapper = (ConnectionWrapper) Proxy.getInvocationHandler(connection);\n            if (streaming)\n            {\n               connectionWrapper.streamingResultSetClosed();\n            }\n            else\n            {\n               connectionWrapper.resultSetClosed(throwable);\n            }\n         }\n         return result;\n      }\n      catch (InvocationTargetException e)\n      {\n         throw e.getTargetException();\n      }\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n   {\n      if (method.getName().equals(\"getConnection\"))\n      {\n         return connection;\n      }\n      if (method.getName().equals(\"toString\"))\n      {\n         return \"StatementWrapper->\"+statement.toString();\n      }\n      if (method.getName().equals(\"setFetchSize\") && args[0].equals(Integer.MIN_VALUE))\n      {\n         // don't pass it to wrapped connection since it is probably not going to understand it\n         makeStreamingResultSet = true;\n         return null;\n      }\n      try\n      {\n         Object result = method.invoke(statement, args);\n         if (result instanceof ResultSet)\n         {\n            ResultSet resultSet = (ResultSet) result;\n            ConnectionWrapper connectionWrapper = (ConnectionWrapper) Proxy.getInvocationHandler(connection);\n            if (makeStreamingResultSet)\n            {\n               connectionWrapper.streamingResultSetOpened();\n            }\n            else\n            {\n               connectionWrapper.resultSetOpened();\n            }\n            return ResultSetWrapper.wrap(resultSet, connection, makeStreamingResultSet);\n         }\n         else if (method.getName().startsWith(\"execute\"))\n         {\n            ConnectionWrapper connectionWrapper = (ConnectionWrapper) Proxy.getInvocationHandler(connection);\n            connectionWrapper.executed();\n         }\n         return result;\n      }\n      catch (InvocationTargetException e)\n      {\n         throw e.getTargetException();\n      }\n   }","id":81696,"modified_method":"@Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n   {\n      if (method.getName().equals(\"getConnection\"))\n      {\n         return connection;\n      }\n      if (method.getName().equals(\"toString\"))\n      {\n         return \"StatementWrapper->\"+statement.toString();\n      }\n      if (method.getName().equals(\"setFetchSize\") && args[0].equals(Integer.MIN_VALUE))\n      {\n         // don't pass it to wrapped connection since it is probably not going to understand it\n         makeStreamingResultSet = true;\n         return null;\n      }\n      try\n      {\n         Object result = method.invoke(statement, args);\n         if (result instanceof ResultSet)\n         {\n            ResultSet resultSet = (ResultSet) result;\n            ConnectionWrapper connectionWrapper = (ConnectionWrapper) Proxy.getInvocationHandler(connection);\n            ResultSet rsProxy = ResultSetWrapper.wrap(resultSet, connection, makeStreamingResultSet);\n            ResultSetWrapper rsWrap = (ResultSetWrapper) Proxy.getInvocationHandler(rsProxy);\n            if (makeStreamingResultSet)\n            {\n               connectionWrapper.streamingResultSetOpened(rsWrap.getThrowable());\n            }\n            else\n            {\n               connectionWrapper.resultSetOpened(rsWrap.getThrowable());\n            }\n            return rsProxy;\n         }\n         else if (method.getName().startsWith(\"execute\"))\n         {\n            ConnectionWrapper connectionWrapper = (ConnectionWrapper) Proxy.getInvocationHandler(connection);\n            connectionWrapper.executed();\n         }\n         return result;\n      }\n      catch (InvocationTargetException e)\n      {\n         throw e.getTargetException();\n      }\n   }","commit_id":"306b5d03d0fff16aa4ae0bf2d62d2acda9bf82a9","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void pasteToTarget(final SNode pasteTarget, final SNode anchorNode, String role, final PastePlaceHint placeHint) {\n    AbstractConceptDeclaration pasteTargetType = pasteTarget.getConceptDeclarationAdapter();\n    final LinkDeclaration link = findSuitableLink(pasteTargetType, role);\n    if (link.getMetaClass() == LinkMetaclass.reference) {\n      assert myPasteNodes.size() == 1 : \"cannot paste multiple nodes to reference\";\n      pasteTarget.setReferent(link.getRole(), myPasteNodes.get(0));\n      return;\n    }\n\n    // unique child?\n    Cardinality cardinality = link.getSourceCardinality();\n    if (cardinality == Cardinality._0__1 || cardinality == Cardinality._1) {\n      assert myPasteNodes.size() == 1 : \"cannot paste multiple children for role '\" + link.getRole() + \"'\";\n      pasteTarget.setChild(link.getRole(), myPasteNodes.get(0));\n      return;\n    }\n\n    SNode _anchorNode = anchorNode;\n    boolean insertBefore = placeHint == PastePlaceHint.BEFORE_ANCHOR;\n    for (SNode pasteNode : myPasteNodes) {\n      SNode node;\n\n      if (SModelUtil_new.isAssignableConcept(pasteNode.getConceptDeclarationAdapter(), link.getTarget())) {\n        node = pasteNode;\n      } else if (PasteWrappersManager.getInstance().canWrapInto(pasteNode, link.getTarget())) {\n        node = PasteWrappersManager.getInstance().wrapInto(pasteNode,  link.getTarget());\n      } else {\n        throw new RuntimeException();\n      }\n\n      pasteTarget.insertChild(_anchorNode, link.getRole(), node, insertBefore);\n\n\n      _anchorNode = pasteNode;\n      insertBefore = false;\n    }\n\n    // delete original anchor if it was abstract concept\n    if (anchorNode != null && anchorNode.getConceptDeclarationAdapter().hasConceptProperty(AbstractConceptDeclaration.CPR_Abstract)) {\n      anchorNode.delete();\n    }\n  }","id":81697,"modified_method":"private void pasteToTarget(final SNode pasteTarget, final SNode anchorNode, String role, final PastePlaceHint placeHint) {\n    AbstractConceptDeclaration pasteTargetType = pasteTarget.getConceptDeclarationAdapter();\n    final LinkDeclaration link = findSuitableLink(pasteTargetType, role);\n\n    // unique child?\n    Cardinality cardinality = link.getSourceCardinality();\n    if (cardinality == Cardinality._0__1 || cardinality == Cardinality._1) {\n      assert myPasteNodes.size() == 1 : \"cannot paste multiple children for role '\" + link.getRole() + \"'\";\n      pasteTarget.setChild(link.getRole(), normalizeForLink(myPasteNodes.get(0), link));\n      return;\n    }\n\n    SNode _anchorNode = anchorNode;\n    boolean insertBefore = placeHint == PastePlaceHint.BEFORE_ANCHOR;\n    for (SNode pasteNode : myPasteNodes) {\n      pasteTarget.insertChild(_anchorNode, link.getRole(), normalizeForLink(pasteNode, link), insertBefore);\n\n      _anchorNode = pasteNode;\n      insertBefore = false;\n    }\n\n    // delete original anchor if it was abstract concept\n    if (anchorNode != null && anchorNode.getConceptDeclarationAdapter().hasConceptProperty(AbstractConceptDeclaration.CPR_Abstract)) {\n      anchorNode.delete();\n    }\n  }","commit_id":"2e7e258688c562deb1ccc5a12240515639462114","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<PasteWrapper> createPasteWrappers() {\n    List<PasteWrapper> result = new ArrayList();\n    result.add(new PasteWrapper() {\n\n      public String getSourceConceptFqName() {\n        return \"jetbrains.mps.baseLanguage.structure.Expression\";\n      }\n\n      public String getTargetConceptFqName() {\n        return \"jetbrains.mps.baseLanguage.structure.Statement\";\n      }\n\n      public SNode wrap(PasteWrapperContext _context) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null);\n        SLinkOperations.setTarget(result, \"expression\", _context.getSourceNode(), true);\n        return result;\n      }\n\n    });\n    return result;\n  }","id":81698,"modified_method":"public static List<PasteWrapper> createPasteWrappers() {\n    List<PasteWrapper> result = new ArrayList();\n    result.add(new PasteWrapper() {\n\n      public String getSourceConceptFqName() {\n        return \"jetbrains.mps.baseLanguage.structure.Expression\";\n      }\n\n      public String getTargetConceptFqName() {\n        return \"jetbrains.mps.baseLanguage.structure.Statement\";\n      }\n\n      public SNode wrap(PasteWrapperContext _context) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null);\n        SLinkOperations.setTarget(result, \"expression\", _context.getSourceNode(), true);\n        return result;\n      }\n\n    });\n    result.add(new PasteWrapper() {\n\n      public String getSourceConceptFqName() {\n        return \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\";\n      }\n\n      public String getTargetConceptFqName() {\n        return \"jetbrains.mps.baseLanguage.structure.Expression\";\n      }\n\n      public SNode wrap(PasteWrapperContext _context) {\n        return SLinkOperations.getTarget(_context.getSourceNode(), \"expression\", true);\n      }\n\n    });\n    return result;\n  }","commit_id":"2e7e258688c562deb1ccc5a12240515639462114","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode wrapInto(SNode node, AbstractConceptDeclaration targetConcept) {\n    PasteWrapper wrapper = getWrapperFor(node, targetConcept);\n    if (wrapper == null) {\n      throw new IllegalStateException();\n    }\n    return wrapper.wrap(new PasteWrapperContext(node));\n  }","id":81699,"modified_method":"public SNode wrapInto(SNode node, AbstractConceptDeclaration targetConcept) {\n    PasteWrapper wrapper = getWrapperFor(node, targetConcept);\n    if (wrapper == null) {\n      throw new IllegalStateException();\n    }\n    SNode result = wrapper.wrap(new PasteWrapperContext(node));\n    if (result.getParent() != null) {\n      result.getParent().removeChild(result);\n    }\n    return result;\n  }","commit_id":"2e7e258688c562deb1ccc5a12240515639462114","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\r\n  protected boolean run() {\r\n    final boolean create = context.user.has(Perm.CREATE);\r\n    String name = MetaData.normPath(args[0]);\r\n    if(name == null || name.endsWith(\".\")) return error(NAME_INVALID_X, args[0]);\r\n\r\n    // add slash to the target if the addressed file is an archive or directory\r\n    IO io = null;\r\n    if(in == null) {\r\n      io = IO.get(args[1]);\r\n    } else if(in.getSystemId() != null) {\r\n      io = IO.get(in.getSystemId());\r\n    } else if(in.getByteStream() != null) {\r\n      try {\r\n        io = cacheRaw();\r\n      } catch(final IOException ex) {\r\n        return error(Util.message(ex));\r\n      }\r\n    }\r\n\r\n    if(io != null) {\r\n      if(!io.exists()) return error(RESOURCE_NOT_FOUND_X, create ? io : args[1]);\r\n      if(!name.endsWith(\"/\") && (io.isDir() || io.isArchive())) name += '/';\r\n    }\r\n\r\n    String target = \"\";\r\n    final int s = name.lastIndexOf('/');\r\n    if(s != -1) {\r\n      target = name.substring(0, s);\r\n      name = name.substring(s + 1);\r\n    }\r\n\r\n    final Data data = context.data();\r\n    final Parser parser;\r\n    if(io != null) {\r\n      // set name of document\r\n      if(!name.isEmpty()) io.name(name);\r\n      // get name from io reference\r\n      else if(!(io instanceof IOContent)) name = io.name();\r\n      parser = new DirParser(io, prop, data.meta.path);\r\n    } else {\r\n      parser = new SAXWrapper(new SAXSource(in), name, context.prop);\r\n    }\r\n    parser.target(target);\r\n\r\n    // ensure that the final name is not empty\r\n    if(name.isEmpty()) return error(NAME_INVALID_X, name);\r\n\r\n    // create disk instances for large documents\r\n    // (does not work for input streams and directories)\r\n    final long fl = parser.src.length();\r\n    boolean large = false;\r\n    final Runtime rt = Runtime.getRuntime();\r\n    if(fl > rt.freeMemory() / 3) {\r\n      Performance.gc(2);\r\n      large = fl > rt.freeMemory() / 3;\r\n    }\r\n    // in main memory mode, never write to disk\r\n    if(prop.is(Prop.MAINMEM)) large = false;\r\n\r\n    // create random database name for disk-based creation\r\n    final String db = large ? context.mprop.random(data.meta.name) : name;\r\n    build = large ? new DiskBuilder(db, parser, context) : new MemBuilder(db, parser);\r\n\r\n    Data tmp = null;\r\n    try {\r\n      tmp = build.build();\r\n    } catch(final IOException ex) {\r\n      Util.debug(ex);\r\n      return error(Util.message(ex));\r\n\r\n    } finally {\r\n      // close and drop intermediary database instance\r\n      try { build.close(); } catch(final IOException e) { }\r\n      if(tmp != null) tmp.close();\r\n      // drop temporary database instance\r\n      if(large) DropDB.drop(db, context);\r\n    }\r\n\r\n    // skip update if fragment is empty\r\n    if(tmp.meta.size > 1) {\r\n      if(lock && !data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\r\n      data.insert(data.meta.size, -1, tmp);\r\n      context.update();\r\n      if(lock) data.finishUpdate();\r\n    }\r\n    // return info message\r\n    return info(parser.info() + PATH_ADDED_X_X, name, perf);\r\n  }","id":81700,"modified_method":"@Override\r\n  protected boolean run() {\r\n    final boolean create = context.user.has(Perm.CREATE);\r\n    String name = MetaData.normPath(args[0]);\r\n    if(name == null || name.endsWith(\".\")) return error(NAME_INVALID_X, args[0]);\r\n\r\n    // add slash to the target if the addressed file is an archive or directory\r\n    IO io = null;\r\n    if(in == null) {\r\n      io = IO.get(args[1]);\r\n    } else if(in.getSystemId() != null) {\r\n      io = IO.get(in.getSystemId());\r\n    } else if(in.getByteStream() != null) {\r\n      try {\r\n        io = cacheRaw();\r\n      } catch(final IOException ex) {\r\n        return error(Util.message(ex));\r\n      }\r\n    }\r\n\r\n    if(io != null) {\r\n      if(!io.exists()) return error(RES_NOT_FOUND_X, create ? io : args[1]);\r\n      if(!name.endsWith(\"/\") && (io.isDir() || io.isArchive())) name += '/';\r\n    }\r\n\r\n    String target = \"\";\r\n    final int s = name.lastIndexOf('/');\r\n    if(s != -1) {\r\n      target = name.substring(0, s);\r\n      name = name.substring(s + 1);\r\n    }\r\n\r\n    final Data data = context.data();\r\n    final Parser parser;\r\n    if(io != null) {\r\n      // set name of document\r\n      if(!name.isEmpty()) io.name(name);\r\n      // get name from io reference\r\n      else if(!(io instanceof IOContent)) name = io.name();\r\n      parser = new DirParser(io, prop, data.meta.path);\r\n    } else {\r\n      parser = new SAXWrapper(new SAXSource(in), name, context.prop);\r\n    }\r\n    parser.target(target);\r\n\r\n    // ensure that the final name is not empty\r\n    if(name.isEmpty()) return error(NAME_INVALID_X, name);\r\n\r\n    // create disk instances for large documents\r\n    // (does not work for input streams and directories)\r\n    final long fl = parser.src.length();\r\n    boolean large = false;\r\n    final Runtime rt = Runtime.getRuntime();\r\n    if(fl > rt.freeMemory() / 3) {\r\n      Performance.gc(2);\r\n      large = fl > rt.freeMemory() / 3;\r\n    }\r\n    // in main memory mode, never write to disk\r\n    if(prop.is(Prop.MAINMEM)) large = false;\r\n\r\n    // create random database name for disk-based creation\r\n    final String db = large ? context.mprop.random(data.meta.name) : name;\r\n    build = large ? new DiskBuilder(db, parser, context) : new MemBuilder(db, parser);\r\n\r\n    Data tmp = null;\r\n    try {\r\n      tmp = build.build();\r\n    } catch(final IOException ex) {\r\n      Util.debug(ex);\r\n      return error(Util.message(ex));\r\n\r\n    } finally {\r\n      // close and drop intermediary database instance\r\n      try { build.close(); } catch(final IOException e) { }\r\n      if(tmp != null) tmp.close();\r\n      // drop temporary database instance\r\n      if(large) DropDB.drop(db, context);\r\n    }\r\n\r\n    // skip update if fragment is empty\r\n    if(tmp.meta.size > 1) {\r\n      if(lock && !data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\r\n      data.insert(data.meta.size, -1, tmp);\r\n      context.update();\r\n      if(lock) data.finishUpdate();\r\n    }\r\n    // return info message\r\n    return info(parser.info() + PATH_ADDED_X_X, name, perf);\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor.\r\n   * @param args command-line arguments\r\n   * @throws IOException I/O exception\r\n   */\r\n  public BaseX(final String... args) throws IOException {\r\n    super(args);\r\n\r\n    // create session to show optional login request\r\n    session();\r\n\r\n    try {\r\n      // open initial document or database\r\n      for(int i = 0; i < ops.size(); i += 2) {\r\n        final String key = ops.get(i);\r\n        final String val = ops.get(i + 1);\r\n        if(key.equals(\"c\")) {\r\n          // run single command\r\n          execute(val);\r\n        } else if(key.equals(\"C\")) {\r\n          // run commands from script file\r\n          final IO io = IO.get(val);\r\n          if(!io.exists()) throw new BaseXException(RESOURCE_NOT_FOUND_X, val);\r\n          final NewlineInput nli = new NewlineInput(io);\r\n          try {\r\n            for(String line; (line = nli.readLine()) != null;) {\r\n              final String l = line.trim();\r\n              // ignore empty lines and comments\r\n              if(!l.isEmpty() && !l.startsWith(\"#\")) execute(l);\r\n            }\r\n          } finally {\r\n            nli.close();\r\n          }\r\n        } else if(key.equals(\"f\")) {\r\n          // query file\r\n          final IO io = IO.get(val);\r\n          if(!io.exists() || io.isDir())\r\n            throw new BaseXException(RESOURCE_NOT_FOUND_X, val);\r\n          final String query = Token.string(new TextInput(io).content());\r\n          execute(new Set(Prop.QUERYPATH, io.path()), false);\r\n          execute(new XQuery(query), verbose);\r\n        } else if(key.equals(\"i\")) {\r\n          // create main memory database if input is XML snippet\r\n          final boolean mem = IO.get(val) instanceof IOContent;\r\n          execute(new Set(Prop.MAINMEM, mem), false);\r\n          execute(new Check(val), verbose);\r\n          execute(new Set(Prop.MAINMEM, false), false);\r\n        } else if(key.equals(\"q\")) {\r\n          // run query\r\n          execute(new XQuery(val), verbose);\r\n        }\r\n      }\r\n\r\n      if(console) {\r\n        // enter interactive mode\r\n        Util.outln(CONSOLE + TRY_MORE_X, sa() ? LOCALMODE : CLIENTMODE);\r\n        console();\r\n      }\r\n\r\n      if(writeProps) context.mprop.write();\r\n    } finally {\r\n      quit();\r\n    }\r\n  }","id":81701,"modified_method":"/**\r\n   * Constructor.\r\n   * @param args command-line arguments\r\n   * @throws IOException I/O exception\r\n   */\r\n  public BaseX(final String... args) throws IOException {\r\n    super(args);\r\n\r\n    // create session to show optional login request\r\n    session();\r\n\r\n    try {\r\n      // open initial document or database\r\n      for(int i = 0; i < ops.size(); i += 2) {\r\n        final String key = ops.get(i);\r\n        final String val = ops.get(i + 1);\r\n        if(key.equals(\"c\")) {\r\n          // run single command\r\n          execute(val);\r\n        } else if(key.equals(\"C\")) {\r\n          // run commands from script file\r\n          final IO io = IO.get(val);\r\n          if(!io.exists()) throw new BaseXException(RES_NOT_FOUND_X, val);\r\n          final NewlineInput nli = new NewlineInput(io);\r\n          try {\r\n            for(String line; (line = nli.readLine()) != null;) {\r\n              final String l = line.trim();\r\n              // ignore empty lines and comments\r\n              if(!l.isEmpty() && !l.startsWith(\"#\")) execute(l);\r\n            }\r\n          } finally {\r\n            nli.close();\r\n          }\r\n        } else if(key.equals(\"f\")) {\r\n          // query file\r\n          final IO io = IO.get(val);\r\n          if(!io.exists() || io.isDir())\r\n            throw new BaseXException(RES_NOT_FOUND_X, val);\r\n          final String query = Token.string(new TextInput(io).content());\r\n          execute(new Set(Prop.QUERYPATH, io.path()), false);\r\n          execute(new XQuery(query), verbose);\r\n        } else if(key.equals(\"i\")) {\r\n          // create main memory database if input is XML snippet\r\n          final boolean mem = IO.get(val) instanceof IOContent;\r\n          execute(new Set(Prop.MAINMEM, mem), false);\r\n          execute(new Check(val), verbose);\r\n          execute(new Set(Prop.MAINMEM, false), false);\r\n        } else if(key.equals(\"q\")) {\r\n          // run query\r\n          execute(new XQuery(val), verbose);\r\n        }\r\n      }\r\n\r\n      if(console) {\r\n        // enter interactive mode\r\n        Util.outln(CONSOLE + TRY_MORE_X, sa() ? LOCALMODE : CLIENTMODE);\r\n        console();\r\n      }\r\n\r\n      if(writeProps) context.mprop.write();\r\n    } finally {\r\n      quit();\r\n    }\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a new database if a valid path was specified.\n   * @param source document source\n   * @param single expect single document\n   * @param ctx database context\n   * @return data reference\n   * @throws IOException I/O exception\n   */\n  public static synchronized Data create(final IO source, final boolean single,\n      final Context ctx) throws IOException {\n\n    // check if input is an existing file\n    if(!source.exists() || single && source.isDir())\n      throw new BaseXException(RESOURCE_NOT_FOUND_X, source);\n\n    // default: create a main memory instance\n    if(!ctx.prop.is(Prop.FORCECREATE)) return CreateDB.mainMem(source, ctx);\n\n    // otherwise, create a persistent database instance\n    final String nm = source.dbname();\n    final DirParser dp = new DirParser(source, ctx.prop, ctx.mprop.dbpath(nm));\n    return CreateDB.create(nm, dp, ctx);\n  }","id":81702,"modified_method":"/**\n   * Creates a new database if a valid path was specified.\n   * @param source document source\n   * @param single expect single document\n   * @param ctx database context\n   * @return data reference\n   * @throws IOException I/O exception\n   */\n  public static synchronized Data create(final IO source, final boolean single,\n      final Context ctx) throws IOException {\n\n    // check if input is an existing file\n    if(!source.exists() || single && source.isDir())\n      throw new BaseXException(RES_NOT_FOUND_X, source);\n\n    // default: create a main memory instance\n    if(!ctx.prop.is(Prop.FORCECREATE)) return CreateDB.mainMem(source, ctx);\n\n    // otherwise, create a persistent database instance\n    final String nm = source.dbname();\n    final DirParser dp = new DirParser(source, ctx.prop, ctx.mprop.dbpath(nm));\n    return CreateDB.create(nm, dp, ctx);\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    if(!MetaData.validName(name, false)) return error(NAME_INVALID_X, name);\n\n    // choose parser and input\n    IO io = null;\n    final String format = prop.get(Prop.PARSER);\n    if(args.length < 1 || args[1] == null) {\n      if(in != null && in.getByteStream() != null) {\n        try {\n          io = cacheRaw();\n          if(io == null) {\n            InputStream is = in.getByteStream();\n            if(!(is instanceof BufferedInputStream ||\n                is instanceof BufferInput)) is = new BufferedInputStream(is);\n\n            final LookupInput li = new LookupInput(is);\n            if(li.lookup() != -1) {\n              parser = new SAXWrapper(new SAXSource(new InputSource(li)),\n                  name + '.' + format, context.prop);\n            }\n          }\n        } catch(final IOException ex) {\n          Util.debug(ex);\n          return error(Util.message(ex));\n        }\n      }\n    } else {\n      io = IO.get(args[1]);\n    }\n\n    if(io != null) {\n      if(!io.exists()) return error(RESOURCE_NOT_FOUND_X, io);\n      if(io instanceof IOContent) io.name(name + '.' + format);\n      parser = new DirParser(io, prop, mprop.dbpath(name));\n    }\n    if(parser == null) parser = Parser.emptyParser(context.prop);\n\n    // close open database\n    new Close().run(context);\n\n    try {\n      if(prop.is(Prop.MAINMEM)) {\n        // create main memory instance\n        final Data data = progress(new MemBuilder(name, parser)).build();\n        context.openDB(data);\n        context.pin(data);\n      } else {\n        if(context.pinned(name)) return error(DB_PINNED_X, name);\n\n        // create disk-based instance\n        progress(new DiskBuilder(name, parser, context)).build().close();\n        // second step: open database and create index structures\n        final Open open = new Open(name);\n        if(!open.run(context)) return error(open.info());\n        final Data data = context.data();\n        try {\n          if(data.meta.createtext) create(IndexType.TEXT,      data, this);\n          if(data.meta.createattr) create(IndexType.ATTRIBUTE, data, this);\n          if(data.meta.createftxt) create(IndexType.FULLTEXT,  data, this);\n        } finally {\n          data.finishUpdate();\n        }\n        context.databases().add(name);\n      }\n      return info(parser.info() + DB_CREATED_X_X, name, perf);\n    } catch(final ProgressException ex) {\n      throw ex;\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      abort();\n      final String msg = ex.getMessage();\n      return error(msg != null && !msg.isEmpty() ? msg :\n        Util.info(NOT_PARSED_X, parser.src));\n    } catch(final Exception ex) {\n      // known exceptions:\n      // - IllegalArgumentException (UTF8, zip files)\n      Util.debug(ex);\n      abort();\n      return error(Util.info(NOT_PARSED_X, parser.src));\n    }\n  }","id":81703,"modified_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    if(!MetaData.validName(name, false)) return error(NAME_INVALID_X, name);\n\n    // choose parser and input\n    IO io = null;\n    final String format = prop.get(Prop.PARSER);\n    if(args.length < 1 || args[1] == null) {\n      if(in != null && in.getByteStream() != null) {\n        try {\n          io = cacheRaw();\n          if(io == null) {\n            InputStream is = in.getByteStream();\n            if(!(is instanceof BufferedInputStream ||\n                is instanceof BufferInput)) is = new BufferedInputStream(is);\n\n            final LookupInput li = new LookupInput(is);\n            if(li.lookup() != -1) {\n              parser = new SAXWrapper(new SAXSource(new InputSource(li)),\n                  name + '.' + format, context.prop);\n            }\n          }\n        } catch(final IOException ex) {\n          Util.debug(ex);\n          return error(Util.message(ex));\n        }\n      }\n    } else {\n      io = IO.get(args[1]);\n    }\n\n    if(io != null) {\n      if(!io.exists()) return error(RES_NOT_FOUND_X, io);\n      if(io instanceof IOContent) io.name(name + '.' + format);\n      parser = new DirParser(io, prop, mprop.dbpath(name));\n    }\n    if(parser == null) parser = Parser.emptyParser(context.prop);\n\n    // close open database\n    new Close().run(context);\n\n    try {\n      if(prop.is(Prop.MAINMEM)) {\n        // create main memory instance\n        final Data data = progress(new MemBuilder(name, parser)).build();\n        context.openDB(data);\n        context.pin(data);\n      } else {\n        if(context.pinned(name)) return error(DB_PINNED_X, name);\n\n        // create disk-based instance\n        progress(new DiskBuilder(name, parser, context)).build().close();\n        // second step: open database and create index structures\n        final Open open = new Open(name);\n        if(!open.run(context)) return error(open.info());\n        final Data data = context.data();\n        try {\n          if(data.meta.createtext) create(IndexType.TEXT,      data, this);\n          if(data.meta.createattr) create(IndexType.ATTRIBUTE, data, this);\n          if(data.meta.createftxt) create(IndexType.FULLTEXT,  data, this);\n        } finally {\n          data.finishUpdate();\n        }\n        context.databases().add(name);\n      }\n      return info(parser.info() + DB_CREATED_X_X, name, perf);\n    } catch(final ProgressException ex) {\n      throw ex;\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      abort();\n      final String msg = ex.getMessage();\n      return error(msg != null && !msg.isEmpty() ? msg :\n        Util.info(NOT_PARSED_X, parser.src));\n    } catch(final Exception ex) {\n      // known exceptions:\n      // - IllegalArgumentException (UTF8, zip files)\n      Util.debug(ex);\n      abort();\n      return error(Util.info(NOT_PARSED_X, parser.src));\n    }\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a main memory database instance for the specified input reference.\n   * @param source document source\n   * @param ctx database context\n   * @return new database instance\n   * @throws IOException I/O exception\n   */\n  public static synchronized MemData mainMem(final IO source, final Context ctx)\n      throws IOException {\n\n    if(!source.exists()) throw new BaseXException(RESOURCE_NOT_FOUND_X, source);\n    return mainMem(new DirParser(source, ctx.prop, null), ctx);\n  }","id":81704,"modified_method":"/**\n   * Returns a main memory database instance for the specified input reference.\n   * @param source document source\n   * @param ctx database context\n   * @return new database instance\n   * @throws IOException I/O exception\n   */\n  public static synchronized MemData mainMem(final IO source, final Context ctx)\n      throws IOException {\n\n    if(!source.exists()) throw new BaseXException(RES_NOT_FOUND_X, source);\n    return mainMem(new DirParser(source, ctx.prop, null), ctx);\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  protected boolean run() {\r\n    final Data data = context.data();\r\n    final String target = args[0];\r\n\r\n    // start update\r\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\r\n\r\n    // delete all documents in reverse order (faster)\r\n    final IntList docs = data.resources.docs(target);\r\n    for(int d = docs.size() - 1; d >= 0; d--) data.delete(docs.get(d));\r\n    if(!docs.isEmpty()) context.update();\r\n\r\n    // delete binaries\r\n    final TokenList bins = data.resources.binaries(target);\r\n    delete(data, target);\r\n\r\n    // finish update\r\n    data.finishUpdate();\r\n\r\n    // return info message\r\n    return info(DOCS_DELETED_X_X, docs.size() + bins.size(), perf);\r\n  }","id":81705,"modified_method":"@Override\r\n  protected boolean run() {\r\n    final Data data = context.data();\r\n    final String target = args[0];\r\n\r\n    // start update\r\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\r\n\r\n    // delete all documents in reverse order (faster)\r\n    final IntList docs = data.resources.docs(target);\r\n    for(int d = docs.size() - 1; d >= 0; d--) data.delete(docs.get(d));\r\n    if(!docs.isEmpty()) context.update();\r\n\r\n    // delete binaries\r\n    final TokenList bins = data.resources.binaries(target);\r\n    delete(data, target);\r\n\r\n    // finish update\r\n    data.finishUpdate();\r\n\r\n    // return info message\r\n    return info(RES_DELETED_X_X, docs.size() + bins.size(), perf);\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Reacts on user input.\n   * @param comp the action component\n   */\n  void action(final Object comp) {\n    final String src = general.input();\n    final String trg = target.getText().trim();\n\n    if(comp == add) {\n      general.setOptions();\n      final Runnable run = new Runnable() {\n        @Override\n        public void run() {\n          dialog.resources.refreshNewFolder(trg);\n        }\n      };\n      DialogProgress.execute(dialog, \"\", run, new Add(trg, src));\n\n    } else if (comp == optimize) {\n      DialogProgress.execute(dialog, \"\", new Optimize());\n\n    } else {\n      boolean ok = general.action(comp, false);\n      if(comp == general.browse || comp == general.input)\n        target.setText(general.dbname);\n\n      String inf = !ok ? RESOURCE_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\n      final Msg icon = Msg.ERROR;\n      if(ok) {\n        // check if target path is valid\n        ok = MetaData.normPath(trg) != null;\n        if(!ok) inf = Util.info(INVALID_X, TARGET_PATH);\n      }\n      general.info.setText(inf, icon);\n      add.setEnabled(ok);\n      optimize.setEnabled(!dialog.gui.context.data().meta.uptodate);\n    }\n  }","id":81706,"modified_method":"/**\n   * Reacts on user input.\n   * @param comp the action component\n   */\n  void action(final Object comp) {\n    final String src = general.input();\n    final String trg = target.getText().trim();\n\n    if(comp == add) {\n      general.setOptions();\n      final Runnable run = new Runnable() {\n        @Override\n        public void run() {\n          dialog.resources.refreshNewFolder(trg);\n        }\n      };\n      DialogProgress.execute(dialog, \"\", run, new Add(trg, src));\n\n    } else if (comp == optimize) {\n      DialogProgress.execute(dialog, \"\", new Optimize());\n\n    } else {\n      boolean ok = general.action(comp, false);\n      if(comp == general.browse || comp == general.input)\n        target.setText(general.dbname);\n\n      String inf = !ok ? RES_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\n      final Msg icon = Msg.ERROR;\n      if(ok) {\n        // check if target path is valid\n        ok = MetaData.normPath(trg) != null;\n        if(!ok) inf = Util.info(INVALID_X, TARGET_PATH);\n      }\n      general.info.setText(inf, icon);\n      add.setEnabled(ok);\n      optimize.setEnabled(!dialog.gui.context.data().meta.uptodate);\n    }\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void action(final Object comp) {\r\n    final boolean valid = general.action(comp, true);\r\n    ft.action(ftxindex.isSelected());\r\n\r\n    // ...must be located before remaining checks\r\n    if(comp == general.browse || comp == general.input) target.setText(general.dbname);\r\n\r\n    final String nm = target.getText().trim();\r\n    ok = valid && !nm.isEmpty();\r\n\r\n    String inf = !valid ? RESOURCE_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\r\n    Msg icon = Msg.ERROR;\r\n    if(ok) {\r\n      ok = MetaData.validName(nm, false);\r\n      if(ok) gui.gprop.set(GUIProp.CREATENAME, nm);\r\n\r\n      if(!ok) {\r\n        // name of database is invalid\r\n        inf = Util.info(INVALID_X, NAME);\r\n      } else if(general.input.getText().trim().isEmpty()) {\r\n        // database will be empty\r\n        inf = EMPTY_DB;\r\n        icon = Msg.WARN;\r\n      } else if(db.contains(nm)) {\r\n        // old database will be overwritten\r\n        inf = OVERWRITE_DB;\r\n        icon = Msg.WARN;\r\n      }\r\n    }\r\n\r\n    general.info.setText(inf, icon);\r\n    enableOK(buttons, B_OK, ok);\r\n  }","id":81707,"modified_method":"@Override\r\n  public void action(final Object comp) {\r\n    final boolean valid = general.action(comp, true);\r\n    ft.action(ftxindex.isSelected());\r\n\r\n    // ...must be located before remaining checks\r\n    if(comp == general.browse || comp == general.input) target.setText(general.dbname);\r\n\r\n    final String nm = target.getText().trim();\r\n    ok = valid && !nm.isEmpty();\r\n\r\n    String inf = !valid ? RES_NOT_FOUND : !ok ? ENTER_DB_NAME : null;\r\n    Msg icon = Msg.ERROR;\r\n    if(ok) {\r\n      ok = MetaData.validName(nm, false);\r\n      if(ok) gui.gprop.set(GUIProp.CREATENAME, nm);\r\n\r\n      if(!ok) {\r\n        // name of database is invalid\r\n        inf = Util.info(INVALID_X, NAME);\r\n      } else if(general.input.getText().trim().isEmpty()) {\r\n        // database will be empty\r\n        inf = EMPTY_DB;\r\n        icon = Msg.WARN;\r\n      } else if(db.contains(nm)) {\r\n        // old database will be overwritten\r\n        inf = OVERWRITE_DB;\r\n        icon = Msg.WARN;\r\n      }\r\n    }\r\n\r\n    general.info.setText(inf, icon);\r\n    enableOK(buttons, B_OK, ok);\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a database information string.\n   * @param meta meta data\n   * @param bold header bold header flag\n   * @param index add index information\n   * @param create create permissions\n   * @return info string\n   */\n  public static String db(final MetaData meta, final boolean bold,\n      final boolean index, final boolean create) {\n\n    final TokenBuilder tb = new TokenBuilder();\n    final String header = (bold ?\n        new TokenBuilder().bold().add('%').norm().toString() : \"%\") + NL;\n    tb.addExt(header, DB_PROPS);\n    format(tb, NAME, meta.name);\n    format(tb, SIZE, Performance.format(meta.dbsize()));\n    format(tb, NODES, Integer.toString(meta.size));\n\n    // count number of raw files\n    format(tb, DOCUMENTS, Integer.toString(meta.ndocs));\n    final int b = meta.path != null ? meta.binaries().descendants().size() : 0;\n    format(tb, BINARIES, Integer.toString(b));\n    format(tb, TIMESTAMP, formatDate(new Date(meta.dbtime()), DATE));\n    if(meta.corrupt) tb.add(' ' + DB_CORRUPT + NL);\n\n    tb.add(NL).addExt(header, RESOURCE_PROPS);\n    if(create && !meta.original.isEmpty()) format(tb, INPUT_PATH, meta.original);\n    if(meta.filesize != 0) format(tb, INPUT_SIZE, Performance.format(meta.filesize));\n    format(tb, TIMESTAMP, formatDate(new Date(meta.time), DATE));\n    format(tb, ENCODING, meta.encoding);\n    format(tb, WS_CHOPPING, Util.flag(meta.chop));\n\n    if(index) {\n      tb.add(NL).addExt(header, INDEXES);\n      if(meta.oldindex()) {\n        tb.add(' ' + H_INDEX_FORMAT + NL);\n      } else {\n        format(tb, UP_TO_DATE, String.valueOf(meta.uptodate));\n        format(tb, TEXT_INDEX, Util.flag(meta.textindex));\n        format(tb, ATTRIBUTE_INDEX, Util.flag(meta.attrindex));\n        format(tb, FULLTEXT_INDEX, Util.flag(meta.ftxtindex));\n      }\n    }\n    return tb.toString();\n  }","id":81708,"modified_method":"/**\n   * Creates a database information string.\n   * @param meta meta data\n   * @param bold header bold header flag\n   * @param index add index information\n   * @param create create permissions\n   * @return info string\n   */\n  public static String db(final MetaData meta, final boolean bold,\n      final boolean index, final boolean create) {\n\n    final TokenBuilder tb = new TokenBuilder();\n    final String header = (bold ?\n        new TokenBuilder().bold().add('%').norm().toString() : \"%\") + NL;\n    tb.addExt(header, DB_PROPS);\n    format(tb, NAME, meta.name);\n    format(tb, SIZE, Performance.format(meta.dbsize()));\n    format(tb, NODES, Integer.toString(meta.size));\n\n    // count number of raw files\n    format(tb, DOCUMENTS, Integer.toString(meta.ndocs));\n    final int b = meta.path != null ? meta.binaries().descendants().size() : 0;\n    format(tb, BINARIES, Integer.toString(b));\n    format(tb, TIMESTAMP, formatDate(new Date(meta.dbtime()), DATE));\n    if(meta.corrupt) tb.add(' ' + DB_CORRUPT + NL);\n\n    tb.add(NL).addExt(header, RES_PROPS);\n    if(create && !meta.original.isEmpty()) format(tb, INPUT_PATH, meta.original);\n    if(meta.filesize != 0) format(tb, INPUT_SIZE, Performance.format(meta.filesize));\n    format(tb, TIMESTAMP, formatDate(new Date(meta.time), DATE));\n    format(tb, ENCODING, meta.encoding);\n    format(tb, WS_CHOPPING, Util.flag(meta.chop));\n\n    if(index) {\n      tb.add(NL).addExt(header, INDEXES);\n      if(meta.oldindex()) {\n        tb.add(' ' + H_INDEX_FORMAT + NL);\n      } else {\n        format(tb, UP_TO_DATE, String.valueOf(meta.uptodate));\n        format(tb, TEXT_INDEX, Util.flag(meta.textindex));\n        format(tb, ATTRIBUTE_INDEX, Util.flag(meta.attrindex));\n        format(tb, FULLTEXT_INDEX, Util.flag(meta.ftxtindex));\n      }\n    }\n    return tb.toString();\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Reads the specified language file.\r\n   * @param lang language\r\n   * @param chk check flag\r\n   */\r\n  private static synchronized void read(final String lang, final boolean chk) {\r\n    BufferedReader br = null;\r\n    try {\r\n      if(DISALLOW) throw new Error(\"Language file was accessed.\");\r\n      if(chk) check = new HashMap<String, Boolean>();\r\n\r\n      final String path = '/' + SUFFIX + '/' + lang + '.' + SUFFIX;\r\n      final InputStream is = Lang.class.getResourceAsStream(path);\r\n      if(is == null) {\r\n        Util.errln(path + \" not found.\");\r\n      } else {\r\n        br = new BufferedReader(new InputStreamReader(is, Token.UTF8));\r\n        for(String line; (line = br.readLine()) != null;) {\r\n          final int i = line.indexOf('=');\r\n          if(i == -1 || line.startsWith(\"#\")) continue;\r\n          final String key = line.substring(0, i).trim();\r\n          String val = line.substring(i + 1).trim();\r\n          if(val.contains(\"\\\\n\")) val = val.replaceAll(\"\\\\\\\\n\", Prop.NL);\r\n          if(Prop.langkeys) val = '[' + key + COLS + val + ']';\r\n          if(TETXTS.get(key) == null) {\r\n            TETXTS.put(key, val);\r\n          } else if(chk) {\r\n            Util.errln(\"%.\" + SUFFIX + \": '%' assigned twice\", lang, key);\r\n          }\r\n          if(chk) check.put(key, true);\r\n        }\r\n      }\r\n    } catch(final IOException ex) {\r\n      Util.errln(ex);\r\n    } finally {\r\n      if(br != null) try { br.close(); } catch(final IOException ex) { }\r\n    }\r\n  }","id":81709,"modified_method":"/**\r\n   * Reads the specified language file.\r\n   * @param lang language\r\n   */\r\n  private static synchronized void read(final String lang) {\r\n    TEXTS.clear();\r\n    CHECK.clear();\r\n    final String path = '/' + SUFFIX + '/' + lang + '.' + SUFFIX;\r\n    final InputStream is = Lang.class.getResourceAsStream(path);\r\n    if(is == null) {\r\n      Util.errln(path + \" not found.\");\r\n    } else {\r\n      BufferedReader br = null;\r\n      try {\r\n        br = new BufferedReader(new InputStreamReader(is, Token.UTF8));\r\n        for(String line; (line = br.readLine()) != null;) {\r\n          final int i = line.indexOf('=');\r\n          if(i == -1 || line.startsWith(\"#\")) continue;\r\n          final String key = line.substring(0, i).trim();\r\n          String val = line.substring(i + 1).trim();\r\n          if(val.contains(\"\\\\n\")) val = val.replaceAll(\"\\\\\\\\n\", Prop.NL);\r\n          if(Prop.langkeys) val = '[' + key + \": \" + val + ']';\r\n          if(TEXTS.put(key, val) != null) {\r\n            Util.errln(\"%.\" + SUFFIX + \": '%' found twice in language file\", lang, key);\r\n            Util.stack(10);\r\n            System.exit(0);\r\n          }\r\n          CHECK.put(key, true);\r\n        }\r\n      } catch(final IOException ex) {\r\n        Util.errln(ex);\r\n      } finally {\r\n        if(br != null) try { br.close(); } catch(final IOException ex) { }\r\n      }\r\n    }\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the specified string.\r\n   * @param key key\r\n   * @return string\r\n   */\r\n  static synchronized String lang(final String key) {\r\n    if(key == null) {\r\n      if(CHECK && !check.isEmpty()) {\r\n        for(final String s : check.keySet())\r\n          Util.errln(\"%.\" + SUFFIX + \": '%' not used\", Prop.language, s);\r\n      }\r\n      return null;\r\n    }\r\n\r\n    final String val = TETXTS.get(key);\r\n    if(val == null) {\r\n      if(!TETXTS.isEmpty())\r\n        Util.errln(\"%.\" + SUFFIX + \": '%' missing\", Prop.language, key);\r\n      return '[' + key + ']';\r\n    }\r\n    if(CHECK) check.remove(key);\r\n    return val;\r\n  }","id":81710,"modified_method":"/**\r\n   * Returns the specified string.\r\n   * @param key key\r\n   * @return string\r\n   */\r\n  static synchronized String lang(final String key) {\r\n    if(key == null) {\r\n      for(final String s : CHECK.keySet()) {\r\n        Util.errln(\"%.\" + SUFFIX + \": '%' not defined in Text class\", Prop.language, s);\r\n        Util.stack(10);\r\n        System.exit(0);\r\n      }\r\n      return null;\r\n    }\r\n\r\n    final String val = TEXTS.get(key);\r\n    if(val == null) {\r\n      Util.errln(\"%.\" + SUFFIX + \": '%' missing in Text class\", Prop.language, key);\r\n      Util.stack(10);\r\n      System.exit(0);\r\n      return '[' + key + ']';\r\n    }\r\n    CHECK.remove(key);\r\n    return val;\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() {\n    final Data data = context.data();\n    final String src = MetaData.normPath(args[0]);\n    if(src == null) return error(NAME_INVALID_X, args[0]);\n    final String trg = MetaData.normPath(args[1]);\n    if(trg == null) return error(NAME_INVALID_X, args[1]);\n\n    // start update\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\n\n    boolean ok = true;\n    int c = 0;\n    final IntList docs = data.resources.docs(src);\n    for(int i = 0, ds = docs.size(); i < ds; i++) {\n      final int pre = docs.get(i);\n      final String target = target(data, pre, src, trg);\n      if(target.isEmpty()) {\n        ok = !info(NAME_INVALID_X, target);\n      } else {\n        data.update(pre, Data.DOC, token(target));\n        c++;\n      }\n    }\n\n    final IOFile file = data.meta.binary(src);\n    if(file != null && file.exists()) {\n      final IOFile target = data.meta.binary(trg);\n      final IOFile trgdir = new IOFile(target.dir());\n      if(!trgdir.exists() && !trgdir.md() || !file.rename(target)) {\n        ok = !info(NAME_INVALID_X, trg);\n      }\n      c++;\n    }\n    // finish update\n    data.finishUpdate();\n\n    // return info message\n    return info(DOCS_RENAMED_X_X, c, perf) && ok;\n  }","id":81711,"modified_method":"@Override\n  protected boolean run() {\n    final Data data = context.data();\n    final String src = MetaData.normPath(args[0]);\n    if(src == null) return error(NAME_INVALID_X, args[0]);\n    final String trg = MetaData.normPath(args[1]);\n    if(trg == null) return error(NAME_INVALID_X, args[1]);\n\n    // start update\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\n\n    boolean ok = true;\n    int c = 0;\n    final IntList docs = data.resources.docs(src);\n    for(int i = 0, ds = docs.size(); i < ds; i++) {\n      final int pre = docs.get(i);\n      final String target = target(data, pre, src, trg);\n      if(target.isEmpty()) {\n        ok = !info(NAME_INVALID_X, target);\n      } else {\n        data.update(pre, Data.DOC, token(target));\n        c++;\n      }\n    }\n\n    final IOFile file = data.meta.binary(src);\n    if(file != null && file.exists()) {\n      final IOFile target = data.meta.binary(trg);\n      final IOFile trgdir = new IOFile(target.dir());\n      if(!trgdir.exists() && !trgdir.md() || !file.rename(target)) {\n        ok = !info(NAME_INVALID_X, trg);\n      }\n      c++;\n    }\n    // finish update\n    data.finishUpdate();\n\n    // return info message\n    return info(RES_RENAMED_X_X, c, perf) && ok;\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() {\n    // check if the input source has already been initialized\n    if(in == null) {\n      final IO io = IO.get(args[1]);\n      if(!io.exists()) return error(RESOURCE_NOT_FOUND_X, io);\n      in = io.inputSource();\n    }\n\n    final String path = MetaData.normPath(args[0]);\n    if(path == null || path.isEmpty()) return error(NO_DIR_ALLOWED_X, args[0]);\n\n    final Data data = context.data();\n    final int pre = data.resources.doc(path, false);\n    // check if path points to a single file\n    if(pre != -1 && data.resources.docs(path).size() != 1)\n      return error(NO_DIR_ALLOWED_X, path);\n\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\n    try {\n      boolean ok = true;\n      final IOFile file = data.meta.binary(path);\n      if(file != null && file.exists()) {\n        // replace binary file if it already exists\n        final Store store = new Store(path);\n        store.setInput(in);\n        ok = store.run(context) || error(store.info());\n      } else {\n        // otherwise, add new document as xml\n        final Add add = new Add(path);\n        add.setInput(in);\n        add.lock = false;\n        ok = add.run(context) || error(add.info());\n        // delete old documents if addition was successful\n        if(ok && pre != -1) data.delete(pre);\n      }\n      return ok && info(DOCS_REPLACED_X_X, 1, perf);\n    } finally {\n      data.finishUpdate();\n    }\n  }","id":81712,"modified_method":"@Override\n  protected boolean run() {\n    // check if the input source has already been initialized\n    if(in == null) {\n      final IO io = IO.get(args[1]);\n      if(!io.exists()) return error(RES_NOT_FOUND_X, io);\n      in = io.inputSource();\n    }\n\n    final String path = MetaData.normPath(args[0]);\n    if(path == null || path.isEmpty()) return error(NO_DIR_ALLOWED_X, args[0]);\n\n    final Data data = context.data();\n    final int pre = data.resources.doc(path, false);\n    // check if path points to a single file\n    if(pre != -1 && data.resources.docs(path).size() != 1)\n      return error(NO_DIR_ALLOWED_X, path);\n\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\n    try {\n      boolean ok = true;\n      final IOFile file = data.meta.binary(path);\n      if(file != null && file.exists()) {\n        // replace binary file if it already exists\n        final Store store = new Store(path);\n        store.setInput(in);\n        ok = store.run(context) || error(store.info());\n      } else {\n        // otherwise, add new document as xml\n        final Add add = new Add(path);\n        add.setInput(in);\n        add.lock = false;\n        ok = add.run(context) || error(add.info());\n        // delete old documents if addition was successful\n        if(ok && pre != -1) data.delete(pre);\n      }\n      return ok && info(RES_REPLACED_X_X, 1, perf);\n    } finally {\n      data.finishUpdate();\n    }\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() throws IOException {\n    final String path = MetaData.normPath(args[0]);\n    if(path == null) return error(NAME_INVALID_X, args[0]);\n\n    final IOFile bin = context.data().meta.binary(path);\n    if(bin == null || !bin.exists() || bin.isDir())\n      return error(RESOURCE_NOT_FOUND_X, path);\n\n    try {\n      final BufferInput bi = new BufferInput(bin);\n      try {\n        for(int b; (b = bi.read()) != -1;) out.write(b);\n      } finally {\n        bi.close();\n      }\n      return info(QUERY_EXECUTED_X, perf);\n    } catch(final IOException ex) {\n      return error(FILE_NOT_STORED_X, ex.getMessage());\n    }\n  }","id":81713,"modified_method":"@Override\n  protected boolean run() throws IOException {\n    final String path = MetaData.normPath(args[0]);\n    if(path == null) return error(NAME_INVALID_X, args[0]);\n\n    final IOFile bin = context.data().meta.binary(path);\n    if(bin == null || !bin.exists() || bin.isDir())\n      return error(RES_NOT_FOUND_X, path);\n\n    try {\n      final BufferInput bi = new BufferInput(bin);\n      try {\n        for(int b; (b = bi.read()) != -1;) out.write(b);\n      } finally {\n        bi.close();\n      }\n      return info(QUERY_EXECUTED_X, perf);\n    } catch(final IOException ex) {\n      return error(FILE_NOT_STORED_X, ex.getMessage());\n    }\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the query string.\r\n   * @param ctx database context\r\n   * @return query string\r\n   * @throws IOException I/O exception\r\n   */\r\n  String read(final Context ctx) throws IOException {\r\n    if(query == null) {\r\n      final IO io = IO.get(args[0]);\r\n      if(!io.exists() || io.isDir()) throw new BaseXException(\r\n          RESOURCE_NOT_FOUND_X, ctx.user.has(Perm.CREATE) ? io : args[0]);\r\n      query = Token.string(io.read());\r\n      ctx.prop.set(Prop.QUERYPATH, io.path());\r\n    }\r\n    return query;\r\n  }","id":81714,"modified_method":"/**\r\n   * Returns the query string.\r\n   * @param ctx database context\r\n   * @return query string\r\n   * @throws IOException I/O exception\r\n   */\r\n  String read(final Context ctx) throws IOException {\r\n    if(query == null) {\r\n      final IO io = IO.get(args[0]);\r\n      if(!io.exists() || io.isDir()) throw new BaseXException(\r\n          RES_NOT_FOUND_X, ctx.user.has(Perm.CREATE) ? io : args[0]);\r\n      query = Token.string(io.read());\r\n      ctx.prop.set(Prop.QUERYPATH, io.path());\r\n    }\r\n    return query;\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() {\n    final boolean create = context.user.has(Perm.CREATE);\n    String path = MetaData.normPath(args[0]);\n    if(path == null || path.endsWith(\".\")) return error(NAME_INVALID_X, args[0]);\n\n    if(in == null) {\n      final IO io = IO.get(args[1]);\n      if(!io.exists() || io.isDir())\n        return error(RESOURCE_NOT_FOUND_X, create ? io : args[1]);\n      in = io.inputSource();\n      // set/add name of document\n      if((path.isEmpty() || path.endsWith(\"/\")) && !(io instanceof IOContent))\n        path += io.name();\n    }\n\n    // ensure that the final name is not empty\n    if(path.isEmpty()) return error(NAME_INVALID_X, path);\n\n    // ensure that the name is not empty and contains no trailing dots\n    final Data data = context.data();\n    if(data.inMemory()) return error(NO_MAINMEM);\n\n    final IOFile file = data.meta.binary(path);\n    if(path.isEmpty() || path.endsWith(\".\") || file == null || file.isDir())\n      return error(NAME_INVALID_X, create ? path : args[0]);\n\n    // start update\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\n\n    try {\n      store(in, file);\n      return info(QUERY_EXECUTED_X, perf);\n    } catch(final IOException ex) {\n      return error(FILE_NOT_STORED_X, ex.getMessage());\n    } finally {\n      data.finishUpdate();\n    }\n  }","id":81715,"modified_method":"@Override\n  protected boolean run() {\n    final boolean create = context.user.has(Perm.CREATE);\n    String path = MetaData.normPath(args[0]);\n    if(path == null || path.endsWith(\".\")) return error(NAME_INVALID_X, args[0]);\n\n    if(in == null) {\n      final IO io = IO.get(args[1]);\n      if(!io.exists() || io.isDir())\n        return error(RES_NOT_FOUND_X, create ? io : args[1]);\n      in = io.inputSource();\n      // set/add name of document\n      if((path.isEmpty() || path.endsWith(\"/\")) && !(io instanceof IOContent))\n        path += io.name();\n    }\n\n    // ensure that the final name is not empty\n    if(path.isEmpty()) return error(NAME_INVALID_X, path);\n\n    // ensure that the name is not empty and contains no trailing dots\n    final Data data = context.data();\n    if(data.inMemory()) return error(NO_MAINMEM);\n\n    final IOFile file = data.meta.binary(path);\n    if(path.isEmpty() || path.endsWith(\".\") || file == null || file.isDir())\n      return error(NAME_INVALID_X, create ? path : args[0]);\n\n    // start update\n    if(!data.startUpdate()) return error(DB_PINNED_X, data.meta.name);\n\n    try {\n      store(in, file);\n      return info(QUERY_EXECUTED_X, perf);\n    } catch(final IOException ex) {\n      return error(FILE_NOT_STORED_X, ex.getMessage());\n    } finally {\n      data.finishUpdate();\n    }\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a better understandable error message for the specified exception.\r\n   * @param ex throwable reference\r\n   * @return error message\r\n   */\r\n  public static String message(final Throwable ex) {\r\n    final String msg = ex.getMessage();\r\n    if(ex instanceof BindException) return SRV_RUNNING;\r\n    else if(ex instanceof FileNotFoundException) return info(RESOURCE_NOT_FOUND_X, msg);\r\n    else if(ex instanceof LoginException) return ACCESS_DENIED;\r\n    else if(ex instanceof ConnectException) return CONNECTION_ERROR;\r\n    else if(ex instanceof SocketTimeoutException) return TIMEOUT_EXCEEDED;\r\n    else if(ex instanceof SocketException) return CONNECTION_ERROR;\r\n    else if(ex instanceof UnknownHostException) return info(UNKNOWN_HOST_X, msg);\r\n    return msg != null && !msg.isEmpty() ? msg : ex.toString();\r\n  }","id":81716,"modified_method":"/**\r\n   * Returns a better understandable error message for the specified exception.\r\n   * @param ex throwable reference\r\n   * @return error message\r\n   */\r\n  public static String message(final Throwable ex) {\r\n    final String msg = ex.getMessage();\r\n    if(ex instanceof BindException) return SRV_RUNNING;\r\n    else if(ex instanceof FileNotFoundException) return info(RES_NOT_FOUND_X, msg);\r\n    else if(ex instanceof LoginException) return ACCESS_DENIED;\r\n    else if(ex instanceof ConnectException) return CONNECTION_ERROR;\r\n    else if(ex instanceof SocketTimeoutException) return TIMEOUT_EXCEEDED;\r\n    else if(ex instanceof SocketException) return CONNECTION_ERROR;\r\n    else if(ex instanceof UnknownHostException) return info(UNKNOWN_HOST_X, msg);\r\n    return msg != null && !msg.isEmpty() ? msg : ex.toString();\r\n  }","commit_id":"4499be3b96f5a5cac9f321cd689c794d60f14fe6","url":"https://github.com/BaseXdb/basex"},{"original_method":"public static PutMappingRequest getPutMappingRequest(final Client client, final String index, final String analyzer) {\n        final PutMappingRequestBuilder builder = client.admin().indices().preparePutMapping(new String[] {index});\n        builder.setType(Messages.TYPE);\n\n        final Map<String, Object> mapping = new HashMap<String, Object>();\n        mapping.put(\"properties\", partFieldProperties(analyzer));\n        mapping.put(\"dynamic_templates\", partDefaultAllInDynamicTemplate());\n        mapping.put(\"_source\", enabledAndCompressed()); // Compress source field..\n        mapping.put(\"_ttl\", enabled()); // Enable purging by TTL.\n\n        // TODO: use multimap?\n        final Map<String, Map<String, Object>> completeMapping = Maps.newHashMap();\n        completeMapping.put(Messages.TYPE, mapping);\n\n        builder.setSource(completeMapping);\n        return builder.request();\n    }","id":81717,"modified_method":"public static PutMappingRequest getPutMappingRequest(final Client client, final String index, final String analyzer) {\n        final PutMappingRequestBuilder builder = client.admin().indices().preparePutMapping(index);\n        builder.setType(Messages.TYPE);\n\n        final Map<String, Object> mapping = ImmutableMap.of(\n                \"properties\", partFieldProperties(analyzer),\n                \"dynamic_templates\", partDefaultAllInDynamicTemplate(),\n                // Compress source field\n                \"_source\", enabledAndCompressed(),\n                // Enable purging by TTL\n                \"_ttl\", enabled());\n\n        final Map<String, Map<String, Object>> completeMapping = ImmutableMap.of(Messages.TYPE, mapping);\n\n        builder.setSource(completeMapping);\n        return builder.request();\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private static Map<String, Boolean> enabledAndCompressed() {\n        final Map<String, Boolean> e = Maps.newHashMap();\n        e.put(\"enabled\", true);\n        e.put(\"compress\", true);\n\n        return e;\n    }","id":81718,"modified_method":"private static Map<String, Boolean> enabledAndCompressed() {\n        return ImmutableMap.of(\n                \"enabled\", true,\n                \"compress\", true);\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@SuppressWarnings(\"rawtypes\")\n\tprivate static Map partFieldProperties(String analyzer) {\n        final Map<String, Map<?, ?>> properties = Maps.newHashMap();\n\n        properties.put(\"message\", analyzedString(analyzer));\n        properties.put(\"full_message\", analyzedString(analyzer));\n\n        // http://joda-time.sourceforge.net/api-release/org/joda/time/format/DateTimeFormat.html\n        // http://www.elasticsearch.org/guide/reference/mapping/date-format.html\n        properties.put(\"timestamp\", typeTimeWithMillis());\n\n        // to support wildcard searches in source we need to lowercase the content (wildcard search lowercases search term)\n        properties.put(\"source\", analyzedString(\"analyzer_keyword\"));\n\n        return properties;\n    }","id":81719,"modified_method":"private static Map<String, Map<String, ? extends Serializable>> partFieldProperties(String analyzer) {\n        return ImmutableMap.of(\n                \"message\", analyzedString(analyzer),\n                \"full_message\", analyzedString(analyzer),\n                // http://joda-time.sourceforge.net/api-release/org/joda/time/format/DateTimeFormat.html\n                // http://www.elasticsearch.org/guide/reference/mapping/date-format.html\n                \"timestamp\", typeTimeWithMillis(),\n                // to support wildcard searches in source we need to lowercase the content (wildcard search lowercases search term)\n                \"source\", analyzedString(\"analyzer_keyword\"));\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private static Map<String, Boolean> enabled() {\n        final Map<String, Boolean> e = Maps.newHashMap();\n        e.put(\"enabled\", true);\n\n        return e;\n    }","id":81720,"modified_method":"private static Map<String, Boolean> enabled() {\n        return ImmutableMap.of(\"enabled\", true);\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private static Map<String, String> analyzedString(String analyzer) {\n        final Map<String, String> type = Maps.newHashMap();\n        type.put(\"index\", \"analyzed\");\n        type.put(\"type\", \"string\");\n        type.put(\"analyzer\", analyzer);\n\n        return type;\n    }","id":81721,"modified_method":"private static Map<String, String> analyzedString(String analyzer) {\n        return ImmutableMap.of(\n                \"index\", \"analyzed\",\n                \"type\", \"string\",\n                \"analyzer\", analyzer);\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@SuppressWarnings(\"rawtypes\")\n\tprivate static List partDefaultAllInDynamicTemplate() {\n        final List dynamicTemplates = new LinkedList();\n        final Map template = new HashMap();\n        final Map defaultAll = new HashMap();\n        final Map notAnalyzed = new HashMap();\n        notAnalyzed.put(\"index\", \"not_analyzed\");\n\n        // Match all.\n        defaultAll.put(\"match\", \"*\");\n        // Analyze nothing by default.\n        defaultAll.put(\"mapping\", notAnalyzed);\n\n        template.put(\"store_generic\", defaultAll);\n        dynamicTemplates.add(template);\n\n        return dynamicTemplates;\n    }","id":81722,"modified_method":"private static List<Map<String, Map<String, Object>>> partDefaultAllInDynamicTemplate() {\n        final Map<String, String> notAnalyzed = ImmutableMap.of(\"index\", \"not_analyzed\");\n        final Map<String, Object> defaultAll = ImmutableMap.of(\n                // Match all\n                \"match\", \"*\",\n                // Analyze nothing by default\n                \"mapping\", notAnalyzed);\n        final Map<String, Map<String, Object>> template = ImmutableMap.of(\"store_generic\", defaultAll);\n\n        return ImmutableList.of(template);\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private static Map<String, Serializable> typeTimeWithMillis() {\n        final Map<String, Serializable> type = Maps.newHashMap();\n        type.put(\"type\", \"date\");\n        type.put(\"format\", Tools.ES_DATE_FORMAT);\n        type.put(\"doc_values\", true);\n\n        return type;\n    }","id":81723,"modified_method":"private static Map<String, Serializable> typeTimeWithMillis() {\n        return ImmutableMap.<String, Serializable>of(\n                \"type\", \"date\",\n                \"format\", Tools.ES_DATE_FORMAT,\n                \"doc_values\", true);\n    }","commit_id":"e35075010d50c81c6535d17e1a0e1425bbfe8886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Nullable\n  public String getPlaceholderText() {\n    if (myText == null) {\n      final FoldingBuilder builder = getFoldingBuilder();\n      return builder == null ? null : builder.getPlaceholderText(myElement);\n    } else {\n      return myText;\n    }\n  }","id":81724,"modified_method":"@Nullable\n  public String getPlaceholderText() {\n    final PsiElement psiElement = myElement.getPsi();\n    if (psiElement == null) return null;\n\n    final Language lang = psiElement.getLanguage();\n    final FoldingBuilder foldingBuilder = LanguageFolding.INSTANCE.forLanguage(lang);\n    if (foldingBuilder != null) {\n      return foldingBuilder.getPlaceholderText(myElement);\n    }\n    return null;\n  }","commit_id":"1adeb1a455cbf98e730a497c1742678bd5dd1d2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the text which is displayed in the editor for the folding region related to the\n   * specified node when the folding region is collapsed.\n   *\n   * @param node the node for which the placeholder text is requested.\n   * @return the placeholder text.\n   */\n  @Nullable\n  public abstract String getPlaceholderText(@NotNull ASTNode node);","id":81725,"modified_method":"/**\n   * Returns the text which is displayed in the editor for the folding region related to the\n   * specified node when the folding region is collapsed.\n   *\n   *\n   * @param node the node for which the placeholder text is requested.\n   * @param range text range within whole file to fold\n   * @return the placeholder text.\n   */\n  @Nullable\n  public String getPlaceholderText(@NotNull ASTNode node, @NotNull TextRange range){\n    return getPlaceholderText(node);\n  }","commit_id":"d5d730b5da609837f0989aa0bf2e1c793c7dbfbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getPlaceholderText() {\n    final PsiElement psiElement = myElement.getPsi();\n    if (psiElement == null) return null;\n\n    final Language lang = psiElement.getLanguage();\n    final FoldingBuilder foldingBuilder = LanguageFolding.INSTANCE.forLanguage(lang);\n    if (foldingBuilder != null) {\n      return foldingBuilder.getPlaceholderText(myElement);\n    }\n    return null;\n  }","id":81726,"modified_method":"@Nullable\n  public String getPlaceholderText() {\n    final PsiElement psiElement = myElement.getPsi();\n    if (psiElement == null) return null;\n\n    final Language lang = psiElement.getLanguage();\n    final FoldingBuilder foldingBuilder = LanguageFolding.INSTANCE.forLanguage(lang);\n    if (foldingBuilder != null) {\n      return foldingBuilder instanceof FoldingBuilderEx\n             ? ((FoldingBuilderEx)foldingBuilder).getPlaceholderText(myElement, myRange)\n             : foldingBuilder.getPlaceholderText(myElement);\n    }\n    return null;\n  }","commit_id":"d5d730b5da609837f0989aa0bf2e1c793c7dbfbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getPlaceholderText() {\n    final PsiElement psiElement = myElement.getPsi();\n    if (psiElement == null) return null;\n\n    final Language lang = psiElement.getLanguage();\n    final FoldingBuilder foldingBuilder = LanguageFolding.INSTANCE.forLanguage(lang);\n    if (foldingBuilder != null) {\n      return foldingBuilder.getPlaceholderText(myElement);\n    }\n    return null;\n  }","id":81727,"modified_method":"@Nullable\n  public String getPlaceholderText() {\n    if (myText == null) {\n      final FoldingBuilder builder = getFoldingBuilder();\n      return builder == null ? null : builder.getPlaceholderText(myElement);\n    } else {\n      return myText;\n    }\n  }","commit_id":"7c662d21c7defa7d1dbcbfac0fed3de12762eb0b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Basic test using Index & Realtime Get with external versioning. This test ensures routing works correctly across versions.\n     */\n    @Test\n    public void testExternalVersion() throws Exception {\n        createIndex(\"test\");\n        final boolean routing = randomBoolean();\n        int numDocs = randomIntBetween(10, 20);\n        for (int i = 0; i < numDocs; i++) {\n            String id = Integer.toString(i);\n            String routingKey = routing ? randomRealisticUnicodeOfLength(10) : null;\n            client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setVersion(1).setVersionType(VersionType.EXTERNAL).setSource(\"field1\", English.intToEnglish(i)).get();\n            GetResponse get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(1l));\n            client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setVersion(2).setVersionType(VersionType.EXTERNAL).setSource(\"field1\", English.intToEnglish(i)).get();\n            get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(2l));\n        }\n    }","id":81728,"modified_method":"/**\n     * Basic test using Index & Realtime Get with external versioning. This test ensures routing works correctly across versions.\n     */\n    @Test\n    public void testExternalVersion() throws Exception {\n        createIndex(\"test\");\n        final boolean routing = randomBoolean();\n        long version = compatibilityVersion().onOrAfter(Version.V_1_2_0) ? Versions.MATCH_ANY_PRE_1_2_0 : Versions.MATCH_ANY;\n        int numDocs = randomIntBetween(10, 20);\n        for (int i = 0; i < numDocs; i++) {\n            String id = Integer.toString(i);\n            String routingKey = routing ? randomRealisticUnicodeOfLength(10) : null;\n            client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setVersion(1).setVersionType(VersionType.EXTERNAL).setSource(\"field1\", English.intToEnglish(i)).get();\n            GetResponse get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).setVersion(version).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(1l));\n            client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setVersion(2).setVersionType(VersionType.EXTERNAL).setSource(\"field1\", English.intToEnglish(i)).get();\n            get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).setVersion(version).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(2l));\n        }\n    }","commit_id":"a960d17d099b99c0bb8abed1206b79d425980cac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Basic test using Index & Realtime Get with internal versioning. This test ensures routing works correctly across versions.\n     */\n    @Test\n    public void testInternalVersion() throws Exception {\n        createIndex(\"test\");\n        final boolean routing = randomBoolean();\n        int numDocs = randomIntBetween(10, 20);\n        for (int i = 0; i < numDocs; i++) {\n            String routingKey = routing ? randomRealisticUnicodeOfLength(10) : null;\n            String id = Integer.toString(i);\n            assertThat(id, client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setSource(\"field1\", English.intToEnglish(i)).get().isCreated(), is(true));\n            GetResponse get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(1l));\n            client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setSource(\"field1\", English.intToEnglish(i)).execute().actionGet();\n            get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(2l));\n        }\n\n        assertVersionCreated(compatibilityVersion(), \"test\");\n    }","id":81729,"modified_method":"/**\n     * Basic test using Index & Realtime Get with internal versioning. This test ensures routing works correctly across versions.\n     */\n    @Test\n    public void testInternalVersion() throws Exception {\n        createIndex(\"test\");\n        final boolean routing = randomBoolean();\n        long version = compatibilityVersion().onOrAfter(Version.V_1_2_0) ? Versions.MATCH_ANY_PRE_1_2_0 : Versions.MATCH_ANY;\n        int numDocs = randomIntBetween(10, 20);\n        for (int i = 0; i < numDocs; i++) {\n            String routingKey = routing ? randomRealisticUnicodeOfLength(10) : null;\n            String id = Integer.toString(i);\n            assertThat(id, client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setSource(\"field1\", English.intToEnglish(i)).get().isCreated(), is(true));\n            GetResponse get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).setVersion(version).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(1l));\n            client().prepareIndex(\"test\", \"type1\", id).setRouting(routingKey).setSource(\"field1\", English.intToEnglish(i)).execute().actionGet();\n            get = client().prepareGet(\"test\", \"type1\", id).setRouting(routingKey).setVersion(version).get();\n            assertThat(\"Document with ID \" +id + \" should exist but doesn't\", get.isExists(), is(true));\n            assertThat(get.getVersion(), equalTo(2l));\n        }\n\n        assertVersionCreated(compatibilityVersion(), \"test\");\n    }","commit_id":"a960d17d099b99c0bb8abed1206b79d425980cac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void storeAll(Map<Long, ?> map) {\n        this.map.putAll(map);\n    }","id":81730,"modified_method":"public void storeAll(Map<Long, Object> map) {\n        this.map.putAll(map);\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Map<Long, ?> loadAll(Collection<Long> keys) {\n        Map<Long, Object> temp = new HashMap<Long, Object>(keys.size());\n        for (Long key: keys){\n            temp.put(key, map.get(key));\n        }\n        return temp;\n    }","id":81731,"modified_method":"public Map<Long, Object> loadAll(Collection<Long> keys) {\n        Map<Long, Object> temp = new HashMap<Long, Object>(keys.size());\n        for (Long key: keys){\n            temp.put(key, map.get(key));\n        }\n        return temp;\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void load(QueueItem item) throws Exception {\n        int bulkLoad = store.getBulkLoad();\n        bulkLoad = Math.min(itemQueue.size(), bulkLoad);\n        if (bulkLoad == 1) {\n            item.setData(store.load(item.getItemId()));\n        } else if (bulkLoad > 1) {\n            ListIterator<QueueItem> iter = itemQueue.listIterator();\n            HashSet<Long> keySet = new HashSet<Long>(bulkLoad);\n            for (int i = 0; i < bulkLoad; i++) {\n                keySet.add(iter.next().getItemId());\n            }\n            Map<Long, Data> values = store.loadAll(keySet);\n            if (values == null) {\n                System.err.println(\"something wrong!\");//TODO\n                return;\n            }\n            dataMap.putAll(values);\n            item.setData(getDataFromMap(item.getItemId()));\n        }\n    }","id":81732,"modified_method":"private void load(QueueItem item) throws Exception {\n        int bulkLoad = store.getBulkLoad();\n        bulkLoad = Math.min(itemQueue.size(), bulkLoad);\n        if (bulkLoad == 1) {\n            item.setData(store.load(item.getItemId()));\n        } else if (bulkLoad > 1) {\n            ListIterator<QueueItem> iter = itemQueue.listIterator();\n            HashSet<Long> keySet = new HashSet<Long>(bulkLoad);\n            for (int i = 0; i < bulkLoad; i++) {\n                keySet.add(iter.next().getItemId());\n            }\n            Map<Long, Data> values = store.loadAll(keySet);\n            if (values == null) {\n                // TODO: can loadAll return null map?\n                return;\n            }\n            dataMap.putAll(values);\n            item.setData(getDataFromMap(item.getItemId()));\n        }\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setConfig(QueueStoreConfig storeConfig) {\n        if (storeConfig == null) {\n            return;\n        }\n        this.storeConfig = storeConfig;\n        try {\n            Class<?> storeClass = Class.forName(storeConfig.getClassName());\n            store = (QueueStore) storeClass.newInstance();\n            enabled = storeConfig.isEnabled();\n            binary = Boolean.parseBoolean(storeConfig.getProperty(\"binary\"));\n            memoryLimit = parseInt(\"memory-limit\", DEFAULT_MEMORY_LIMIT);\n            bulkLoad = parseInt(\"bulk-load\", DEFAULT_BULK_LOAD);\n            if (bulkLoad < 1) {\n                bulkLoad = 1;\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }","id":81733,"modified_method":"public void setConfig(QueueStoreConfig storeConfig) {\n        if (storeConfig == null) {\n            return;\n        }\n        this.storeConfig = storeConfig;\n        try {\n            store = ClassLoaderUtil.newInstance(storeConfig.getClassName());\n            enabled = storeConfig.isEnabled();\n            binary = Boolean.parseBoolean(storeConfig.getProperty(\"binary\"));\n            memoryLimit = parseInt(\"memory-limit\", DEFAULT_MEMORY_LIMIT);\n            bulkLoad = parseInt(\"bulk-load\", DEFAULT_BULK_LOAD);\n            if (bulkLoad < 1) {\n                bulkLoad = 1;\n            }\n        } catch (Exception e) {\n            throw new HazelcastException(e);\n        }\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void store(Long key, Data value) throws Exception {\n        if (enabled) {\n            store.store(key, binary ? value.buffer : serializationService.toObject(value));\n        }\n    }","id":81734,"modified_method":"public void store(Long key, Data value) {\n        if (enabled) {\n            final Object actualValue;\n            if (binary) {\n                // WARNING: we can't pass original Data to the user\n                BufferObjectDataOutput out = (BufferObjectDataOutput) serializationService.createObjectDataOutput(value.totalSize());\n                try {\n                    value.writeData(out);\n                } catch (IOException e) {\n                    throw new HazelcastException(e);\n                }\n                // buffer size is exactly equal to binary size, no need to copy array. (also no need to close the out)\n                actualValue = out.getBuffer();\n            } else {\n                actualValue = serializationService.toObject(value);\n            }\n            store.store(key, actualValue);\n        }\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Data load(Long key) throws Exception {\n        if (enabled) {\n            Object val = store.load(key);\n            if (binary) {\n                return (Data) val;\n            }\n            return serializationService.toData(val);\n        }\n        return null;\n    }","id":81735,"modified_method":"public Data load(Long key) {\n        if (enabled) {\n            final Object val = store.load(key);\n            if (binary) {\n                byte[] dataBuffer = (byte[]) val;\n                ObjectDataInput in = serializationService.createObjectDataInput(dataBuffer);\n                Data data = new Data();\n                try {\n                    data.readData(in);\n                } catch (IOException e) {\n                    throw new HazelcastException(e);\n                }\n                return data;\n            }\n            return serializationService.toData(val);\n        }\n        return null;\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void storeAll(Map<Long, Data> map) throws Exception {\n        if (enabled) {\n            if (binary) {\n                store.storeAll(map);\n            } else {\n                Map<Long, Object> objectMap = new HashMap<Long, Object>(map.size());\n                for (Map.Entry<Long, Data> entry : map.entrySet()) {\n                    objectMap.put(entry.getKey(), serializationService.toObject(entry.getValue()));\n                }\n                store.storeAll(objectMap);\n            }\n        }\n    }","id":81736,"modified_method":"public void storeAll(Map<Long, Data> map) {\n        if (enabled) {\n            final Map<Long, Object> objectMap = new HashMap<Long, Object>(map.size());\n            if (binary) {\n                // WARNING: we can't pass original Data to the user\n                // TODO: is there really an advantage of using binary storeAll? since we need to do array copy for each item.\n                BufferObjectDataOutput out = (BufferObjectDataOutput) serializationService.createObjectDataOutput(1024);\n                try {\n                    for (Map.Entry<Long, Data> entry : map.entrySet()) {\n                        entry.getValue().writeData(out);\n                        objectMap.put(entry.getKey(), out.toByteArray());\n                        out.reset();\n                    }\n                } catch (IOException e) {\n                    throw new HazelcastException(e);\n                } finally {\n                    IOUtil.closeResource(out);\n                }\n            } else {\n                for (Map.Entry<Long, Data> entry : map.entrySet()) {\n                    objectMap.put(entry.getKey(), serializationService.toObject(entry.getValue()));\n                }\n            }\n            store.storeAll(objectMap);\n        }\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Map<Long, Data> loadAll(Collection<Long> keys) throws Exception {\n        if (enabled) {\n            Map<Long, ?> map = store.loadAll(keys);\n            if (binary) {\n                return (Map<Long, Data>) map;\n            }\n            Map<Long, Data> dataMap = new HashMap<Long, Data>(map.size());\n            for (Map.Entry<Long, ?> entry : map.entrySet()) {\n                dataMap.put(entry.getKey(), serializationService.toData(entry.getValue()));\n            }\n            return dataMap;\n        }\n        return null;\n    }","id":81737,"modified_method":"public Map<Long, Data> loadAll(Collection<Long> keys) {\n        if (enabled) {\n            final Map<Long, ?> map = store.loadAll(keys);\n            if (map == null) {\n                return Collections.emptyMap();\n            }\n            final Map<Long, Data> dataMap = new HashMap<Long, Data>(map.size());\n            if (binary) {\n                for (Map.Entry<Long, ?> entry : map.entrySet()) {\n                    byte[] dataBuffer = (byte[]) entry.getValue();\n                    ObjectDataInput in = serializationService.createObjectDataInput(dataBuffer);\n                    Data data = new Data();\n                    try {\n                        data.readData(in);\n                    } catch (IOException e) {\n                        throw new HazelcastException(e);\n                    }\n                    dataMap.put(entry.getKey(), data);\n                }\n                return (Map<Long, Data>) map;\n            } else {\n                for (Map.Entry<Long, ?> entry : map.entrySet()) {\n                    dataMap.put(entry.getKey(), serializationService.toData(entry.getValue()));\n                }\n            }\n            return dataMap;\n        }\n        return null;\n    }","commit_id":"2226438f43b10dfd8ab75efd4bd931652a28f3a5","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static List<AutoDeployListener> getAutoDeployListeners() {\n\t\tList<AutoDeployListener> autoDeployListeners =\n\t\t\tnew ArrayList<AutoDeployListener>();\n\n\t\tString[] autoDeployListenerClassNames = PropsUtil.getArray(\n\t\t\tPropsKeys.AUTO_DEPLOY_LISTENERS);\n\n\t\tfor (String autoDeployListenerClassName :\n\t\t\t\tautoDeployListenerClassNames) {\n\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiating \" + autoDeployListenerClassName);\n\t\t\t\t}\n\n\t\t\t\tAutoDeployListener autoDeployListener =\n\t\t\t\t\t(AutoDeployListener)Class.forName(\n\t\t\t\t\t\tautoDeployListenerClassName).newInstance();\n\n\t\t\t\tautoDeployListeners.add(autoDeployListener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn autoDeployListeners;\n\t}","id":81738,"modified_method":"public static List<AutoDeployListener> getAutoDeployListeners() {\n\t\tList<AutoDeployListener> autoDeployListeners =\n\t\t\tnew ArrayList<AutoDeployListener>();\n\n\t\tString[] autoDeployListenerClassNames = PropsUtil.getArray(\n\t\t\tPropsKeys.AUTO_DEPLOY_LISTENERS);\n\n\t\tfor (String autoDeployListenerClassName :\n\t\t\t\tautoDeployListenerClassNames) {\n\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiating \" + autoDeployListenerClassName);\n\t\t\t\t}\n\n\t\t\t\tAutoDeployListener autoDeployListener =\n\t\t\t\t\t(AutoDeployListener)InstanceFactory.newInstance(\n\t\t\t\t\t\tautoDeployListenerClassName);\n\n\t\t\t\tautoDeployListeners.add(autoDeployListener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn autoDeployListeners;\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SandboxDeployListener> getSandboxDeployListeners() {\n\t\tList<SandboxDeployListener> sandboxDeployListeners =\n\t\t\tnew ArrayList<SandboxDeployListener>();\n\n\t\tString[] sandboxDeployListenerClassNames = PropsUtil.getArray(\n\t\t\tPropsKeys.SANDBOX_DEPLOY_LISTENERS);\n\n\t\tfor (String sandboxDeployListenerClassName :\n\t\t\t\tsandboxDeployListenerClassNames) {\n\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Instantiating \" + sandboxDeployListenerClassName);\n\t\t\t\t}\n\n\t\t\t\tSandboxDeployListener sandboxDeployListener =\n\t\t\t\t\t(SandboxDeployListener)Class.forName(\n\t\t\t\t\t\tsandboxDeployListenerClassName).newInstance();\n\n\t\t\t\tsandboxDeployListeners.add(sandboxDeployListener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn sandboxDeployListeners;\n\t}","id":81739,"modified_method":"public static List<SandboxDeployListener> getSandboxDeployListeners() {\n\t\tList<SandboxDeployListener> sandboxDeployListeners =\n\t\t\tnew ArrayList<SandboxDeployListener>();\n\n\t\tString[] sandboxDeployListenerClassNames = PropsUtil.getArray(\n\t\t\tPropsKeys.SANDBOX_DEPLOY_LISTENERS);\n\n\t\tfor (String sandboxDeployListenerClassName :\n\t\t\t\tsandboxDeployListenerClassNames) {\n\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Instantiating \" + sandboxDeployListenerClassName);\n\t\t\t\t}\n\n\t\t\t\tSandboxDeployListener sandboxDeployListener =\n\t\t\t\t\t(SandboxDeployListener)InstanceFactory.newInstance(\n\t\t\t\t\t\tsandboxDeployListenerClassName);\n\n\t\t\t\tsandboxDeployListeners.add(sandboxDeployListener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn sandboxDeployListeners;\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<HotDeployListener> getHotDeployListeners() {\n\t\tList<HotDeployListener> hotDeployListeners =\n\t\t\tnew ArrayList<HotDeployListener>();\n\n\t\tString[] hotDeployListenerClassNames = PropsUtil.getArray(\n\t\t\tPropsKeys.HOT_DEPLOY_LISTENERS);\n\n\t\tfor (String hotDeployListenerClassName : hotDeployListenerClassNames) {\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiating \" + hotDeployListenerClassName);\n\t\t\t\t}\n\n\t\t\t\tHotDeployListener hotDeployListener =\n\t\t\t\t\t(HotDeployListener)Class.forName(\n\t\t\t\t\t\thotDeployListenerClassName).newInstance();\n\n\t\t\t\thotDeployListeners.add(hotDeployListener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn hotDeployListeners;\n\t}","id":81740,"modified_method":"public static List<HotDeployListener> getHotDeployListeners() {\n\t\tList<HotDeployListener> hotDeployListeners =\n\t\t\tnew ArrayList<HotDeployListener>();\n\n\t\tString[] hotDeployListenerClassNames = PropsUtil.getArray(\n\t\t\tPropsKeys.HOT_DEPLOY_LISTENERS);\n\n\t\tfor (String hotDeployListenerClassName : hotDeployListenerClassNames) {\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiating \" + hotDeployListenerClassName);\n\t\t\t\t}\n\n\t\t\t\tHotDeployListener hotDeployListener =\n\t\t\t\t\t(HotDeployListener)InstanceFactory.newInstance(\n\t\t\t\t\t\thotDeployListenerClassName);\n\n\t\t\t\thotDeployListeners.add(hotDeployListener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn hotDeployListeners;\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setTemplateLoaders(\n\t\tString[] freeMarkerTemplateLoaderClassNames) {\n\n\t\tList<FreeMarkerTemplateLoader> freeMarkerTemplateLoaders =\n\t\t\tnew ArrayList<FreeMarkerTemplateLoader>(\n\t\t\t\tfreeMarkerTemplateLoaderClassNames.length);\n\n\t\tfor (String freeMarkerTemplateLoaderClassName :\n\t\t\t\tfreeMarkerTemplateLoaderClassNames) {\n\n\t\t\ttry {\n\t\t\t\tFreeMarkerTemplateLoader freeMarkerTemplateLoader =\n\t\t\t\t\t(FreeMarkerTemplateLoader)Class.forName(\n\t\t\t\t\t\tfreeMarkerTemplateLoaderClassName).newInstance();\n\n\t\t\t\tfreeMarkerTemplateLoaders.add(freeMarkerTemplateLoader);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\t_freeMarkerTemplateLoaders = freeMarkerTemplateLoaders.toArray(\n\t\t\tnew FreeMarkerTemplateLoader[freeMarkerTemplateLoaders.size()]);\n\t}","id":81741,"modified_method":"public void setTemplateLoaders(\n\t\tString[] freeMarkerTemplateLoaderClassNames) {\n\n\t\tList<FreeMarkerTemplateLoader> freeMarkerTemplateLoaders =\n\t\t\tnew ArrayList<FreeMarkerTemplateLoader>(\n\t\t\t\tfreeMarkerTemplateLoaderClassNames.length);\n\n\t\tfor (String freeMarkerTemplateLoaderClassName :\n\t\t\t\tfreeMarkerTemplateLoaderClassNames) {\n\n\t\t\ttry {\n\t\t\t\tFreeMarkerTemplateLoader freeMarkerTemplateLoader =\n\t\t\t\t\t(FreeMarkerTemplateLoader)InstanceFactory.newInstance(\n\t\t\t\t\t\tfreeMarkerTemplateLoaderClassName);\n\n\t\t\t\tfreeMarkerTemplateLoaders.add(freeMarkerTemplateLoader);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\t_freeMarkerTemplateLoaders = freeMarkerTemplateLoaders.toArray(\n\t\t\tnew FreeMarkerTemplateLoader[freeMarkerTemplateLoaders.size()]);\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private PortletFilter _init(\n\t\t\tcom.liferay.portal.model.PortletFilter portletFilterModel,\n\t\t\tFilterConfig filterConfig, PortletFilter portletFilter)\n\t\tthrows PortletException {\n\n\t\ttry {\n\t\t\tif (portletFilter == null) {\n\t\t\t\tportletFilter = (PortletFilter)Class.forName(\n\t\t\t\t\tportletFilterModel.getFilterClass()).newInstance();\n\t\t\t}\n\n\t\t\tportletFilter.init(filterConfig);\n\t\t}\n\t\tcatch (ClassNotFoundException cnofe) {\n\t\t\tthrow new UnavailableException(cnofe.getMessage());\n\t\t}\n\t\tcatch (InstantiationException ie) {\n\t\t\tthrow new UnavailableException(ie.getMessage());\n\t\t}\n\t\tcatch (IllegalAccessException iae) {\n\t\t\tthrow new UnavailableException(iae.getMessage());\n\t\t}\n\n\t\treturn portletFilter;\n\t}","id":81742,"modified_method":"private PortletFilter _init(\n\t\t\tcom.liferay.portal.model.PortletFilter portletFilterModel,\n\t\t\tFilterConfig filterConfig, PortletFilter portletFilter)\n\t\tthrows PortletException {\n\n\t\ttry {\n\t\t\tif (portletFilter == null) {\n\t\t\t\tportletFilter = (PortletFilter)InstanceFactory.newInstance(\n\t\t\t\t\tportletFilterModel.getFilterClass());\n\t\t\t}\n\n\t\t\tportletFilter.init(filterConfig);\n\t\t}\n\t\tcatch (PortletException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UnavailableException(e.getMessage());\n\t\t}\n\n\t\treturn portletFilter;\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private PortletURLGenerationListener _init(\n\t\t\tPortletURLListener portletURLListener,\n\t\t\tPortletURLGenerationListener portletURLGenerationListener)\n\t\tthrows PortletException {\n\n\t\ttry {\n\t\t\tif (portletURLGenerationListener == null) {\n\t\t\t\tportletURLGenerationListener =\n\t\t\t\t\t(PortletURLGenerationListener)Class.forName(\n\t\t\t\t\t\tportletURLListener.getListenerClass()).newInstance();\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException cnofe) {\n\t\t\tthrow new UnavailableException(cnofe.getMessage());\n\t\t}\n\t\tcatch (InstantiationException ie) {\n\t\t\tthrow new UnavailableException(ie.getMessage());\n\t\t}\n\t\tcatch (IllegalAccessException iae) {\n\t\t\tthrow new UnavailableException(iae.getMessage());\n\t\t}\n\n\t\treturn portletURLGenerationListener;\n\t}","id":81743,"modified_method":"private PortletURLGenerationListener _init(\n\t\t\tPortletURLListener portletURLListener,\n\t\t\tPortletURLGenerationListener portletURLGenerationListener)\n\t\tthrows PortletException {\n\n\t\ttry {\n\t\t\tif (portletURLGenerationListener == null) {\n\t\t\t\tportletURLGenerationListener =\n\t\t\t\t\t(PortletURLGenerationListener)InstanceFactory.newInstance(\n\t\t\t\t\t\tportletURLListener.getListenerClass());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UnavailableException(e.getMessage());\n\t\t}\n\n\t\treturn portletURLGenerationListener;\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static LinkedHashMap<String, String> getUserInfo(\n\t\tUser user, LinkedHashMap<String, String> userInfo, Portlet portlet) {\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\t// Liferay user attributes\n\n\t\ttry {\n\t\t\tUserAttributes userAttributes = new UserAttributes(user);\n\n\t\t\t// Mandatory user attributes\n\n\t\t\tuserInfo.put(\n\t\t\t\tUserAttributes.LIFERAY_COMPANY_ID,\n\t\t\t\tuserAttributes.getValue(UserAttributes.LIFERAY_COMPANY_ID));\n\n\t\t\tuserInfo.put(\n\t\t\t\tUserAttributes.LIFERAY_USER_ID,\n\t\t\t\tuserAttributes.getValue(UserAttributes.LIFERAY_USER_ID));\n\n\t\t\t// Portlet user attributes\n\n\t\t\tfor (String attrName : portletApp.getUserAttributes()) {\n\t\t\t\tString attrValue = userAttributes.getValue(attrName);\n\n\t\t\t\tif (attrValue != null) {\n\t\t\t\t\tuserInfo.put(attrName, attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tMap<String, String> unmodifiableUserInfo =\n\t\t\tCollections.unmodifiableMap((Map<String, String>)userInfo.clone());\n\n\t\t// Custom user attributes\n\n\t\tMap<String, CustomUserAttributes> cuaInstances =\n\t\t\tnew HashMap<String, CustomUserAttributes>();\n\n\t\tfor (Map.Entry<String, String> entry :\n\t\t\t\tportletApp.getCustomUserAttributes().entrySet()) {\n\n\t\t\tString attrName = entry.getKey();\n\t\t\tString attrCustomClass = entry.getValue();\n\n\t\t\tCustomUserAttributes cua = cuaInstances.get(attrCustomClass);\n\n\t\t\tif (cua == null) {\n\t\t\t\tif (portletApp.isWARFile()) {\n\t\t\t\t\tPortletContextBag portletContextBag =\n\t\t\t\t\t\tPortletContextBagPool.get(\n\t\t\t\t\t\t\tportletApp.getServletContextName());\n\n\t\t\t\t\tMap<String, CustomUserAttributes> customUserAttributes =\n\t\t\t\t\t\tportletContextBag.getCustomUserAttributes();\n\n\t\t\t\t\tcua = customUserAttributes.get(attrCustomClass);\n\n\t\t\t\t\tcua = (CustomUserAttributes)cua.clone();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcua = (CustomUserAttributes)Class.forName(\n\t\t\t\t\t\t\tattrCustomClass).newInstance();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcuaInstances.put(attrCustomClass, cua);\n\t\t\t}\n\n\t\t\tif (cua != null) {\n\t\t\t\tString attrValue = cua.getValue(attrName, unmodifiableUserInfo);\n\n\t\t\t\tif (attrValue != null) {\n\t\t\t\t\tuserInfo.put(attrName, attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn userInfo;\n\t}","id":81744,"modified_method":"public static LinkedHashMap<String, String> getUserInfo(\n\t\tUser user, LinkedHashMap<String, String> userInfo, Portlet portlet) {\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\t// Liferay user attributes\n\n\t\ttry {\n\t\t\tUserAttributes userAttributes = new UserAttributes(user);\n\n\t\t\t// Mandatory user attributes\n\n\t\t\tuserInfo.put(\n\t\t\t\tUserAttributes.LIFERAY_COMPANY_ID,\n\t\t\t\tuserAttributes.getValue(UserAttributes.LIFERAY_COMPANY_ID));\n\n\t\t\tuserInfo.put(\n\t\t\t\tUserAttributes.LIFERAY_USER_ID,\n\t\t\t\tuserAttributes.getValue(UserAttributes.LIFERAY_USER_ID));\n\n\t\t\t// Portlet user attributes\n\n\t\t\tfor (String attrName : portletApp.getUserAttributes()) {\n\t\t\t\tString attrValue = userAttributes.getValue(attrName);\n\n\t\t\t\tif (attrValue != null) {\n\t\t\t\t\tuserInfo.put(attrName, attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tMap<String, String> unmodifiableUserInfo =\n\t\t\tCollections.unmodifiableMap((Map<String, String>)userInfo.clone());\n\n\t\t// Custom user attributes\n\n\t\tMap<String, CustomUserAttributes> cuaInstances =\n\t\t\tnew HashMap<String, CustomUserAttributes>();\n\n\t\tfor (Map.Entry<String, String> entry :\n\t\t\t\tportletApp.getCustomUserAttributes().entrySet()) {\n\n\t\t\tString attrName = entry.getKey();\n\t\t\tString attrCustomClass = entry.getValue();\n\n\t\t\tCustomUserAttributes cua = cuaInstances.get(attrCustomClass);\n\n\t\t\tif (cua == null) {\n\t\t\t\tif (portletApp.isWARFile()) {\n\t\t\t\t\tPortletContextBag portletContextBag =\n\t\t\t\t\t\tPortletContextBagPool.get(\n\t\t\t\t\t\t\tportletApp.getServletContextName());\n\n\t\t\t\t\tMap<String, CustomUserAttributes> customUserAttributes =\n\t\t\t\t\t\tportletContextBag.getCustomUserAttributes();\n\n\t\t\t\t\tcua = customUserAttributes.get(attrCustomClass);\n\n\t\t\t\t\tcua = (CustomUserAttributes)cua.clone();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcua = (CustomUserAttributes)InstanceFactory.newInstance(\n\t\t\t\t\t\t\tattrCustomClass);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcuaInstances.put(attrCustomClass, cua);\n\t\t\t}\n\n\t\t\tif (cua != null) {\n\t\t\t\tString attrValue = cua.getValue(attrName, unmodifiableUserInfo);\n\n\t\t\t\tif (attrValue != null) {\n\t\t\t\t\tuserInfo.put(attrName, attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn userInfo;\n\t}","commit_id":"82744dfdf77d9f8494527a4cab3a4ad3ba15387f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean logout() {\n\t\tgetSubject().getPrincipals().clear();\n\n\t\treturn true;\n\t}","id":81745,"modified_method":"public boolean logout() {\n\t\tSubject subject = getSubject();\n\n\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\tprincipals.clear();\n\n\t\treturn true;\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean commit() {\n\t\tif (getPrincipal() != null) {\n\t\t\tgetSubject().getPrincipals().add(getPrincipal());\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":81746,"modified_method":"@SuppressWarnings(\"unused\")\n\tpublic boolean commit() throws LoginException {\n\t\tPrincipal principal = getPrincipal();\n\n\t\tif (principal != null) {\n\t\t\tSubject subject = getSubject();\n\n\t\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\t\tprincipals.add(getPrincipal());\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalRole role = new PortalRole(\"users\");\n\n\t\t\tgetSubject().getPrincipals().add(role);\n\t\t}\n\n\t\treturn commitValue;\n\t}","id":81747,"modified_method":"public boolean commit() throws LoginException {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalRole role = new PortalRole(\"users\");\n\n\t\t\tSubject subject = getSubject();\n\n\t\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\t\tprincipals.add(role);\n\t\t}\n\n\t\treturn commitValue;\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Principal getPortalPrincipal(String name) {\n\t\treturn (Principal)ReflectionUtil.newInstance(_WLS_USER_IMPL, name);\n\t}","id":81748,"modified_method":"protected Principal getPortalPrincipal(String name) throws LoginException {\n\t\ttry {\n\t\t\treturn (Principal)InstanceFactory.newInstance(\n\t\t\t\t_WLS_USER_IMPL, String.class, name);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new LoginException(e.getMessage());\n\t\t}\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Principal getPortalPrincipal(String name) {\n\t\treturn (Principal)ReflectionUtil.newInstance(_JPRINCIPAL, name);\n\t}","id":81749,"modified_method":"protected Principal getPortalPrincipal(String name) throws LoginException {\n\t\ttry {\n\t\t\treturn (Principal)InstanceFactory.newInstance(\n\t\t\t\t_JPRINCIPAL, String.class, name);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new LoginException(e.getMessage());\n\t\t}\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tgetSubject().getPrincipals().add(getPrincipal());\n\t\t\tgetSubject().getPrivateCredentials().add(getPassword());\n\n\t\t\tPrincipal group = (Principal)ReflectionUtil.newInstance(\n\t\t\t\t_JGROUP, \"Roles\");\n\t\t\tObject role = ReflectionUtil.newInstance(_JROLE, \"users\");\n\n\t\t\ttry {\n\t\t\t\tMethod method = MethodCache.get(\n\t\t\t\t\t_JGROUP, \"addMember\", new Class[] {role.getClass()});\n\n\t\t\t\tmethod.invoke(group, new Object[] {role});\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\tgetSubject().getPrincipals().add(group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","id":81750,"modified_method":"public boolean commit() throws LoginException {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tSubject subject = getSubject();\n\n\t\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\t\tprincipals.add(getPrincipal());\n\n\t\t\tSet<Object> privateCredentials = subject.getPrivateCredentials();\n\n\t\t\tprivateCredentials.add(getPassword());\n\n\t\t\ttry {\n\t\t\t\tPrincipal group = (Principal)InstanceFactory.newInstance(\n\t\t\t\t\t_JGROUP, String.class, \"Roles\");\n\t\t\t\tObject role = InstanceFactory.newInstance(\n\t\t\t\t\t_JROLE, String.class, \"users\");\n\n\t\t\t\tMethod method = MethodCache.get(\n\t\t\t\t\t_JGROUP, \"addMember\", new Class[] {role.getClass()});\n\n\t\t\t\tmethod.invoke(group, new Object[] {role});\n\n\t\t\t\tprincipals.add(group);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn commitValue;\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalGroup group = new PortalGroup(\"Roles\");\n\n\t\t\tgroup.addMember(new PortalPrincipal(\"users\"));\n\n\t\t\tgetSubject().getPrincipals().add(group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","id":81751,"modified_method":"public boolean commit() throws LoginException {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalGroup group = new PortalGroup(\"Roles\");\n\n\t\t\tgroup.addMember(new PortalPrincipal(\"users\"));\n\n\t\t\tSubject subject = getSubject();\n\n\t\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\t\tprincipals.add(group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalRole role = new PortalRole(\"users\");\n\n\t\t\tgetSubject().getPrincipals().add(role);\n\t\t}\n\n\t\treturn commitValue;\n\t}","id":81752,"modified_method":"public boolean commit() throws LoginException {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalRole role = new PortalRole(\"users\");\n\n\t\t\tSubject subject = getSubject();\n\n\t\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\t\tprincipals.add(role);\n\t\t}\n\n\t\treturn commitValue;\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortalLoginModule() {\n\t\tif (Validator.isNotNull(PropsValues.PORTAL_JAAS_IMPL)) {\n\t\t\ttry {\n\t\t\t\t_loginModule = (LoginModule)Class.forName(\n\t\t\t\t\tPropsValues.PORTAL_JAAS_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\tif (_loginModule == null) {\n\n\t\t\t// Check application servers\n\n\t\t\tif (ServerDetector.isJBoss()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.jboss.PortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isJOnAS()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.jonas.PortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isResin()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.resin.PortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isWebLogic()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.weblogic.PortalLoginModule();\n\t\t\t}\n\n\t\t\t// Check servlet containers\n\n\t\t\telse if (ServerDetector.isJetty()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.jetty.PortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isTomcat()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.tomcat.PortalLoginModule();\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(_loginModule.getClass().getName());\n\t\t}\n\t}","id":81753,"modified_method":"public PortalLoginModule() {\n\t\tif (Validator.isNotNull(PropsValues.PORTAL_JAAS_IMPL)) {\n\t\t\ttry {\n\t\t\t\t_loginModule = (LoginModule)InstanceFactory.newInstance(\n\t\t\t\t\tPropsValues.PORTAL_JAAS_IMPL);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_loginModule == null) {\n\t\t\tif (ServerDetector.isJBoss()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.jboss.\n\t\t\t\t\t\tPortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isJetty()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.jetty.\n\t\t\t\t\t\tPortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isJOnAS()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.jonas.\n\t\t\t\t\t\tPortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isResin()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.resin.\n\t\t\t\t\t\tPortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isTomcat()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.tomcat.\n\t\t\t\t\t\tPortalLoginModule();\n\t\t\t}\n\t\t\telse if (ServerDetector.isWebLogic()) {\n\t\t\t\t_loginModule =\n\t\t\t\t\tnew com.liferay.portal.security.jaas.ext.weblogic.\n\t\t\t\t\t\tPortalLoginModule();\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(_loginModule.getClass().getName());\n\t\t}\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean commit() {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalGroup group = new PortalGroup(\"__roles__\");\n\n\t\t\tgroup.addMember(new PortalPrincipal(\"users\"));\n\n\t\t\tgetSubject().getPrincipals().add(group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","id":81754,"modified_method":"public boolean commit() throws LoginException {\n\t\tboolean commitValue = super.commit();\n\n\t\tif (commitValue) {\n\t\t\tPortalGroup group = new PortalGroup(\"__roles__\");\n\n\t\t\tgroup.addMember(new PortalPrincipal(\"users\"));\n\n\t\t\tSubject subject = getSubject();\n\n\t\t\tSet<Principal> principals = subject.getPrincipals();\n\n\t\t\tprincipals.add(group);\n\t\t}\n\n\t\treturn commitValue;\n\t}","commit_id":"9788d15aaf79c929418a66fb64700326814df974","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DB getDB() {\n\t\tif (_db == null) {\n\t\t\ttry {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Using dialect \" + PropsValues.HIBERNATE_DIALECT);\n\t\t\t\t}\n\n\t\t\t\tDialect dialect = (Dialect)Class.forName(\n\t\t\t\t\tPropsValues.HIBERNATE_DIALECT).newInstance();\n\n\t\t\t\tsetDB(dialect);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn _db;\n\t}","id":81755,"modified_method":"public DB getDB() {\n\t\tif (_db == null) {\n\t\t\ttry {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Using dialect \" + PropsValues.HIBERNATE_DIALECT);\n\t\t\t\t}\n\n\t\t\t\tDialect dialect = (Dialect)InstanceFactory.newInstance(\n\t\t\t\t\tPropsValues.HIBERNATE_DIALECT);\n\n\t\t\t\tsetDB(dialect);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn _db;\n\t}","commit_id":"0a42597b8cdf64c0b2f29068fb38531286f7a1d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private Bundle getBundleFromService(ServiceContainer serviceContainer, ServiceName serviceName) throws ExecutionException, TimeoutException {\n        ServiceController<Bundle> controller = (ServiceController<Bundle>) serviceContainer.getService(serviceName);\n        FutureServiceValue<Bundle> future = new FutureServiceValue<Bundle>(controller);\n        return future.get(5, TimeUnit.SECONDS);\n    }","id":81756,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private Bundle getBundleFromService(ServiceName serviceName) throws ExecutionException, TimeoutException {\n        ServiceController<Bundle> controller = (ServiceController<Bundle>) getServiceContainer().getService(serviceName);\n        FutureServiceValue<Bundle> future = new FutureServiceValue<Bundle>(controller);\n        return future.get(5, TimeUnit.SECONDS);\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"Bundle registerModule(ModuleIdentifier moduleId) throws Exception {\n        final ServiceController<?> bundleContextService = getServiceContainer().getRequiredService(ServiceNames.FRAMEWORK_ACTIVE);\n        if (bundleContextService.getMode() == Mode.ON_DEMAND && bundleContextService.getState() == State.DOWN) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            bundleContextService.addListener(new AbstractServiceListener<Object>() {\n\n                @Override\n                public void serviceStarted(ServiceController<? extends Object> controller) {\n                    latch.countDown();\n                    controller.removeListener(this);\n                }\n\n                @Override\n                public void serviceFailed(ServiceController<? extends Object> controller, StartException reason) {\n                    latch.countDown();\n                    controller.removeListener(this);\n                }\n            });\n            bundleContextService.setMode(Mode.ACTIVE);\n            latch.await(10, TimeUnit.SECONDS);\n\n            if (bundleContextService.getState() != State.UP)\n                throw new IllegalStateException(\"BundleContextService not started\");\n        }\n\n        final ServiceController<?> bundleManagerService = getServiceContainer().getRequiredService(ServiceNames.BUNDLE_MANAGER);\n        BundleManagement bundleManager = (BundleManagement) bundleManagerService.getValue();\n        if (bundleManager == null)\n            throw new IllegalStateException(\"BundleManagement not started\");\n\n        ServiceContainer serviceContainer = getServiceContainer();\n        ServiceTarget serviceTarget = serviceContainer.subTarget();\n        ServiceName serviceName = bundleManager.installBundle(serviceTarget, moduleId);\n        return getBundleFromService(serviceContainer, serviceName);\n    }","id":81757,"modified_method":"@SuppressWarnings(\"unchecked\")\n    Bundle registerModule(ModuleIdentifier moduleId) throws Exception {\n        ServiceController<Framework> frameworkController = (ServiceController<Framework>) getServiceContainer().getRequiredService(ServiceNames.FRAMEWORK_ACTIVE);\n        new FutureServiceValue<Framework>(frameworkController).get();\n\n        ServiceController<BundleManagement> bundleManagerService = (ServiceController<BundleManagement>) getServiceContainer().getRequiredService(ServiceNames.BUNDLE_MANAGER);\n        BundleManagement bundleManager = new FutureServiceValue<BundleManagement>(bundleManagerService).get();\n\n        ServiceTarget serviceTarget = getServiceContainer().subTarget();\n        ServiceName serviceName = bundleManager.installBundle(serviceTarget, moduleId);\n        return getBundleFromService(serviceName);\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void bundleInvokesModuleService() throws Exception {\n        // Deploy the non-OSGi module which contains the target service\n        Archive<?> targetArchive = deploymentProvider.getClientDeployment(TARGET_MODULE_NAME);\n        String targetDeploymentName = archiveDeployer.deploy(targetArchive);\n        assertNotNull(\"Deployment name not null\", targetDeploymentName);\n        try {\n            // Check that the target service is up\n            ServiceName targetService = ServiceName.parse(\"jboss.osgi.xservice.target\");\n            assertServiceState(targetService, State.UP, 5000);\n\n            // Register the target module with the OSGi layer\n            Bundle targetBundle = registerModule(ModuleIdentifier.create(\"deployment.\" + targetDeploymentName));\n            try {\n                // Install the client bundle\n                InputStream input = deploymentProvider.getClientDeploymentAsStream(CLIENT_BUNDLE_NAME);\n                Bundle clientBundle = context.installBundle(CLIENT_BUNDLE_NAME, input);\n                assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, clientBundle.getState());\n                try {\n                    // Start the client bundle, which calls the target service.\n                    clientBundle.start();\n                    assertEquals(\"Bundle ACTIVE\", Bundle.ACTIVE, clientBundle.getState());\n                } finally {\n                    // Uninstall the client bundle\n                    clientBundle.uninstall();\n                }\n            } finally {\n                targetBundle.uninstall();\n            }\n        } finally {\n            // Undeploy the target module\n            archiveDeployer.undeploy(targetDeploymentName);\n        }\n    }","id":81758,"modified_method":"@Test\n    public void bundleInvokesModuleService() throws Exception {\n        // Deploy the non-OSGi module which contains the target service\n        Archive<?> targetArchive = deploymentProvider.getClientDeployment(TARGET_MODULE_NAME);\n        String targetDeploymentName = archiveDeployer.deploy(targetArchive);\n        assertNotNull(\"Deployment name not null\", targetDeploymentName);\n        try {\n            // Check that the target service is up\n            ServiceName targetService = ServiceName.parse(\"jboss.osgi.example.target.service\");\n            assertServiceState(targetService, State.UP, 5000);\n\n            // Register the target module with the OSGi layer\n            Bundle targetBundle = registerModule(ModuleIdentifier.create(\"deployment.\" + targetDeploymentName));\n            try\n            {\n                assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, targetBundle.getState());\n\n                // Install the client bundle\n                InputStream input = deploymentProvider.getClientDeploymentAsStream(CLIENT_BUNDLE_NAME);\n                Bundle clientBundle = context.installBundle(CLIENT_BUNDLE_NAME, input);\n                assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, clientBundle.getState());\n                try {\n                    // Start the client bundle, which calls the target service.\n                    clientBundle.start();\n                    assertEquals(\"Bundle ACTIVE\", Bundle.ACTIVE, clientBundle.getState());\n                } finally {\n                    // Uninstall the client bundle\n                    clientBundle.uninstall();\n                }\n            }\n            finally {\n                // Uninstall the target bundle\n                targetBundle.uninstall();\n            }\n        } finally {\n            // Undeploy the target module\n            archiveDeployer.undeploy(targetDeploymentName);\n        }\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = OSGiDeploymentAttachment.getDeployment(deploymentUnit);\n\n        String contextName = deploymentUnit.getName();\n        ServiceRegistry serviceRegistry = phaseContext.getServiceRegistry();\n        Deployment holderDep = DeploymentHolderService.getDeployment(serviceRegistry, contextName);\n        VirtualFile virtualFile = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n\n        String location = holderDep != null ? holderDep.getLocation() : contextName;\n        boolean autoStart = holderDep != null ? holderDep.isAutoStart() : true;\n\n        // Check for attached BundleInfo\n        BundleInfo info = BundleInfoAttachment.getBundleInfo(deploymentUnit);\n        if (deployment == null && info != null) {\n            deployment = DeploymentFactory.createDeployment(info);\n            deployment.addAttachment(BundleInfo.class, info);\n            OSGiDeploymentAttachment.attachDeployment(deploymentUnit, deployment);\n        }\n\n        // Check for attached OSGiMetaData\n        OSGiMetaData metadata = OSGiMetaDataAttachment.getOSGiMetaData(deploymentUnit);\n        if (deployment == null && metadata != null) {\n            String symbolicName = metadata.getBundleSymbolicName();\n            Version version = metadata.getBundleVersion();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n            deployment.addAttachment(OSGiMetaData.class, metadata);\n            OSGiDeploymentAttachment.attachDeployment(deploymentUnit, deployment);\n        }\n\n        // Check for attached XModule\n        XModule resModule = XModuleAttachment.getXModuleAttachment(deploymentUnit);\n        if (deployment == null && resModule != null) {\n            String symbolicName = resModule.getName();\n            Version version = resModule.getVersion();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n            deployment.addAttachment(XModule.class, resModule);\n            OSGiDeploymentAttachment.attachDeployment(deploymentUnit, deployment);\n        }\n\n        // Create the {@link BundleInstallService}\n        if (deployment != null) {\n            // Prevent garbage collection of the MountHandle which will close the file\n            MountHandle mount = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getMountHandle();\n            deployment.addAttachment(MountHandle.class, mount);\n            deployment.setAutoStart(autoStart);\n            BundleInstallService.addService(phaseContext, deployment);\n        }\n    }","id":81759,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final String contextName = deploymentUnit.getName();\n\n        // Check if we already have an OSGi deployment\n        Deployment deployment = OSGiDeploymentAttachment.getDeployment(deploymentUnit);\n\n        // Check if {@link InstallHandlerIntegration} provided the {@link Deployment}\n        if (deployment == null) {\n            ServiceRegistry serviceRegistry = phaseContext.getServiceRegistry();\n            ServiceController<Deployment> controller = DeploymentHolderService.getDeployment(serviceRegistry, contextName);\n            if (controller != null) {\n                deployment = controller.getValue();\n                controller.setMode(Mode.REMOVE);\n            }\n        }\n\n        // Check for attached BundleInfo\n        BundleInfo info = BundleInfoAttachment.getBundleInfo(deploymentUnit);\n        if (deployment == null && info != null) {\n            deployment = DeploymentFactory.createDeployment(info);\n            deployment.addAttachment(BundleInfo.class, info);\n            deployment.setAutoStart(true);\n            OSGiDeploymentAttachment.attachDeployment(deploymentUnit, deployment);\n        }\n\n        // Check for attached OSGiMetaData\n        OSGiMetaData metadata = OSGiMetaDataAttachment.getOSGiMetaData(deploymentUnit);\n        if (deployment == null && metadata != null) {\n            String symbolicName = metadata.getBundleSymbolicName();\n            Version version = metadata.getBundleVersion();\n            VirtualFile virtualFile = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), contextName, symbolicName, version);\n            deployment.setAutoStart(true);\n            deployment.addAttachment(OSGiMetaData.class, metadata);\n            OSGiDeploymentAttachment.attachDeployment(deploymentUnit, deployment);\n        }\n\n        // Check for attached XModule\n        XModule resModule = XModuleAttachment.getXModuleAttachment(deploymentUnit);\n        if (deployment == null && resModule != null) {\n            String symbolicName = resModule.getName();\n            Version version = resModule.getVersion();\n            VirtualFile virtualFile = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), contextName, symbolicName, version);\n            deployment.setAutoStart(true);\n            deployment.addAttachment(XModule.class, resModule);\n            OSGiDeploymentAttachment.attachDeployment(deploymentUnit, deployment);\n        }\n\n        // Create the {@link BundleInstallService}\n        if (deployment != null) {\n            // Prevent garbage collection of the MountHandle which will close the file\n            // MountHandle mount = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getMountHandle();\n            // deployment.addAttachment(MountHandle.class, mount);\n            BundleInstallService.addService(phaseContext, deployment);\n        }\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(DeploymentPhaseContext phaseContext, Deployment deployment) {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final BundleInstallService service = new BundleInstallService(deployment);\n        final String contextName = deploymentUnit.getName();\n        final ServiceName serviceName = getServiceName(contextName);\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        ServiceBuilder<BundleInstallService> builder = serviceTarget.addService(serviceName, service);\n        builder.addDependency(ServiceNames.SYSTEM_CONTEXT, BundleContext.class, service.injectedBundleContext);\n        builder.addDependency(ServiceNames.BUNDLE_MANAGER, BundleManagement.class, service.injectedBundleManager);\n        builder.addDependency(BundleStartupProcessor.SERVICE_NAME, BundleStartupProcessor.class, service.injectedStartTracker);\n        builder.addDependency(org.jboss.as.server.deployment.Services.deploymentUnitName(contextName));\n        builder.install();\n    }","id":81760,"modified_method":"public static void addService(DeploymentPhaseContext phaseContext, Deployment deployment) {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final BundleInstallService service = new BundleInstallService(deployment);\n        final String contextName = deploymentUnit.getName();\n        final ServiceName serviceName = getServiceName(contextName);\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        ServiceBuilder<BundleInstallService> builder = serviceTarget.addService(serviceName, service);\n        builder.addDependency(ServiceNames.BUNDLE_MANAGER, BundleManagement.class, service.injectedBundleManager);\n        builder.addDependency(BundleStartTracker.SERVICE_NAME, BundleStartTracker.class, service.injectedStartTracker);\n        builder.addDependency(Services.deploymentUnitName(contextName));\n        builder.addDependency(ServiceNames.FRAMEWORK_INIT);\n        builder.install();\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static Deployment getDeployment(ServiceRegistry registry, String contextName) {\n        ServiceController<?> controller = registry.getService(getServiceName(contextName));\n        return controller != null ? (Deployment) controller.getValue() : null;\n    }","id":81761,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static ServiceController<Deployment> getDeployment(ServiceRegistry registry, String contextName) {\n        return (ServiceController<Deployment>) registry.getService(getServiceName(contextName));\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(ServiceTarget serviceTarget)\n   {\n      EchoInvokerService service = new EchoInvokerService();\n      ServiceBuilder<?> serviceBuilder = serviceTarget.addService(SERVICE_NAME, service);\n      serviceBuilder.addDependency(ServiceName.parse(\"jboss.osgi.context\"), BundleContext.class, service.injectedBundleContext);\n      serviceBuilder.setInitialMode(Mode.ACTIVE);\n      serviceBuilder.install();\n      log.infof(\"Service added: %s\", SERVICE_NAME);\n      log.infof(\"Echo Loader: %s\", Echo.class.getClassLoader());\n   }","id":81762,"modified_method":"public static void addService(ServiceTarget serviceTarget)\n   {\n      EchoInvokerService service = new EchoInvokerService();\n      ServiceBuilder<?> serviceBuilder = serviceTarget.addService(SERVICE_NAME, service);\n      serviceBuilder.addDependency(ServiceName.of(\"jbosgi\", \"systemcontext\"), BundleContext.class, service.injectedBundleContext);\n      serviceBuilder.setInitialMode(Mode.ACTIVE);\n      serviceBuilder.install();\n      log.infof(\"Service added: %s\", SERVICE_NAME);\n      log.infof(\"Echo Loader: %s\", Echo.class.getClassLoader());\n   }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(ServiceTarget serviceTarget)\n   {\n      // Add the service with an alias that the OSGi layer can use to lookup the service\n      ServiceBuilder<Echo> serviceBuilder = serviceTarget.addService(SERVICE_NAME, new EchoService());\n      serviceBuilder.addAliases(ServiceName.of(Constants.JBOSGI_PREFIX, Echo.class.getName()));\n      serviceBuilder.setInitialMode(Mode.ACTIVE);\n      serviceBuilder.install();\n      log.infof(\"Service added: %s\", SERVICE_NAME);\n      log.infof(\"Echo Loader: %s\", Echo.class.getClassLoader());\n   }","id":81763,"modified_method":"public static void addService(ServiceTarget serviceTarget)\n   {\n      // Add the service with an alias that the OSGi layer can use to lookup the service\n      ServiceBuilder<Echo> serviceBuilder = serviceTarget.addService(SERVICE_NAME, new EchoService());\n      serviceBuilder.addAliases(ServiceName.of(\"jbosgi\", \"xservice\", Echo.class.getName()));\n      serviceBuilder.setInitialMode(Mode.ACTIVE);\n      serviceBuilder.install();\n      log.infof(\"Service added: %s\", SERVICE_NAME);\n      log.infof(\"Echo Loader: %s\", Echo.class.getClassLoader());\n   }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public List<URL> getAutoInstallList(BundleContext context) {\n            return Collections.unmodifiableList(autoInstall);\n        }","id":81764,"modified_method":"@Override\n        public List<URL> getAutoInstallList() {\n            return Collections.unmodifiableList(autoInstall);\n        }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void start(StartContext context) throws StartException {\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Start the OSGi {@link Framework}\n            FrameworkBuilder builder = new FrameworkBuilder(props);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(context.getChildTarget());\n            builder.addProvidedService(org.jboss.osgi.framework.ServiceNames.AUTOINSTALL_PROVIDER);\n            builder.addProvidedService(org.jboss.osgi.framework.ServiceNames.DEPLOYERSERVICE_PROVIDER);\n            builder.addProvidedService(ServiceNames.FRAMEWORK_MODULE_PROVIDER);\n            builder.addProvidedService(ServiceNames.MODULE_LOADER_PROVIDER);\n\n            Activation activation = subsystemState.getActivationPolicy();\n            Mode initialMode = (activation == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n            builder.createFrameworkServices(initialMode, true);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to create Framework services\", t);\n        }\n    }","id":81765,"modified_method":"public synchronized void start(StartContext context) throws StartException {\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Start the OSGi {@link Framework}\n            FrameworkBuilder builder = new FrameworkBuilder(props);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(context.getChildTarget());\n            builder.addProvidedService(ServiceNames.AUTOINSTALL_PROVIDER);\n            builder.addProvidedService(ServiceNames.INSTALL_HANDLER);\n            builder.addProvidedService(ServiceNames.FRAMEWORK_MODULE_PROVIDER);\n            builder.addProvidedService(ServiceNames.MODULE_LOADER_PROVIDER);\n            builder.addProvidedService(ServiceNames.SYSTEM_SERVICES_PROVIDER);\n\n            Activation activation = subsystemState.getActivationPolicy();\n            Mode initialMode = (activation == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n            builder.createFrameworkServices(initialMode, true);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to create Framework services\", t);\n        }\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void start(StartContext context) throws StartException {\n\n            // Register the {@link MBeanServer} as OSGi service\n            MBeanServer mbeanServer = injectedMBeanServer.getValue();\n            BundleContext systemContext = injectedSystemContext.getValue();\n            systemContext.registerService(MBeanServer.class.getName(), mbeanServer, null);\n\n            // Register the {@link ServiceContainer} as OSGi service\n            serviceContainer = context.getController().getServiceContainer();\n            systemContext.registerService(ServiceContainer.class.getName(), serviceContainer, null);\n        }","id":81766,"modified_method":"@Override\n        public void start(StartContext context) throws StartException {\n            serviceContainer = context.getController().getServiceContainer();\n        }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(final ServiceTarget target) {\n            SystemServicesIntegration service = new SystemServicesIntegration();\n            ServiceBuilder<?> builder = target.addService(SYSTEM_SERVICES, service);\n            builder.addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer);\n            builder.addDependency(ServiceNames.SYSTEM_CONTEXT, BundleContext.class, service.injectedSystemContext);\n            builder.setInitialMode(Mode.ON_DEMAND);\n            builder.install();\n        }","id":81767,"modified_method":"public static void addService(final ServiceTarget target) {\n            SystemServicesIntegration service = new SystemServicesIntegration();\n            ServiceBuilder<SystemServicesProvider> builder = target.addService(ServiceNames.SYSTEM_SERVICES_PROVIDER, service);\n            builder.addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer);\n            builder.addDependency(ServiceNames.FRAMEWORK_CREATE);\n            builder.setInitialMode(Mode.ON_DEMAND);\n            builder.install();\n        }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public List<URL> getAutoStartList(BundleContext context) {\n            return Collections.unmodifiableList(autoStart);\n        }","id":81768,"modified_method":"@Override\n        public List<URL> getAutoStartList() {\n            return Collections.unmodifiableList(autoStart);\n        }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void moduleInvokesBundleService() throws Exception {\n        // Deploy the module that contains the API\n        Archive<?> apiArchive = deploymentProvider.getClientDeployment(API_MODULE_NAME);\n        String apiDeploymentName = archiveDeployer.deploy(apiArchive);\n        assertNotNull(\"Deployment name not null\", apiDeploymentName);\n        try {\n            // Register the API module with the OSGi layer\n            Bundle apiBundle = registerModule(ModuleIdentifier.create(\"deployment.\" + apiDeploymentName));\n            try\n            {\n                // Install the bundle that contains the target service\n                InputStream input = deploymentProvider.getClientDeploymentAsStream(TARGET_BUNDLE_NAME);\n                Bundle targetBundle = context.installBundle(TARGET_BUNDLE_NAME, input);\n                assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, targetBundle.getState());\n                try {\n                    // Start the target service bundle\n                    targetBundle.start();\n                    assertEquals(\"Bundle ACTIVE\", Bundle.ACTIVE, targetBundle.getState());\n\n                    // Deploy the non-osgi client module\n                    Archive<?> clientArchive = deploymentProvider.getClientDeployment(CLIENT_MODULE_NAME);\n                    String clientDeploymentName = archiveDeployer.deploy(clientArchive);\n                    assertNotNull(\"Deployment name not null\", clientDeploymentName);\n                    try {\n                        // Wait for the client service to come up\n                        assertServiceState(ServiceName.parse(\"jboss.osgi.xservice.invoker\"), State.UP, 5000);\n                    } finally {\n                        // Undeploy the client module\n                        archiveDeployer.undeploy(clientDeploymentName);\n                    }\n                } finally {\n                    // Uninstall the target bundle\n                    targetBundle.uninstall();\n                }\n            }\n            finally {\n                apiBundle.uninstall();\n            }\n        } finally {\n            // Undeploy the API module\n            archiveDeployer.undeploy(apiDeploymentName);\n        }\n    }","id":81769,"modified_method":"@Test\n    public void moduleInvokesBundleService() throws Exception {\n        // Deploy the module that contains the API\n        Archive<?> apiArchive = deploymentProvider.getClientDeployment(API_MODULE_NAME);\n        String apiDeploymentName = archiveDeployer.deploy(apiArchive);\n        assertNotNull(\"Deployment name not null\", apiDeploymentName);\n        try {\n            // Register the API module with the OSGi layer\n            Bundle apiBundle = registerModule(ModuleIdentifier.create(\"deployment.\" + apiDeploymentName));\n            try\n            {\n                assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, apiBundle.getState());\n\n                // Install the bundle that contains the target service\n                InputStream input = deploymentProvider.getClientDeploymentAsStream(TARGET_BUNDLE_NAME);\n                Bundle targetBundle = context.installBundle(TARGET_BUNDLE_NAME, input);\n                assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, targetBundle.getState());\n                try {\n                    // Start the target service bundle\n                    targetBundle.start();\n                    assertEquals(\"Bundle ACTIVE\", Bundle.ACTIVE, targetBundle.getState());\n\n                    // Deploy the non-osgi client module\n                    Archive<?> clientArchive = deploymentProvider.getClientDeployment(CLIENT_MODULE_NAME);\n                    String clientDeploymentName = archiveDeployer.deploy(clientArchive);\n                    assertNotNull(\"Deployment name not null\", clientDeploymentName);\n                    try {\n                        // Wait for the client service to come up\n                        assertServiceState(ServiceName.parse(\"jboss.osgi.example.invoker.service\"), State.UP, 5000);\n                    } finally {\n                        // Undeploy the client module\n                        archiveDeployer.undeploy(clientDeploymentName);\n                    }\n                } finally {\n                    // Uninstall the target bundle\n                    targetBundle.uninstall();\n                }\n            }\n            finally\n            {\n                // Uninstall the API bundle\n                apiBundle.uninstall();\n            }\n        } finally {\n            // Undeploy the API module\n            archiveDeployer.undeploy(apiDeploymentName);\n        }\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        BundleInfo info = BundleInfoAttachment.getBundleInfo(deploymentUnit);\n        if (info != null)\n            return;\n\n        // Get the manifest from the deployment's virtual file\n        VirtualFile virtualFile = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        Manifest manifest = deploymentUnit.getAttachment(Attachments.OSGI_MANIFEST);\n        if (manifest == null)\n            return;\n\n        // Construct and attach the {@link BundleInfo}\n        try {\n            String contextName = deploymentUnit.getName();\n            ServiceRegistry serviceRegistry = phaseContext.getServiceRegistry();\n            Deployment holderdep = DeploymentHolderService.getDeployment(serviceRegistry, contextName);\n            String location = holderdep != null ? holderdep.getLocation() : contextName;\n            info = BundleInfo.createBundleInfo(AbstractVFS.adapt(virtualFile), location);\n            BundleInfoAttachment.attachBundleInfo(deploymentUnit, info);\n        } catch (BundleException ex) {\n            throw new DeploymentUnitProcessingException(\"Cannot create bundle deployment from: \" + virtualFile);\n        }\n    }","id":81770,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final String contextName = deploymentUnit.getName();\n        final ServiceRegistry serviceRegistry = phaseContext.getServiceRegistry();\n\n        // Check if we already have an OSGi deployment\n        BundleInfo info = BundleInfoAttachment.getBundleInfo(deploymentUnit);\n        ServiceController<Deployment> deploymentController = DeploymentHolderService.getDeployment(serviceRegistry, contextName);\n        if (info != null || deploymentController != null)\n            return;\n\n        // Get the manifest from the deployment's virtual file\n        VirtualFile virtualFile = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        Manifest manifest = deploymentUnit.getAttachment(Attachments.OSGI_MANIFEST);\n        if (manifest == null)\n            return;\n\n        // Construct and attach the {@link BundleInfo}\n        try {\n            info = BundleInfo.createBundleInfo(AbstractVFS.adapt(virtualFile), contextName);\n            BundleInfoAttachment.attachBundleInfo(deploymentUnit, info);\n        } catch (BundleException ex) {\n            throw new DeploymentUnitProcessingException(\"Cannot create bundle deployment from: \" + virtualFile);\n        }\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n        populateSubModel(context.getSubModel(), operation);\n\n        if (context instanceof BootOperationContext) {\n            final BootOperationContext updateContext = (BootOperationContext) context;\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    log.infof(\"Activating OSGi Subsystem\");\n                    long begin = System.currentTimeMillis();\n                    SubsystemState subsystemState = createSubsystemState(operation);\n\n                    // TODO: Hack, which registers the framework module with the {@link ModularURLStreamHandlerFactory}\n                    String value = SecurityActions.getSystemProperty(\"jboss.protocol.handler.modules\", \"org.jboss.osgi.framework\");\n                    if (!value.equals(\"org.jboss.osgi.framework\")) {\n                        value = value + \"|org.jboss.osgi.framework\";\n                    }\n                    SecurityActions.setSystemProperty(\"jboss.protocol.handler.modules\", value);\n\n                    ServiceTarget serviceTarget = context.getServiceTarget();\n                    Activation policy = subsystemState.getActivationPolicy();\n                    BundleContextService.addService(serviceTarget, policy);\n                    BundleStartupProcessor.addService(serviceTarget);\n                    DeployerServiceIntegration.addService(serviceTarget);\n                    FrameworkBootstrapService.addService(serviceTarget, subsystemState);\n\n                    ConfigAdminServiceImpl.addService(serviceTarget, subsystemState);\n\n                    new OSGiDeploymentActivator().activate(updateContext);\n                    resultHandler.handleResultComplete();\n\n                    long end = System.currentTimeMillis();\n                    log.debugf(\"Activated OSGi Subsystem in %dms\", end - begin);\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n\n        // Create the compensating operation\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n        return new BasicOperationResult(compensatingOperation);\n    }","id":81771,"modified_method":"@Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n        populateSubModel(context.getSubModel(), operation);\n\n        if (context instanceof BootOperationContext) {\n            final BootOperationContext updateContext = (BootOperationContext) context;\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    log.infof(\"Activating OSGi Subsystem\");\n                    long begin = System.currentTimeMillis();\n                    SubsystemState subsystemState = createSubsystemState(operation);\n\n                    // TODO: Hack, which registers the framework module with the {@link ModularURLStreamHandlerFactory}\n                    String value = SecurityActions.getSystemProperty(\"jboss.protocol.handler.modules\", \"org.jboss.osgi.framework\");\n                    if (!value.equals(\"org.jboss.osgi.framework\")) {\n                        value = value + \"|org.jboss.osgi.framework\";\n                    }\n                    SecurityActions.setSystemProperty(\"jboss.protocol.handler.modules\", value);\n\n                    ServiceTarget serviceTarget = context.getServiceTarget();\n                    Activation policy = subsystemState.getActivationPolicy();\n                    BundleContextService.addService(serviceTarget, policy);\n                    BundleStartTracker.addService(serviceTarget);\n                    InstallHandlerIntegration.addService(serviceTarget);\n                    FrameworkBootstrapService.addService(serviceTarget, subsystemState);\n\n                    ConfigAdminServiceImpl.addService(serviceTarget, subsystemState);\n\n                    new OSGiDeploymentActivator().activate(updateContext);\n                    resultHandler.handleResultComplete();\n\n                    long end = System.currentTimeMillis();\n                    log.debugf(\"Activated OSGi Subsystem in %dms\", end - begin);\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n\n        // Create the compensating operation\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n        return new BasicOperationResult(compensatingOperation);\n    }","commit_id":"ae64f0e42756b6bf1f03c2fa71afb89401394f4c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public NSArray<PageNumber> pageNumbers() {\n\t\tWODisplayGroup displayGroup = displayGroup();\n\t\tint pageCount = displayGroup.batchCount();\n\t\tint currentPageNumber = displayGroup.currentBatchIndex();\n\t\tint pageSize = displayGroup.numberOfObjectsPerBatch();\n\t\tif (_lastPageCount != pageCount || _lastCurrentPageNumber != currentPageNumber || _lastPageSize != pageSize) {\n\t\t\t_pageNumbers = new NSMutableArray<PageNumber>();\n\n\t\t\tint nearEdgeCount;\n\t\t\tint endCount;\n\t\t\tint nearCount;\n\t\t\tint minimumCount;\n\n\t\t\tif (ERXComponentUtilities.booleanValueForBinding(this, \"small\", false)) {\n\t\t\t\tnearEdgeCount = 1;\n\t\t\t\tendCount = 1;\n\t\t\t\tnearCount = 0;\n\t\t\t\tminimumCount = 5;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnearEdgeCount = 8;\n\t\t\t\tendCount = 2;\n\t\t\t\tnearCount = 3;\n\t\t\t\tminimumCount = 15;\n\t\t\t}\n\t\t\t\n\t\t\tif (pageCount <= minimumCount) {\n\t\t\t\taddPageNumbers(1, pageCount);\n\t\t\t}\n\t\t\telse if (currentPageNumber <= nearEdgeCount) {\n\t\t\t\taddPageNumbers(1, Math.max(nearEdgeCount - 1, currentPageNumber + nearCount));\n\t\t\t\taddEllipsis();\n\t\t\t\taddPageNumbers(pageCount - endCount + 1, pageCount);\n\t\t\t}\n\t\t\telse if (currentPageNumber > pageCount - nearEdgeCount) {\n\t\t\t\taddPageNumbers(1, endCount);\n\t\t\t\taddEllipsis();\n\t\t\t\taddPageNumbers(Math.min(pageCount - nearEdgeCount + 2, currentPageNumber - nearCount), pageCount);\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddPageNumbers(1, endCount);\n\t\t\t\tif (currentPageNumber - nearCount > (endCount + 1)) {\n\t\t\t\t\taddEllipsis();\n\t\t\t\t}\n\t\t\t\taddPageNumbers(Math.max(endCount + 1, currentPageNumber - nearCount), Math.min(currentPageNumber + nearCount, pageCount - endCount));\n\t\t\t\tif (currentPageNumber + nearCount < pageCount - endCount) {\n\t\t\t\t\taddEllipsis();\n\t\t\t\t}\n\t\t\t\taddPageNumbers(pageCount - endCount + 1, pageCount);\n\t\t\t}\n\n\t\t\t_lastPageCount = pageCount;\n\t\t\t_lastCurrentPageNumber = currentPageNumber;\n\t\t\t_lastPageSize = pageSize;\n\t\t}\n\n\t\treturn _pageNumbers;\n\t}","id":81772,"modified_method":"public NSArray<PageNumber> pageNumbers() {\n\t\tint pageCount = batchCount();\n\t\tint currentPageNumber = currentBatchIndex();\n\t\tint pageSize = numberOfObjectsPerBatch();\n\t\tif (_lastPageCount != pageCount || _lastCurrentPageNumber != currentPageNumber || _lastPageSize != pageSize) {\n\t\t\t_pageNumbers = new NSMutableArray<PageNumber>();\n\n\t\t\tint nearEdgeCount;\n\t\t\tint endCount;\n\t\t\tint nearCount;\n\t\t\tint minimumCount;\n\n\t\t\tif (ERXComponentUtilities.booleanValueForBinding(this, \"small\", false)) {\n\t\t\t\tnearEdgeCount = 1;\n\t\t\t\tendCount = 1;\n\t\t\t\tnearCount = 0;\n\t\t\t\tminimumCount = 5;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnearEdgeCount = 8;\n\t\t\t\tendCount = 2;\n\t\t\t\tnearCount = 3;\n\t\t\t\tminimumCount = 15;\n\t\t\t}\n\t\t\t\n\t\t\tif (pageCount <= minimumCount) {\n\t\t\t\taddPageNumbers(1, pageCount);\n\t\t\t}\n\t\t\telse if (currentPageNumber <= nearEdgeCount) {\n\t\t\t\taddPageNumbers(1, Math.max(nearEdgeCount - 1, currentPageNumber + nearCount));\n\t\t\t\taddEllipsis();\n\t\t\t\taddPageNumbers(pageCount - endCount + 1, pageCount);\n\t\t\t}\n\t\t\telse if (currentPageNumber > pageCount - nearEdgeCount) {\n\t\t\t\taddPageNumbers(1, endCount);\n\t\t\t\taddEllipsis();\n\t\t\t\taddPageNumbers(Math.min(pageCount - nearEdgeCount + 2, currentPageNumber - nearCount), pageCount);\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddPageNumbers(1, endCount);\n\t\t\t\tif (currentPageNumber - nearCount > (endCount + 1)) {\n\t\t\t\t\taddEllipsis();\n\t\t\t\t}\n\t\t\t\taddPageNumbers(Math.max(endCount + 1, currentPageNumber - nearCount), Math.min(currentPageNumber + nearCount, pageCount - endCount));\n\t\t\t\tif (currentPageNumber + nearCount < pageCount - endCount) {\n\t\t\t\t\taddEllipsis();\n\t\t\t\t}\n\t\t\t\taddPageNumbers(pageCount - endCount + 1, pageCount);\n\t\t\t}\n\n\t\t\t_lastPageCount = pageCount;\n\t\t\t_lastCurrentPageNumber = currentPageNumber;\n\t\t\t_lastPageSize = pageSize;\n\t\t}\n\t\treturn _pageNumbers;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults nextPage() {\n\t\tWODisplayGroup displayGroup = displayGroup();\n\t\tdisplayGroup.displayNextBatch();\n\t\treturn null;\n\t}","id":81773,"modified_method":"public WOActionResults nextPage() {\n\t\tWOActionResults nextPage = null;\n\t\tif(displayGroup() != null){\n\t\t\tWODisplayGroup displayGroup = displayGroup();\n\t\t\tdisplayGroup.displayNextBatch();\n\t\t} else if(parentActionName() != null){\n\t\t\tInteger nextBatchIndex = new Integer((currentBatchIndex() + 1));\n\t\t\tint pageCount  = batchCount();\n\t\t\tif((nextBatchIndex.intValue()  > pageCount)){\n\t\t\t\tnextBatchIndex = new Integer(pageCount);\n\t\t\t} \n\t\t\tsetValueForBinding(nextBatchIndex, \"currentBatchIndex\");\n\t\t\tnextPage = performParentAction(parentActionName());\n\t\t}\n\t\treturn nextPage;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults selectPage() {\n\t\tWODisplayGroup displayGroup = displayGroup();\n\t\tInteger pageNumber = _repetitionPageNumber.pageNumber();\n\t\tif (pageNumber != null) {\n\t\t\tdisplayGroup.setCurrentBatchIndex(pageNumber.intValue());\n\t\t}\n\t\treturn null;\n\t}","id":81774,"modified_method":"public WOActionResults selectPage() {\n\t\tWOActionResults selectPage = null;\n\t\tInteger pageNumber = _repetitionPageNumber.pageNumber();\n\t\tif (pageNumber != null) {\n\t\t\tif (displayGroup() != null) {\n\t\t\t\tdisplayGroup().setCurrentBatchIndex(pageNumber.intValue());\n\t\t\t} else {\n\t\t\t\tsetValueForBinding(pageNumber, \"currentBatchIndex\");\n\t\t\t\tselectPage = performParentAction(parentActionName());\n\t\t\t}\n\t\t}\n\t\treturn selectPage;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean hasMultiplePages() {\n    WODisplayGroup displayGroup = displayGroup();\n\t  return displayGroup.batchCount() > 1;\n\t}","id":81775,"modified_method":"public boolean hasMultiplePages() {\n\t\treturn batchCount() > 1;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean hasPreviousPage() {\n\t\tWODisplayGroup displayGroup = displayGroup();\n\t\treturn displayGroup.currentBatchIndex() > 1;\n\t}","id":81776,"modified_method":"public boolean hasPreviousPage() {\n\t\treturn currentBatchIndex() > 1;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean hasNextPage() {\n\t\tWODisplayGroup displayGroup = displayGroup();\n\t\treturn displayGroup.currentBatchIndex() < displayGroup.batchCount();\n\t}","id":81777,"modified_method":"public boolean hasNextPage() {\n\t\treturn currentBatchIndex() < batchCount();\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray objects() {\n\t\tif (displayGroup() instanceof ERXDisplayGroup) {\n\t\t\tERXDisplayGroup dg = (ERXDisplayGroup) displayGroup();\n\t\t\treturn dg.filteredObjects();\n\t\t}\n\t\treturn displayGroup().allObjects();\n\t}","id":81778,"modified_method":"public NSArray objects() {\n\t\tNSArray objects = null;\n\t\tif(displayGroup() != null){\n\t\t\tif (displayGroup() instanceof ERXDisplayGroup) {\n\t\t\t\tERXDisplayGroup dg = (ERXDisplayGroup) displayGroup();\n\t\t\t\tobjects =  dg.filteredObjects();\n\t\t\t} else {\n\t\t\t\tobjects =  displayGroup().allObjects();\n\t\t\t}\n\t\t} \n\t\treturn objects;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults previousPage() {\n\t\tWODisplayGroup displayGroup = displayGroup();\n\t\tdisplayGroup.displayPreviousBatch();\n\t\treturn null;\n\t}","id":81779,"modified_method":"public WOActionResults previousPage() {\n\t\tWOActionResults previousPage = null;\n\t\tif(displayGroup() != null){\n\t\t\tWODisplayGroup displayGroup = displayGroup();\n\t\t\tdisplayGroup.displayPreviousBatch();\n\t\t} else if(parentActionName() != null){\n\t\t\tInteger previousBatchIndex = new Integer((currentBatchIndex() - 1));\n\t\t\tif(!(previousBatchIndex.intValue()  > 0)){\n\t\t\t\tpreviousBatchIndex = new Integer(1);\n\t\t\t} \n\t\t\tsetValueForBinding(previousBatchIndex, \"currentBatchIndex\");\n\t\t\tpreviousPage = performParentAction(parentActionName());\n\t\t}\n\t\treturn previousPage;\n\t}","commit_id":"21431be06a33c00ed26a3b22110fc0f0e12417d0","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overridden to localize the fetch specification if needed.\n\t * @return <code>null<\/code> to force the page to reload\n\t */\n\t@Override\n\tpublic Object fetch() {\n\t\tif(log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Fetching: {}\", this, new RuntimeException(\"Dummy for Stacktrace\"));\n\t\t}\n\t\tObject result;\n\t\t// ak: we need to transform localized keys (foo.name->foo.name_de)\n\t\t// when we do a real fetch. This actually\n\t\t// belongs into ERXEC, but I'm reluctant to have this morphing done\n\t\t// every time a fetch occurs as it affects mainly sort ordering\n\t\t// from the display group\n\t\tif (dataSource() instanceof EODatabaseDataSource) {\n\t\t\tEODatabaseDataSource ds = (EODatabaseDataSource) dataSource();\n\t\t\tEOFetchSpecification old = ds.fetchSpecification();\n\t\t\tEOFetchSpecification fs = ERXEOAccessUtilities.localizeFetchSpecification(ds.editingContext(), old);\n\t\t\tds.setFetchSpecification(fs);\n\t\t\ttry {\n\t\t\t\tresult = super.fetch();\n\t\t\t} finally {\n\t\t\t\tds.setFetchSpecification(old);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = super.fetch();\n\t\t}\n\t\treturn result;\n\t}","id":81780,"modified_method":"/**\n\t * Overridden to localize the fetch specification if needed.\n\t * @return <code>null<\/code> to force the page to reload\n\t */\n\t@Override\n\tpublic Object fetch() {\n\t\tif(log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Fetching: {}\", this, new RuntimeException(\"Dummy for Stacktrace\"));\n\t\t}\n\t\tObject result;\n\t\t// ak: we need to transform localized keys (foo.name->foo.name_de)\n\t\t// when we do a real fetch. This actually\n\t\t// belongs into ERXEC, but I'm reluctant to have this morphing done\n\t\t// every time a fetch occurs as it affects mainly sort ordering\n\t\t// from the display group\n\t\tif (dataSource() instanceof EODatabaseDataSource) {\n\t\t\tEODatabaseDataSource ds = (EODatabaseDataSource) dataSource();\n\t\t\tEOFetchSpecification old = ds.fetchSpecification();\n\t\t\tEOFetchSpecification fs = ERXEOAccessUtilities.localizeFetchSpecification(ds.editingContext(), old);\n\t\t\tds.setFetchSpecification(fs);\n\t\t\ttry {\n\t\t\t\tresult = super.fetch();\n\t\t\t} finally {\n\t\t\t\tds.setFetchSpecification(old);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = super.fetch();\n\t\t}\n\t\t// flush cache\n\t\t_filteredObjects = null;\n\t\treturn result;\n\t}","commit_id":"cac167713b700d717360257e05dd54e3bce60dbb","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns all objects, filtered by the qualifier().\n\t * @return filtered objects\n\t */\n\tpublic NSArray<T> filteredObjects() {\n\t\t// FIXME AK: need to cache here\n\t\tNSArray<T> result;\n\t\tEOQualifier q=qualifier();\n\t\tif (q!=null) {\n\t\t\tresult=EOQualifier.filteredArrayWithQualifier(allObjects(),q);\n\t\t} else {\n\t\t\tresult=allObjects();\n\t\t}\n\t\treturn result;\n\t}","id":81781,"modified_method":"/**\n\t * Returns all objects, filtered by the qualifier().\n\t * @return filtered objects\n\t */\n\tpublic NSArray<T> filteredObjects() {\n\t\tif (qualifier() == null) {\n\t\t\treturn allObjects();\n\t\t} else if (_filteredObjects == null) {\n\t\t\t_filteredObjects = EOQualifier.filteredArrayWithQualifier(allObjects(), qualifier());\n\t\t}\n\t\treturn _filteredObjects;\n\t}","commit_id":"cac167713b700d717360257e05dd54e3bce60dbb","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public final void map(Chunk [] chunks, NewChunk [] outputs){\n    long t0 = System.nanoTime(), t2 = 0;\n    if(_job != null && _job.self() != null && !Job.isRunning(_job.self()))throw new JobCancelledException();\n    final int nrows = chunks[0]._len;\n    final long offset = chunks[0]._start;\n    chunkInit();\n    double [] nums = MemoryManager.malloc8d(_dinfo._nums);\n    int    [] cats = MemoryManager.malloc4(_dinfo._cats);\n    double [] response = MemoryManager.malloc8d(_dinfo._responses);\n    int start = 0;\n    int end = nrows;\n\n    boolean contiguous = false;\n    Random skip_rng = null; //random generator for skipping rows\n    if (_useFraction < 1.0) {\n      skip_rng = water.util.Utils.getDeterRNG(new Random().nextLong());\n      if (contiguous) {\n        final int howmany = (int)Math.ceil(_useFraction*nrows);\n        if (howmany > 0) {\n          start = skip_rng.nextInt(nrows - howmany);\n          end = start + howmany;\n        }\n        assert(start < nrows);\n        assert(end <= nrows);\n      }\n    }\n\n    long[] shuf_map = null;\n    if (_shuffle) {\n      shuf_map = new long[end-start];\n      for (int i=0;i<shuf_map.length;++i)\n        shuf_map[i] = start + i;\n      Utils.shuffleArray(shuf_map, new Random().nextLong());\n    }\n    long nanos = 0;\n    long t1 = System.nanoTime();\n    OUTER:\n    for(int rr = start; rr < end; ++rr){\n      final int r = shuf_map != null ? (int)shuf_map[rr-start] : rr;\n      if ((_dinfo._nfolds > 0 && (r % _dinfo._nfolds) == _dinfo._foldId)\n              || (skip_rng != null && skip_rng.nextFloat() > _useFraction))continue;\n      for(Chunk c:chunks)if(c.isNA0(r))continue OUTER; // skip rows with NAs!\n      int i = 0, ncats = 0;\n      for(; i < _dinfo._cats; ++i){\n        int c = (int)chunks[i].at80(r);\n        if(c != 0)cats[ncats++] = c + _dinfo._catOffsets[i] - 1;\n      }\n      final int n = chunks.length-_dinfo._responses;\n      for(;i < n;++i){\n        double d = chunks[i].at0(r);\n        if(_dinfo._normMul != null) d = (d - _dinfo._normSub[i-_dinfo._cats])*_dinfo._normMul[i-_dinfo._cats];\n        nums[i-_dinfo._cats] = d;\n      }\n      for(i = 0; i < _dinfo._responses; ++i) {\n        response[i] = chunks[chunks.length-_dinfo._responses + i].at0(r);\n        if (_dinfo._normRespMul != null) response[i] = (response[i] - _dinfo._normRespSub[i])*_dinfo._normRespMul[i];\n      }\n      if(outputs != null && outputs.length > 0)\n        processRow(offset+r, nums, ncats, cats, response, outputs);\n      else\n        processRow(offset+r, nums, ncats, cats, response);\n      t2 = System.nanoTime();\n      nanos += (t2-t1);\n      t1 = t2;\n    }\n    chunkDone();\n    System.out.println(\"FrameTask.map done, processRow took \" + nanos + \"ns, while while map took \" + (t2 - t0) + \"ns and compute2 took \" + (t2-_t0)+\"ns\");\n    System.out.println();\n  }","id":81782,"modified_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public final void map(Chunk [] chunks, NewChunk [] outputs){\n    if(_job != null && _job.self() != null && !Job.isRunning(_job.self()))throw new JobCancelledException();\n    final int nrows = chunks[0]._len;\n    final long offset = chunks[0]._start;\n    chunkInit();\n    double [] nums = MemoryManager.malloc8d(_dinfo._nums);\n    int    [] cats = MemoryManager.malloc4(_dinfo._cats);\n    double [] response = MemoryManager.malloc8d(_dinfo._responses);\n    int start = 0;\n    int end = nrows;\n\n    boolean contiguous = false;\n    Random skip_rng = null; //random generator for skipping rows\n    if (_useFraction < 1.0) {\n      skip_rng = water.util.Utils.getDeterRNG(new Random().nextLong());\n      if (contiguous) {\n        final int howmany = (int)Math.ceil(_useFraction*nrows);\n        if (howmany > 0) {\n          start = skip_rng.nextInt(nrows - howmany);\n          end = start + howmany;\n        }\n        assert(start < nrows);\n        assert(end <= nrows);\n      }\n    }\n\n    long[] shuf_map = null;\n    if (_shuffle) {\n      shuf_map = new long[end-start];\n      for (int i=0;i<shuf_map.length;++i)\n        shuf_map[i] = start + i;\n      Utils.shuffleArray(shuf_map, new Random().nextLong());\n    }\n    OUTER:\n    for(int rr = start; rr < end; ++rr){\n      final int r = shuf_map != null ? (int)shuf_map[rr-start] : rr;\n      if ((_dinfo._nfolds > 0 && (r % _dinfo._nfolds) == _dinfo._foldId)\n              || (skip_rng != null && skip_rng.nextFloat() > _useFraction))continue;\n      for(Chunk c:chunks)if(c.isNA0(r))continue OUTER; // skip rows with NAs!\n      int i = 0, ncats = 0;\n      for(; i < _dinfo._cats; ++i){\n        int c = (int)chunks[i].at80(r);\n        if(c != 0)cats[ncats++] = c + _dinfo._catOffsets[i] - 1;\n      }\n      final int n = chunks.length-_dinfo._responses;\n      for(;i < n;++i){\n        double d = chunks[i].at0(r);\n        if(_dinfo._normMul != null) d = (d - _dinfo._normSub[i-_dinfo._cats])*_dinfo._normMul[i-_dinfo._cats];\n        nums[i-_dinfo._cats] = d;\n      }\n      for(i = 0; i < _dinfo._responses; ++i) {\n        response[i] = chunks[chunks.length-_dinfo._responses + i].at0(r);\n        if (_dinfo._normRespMul != null) response[i] = (response[i] - _dinfo._normRespSub[i])*_dinfo._normRespMul[i];\n      }\n      if(outputs != null && outputs.length > 0)\n        processRow(offset+r, nums, ncats, cats, response, outputs);\n      else\n        processRow(offset+r, nums, ncats, cats, response);\n    }\n    chunkDone();\n  }","commit_id":"63f281d61f9c982bf16604d4181e792e46346d36","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void callback(final GLMTask.GLMLineSearchTask glmt) {\n      Log.info(\"GLM invoking line search\");\n      double step = 0.5;\n      for(int i = 0; i < glmt._objvals.length; ++i){\n        if(!needLineSearch(glmt._betas[i],glmt._objvals[i],step)){\n          Log.info(\"GLM line search: found admissible step=\" + step);\n          if(step < 1e-2) // too small a step, increase precision of the solver\n            ADMM_GRAD_EPS = 1e-8;\n          _lastResult = null; // set last result to null so that the Iteration will not attempt to verify whether or not it should do the line search.\n          new GLMIterationTask(GLM2.this,_dinfo,_glm,true,true,true,glmt._betas[i],_ymu,_reg,new Iteration()).asyncExec(_dinfo._adaptedFrame);\n          return;\n        }\n        step *= 0.5;\n      } // no line step works, forcibly converge\n      // first try to increase precision of our solver\n      if(ADMM_GRAD_EPS > 1e-8) {\n        ADMM_GRAD_EPS = 1e-8;\n        new GLMIterationTask(GLM2.this,_dinfo,_glm,true,true,true,_lastResult._glmt._beta,_ymu,_reg,new Iteration()).asyncExec(_dinfo._adaptedFrame);\n      }\n      Log.info(\"GLM: line search failed to find feasible step. Forcibly converged.\");\n      nextLambda(_lastResult._glmt);\n    }","id":81783,"modified_method":"@Override public void callback(final GLMTask.GLMLineSearchTask glmt) {\n      Log.info(\"GLM invoking line search\");\n      double step = 0.5;\n      for(int i = 0; i < glmt._objvals.length; ++i){\n        if(!needLineSearch(glmt._betas[i],glmt._objvals[i],step)){\n          Log.info(\"GLM line search: found admissible step=\" + step);\n          if(step < 1e-2) // too small a step, increase precision of the solver\n            ADMM_GRAD_EPS = MIN_ADMM_GRAD_EPS;\n          _lastResult = null; // set last result to null so that the Iteration will not attempt to verify whether or not it should do the line search.\n          new GLMIterationTask(GLM2.this,_dinfo,_glm,true,true,true,glmt._betas[i],_ymu,_reg,new Iteration()).asyncExec(_dinfo._adaptedFrame);\n          return;\n        }\n        step *= 0.5;\n      } // no line step works, forcibly converge\n      // first try to increase precision of our solver\n      if(ADMM_GRAD_EPS > MIN_ADMM_GRAD_EPS) {\n        ADMM_GRAD_EPS = MIN_ADMM_GRAD_EPS;\n        new GLMIterationTask(GLM2.this,_dinfo,_glm,true,true,true,_lastResult._glmt._beta,_ymu,_reg,new Iteration()).asyncExec(_dinfo._adaptedFrame);\n      }\n      Log.info(\"GLM: line search failed to find feasible step. Forcibly converged.\");\n      nextLambda(_lastResult._glmt);\n    }","commit_id":"63f281d61f9c982bf16604d4181e792e46346d36","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void callback(final GLMIterationTask glmt) {\n      if( !isRunning(self()) )  throw new JobCancelledException();\n      boolean converged = false;\n      if(glmt._val != null){\n        glmt._val.finalize_AIC_AUC();\n        _model.setAndTestValidation(_lambdaIdx,glmt._val);//.store();\n        _model.clone().update(self());\n        lastValidation = System.currentTimeMillis();\n      }\n      if(glmt._beta != null && higher_accuracy && _glm.family != Family.tweedie){\n        converged = true;\n        double l1pen = alpha[0]*lambda[_lambdaIdx]*glmt._n;\n        double l2pen = (1-alpha[0])*lambda[_lambdaIdx]*glmt._n;\n        final double eps = 1e-2;\n        if(higher_accuracy && glmt._val != null){\n          for(int i = 0; i < glmt._grad.length-1; ++i) {// add l2 reg. term to the gradient\n            glmt._grad[i] += l2pen*glmt._beta[i];\n            if(glmt._beta[i] < 0)\n              converged &= Math.abs(glmt._grad[i] - l1pen) < eps;\n            else if(glmt._beta[i] > 0)\n              converged &= Math.abs(glmt._grad[i] + l1pen) < eps;\n            else\n              converged &= LSMSolver.shrinkage(glmt._grad[i],l1pen+eps) == 0;\n          }\n          if(converged) Log.info(\"GLM converged by reaching 0 gradient/subgradient.\");\n          double objval = glmt._val.residual_deviance + 0.5*l2pen*l2norm(glmt._beta);\n          if(!converged && _lastResult != null && needLineSearch(glmt._beta,objval,1)){\n            new GLMTask.GLMLineSearchTask(GLM2.this,_dinfo,_glm,_lastResult._glmt._beta,glmt._beta,1e-8, new LineSearchIteration()).asyncExec(_dinfo._adaptedFrame);\n            return;\n          }\n          _lastResult = new IterationInfo(GLM2.this._iter-1, objval, glmt);\n        }\n      }\n      double [] newBeta = glmt._beta != null?glmt._beta.clone():MemoryManager.malloc8d(glmt._xy.length);\n      double [] newBetaDeNorm = null;\n      ADMMSolver slvr = new ADMMSolver(lambda[_lambdaIdx],alpha[0], ADMM_GRAD_EPS, _addedL2);\n      slvr.solve(glmt._gram,glmt._xy,glmt._yy,newBeta);\n      _addedL2 = slvr._addedL2;\n      if(Utils.hasNaNsOrInfs(newBeta)){\n        Log.info(\"GLM forcibly converged by getting NaNs and/or Infs in beta\");\n      } else {\n        if(_dinfo._standardize) {\n          newBetaDeNorm = newBeta.clone();\n          double norm = 0.0;        // Reverse any normalization on the intercept\n          // denormalize only the numeric coefs (categoricals are not normalized)\n          final int numoff = newBeta.length - _dinfo._nums - 1;\n          for( int i=numoff; i< newBeta.length-1; i++ ) {\n            double b = newBetaDeNorm[i]*_dinfo._normMul[i-numoff];\n            norm += b*_dinfo._normSub[i-numoff]; // Also accumulate the intercept adjustment\n            newBetaDeNorm[i] = b;\n          }\n          newBetaDeNorm[newBetaDeNorm.length-1] -= norm;\n        }\n        _model.setLambdaSubmodel(_lambdaIdx,newBetaDeNorm == null?newBeta:newBetaDeNorm, newBetaDeNorm==null?null:newBeta, _iter);\n        if(beta_diff(glmt._beta,newBeta) < beta_epsilon){\n          Log.info(\"GLM converged by reaching fixed-point.\");\n          converged = true;\n        }\n        if(!converged && _glm.family != Family.gaussian && _iter < max_iter){\n          ++_iter;\n          boolean validate = higher_accuracy || (System.currentTimeMillis() - lastValidation) > 8e3;\n          new GLMIterationTask(GLM2.this,_dinfo,glmt._glm, true, validate, higher_accuracy,newBeta,_ymu,_reg,new Iteration()).asyncExec(_dinfo._adaptedFrame);\n          return;\n        }\n      }\n      // done with this lambda\n      nextLambda(glmt);\n    }","id":81784,"modified_method":"@Override public void callback(final GLMIterationTask glmt) {\n      if( !isRunning(self()) )  throw new JobCancelledException();\n      boolean converged = false;\n      if(glmt._val != null){\n        glmt._val.finalize_AIC_AUC();\n        _model.setAndTestValidation(_lambdaIdx,glmt._val);//.store();\n        _model.clone().update(self());\n        lastValidation = System.currentTimeMillis();\n      }\n      if(glmt._beta != null && higher_accuracy && _glm.family != Family.tweedie){\n        converged = true;\n        final double eps = 1e-2;\n        if(higher_accuracy && glmt._val != null){\n          double l1pen = alpha[0]*lambda[_lambdaIdx]*glmt._n;\n          double l2pen = (1-alpha[0])*lambda[_lambdaIdx]*glmt._n;\n          subgrad(alpha[0],lambda[_lambdaIdx],glmt._beta,glmt._grad);\n          double err = 0;\n          for(double d:glmt._grad)\n            if(d > err)err = d;\n            else if(d < -err) err = -d;\n          converged = err <= eps;\n          if(converged) Log.info(\"GLM converged by reaching 0 gradient/subgradient.\");\n          // TODO - use proper objective, this one works only for binomial and gaussian\n          double objval = glmt._val.residual_deviance/glmt._n + 0.5*l2pen*l2norm(glmt._beta);\n          if(!converged && _lastResult != null && needLineSearch(glmt._beta,objval,1)){\n            new GLMTask.GLMLineSearchTask(GLM2.this,_dinfo,_glm,_lastResult._glmt._beta,glmt._beta,1e-8, new LineSearchIteration()).asyncExec(_dinfo._adaptedFrame);\n            return;\n          }\n          _lastResult = new IterationInfo(GLM2.this._iter-1, objval, glmt);\n        }\n      }\n      double [] newBeta = glmt._beta != null?glmt._beta.clone():MemoryManager.malloc8d(glmt._xy.length);\n      double [] newBetaDeNorm = null;\n      ADMMSolver slvr = new ADMMSolver(lambda[_lambdaIdx],alpha[0], ADMM_GRAD_EPS, _addedL2);\n      slvr.solve(glmt._gram,glmt._xy,glmt._yy,newBeta);\n      _addedL2 = slvr._addedL2;\n      if(Utils.hasNaNsOrInfs(newBeta)){\n        Log.info(\"GLM forcibly converged by getting NaNs and/or Infs in beta\");\n      } else {\n        if(_dinfo._standardize) {\n          newBetaDeNorm = newBeta.clone();\n          double norm = 0.0;        // Reverse any normalization on the intercept\n          // denormalize only the numeric coefs (categoricals are not normalized)\n          final int numoff = newBeta.length - _dinfo._nums - 1;\n          for( int i=numoff; i< newBeta.length-1; i++ ) {\n            double b = newBetaDeNorm[i]*_dinfo._normMul[i-numoff];\n            norm += b*_dinfo._normSub[i-numoff]; // Also accumulate the intercept adjustment\n            newBetaDeNorm[i] = b;\n          }\n          newBetaDeNorm[newBetaDeNorm.length-1] -= norm;\n        }\n        _model.setLambdaSubmodel(_lambdaIdx,newBetaDeNorm == null?newBeta:newBetaDeNorm, newBetaDeNorm==null?null:newBeta, _iter);\n        if(beta_diff(glmt._beta,newBeta) < beta_epsilon){\n          Log.info(\"GLM converged by reaching fixed-point.\");\n          converged = true;\n        }\n        if(!converged && _glm.family != Family.gaussian && _iter < max_iter){\n          ++_iter;\n          boolean validate = higher_accuracy || (System.currentTimeMillis() - lastValidation) > 8e3;\n          new GLMIterationTask(GLM2.this,_dinfo,glmt._glm, true, validate, higher_accuracy,newBeta,_ymu,_reg,new Iteration()).asyncExec(_dinfo._adaptedFrame);\n          return;\n        }\n      }\n      // done with this lambda\n      nextLambda(glmt);\n    }","commit_id":"63f281d61f9c982bf16604d4181e792e46346d36","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void nextLambda(final GLMIterationTask glmt){\n    System.out.println(\"computing validation at t = \" + (System.currentTimeMillis() - start));\n    // We're done with this lambda, launch validation\n    H2OCallback fin = new H2OCallback<GLMValidationTask>() {\n      @Override public void callback(GLMValidationTask tsk) {\n        System.out.println(\"validation computed at t = \" + (System.currentTimeMillis() - start));\n        boolean improved = _model.setAndTestValidation(_lambdaIdx,tsk._res);\n        _model.clone().update(self());\n        if((improved || _runAllLambdas) && _lambdaIdx < (lambda.length-1) ){ // continue with next lambda value?\n          glmt._val = null;\n          ++_lambdaIdx;\n          new Iteration().callback(glmt);\n        } else    // nope, we're done\n          GLM2.this.complete(); // signal we're done to anyone waiting for the job\n      }\n      @Override public boolean onExceptionalCompletion(Throwable ex, CountedCompleter cc){\n        GLM2.this.cancel(ex);\n        return true;\n      }\n    };\n    if(GLM2.this.n_folds >= 2) xvalidate(_model.clone(), _lambdaIdx, fin);\n    else  new GLMValidationTask(_model.clone(),_lambdaIdx,fin).asyncExec(_dinfo._adaptedFrame);\n  }","id":81785,"modified_method":"public void nextLambda(final GLMIterationTask glmt){\n    System.out.println(\"computing validation at t = \" + (System.currentTimeMillis() - start));\n    // We're done with this lambda, launch validation\n    if(glmt._val == null || glmt._grad == null){\n      // validate and check gradietn whether we have right result\n      new GLMIterationTask(GLM2.this,_dinfo,_glm,false,true,true,glmt._beta,_ymu,_reg,new H2OCallback<GLMIterationTask>() {\n        @Override public void callback(GLMIterationTask g){nextLambda2(g);}\n        @Override public boolean onExceptionalCompletion(Throwable ex, CountedCompleter cc){\n          GLM2.this.cancel(ex);\n          return true;\n        }\n      }).asyncExec(_dinfo._adaptedFrame);\n    } else nextLambda2(glmt);\n  }","commit_id":"63f281d61f9c982bf16604d4181e792e46346d36","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected void chunkDone(){\n      _gram.mul(_reg);\n      if(_val != null)_val.regularize(_reg);\n      for(int i = 0; i < _xy.length; ++i)\n        _xy[i] *= _reg;\n      _yy *= _reg;\n    }","id":81786,"modified_method":"@Override protected void chunkDone(){\n      _gram.mul(_reg);\n      if(_val != null)_val.regularize(_reg);\n      for(int i = 0; i < _xy.length; ++i)\n        _xy[i] *= _reg;\n      if(_grad != null)\n        for(int i = 0; i < _grad.length; ++i)\n          _grad[i] *= _reg;\n\n      _yy *= _reg;\n    }","commit_id":"63f281d61f9c982bf16604d4181e792e46346d36","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void callback(final GLMIterationTask glmt){\n      assert _activeCols == null || glmt._beta == null || glmt._beta.length == (_activeCols.length+1):LogInfo(\"betalen = \" + glmt._beta.length + \", activecols = \" + _activeCols.length);\n      assert _activeCols == null || _activeCols.length == _activeData.fullN();\n      assert getCompleter().getPendingCount() >= 1:LogInfo(\"unexpected pending count, expected >=  1, got \" + getCompleter().getPendingCount()); // will be decreased by 1 after we leave this callback\n      if(_countIteration)++_iter;\n      _callbackStart = System.currentTimeMillis();\n      LogInfo(\"iteration done in \" + (_callbackStart - _iterationStartTime) + \"ms\");\n      if( !isRunning(self()) )  throw new JobCancelledException();\n      boolean gotNaNsorInfs = Utils.hasNaNsOrInfs(glmt._xy) || glmt._gram.hasNaNsOrInfs();\n      boolean constBeta = true;\n      if(gotNaNsorInfs){\n        LogInfo(\"got NaNs/Infs, invoking line-search.\");\n        setHighAccuracy();\n        if(_lastResult == null) {\n          if(glmt._beta == null) // failed in first iteration! throw an error\n            throw new RuntimeException(LogInfo(\"GLM2: can not solve. Got NaNs/Infs in the first iteration\"));\n          for (int i = 0; i < glmt._beta.length; ++i) {\n            glmt._beta[i] *= 0.5;\n            constBeta &= glmt._beta[i] < beta_epsilon;\n          }\n        } else {\n          assert !Arrays.equals(glmt._beta,_lastResult._glmt._beta);\n          double [] lastBeta = resizeVec(_lastResult._glmt._beta,_activeCols,_lastResult._activeCols);\n          for (int i = 0; i < glmt._beta.length; ++i) {\n            glmt._beta[i] = 0.5 * (glmt._beta[i] + lastBeta[i]);\n            double diff = (glmt._beta[i] - lastBeta[i]);\n            constBeta &= (-beta_epsilon < diff && diff < beta_epsilon);\n          }\n        }\n        if(constBeta) { // line search failed to progress -> converge (if we a valid solution already, otherwise fail!)\n          if(_lastResult == null)throw new RuntimeException(LogInfo(\"GLM failed to solve! Got NaNs/Infs in the first iteration and line search did not help!\"));\n          checkKKTAndComplete(_lastResult._glmt.clone(),_lastResult._glmt._beta,false);\n          return;\n        } else // do the line search iteration\n          new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, true, true, glmt._beta,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),true)).asyncExec(_activeData._adaptedFrame);\n        return;\n      }\n      if(glmt._val != null){\n        if(family != Family.gaussian && !(glmt._val.residual_deviance <= glmt._val.null_deviance)){ // complete fail, look if we can restart with higher_accuracy on\n          if(!highAccuracy()){\n            LogInfo(\"reached negative explained deviance without line-search, rerunning with high accuracy settings.\");\n            setHighAccuracy();\n            if(_lastResult != null)\n              new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, true, true, _lastResult._glmt._beta,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),false)).asyncExec(_activeData._adaptedFrame);\n            else if(_lambdaIdx > 2) // > 2 because 0 is null model, we don't wan to run with that\n                throw H2O.unimpl();\n//              new GLMIterationTask(GLM2.this,_activeData,glmt._glm, true, true, true, _model.submodels[_lambdaIdx-1].norm_beta,_ymu,1.0/_nobs,thresholds, new Iteration()).asyncExec(_activeData._adaptedFrame);\n            else // no sane solution to go back to, start from scratch!\n              new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, false, false, null,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),false)).asyncExec(_activeData._adaptedFrame);\n            _lastResult = null;\n            return;\n          }\n        }\n      }\n\n      if(glmt._val != null && glmt._computeGradient){ // check gradient\n        final double [] grad = glmt.gradient(alpha[0],_currentLambda);\n        ADMMSolver.subgrad(alpha[0], _currentLambda, glmt._beta, grad);\n        double err = 0;\n        for(double d:grad)\n          if(d > err) err = d;\n          else if(d < -err) err = -d;\n        LogInfo(\"gradient after \" + _iter + \" iterations = \" + err);\n        if(_doLineSearch && err <= GLM_GRAD_EPS){\n          LogInfo(\"converged by reaching small enough gradient, with max |subgradient| = \" + err );\n          checkKKTAndComplete(glmt, glmt._beta,false);\n          return;\n        }\n      }\n      if(glmt._beta != null && glmt._val!=null && glmt._computeGradient && _glm.family != Family.tweedie){\n        if(_doLineSearch && needLineSearch(glmt._beta,objval(glmt),1)){\n          if(!highAccuracy()){\n            setHighAccuracy();\n            if(_lastResult._iter < (_iter-2)){ // there is a gap form last result...return to it and start again\n              final double [] prevBeta = _lastResult._activeCols != _activeCols? resizeVec(_lastResult._glmt._beta, _activeCols, _lastResult._activeCols):_lastResult._glmt._beta;\n              new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, true, true, prevBeta, _ymu,1.0/_nobs, thresholds, new Iteration(getCompleter(),false)).asyncExec(_activeData._adaptedFrame);\n              return;\n            }\n          }\n          final double [] b = resizeVec(_lastResult._glmt._beta, _activeCols, _lastResult._activeCols);\n          assert (b.length == glmt._beta.length):LogInfo(b.length + \" != \" + glmt._beta.length + \", pickNextLambda = \" + _activeCols.length);\n          new GLMTask.GLMLineSearchTask(GLM2.this.self(),_activeData,_glm, b,glmt._beta,1e-4,glmt._nobs,alpha[0],_currentLambda, new LineSearchIteration(getCompleter())).asyncExec(_activeData._adaptedFrame);\n          return;\n        }\n        _lastResult = new IterationInfo(GLM2.this._iter-1, glmt,_activeCols,null);\n      }\n      final double [] newBeta = MemoryManager.malloc8d(glmt._xy.length);\n      ADMMSolver slvr = new ADMMSolver(_currentLambda,alpha[0], _gradientEps, _addedL2);\n      slvr._rho = _currentLambda*alpha[0]*_rho_mul;\n      long t1 = System.currentTimeMillis();\n      slvr.solve(glmt._gram,glmt._xy,glmt._yy,newBeta);\n      if(slvr._addedL2 > _addedL2) LogInfo(\"added \" + (slvr._addedL2 - _addedL2) + \"L2 penalty\");\n      LogInfo(\"ADMM: \" + slvr.iterations + \" iterationss, \" + (System.currentTimeMillis()-t1) + \"ms (\" + slvr.decompTime + \"), subgrad_err=\" + slvr.gerr);\n      new GLM2_ProgressUpdate().fork(_progressKey); // update progress\n      _gradientEps = Math.max(ADMM_GRAD_EPS,Math.min(slvr.gerr,0.01));\n      _addedL2 = slvr._addedL2;\n      if(Utils.hasNaNsOrInfs(newBeta)){\n        throw new RuntimeException(LogInfo(\"got NaNs and/or Infs in beta\"));\n      } else {\n        final double bdiff = beta_diff(glmt._beta,newBeta);\n        if(_glm.family == Family.gaussian || bdiff < beta_epsilon || _iter >= max_iter){ // Gaussian is non-iterative and gradient is ADMMSolver's gradient => just validate and move on to the next lambda_value\n          int diff = (int)Math.log10(bdiff);\n          int nzs = 0;\n          for(int i = 0; i < newBeta.length; ++i)\n            if(newBeta[i] != 0) ++nzs;\n          LogInfo(\"converged (reached a fixed point with ~ 1e\" + diff + \" precision), got \" + nzs + \" nzs\");\n          checkKKTAndComplete(glmt,newBeta,false);\n          return;\n        } else { // not done yet, launch next iteration\n          if(glmt._beta != null)\n            setSubmodel(glmt._beta, glmt._val,(H2OCountedCompleter)getCompleter().getCompleter()); // update current intermediate result\n          final boolean validate = higher_accuracy || (_iter % 5) == 0;\n          new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, validate, validate, newBeta,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),validate)).asyncExec(_activeData._adaptedFrame);\n        }\n      }\n    }","id":81787,"modified_method":"@Override public void callback(final GLMIterationTask glmt){\n      assert _activeCols == null || glmt._beta == null || glmt._beta.length == (_activeCols.length+1):LogInfo(\"betalen = \" + glmt._beta.length + \", activecols = \" + _activeCols.length);\n      assert _activeCols == null || _activeCols.length == _activeData.fullN();\n      assert getCompleter().getPendingCount() >= 1:LogInfo(\"unexpected pending count, expected >=  1, got \" + getCompleter().getPendingCount()); // will be decreased by 1 after we leave this callback\n      if(_countIteration)++_iter;\n      _callbackStart = System.currentTimeMillis();\n      LogInfo(\"iteration done in \" + (_callbackStart - _iterationStartTime) + \"ms\");\n      if( !isRunning(self()) )  throw new JobCancelledException();\n      boolean gotNaNsorInfs = Utils.hasNaNsOrInfs(glmt._xy) || glmt._gram.hasNaNsOrInfs();\n      boolean constBeta = true;\n      if(gotNaNsorInfs){\n        LogInfo(\"got NaNs/Infs, invoking line-search.\");\n        setHighAccuracy();\n        if(_lastResult == null) {\n          if(glmt._beta == null) // failed in first iteration! throw an error\n            throw new RuntimeException(LogInfo(\"GLM2: can not solve. Got NaNs/Infs in the first iteration\"));\n          for (int i = 0; i < glmt._beta.length; ++i) {\n            glmt._beta[i] *= 0.5;\n            constBeta &= glmt._beta[i] < beta_epsilon;\n          }\n        } else {\n          assert !Arrays.equals(glmt._beta,_lastResult._glmt._beta);\n          double [] lastBeta = resizeVec(_lastResult._glmt._beta,_activeCols,_lastResult._activeCols);\n          for (int i = 0; i < glmt._beta.length; ++i) {\n            glmt._beta[i] = 0.5 * (glmt._beta[i] + lastBeta[i]);\n            double diff = (glmt._beta[i] - lastBeta[i]);\n            constBeta &= (-beta_epsilon < diff && diff < beta_epsilon);\n          }\n        }\n        if(constBeta) { // line search failed to progress -> converge (if we a valid solution already, otherwise fail!)\n          if(_lastResult == null)throw new RuntimeException(LogInfo(\"GLM failed to solve! Got NaNs/Infs in the first iteration and line search did not help!\"));\n          checkKKTAndComplete(_lastResult._glmt.clone(),_lastResult._glmt._beta,false);\n          return;\n        } else // do the line search iteration\n          new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, true, true, glmt._beta,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),true)).asyncExec(_activeData._adaptedFrame);\n        return;\n      }\n      if(glmt._val != null){\n        if(family != Family.gaussian && !(glmt._val.residual_deviance <= glmt._val.null_deviance)){ // complete fail, look if we can restart with higher_accuracy on\n          if(!highAccuracy()){\n            LogInfo(\"reached negative explained deviance without line-search, rerunning with high accuracy settings.\");\n            setHighAccuracy();\n            if(_lastResult != null && Arrays.equals(_lastResult._activeCols,_activeCols))\n              new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, true, true, _lastResult._glmt._beta,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),false)).asyncExec(_activeData._adaptedFrame);\n            else // no sane solution to go back to, start from scratch!\n              new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, false, false, null,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),false)).asyncExec(_activeData._adaptedFrame);\n            _lastResult = null;\n            return;\n          }\n        }\n      }\n\n      if(glmt._val != null && glmt._computeGradient){ // check gradient\n        final double [] grad = glmt.gradient(alpha[0],_currentLambda);\n        ADMMSolver.subgrad(alpha[0], _currentLambda, glmt._beta, grad);\n        double err = 0;\n        for(double d:grad)\n          if(d > err) err = d;\n          else if(d < -err) err = -d;\n        LogInfo(\"gradient after \" + _iter + \" iterations = \" + err);\n        if(_doLineSearch && err <= GLM_GRAD_EPS){\n          LogInfo(\"converged by reaching small enough gradient, with max |subgradient| = \" + err );\n          checkKKTAndComplete(glmt, glmt._beta,false);\n          return;\n        }\n      }\n      if(glmt._beta != null && glmt._val!=null && glmt._computeGradient && _glm.family != Family.tweedie){\n        if(_doLineSearch && needLineSearch(glmt._beta,objval(glmt),1)){\n          if(!highAccuracy()){\n            setHighAccuracy();\n            if(_lastResult._iter < (_iter-2)){ // there is a gap form last result...return to it and start again\n              final double [] prevBeta = _lastResult._activeCols != _activeCols? resizeVec(_lastResult._glmt._beta, _activeCols, _lastResult._activeCols):_lastResult._glmt._beta;\n              new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, true, true, prevBeta, _ymu,1.0/_nobs, thresholds, new Iteration(getCompleter(),false)).asyncExec(_activeData._adaptedFrame);\n              return;\n            }\n          }\n          final double [] b = resizeVec(_lastResult._glmt._beta, _activeCols, _lastResult._activeCols);\n          assert (b.length == glmt._beta.length):LogInfo(b.length + \" != \" + glmt._beta.length + \", pickNextLambda = \" + _activeCols.length);\n          new GLMTask.GLMLineSearchTask(GLM2.this.self(),_activeData,_glm, b,glmt._beta,1e-4,glmt._nobs,alpha[0],_currentLambda, new LineSearchIteration(getCompleter())).asyncExec(_activeData._adaptedFrame);\n          return;\n        }\n        _lastResult = new IterationInfo(GLM2.this._iter-1, glmt,_activeCols,null);\n      }\n      final double [] newBeta = MemoryManager.malloc8d(glmt._xy.length);\n      ADMMSolver slvr = new ADMMSolver(_currentLambda,alpha[0], _gradientEps, _addedL2);\n      slvr._rho = _currentLambda*alpha[0]*_rho_mul;\n      long t1 = System.currentTimeMillis();\n      slvr.solve(glmt._gram,glmt._xy,glmt._yy,newBeta);\n      if(slvr._addedL2 > _addedL2) LogInfo(\"added \" + (slvr._addedL2 - _addedL2) + \"L2 penalty\");\n      LogInfo(\"ADMM: \" + slvr.iterations + \" iterationss, \" + (System.currentTimeMillis()-t1) + \"ms (\" + slvr.decompTime + \"), subgrad_err=\" + slvr.gerr);\n      new GLM2_ProgressUpdate().fork(_progressKey); // update progress\n      _gradientEps = Math.max(ADMM_GRAD_EPS,Math.min(slvr.gerr,0.01));\n      _addedL2 = slvr._addedL2;\n      if(Utils.hasNaNsOrInfs(newBeta)){\n        throw new RuntimeException(LogInfo(\"got NaNs and/or Infs in beta\"));\n      } else {\n        final double bdiff = beta_diff(glmt._beta,newBeta);\n        if(_glm.family == Family.gaussian || bdiff < beta_epsilon || _iter >= max_iter){ // Gaussian is non-iterative and gradient is ADMMSolver's gradient => just validate and move on to the next lambda_value\n          int diff = (int)Math.log10(bdiff);\n          int nzs = 0;\n          for(int i = 0; i < newBeta.length; ++i)\n            if(newBeta[i] != 0) ++nzs;\n          LogInfo(\"converged (reached a fixed point with ~ 1e\" + diff + \" precision), got \" + nzs + \" nzs\");\n          checkKKTAndComplete(glmt,newBeta,false);\n          return;\n        } else { // not done yet, launch next iteration\n          if(glmt._beta != null)\n            setSubmodel(glmt._beta, glmt._val,(H2OCountedCompleter)getCompleter().getCompleter()); // update current intermediate result\n          final boolean validate = higher_accuracy || (_iter % 5) == 0;\n          new GLMIterationTask(GLM2.this.self(),_activeData,glmt._glm, true, validate, validate, newBeta,_ymu,1.0/_nobs,thresholds, new Iteration(getCompleter(),validate)).asyncExec(_activeData._adaptedFrame);\n        }\n      }\n    }","commit_id":"60a9519830e5c7dd81b483148d44b7f8e77cf6bc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n\tpublic void resourceChanged(IResourceChangeEvent event) {\n\t    if (viewer.getTree().isDisposed()) {\n\t        return;\n\t    }\n\t\ttry {\n\t\t\tfinal List<IResource> toBeRefreshed = new LinkedList<IResource>();\n\t\t\tevent.getDelta().accept(new IResourceDeltaVisitor() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean visit(IResourceDelta delta) throws CoreException {\n\t\t\t\t\tif (delta.getResource() instanceof IContainer) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tIProject p = delta.getResource().getProject();\n\t\t\t\t\tIFolder syncDir = getSyncDir(p);\n\t\t\t\t\tif (syncDir==null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\ttoBeRefreshed.add(syncDir.getProject());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (toBeRefreshed.size()==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (Iterator<IResource> it = toBeRefreshed.iterator(); it\n\t\t\t\t\t.hasNext();) {\n\t\t\t\tfinal IResource iResource = it.next();\n\t\t\t\tviewer.getTree().getDisplay().asyncExec(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tviewer.refresh(iResource.getProject(), true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\t//TODO proper logging\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":81788,"modified_method":"@Override\n\tpublic void resourceChanged(IResourceChangeEvent event) {\n\t    if (viewer.getTree().isDisposed()) {\n\t        return;\n\t    }\n\t\ttry {\n            final Set<IProject> toBeRefreshed = new HashSet<IProject>();\n\t\t\tevent.getDelta().accept(new IResourceDeltaVisitor() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean visit(IResourceDelta delta) throws CoreException {\n\t\t\t\t\tif (delta.getResource() instanceof IContainer) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tIProject p = delta.getResource().getProject();\n\t\t\t\t\tIFolder syncDir = getSyncDir(p);\n\t\t\t\t\tif (syncDir==null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\ttoBeRefreshed.add(syncDir.getProject());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n            for (final IProject project : toBeRefreshed) {\n\t\t\t\tviewer.getTree().getDisplay().asyncExec(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n                        long start = System.currentTimeMillis();\n                        viewer.refresh(project, true);\n                        long end = System.currentTimeMillis();\n                        Activator.getDefault().getPluginLogger()\n                                .tracePerformance(\"viewer.refresh({0},true)\", (end - start), project);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\t//TODO proper logging\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"f38c2ff7b6d729ee3d2e8eaded1b19610cfb9265","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\tpublic Object[] getChildren(Object parentElement) {\n\t\tif (parentElement instanceof IProject) {\n\t\t\treturn projectGetChildren((IProject)parentElement);\n\t\t} else if (parentElement instanceof JcrNode) {\n\t\t\tJcrNode node = (JcrNode)parentElement;\n\t\t\treturn node.getChildren(true);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":81789,"modified_method":"@Override\n\tpublic Object[] getChildren(Object parentElement) {\n\t\tif (parentElement instanceof IProject) {\n\t\t\treturn projectGetChildren((IProject)parentElement);\n\t\t} else if (parentElement instanceof JcrNode) {\n            long start = System.currentTimeMillis();\n\t\t\tJcrNode node = (JcrNode)parentElement;\n            Object[] children = node.getChildren(true);\n            long end = System.currentTimeMillis();\n            Activator.getDefault().getPluginLogger()\n                    .tracePerformance(\"node.getChildren for node at {0}\", (end - start), node.getJcrPath());\n            return children;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"f38c2ff7b6d729ee3d2e8eaded1b19610cfb9265","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\tpublic Image getImage(Object element) {\n\t\tif (element instanceof JcrNode) {\n\t\t\tJcrNode jcrNode = (JcrNode)element;\n\t\t\treturn jcrNode.getImage();\n\t\t} else {\n\t\t\t// fallback to default\n\t\t\treturn null;\n\t\t}\n\t}","id":81790,"modified_method":"@Override\n\tpublic Image getImage(Object element) {\n\t\tif (element instanceof JcrNode) {\n\t\t\tJcrNode jcrNode = (JcrNode)element;\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tImage image = jcrNode.getImage();\n\t\t\tlong end = System.currentTimeMillis();\n            Activator.getDefault().getPluginLogger()\n                    .tracePerformance(\"getImage for node at {0}\", (end - start), jcrNode.getJcrPath());\n            return image;\n\t\t} else {\n\t\t\t// fallback to default\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"f38c2ff7b6d729ee3d2e8eaded1b19610cfb9265","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void optionsChanged(DebugOptions options) {\n    \t\n        String pluginId = plugin.getBundle().getSymbolicName();\n\n        debugEnabled = options.getBooleanOption(pluginId + \"/debug\", false);\n        consoleEnabled = options.getBooleanOption(pluginId + \"/debug/console\", false) && debugEnabled;\n        trace = options.newDebugTrace(pluginId, getClass());\n    }","id":81791,"modified_method":"@Override\n    public void optionsChanged(DebugOptions options) {\n    \t\n        String pluginId = plugin.getBundle().getSymbolicName();\n\n        debugEnabled = options.getBooleanOption(pluginId + \"/debug\", false);\n        consoleEnabled = options.getBooleanOption(pluginId + \"/debug/console\", false) && debugEnabled;\n        performanceEnabled = options.getBooleanOption(pluginId + \"/debug/performance\", false) && debugEnabled;\n        trace = options.newDebugTrace(pluginId, getClass());\n    }","commit_id":"f38c2ff7b6d729ee3d2e8eaded1b19610cfb9265","url":"https://github.com/apache/sling"},{"original_method":"/**\n     *  If verifySig is true,\n     *  this validates the signature while reading in,\n     *  and throws a DataFormatException if the sig is invalid.\n     *  This is faster than reserializing to validate later.\n     *\n     *  @throws IllegalStateException if RouterInfo was already read in\n     *  @since 0.9\n     */\n    public void readBytes(InputStream in, boolean verifySig) throws DataFormatException, IOException {\n        if (_signature != null)\n            throw new IllegalStateException();\n        InputStream din;\n        MessageDigest digest;\n        if (verifySig) {\n            digest = SHA1.getInstance();\n            din = new DigestInputStream(in, digest);\n        } else {\n            digest = null;\n            din = in;\n        }\n        _identity = new RouterIdentity();\n        _identity.readBytes(din);\n        // avoid thrashing objects\n        //Date when = DataHelper.readDate(in);\n        //if (when == null)\n        //    _published = 0;\n        //else\n        //    _published = when.getTime();\n        _published = DataHelper.readLong(din, 8);\n        int numAddresses = (int) DataHelper.readLong(din, 1);\n        for (int i = 0; i < numAddresses; i++) {\n            RouterAddress address = new RouterAddress();\n            address.readBytes(din);\n            _addresses.add(address);\n        }\n        int numPeers = (int) DataHelper.readLong(din, 1);\n        if (numPeers == 0) {\n            _peers = null;\n        } else {\n            _peers = new HashSet<Hash>(numPeers);\n            for (int i = 0; i < numPeers; i++) {\n                Hash peerIdentityHash = new Hash();\n                peerIdentityHash.readBytes(din);\n                _peers.add(peerIdentityHash);\n            }\n        }\n        DataHelper.readProperties(din, _options);\n        _signature = new Signature(_identity.getSigningPublicKey().getType());\n        _signature.readBytes(in);\n\n        if (verifySig) {\n            SHA1Hash hash = new SHA1Hash(digest.digest());\n            _isValid = DSAEngine.getInstance().verifySignature(_signature, hash, _identity.getSigningPublicKey());\n            _validated = true;\n            if (!_isValid) {\n                throw new DataFormatException(\"Bad sig\");\n            }\n        }\n\n        //_log.debug(\"Read routerInfo: \" + toString());\n    }","id":81792,"modified_method":"/**\n     *  If verifySig is true,\n     *  this validates the signature while reading in,\n     *  and throws a DataFormatException if the sig is invalid.\n     *  This is faster than reserializing to validate later.\n     *\n     *  @throws IllegalStateException if RouterInfo was already read in\n     *  @since 0.9\n     */\n    public void readBytes(InputStream in, boolean verifySig) throws DataFormatException, IOException {\n        if (_signature != null)\n            throw new IllegalStateException();\n        _identity = new RouterIdentity();\n        _identity.readBytes(in);\n        // can't set the digest until we know the sig type\n        InputStream din;\n        MessageDigest digest;\n        if (verifySig) {\n            SigType type = _identity.getSigningPublicKey().getType();\n            if (type != SigType.EdDSA_SHA512_Ed25519) {\n                // This won't work for EdDSA\n                digest = _identity.getSigningPublicKey().getType().getDigestInstance();\n                // TODO any better way?\n                digest.update(_identity.toByteArray());\n                din = new DigestInputStream(in, digest);\n            } else {\n                digest = null;\n                din = in;\n            }\n        } else {\n            digest = null;\n            din = in;\n        }\n        // avoid thrashing objects\n        //Date when = DataHelper.readDate(in);\n        //if (when == null)\n        //    _published = 0;\n        //else\n        //    _published = when.getTime();\n        _published = DataHelper.readLong(din, 8);\n        int numAddresses = (int) DataHelper.readLong(din, 1);\n        for (int i = 0; i < numAddresses; i++) {\n            RouterAddress address = new RouterAddress();\n            address.readBytes(din);\n            _addresses.add(address);\n        }\n        int numPeers = (int) DataHelper.readLong(din, 1);\n        if (numPeers == 0) {\n            _peers = null;\n        } else {\n            _peers = new HashSet<Hash>(numPeers);\n            for (int i = 0; i < numPeers; i++) {\n                Hash peerIdentityHash = new Hash();\n                peerIdentityHash.readBytes(din);\n                _peers.add(peerIdentityHash);\n            }\n        }\n        DataHelper.readProperties(din, _options);\n        _signature = new Signature(_identity.getSigningPublicKey().getType());\n        _signature.readBytes(in);\n\n        if (verifySig) {\n            SigType type = _identity.getSigningPublicKey().getType();\n            if (type != SigType.EdDSA_SHA512_Ed25519) {\n                // This won't work for EdDSA\n                SimpleDataStructure hash = _identity.getSigningPublicKey().getType().getHashInstance();\n                hash.setData(digest.digest());\n                _isValid = DSAEngine.getInstance().verifySignature(_signature, hash, _identity.getSigningPublicKey());\n                _validated = true;\n            } else {\n                doValidate();\n            }\n            if (!_isValid) {\n                throw new DataFormatException(\"Bad sig\");\n            }\n        }\n\n        //_log.debug(\"Read routerInfo: \" + toString());\n    }","commit_id":"a72866ee6aca2adc58d592b5119411302ed6f2ce","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private IdArrayBasedBlob decodeBlob(ByteBuf in, int length, byte type) {\n        int inIdLen = in.readInt();\n        byte[] bid = new byte[inIdLen];\n        in.readBytes(bid);\n        String id = new String(bid, Charset.forName(\"UTF-8\"));\n\n        long hash = in.readLong();\n        byte[] blob = new byte[length];\n        in.readBytes(blob);\n        Hasher hasher = Hashing.murmur3_32().newHasher();\n        long check = hasher.putBytes(blob).hash().padToLong();\n        if (hash == check) {\n            log.debug(\"received blob with id {} and size {}\", id, blob.length);\n            return new IdArrayBasedBlob(blob, id);\n        }\n        log.debug(\"received corrupted binary {}, ignoring\", id);\n        return null;\n    }","id":81793,"modified_method":"private IdArrayBasedBlob decodeBlob(ByteBuf in, int length, byte type) {\n        int inIdLen = in.readInt();\n        byte[] bid = new byte[inIdLen];\n        in.readBytes(bid);\n        String id = new String(bid, Charset.forName(\"UTF-8\"));\n\n        long hash = in.readLong();\n        // #readBytes throws a 'REPLAY' exception if there are not enough bytes\n        // available for reading\n        ByteBuf data = in.readBytes(length);\n        byte[] blob;\n        if (data.hasArray()) {\n            blob = data.array();\n        } else {\n            blob = new byte[length];\n            data.readBytes(blob);\n        }\n\n        Hasher hasher = Hashing.murmur3_32().newHasher();\n        long check = hasher.putBytes(blob).hash().padToLong();\n        if (hash == check) {\n            log.debug(\"received blob with id {} and size {}\", id, blob.length);\n            return new IdArrayBasedBlob(blob, id);\n        }\n        log.debug(\"received corrupted binary {}, ignoring\", id);\n        return null;\n    }","commit_id":"7712579a2c9c7888478f439251a57fe81fc6442a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Segment decodeSegment(ByteBuf in, int len, byte type) {\n        long msb = in.readLong();\n        long lsb = in.readLong();\n        long hash = in.readLong();\n        byte[] segment = new byte[len - 25];\n        in.readBytes(segment);\n        Hasher hasher = Hashing.murmur3_32().newHasher();\n        long check = hasher.putBytes(segment).hash().padToLong();\n        if (hash == check) {\n            SegmentId id = new SegmentId(store.getTracker(), msb, lsb);\n            Segment s = new Segment(store.getTracker(), id,\n                    ByteBuffer.wrap(segment));\n            log.debug(\"received segment with id {} and size {}\", id, s.size());\n            return s;\n        }\n        log.debug(\"received corrupted segment {}, ignoring\", new UUID(msb, lsb));\n        return null;\n    }","id":81794,"modified_method":"private Segment decodeSegment(ByteBuf in, int len, byte type) {\n        long msb = in.readLong();\n        long lsb = in.readLong();\n        long hash = in.readLong();\n\n        // #readBytes throws a 'REPLAY' exception if there are not enough bytes\n        // available for reading\n        ByteBuf data = in.readBytes(len - 25);\n        byte[] segment;\n        if (data.hasArray()) {\n            segment = data.array();\n        } else {\n            segment = new byte[len - 25];\n            in.readBytes(segment);\n        }\n\n        Hasher hasher = Hashing.murmur3_32().newHasher();\n        long check = hasher.putBytes(segment).hash().padToLong();\n        if (hash == check) {\n            SegmentId id = new SegmentId(store.getTracker(), msb, lsb);\n            Segment s = new Segment(store.getTracker(), id,\n                    ByteBuffer.wrap(segment));\n            log.debug(\"received segment with id {} and size {}\", id, s.size());\n            return s;\n        }\n        log.debug(\"received corrupted segment {}, ignoring\", new UUID(msb, lsb));\n        return null;\n    }","commit_id":"7712579a2c9c7888478f439251a57fe81fc6442a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static Object getObjectForMessage(Message source) throws JMSException\n    {\n        Object result;\n        try\n        {\n            if (source instanceof ObjectMessage)\n            {\n                result = ((ObjectMessage)source).getObject();\n            }\n            else if (source instanceof MapMessage)\n            {\n                Hashtable map = new Hashtable();\n                MapMessage m = (MapMessage)source;\n\n                for (Enumeration e = m.getMapNames(); e.hasMoreElements();)\n                {\n                    String name = (String)e.nextElement();\n                    Object obj = m.getObject(name);\n                    map.put(name, obj);\n                }\n\n                result = map;\n            }\n            else if (source instanceof BytesMessage)\n            {\n                BytesMessage bm = (BytesMessage)source;\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n                byte[] buffer = new byte[1024 * 4];\n                int len;\n                bm.reset();\n                while ((len = bm.readBytes(buffer)) != -1)\n                {\n                    baos.write(buffer, 0, len);\n                }\n                baos.flush();\n                result = baos.toByteArray();\n                baos.close();\n                if (result != null)\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        logger.debug(\"JMSToObject: extracted \" + ((byte[])result).length\n                                     + \" bytes from JMS BytesMessage\");\n                    }\n                }\n            }\n            else if (source instanceof TextMessage)\n            {\n                result = ((TextMessage)source).getText();\n            }\n            else if (source instanceof BytesMessage)\n            {\n                byte[] bytes = getBytesFromMessage(source);\n                return CompressionHelper.getDefaultCompressionStrategy().uncompressByteArray(bytes);\n            }\n            else if (source instanceof StreamMessage)\n            {\n                StreamMessage sm = (StreamMessage)source;\n\n                result = new Vector();\n                try\n                {\n                    Object obj;\n                    while ((obj = sm.readObject()) != null)\n                    {\n                        ((Vector)result).addElement(obj);\n                    }\n                }\n                catch (MessageEOFException eof)\n                {\n                    // ignored\n                }\n                catch (Exception e)\n                {\n                    throw new JMSException(\"Failed to extract information from JMS Stream Message: \" + e);\n                }\n            }\n            else\n            {\n                result = source;\n            }\n        }\n        catch (Exception e)\n        {\n            throw new JMSException(\"Failed to transform message: \" + e.getMessage());\n        }\n        return result;\n    }","id":81795,"modified_method":"public static Object getObjectForMessage(Message source) throws JMSException, IOException\n    {\n        if (source instanceof ObjectMessage)\n        {\n            return ((ObjectMessage)source).getObject();\n        }\n        else if (source instanceof MapMessage)\n        {\n            Hashtable map = new Hashtable();\n            MapMessage m = (MapMessage)source;\n\n            for (Enumeration e = m.getMapNames(); e.hasMoreElements();)\n            {\n                String name = (String)e.nextElement();\n                Object obj = m.getObject(name);\n                map.put(name, obj);\n            }\n\n            return map;\n        }\n        else if (source instanceof TextMessage)\n        {\n            return ((TextMessage)source).getText();\n        }\n        else if (source instanceof BytesMessage)\n        {\n            byte[] bytes = getBytesFromMessage(source);\n            return CompressionHelper.getDefaultCompressionStrategy().uncompressByteArray(bytes);\n        }\n        else if (source instanceof StreamMessage)\n        {\n            try\n            {\n                StreamMessage sMsg = (StreamMessage)source;\n                Vector result = new Vector();\n                Object obj;\n                while ((obj = sMsg.readObject()) != null)\n                {\n                    result.addElement(obj);\n                }\n                return result;\n            }\n            catch (MessageEOFException eof)\n            {\n                // ignored\n            }\n            catch (Exception e)\n            {\n                throw new JMSException(\"Failed to extract information from JMS Stream Message: \" + e);\n            }\n        }\n\n        // what else is there to do?\n        return source;\n    }","commit_id":"5261c656844e4b7dfedf2441dec1aa970792969f","url":"https://github.com/mulesoft/mule"},{"original_method":"public static Message getMessageForObject(Object object, Session session) throws JMSException\n    {\n        if (object instanceof Message)\n        {\n            return (Message)object;\n        }\n        else if (object instanceof String)\n        {\n            TextMessage text = session.createTextMessage((String)object);\n            return text;\n        }\n        else if (object instanceof Map)\n        {\n            MapMessage map = session.createMapMessage();\n            Map.Entry entry;\n            Map temp = (Map)object;\n\n            for (Iterator i = temp.entrySet().iterator(); i.hasNext();)\n            {\n                entry = (Map.Entry)i.next();\n                map.setObject(entry.getKey().toString(), entry.getValue());\n            }\n\n            return map;\n        }\n        else if (object instanceof InputStream)\n        {\n            StreamMessage stream = session.createStreamMessage();\n            InputStream temp = (InputStream)object;\n\n            byte[] buffer = new byte[1024 * 4];\n            int len;\n            try\n            {\n                while ((len = temp.read(buffer)) != -1)\n                {\n                    stream.writeBytes(buffer, 0, len);\n                }\n            }\n            catch (IOException e)\n            {\n                throw new JMSException(\"Failed to read input stream to create a stream message: \" + e);\n            }\n\n            return stream;\n        }\n        else if (object instanceof byte[])\n        {\n            BytesMessage bytes = session.createBytesMessage();\n            byte[] buf = (byte[])object;\n            for (int i = 0; i < buf.length; i++)\n            {\n                bytes.writeByte(buf[i]);\n            }\n\n            return bytes;\n        }\n        else if (object instanceof Serializable)\n        {\n            ObjectMessage oMsg = session.createObjectMessage();\n            oMsg.setObject((Serializable)object);\n            return oMsg;\n        }\n        else\n        {\n            throw new JMSException(\n                \"Source was not a supported type, data must be Serializable, String, byte[], Map or InputStream\");\n        }\n    }","id":81796,"modified_method":"public static Message getMessageForObject(Object object, Session session) throws JMSException\n    {\n        if (object instanceof Message)\n        {\n            return (Message)object;\n        }\n        else if (object instanceof String)\n        {\n            return session.createTextMessage((String)object);\n        }\n        else if (object instanceof Map)\n        {\n            MapMessage mMsg = session.createMapMessage();\n            Map src = (Map)object;\n\n            for (Iterator i = src.entrySet().iterator(); i.hasNext();)\n            {\n                Map.Entry entry = (Map.Entry)i.next();\n                mMsg.setObject(entry.getKey().toString(), entry.getValue());\n            }\n\n            return mMsg;\n        }\n        else if (object instanceof InputStream)\n        {\n            StreamMessage sMsg = session.createStreamMessage();\n            InputStream temp = (InputStream)object;\n\n            byte[] buffer = new byte[4096];\n            int len;\n\n            try\n            {\n                while ((len = temp.read(buffer)) != -1)\n                {\n                    sMsg.writeBytes(buffer, 0, len);\n                }\n            }\n            catch (IOException e)\n            {\n                throw new JMSException(\"Failed to read input stream to create a stream message: \" + e);\n            }\n\n            return sMsg;\n        }\n        else if (object instanceof byte[])\n        {\n            BytesMessage bMsg = session.createBytesMessage();\n            bMsg.writeBytes((byte[])object);\n            return bMsg;\n        }\n        else if (object instanceof Serializable)\n        {\n            ObjectMessage oMsg = session.createObjectMessage();\n            oMsg.setObject((Serializable)object);\n            return oMsg;\n        }\n        else\n        {\n            throw new JMSException(\n                \"Source was not a supported type, data must be Serializable, String, byte[], Map or InputStream\");\n        }\n    }","commit_id":"5261c656844e4b7dfedf2441dec1aa970792969f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * @param message the message to receive the bytes from. Note this only works for\n     *            TextMessge, ObjectMessage, StreamMessage and BytesMessage.\n     * @return a byte array corresponding with the message payload\n     * @throws JMSException if the message can't be read or if the message passed is\n     *             a MapMessage\n     * @throws java.io.IOException if a failiare occurs while stream and converting\n     *             the message data\n     */\n    public static byte[] getBytesFromMessage(Message message) throws JMSException, IOException\n    {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024 * 4];\n        int len;\n\n        if (message instanceof BytesMessage)\n        {\n            BytesMessage bMsg = (BytesMessage)message;\n            // put message in read-only mode\n            bMsg.reset();\n            while ((len = bMsg.readBytes(buffer)) != -1)\n            {\n                baos.write(buffer, 0, len);\n            }\n        }\n        else if (message instanceof StreamMessage)\n        {\n            StreamMessage sMsg = (StreamMessage)message;\n            sMsg.reset();\n            while ((len = sMsg.readBytes(buffer)) != -1)\n            {\n                baos.write(buffer, 0, len);\n            }\n        }\n        else if (message instanceof ObjectMessage)\n        {\n            ObjectMessage oMsg = (ObjectMessage)message;\n            ByteArrayOutputStream bs = new ByteArrayOutputStream();\n            ObjectOutputStream os = new ObjectOutputStream(bs);\n            os.writeObject(oMsg.getObject());\n            os.flush();\n            baos.write(bs.toByteArray());\n            os.close();\n            bs.close();\n        }\n        else if (message instanceof TextMessage)\n        {\n            TextMessage tMsg = (TextMessage)message;\n            String tMsgText = tMsg.getText();\n\n            if (null == tMsgText)\n            {\n                // Avoid creating new instances of byte arrays,\n                // even empty ones. The load on this part of the\n                // code can be high.\n                baos.write(ArrayUtils.EMPTY_BYTE_ARRAY);\n            }\n            else\n            {\n                baos.write(tMsgText.getBytes());\n\n            }\n        }\n        else\n        {\n            throw new JMSException(\"Cannot get bytes from Map Message\");\n        }\n\n        baos.flush();\n        byte[] bytes = baos.toByteArray();\n        baos.close();\n        return bytes;\n    }","id":81797,"modified_method":"/**\n     * @param message the message to receive the bytes from. Note this only works for\n     *            TextMessge, ObjectMessage, StreamMessage and BytesMessage.\n     * @return a byte array corresponding with the message payload\n     * @throws JMSException if the message can't be read or if the message passed is\n     *             a MapMessage\n     * @throws java.io.IOException if a failiare occurs while stream and converting\n     *             the message data\n     */\n    public static byte[] getBytesFromMessage(Message message) throws JMSException, IOException\n    {\n        if (message instanceof BytesMessage)\n        {\n            BytesMessage bMsg = (BytesMessage)message;\n            bMsg.reset();\n\n            long bmBodyLength = bMsg.getBodyLength();\n            if (bmBodyLength > Integer.MAX_VALUE)\n            {\n                throw new JMSException(\"Size of BytesMessage exceeds Integer.MAX_VALUE; \"\n                                       + \"please consider using JMS StreamMessage instead\");\n            }\n\n            byte[] bytes = new byte[(int)bmBodyLength];\n            bMsg.readBytes(bytes);\n            return bytes;\n        }\n        else if (message instanceof StreamMessage)\n        {\n            StreamMessage sMsg = (StreamMessage)message;\n            sMsg.reset();\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[4096];\n            int len;\n\n            while ((len = sMsg.readBytes(buffer)) != -1)\n            {\n                baos.write(buffer, 0, len);\n            }\n\n            return baos.toByteArray();\n        }\n        else if (message instanceof ObjectMessage)\n        {\n            ObjectMessage oMsg = (ObjectMessage)message;\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream os = new ObjectOutputStream(baos);\n            os.writeObject(oMsg.getObject());\n            os.flush();\n            os.close();\n            return baos.toByteArray();\n        }\n        else if (message instanceof TextMessage)\n        {\n            TextMessage tMsg = (TextMessage)message;\n            String tMsgText = tMsg.getText();\n\n            if (null == tMsgText)\n            {\n                // Avoid creating new instances of byte arrays, even empty ones. The\n                // load on this part of the code can be high.\n                return ArrayUtils.EMPTY_BYTE_ARRAY;\n            }\n            else\n            {\n                return tMsgText.getBytes();\n            }\n        }\n        else\n        {\n            throw new JMSException(\"Cannot get bytes from Map Message\");\n        }\n    }","commit_id":"5261c656844e4b7dfedf2441dec1aa970792969f","url":"https://github.com/mulesoft/mule"},{"original_method":"void processStatus(final FilePath filePath, final SVNStatus status) throws SVNException {\n    final int wcFormat = status.getWorkingCopyFormat();\n    if (WorkingCopyFormat.ONE_DOT_SEVEN.getFormat() != wcFormat && ISVNWCDb.WC_FORMAT_17 != wcFormat) {\n      loadEntriesFile(filePath);\n    }\n    if (status != null) {\n      FileStatus fStatus = SvnStatusConvertor.convertStatus(status);\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (SvnVcs.svnStatusIsUnversioned(status) || SvnVcs.svnStatusIs(status, SVNStatusType.UNKNOWN)) {\n        final VirtualFile file = filePath.getVirtualFile();\n        if (file != null) {\n          myChangelistBuilder.processUnversionedFile(file);\n        }\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_ADDED)) {\n        myChangelistBuilder.processChangeInList(createChange(null, CurrentContentRevision.create(filePath), fStatus, status),\n                                                changeListNameFromStatus(status), SvnVcs.getKey());\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_CONFLICTED) ||\n               SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_MODIFIED) ||\n               SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_REPLACED) ||\n               propStatus == SVNStatusType.STATUS_MODIFIED ||\n               propStatus == SVNStatusType.STATUS_CONFLICTED) {\n        myChangelistBuilder.processChangeInList(createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status.getRevision()),\n                            CurrentContentRevision.create(filePath), fStatus, status), changeListNameFromStatus(status), SvnVcs.getKey());\n        checkSwitched(filePath, myChangelistBuilder, status, fStatus);\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_DELETED)) {\n        myChangelistBuilder.processChangeInList(\n          createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status.getRevision()), null, fStatus, status),\n          changeListNameFromStatus(status), SvnVcs.getKey());\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_MISSING)) {\n        myChangelistBuilder.processLocallyDeletedFile(createLocallyDeletedChange(filePath, status));\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_IGNORED)) {\n        myChangelistBuilder.processIgnoredFile(filePath.getVirtualFile());\n      }\n      else if (status.isCopied()) {\n        //\n      }\n      else if ((fStatus == FileStatus.NOT_CHANGED || fStatus == FileStatus.SWITCHED) && statusType != SVNStatusType.STATUS_NONE) {\n        VirtualFile file = filePath.getVirtualFile();\n        if (file != null && FileDocumentManager.getInstance().isFileModified(file)) {\n          myChangelistBuilder.processChangeInList(createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status.getRevision()),\n                                                   CurrentContentRevision.create(filePath), FileStatus.MODIFIED, status), changeListNameFromStatus(status),\n                                                  SvnVcs.getKey());\n        } else if (status.getTreeConflict() != null) {\n          myChangelistBuilder.processChange(createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status.getRevision()),\n                                                   CurrentContentRevision.create(filePath), FileStatus.MODIFIED, status), SvnVcs.getKey());\n        }\n        checkSwitched(filePath, myChangelistBuilder, status, fStatus);\n      }\n    }\n  }","id":81798,"modified_method":"void processStatus(final FilePath filePath, final SVNStatus status) throws SVNException {\n    final int wcFormat = status.getWorkingCopyFormat();\n    if (WorkingCopyFormat.ONE_DOT_SEVEN.getFormat() != wcFormat && ISVNWCDb.WC_FORMAT_17 != wcFormat) {\n      loadEntriesFile(filePath);\n    }\n    if (status != null) {\n      FileStatus fStatus = SvnStatusConvertor.convertStatus(status);\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (SvnVcs.svnStatusIsUnversioned(status) || SvnVcs.svnStatusIs(status, SVNStatusType.UNKNOWN)) {\n        final VirtualFile file = filePath.getVirtualFile();\n        if (file != null) {\n          myChangelistBuilder.processUnversionedFile(file);\n        }\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_ADDED)) {\n        myChangelistBuilder.processChangeInList(createChange(null, CurrentContentRevision.create(filePath), fStatus, status),\n                                                changeListNameFromStatus(status), SvnVcs.getKey());\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_CONFLICTED) ||\n               SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_MODIFIED) ||\n               SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_REPLACED) ||\n               propStatus == SVNStatusType.STATUS_MODIFIED ||\n               propStatus == SVNStatusType.STATUS_CONFLICTED) {\n        myChangelistBuilder.processChangeInList(createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status),\n                            CurrentContentRevision.create(filePath), fStatus, status), changeListNameFromStatus(status), SvnVcs.getKey());\n        checkSwitched(filePath, myChangelistBuilder, status, fStatus);\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_DELETED)) {\n        myChangelistBuilder.processChangeInList(\n          createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status), null, fStatus, status),\n          changeListNameFromStatus(status), SvnVcs.getKey());\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_MISSING)) {\n        myChangelistBuilder.processLocallyDeletedFile(createLocallyDeletedChange(filePath, status));\n      }\n      else if (SvnVcs.svnStatusIs(status, SVNStatusType.STATUS_IGNORED)) {\n        myChangelistBuilder.processIgnoredFile(filePath.getVirtualFile());\n      }\n      else if (status.isCopied()) {\n        //\n      }\n      else if ((fStatus == FileStatus.NOT_CHANGED || fStatus == FileStatus.SWITCHED) && statusType != SVNStatusType.STATUS_NONE) {\n        VirtualFile file = filePath.getVirtualFile();\n        if (file != null && FileDocumentManager.getInstance().isFileModified(file)) {\n          myChangelistBuilder.processChangeInList(createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status),\n                                                   CurrentContentRevision.create(filePath), FileStatus.MODIFIED, status), changeListNameFromStatus(status),\n                                                  SvnVcs.getKey());\n        } else if (status.getTreeConflict() != null) {\n          myChangelistBuilder.processChange(createChange(SvnContentRevision.createBaseRevision(myVcs, filePath, status),\n                                                   CurrentContentRevision.create(filePath), FileStatus.MODIFIED, status), SvnVcs.getKey());\n        }\n        checkSwitched(filePath, myChangelistBuilder, status, fStatus);\n      }\n    }\n  }","commit_id":"99c3eceb136d2920df353baea5d5b1b4425e8a5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n   * If possible, converts this path expression to a path iterator.\r\n   * @param ctx context reference\r\n   * @return resulting operator\r\n   */\r\n  private AxisPath iterator(final QueryContext ctx) {\r\n    // skip paths with variables...\r\n    if(root != null && root.uses(Use.VAR, ctx)) {\r\n      return this;\r\n    }\r\n\r\n    // Simple iterator: one downward location step or parent step\r\n    if(step.length == 1 && (step[0].axis.down)) {\r\n      return new SingleIterPath(root, step);\r\n    }\r\n\r\n    // To check if the result of a path is in document order so that no special \r\n    // ordering functions are needed and we can use the SimpleIterPath, \r\n    // we are geared to an automaton that is provided in the paper \r\n    // \"Avoiding Unnecessary Ordering Operations in XPath\" by\r\n    // Jan Hidders and Phillipe Michiels.\r\n    \r\n    // Link: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.4006\r\n    // Page 6 - Figure 5\r\n    \r\n    // Since BaseX has a slightly different implementation, it is possible\r\n    // to have alternating child and parent steps or more parent steps -\r\n    // different than described in the paper.\r\n    \r\n    // check if root exists and has no duplicates\r\n    boolean iter = root != null && !root.duplicates(ctx);\r\n    \r\n    if (iter) {\r\n      int i = 0;\r\n      while (true) {\r\n        \r\n        // First steps can be attribute, parent or self steps.\r\n        if (step[i].axis == Axis.ATTR \r\n            || step[i].axis == Axis.PARENT \r\n            || step[i].axis == Axis.SELF) {\r\n          i++;\r\n          // iter is still true.\r\n          if (i == step.length) break;\r\n          continue;\r\n        }\r\n        \r\n        // If after only-parent steps or without any parent steps the next \r\n        // and only step is an descendant, descendant-or-self, preceding\r\n        // or following step, the result of the path is still in document order.\r\n        if (step[i].axis == Axis.DESC\r\n            || step[i].axis == Axis.DESCORSELF\r\n            || step[i].axis == Axis.FOLL\r\n            || step[i].axis == Axis.PREC) {\r\n          i++;\r\n          // iter is still true.\r\n          if (i == step.length) break;\r\n          else {\r\n            iter = false;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        // If after only-parent steps or without any parent steps the next \r\n        // step is an attribute, child, self, preceding-sibling or\r\n        // following-sibling step, the result of the path is still in \r\n        // document order.\r\n        if (step[i].axis == Axis.ATTR\r\n            || step[i].axis == Axis.CHILD\r\n            || step[i].axis == Axis.FOLLSIBL\r\n            || step[i].axis == Axis.PRECSIBL \r\n            || step[i].axis == Axis.SELF) {\r\n          i++;\r\n          // iter is still true.\r\n          if (i == step.length) break;\r\n\r\n          // In this state are finite attribute, child, parent or self steps \r\n          // possible.\r\n          while (step[i].axis == Axis.ATTR\r\n              || step[i].axis == Axis.CHILD\r\n              || step[i].axis == Axis.PARENT \r\n              || step[i].axis == Axis.SELF) {\r\n            i++;\r\n            // iter is still true.\r\n            if (i == step.length) break;\r\n          }\r\n          // iter is still true.\r\n          // This check is necessary because of the while loop before.\r\n          if (i == step.length) break;\r\n\r\n          // The last step can  be a attribute, child, parent or self step,\r\n          // and also a descendant or descendant-or-self step.\r\n          iter &= step[i].axis.down;\r\n          \r\n        } else {\r\n          iter = false;\r\n          break;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if(iter) {\r\n      return new SimpleIterPath(root, step);\r\n    }\r\n    \r\n    // return null if no iterator could be created\r\n    return this;\r\n  }","id":81799,"modified_method":"/**\r\n   * If possible, converts this path expression to a path iterator.\r\n   * @param ctx context reference\r\n   * @return resulting operator\r\n   */\r\n  private AxisPath iterator(final QueryContext ctx) {\r\n    // skip paths with variables...\r\n    if(root != null && root.uses(Use.VAR, ctx)) {\r\n      return this;\r\n    }\r\n\r\n    /* Simple iterator: one downward location step or parent step\r\n    if(step.length == 1 && (step[0].axis.down)) {\r\n      return new SingleIterPath(root, step);\r\n    }*/\r\n\r\n    // To check if the result of a path is in document order so that no special \r\n    // ordering functions are needed and we can use the SimpleIterPath, \r\n    // we are geared to an automaton that is provided in the paper \r\n    // \"Avoiding Unnecessary Ordering Operations in XPath\" by\r\n    // Jan Hidders and Philippe Michiels.\r\n    \r\n    // Link: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.4006\r\n    // Page 6 - Figure 5\r\n    \r\n    // Since BaseX has a slightly different implementation, it is possible\r\n    // to have alternating child and parent steps or more parent steps -\r\n    // different than described in the paper.\r\n    \r\n    // check if root exists and has no duplicates\r\n    boolean iter = root != null && !root.duplicates(ctx);\r\n    \r\n    if (iter) {\r\n      int i = 0;\r\n      while (true) {\r\n        \r\n        // First steps can be attribute, parent or self steps.\r\n        if (step[i].axis == Axis.ATTR \r\n            || step[i].axis == Axis.PARENT \r\n            || step[i].axis == Axis.SELF) {\r\n          i++;\r\n          // iter is still true.\r\n          if (i == step.length) break;\r\n          continue;\r\n        }\r\n        \r\n        // If after only-parent steps or without any parent steps the next \r\n        // and only step is an descendant, descendant-or-self, preceding\r\n        // or following step, the result of the path is still in document order.\r\n        if (step[i].axis == Axis.DESC\r\n            || step[i].axis == Axis.DESCORSELF\r\n            || step[i].axis == Axis.FOLL\r\n            || step[i].axis == Axis.PREC) {\r\n          i++;\r\n          // iter is still true.\r\n          if (i == step.length) break;\r\n          else {\r\n            iter = false;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        // If after only-parent steps or without any parent steps the next \r\n        // step is an attribute, child, self, preceding-sibling or\r\n        // following-sibling step, the result of the path is still in \r\n        // document order.\r\n        if (step[i].axis == Axis.ATTR\r\n            || step[i].axis == Axis.CHILD\r\n            || step[i].axis == Axis.FOLLSIBL\r\n            || step[i].axis == Axis.PRECSIBL \r\n            || step[i].axis == Axis.SELF) {\r\n          i++;\r\n          // iter is still true.\r\n          if (i == step.length) break;\r\n\r\n          // In this state are finite attribute, child, parent or self steps \r\n          // possible.\r\n          while (step[i].axis == Axis.ATTR\r\n              || step[i].axis == Axis.CHILD\r\n              || step[i].axis == Axis.PARENT \r\n              || step[i].axis == Axis.SELF) {\r\n            i++;\r\n            // iter is still true.\r\n            if (i == step.length) break;\r\n          }\r\n          // iter is still true.\r\n          // This check is necessary because of the while loop before.\r\n          if (i == step.length) break;\r\n\r\n          // The last step can  be a attribute, child, parent or self step,\r\n          // and also a descendant or descendant-or-self step.\r\n          iter &= step[i].axis.down;\r\n          \r\n        } else {\r\n          iter = false;\r\n          break;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if(iter) {\r\n      return new SimpleIterPath(root, step);\r\n    }\r\n    \r\n    // return null if no iterator could be created\r\n    return this;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    for(int i = 0; i < expr.length; i++) expr[i] = expr[i].indexEquivalent(ic);\r\n\r\n    if(pex.length == 0) {\r\n      // !A FTAnd !B = !(a ftor b)\r\n      for(int i = 0; i < expr.length; i++) expr[i] = expr[i].expr[0];\r\n      return new FTNotIndex(new FTUnion(nex, false, expr));\r\n    }\r\n    return new FTIntersection(pex, nex, expr);\r\n  }","id":81800,"modified_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    for(int i = 0; i < expr.length; i++) expr[i] = expr[i].indexEquivalent(ic);\r\n\r\n    if(pex.length == 0) {\r\n      // !A FTAnd !B = !(a ftor b)\r\n      for(int i = 0; i < expr.length; i++) expr[i] = expr[i].expr[0];\r\n      return new FTNot(new FTUnion(nex, false, expr));\r\n    }\r\n    return new FTIntersection(pex, nex, expr);\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Expr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    ic.ctx.compInfo(OPTFTXINDEX);\r\n\r\n    final FTExpr ie = ftexpr.indexEquivalent(ic);\r\n\r\n    // sequential evaluation with index access\r\n    if(ic.seq) return new FTContainsSIndex(expr, ie, !ic.ftnot);\r\n\r\n    // standard index evaluation; first expression will always be an axis path\r\n    return ((AxisPath) expr).invertPath(new FTIndexAccess(ie, ft, ic), ic.step);\r\n  }","id":81801,"modified_method":"@Override\r\n  public Expr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    ic.ctx.compInfo(OPTFTXINDEX);\r\n\r\n    final FTExpr ie = ftexpr.indexEquivalent(ic);\r\n\r\n    // sequential evaluation with index access\r\n    if(ic.seq) return new FTContainsSIndex(expr, ie, ic.ftnot);\r\n\r\n    // standard index evaluation; first expression will always be an axis path\r\n    return ((AxisPath) expr).invertPath(new FTIndexAccess(ie, ft, ic), ic.step);\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor.\r\n   * @param e contains, select and optional ignore expression\r\n   * @param fte full-text expression\r\n   * @param v visualize ft results\r\n   */\r\n  public FTContainsSIndex(final Expr e, final FTExpr fte, final boolean v) {\r\n    super(e, fte);\r\n    vis = v;\r\n  }","id":81802,"modified_method":"/**\r\n   * Constructor.\r\n   * @param e contains, select and optional ignore expression\r\n   * @param fte full-text expression\r\n   * @param n not flag\r\n   */\r\n  public FTContainsSIndex(final Expr e, final FTExpr fte, final boolean n) {\r\n    super(e, fte);\r\n    not = n;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Bln atomic(final QueryContext ctx) throws QueryException {\r\n    final Iter ir = expr.iter(ctx);\r\n    final Tokenizer tmp = ctx.fttoken;\r\n    ctx.fttoken = ft;\r\n\r\n    if(fti == null) fti = ftexpr.iter(ctx);\r\n    if(ftn == null) ftn = fti.next();\r\n\r\n    double d = 0;\r\n    DBNode n;\r\n    while((n = (DBNode) ir.next()) != null) {\r\n      n.score(1);\r\n\r\n      while(ftn != null && ftn != null && n.pre > ftn.pre) ftn = fti.next();\r\n\r\n      if(ftn != null) {\r\n        // [CG] check\r\n        //final boolean not = ftn.matches.not;\r\n        boolean not = false;\r\n        if(ftn.pre == n.pre) {\r\n          ftn = null;\r\n          d = not ? 0 : n.score();\r\n          break;\r\n        }\r\n        if(not) {\r\n          d = n.score();\r\n          break;\r\n        }\r\n      } else {\r\n        fti = null;\r\n      }\r\n    }\r\n    ctx.fttoken = tmp;\r\n\r\n    // add entry to visualization\r\n    if(d > 0 && ctx.ftpos != null && vis) ctx.ftpos.add(ftn.pre, ftn.all);\r\n    \r\n    return Bln.get(d);\r\n  }","id":81803,"modified_method":"@Override\r\n  public Bln atomic(final QueryContext ctx) throws QueryException {\r\n    final Iter ir = expr.iter(ctx);\r\n    final Tokenizer tmp = ctx.fttoken;\r\n    ctx.fttoken = ft;\r\n    \r\n    // create index iterator\r\n    if(fti == null) {\r\n      fti = ftexpr.iter(ctx);\r\n      ftn = fti.next();\r\n    }\r\n\r\n    // find next relevant index entry\r\n    boolean found = false;\r\n    DBNode n = null;\r\n    while(!found && (n = (DBNode) ir.next()) != null) {\r\n      // find entry with pre value equal to or larger than current node\r\n      while(ftn != null && n.pre > ftn.pre) ftn = fti.next();\r\n      found = (ftn != null && n.pre == ftn.pre) ^ not;\r\n    }\r\n    // reset index iterator after all nodes have been processed\r\n    if(n == null) fti = null;\r\n\r\n    // add entry to visualization\r\n    if(found && ctx.ftpos != null && !not) ctx.ftpos.add(ftn.pre, ftn.all);\r\n    \r\n    ctx.fttoken = tmp;\r\n    return Bln.get(found ? 1 : 0);\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public double score() {\n    // default score for index results\n    if(score == -1) score = all.match() ? 1 : 0;\n    return score;\n  }","id":81804,"modified_method":"@Override\n  public double score() {\n    // default score for index results\n    if(score == -1) score = all.matches() ? 1 : 0;\n    return score;\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Checks if at least one of the matches yields true.\r\n   * @return result of check\r\n   */\r\n  public boolean match() {\r\n    for(int a = 0; a < size; a++) if(match[a].match()) return true;\r\n    return false;\r\n  }","id":81805,"modified_method":"/**\r\n   * Checks if at least one of the matches contains only includes.\r\n   * @return result of check\r\n   */\r\n  public boolean matches() {\r\n    for(int a = 0; a < size; a++) if(match[a].match()) return true;\r\n    return false;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Resets the match counter.\r\n   * @param s sets the token number\r\n   */\r\n  public void reset(final byte s) {\r\n    size = 0;\r\n    sTokenNum = s;\r\n  }","id":81806,"modified_method":"/**\r\n   * Resets the match counter.\r\n   * @param s sets the token number\r\n   */\r\n  public void reset(final byte s) {\r\n    sTokenNum = s;\r\n    size = 0;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem item = expr[0].atomic(ctx);\r\n    final FTMatches all = item.all;\r\n    for(int e = 1; e < expr.length; e++) {\r\n      final FTMatches al = expr[e].atomic(ctx).all;\r\n      for(int a = 0; a < all.size; a++) {\r\n        for(int b = 0; b < al.size; b++) {\r\n          if(!all.match[a].notin(al.match[b])) {\r\n            all.delete(a--);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if(all.size == 0) item.score(0);\r\n    return item;\r\n  }","id":81807,"modified_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem item = expr[0].atomic(ctx);\r\n    final FTMatches all = item.all;\r\n    for(int e = 1; e < expr.length; e++) {\r\n      if(!all.mildnot(expr[e].atomic(ctx).all)) break;\r\n    }\r\n    if(all.size == 0) item.score(0);\r\n    return item;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    if(expr.length == 1) return expr[0].indexEquivalent(ic);\r\n    \r\n    // assumption 1: ftcontains \"a\" not in \"a b\" not in \"a c\"\r\n    // and ftcontains \"a\" not in \"a b\" ftand \"a\" not in \"a c\" are equivalent\r\n\r\n    final FTExpr[] ie = new FTExpr[2];\r\n    final FTMildNotIndex[] mne = new FTMildNotIndex[expr.length - 1];\r\n    final int[] pex = new int[expr.length - 1];\r\n    ie[0] = expr[0].indexEquivalent(ic);\r\n    for(int i = 1; i < expr.length; i++) {\r\n      ie[1] = expr[i].indexEquivalent(ic);\r\n      mne[i - 1] = new FTMildNotIndex(ie);\r\n      pex[i - 1] = i - 1;\r\n    }\r\n    if(mne.length == 1) {\r\n      return mne[0];\r\n    }\r\n    return new FTIntersection(pex, new int[] {}, mne);\r\n  }","id":81808,"modified_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    if(expr.length == 1) return expr[0].indexEquivalent(ic);\r\n    \r\n    // assumption 1: ftcontains \"a\" not in \"a b\" not in \"a c\"\r\n    // and ftcontains \"a\" not in \"a b\" ftand \"a\" not in \"a c\" are equivalent\r\n\r\n    final FTExpr[] ie = new FTExpr[2];\r\n    final FTMildNot[] mne = new FTMildNot[expr.length - 1];\r\n    final int[] pex = new int[expr.length - 1];\r\n    ie[0] = expr[0].indexEquivalent(ic);\r\n    for(int i = 1; i < expr.length; i++) {\r\n      ie[1] = expr[i].indexEquivalent(ic);\r\n      mne[i - 1] = new FTMildNot(ie);\r\n      pex[i - 1] = i - 1;\r\n    }\r\n    if(mne.length == 1) {\r\n      return mne[0];\r\n    }\r\n    return new FTIntersection(pex, new int[] {}, mne);\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public boolean indexAccessible(final IndexContext ic) throws QueryException {\r\n    // [CG] FT: skip index access\r\n    if(1 == 1) return false;\r\n\r\n    ic.ftnot ^= true;\r\n    // in case of ftand ftnot seq could be set false in FTAnd\r\n    ic.seq = true;\r\n    final boolean ia = expr[0].indexAccessible(ic);\r\n    ic.is = Integer.MAX_VALUE;\r\n    return ia;\r\n  }","id":81809,"modified_method":"@Override\r\n  public boolean indexAccessible(final IndexContext ic) throws QueryException {\r\n    ic.ftnot ^= true;\r\n    ic.seq = ic.ftnot;\r\n    final boolean ia = expr[0].indexAccessible(ic);\r\n    ic.is = Integer.MAX_VALUE;\r\n    return ia;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    return new FTNotIndex(expr[0].indexEquivalent(ic));\r\n  }","id":81810,"modified_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    expr[0] = expr[0].indexEquivalent(ic);\r\n    return this;\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem it = expr[0].atomic(ctx);\r\n    it.all.not();\r\n    // needed to support negated queries without hits ('a' ftcontains ftnot 'b')\r\n    it.score(it.score() == 0 ? 1 : 0);\r\n    return it;\r\n  }","id":81811,"modified_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    return not(expr[0].atomic(ctx));\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    for(int i = 0; i < expr.length; i++) expr[i] = expr[i].indexEquivalent(ic);\r\n\r\n    if(pex.length == 0) {\r\n      // !A FTOR !B = !(a ftand b)\r\n      FTExpr[] nexpr = new FTExpr[nex.length];\r\n      for(int i = 0; i < nex.length; i++) nexpr[i] = expr[nex[i]].expr[0];\r\n      return new FTNotIndex(new FTIntersection(pex, nex, nexpr));\r\n    }\r\n\r\n    // [SG] is never the case..\r\n    //if(pex.length == 0) return new FTUnion(nex, true, expr);\r\n\r\n    if(nex.length == 0) return pex.length == 1 ?\r\n        expr[pex[0]] : new FTUnion(pex, false, expr);\r\n    \r\n    return new FTUnion(gen(), true, expr);\r\n  }","id":81812,"modified_method":"@Override\r\n  public FTExpr indexEquivalent(final IndexContext ic) throws QueryException {\r\n    for(int i = 0; i < expr.length; i++) expr[i] = expr[i].indexEquivalent(ic);\r\n\r\n    if(pex.length == 0) {\r\n      // !A FTOR !B = !(a ftand b)\r\n      FTExpr[] nexpr = new FTExpr[nex.length];\r\n      for(int i = 0; i < nex.length; i++) nexpr[i] = expr[nex[i]].expr[0];\r\n      return new FTNot(new FTIntersection(pex, nex, nexpr));\r\n    }\r\n\r\n    // [SG] is never the case..\r\n    //if(pex.length == 0) return new FTUnion(nex, true, expr);\r\n\r\n    if(nex.length == 0) return pex.length == 1 ?\r\n        expr[pex[0]] : new FTUnion(pex, false, expr);\r\n    \r\n    return new FTUnion(gen(), true, expr);\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the root of the current context or null.\r\n   * @param ctx query context\r\n   * @return root\r\n   */\r\n  protected Item root(final QueryContext ctx) {\r\n    final Item it = ctx.item;\r\n    if(root == null) return it;\r\n    if(root.i()) return (Item) root;\r\n    if(!(root instanceof Root) || it == null) return null;\r\n    return it.size(ctx) != 1 ? it : ((Root) root).root(it);\r\n  }","id":81813,"modified_method":"/**\r\n   * Returns the root of the current context or null.\r\n   * @param ctx query context\r\n   * @return root\r\n   */\r\n  protected Item root(final QueryContext ctx) {\r\n    final Item it = ctx != null ? ctx.item : null;\r\n    if(root == null) return it;\r\n    if(root.i()) return (Item) root;\r\n    if(!(root instanceof Root) || it == null) return null;\r\n    return it.size(ctx) != 1 ? it : ((Root) root).root(it);\r\n  }","commit_id":"e94fa90375357f30370c302de03404a4a29cd989","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem item = expr[0].atomic(ctx);\r\n    for(int e = 1; e < expr.length; e++) {\r\n      final FTItem it = expr[e].atomic(ctx);\r\n      item.all = and(item.all, it.all);\r\n      item.score(ctx.score.and(it.score(), item.score()));\r\n    }\r\n    return item;\r\n  }","id":81814,"modified_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem item = expr[0].atomic(ctx);\r\n    for(int e = 1; e < expr.length; e++) and(ctx, item, expr[e].atomic(ctx));\r\n    return item;\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) throws QueryException {\r\n    // initialize iterators\r\n    final FTIter[] ir = new FTIter[expr.length];\r\n    final FTItem[] it = new FTItem[expr.length];\r\n    for(int e = 0; e < expr.length; e++) {\r\n      ir[e] = expr[e].iter(ctx);\r\n      it[e] = ir[e].next();\r\n    }\r\n\r\n    return new FTIter() {\r\n      @Override\r\n      public FTItem next() throws QueryException {\r\n        // find item with lowest pre value\r\n        for(int i = 0; i < it.length; i++) {\r\n          if(it[i] == null) {\r\n            if(neg[i]) continue;\r\n            return null;\r\n          }\r\n\r\n          final int d = it[0].pre - it[i].pre;\r\n          if(neg[i]) {\r\n            if(d >= 0) {\r\n              if(d == 0) it[0] = ir[0].next();\r\n              it[i] = ir[i].next();\r\n              i = -1;\r\n            }\r\n          } else {\r\n            if(d != 0) {\r\n              if(d < 0) i = 0;\r\n              it[i] = ir[i].next();\r\n              i = -1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // merge all matches\r\n        final FTItem item = it[0];\r\n        for(int i = 1; i < it.length; i++) {\r\n          // [CG] FT: item.all = FTMatches.not(it[i].all, 0);\r\n          if(neg[i]) continue;\r\n          item.all = and(item.all, it[i].all);\r\n          item.score(ctx.score.ftAnd(item, it[i]));\r\n          it[i] = ir[i].next();\r\n        }\r\n        it[0] = ir[0].next();\r\n        return item;\r\n      }\r\n    };\r\n  }","id":81815,"modified_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) throws QueryException {\r\n    // initialize iterators\r\n    final FTIter[] ir = new FTIter[expr.length];\r\n    final FTItem[] it = new FTItem[expr.length];\r\n    for(int e = 0; e < expr.length; e++) {\r\n      ir[e] = expr[e].iter(ctx);\r\n      it[e] = ir[e].next();\r\n    }\r\n\r\n    return new FTIter() {\r\n      @Override\r\n      public FTItem next() throws QueryException {\r\n        // find item with lowest pre value\r\n        for(int i = 0; i < it.length; i++) {\r\n          if(it[i] == null) {\r\n            if(neg[i]) continue;\r\n            return null;\r\n          }\r\n\r\n          final int d = it[0].pre - it[i].pre;\r\n          if(neg[i]) {\r\n            if(d >= 0) {\r\n              if(d == 0) it[0] = ir[0].next();\r\n              it[i] = ir[i].next();\r\n              i = -1;\r\n            }\r\n          } else {\r\n            if(d != 0) {\r\n              if(d < 0) i = 0;\r\n              it[i] = ir[i].next();\r\n              i = -1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // merge all matches\r\n        final FTItem item = it[0];\r\n        for(int i = 1; i < it.length; i++) {\r\n          // [CG] FT: item.all = FTMatches.not(it[i].all, 0);\r\n          if(neg[i]) continue;\r\n          and(ctx, item, it[i]);\r\n          it[i] = ir[i].next();\r\n        }\r\n        it[0] = ir[0].next();\r\n        return item;\r\n      }\r\n    };\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Bln atomic(final QueryContext ctx) throws QueryException {\r\n    final Iter iter = expr.iter(ctx);\r\n    final Tokenizer tmp = ctx.fttoken;\r\n    ctx.fttoken = ft;\r\n    double s = 0;\r\n    Item it;\r\n\r\n    while((it = iter.next()) != null) {\r\n      ft.init(it.str());\r\n      final FTItem item = ftexpr.atomic(ctx);\r\n      double d = 0;\r\n      if(item.all.matches()) {\r\n        d = item.score();\r\n        // no scoring found - use default value\r\n        if(d == 0) d = 1;\r\n      }\r\n      s = ctx.score.and(s, d);\r\n\r\n      // add entry to visualization\r\n      if(d > 0 && ctx.ftpos != null && it instanceof DBNode) {\r\n        ctx.ftpos.add(((DBNode) it).pre, item.all);\r\n      }\r\n    }\r\n\r\n    ctx.fttoken = tmp;\r\n    s = Math.max(ctx.item.score - s / ctx.item.score, s - ctx.item.score / s);\r\n    return Bln.get(s);\r\n  }","id":81816,"modified_method":"@Override\r\n  public Bln atomic(final QueryContext ctx) throws QueryException {\r\n    final Iter iter = expr.iter(ctx);\r\n    final Tokenizer tmp = ctx.fttoken;\r\n    ctx.fttoken = ft;\r\n    double s = 0;\r\n    Item it;\r\n\r\n    while((it = iter.next()) != null) {\r\n      ft.init(it.str());\r\n      final FTItem item = ftexpr.atomic(ctx);\r\n      double d = 0;\r\n      if(item.all.matches()) {\r\n        d = item.score();\r\n        // no scoring found - use default value\r\n        if(d == 0) d = 1;\r\n      }\r\n      s = ctx.score.and(s, d);\r\n\r\n      // add entry to visualization\r\n      if(d > 0 && ctx.ftpos != null && it instanceof DBNode) {\r\n        ctx.ftpos.add(((DBNode) it).pre, item.all);\r\n      }\r\n    }\r\n\r\n    ctx.fttoken = tmp;\r\n    /* [SG] null/NaN tests added; still, many FTTests are broken (e.g. if both\r\n     *   s and is are 1). If these bugs don't occur in the INEX context, we\r\n     *   could use a Prop.INEX flag here to save time.\r\n    final double is = ctx.item.score;\r\n    if(s != 0 && s == s && is != 0 && is == is) {\r\n      s = Math.max(ctx.item.score - s / ctx.item.score, s - ctx.item.score / s);\r\n    }*/\r\n    return Bln.get(s);\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public double score() {\n    if (score == -1) {\n      final double ntl = super.data.textLen(super.pre); \n      score = ((tl + 1) * all.match.length - 1) / ntl;\n    }\n\n    // default score for index results\n//    if(score == -1) score = all.matches() ? 1 : 0;\n    return score;\n  }","id":81817,"modified_method":"@Override\n  public double score() {\n    if(score == -1) {\n      score = ((tl + 1) * all.match.length - 1) / data.textLen(pre);\n    }\n    // default score for index results\n    // if(score == -1) score = all.matches() ? 1 : 0;\n    return score;\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    return not(expr[0].atomic(ctx));\r\n  }","id":81818,"modified_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    return not(ctx, expr[0].atomic(ctx));\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) throws QueryException {\r\n    return new FTIter() {\r\n      final FTIter ir = expr[0].iter(ctx);\r\n\r\n      @Override\r\n      public FTItem next() throws QueryException {\r\n        FTItem it = not(ir.next());\r\n        if (it == null) return it;\r\n        it.score(ctx.score.ftNot(it.score()));\r\n        return it;\r\n      }\r\n    };\r\n  }","id":81819,"modified_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) throws QueryException {\r\n    return new FTIter() {\r\n      final FTIter ir = expr[0].iter(ctx);\r\n\r\n      @Override\r\n      public FTItem next() throws QueryException {\r\n        return not(ctx, ir.next());\r\n      }\r\n    };\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem item = expr[0].atomic(ctx);\r\n    for(int e = 1; e < expr.length; e++) {\r\n      final FTItem it = expr[e].atomic(ctx);\r\n      item.all = or(item.all, it.all);\r\n      item.score(ctx.score.or(item.score(), it.score()));\r\n    }\r\n    return item;\r\n  }","id":81820,"modified_method":"@Override\r\n  public FTItem atomic(final QueryContext ctx) throws QueryException {\r\n    final FTItem item = expr[0].atomic(ctx);\r\n    for(int e = 1; e < expr.length; e++) or(ctx, item, expr[e].atomic(ctx));\r\n    return item;\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) throws QueryException {\r\n    // initialize iterators\r\n    final FTIter[] ir = new FTIter[expr.length];\r\n    final FTItem[] it = new FTItem[expr.length];\r\n    for(int e = 0; e < expr.length; e++) {\r\n      ir[e] = expr[e].iter(ctx);\r\n      it[e] = ir[e].next();\r\n    }\r\n\r\n    return new FTIter() {\r\n      @Override\r\n      public FTItem next() throws QueryException {\r\n        // find item with smallest pre value\r\n        int p = -1;\r\n        for(int i = 0; i < it.length; i++) {\r\n          if(it[i] != null && (p == -1 || it[p].pre > it[i].pre)) p = i;\r\n        }\r\n        // no items left - leave\r\n        if(p == -1) return null;\r\n\r\n        // merge all matches\r\n        final FTItem item = it[p];\r\n        for(int i = 0; i < it.length; i++) {\r\n          if(it[i] != null && p != i && item.pre == it[i].pre) {\r\n            item.all = or(item.all, it[i].all);\r\n            item.score(ctx.score.ftOr(item, it[i], ctx.ftoknum, expr.length));\r\n            it[i] = ir[i].next();\r\n          }\r\n        }\r\n        it[p] = ir[p].next();\r\n        return item;\r\n      }\r\n    };\r\n  }","id":81821,"modified_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) throws QueryException {\r\n    // initialize iterators\r\n    final FTIter[] ir = new FTIter[expr.length];\r\n    final FTItem[] it = new FTItem[expr.length];\r\n    for(int e = 0; e < expr.length; e++) {\r\n      ir[e] = expr[e].iter(ctx);\r\n      it[e] = ir[e].next();\r\n    }\r\n\r\n    return new FTIter() {\r\n      @Override\r\n      public FTItem next() throws QueryException {\r\n        // find item with smallest pre value\r\n        int p = -1;\r\n        for(int i = 0; i < it.length; i++) {\r\n          if(it[i] != null && (p == -1 || it[p].pre > it[i].pre)) p = i;\r\n        }\r\n        // no items left - leave\r\n        if(p == -1) return null;\r\n\r\n        // merge all matches\r\n        final FTItem item = it[p];\r\n        for(int i = 0; i < it.length; i++) {\r\n          if(it[i] != null && p != i && item.pre == it[i].pre) {\r\n            or(ctx, item, it[i]);\r\n            it[i] = ir[i].next();\r\n          }\r\n        }\r\n        it[p] = ir[p].next();\r\n        return item;\r\n      }\r\n    };\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) {\r\n    return new FTIter() {\r\n      /** Index iterator. */\r\n      FTIndexIterator iat;\r\n\r\n      @Override\r\n      public FTItem next() {\r\n        if(iat == null) {\r\n          // more than one token: deactivate fast processing\r\n          final Tokenizer ft = new Tokenizer(txt, ctx.ftopt, fast,\r\n              ctx.context.prop);\r\n          ft.fast &= ft.count() == 1;\r\n          ft.init();\r\n          while(ft.more()) {\r\n            final FTIndexIterator it = (FTIndexIterator) data.ids(ft);\r\n            iat = iat == null ? it : FTIndexIterator.phrase(iat, it);\r\n          }\r\n          iat.setTokenNum(++ctx.ftoknum);\r\n        }\r\n        int tl = -1;\r\n        if (query instanceof Str) {\r\n          final Str s = (Str) query;\r\n          tl = s.str().length;\r\n        }\r\n        return iat.more() ? new FTItem(iat.matches(), \r\n            data, iat.next(), tl) : null;\r\n      }\r\n    };\r\n  }","id":81822,"modified_method":"@Override\r\n  public FTIter iter(final QueryContext ctx) {\r\n    return new FTIter() {\r\n      /** Index iterator. */\r\n      FTIndexIterator iat;\r\n\r\n      @Override\r\n      public FTItem next() {\r\n        if(iat == null) {\r\n          // more than one token: deactivate fast processing\r\n          final Tokenizer ft = new Tokenizer(txt, ctx.ftopt, fast,\r\n              ctx.context.prop);\r\n          ft.fast &= ft.count() == 1;\r\n          ft.init();\r\n          while(ft.more()) {\r\n            final FTIndexIterator it = (FTIndexIterator) data.ids(ft);\r\n            iat = iat == null ? it : FTIndexIterator.phrase(iat, it);\r\n          }\r\n          iat.setTokenNum(++ctx.ftoknum);\r\n        }\r\n        return iat.more() ? new FTItem(iat.matches(), \r\n            data, iat.next(), txt.length) : null;\r\n      }\r\n    };\r\n  }","commit_id":"bcf68a5df7ed459c524a63ee748ea4f79777f648","url":"https://github.com/BaseXdb/basex"},{"original_method":"private boolean generateText(IOperationContext context, GenerationStatus status, Map<SNode, String> outputNodeContents) {\n    boolean hasErrors = false;\n    ModelDependencies dependRoot = new ModelDependencies();\n    DebugInfo info = new DebugInfo();\n    status.setDebugInfo(info);\n    status.setBLDependencies(dependRoot);\n    for (SNode outputNode : status.getOutputModel().getRoots()) {\n      try {\n        TextGenerationResult result = TextGenerationUtil.generateText(context, outputNode);\n        String fileName = outputNode.getName() + \".\" + TextGenManager.instance().getExtension(outputNode);\n        fillDebugInfo(info, outputNode, fileName, result);\n        fillDependencies(dependRoot, outputNode, fileName, result);\n\n        hasErrors |= result.hasErrors();\n        outputNodeContents.put(outputNode, result.getText());\n      } finally {\n        TextGenManager.reset();\n      }\n    }\n    return !hasErrors;\n  }","id":81823,"modified_method":"private boolean generateText(IOperationContext context, GenerationStatus status, Map<SNode, String> outputNodeContents) {\n    boolean hasErrors = false;\n    ModelDependencies dependRoot = new ModelDependencies();\n    DebugInfo info = new DebugInfo();\n    status.setDebugInfo(info);\n    status.setBLDependencies(dependRoot);\n\n    SModel outputModel = status.getOutputModel();\n    if(outputModel != null) {\n      for (SNode outputNode : outputModel.getRoots()) {\n        try {\n          TextGenerationResult result = TextGenerationUtil.generateText(context, outputNode);\n          String fileName = outputNode.getName() + \".\" + TextGenManager.instance().getExtension(outputNode);\n          fillDebugInfo(info, outputNode, fileName, result);\n          fillDependencies(dependRoot, outputNode, fileName, result);\n\n          hasErrors |= result.hasErrors();\n          outputNodeContents.put(outputNode, result.getText());\n        } finally {\n          TextGenManager.reset();\n        }\n      }\n    }\n    return !hasErrors;\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void analyzeDependencies(@NotNull GenerationDependencies dependencies) {\n\n    GenerationRootDependencies commonDeps = dependencies.getDependenciesFor(ModelDigestUtil.HEADER);\n    if(commonDeps == null) {\n      return;\n    }\n\n    // check model header\n    {\n      String oldHash = commonDeps.getHash();\n      String newHash = myGenerationHashes.get(ModelDigestUtil.HEADER);\n      if(oldHash == null || newHash == null || !newHash.equals(oldHash)) {\n        return;\n      }\n    }\n\n    // check external dependencies\n    Set<String> changedModels = new HashSet<String>();\n    Map<String,String> externalHashes = dependencies.getExternalHashes();\n    for(Entry<String,String> entry : externalHashes.entrySet()) {\n      String modelReference = entry.getKey();\n      SModelDescriptor sm = SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(modelReference));\n      if(sm == null) {\n        changedModels.add(modelReference);\n        continue;\n      }\n      String oldHash = entry.getValue();\n      if(oldHash == null) {\n        // TODO hash for packaged models\n        if(!sm.isPackaged() && !SModelStereotype.isStubModelStereotype(sm.getStereotype())) {\n          changedModels.add(modelReference);\n        }\n        continue;\n      }\n      Map<String, String> map = ModelDigestUtil.getGenerationHashes(sm, myProject);\n      String newHash = map != null ? map.get(ModelDigestUtil.FILE) : null;\n      if(newHash == null || !oldHash.equals(newHash)) {\n        changedModels.add(modelReference);\n      }\n    }\n\n    // check roots\n    List<SNode> rootsList = myModel.getSModel().getRoots();\n    Map<String, SNode> rootById = new HashMap<String, SNode>();\n\n    myUnchangedRoots = new HashSet<SNode>();\n    for(SNode root : rootsList) {\n      String id = root.getId();\n      GenerationRootDependencies rd = dependencies.getDependenciesFor(id);\n      String oldHash;\n      if(rd == null || (oldHash = rd.getHash()) == null) {\n        continue;\n      }\n      String newHash = myGenerationHashes.get(id);\n      if(newHash == null || !newHash.equals(oldHash)) {\n        continue;\n      }\n      boolean isDirty = false;\n      for(String m : rd.getExternal()) {\n        if(changedModels.contains(m)) {\n          isDirty = true;\n          break;\n        }\n      }\n      if(!isDirty) {\n        myUnchangedRoots.add(root);\n      }\n    }\n\n    if(myUnchangedRoots.isEmpty()) {\n      return;\n    }\n\n    for(SNode root : rootsList) {\n      rootById.put(root.getId(), root);\n    }\n\n    // closure using saved dependencies graph\n    myConditionalsUnchanged = true;\n    Map<String, Set<String>> savedDep = getDependenciesWithoutOrientation(dependencies, myUnchangedRoots);\n    closureUsingSavedDependencies(savedDep);\n\n    if(myUnchangedRoots.isEmpty()) {\n      return;\n    }\n\n    // closure using current dependencies\n    ConnectedComponentPartitioner partitioner = new ConnectedComponentPartitioner(rootsList);\n    List<SNode[]> components = partitioner.partition();\n    boolean changed = closureUsingReferences(components, savedDep);\n\n    // repeat\n    while(changed) {\n      if(myUnchangedRoots.isEmpty() && myConditionalsUnchanged == false) {\n        return;\n      }\n      changed = closureUsingSavedDependencies(savedDep);\n      if(changed) {\n        changed = closureUsingReferences(components, savedDep);\n      }\n    }\n  }","id":81824,"modified_method":"private void analyzeDependencies(@NotNull GenerationDependencies dependencies) {\n\n    GenerationRootDependencies commonDeps = dependencies.getDependenciesFor(ModelDigestUtil.HEADER);\n    if(commonDeps == null) {\n      return;\n    }\n\n    // check model header\n    {\n      String oldHash = commonDeps.getHash();\n      String newHash = myGenerationHashes.get(ModelDigestUtil.HEADER);\n      if(oldHash == null || newHash == null || !newHash.equals(oldHash)) {\n        return;\n      }\n    }\n\n    // check external dependencies\n    Set<String> changedModels = new HashSet<String>();\n    Map<String,String> externalHashes = dependencies.getExternalHashes();\n    for(Entry<String,String> entry : externalHashes.entrySet()) {\n      String modelReference = entry.getKey();\n      SModelDescriptor sm = SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(modelReference));\n      if(sm == null) {\n        changedModels.add(modelReference);\n        continue;\n      }\n      String oldHash = entry.getValue();\n      if(oldHash == null) {\n        // TODO hash for packaged models\n        if(!sm.isPackaged() && !SModelStereotype.isStubModelStereotype(sm.getStereotype())) {\n          changedModels.add(modelReference);\n        }\n        continue;\n      }\n      Map<String, String> map = ModelDigestUtil.getGenerationHashes(sm, myProject);\n      String newHash = map != null ? map.get(ModelDigestUtil.FILE) : null;\n      if(newHash == null || !oldHash.equals(newHash)) {\n        changedModels.add(modelReference);\n      }\n    }\n\n    // check roots\n    List<SNode> rootsList = myModel.getSModel().getRoots();\n    myRootsCount = rootsList.size();\n    Map<String, SNode> rootById = new HashMap<String, SNode>();\n\n    myUnchangedRoots = new HashSet<SNode>();\n    for(SNode root : rootsList) {\n      String id = root.getId();\n      GenerationRootDependencies rd = dependencies.getDependenciesFor(id);\n      String oldHash;\n      if(rd == null || (oldHash = rd.getHash()) == null) {\n        continue;\n      }\n      String newHash = myGenerationHashes.get(id);\n      if(newHash == null || !newHash.equals(oldHash)) {\n        continue;\n      }\n      boolean isDirty = false;\n      for(String m : rd.getExternal()) {\n        if(changedModels.contains(m)) {\n          isDirty = true;\n          break;\n        }\n      }\n      if(!isDirty) {\n        myUnchangedRoots.add(root);\n      }\n    }\n\n    if(myUnchangedRoots.isEmpty()) {\n      return;\n    }\n\n    for(SNode root : rootsList) {\n      rootById.put(root.getId(), root);\n    }\n\n    // closure using saved dependencies graph\n    myConditionalsUnchanged = true;\n    Map<String, Set<String>> savedDep = getDependenciesWithoutOrientation(dependencies, myUnchangedRoots);\n    closureUsingSavedDependencies(savedDep);\n\n    if(myUnchangedRoots.isEmpty()) {\n      return;\n    }\n\n    // closure using current dependencies\n    ConnectedComponentPartitioner partitioner = new ConnectedComponentPartitioner(rootsList);\n    List<SNode[]> components = partitioner.partition();\n    boolean changed = closureUsingReferences(components, savedDep);\n\n    // repeat\n    while(changed) {\n      if(myUnchangedRoots.isEmpty() && myConditionalsUnchanged == false) {\n        return;\n      }\n      changed = closureUsingSavedDependencies(savedDep);\n      if(changed) {\n        changed = closureUsingReferences(components, savedDep);\n      }\n    }\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenerationStatus generateModel() throws GenerationCanceledException {\n    if (myMajorStep != 0) {\n      throw new GenerationCanceledException();\n    }\n\n    // create a plan\n    myGenerationPlan = new GenerationPlan(myOriginalInputModel.getSModel());\n    if (!checkGenerationPlan(myGenerationPlan)) {\n      // throw new GenerationCanceledException();\n    }\n\n    GenerationFilter filter = new GenerationFilter(myOriginalInputModel, myInvocationContext.getProject(), myGenerationContext);\n    myDependenciesBuilder = filter.createDependenciesBuilder();\n\n    if(!filter.getUnchangedRoots().isEmpty()) {\n      myLogger.info(filter.getUnchangedRoots().size() + \" roots are unchanged\");\n    }\n\n    try {\n      SModel currInputModel = myOriginalInputModel.getSModel();\n      SModel currOutput = null;\n\n      ttrace.push(\"steps\", false);\n      for (myMajorStep = 0; myMajorStep < myGenerationPlan.getStepCount(); myMajorStep++) {\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"executing step \" + (myMajorStep + 1));\n        }\n        //ttrace.push(\"step \" + (myMajorStep + 1), false);\n        currOutput = executeMajorStep(currInputModel);\n        //ttrace.pop();\n        if (currOutput == null || myLogger.getErrorCount() > 0) {\n          break;\n        }\n        if (myGenerationPlan.getMappingConfigurations(myMajorStep).isEmpty()) {\n          break;\n        }\n        currInputModel = currOutput;\n      }\n      ttrace.pop();\n\n      // we need this in order to prevent memory leaks from nodes which are reported to message view\n      // since session objects might include objects with disposed class loaders\n      if (mySessionContext != null) {\n        mySessionContext.clearTransientObjects();\n      }\n\n      return new GenerationStatus(myOriginalInputModel.getSModel(), currOutput,\n        myDependenciesBuilder.getResult(myInvocationContext.getProject()), myLogger.getErrorCount() > 0,\n        myLogger.getWarningCount() > 0, false);\n\n    } catch (GenerationCanceledException gce) {\n      throw gce;\n    } catch (GenerationFailureException gfe) {\n      myLogger.error(gfe.getMessage());\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelFqName() + \"\\\" generation failed : \" + gfe);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    } catch (Throwable e) {\n      myLogger.handleException(e);\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelFqName() + \"\\\" generation failed : \" + e);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    }\n  }","id":81825,"modified_method":"public GenerationStatus generateModel() throws GenerationCanceledException {\n    if (myMajorStep != 0) {\n      throw new GenerationCanceledException();\n    }\n\n    // create a plan\n    myGenerationPlan = new GenerationPlan(myOriginalInputModel.getSModel());\n    if (!checkGenerationPlan(myGenerationPlan)) {\n      // throw new GenerationCanceledException();\n    }\n\n    GenerationFilter filter = new GenerationFilter(myOriginalInputModel, myInvocationContext.getProject(), myGenerationContext);\n    myDependenciesBuilder = filter.createDependenciesBuilder();\n\n    if(!filter.getUnchangedRoots().isEmpty() || !filter.areConditionalsDirty()) {\n      int unchanged = filter.getUnchangedRoots().size();\n      int total = filter.getRootsCount();\n      myLogger.info((filter.areConditionalsDirty() ? \"\" : \"descriptors and \") + unchanged + \" of \" + total + \" roots are unchanged\");\n\n      if(total > 0 && unchanged == total && !filter.areConditionalsDirty()) {\n        myLogger.info(\"generated files are up-to-date\");\n        return new GenerationStatus(myOriginalInputModel.getSModel(), null,\n          myDependenciesBuilder.getResult(myInvocationContext.getProject()), false, false, false);\n      }\n    }\n\n    try {\n      SModel currInputModel = myOriginalInputModel.getSModel();\n      SModel currOutput = null;\n\n      ttrace.push(\"steps\", false);\n      for (myMajorStep = 0; myMajorStep < myGenerationPlan.getStepCount(); myMajorStep++) {\n        if (myLogger.needsInfo()) {\n          myLogger.info(\"executing step \" + (myMajorStep + 1));\n        }\n        //ttrace.push(\"step \" + (myMajorStep + 1), false);\n        currOutput = executeMajorStep(currInputModel);\n        //ttrace.pop();\n        if (currOutput == null || myLogger.getErrorCount() > 0) {\n          break;\n        }\n        if (myGenerationPlan.getMappingConfigurations(myMajorStep).isEmpty()) {\n          break;\n        }\n        currInputModel = currOutput;\n      }\n      ttrace.pop();\n\n      // we need this in order to prevent memory leaks from nodes which are reported to message view\n      // since session objects might include objects with disposed class loaders\n      if (mySessionContext != null) {\n        mySessionContext.clearTransientObjects();\n      }\n\n      return new GenerationStatus(myOriginalInputModel.getSModel(), currOutput,\n        myDependenciesBuilder.getResult(myInvocationContext.getProject()), myLogger.getErrorCount() > 0,\n        myLogger.getWarningCount() > 0, false);\n\n    } catch (GenerationCanceledException gce) {\n      throw gce;\n    } catch (GenerationFailureException gfe) {\n      myLogger.error(gfe.getMessage());\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelFqName() + \"\\\" generation failed : \" + gfe);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    } catch (Throwable e) {\n      myLogger.handleException(e);\n      myLogger.error(\"model \\\"\" + myOriginalInputModel.getSModelFqName() + \"\\\" generation failed : \" + e);\n      return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());\n    }\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModel preProcessModel(RuleManager ruleManager, SModel currentInputModel) throws GenerationFailureException {\n    List<MappingScript> preMappingScripts = ruleManager.getPreMappingScripts();\n    if (preMappingScripts.isEmpty()) {\n      return currentInputModel;\n    }\n\n    // need to clone input model?\n    boolean needToCloneInputMode = !myDiscardTransients;  // clone model if save transients (needed for tracing)\n    if (!needToCloneInputMode) {\n      for (MappingScript preMappingScript : preMappingScripts) {\n        if (preMappingScript.getScriptKind() == MappingScriptKind.pre_process_input_model) {\n          if (preMappingScript.getModifiesModel()) {\n            needToCloneInputMode = true;\n            break;\n          }\n        }\n      }\n    }\n    SModel toRecycle = null;\n    if (needToCloneInputMode) {\n      ttrace.push(\"model clone\", false);\n      SModel currentInputModel_clone = createTransientModel();\n      if (myLogger.needsInfo()) {\n        myLogger.info(\"clone model '\" + currentInputModel.getSModelFqName() + \"' --> '\" + currentInputModel_clone.getSModelFqName() + \"'\");\n      }\n      CloneUtil.cloneModel(currentInputModel, currentInputModel_clone, currentInputModel == mySessionContext.getOriginalInputModel());\n      ttrace.pop();\n\n      if (!myDiscardTransients) { // tracing\n        mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel, currentInputModel_clone, preMappingScripts);\n      }\n\n      // probably we can forget about former input model here\n      toRecycle = currentInputModel;\n      currentInputModel = currentInputModel_clone;\n    }\n\n    boolean preProcessed = false;\n    for (MappingScript preMappingScript : preMappingScripts) {\n      if (preMappingScript.getScriptKind() != MappingScriptKind.pre_process_input_model) {\n        myLogger.warning(preMappingScript.getNode(), \"skip script '\" + preMappingScript + \"' (\" + preMappingScript.getModel().getSModelFqName() + \") - wrong script kind\");\n        continue;\n      }\n      if (myLogger.needsInfo()) {\n        myLogger.info(preMappingScript.getNode(), \"pre-process '\" + preMappingScript + \"' (\" + preMappingScript.getModel().getSModelFqName() + \")\");\n      }\n      TemplateGenerator templateGenerator = new TemplateGenerator(mySessionContext, myProgressMonitor, myLogger, ruleManager, currentInputModel, currentInputModel, myGenerationContext, myDependenciesBuilder, ttrace);\n      templateGenerator.getDefaultExecutionContext(null).executeMappingScript(preMappingScript, currentInputModel);\n      preProcessed = true;\n    }\n    if(needToCloneInputMode) {\n      myDependenciesBuilder.scriptApplied(currentInputModel);\n      recycleWasteModel(toRecycle);\n    }\n    if(myLogger.needsInfo() && preProcessed) {\n      myLogger.info(\"pre-processing finished\");\n    }\n    return currentInputModel;\n  }","id":81826,"modified_method":"private SModel preProcessModel(RuleManager ruleManager, SModel currentInputModel) throws GenerationFailureException {\n    List<MappingScript> preMappingScripts = ruleManager.getPreMappingScripts();\n    if (preMappingScripts.isEmpty()) {\n      return currentInputModel;\n    }\n\n    // need to clone input model?\n    boolean needToCloneInputModel = !myDiscardTransients;  // clone model if save transients (needed for tracing)\n    if (!needToCloneInputModel) {\n      for (MappingScript preMappingScript : preMappingScripts) {\n        if (preMappingScript.getScriptKind() == MappingScriptKind.pre_process_input_model) {\n          if (preMappingScript.getModifiesModel()) {\n            needToCloneInputModel = true;\n            break;\n          }\n        }\n      }\n    }\n    SModel toRecycle = null;\n    if (needToCloneInputModel) {\n      ttrace.push(\"model clone\", false);\n      SModel currentInputModel_clone = createTransientModel();\n      if (myLogger.needsInfo()) {\n        myLogger.info(\"clone model '\" + currentInputModel.getSModelFqName() + \"' --> '\" + currentInputModel_clone.getSModelFqName() + \"'\");\n      }\n      CloneUtil.cloneModel(currentInputModel, currentInputModel_clone, currentInputModel == mySessionContext.getOriginalInputModel());\n      ttrace.pop();\n\n      if (!myDiscardTransients) { // tracing\n        mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel, currentInputModel_clone, preMappingScripts);\n      }\n\n      // probably we can forget about former input model here\n      toRecycle = currentInputModel;\n      currentInputModel = currentInputModel_clone;\n    }\n\n    boolean preProcessed = false;\n    for (MappingScript preMappingScript : preMappingScripts) {\n      if (preMappingScript.getScriptKind() != MappingScriptKind.pre_process_input_model) {\n        myLogger.warning(preMappingScript.getNode(), \"skip script '\" + preMappingScript + \"' (\" + preMappingScript.getModel().getSModelFqName() + \") - wrong script kind\");\n        continue;\n      }\n      if (myLogger.needsInfo()) {\n        myLogger.info(preMappingScript.getNode(), \"pre-process '\" + preMappingScript + \"' (\" + preMappingScript.getModel().getSModelFqName() + \")\");\n      }\n      TemplateGenerator templateGenerator = new TemplateGenerator(mySessionContext, myProgressMonitor, myLogger, ruleManager, currentInputModel, currentInputModel, myGenerationContext, myDependenciesBuilder, ttrace);\n      templateGenerator.getDefaultExecutionContext(null).executeMappingScript(preMappingScript, currentInputModel);\n      preProcessed = true;\n    }\n    if(needToCloneInputModel) {\n      myDependenciesBuilder.scriptApplied(currentInputModel);\n      recycleWasteModel(toRecycle);\n    }\n    if(myLogger.needsInfo() && preProcessed) {\n      myLogger.info(\"pre-processing finished\");\n    }\n    return currentInputModel;\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    info(\"handling output...\");\n\n    if (status.getOutputModel() != null) {\n      boolean result = collectSources(module, inputModel, invocationContext, status.getOutputModel());\n\n      if (!result) {\n        info(\"there were errors.\");\n        return false;\n      }\n    }\n    return true;\n  }","id":81827,"modified_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    info(\"handling output...\");\n\n    SModel outputModel = status.getOutputModel();\n    if (outputModel != null) {\n      boolean result = collectSources(module, inputModel, invocationContext, outputModel);\n\n      if (!result) {\n        info(\"there were errors.\");\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    info(\"handling output...\");\n    String targetDir = module.getOutputFor(inputModel);\n\n    if (status.getOutputModel() != null) {\n      long startJobTime = System.currentTimeMillis();\n      boolean result = FileGenerationManager.getInstance().handleOutput(invocationContext, status, new File(targetDir));\n\n      if (!result) {\n        info(\"there were errors.\");\n        return false;\n      }\n      if (myLogger.needsInfo()) {\n        myLogger.info(\"output generated in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n      }\n    } else if (!(status.isCanceled() || status.isError())) {\n      FileGenerationManager.getInstance().handleEmptyOutput(invocationContext, status, new File(targetDir));\n    }\n    return true;\n  }","id":81828,"modified_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    info(\"handling output...\");\n    String targetDir = module.getOutputFor(inputModel);\n\n    long startJobTime = System.currentTimeMillis();\n    boolean result = FileGenerationManager.getInstance().handleOutput(invocationContext, status, new File(targetDir));\n\n    if (!result) {\n      info(\"there were errors.\");\n      return false;\n    }\n    if (myLogger.needsInfo()) {\n      myLogger.info(\"output generated in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n    }\n    return true;\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext context, ITaskProgressHelper progressHelper) {\n    final OutputViewTool viewTool = OutputViewTool.getOutputViewTool(context.getProject());\n    viewTool.clear();\n\n    List<SNode> roots = new ArrayList<SNode>(status.getOutputModel().getRoots());\n    Collections.sort(roots, new Comparator<SNode>() {\n      public int compare(SNode o1, SNode o2) {\n        String name1 = o1.getName();\n        String name2 = o2.getName();\n        if (name1 == null && name2 == null) {\n          return o1.hashCode() - o2.hashCode();\n        }\n        if (name1 == null) return -1;\n        if (name2 == null) return 1;\n        return name1.compareTo(name2);\n      }\n    });\n\n    boolean wereErrors = false;\n    for (SNode root : roots) {\n      TextGenerationResult result = TextGenerationUtil.generateText(context, root);\n      wereErrors |= result.hasErrors();\n      final String nodeText = result.getText();\n      ThreadUtils.runInUIThreadNoWait(new Runnable() {\n        public void run() {\n          viewTool.append(nodeText);\n          viewTool.append(\"\\n\");\n          viewTool.append(\"\\r\\n-------------------------------------------------------------------------------\\n\");\n        }\n      });\n    }\n\n    viewTool.openToolLater(true);\n\n    return !wereErrors;\n  }","id":81829,"modified_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext context, ITaskProgressHelper progressHelper) {\n    final OutputViewTool viewTool = OutputViewTool.getOutputViewTool(context.getProject());\n    viewTool.clear();\n\n    SModel outputModel = status.getOutputModel();\n    List<SNode> roots = new ArrayList<SNode>(outputModel != null ? outputModel.getRoots() : Collections.<SNode>emptyList());\n    Collections.sort(roots, new Comparator<SNode>() {\n      public int compare(SNode o1, SNode o2) {\n        String name1 = o1.getName();\n        String name2 = o2.getName();\n        if (name1 == null && name2 == null) {\n          return o1.hashCode() - o2.hashCode();\n        }\n        if (name1 == null) return -1;\n        if (name2 == null) return 1;\n        return name1.compareTo(name2);\n      }\n    });\n\n    boolean wereErrors = false;\n    for (SNode root : roots) {\n      TextGenerationResult result = TextGenerationUtil.generateText(context, root);\n      wereErrors |= result.hasErrors();\n      final String nodeText = result.getText();\n      ThreadUtils.runInUIThreadNoWait(new Runnable() {\n        public void run() {\n          viewTool.append(nodeText);\n          viewTool.append(\"\\n\");\n          viewTool.append(\"\\r\\n-------------------------------------------------------------------------------\\n\");\n        }\n      });\n    }\n\n    viewTool.openToolLater(true);\n\n    return !wereErrors;\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext ocontext, ITaskProgressHelper progressHelper) {\n    String targetDir = module.getOutputFor(inputModel);\n    List<SNode> roots = status.getOutputModel().getRoots();\n    boolean generatedOk = true;\n    // generate files\n    for (SNode output : ListSequence.fromList(roots)) {\n      String fileName = output.getName() + \".\" + TextGenManager.instance().getExtension(output);\n      TextGenerationResult result = TextGenerationUtil.generateText(ocontext, output);\n      if(result.hasErrors()) {\n        warning(\"cannot generate \" + fileName);\n        generatedOk = false;\n      } else {\n        fileGenerated(targetDir, fileName, result);\n      }\n    }\n    return generatedOk;\n  }","id":81830,"modified_method":"public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext ocontext, ITaskProgressHelper progressHelper) {\n    String targetDir = module.getOutputFor(inputModel);\n    SModel outputModel = status.getOutputModel();\n    List<SNode> roots = outputModel != null ? outputModel.getRoots() : Collections.<SNode>emptyList();\n    boolean generatedOk = true;\n    // generate files\n    for (SNode output : ListSequence.fromList(roots)) {\n      String fileName = output.getName() + \".\" + TextGenManager.instance().getExtension(output);\n      TextGenerationResult result = TextGenerationUtil.generateText(ocontext, output);\n      if(result.hasErrors()) {\n        warning(\"cannot generate \" + fileName);\n        generatedOk = false;\n      } else {\n        fileGenerated(targetDir, fileName, result);\n      }\n    }\n    return generatedOk;\n  }","commit_id":"3fb48fbbc3741448c9916c4f0f620a4bb1cb21b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void setupTCPCommunication() throws Exception {\n        if (channelFactory == null) {\n            bossExecutor = context.getExecutorServiceManager().newCachedThreadPool(this, \"NettyTCPBoss\");\n            workerExecutor = context.getExecutorServiceManager().newCachedThreadPool(this, \"NettyTCPWorker\");\n            if (configuration.getWorkerCount() <= 0) {\n                channelFactory = new NioClientSocketChannelFactory(bossExecutor, workerExecutor);\n            } else {\n                channelFactory = new NioClientSocketChannelFactory(bossExecutor, workerExecutor, configuration.getWorkerCount());\n            }\n        }\n    }","id":81831,"modified_method":"protected void setupTCPCommunication() throws Exception {\n        if (channelFactory == null) {\n            // prefer using explicit configured thread pools\n            BossPool bp = configuration.getBossPool();\n            WorkerPool wp = configuration.getWorkerPool();\n\n            if (bp == null) {\n                // create new pool which we should shutdown when stopping as its not shared\n                bossPool = new NettyClientBossPoolBuilder()\n                        .withBossCount(configuration.getBossCount())\n                        .withName(\"NettyClientTCPBoss\")\n                        .build();\n                bp = bossPool;\n            }\n            if (wp == null) {\n                // create new pool which we should shutdown when stopping as its not shared\n                workerPool = new NettyWorkerPoolBuilder()\n                        .withWorkerCount(configuration.getWorkerCount())\n                        .withName(\"NettyClientTCPWorker\")\n                        .build();\n                wp = workerPool;\n            }\n            channelFactory = new NioClientSocketChannelFactory(bp, wp);\n        }\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"protected void setupUDPCommunication() throws Exception {\n        if (datagramChannelFactory == null) {\n            workerExecutor = context.getExecutorServiceManager().newCachedThreadPool(this, \"NettyUDPWorker\");\n            if (configuration.getWorkerCount() <= 0) {\n                datagramChannelFactory = new NioDatagramChannelFactory(workerExecutor);\n            } else {\n                datagramChannelFactory = new NioDatagramChannelFactory(workerExecutor, configuration.getWorkerCount());\n            }\n        }\n    }","id":81832,"modified_method":"protected void setupUDPCommunication() throws Exception {\n        if (datagramChannelFactory == null) {\n            int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : NettyHelper.DEFAULT_IO_THREADS;\n            workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n            datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n        }\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStop() throws Exception {\n        LOG.debug(\"Stopping producer at address: {}\", configuration.getAddress());\n        // close all channels\n        LOG.trace(\"Closing {} channels\", ALL_CHANNELS.size());\n        ChannelGroupFuture future = ALL_CHANNELS.close();\n        future.awaitUninterruptibly();\n\n        // and then release other resources\n        if (channelFactory != null) {\n            channelFactory.releaseExternalResources();\n        }\n\n        // and then shutdown the thread pools\n        if (bossExecutor != null) {\n            context.getExecutorServiceManager().shutdown(bossExecutor);\n            bossExecutor = null;\n        }\n        if (workerExecutor != null) {\n            context.getExecutorServiceManager().shutdown(workerExecutor);\n            workerExecutor = null;\n        }\n\n        if (pool != null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Stopping producer with channel pool[active={}, idle={}]\", pool.getNumActive(), pool.getNumIdle());\n            }\n            pool.close();\n            pool = null;\n        }\n\n        super.doStop();\n    }","id":81833,"modified_method":"@Override\n    protected void doStop() throws Exception {\n        LOG.debug(\"Stopping producer at address: {}\", configuration.getAddress());\n        // close all channels\n        LOG.trace(\"Closing {} channels\", ALL_CHANNELS.size());\n        ChannelGroupFuture future = ALL_CHANNELS.close();\n        future.awaitUninterruptibly();\n\n        // and then release other resources\n        if (channelFactory != null) {\n            channelFactory.releaseExternalResources();\n        }\n\n        // and then shutdown the thread pools\n        if (bossPool != null) {\n            bossPool.shutdown();\n            bossPool = null;\n        }\n        if (workerPool != null) {\n            workerPool.shutdown();\n            workerPool = null;\n        }\n\n        if (pool != null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Stopping producer with channel pool[active={}, idle={}]\", pool.getNumActive(), pool.getNumIdle());\n            }\n            pool.close();\n            pool = null;\n        }\n\n        super.doStop();\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                sharedWorker = new NettyWorkerPoolBuilder().withWorkerCount(10).build();\n                jndi.bind(\"sharedWorker\", sharedWorker);\n                sharedBoos = new NettyBossPoolBuilder().withBossCount(20).build();\n                jndi.bind(\"sharedBoss\", sharedBoos);\n\n                for (int i = 0; i < 100; i++) {\n                    from(\"netty:tcp://localhost:\" + getNextPort() + \"?textline=true&sync=true&orderedThreadPoolExecutor=false\"\n                            + \"&bossPool=#sharedBoss&workerPool=#sharedWorker\")\n                        .validate(body().isInstanceOf(String.class))\n                        .to(\"log:result\")\n                        .to(\"mock:result\")\n                        .transform(body().regexReplaceAll(\"Hello\", \"Bye\"));\n                }\n            }\n        };\n    }","id":81834,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                sharedWorker = new NettyWorkerPoolBuilder().withWorkerCount(10).build();\n                jndi.bind(\"sharedWorker\", sharedWorker);\n                sharedBoos = new NettyServerBossPoolBuilder().withBossCount(20).build();\n                jndi.bind(\"sharedBoss\", sharedBoos);\n\n                for (int i = 0; i < 100; i++) {\n                    from(\"netty:tcp://localhost:\" + getNextPort() + \"?textline=true&sync=true&orderedThreadPoolExecutor=false\"\n                            + \"&bossPool=#sharedBoss&workerPool=#sharedWorker\")\n                        .validate(body().isInstanceOf(String.class))\n                        .to(\"log:result\")\n                        .to(\"mock:result\")\n                        .transform(body().regexReplaceAll(\"Hello\", \"Bye\"));\n                }\n            }\n        };\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testSharedThreadPool() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedMessageCount(30);\n\n        for (int i = 0; i < 10; i++) {\n            String reply = template.requestBody(\"netty:tcp://localhost:\" + port + \"?textline=true&sync=true\", \"Hello World\", String.class);\n            assertEquals(\"Bye World\", reply);\n\n            reply = template.requestBody(\"netty:tcp://localhost:\" + port2 + \"?textline=true&sync=true\", \"Hello Camel\", String.class);\n            assertEquals(\"Hi Camel\", reply);\n\n            reply = template.requestBody(\"netty:tcp://localhost:\" + port3 + \"?textline=true&sync=true\", \"Hello Claus\", String.class);\n            assertEquals(\"Hej Claus\", reply);\n        }\n\n        assertMockEndpointsSatisfied();\n\n        shared.shutdown();\n    }","id":81835,"modified_method":"@Test\n    public void testSharedThreadPool() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedMessageCount(30);\n\n        for (int i = 0; i < 10; i++) {\n            String reply = template.requestBody(\"netty:tcp://localhost:\" + port + \"?textline=true&sync=true&workerPool=#sharedClientPool\", \"Hello World\", String.class);\n            assertEquals(\"Bye World\", reply);\n\n            reply = template.requestBody(\"netty:tcp://localhost:\" + port2 + \"?textline=true&sync=true&workerPool=#sharedClientPool\", \"Hello Camel\", String.class);\n            assertEquals(\"Hi Camel\", reply);\n\n            reply = template.requestBody(\"netty:tcp://localhost:\" + port3 + \"?textline=true&sync=true&workerPool=#sharedClientPool\", \"Hello Claus\", String.class);\n            assertEquals(\"Hej Claus\", reply);\n        }\n\n        assertMockEndpointsSatisfied();\n\n        sharedServer.shutdown();\n        sharedClient.shutdown();\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // we have 3 routes, but lets try to have only 2 threads in the pool\n                shared = new NettyWorkerPoolBuilder().withWorkerCount(2).build();\n                jndi.bind(\"sharedPool\", shared);\n\n                port = getPort();\n                port2 = getNextPort();\n                port3 = getNextPort();\n\n                from(\"netty:tcp://localhost:\" + port + \"?textline=true&sync=true&workerPool=#sharedPool&orderedThreadPoolExecutor=false\")\n                    .validate(body().isInstanceOf(String.class))\n                    .to(\"log:result\")\n                    .to(\"mock:result\")\n                    .transform(body().regexReplaceAll(\"Hello\", \"Bye\"));\n\n                from(\"netty:tcp://localhost:\" + port2 + \"?textline=true&sync=true&workerPool=#sharedPool&orderedThreadPoolExecutor=false\")\n                    .validate(body().isInstanceOf(String.class))\n                    .to(\"log:result\")\n                    .to(\"mock:result\")\n                    .transform(body().regexReplaceAll(\"Hello\", \"Hi\"));\n\n                from(\"netty:tcp://localhost:\" + port3 + \"?textline=true&sync=true&workerPool=#sharedPool&orderedThreadPoolExecutor=false\")\n                    .validate(body().isInstanceOf(String.class))\n                    .to(\"log:result\")\n                    .to(\"mock:result\")\n                    .transform(body().regexReplaceAll(\"Hello\", \"Hej\"));\n            }\n        };\n    }","id":81836,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // we have 3 routes, but lets try to have only 2 threads in the pool\n                sharedServer = new NettyWorkerPoolBuilder().withWorkerCount(2).withName(\"NettyServer\").build();\n                jndi.bind(\"sharedServerPool\", sharedServer);\n                sharedClient = new NettyWorkerPoolBuilder().withWorkerCount(3).withName(\"NettyClient\").build();\n                jndi.bind(\"sharedClientPool\", sharedClient);\n\n                port = getPort();\n                port2 = getNextPort();\n                port3 = getNextPort();\n\n                from(\"netty:tcp://localhost:\" + port + \"?textline=true&sync=true&workerPool=#sharedServerPool&orderedThreadPoolExecutor=false\")\n                    .validate(body().isInstanceOf(String.class))\n                    .to(\"log:result\")\n                    .to(\"mock:result\")\n                    .transform(body().regexReplaceAll(\"Hello\", \"Bye\"));\n\n                from(\"netty:tcp://localhost:\" + port2 + \"?textline=true&sync=true&workerPool=#sharedServerPool&orderedThreadPoolExecutor=false\")\n                    .validate(body().isInstanceOf(String.class))\n                    .to(\"log:result\")\n                    .to(\"mock:result\")\n                    .transform(body().regexReplaceAll(\"Hello\", \"Hi\"));\n\n                from(\"netty:tcp://localhost:\" + port3 + \"?textline=true&sync=true&workerPool=#sharedServerPool&orderedThreadPoolExecutor=false\")\n                    .validate(body().isInstanceOf(String.class))\n                    .to(\"log:result\")\n                    .to(\"mock:result\")\n                    .transform(body().regexReplaceAll(\"Hello\", \"Hej\"));\n            }\n        };\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"protected void startServerBootstrap() {\n        // prefer using explicit configured thread pools\n        BossPool bp = configuration.getBossPool();\n        WorkerPool wp = configuration.getWorkerPool();\n\n        if (bp == null) {\n            // create new pool which we should shutdown when stopping as its not shared\n            bossPool = new NettyBossPoolBuilder()\n                    .withBossCount(configuration.getBossCount())\n                    .withName(\"NettyTCPBoss\")\n                    .build();\n            bp = bossPool;\n        }\n        if (wp == null) {\n            // create new pool which we should shutdown when stopping as its not shared\n            workerPool = new NettyWorkerPoolBuilder()\n                    .withWorkerCount(configuration.getWorkerCount())\n                    .withName(\"NettyTCPWorker\")\n                    .build();\n            wp = workerPool;\n        }\n\n        channelFactory = new NioServerSocketChannelFactory(bp, wp);\n\n        serverBootstrap = new ServerBootstrap(channelFactory);\n        serverBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        serverBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        serverBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        if (configuration.getBacklog() > 0) {\n            serverBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                serverBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ServerBootstrap {} with options: {}\", serverBootstrap, serverBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        serverBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ServerBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = serverBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","id":81837,"modified_method":"protected void startServerBootstrap() {\n        // prefer using explicit configured thread pools\n        BossPool bp = configuration.getBossPool();\n        WorkerPool wp = configuration.getWorkerPool();\n\n        if (bp == null) {\n            // create new pool which we should shutdown when stopping as its not shared\n            bossPool = new NettyServerBossPoolBuilder()\n                    .withBossCount(configuration.getBossCount())\n                    .withName(\"NettyServerTCPBoss\")\n                    .build();\n            bp = bossPool;\n        }\n        if (wp == null) {\n            // create new pool which we should shutdown when stopping as its not shared\n            workerPool = new NettyWorkerPoolBuilder()\n                    .withWorkerCount(configuration.getWorkerCount())\n                    .withName(\"NettyServerTCPWorker\")\n                    .build();\n            wp = workerPool;\n        }\n\n        channelFactory = new NioServerSocketChannelFactory(bp, wp);\n\n        serverBootstrap = new ServerBootstrap(channelFactory);\n        serverBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        serverBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        serverBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        if (configuration.getBacklog() > 0) {\n            serverBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                serverBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ServerBootstrap {} with options: {}\", serverBootstrap, serverBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        serverBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ServerBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = serverBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"protected void startServerBootstrap() {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = connectionlessBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","id":81838,"modified_method":"protected void startServerBootstrap() {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : NettyHelper.DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = connectionlessBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","commit_id":"39ce6256870006d0490bac6c7fff1ef2abbd0470","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Checks if the other {@link NettyServerBootstrapConfiguration} is compatible\n     * with this, as a Netty listener bound on port X shares the same common\n     * {@link NettyServerBootstrapConfiguration}, which must be identical.\n     */\n    public boolean compatible(NettyServerBootstrapConfiguration other) {\n        boolean isCompatible = true;\n\n        if (!protocol.equals(other.protocol)) {\n            isCompatible = false;\n        } else if (!host.equals(other.host)) {\n            isCompatible = false;\n        } else if (port != other.port) {\n            isCompatible = false;\n        } else if (broadcast != other.broadcast) {\n            isCompatible = false;\n        } else if (sendBufferSize != other.sendBufferSize) {\n            return false;\n        } else if (receiveBufferSize != other.receiveBufferSize) {\n            isCompatible = false;\n        } else if (receiveBufferSizePredictor != other.receiveBufferSizePredictor) {\n            isCompatible = false;\n        } else if (workerCount != other.workerCount) {\n            isCompatible = false;\n        } else if (keepAlive != other.keepAlive) {\n            isCompatible = false;\n        } else if (tcpNoDelay != other.tcpNoDelay) {\n            isCompatible = false;\n        } else if (reuseAddress != other.reuseAddress) {\n            isCompatible = false;\n        } else if (connectTimeout != other.connectTimeout) {\n            isCompatible = false;\n        } else if (backlog != other.backlog) {\n            isCompatible = false;\n        } else if (serverPipelineFactory != other.serverPipelineFactory) {\n            isCompatible = false;\n        } else if (nettyServerBootstrapFactory != other.nettyServerBootstrapFactory) {\n            isCompatible = false;\n        } else if (options == null && other.options != null) {\n            // validate all the options is identical\n            isCompatible = false;\n        } else if (options != null && other.options == null) {\n            isCompatible = false;\n        } else if (options != null && other.options != null && options.size() != other.options.size()) {\n            isCompatible = false;\n        } else if (options != null && other.options != null && !options.keySet().containsAll(other.options.keySet())) {\n            isCompatible = false;\n        } else if (options != null && other.options != null && !options.values().containsAll(other.options.values())) {\n            isCompatible = false;\n        } else if (ssl != other.ssl) {\n            isCompatible = false;\n        } else if (sslHandler != other.sslHandler) {\n            isCompatible = false;\n        } else if (sslContextParameters != other.sslContextParameters) {\n            isCompatible = false;\n        } else if (needClientAuth != other.needClientAuth) {\n            isCompatible = false;\n        } else if (keyStoreFile != other.keyStoreFile) {\n            isCompatible = false;\n        } else if (trustStoreFile != other.trustStoreFile) {\n            isCompatible = false;\n        } else if (keyStoreResource != null && !keyStoreResource.equals(other.keyStoreResource)) {\n            isCompatible = false;\n        } else if (trustStoreResource != null && !trustStoreResource.equals(other.trustStoreResource)) {\n            isCompatible = false;\n        } else if (keyStoreFormat != null && !keyStoreFormat.equals(other.keyStoreFormat)) {\n            isCompatible = false;\n        } else if (securityProvider != null && !securityProvider.equals(other.securityProvider)) {\n            isCompatible = false;\n        } else if (passphrase != null && !passphrase.equals(other.passphrase)) {\n            isCompatible = false;\n        }\n\n        return isCompatible;\n    }","id":81839,"modified_method":"/**\n     * Checks if the other {@link NettyServerBootstrapConfiguration} is compatible\n     * with this, as a Netty listener bound on port X shares the same common\n     * {@link NettyServerBootstrapConfiguration}, which must be identical.\n     */\n    public boolean compatible(NettyServerBootstrapConfiguration other) {\n        boolean isCompatible = true;\n\n        if (!protocol.equals(other.protocol)) {\n            isCompatible = false;\n        } else if (!host.equals(other.host)) {\n            isCompatible = false;\n        } else if (port != other.port) {\n            isCompatible = false;\n        } else if (broadcast != other.broadcast) {\n            isCompatible = false;\n        } else if (sendBufferSize != other.sendBufferSize) {\n            return false;\n        } else if (receiveBufferSize != other.receiveBufferSize) {\n            isCompatible = false;\n        } else if (receiveBufferSizePredictor != other.receiveBufferSizePredictor) {\n            isCompatible = false;\n        } else if (workerCount != other.workerCount) {\n            isCompatible = false;\n        } else if (bossCount != other.bossCount) {\n            isCompatible = false;\n        } else if (keepAlive != other.keepAlive) {\n            isCompatible = false;\n        } else if (tcpNoDelay != other.tcpNoDelay) {\n            isCompatible = false;\n        } else if (reuseAddress != other.reuseAddress) {\n            isCompatible = false;\n        } else if (connectTimeout != other.connectTimeout) {\n            isCompatible = false;\n        } else if (backlog != other.backlog) {\n            isCompatible = false;\n        } else if (serverPipelineFactory != other.serverPipelineFactory) {\n            isCompatible = false;\n        } else if (nettyServerBootstrapFactory != other.nettyServerBootstrapFactory) {\n            isCompatible = false;\n        } else if (options == null && other.options != null) {\n            // validate all the options is identical\n            isCompatible = false;\n        } else if (options != null && other.options == null) {\n            isCompatible = false;\n        } else if (options != null && other.options != null && options.size() != other.options.size()) {\n            isCompatible = false;\n        } else if (options != null && other.options != null && !options.keySet().containsAll(other.options.keySet())) {\n            isCompatible = false;\n        } else if (options != null && other.options != null && !options.values().containsAll(other.options.values())) {\n            isCompatible = false;\n        } else if (ssl != other.ssl) {\n            isCompatible = false;\n        } else if (sslHandler != other.sslHandler) {\n            isCompatible = false;\n        } else if (sslContextParameters != other.sslContextParameters) {\n            isCompatible = false;\n        } else if (needClientAuth != other.needClientAuth) {\n            isCompatible = false;\n        } else if (keyStoreFile != other.keyStoreFile) {\n            isCompatible = false;\n        } else if (trustStoreFile != other.trustStoreFile) {\n            isCompatible = false;\n        } else if (keyStoreResource != null && !keyStoreResource.equals(other.keyStoreResource)) {\n            isCompatible = false;\n        } else if (trustStoreResource != null && !trustStoreResource.equals(other.trustStoreResource)) {\n            isCompatible = false;\n        } else if (keyStoreFormat != null && !keyStoreFormat.equals(other.keyStoreFormat)) {\n            isCompatible = false;\n        } else if (securityProvider != null && !securityProvider.equals(other.securityProvider)) {\n            isCompatible = false;\n        } else if (passphrase != null && !passphrase.equals(other.passphrase)) {\n            isCompatible = false;\n        } else if (bossPool != other.bossPool) {\n            isCompatible = false;\n        } else if (workerPool != other.workerPool) {\n            isCompatible = false;\n        }\n\n        return isCompatible;\n    }","commit_id":"4664d64c69840637b564b5f65c5ec0f026e46c10","url":"https://github.com/apache/camel"},{"original_method":"public String toStringBootstrapConfiguration() {\n        return \"NettyServerBootstrapConfiguration{\"\n                + \"protocol='\" + protocol + '\\''\n                + \", host='\" + host + '\\''\n                + \", port=\" + port\n                + \", broadcast=\" + broadcast\n                + \", sendBufferSize=\" + sendBufferSize\n                + \", receiveBufferSize=\" + receiveBufferSize\n                + \", receiveBufferSizePredictor=\" + receiveBufferSizePredictor\n                + \", workerCount=\" + workerCount\n                + \", keepAlive=\" + keepAlive\n                + \", tcpNoDelay=\" + tcpNoDelay\n                + \", reuseAddress=\" + reuseAddress\n                + \", connectTimeout=\" + connectTimeout\n                + \", backlog=\" + backlog\n                + \", serverPipelineFactory=\" + serverPipelineFactory\n                + \", nettyServerBootstrapFactory=\" + nettyServerBootstrapFactory\n                + \", options=\" + options\n                + \", ssl=\" + ssl\n                + \", sslHandler=\" + sslHandler\n                + \", sslContextParameters='\" + sslContextParameters + '\\''\n                + \", needClientAuth=\" + needClientAuth\n                + \", keyStoreFile=\" + keyStoreFile\n                + \", trustStoreFile=\" + trustStoreFile\n                + \", keyStoreResource='\" + keyStoreResource + '\\''\n                + \", trustStoreResource='\" + trustStoreResource + '\\''\n                + \", keyStoreFormat='\" + keyStoreFormat + '\\''\n                + \", securityProvider='\" + securityProvider + '\\''\n                + \", passphrase='\" + passphrase + '\\''\n                + '}';\n    }","id":81840,"modified_method":"public String toStringBootstrapConfiguration() {\n        return \"NettyServerBootstrapConfiguration{\"\n                + \"protocol='\" + protocol + '\\''\n                + \", host='\" + host + '\\''\n                + \", port=\" + port\n                + \", broadcast=\" + broadcast\n                + \", sendBufferSize=\" + sendBufferSize\n                + \", receiveBufferSize=\" + receiveBufferSize\n                + \", receiveBufferSizePredictor=\" + receiveBufferSizePredictor\n                + \", workerCount=\" + workerCount\n                + \", bossCount=\" + bossCount\n                + \", keepAlive=\" + keepAlive\n                + \", tcpNoDelay=\" + tcpNoDelay\n                + \", reuseAddress=\" + reuseAddress\n                + \", connectTimeout=\" + connectTimeout\n                + \", backlog=\" + backlog\n                + \", serverPipelineFactory=\" + serverPipelineFactory\n                + \", nettyServerBootstrapFactory=\" + nettyServerBootstrapFactory\n                + \", options=\" + options\n                + \", ssl=\" + ssl\n                + \", sslHandler=\" + sslHandler\n                + \", sslContextParameters='\" + sslContextParameters + '\\''\n                + \", needClientAuth=\" + needClientAuth\n                + \", keyStoreFile=\" + keyStoreFile\n                + \", trustStoreFile=\" + trustStoreFile\n                + \", keyStoreResource='\" + keyStoreResource + '\\''\n                + \", trustStoreResource='\" + trustStoreResource + '\\''\n                + \", keyStoreFormat='\" + keyStoreFormat + '\\''\n                + \", securityProvider='\" + securityProvider + '\\''\n                + \", passphrase='\" + passphrase + '\\''\n                + \", bossPool=\" + bossPool\n                + \", workerPool=\" + workerPool\n                + '}';\n    }","commit_id":"4664d64c69840637b564b5f65c5ec0f026e46c10","url":"https://github.com/apache/camel"},{"original_method":"protected void startServerBootstrap() {\n        if (camelContext != null) {\n            bossExecutor = camelContext.getExecutorServiceManager().newCachedThreadPool(this, \"NettyTCPBoss\");\n            workerExecutor = camelContext.getExecutorServiceManager().newCachedThreadPool(this, \"NettyTCPWorker\");\n        } else {\n            bossExecutor = Executors.newCachedThreadPool(threadFactory);\n            workerExecutor = Executors.newCachedThreadPool(threadFactory);\n        }\n\n        if (configuration.getWorkerCount() <= 0) {\n            channelFactory = new NioServerSocketChannelFactory(bossExecutor, workerExecutor);\n        } else {\n            channelFactory = new NioServerSocketChannelFactory(bossExecutor, workerExecutor,\n                    configuration.getWorkerCount());\n        }\n\n        serverBootstrap = new ServerBootstrap(channelFactory);\n        serverBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        serverBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        serverBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        if (configuration.getBacklog() > 0) {\n            serverBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                serverBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ServerBootstrap {} with options: {}\", serverBootstrap, serverBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        serverBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ServerBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = serverBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","id":81841,"modified_method":"protected void startServerBootstrap() {\n        // prefer using explicit configured thread pools\n        BossPool bp = configuration.getBossPool();\n        WorkerPool wp = configuration.getWorkerPool();\n\n        if (bp == null) {\n            // create new pool which we should shutdown when stopping as its not shared\n            bossPool = new NettyBossPoolBuilder()\n                    .withBossCount(configuration.getBossCount())\n                    .withName(\"NettyTCPBoss\")\n                    .build();\n            bp = bossPool;\n        }\n        if (wp == null) {\n            // create new pool which we should shutdown when stopping as its not shared\n            workerPool = new NettyWorkerPoolBuilder()\n                    .withWorkerCount(configuration.getWorkerCount())\n                    .withName(\"NettyTCPWorker\")\n                    .build();\n            wp = workerPool;\n        }\n\n        channelFactory = new NioServerSocketChannelFactory(bp, wp);\n\n        serverBootstrap = new ServerBootstrap(channelFactory);\n        serverBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        serverBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        serverBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        serverBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        if (configuration.getBacklog() > 0) {\n            serverBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                serverBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ServerBootstrap {} with options: {}\", serverBootstrap, serverBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        serverBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ServerBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = serverBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","commit_id":"4664d64c69840637b564b5f65c5ec0f026e46c10","url":"https://github.com/apache/camel"},{"original_method":"protected void stopServerBootstrap() {\n        // close all channels\n        LOG.info(\"ServerBootstrap unbinding from {}:{}\", configuration.getHost(), configuration.getPort());\n\n        LOG.trace(\"Closing {} channels\", allChannels.size());\n        ChannelGroupFuture future = allChannels.close();\n        future.awaitUninterruptibly();\n\n        // close server external resources\n        if (channelFactory != null) {\n            channelFactory.releaseExternalResources();\n            channelFactory = null;\n        }\n\n        // and then shutdown the thread pools\n        if (bossExecutor != null) {\n            if (camelContext != null) {\n                camelContext.getExecutorServiceManager().shutdown(bossExecutor);\n            } else {\n                bossExecutor.shutdownNow();\n            }\n            bossExecutor = null;\n        }\n        if (workerExecutor != null) {\n            if (camelContext != null) {\n                camelContext.getExecutorServiceManager().shutdown(workerExecutor);\n            } else {\n                workerExecutor.shutdownNow();\n            }\n            workerExecutor = null;\n        }\n    }","id":81842,"modified_method":"protected void stopServerBootstrap() {\n        // close all channels\n        LOG.info(\"ServerBootstrap unbinding from {}:{}\", configuration.getHost(), configuration.getPort());\n\n        LOG.trace(\"Closing {} channels\", allChannels.size());\n        ChannelGroupFuture future = allChannels.close();\n        future.awaitUninterruptibly();\n\n        // close server external resources\n        if (channelFactory != null) {\n            channelFactory.releaseExternalResources();\n            channelFactory = null;\n        }\n\n        // and then shutdown the thread pools\n        if (bossPool != null) {\n            bossPool.shutdown();\n            bossPool = null;\n        }\n        if (workerPool != null) {\n            workerPool.shutdown();\n            workerPool = null;\n        }\n    }","commit_id":"4664d64c69840637b564b5f65c5ec0f026e46c10","url":"https://github.com/apache/camel"},{"original_method":"protected void startServerBootstrap() {\n        if (camelContext != null) {\n            workerExecutor = camelContext.getExecutorServiceManager().newCachedThreadPool(this, \"NettyUDPWorker\");\n        } else {\n            workerExecutor = Executors.newCachedThreadPool(threadFactory);\n        }\n\n        if (configuration.getWorkerCount() <= 0) {\n            datagramChannelFactory = new NioDatagramChannelFactory(workerExecutor);\n        } else {\n            datagramChannelFactory = new NioDatagramChannelFactory(workerExecutor, configuration.getWorkerCount());\n        }\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = connectionlessBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","id":81843,"modified_method":"protected void startServerBootstrap() {\n        // create non-shared worker pool\n        int count = configuration.getWorkerCount() > 0 ? configuration.getWorkerCount() : DEFAULT_IO_THREADS;\n        workerPool = new NioDatagramWorkerPool(Executors.newCachedThreadPool(), count);\n\n        datagramChannelFactory = new NioDatagramChannelFactory(workerPool);\n\n        connectionlessBootstrap = new ConnectionlessBootstrap(datagramChannelFactory);\n        connectionlessBootstrap.setOption(\"child.keepAlive\", configuration.isKeepAlive());\n        connectionlessBootstrap.setOption(\"child.tcpNoDelay\", configuration.isTcpNoDelay());\n        connectionlessBootstrap.setOption(\"reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.reuseAddress\", configuration.isReuseAddress());\n        connectionlessBootstrap.setOption(\"child.connectTimeoutMillis\", configuration.getConnectTimeout());\n        connectionlessBootstrap.setOption(\"child.broadcast\", configuration.isBroadcast());\n        connectionlessBootstrap.setOption(\"sendBufferSize\", configuration.getSendBufferSize());\n        connectionlessBootstrap.setOption(\"receiveBufferSize\", configuration.getReceiveBufferSize());\n        // only set this if user has specified\n        if (configuration.getReceiveBufferSizePredictor() > 0) {\n            connectionlessBootstrap.setOption(\"receiveBufferSizePredictorFactory\",\n                    new FixedReceiveBufferSizePredictorFactory(configuration.getReceiveBufferSizePredictor()));\n        }\n        if (configuration.getBacklog() > 0) {\n            connectionlessBootstrap.setOption(\"backlog\", configuration.getBacklog());\n        }\n\n        // set any additional netty options\n        if (configuration.getOptions() != null) {\n            for (Map.Entry<String, Object> entry : configuration.getOptions().entrySet()) {\n                connectionlessBootstrap.setOption(entry.getKey(), entry.getValue());\n            }\n        }\n\n        LOG.debug(\"Created ConnectionlessBootstrap {} with options: {}\", connectionlessBootstrap, connectionlessBootstrap.getOptions());\n\n        // set the pipeline factory, which creates the pipeline for each newly created channels\n        connectionlessBootstrap.setPipelineFactory(pipelineFactory);\n\n        LOG.info(\"ConnectionlessBootstrap binding to {}:{}\", configuration.getHost(), configuration.getPort());\n        channel = connectionlessBootstrap.bind(new InetSocketAddress(configuration.getHost(), configuration.getPort()));\n        // to keep track of all channels in use\n        allChannels.add(channel);\n    }","commit_id":"4664d64c69840637b564b5f65c5ec0f026e46c10","url":"https://github.com/apache/camel"},{"original_method":"protected void stopServerBootstrap() {\n        // close all channels\n        LOG.info(\"ConnectionlessBootstrap unbinding from {}:{}\", configuration.getHost(), configuration.getPort());\n\n        LOG.trace(\"Closing {} channels\", allChannels.size());\n        ChannelGroupFuture future = allChannels.close();\n        future.awaitUninterruptibly();\n\n        // close server external resources\n        if (datagramChannelFactory != null) {\n            datagramChannelFactory.releaseExternalResources();\n            datagramChannelFactory = null;\n        }\n\n        // and then shutdown the thread pools\n        if (workerExecutor != null) {\n            if (camelContext != null) {\n                camelContext.getExecutorServiceManager().shutdown(workerExecutor);\n            } else {\n                workerExecutor.shutdownNow();\n            }\n            workerExecutor = null;\n        }\n    }","id":81844,"modified_method":"protected void stopServerBootstrap() {\n        // close all channels\n        LOG.info(\"ConnectionlessBootstrap unbinding from {}:{}\", configuration.getHost(), configuration.getPort());\n\n        LOG.trace(\"Closing {} channels\", allChannels.size());\n        ChannelGroupFuture future = allChannels.close();\n        future.awaitUninterruptibly();\n\n        // close server external resources\n        if (datagramChannelFactory != null) {\n            datagramChannelFactory.releaseExternalResources();\n            datagramChannelFactory = null;\n        }\n\n        // and then shutdown the thread pools\n        if (workerPool != null) {\n            workerPool.shutdown();\n            workerPool = null;\n        }\n    }","commit_id":"4664d64c69840637b564b5f65c5ec0f026e46c10","url":"https://github.com/apache/camel"},{"original_method":"public void dump()\n    {\n        System.out.printf(\"Captured %d incoming frames%n\",frames.size());\n        for (int i = 0; i < frames.size(); i++)\n        {\n            WebSocketFrame frame = frames.get(i);\n            System.out.printf(\"[%3d] %s%n\",i,frame);\n            System.out.printf(\"          %s%n\",BufferUtil.toDetailString(frame.getPayload()));\n        }\n    }","id":81845,"modified_method":"public void dump()\n    {\n        System.err.printf(\"Captured %d incoming frames%n\",frames.size());\n        for (int i = 0; i < frames.size(); i++)\n        {\n            WebSocketFrame frame = frames.get(i);\n            System.err.printf(\"[%3d] %s%n\",i,frame);\n            System.err.printf(\"          %s%n\",BufferUtil.toDetailString(frame.getPayload()));\n        }\n    }","commit_id":"7d2d40dc2b8dc1b858152e0dc795206cd3214049","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Enqueue internal frame from {@link OutgoingFrames} stack for eventual write out on the physical connection.\n     */\n    @Override\n    public <C> void output(C context, Callback<C> callback, WebSocketFrame frame)\n    {\n        synchronized (queue)\n        {\n            if (frame.getOpCode().isControlFrame())\n            {\n                ControlFrameBytes<C> bytes = new ControlFrameBytes<C>(this,callback,context,frame);\n                scheduleTimeout(bytes);\n                queue.prepend(bytes);\n            }\n            else\n            {\n                DataFrameBytes<C> bytes = new DataFrameBytes<C>(this,callback,context,frame);\n                scheduleTimeout(bytes);\n                queue.append(bytes);\n            }\n        }\n        flush();\n    }","id":81846,"modified_method":"/**\n     * Enqueue internal frame from {@link OutgoingFrames} stack for eventual write out on the physical connection.\n     */\n    @Override\n    public <C> void output(C context, Callback<C> callback, WebSocketFrame frame)\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"output({}, {}, {})\",context,callback,frame);\n        }\n\n        synchronized (queue)\n        {\n            FrameBytes<C> bytes = null;\n\n            if (frame.getOpCode().isControlFrame())\n            {\n                bytes = new ControlFrameBytes<C>(this,callback,context,frame);\n            }\n            else\n            {\n                bytes = new DataFrameBytes<C>(this,callback,context,frame);\n            }\n\n            scheduleTimeout(bytes);\n            if (frame.getOpCode() == OpCode.PING)\n            {\n                queue.prepend(bytes);\n            }\n            else\n            {\n                queue.append(bytes);\n            }\n        }\n        flush();\n    }","commit_id":"7d2d40dc2b8dc1b858152e0dc795206cd3214049","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private int read(ByteBuffer buffer)\n    {\n        AsyncEndPoint endPoint = getEndPoint();\n        try\n        {\n            while (true)\n            {\n                int filled = endPoint.fill(buffer);\n                if (filled == 0)\n                {\n                    return 0;\n                }\n                else if (filled < 0)\n                {\n                    disconnect(false);\n                    return -1;\n                }\n                else\n                {\n                    if (LOG.isDebugEnabled())\n                    {\n                        LOG.debug(\"Filled {} bytes - {}\",filled,BufferUtil.toDetailString(buffer));\n                    }\n                    parser.parse(buffer);\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            LOG.warn(e);\n            terminateConnection(StatusCode.PROTOCOL,e.getMessage());\n            return -1;\n        }\n        catch (CloseException e)\n        {\n            LOG.warn(e);\n            terminateConnection(e.getStatusCode(),e.getMessage());\n            return -1;\n        }\n    }","id":81847,"modified_method":"private int read(ByteBuffer buffer)\n    {\n        AsyncEndPoint endPoint = getEndPoint();\n        try\n        {\n            while (true)\n            {\n                int filled = endPoint.fill(buffer);\n                if (filled == 0)\n                {\n                    return 0;\n                }\n                else if (filled < 0)\n                {\n                    LOG.debug(\"read - EOF Reached\");\n                    disconnect(false);\n                    return -1;\n                }\n                else\n                {\n                    if (LOG.isDebugEnabled())\n                    {\n                        LOG.debug(\"Filled {} bytes - {}\",filled,BufferUtil.toDetailString(buffer));\n                    }\n                    parser.parse(buffer);\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            LOG.warn(e);\n            terminateConnection(StatusCode.PROTOCOL,e.getMessage());\n            return -1;\n        }\n        catch (CloseException e)\n        {\n            LOG.warn(e);\n            terminateConnection(e.getStatusCode(),e.getMessage());\n            return -1;\n        }\n    }","commit_id":"7d2d40dc2b8dc1b858152e0dc795206cd3214049","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private final JCExpression transformInvocationPrimary(JCExpression primaryExpr,\n            String selector) {\n        JCExpression actualPrimExpr;\n        if (primary instanceof Tree.QualifiedTypeExpression\n                && ((Tree.QualifiedTypeExpression)primary).getPrimary() instanceof Tree.BaseTypeExpression) {\n            actualPrimExpr = gen().makeSelect(primaryExpr, \"this\");\n        } else {\n            actualPrimExpr = primaryExpr;\n        }\n        if (callVarName != null) {\n            // Prepare the first argument holding the primary for the call\n            JCExpression callVarExpr = gen().makeUnquotedIdent(callVarName);\n            JCVariableDecl callVar;\n            ProducedType type = ((Tree.MemberOrTypeExpression)primary).getTarget().getQualifyingType();\n            if (primaryExpr != null) {\n                callVar = gen().makeVar(callVarName, gen().makeJavaType(type, AbstractTransformer.NO_PRIMITIVES), actualPrimExpr);\n            } else {\n                callVar = gen().makeVar(callVarName, gen().makeJavaType(type, AbstractTransformer.NO_PRIMITIVES), gen().makeUnquotedIdent(\"this\"));\n            }\n            vars.prepend(callVar);\n            actualPrimExpr = callVarExpr;\n        }\n        return actualPrimExpr;\n    }","id":81848,"modified_method":"private final JCExpression transformInvocationPrimary(JCExpression primaryExpr,\n            String selector) {\n        JCExpression actualPrimExpr;\n        if (primary instanceof Tree.QualifiedTypeExpression\n                && ((Tree.QualifiedTypeExpression)primary).getPrimary() instanceof Tree.BaseTypeExpression) {\n            actualPrimExpr = gen().makeSelect(primaryExpr, \"this\");\n        } else {\n            actualPrimExpr = primaryExpr;\n        }\n        if (callVarName != null) {\n            // Prepare the first argument holding the primary for the call\n            JCExpression callVarExpr = gen().makeUnquotedIdent(callVarName);\n            JCVariableDecl callVar = null;\n            ProducedType type = ((Tree.MemberOrTypeExpression)primary).getTarget().getQualifyingType();\n            if (vars != null \n                    && !vars.isEmpty() \n                    && primaryExpr != null\n                    && selector != null) {\n                callVar = gen().makeVar(callVarName, gen().makeJavaType(type, AbstractTransformer.NO_PRIMITIVES), actualPrimExpr);\n            }/*else if () {\n                callVar = gen().makeVar(callVarName, gen().makeJavaType(type, AbstractTransformer.NO_PRIMITIVES), gen().makeUnquotedIdent(\"this\"));\n            }*/\n            if (callVar != null) {\n                vars.prepend(callVar);\n                actualPrimExpr = callVarExpr;\n            }\n        }\n        return actualPrimExpr;\n    }","commit_id":"12e538f8d6d4b8855fcdb11124dfe23a80fa278d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    protected void compute() {\n        java.util.List<ProducedType> typeArgumentModels = getTypeArguments();\n        boolean isRaw = transformedTypArguments.isEmpty();\n        \n        if (getPrimaryDeclaration() != null) {\n            java.util.List<ParameterList> paramLists = ((Functional)getPrimaryDeclaration()).getParameterLists();\n            java.util.List<Tree.NamedArgument> namedArguments = namedArgumentList.getNamedArguments();\n            java.util.List<Parameter> declaredParams = paramLists.get(0).getParameters();\n            Parameter lastDeclared = declaredParams.size() > 0 ? declaredParams.get(declaredParams.size() - 1) : null;\n            boolean boundSequenced = false;\n            String varBaseName = gen().aliasName(\"arg\");\n            callVarName = varBaseName + \"$callable$\";\n            \n            int numDeclared = declaredParams.size();\n            int numDeclaredFixed = (lastDeclared != null && lastDeclared.isSequenced()) ? numDeclared - 1 : numDeclared;\n            int numPassed = namedArguments.size();\n            int idx = 0;\n            for (Tree.NamedArgument namedArg : namedArguments) {\n                gen().at(namedArg);\n                Tree.Expression expr = ((Tree.SpecifiedArgument)namedArg).getSpecifierExpression().getExpression();\n                Parameter declaredParam = namedArg.getParameter();\n                int index;\n                BoxingStrategy boxType;\n                ProducedType type;\n                if (declaredParam != null) {\n                    if (declaredParam.isSequenced()) {\n                        boundSequenced = true;\n                    }\n                    index = declaredParams.indexOf(declaredParam);\n                    boxType = Util.getBoxingStrategy(declaredParam);\n                    type = gen().getTypeForParameter(declaredParam, isRaw, typeArgumentModels);\n                } else {\n                    // Arguments of overloaded methods don't have a reference to parameter\n                    index = idx++;\n                    boxType = BoxingStrategy.UNBOXED;\n                    type = expr.getTypeModel();\n                }\n                String varName = varBaseName + \"$\" + index;\n                // if we can't pick up on the type from the declaration, revert to the type of the expression\n                if(gen().isTypeParameter(gen().simplifyType(type)))\n                    type = expr.getTypeModel();\n                \n                JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                JCExpression argExpr = gen().expressionGen().transformExpression(expr, boxType, type);\n                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                vars.append(varDecl);\n            }\n            \n            if (!Decl.isOverloaded(getPrimaryDeclaration()) && numPassed < numDeclaredFixed) {\n                final boolean needsThis = appendThis(varBaseName);\n                // append any arguments for defaulted parameters\n                for (int ii = 0; ii < numDeclaredFixed; ii++) {\n                    Parameter param = declaredParams.get(ii);\n                    if (containsParameter(namedArguments, param)) {\n                        continue;\n                    }\n                    String varName = varBaseName + \"$\" + ii;\n                    String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), param);\n                    List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, ii, needsThis);\n                    JCExpression argExpr;\n                    if (!param.isSequenced()\n                            || hasDefaultArgument(ii)) {\n                        Declaration container = param.getDeclaration().getRefinedDeclaration();\n                        if (!container.isToplevel()) {\n                            container = (Declaration)container.getContainer();\n                        }\n                        String className = Util.getCompanionClassName(container.getName());\n                        argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                    } else {\n                        argExpr = gen().makeEmpty();\n                    }\n                    BoxingStrategy boxType = Util.getBoxingStrategy(param);\n                    ProducedType type = gen().getTypeForParameter(param, isRaw, typeArgumentModels);\n                    JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                    JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                    vars.append(varDecl);\n                }\n            }\n            \n            Tree.SequencedArgument sequencedArgument = namedArgumentList.getSequencedArgument();\n            if (sequencedArgument != null) {\n                gen().at(sequencedArgument);\n                String varName = varBaseName + \"$\" + numDeclaredFixed;\n                JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                JCExpression argExpr = gen().makeSequenceRaw(sequencedArgument.getExpressionList().getExpressions());\n                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                vars.append(varDecl);\n            } else if (lastDeclared != null \n                    && lastDeclared.isSequenced() \n                    && !boundSequenced) {\n                String varName = varBaseName + \"$\" + numDeclaredFixed;\n                JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, gen().makeEmpty());\n                vars.append(varDecl);\n            }\n            \n            if (!Decl.isOverloaded(getPrimaryDeclaration())) {\n                args.appendList(makeVarRefArgumentList(varBaseName, numDeclared));\n            } else {\n                // For overloaded methods (and therefore Java interop) we just pass the arguments we have\n                args.appendList(makeVarRefArgumentList(varBaseName, numPassed));\n            }\n        }\n    }","id":81849,"modified_method":"@Override\n    protected void compute() {\n        java.util.List<ProducedType> typeArgumentModels = getTypeArguments();\n        boolean isRaw = transformedTypArguments.isEmpty();\n        \n        if (getPrimaryDeclaration() != null) {\n            java.util.List<ParameterList> paramLists = ((Functional)getPrimaryDeclaration()).getParameterLists();\n            java.util.List<Tree.NamedArgument> namedArguments = namedArgumentList.getNamedArguments();\n            java.util.List<Parameter> declaredParams = paramLists.get(0).getParameters();\n            Parameter lastDeclared = declaredParams.size() > 0 ? declaredParams.get(declaredParams.size() - 1) : null;\n            boolean boundSequenced = false;\n            String varBaseName = gen().aliasName(\"arg\");\n            callVarName = varBaseName + \"$callable$\";\n            \n            int numDeclared = declaredParams.size();\n            int numDeclaredFixed = (lastDeclared != null && lastDeclared.isSequenced()) ? numDeclared - 1 : numDeclared;\n            int numPassed = namedArguments.size();\n            int idx = 0;\n            // Assign vars for each named argument given\n            for (Tree.NamedArgument namedArg : namedArguments) {\n                gen().at(namedArg);\n                Tree.Expression expr = ((Tree.SpecifiedArgument)namedArg).getSpecifierExpression().getExpression();\n                Parameter declaredParam = namedArg.getParameter();\n                int index;\n                BoxingStrategy boxType;\n                ProducedType type;\n                if (declaredParam != null) {\n                    if (declaredParam.isSequenced()) {\n                        boundSequenced = true;\n                    }\n                    index = declaredParams.indexOf(declaredParam);\n                    boxType = Util.getBoxingStrategy(declaredParam);\n                    type = gen().getTypeForParameter(declaredParam, isRaw, typeArgumentModels);\n                } else {\n                    // Arguments of overloaded methods don't have a reference to parameter\n                    index = idx++;\n                    boxType = BoxingStrategy.UNBOXED;\n                    type = expr.getTypeModel();\n                }\n                String varName = varBaseName + \"$\" + index;\n                // if we can't pick up on the type from the declaration, revert to the type of the expression\n                if(gen().isTypeParameter(gen().simplifyType(type)))\n                    type = expr.getTypeModel();\n                \n                JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                JCExpression argExpr = gen().expressionGen().transformExpression(expr, boxType, type);\n                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                vars.append(varDecl);\n            }\n            \n            final boolean needsThis = Decl.withinClassOrInterface(getPrimaryDeclaration());\n            boolean hadThis = false;\n            \n            if (!Decl.isOverloaded(getPrimaryDeclaration()) && numPassed < numDeclaredFixed) {\n                if (needsThis && !hadThis) {\n                    appendThis(varBaseName);\n                    hadThis = true;\n                }\n                // append any arguments for defaulted parameters\n                for (int ii = 0; ii < numDeclaredFixed; ii++) {\n                    Parameter param = declaredParams.get(ii);\n                    if (containsParameter(namedArguments, param)) {\n                        continue;\n                    }\n                    String varName = varBaseName + \"$\" + ii;\n                    String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), param);\n                    List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, ii, needsThis);\n                    JCExpression argExpr;\n                    if (!param.isSequenced()\n                            || hasDefaultArgument(ii)) {\n                        Declaration container = param.getDeclaration().getRefinedDeclaration();\n                        if (!container.isToplevel()) {\n                            container = (Declaration)container.getContainer();\n                        }\n                        String className = Util.getCompanionClassName(container.getName());\n                        argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                    } else {\n                        argExpr = gen().makeEmpty();\n                    }\n                    BoxingStrategy boxType = Util.getBoxingStrategy(param);\n                    ProducedType type = gen().getTypeForParameter(param, isRaw, typeArgumentModels);\n                    JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                    JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                    vars.append(varDecl);\n                }\n            }\n            \n            JCExpression argExpr = null;\n            Tree.SequencedArgument sequencedArgument = namedArgumentList.getSequencedArgument();\n            if (sequencedArgument != null) {\n                gen().at(sequencedArgument);\n                argExpr = gen().makeSequenceRaw(sequencedArgument.getExpressionList().getExpressions());   \n            } else if (lastDeclared != null \n                    && lastDeclared.isSequenced() \n                    && !boundSequenced) {\n                if (parameters.get(parameters.size()-1).isDefaulted()) {\n                    if (needsThis && !hadThis) {\n                        appendThis(varBaseName);\n                        hadThis = true;\n                    }\n                    Parameter sequencedParameter = parameters.get(parameters.size()-1);\n                    String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), sequencedParameter);\n                    List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, numDeclaredFixed, needsThis);\n                    Declaration container = sequencedParameter.getDeclaration().getRefinedDeclaration();\n                    if (!container.isToplevel()) {\n                        container = (Declaration)container.getContainer();\n                    }\n                    String className = Util.getCompanionClassName(container.getName());\n                    argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                } else {\n                    argExpr = gen().makeEmpty();\n                }\n            }\n            if (argExpr != null) {\n                String varName = varBaseName + \"$\" + numDeclaredFixed;\n                JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                vars.append(varDecl);\n            }\n            \n            if (!Decl.isOverloaded(getPrimaryDeclaration())) {\n                args.appendList(makeVarRefArgumentList(varBaseName, numDeclared));\n            } else {\n                // For overloaded methods (and therefore Java interop) we just pass the arguments we have\n                args.appendList(makeVarRefArgumentList(varBaseName, numPassed));\n            }\n        }\n    }","commit_id":"12e538f8d6d4b8855fcdb11124dfe23a80fa278d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected final boolean appendThis(String varBaseName) {\n        final boolean needsThis = Decl.withinClassOrInterface(getPrimaryDeclaration());\n        if (needsThis) {\n            // first append $this\n            ProducedType thisType = gen().getThisType(getPrimaryDeclaration());\n            vars.append(gen().makeVar(varBaseName + \"$this$\", \n                    gen().makeJavaType(thisType, AbstractTransformer.NO_PRIMITIVES), \n                    gen().makeUnquotedIdent(callVarName)));\n        }\n        return needsThis;\n    }","id":81850,"modified_method":"protected final void appendThis(String varBaseName) {\n        // first append $this\n        String name;\n        if (primary instanceof Tree.BaseMemberOrTypeExpression) {\n            name = \"this\";\n        } else {\n            name = callVarName;\n        }\n        ProducedType thisType = gen().getThisType(getPrimaryDeclaration());\n        vars.append(gen().makeVar(varBaseName + \"$this$\", \n                gen().makeJavaType(thisType, AbstractTransformer.NO_PRIMITIVES), \n                gen().makeUnquotedIdent(name)));\n    }","commit_id":"12e538f8d6d4b8855fcdb11124dfe23a80fa278d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void computeWithDefaultedParameters(final boolean isRaw,\n            int numParameters, int numArguments) {\n        String varBaseName = gen().aliasName(\"arg\");\n        callVarName = varBaseName + \"$callable$\";\n        boolean needsThis = appendThis(varBaseName);\n        // append the normal args\n        int idx = 0;\n        for (int ii = 0; ii < this.getNumArguments(); ii++) {\n            gen().at(this.getArgumentExpression(ii));\n            Tree.Expression expr = this.getArgumentExpression(ii);\n            Parameter declaredParam = this.getParameter(ii);\n            int index;\n            BoxingStrategy boxType;\n            ProducedType type;\n            if (declaredParam != null) {\n                index = getDeclaredParameters().indexOf(declaredParam);\n                boxType = Util.getBoxingStrategy(declaredParam);\n                type = gen().getTypeForParameter(declaredParam, isRaw, getTypeArguments());\n            } else {\n                // Arguments of overloaded methods don't have a reference to parameter\n                index = idx++;\n                boxType = BoxingStrategy.UNBOXED;\n                type = expr.getTypeModel();\n            }\n            String varName = varBaseName + \"$\" + index;\n            // if we can't pick up on the type from the declaration, revert to the type of the expression\n            if(gen().isTypeParameter(type))\n                type = expr.getTypeModel();\n            JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n            JCExpression argExpr = gen().expressionGen().transformExpression(expr, boxType, type);\n            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n            vars.append(varDecl);\n        }\n        if (!Decl.isOverloaded(getPrimaryDeclaration())) {\n            // append any arguments for defaulted parameters\n            for (int ii = numArguments; ii < numParameters; ii++) {\n                Parameter param = getDeclaredParameters().get(ii);\n                String varName = varBaseName + \"$\" + ii;\n                String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), param);\n                List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, ii, needsThis);\n                JCExpression argExpr;\n                if (!param.isSequenced()\n                        || hasDefaultArgument(ii)) {\n                    Declaration container = param.getDeclaration().getRefinedDeclaration();\n                    if (!container.isToplevel()) {\n                        container = (Declaration)container.getContainer();\n                    }\n                    String className = Util.getCompanionClassName(container.getName());\n                    argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                } else {\n                    argExpr = gen().makeEmpty();\n                }\n                BoxingStrategy boxType = Util.getBoxingStrategy(param);\n                ProducedType type = gen().getTypeForParameter(param, isRaw, getTypeArguments());\n                JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                vars.append(varDecl);\n            }\n            args.appendList(makeVarRefArgumentList(varBaseName, numParameters));\n        } else {\n            // For overloaded methods (and therefore Java interop) we just pass the arguments we have\n            args.appendList(makeVarRefArgumentList(varBaseName, numArguments));\n        }\n    }","id":81851,"modified_method":"private void computeWithDefaultedParameters(final boolean isRaw,\n            int numParameters, int numArguments) {\n        String varBaseName = gen().aliasName(\"arg\");\n        callVarName = varBaseName + \"$callable$\";\n        final boolean needsThis = Decl.withinClassOrInterface(getPrimaryDeclaration());\n        if (needsThis) { \n            appendThis(varBaseName);\n        }\n        // append the normal args\n        int idx = 0;\n        for (int ii = 0; ii < this.getNumArguments(); ii++) {\n            gen().at(this.getArgumentExpression(ii));\n            Tree.Expression expr = this.getArgumentExpression(ii);\n            Parameter declaredParam = this.getParameter(ii);\n            int index;\n            BoxingStrategy boxType;\n            ProducedType type;\n            if (declaredParam != null) {\n                index = getDeclaredParameters().indexOf(declaredParam);\n                boxType = Util.getBoxingStrategy(declaredParam);\n                type = gen().getTypeForParameter(declaredParam, isRaw, getTypeArguments());\n            } else {\n                // Arguments of overloaded methods don't have a reference to parameter\n                index = idx++;\n                boxType = BoxingStrategy.UNBOXED;\n                type = expr.getTypeModel();\n            }\n            String varName = varBaseName + \"$\" + index;\n            // if we can't pick up on the type from the declaration, revert to the type of the expression\n            if(gen().isTypeParameter(type))\n                type = expr.getTypeModel();\n            JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n            JCExpression argExpr = gen().expressionGen().transformExpression(expr, boxType, type);\n            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n            vars.append(varDecl);\n        }\n        if (!Decl.isOverloaded(getPrimaryDeclaration())) {\n            // append any arguments for defaulted parameters\n            for (int ii = numArguments; ii < numParameters; ii++) {\n                Parameter param = getDeclaredParameters().get(ii);\n                String varName = varBaseName + \"$\" + ii;\n                String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), param);\n                List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, ii, needsThis);\n                JCExpression argExpr = null;\n                if (param.isDefaulted()) {\n                    Declaration container = param.getDeclaration().getRefinedDeclaration();\n                    if (!container.isToplevel()) {\n                        container = (Declaration)container.getContainer();\n                    }\n                    String className = Util.getCompanionClassName(container.getName());\n                    argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                } else if (param.isSequenced()) {\n                    argExpr = gen().makeEmpty();\n                }\n                if (argExpr != null) {\n                    BoxingStrategy boxType = Util.getBoxingStrategy(param);\n                    ProducedType type = gen().getTypeForParameter(param, isRaw, getTypeArguments());\n                    JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                    JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                    vars.append(varDecl);\n                }\n            }\n            args.appendList(makeVarRefArgumentList(varBaseName, numParameters));\n        } else {\n            // For overloaded methods (and therefore Java interop) we just pass the arguments we have\n            args.appendList(makeVarRefArgumentList(varBaseName, numArguments));\n        }\n    }","commit_id":"12e538f8d6d4b8855fcdb11124dfe23a80fa278d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    protected final void compute() {\n        \n        final boolean isRaw = transformedTypArguments.isEmpty();\n        int numParameters = getDeclaredParameters().size();\n        int numArguments = this.getNumArguments();\n        Parameter lastDeclaredParam = getDeclaredParameters().isEmpty() ? null : getDeclaredParameters().get(getDeclaredParameters().size() - 1); \n        if (lastDeclaredParam != null \n                && lastDeclaredParam.isSequenced()\n                && !this.dontBoxSequence() // foo(sequence...) syntax => no need to box\n                && numArguments >= (numParameters -1)) {\n            computeWithSequencedParameter(isRaw, numParameters, numArguments);\n        } else if (numArguments < numParameters) {\n            computeWithDefaultedParameters(isRaw, numParameters, numArguments);\n        } else {\n            computeSimple(isRaw);\n        }\n    }","id":81852,"modified_method":"@Override\n    protected final void compute() {\n        \n        final boolean isRaw = transformedTypArguments.isEmpty();\n        int numParameters = getDeclaredParameters().size();\n        int numArguments = this.getNumArguments();\n        boolean hasDefaulted = false;\n        for (Parameter param : getDeclaredParameters().subList(Math.min(numArguments, numParameters), numParameters)) {\n            if (param.isDefaulted()) {\n                hasDefaulted = true;\n                break;\n            }\n        }\n        \n        Parameter lastDeclaredParam = getDeclaredParameters().isEmpty() ? null : getDeclaredParameters().get(getDeclaredParameters().size() - 1);\n        if (hasDefaulted) {\n            computeWithDefaultedParameters(isRaw, numParameters, numArguments);\n        } else if (lastDeclaredParam != null \n                && lastDeclaredParam.isSequenced()\n                && !this.dontBoxSequence() // foo(sequence...) syntax => no need to box\n                && numArguments >= (numParameters -1)) {\n            computeWithSequencedParameter(isRaw, numParameters, numArguments);\n        } else {\n            computeSimple(isRaw);\n        }\n    }","commit_id":"12e538f8d6d4b8855fcdb11124dfe23a80fa278d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public Double evaluateDatumInOneDimension( final VariantDatum datum, final int iii ) {\n        if(datum.isNull[iii]) { return null; }\n\n        final Normal normal = new Normal(0.0, 1.0, null);\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            normal.setState( gaussian.mu[iii], gaussian.sigma.get(iii, iii) );\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + Math.log10( normal.pdf( datum.annotations[iii] ) );\n        }\n        double lod = MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n\n        // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n        // Cap the values at an extremely negative value and spread them out randomly\n        if( lod < MIN_ACCEPTABLE_LOD_SCORE ) {\n            lod = MIN_ACCEPTABLE_LOD_SCORE - GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE;\n        }\n        return lod;\n    }","id":81853,"modified_method":"public Double evaluateDatumInOneDimension( final VariantDatum datum, final int iii ) {\n        if(datum.isNull[iii]) { return null; }\n\n        final Normal normal = new Normal(0.0, 1.0, null);\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            normal.setState( gaussian.mu[iii], gaussian.sigma.get(iii, iii) );\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + Math.log10( normal.pdf( datum.annotations[iii] ) );\n        }\n        return MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n    }","commit_id":"b0086768784789e0550bc58b0253d09cb2968d4a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public double evaluateDatum( final VariantDatum datum ) {\n        for( final boolean isNull : datum.isNull ) {\n            if( isNull ) { return evaluateDatumMarginalized( datum ); }\n        }\n        // Fill an array with the log10 probability coming from each Gaussian and then use MathUtils to sum them up correctly\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n        }\n        double lod = MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n\n        // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n        // Cap the values at an extremely negative value and spread them out randomly\n        if( lod < MIN_ACCEPTABLE_LOD_SCORE ) {\n            lod = MIN_ACCEPTABLE_LOD_SCORE - GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE;\n        }\n        return lod;\n    }","id":81854,"modified_method":"public double evaluateDatum( final VariantDatum datum ) {\n        for( final boolean isNull : datum.isNull ) {\n            if( isNull ) { return evaluateDatumMarginalized( datum ); }\n        }\n        // Fill an array with the log10 probability coming from each Gaussian and then use MathUtils to sum them up correctly\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n        }\n        return MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n    }","commit_id":"b0086768784789e0550bc58b0253d09cb2968d4a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public double evaluateDatumMarginalized( final VariantDatum datum ) {\n        int numRandomDraws = 0;\n        double sumPVarInGaussian = 0.0;\n        final int numIterPerMissingAnnotation = 10; // Trade off here between speed of computation and accuracy of the marginalization\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        // for each dimension\n        for( int iii = 0; iii < datum.annotations.length; iii++ ) {\n            // if it is missing marginalize over the missing dimension by drawing X random values for the missing annotation and averaging the lod\n            if( datum.isNull[iii] ) {\n                for( int ttt = 0; ttt < numIterPerMissingAnnotation; ttt++ ) {\n                    datum.annotations[iii] = GenomeAnalysisEngine.getRandomGenerator().nextGaussian(); // draw a random sample from the standard normal distribution\n\n                    // evaluate this random data point\n                    int gaussianIndex = 0;\n                    for( final MultivariateGaussian gaussian : gaussians ) {\n                        pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n                    }\n\n                    // add this sample's probability to the pile in order to take an average in the end\n                    sumPVarInGaussian += Math.pow(10.0, MathUtils.log10sumLog10(pVarInGaussianLog10)); // p = 10 ^ Sum(pi_k * p(v|n,k))\n                    numRandomDraws++;\n                }\n            }\n        }\n        double lod = Math.log10( sumPVarInGaussian / ((double) numRandomDraws) );\n\n        // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n        // Cap the values at an extremely negative value and spread them out randomly\n        if( lod < MIN_ACCEPTABLE_LOD_SCORE ) {\n            lod = MIN_ACCEPTABLE_LOD_SCORE - GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE;\n        }\n        return lod;\n    }","id":81855,"modified_method":"public double evaluateDatumMarginalized( final VariantDatum datum ) {\n        int numRandomDraws = 0;\n        double sumPVarInGaussian = 0.0;\n        final int numIterPerMissingAnnotation = 10; // Trade off here between speed of computation and accuracy of the marginalization\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        // for each dimension\n        for( int iii = 0; iii < datum.annotations.length; iii++ ) {\n            // if it is missing marginalize over the missing dimension by drawing X random values for the missing annotation and averaging the lod\n            if( datum.isNull[iii] ) {\n                for( int ttt = 0; ttt < numIterPerMissingAnnotation; ttt++ ) {\n                    datum.annotations[iii] = GenomeAnalysisEngine.getRandomGenerator().nextGaussian(); // draw a random sample from the standard normal distribution\n\n                    // evaluate this random data point\n                    int gaussianIndex = 0;\n                    for( final MultivariateGaussian gaussian : gaussians ) {\n                        pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n                    }\n\n                    // add this sample's probability to the pile in order to take an average in the end\n                    sumPVarInGaussian += Math.pow(10.0, MathUtils.log10sumLog10(pVarInGaussianLog10)); // p = 10 ^ Sum(pi_k * p(v|n,k))\n                    numRandomDraws++;\n                }\n            }\n        }\n        return Math.log10( sumPVarInGaussian / ((double) numRandomDraws) );\n    }","commit_id":"b0086768784789e0550bc58b0253d09cb2968d4a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void evaluateData( final List<VariantDatum> data, final GaussianMixtureModel model, final boolean evaluateContrastively ) {\n        if( !model.isModelReadyForEvaluation ) {\n            model.precomputeDenominatorForEvaluation();\n        }\n        \n        logger.info(\"Evaluating full set of \" + data.size() + \" variants...\");\n        for( final VariantDatum datum : data ) {\n            final double thisLod = evaluateDatum( datum, model );\n            if( Double.isNaN(thisLod) ) {\n                if( evaluateContrastively ) {\n                    throw new UserException(\"NaN LOD value assigned. Clustering with this few variants and these annotations is unsafe. Please consider raising the number of variants used to train the negative model (via --percentBadVariants 0.05, for example) or lowering the maximum number of Gaussians to use in the model (via --maxGaussians 4, for example)\");\n                } else {\n                    throw new UserException(\"NaN LOD value assigned. Clustering with this few variants and these annotations is unsafe.\");\n                }\n            }\n            datum.lod = ( evaluateContrastively ? (datum.prior + datum.lod - thisLod) : thisLod );\n        }\n    }","id":81856,"modified_method":"public void evaluateData( final List<VariantDatum> data, final GaussianMixtureModel model, final boolean evaluateContrastively ) {\n        if( !model.isModelReadyForEvaluation ) {\n            model.precomputeDenominatorForEvaluation();\n        }\n        \n        logger.info(\"Evaluating full set of \" + data.size() + \" variants...\");\n        for( final VariantDatum datum : data ) {\n            final double thisLod = evaluateDatum( datum, model );\n            if( Double.isNaN(thisLod) ) {\n                if( evaluateContrastively ) {\n                    throw new UserException(\"NaN LOD value assigned. Clustering with this few variants and these annotations is unsafe. Please consider raising the number of variants used to train the negative model (via --percentBadVariants 0.05, for example) or lowering the maximum number of Gaussians to use in the model (via --maxGaussians 4, for example)\");\n                } else {\n                    throw new UserException(\"NaN LOD value assigned. Clustering with this few variants and these annotations is unsafe.\");\n                }\n            }\n\n            datum.lod = ( evaluateContrastively ?\n                            ( Double.isInfinite(datum.lod) ? // positive model said negative infinity\n                                    ( MIN_ACCEPTABLE_LOD_SCORE + GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE ) // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n                                    : datum.prior + datum.lod - thisLod) // contrastive evaluation: (prior + positive model - negative model)\n                            : thisLod ); // positive model only so set the lod and return\n        }\n    }","commit_id":"b0086768784789e0550bc58b0253d09cb2968d4a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public double evaluateDatumMarginalized( final VariantDatum datum ) {\n        int numSamples = 0;\n        double sumPVarInGaussian = 0.0;\n        final int numIterPerMissingAnnotation = 10; // Trade off here between speed of computation and accuracy of the marginalization\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        // for each dimension\n        for( int iii = 0; iii < datum.annotations.length; iii++ ) {\n            // if it is missing marginalize over the missing dimension by drawing X random values for the missing annotation and averaging the lod\n            if( datum.isNull[iii] ) {\n                for( int ttt = 0; ttt < numIterPerMissingAnnotation; ttt++ ) {\n                    datum.annotations[iii] = GenomeAnalysisEngine.getRandomGenerator().nextGaussian(); // draw a random sample from the standard normal distribution\n\n                    // evaluate this random data point\n                    int gaussianIndex = 0;\n                    for( final MultivariateGaussian gaussian : gaussians ) {\n                        pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n                    }\n\n                    // add this sample's probability to the pile in order to take an average in the end\n                    sumPVarInGaussian += Math.pow(10.0, MathUtils.log10sumLog10(pVarInGaussianLog10)); // p = 10 ^ Sum(pi_k * p(v|n,k))\n                    numSamples++;\n                }\n            }\n        }\n        return Math.log10( sumPVarInGaussian / ((double) numSamples) );\n    }","id":81857,"modified_method":"public double evaluateDatumMarginalized( final VariantDatum datum ) {\n        int numRandomDraws = 0;\n        double sumPVarInGaussian = 0.0;\n        final int numIterPerMissingAnnotation = 10; // Trade off here between speed of computation and accuracy of the marginalization\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        // for each dimension\n        for( int iii = 0; iii < datum.annotations.length; iii++ ) {\n            // if it is missing marginalize over the missing dimension by drawing X random values for the missing annotation and averaging the lod\n            if( datum.isNull[iii] ) {\n                for( int ttt = 0; ttt < numIterPerMissingAnnotation; ttt++ ) {\n                    datum.annotations[iii] = GenomeAnalysisEngine.getRandomGenerator().nextGaussian(); // draw a random sample from the standard normal distribution\n\n                    // evaluate this random data point\n                    int gaussianIndex = 0;\n                    for( final MultivariateGaussian gaussian : gaussians ) {\n                        pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n                    }\n\n                    // add this sample's probability to the pile in order to take an average in the end\n                    sumPVarInGaussian += Math.pow(10.0, MathUtils.log10sumLog10(pVarInGaussianLog10)); // p = 10 ^ Sum(pi_k * p(v|n,k))\n                    numRandomDraws++;\n                }\n            }\n        }\n        double lod = Math.log10( sumPVarInGaussian / ((double) numRandomDraws) );\n\n        // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n        // Cap the values at an extremely negative value and spread them out randomly\n        if( lod < MIN_ACCEPTABLE_LOD_SCORE ) {\n            lod = MIN_ACCEPTABLE_LOD_SCORE - GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE;\n        }\n        return lod;\n    }","commit_id":"539e157ecddee3a5d6a5729e3eb0d55b97404ece","url":"https://github.com/broadgsa/gatk"},{"original_method":"public double evaluateDatum( final VariantDatum datum ) {\n        for( final boolean isNull : datum.isNull ) {\n            if( isNull ) { return evaluateDatumMarginalized( datum ); }\n        }\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n        }\n        return MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n    }","id":81858,"modified_method":"public double evaluateDatum( final VariantDatum datum ) {\n        for( final boolean isNull : datum.isNull ) {\n            if( isNull ) { return evaluateDatumMarginalized( datum ); }\n        }\n        // Fill an array with the log10 probability coming from each Gaussian and then use MathUtils to sum them up correctly\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + gaussian.evaluateDatumLog10( datum );\n        }\n        double lod = MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n\n        // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n        // Cap the values at an extremely negative value and spread them out randomly\n        if( lod < MIN_ACCEPTABLE_LOD_SCORE ) {\n            lod = MIN_ACCEPTABLE_LOD_SCORE - GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE;\n        }\n        return lod;\n    }","commit_id":"539e157ecddee3a5d6a5729e3eb0d55b97404ece","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Double evaluateDatumInOneDimension( final VariantDatum datum, final int iii ) {\n        if(datum.isNull[iii]) { return null; }\n\n        final Normal normal = new Normal(0.0, 1.0, null);\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            normal.setState( gaussian.mu[iii], gaussian.sigma.get(iii, iii) );\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + Math.log10( normal.pdf( datum.annotations[iii] ) );\n        }\n        return MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n    }","id":81859,"modified_method":"public Double evaluateDatumInOneDimension( final VariantDatum datum, final int iii ) {\n        if(datum.isNull[iii]) { return null; }\n\n        final Normal normal = new Normal(0.0, 1.0, null);\n        final double[] pVarInGaussianLog10 = new double[gaussians.size()];\n        int gaussianIndex = 0;\n        for( final MultivariateGaussian gaussian : gaussians ) {\n            normal.setState( gaussian.mu[iii], gaussian.sigma.get(iii, iii) );\n            pVarInGaussianLog10[gaussianIndex++] = gaussian.pMixtureLog10 + Math.log10( normal.pdf( datum.annotations[iii] ) );\n        }\n        double lod = MathUtils.log10sumLog10(pVarInGaussianLog10); // Sum(pi_k * p(v|n,k))\n\n        // Negative infinity lod values are possible when covariates are extremely far away from their tight Gaussians\n        // Cap the values at an extremely negative value and spread them out randomly\n        if( lod < MIN_ACCEPTABLE_LOD_SCORE ) {\n            lod = MIN_ACCEPTABLE_LOD_SCORE - GenomeAnalysisEngine.getRandomGenerator().nextDouble() * MIN_ACCEPTABLE_LOD_SCORE;\n        }\n        return lod;\n    }","commit_id":"539e157ecddee3a5d6a5729e3eb0d55b97404ece","url":"https://github.com/broadgsa/gatk"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","id":81860,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        return targetBuffer;\n    }","commit_id":"def31026b045f9b2f86f604e7ddd024768321bfc","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","id":81861,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        return targetBuffer;\n    }","commit_id":"d884f0478699e056c8bf25d2d519d3725d8ae09b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","id":81862,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        if ( type.includesSlaveContext() )\n        {\n            writeTransactionStreams( response.transactions(), targetBuffer );\n        }\n        return targetBuffer;\n    }","commit_id":"c964dea3d13a4177b4b00b3dd4bf3aa02f31b1fc","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testSessionAttributes() throws Exception\n    {\n        setupContext(\"test1\", \"/\");\n        setupContext(\"test2\", \"/\");\n\n        setupLatches(2);\n\n        setupServlet(\"lowRankServlet\", new String[] { \"/foo\" }, 1, \"test1\");\n        setupServlet(\"highRankServlet\", new String[] { \"/bar\" }, 2, \"test2\" );\n\n        assertTrue(initLatch.await(5, TimeUnit.SECONDS));\n\n        RequestConfig globalConfig = RequestConfig.custom()\n                .setCookieSpec(CookieSpecs.BEST_MATCH)\n                .build();\n        final CloseableHttpClient httpclient = HttpClients.custom().setDefaultRequestConfig(globalConfig)\n                .setDefaultCookieStore(new BasicCookieStore())\n                .build();\n\n        // session should not be available\n        final JSONObject obj1 = getJSONResponse(httpclient, \"/foo\");\n        assertFalse(((Boolean)obj1.get(\"session\")).booleanValue());\n\n        final JSONObject obj2 = getJSONResponse(httpclient, \"/bar\");\n        assertFalse(((Boolean)obj2.get(\"session\")).booleanValue());\n\n        // create session for one context\n        final JSONObject obj3 = getJSONResponse(httpclient, \"/foo?create=true\");\n        assertTrue(((Boolean)obj3.get(\"session\")).booleanValue());\n        assertEquals(\"test1\", obj3.get(\"value\"));\n        final JSONObject obj4 = getJSONResponse(httpclient, \"/bar\");\n        assertFalse(((Boolean)obj4.get(\"session\")).booleanValue());\n        final JSONObject obj5 = getJSONResponse(httpclient, \"/foo\");\n        assertTrue(((Boolean)obj5.get(\"session\")).booleanValue());\n        assertEquals(\"test1\", obj5.get(\"value\"));\n\n        // create session for second context\n        final JSONObject obj6 = getJSONResponse(httpclient, \"/bar?create=true\");\n        assertTrue(((Boolean)obj6.get(\"session\")).booleanValue());\n        assertEquals(\"test2\", obj6.get(\"value\"));\n        final JSONObject obj7 = getJSONResponse(httpclient, \"/foo\");\n        assertTrue(((Boolean)obj7.get(\"session\")).booleanValue());\n        assertEquals(\"test1\", obj7.get(\"value\"));\n    }","id":81863,"modified_method":"@Test\n    public void testSessionAttributes() throws Exception\n    {\n        setupContext(\"test1\", \"/\");\n        setupContext(\"test2\", \"/\");\n\n        setupLatches(2);\n\n        setupServlet(\"foo\", new String[] { \"/foo\" }, 1, \"test1\");\n        setupServlet(\"bar\", new String[] { \"/bar\" }, 2, \"test2\" );\n\n        assertTrue(initLatch.await(5, TimeUnit.SECONDS));\n\n        RequestConfig globalConfig = RequestConfig.custom()\n                .setCookieSpec(CookieSpecs.BEST_MATCH)\n                .build();\n        final CloseableHttpClient httpclient = HttpClients.custom().setDefaultRequestConfig(globalConfig)\n                .setDefaultCookieStore(new BasicCookieStore())\n                .build();\n\n        JSONObject json;\n\n        // session should not be available\n        // check for foo servlet\n        json = getJSONResponse(httpclient, \"/foo\");\n        assertFalse(((Boolean)json.get(\"session\")).booleanValue());\n\n        // check for bar servlet\n        json = getJSONResponse(httpclient, \"/bar\");\n        assertFalse(((Boolean)json.get(\"session\")).booleanValue());\n\n        // create session for  context of servlet foo\n        // check session and session attribute\n        json = getJSONResponse(httpclient, \"/foo?create=true\");\n        assertTrue(((Boolean)json.get(\"session\")).booleanValue());\n        assertEquals(\"test1\", json.get(\"value\"));\n        final String sessionId1 = (String)json.get(\"sessionId\");\n        assertNotNull(sessionId1);\n\n        // check session for servlet bar (= no session)\n        json = getJSONResponse(httpclient, \"/bar\");\n        assertFalse(((Boolean)json.get(\"session\")).booleanValue());\n        // another request to servlet foo, still the same\n        json = getJSONResponse(httpclient, \"/foo\");\n        assertTrue(((Boolean)json.get(\"session\")).booleanValue());\n        assertEquals(\"test1\", json.get(\"value\"));\n        assertEquals(sessionId1, json.get(\"sessionId\"));\n\n        // create session for second context\n        json = getJSONResponse(httpclient, \"/bar?create=true\");\n        assertTrue(((Boolean)json.get(\"session\")).booleanValue());\n        assertEquals(\"test2\", json.get(\"value\"));\n        final String sessionId2 = (String)json.get(\"sessionId\");\n        assertNotNull(sessionId2);\n        assertFalse(sessionId1.equals(sessionId2));\n\n        // and context foo is untouched\n        json = getJSONResponse(httpclient, \"/foo\");\n        assertTrue(((Boolean)json.get(\"session\")).booleanValue());\n        assertEquals(\"test1\", json.get(\"value\"));\n        assertEquals(sessionId1, json.get(\"sessionId\"));\n\n        // invalidate session for foo context\n        json = getJSONResponse(httpclient, \"/foo?destroy=true\");\n        assertFalse(((Boolean)json.get(\"session\")).booleanValue());\n        // bar should be untouched\n        json = getJSONResponse(httpclient, \"/bar\");\n        assertTrue(((Boolean)json.get(\"session\")).booleanValue());\n        assertEquals(\"test2\", json.get(\"value\"));\n        assertEquals(sessionId2, json.get(\"sessionId\"));\n    }","commit_id":"a6519ca165aceae4c8fcc3cd156edc3eee29ba6d","url":"https://github.com/apache/felix"},{"original_method":"private void setupServlet(final String name, String[] path, int rank, final String context) throws Exception\n    {\n        Dictionary<String, Object> servletProps = new Hashtable<String, Object>();\n        servletProps.put(HTTP_WHITEBOARD_SERVLET_NAME, name);\n        servletProps.put(HTTP_WHITEBOARD_SERVLET_PATTERN, path);\n        servletProps.put(SERVICE_RANKING, rank);\n        if (context != null)\n        {\n            servletProps.put(HTTP_WHITEBOARD_CONTEXT_SELECT, \"(\" + HTTP_WHITEBOARD_CONTEXT_NAME + \"=\" + context + \")\");\n        }\n\n        Servlet sessionServlet = new TestServlet(initLatch, destroyLatch)\n        {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws IOException\n            {\n                final boolean create = req.getParameter(\"create\") != null;\n                if ( create )\n                {\n                    req.getSession();\n                }\n                final HttpSession s = req.getSession(false);\n                if ( s != null )\n                {\n                    s.setAttribute(\"value\", context);\n                }\n\n                final PrintWriter pw = resp.getWriter();\n                pw.println(\"{\");\n                if ( s == null )\n                {\n                    pw.println(\" \\\"session\\\" : false\");\n                }\n                else\n                {\n                    pw.println(\" \\\"session\\\" : true,\");\n                    pw.println(\" \\\"isNew\\\" : \" + s.isNew() + \",\");\n                    pw.println(\" \\\"sessionId\\\" : \\\"\" + s.getId() + \"\\\",\");\n                    pw.println(\" \\\"value\\\" : \\\"\" + s.getAttribute(\"value\") + \"\\\"\");\n                }\n                pw.println(\"}\");\n            }\n        };\n\n        registrations.add(m_context.registerService(Servlet.class.getName(), sessionServlet, servletProps));\n    }","id":81864,"modified_method":"private void setupServlet(final String name, String[] path, int rank, final String context) throws Exception\n    {\n        Dictionary<String, Object> servletProps = new Hashtable<String, Object>();\n        servletProps.put(HTTP_WHITEBOARD_SERVLET_NAME, name);\n        servletProps.put(HTTP_WHITEBOARD_SERVLET_PATTERN, path);\n        servletProps.put(SERVICE_RANKING, rank);\n        if (context != null)\n        {\n            servletProps.put(HTTP_WHITEBOARD_CONTEXT_SELECT, \"(\" + HTTP_WHITEBOARD_CONTEXT_NAME + \"=\" + context + \")\");\n        }\n\n        Servlet sessionServlet = new TestServlet(initLatch, destroyLatch)\n        {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws IOException\n            {\n                final boolean create = req.getParameter(\"create\") != null;\n                if ( create )\n                {\n                    req.getSession();\n                }\n                final boolean destroy = req.getParameter(\"destroy\") != null;\n                if ( destroy )\n                {\n                    req.getSession().invalidate();\n                }\n                final HttpSession s = req.getSession(false);\n                if ( s != null )\n                {\n                    s.setAttribute(\"value\", context);\n                }\n\n                final PrintWriter pw = resp.getWriter();\n                pw.println(\"{\");\n                if ( s == null )\n                {\n                    pw.println(\" \\\"session\\\" : false\");\n                }\n                else\n                {\n                    pw.println(\" \\\"session\\\" : true,\");\n                    pw.println(\" \\\"sessionId\\\" : \\\"\" + s.getId() + \"\\\",\");\n                    pw.println(\" \\\"value\\\" : \\\"\" + s.getAttribute(\"value\") + \"\\\"\");\n                }\n                pw.println(\"}\");\n            }\n        };\n\n        registrations.add(m_context.registerService(Servlet.class.getName(), sessionServlet, servletProps));\n    }","commit_id":"a6519ca165aceae4c8fcc3cd156edc3eee29ba6d","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * Examine null values.\n\t * Report any that are guaranteed to be dereferenced on\n\t * non-implicit-exception paths.\n\t * \n\t * @throws CFGBuilderException \n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void examineNullValues() throws CFGBuilderException, DataflowAnalysisException {\n\t\tSet<LocationWhereValueBecomesNull> locationWhereValueBecomesNullSet =\n\t\t\tinvDataflow.getAnalysis().getLocationWhereValueBecomesNullSet();\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"----------------------- examineNullValues \" + locationWhereValueBecomesNullSet.size());\n\t\t}\n\t\t\n\t\tMap<ValueNumber, SortedSet<Location>> bugStatementLocationMap =\n\t\t\tnew HashMap<ValueNumber, SortedSet<Location>>();\n\t\t// Inspect the method for locations where a null value is guaranteed to\n\t\t// be dereferenced.  Add the dereference locations\n\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap =\n\t\t\tnew HashMap<ValueNumber, NullValueUnconditionalDeref>();\n\t\t\n       // Check every location\n\t\tfor (Iterator<Location> i = classContext.getCFG(method).locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"At location \" + location);\n\t\t\t}\n\t\t\t{\n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n\t\t\t\tif (assertionMethods.isAssertionInstruction (in, classContext.getConstantPoolGen()) ) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugStatementLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaDataflow.getFactAtLocation(location), invDataflow.getFactAtLocation(location), uvdDataflow.getFactAfterLocation(location));\n\t\t}\n\t\tHashSet<ValueNumber> npeIfStatementCovered = new HashSet<ValueNumber>(nullValueGuaranteedDerefMap.keySet());\n        Map<ValueNumber, SortedSet<Location>> bugEdgeLocationMap =\n            new HashMap<ValueNumber, SortedSet<Location>>();\n        \n\t\t// Check every non-exception control edge\n\t\tfor (Iterator<Edge> i = classContext.getCFG(method).edgeIterator(); i.hasNext();) {\n\t\t\tEdge edge = i.next();\n\t\t\t\n\t\t\tif (edge.isExceptionEdge()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"On edge \" + edge.formatAsString(false));\n\t\t\t}\n\t\t\t\n\t\t\tValueNumberFrame vnaFact = vnaDataflow.getResultFact(edge.getSource());\n\t\t\tIsNullValueFrame invFact = invDataflow.getFactOnEdge(edge);\n\t\t\tUnconditionalValueDerefSet uvdFact = uvdDataflow.getFactOnEdge(edge);\n\t\t\tLocation location = Location.getLastLocation(edge.getSource());\n\t\t\tif (location != null) {\n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n\t\t\t\tif (assertionMethods.isAssertionInstruction(in, classContext.getConstantPoolGen())) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugEdgeLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaFact, invFact, uvdFact);\n\t\t\t}\n\t\t}\n        Map<ValueNumber, SortedSet<Location>> bugLocationMap = bugEdgeLocationMap;\n        bugLocationMap.putAll(bugStatementLocationMap);\n\t\t//\tFor each value number that is null somewhere in the\n\t\t// method, collect the set of locations where it becomes null.\n\t\t// FIXME: we may see some locations that are not guaranteed to be dereferenced (how to fix this?)\n\t\tMap<ValueNumber, Set<Location>> nullValueAssignmentMap =\n\t\t\tnew HashMap<ValueNumber, Set<Location>>();\n\t\tfor (LocationWhereValueBecomesNull lwvbn : locationWhereValueBecomesNullSet) {\n\t\t\tif (DEBUG_DEREFS) System.out.println(\"OOO \" + lwvbn);\n\t\t\tSet<Location> locationSet = nullValueAssignmentMap.get(lwvbn.getValueNumber());\n\t\t\tif (locationSet == null) {\n\t\t\t\tlocationSet = new HashSet<Location>();\n\t\t\t\tnullValueAssignmentMap.put(lwvbn.getValueNumber(), locationSet);\n\t\t\t}\n\t\t\tlocationSet.add(lwvbn.getLocation());\n\t\t\tif (DEBUG_DEREFS)\n\t\t\t\tSystem.out.println(lwvbn.getValueNumber() + \" becomes null at \" + lwvbn.getLocation());\n\t\t}\n\n\t\t// Report \n\t\tfor (Map.Entry<ValueNumber, NullValueUnconditionalDeref> e  : nullValueGuaranteedDerefMap.entrySet()) {\n\t\t\tValueNumber valueNumber = e.getKey();\n\t\t\tSet<Location> derefLocationSet = e.getValue().getDerefLocationSet();\n\t\t\tSet<Location> assignedNullLocationSet = nullValueAssignmentMap.get(valueNumber);\n\t\t\tif (assignedNullLocationSet == null) {\n\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\tString where = classContext.getJavaClass().getClassName() + \".\" + method.getName() + \":\" + method.getSignature();\n\t\t\t\t\tSystem.out.println(\"Problem at \" + where);\n\t\t\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\t\t\tSystem.out.println(\"Dereference at \" + loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO: figure out why this is failing\n\t\t\t\tif (false) \n\t\t\t\tassert false: \"No assigned NullLocationSet for \" + valueNumber + \" in \" + nullValueAssignmentMap.keySet()\n\t\t\t\t+ \" while analyzing \" + classContext.getJavaClass().getClassName() + \".\" + method.getName();\n\t\t\t\tassignedNullLocationSet = TigerSubstitutes.emptySet();\n\t\t\t}\n            SortedSet<Location> knownNullAndDoomedAt = bugLocationMap.get(valueNumber);\n                 \n            BugAnnotation variableAnnotation = null;\n            try {\n                for (Location loc : derefLocationSet)  {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : knownNullAndDoomedAt) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : assignedNullLocationSet) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                \n                \n            } catch (DataflowAnalysisException e2) {\n            }\n            if (variableAnnotation == null) variableAnnotation = new LocalVariableAnnotation(\"?\",-1,-1);\n\n            \n            PostDominatorsAnalysis postDomAnalysis =\n                classContext.getNonExceptionPostDominatorsAnalysis(method);\n            removeStrictlyPostDominatedLocations(derefLocationSet, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(knownNullAndDoomedAt, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(assignedNullLocationSet, postDomAnalysis);\n            \n            \n\t\t\tcollector.foundGuaranteedNullDeref(\n\t\t\t\t\tassignedNullLocationSet,\n\t\t\t\t\tderefLocationSet,\n\t\t\t\t\tknownNullAndDoomedAt,\n\t\t\t\t\tvnaDataflow, valueNumber, \n                    variableAnnotation, e.getValue().isAlwaysOnExceptionPath(),  npeIfStatementCovered.contains(valueNumber));\n\t\t}\n\t}","id":81865,"modified_method":"/**\n\t * Examine null values.\n\t * Report any that are guaranteed to be dereferenced on\n\t * non-implicit-exception paths.\n\t * \n\t * @throws CFGBuilderException \n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void examineNullValues() throws CFGBuilderException, DataflowAnalysisException {\n\t\tSet<LocationWhereValueBecomesNull> locationWhereValueBecomesNullSet =\n\t\t\tinvDataflow.getAnalysis().getLocationWhereValueBecomesNullSet();\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"----------------------- examineNullValues \" + locationWhereValueBecomesNullSet.size());\n\t\t}\n\t\t\n\t\tMap<ValueNumber, SortedSet<Location>> bugStatementLocationMap =\n\t\t\tnew HashMap<ValueNumber, SortedSet<Location>>();\n\t\t// Inspect the method for locations where a null value is guaranteed to\n\t\t// be dereferenced.  Add the dereference locations\n\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap =\n\t\t\tnew HashMap<ValueNumber, NullValueUnconditionalDeref>();\n\t\t\n       // Check every location\n\t\tfor (Iterator<Location> i = classContext.getCFG(method).locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"At location \" + location);\n\t\t\t}\n\t\t\t{\n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n\t\t\t\tif (assertionMethods.isAssertionInstruction (in, classContext.getConstantPoolGen()) ) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugStatementLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaDataflow.getFactAtLocation(location), invDataflow.getFactAtLocation(location), uvdDataflow.getFactAfterLocation(location));\n\t\t}\n\t\tHashSet<ValueNumber> npeIfStatementCovered = new HashSet<ValueNumber>(nullValueGuaranteedDerefMap.keySet());\n        Map<ValueNumber, SortedSet<Location>> bugEdgeLocationMap =\n            new HashMap<ValueNumber, SortedSet<Location>>();\n        \n\t\t// Check every non-exception control edge\n\t\tfor (Iterator<Edge> i = classContext.getCFG(method).edgeIterator(); i.hasNext();) {\n\t\t\tEdge edge = i.next();\n\t\t\t\n\t\t\tif (edge.isExceptionEdge()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"On edge \" + edge.formatAsString(false));\n\t\t\t}\n\t\t\t\n\t\t\tValueNumberFrame vnaFact = vnaDataflow.getResultFact(edge.getSource());\n\t\t\tIsNullValueFrame invFact = invDataflow.getFactOnEdge(edge);\n\t\t\tUnconditionalValueDerefSet uvdFact = uvdDataflow.getFactOnEdge(edge);\n\t\t\tLocation location = Location.getLastLocation(edge.getSource());\n\t\t\tif (location != null) {\n\t\t\t\tInstruction in = location.getHandle().getInstruction();\n\t\t\t\tif (assertionMethods.isAssertionInstruction(in, classContext.getConstantPoolGen())) {\n\t\t\t\t\tif (DEBUG_DEREFS) \n\t\t\t\t\t\tSystem.out.println(\"Skipping because it is an assertion method \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n                    bugEdgeLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n                    vnaFact, invFact, uvdFact);\n\t\t\t}\n\t\t}\n        Map<ValueNumber, SortedSet<Location>> bugLocationMap = bugEdgeLocationMap;\n        bugLocationMap.putAll(bugStatementLocationMap);\n\t\t//\tFor each value number that is null somewhere in the\n\t\t// method, collect the set of locations where it becomes null.\n\t\t// FIXME: we may see some locations that are not guaranteed to be dereferenced (how to fix this?)\n\t\tMap<ValueNumber, Set<Location>> nullValueAssignmentMap =\n\t\t\tnew HashMap<ValueNumber, Set<Location>>();\n\t\tfor (LocationWhereValueBecomesNull lwvbn : locationWhereValueBecomesNullSet) {\n\t\t\tif (DEBUG_DEREFS) System.out.println(\"OOO \" + lwvbn);\n\t\t\tSet<Location> locationSet = nullValueAssignmentMap.get(lwvbn.getValueNumber());\n\t\t\tif (locationSet == null) {\n\t\t\t\tlocationSet = new HashSet<Location>();\n\t\t\t\tnullValueAssignmentMap.put(lwvbn.getValueNumber(), locationSet);\n\t\t\t}\n\t\t\tlocationSet.add(lwvbn.getLocation());\n\t\t\tif (DEBUG_DEREFS)\n\t\t\t\tSystem.out.println(lwvbn.getValueNumber() + \" becomes null at \" + lwvbn.getLocation());\n\t\t}\n\n\t\t// Report \n\t\tfor (Map.Entry<ValueNumber, NullValueUnconditionalDeref> e  : nullValueGuaranteedDerefMap.entrySet()) {\n\t\t\tValueNumber valueNumber = e.getKey();\n\t\t\tSet<Location> derefLocationSet = e.getValue().getDerefLocationSet();\n\t\t\tSet<Location> assignedNullLocationSet = nullValueAssignmentMap.get(valueNumber);\n\t\t\tif (assignedNullLocationSet == null) {\n\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\tString where = classContext.getJavaClass().getClassName() + \".\" + method.getName() + \":\" + method.getSignature();\n\t\t\t\t\tSystem.out.println(\"Problem at \" + where);\n\t\t\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\t\t\tSystem.out.println(\"Dereference at \" + loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO: figure out why this is failing\n\t\t\t\tif (false) \n\t\t\t\tassert false: \"No assigned NullLocationSet for \" + valueNumber + \" in \" + nullValueAssignmentMap.keySet()\n\t\t\t\t+ \" while analyzing \" + classContext.getJavaClass().getClassName() + \".\" + method.getName();\n\t\t\t\tassignedNullLocationSet = TigerSubstitutes.emptySet();\n\t\t\t}\n            SortedSet<Location> knownNullAndDoomedAt = bugLocationMap.get(valueNumber);\n                 \n            BugAnnotation variableAnnotation = null;\n            try {\n                for (Location loc : derefLocationSet)  {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : knownNullAndDoomedAt) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                if (variableAnnotation == null) for (Location loc : assignedNullLocationSet) {\n                    variableAnnotation = NullDerefAndRedundantComparisonFinder.findAnnotationFromValueNumber(method, loc, valueNumber, vnaDataflow.getFactAtLocation(loc));\n                    if (variableAnnotation != null) break;\n                }\n                \n                \n            } catch (DataflowAnalysisException e2) {\n            }\n            if (variableAnnotation == null) variableAnnotation = new LocalVariableAnnotation(\"?\",-1,-1);\n\n            \n\n            if (PRUNE_GUARANTEED_DEREFERENCES) {\n                PostDominatorsAnalysis postDomAnalysis =\n                    classContext.getNonExceptionPostDominatorsAnalysis(method);\n            removeStrictlyPostDominatedLocations(derefLocationSet, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(knownNullAndDoomedAt, postDomAnalysis);\n            \n            removeStrictlyPostDominatedLocations(assignedNullLocationSet, postDomAnalysis);\n            }\n            \n            \n\t\t\tcollector.foundGuaranteedNullDeref(\n\t\t\t\t\tassignedNullLocationSet,\n\t\t\t\t\tderefLocationSet,\n\t\t\t\t\tknownNullAndDoomedAt,\n\t\t\t\t\tvnaDataflow, valueNumber, \n                    variableAnnotation, e.getValue().isAlwaysOnExceptionPath(),  npeIfStatementCovered.contains(valueNumber));\n\t\t}\n\t}","commit_id":"bf4a9b2fcdd4cf6b54520532eeebdf9cd6a05737","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static String writeValue(final Object iValue, final String iFormat) throws IOException {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\r\n\t\tfinal boolean oldAutoConvertSettings;\r\n\r\n\t\tif (iValue instanceof ORecordLazyMultiValue) {\r\n\t\t\toldAutoConvertSettings = ((ORecordLazyMultiValue) iValue).isAutoConvertToRecord();\r\n\t\t\t((ORecordLazyMultiValue) iValue).setAutoConvertToRecord(false);\r\n\t\t} else\r\n\t\t\toldAutoConvertSettings = false;\r\n\r\n\t\tif (iValue == null)\r\n\t\t\tbuffer.append(\"null\");\r\n\r\n\t\telse if (iValue instanceof ORecordId) {\r\n\t\t\tfinal ORecordId rid = (ORecordId) iValue;\r\n\t\t\tbuffer.append(\"\\\"#\");\r\n\t\t\tbuffer.append(rid.toString());\r\n\t\t\tbuffer.append('\\\"');\r\n\r\n\t\t} else if (iValue instanceof ORecord<?>) {\r\n\t\t\tfinal ORecord<?> linked = (ORecord<?>) iValue;\r\n\t\t\tif (linked.getIdentity().isValid()) {\r\n\t\t\t\tbuffer.append(\"\\\"#\");\r\n\t\t\t\tbuffer.append(linked.getIdentity().toString());\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append(linked.toJSON(iFormat));\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue.getClass().isArray()) {\r\n\r\n\t\t\tif (iValue instanceof byte[]) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tfinal byte[] source = (byte[]) iValue;\r\n\r\n\t\t\t\tbuffer.append(OBase64Utils.encodeBytes(source));\r\n\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('[');\r\n\t\t\t\tfor (int i = 0; i < Array.getLength(iValue); ++i) {\r\n\t\t\t\t\tif (i > 0)\r\n\t\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\t\tbuffer.append(writeValue(Array.get(iValue, i), iFormat));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append(']');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue instanceof Collection<?>) {\r\n\t\t\tfinal Collection<Object> coll = (Collection<Object>) iValue;\r\n\t\t\tbuffer.append('[');\r\n\t\t\tint i = 0;\r\n\t\t\tfor (Iterator<Object> it = coll.iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(it.next(), iFormat));\r\n\t\t\t}\r\n\t\t\tbuffer.append(']');\r\n\r\n\t\t} else if (iValue instanceof Map<?, ?>) {\r\n\t\t\tfinal Map<Object, Object> map = (Map<Object, Object>) iValue;\r\n\t\t\tbuffer.append('{');\r\n\t\t\tint i = 0;\r\n\t\t\tEntry<Object, Object> entry;\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = map.entrySet().iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tentry = it.next();\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getKey(), iFormat));\r\n\t\t\t\tbuffer.append(\": \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getValue(), iFormat));\r\n\t\t\t}\r\n\t\t\tbuffer.append('}');\r\n\r\n\t\t} else if (iValue instanceof Date) {\r\n\t\t\tfinal SimpleDateFormat dateFormat = new SimpleDateFormat(ORecordSerializerJSON.DEF_DATE_FORMAT);\r\n\t\t\tbuffer.append('\"');\r\n\t\t\tbuffer.append(dateFormat.format(iValue));\r\n\t\t\tbuffer.append('\"');\r\n\t\t} else if (iValue instanceof String) {\r\n\t\t\tfinal String v = (String) iValue;\r\n\t\t\tif (v.startsWith(\"\\\"\"))\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\telse {\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tbuffer.append(iValue.toString());\r\n\r\n\t\tif (iValue instanceof ORecordLazyMultiValue)\r\n\t\t\t((ORecordLazyMultiValue) iValue).setAutoConvertToRecord(oldAutoConvertSettings);\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":81866,"modified_method":"public static String writeValue(final Object iValue, final String iFormat) throws IOException {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\r\n\t\tfinal boolean oldAutoConvertSettings;\r\n\r\n\t\tif (iValue instanceof ORecordLazyMultiValue) {\r\n\t\t\toldAutoConvertSettings = ((ORecordLazyMultiValue) iValue).isAutoConvertToRecord();\r\n\t\t\t((ORecordLazyMultiValue) iValue).setAutoConvertToRecord(false);\r\n\t\t} else\r\n\t\t\toldAutoConvertSettings = false;\r\n\r\n\t\tif (iValue == null)\r\n\t\t\tbuffer.append(\"null\");\r\n\r\n\t\telse if (iValue instanceof ORecordId) {\r\n\t\t\tfinal ORecordId rid = (ORecordId) iValue;\r\n\t\t\tbuffer.append(\"\\\"#\");\r\n\t\t\trid.toString(buffer);\r\n\t\t\tbuffer.append('\\\"');\r\n\r\n\t\t} else if (iValue instanceof ORecord<?>) {\r\n\t\t\tfinal ORecord<?> linked = (ORecord<?>) iValue;\r\n\t\t\tif (linked.getIdentity().isValid()) {\r\n\t\t\t\tbuffer.append(\"\\\"#\");\r\n\t\t\t\tlinked.getIdentity().toString(buffer);\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append(linked.toJSON(iFormat));\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue.getClass().isArray()) {\r\n\r\n\t\t\tif (iValue instanceof byte[]) {\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t\tfinal byte[] source = (byte[]) iValue;\r\n\r\n\t\t\t\tbuffer.append(OBase64Utils.encodeBytes(source));\r\n\r\n\t\t\t\tbuffer.append('\\\"');\r\n\t\t\t} else {\r\n\t\t\t\tbuffer.append('[');\r\n\t\t\t\tfor (int i = 0; i < Array.getLength(iValue); ++i) {\r\n\t\t\t\t\tif (i > 0)\r\n\t\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\t\tbuffer.append(writeValue(Array.get(iValue, i), iFormat));\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.append(']');\r\n\t\t\t}\r\n\r\n\t\t} else if (iValue instanceof Collection<?>) {\r\n\t\t\tfinal Collection<Object> coll = (Collection<Object>) iValue;\r\n\t\t\tbuffer.append('[');\r\n\t\t\tint i = 0;\r\n\t\t\tfor (Iterator<Object> it = coll.iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(it.next(), iFormat));\r\n\t\t\t}\r\n\t\t\tbuffer.append(']');\r\n\r\n\t\t} else if (iValue instanceof Map<?, ?>) {\r\n\t\t\tfinal Map<Object, Object> map = (Map<Object, Object>) iValue;\r\n\t\t\tbuffer.append('{');\r\n\t\t\tint i = 0;\r\n\t\t\tEntry<Object, Object> entry;\r\n\t\t\tfor (Iterator<Entry<Object, Object>> it = map.entrySet().iterator(); it.hasNext(); ++i) {\r\n\t\t\t\tentry = it.next();\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getKey(), iFormat));\r\n\t\t\t\tbuffer.append(\": \");\r\n\t\t\t\tbuffer.append(writeValue(entry.getValue(), iFormat));\r\n\t\t\t}\r\n\t\t\tbuffer.append('}');\r\n\r\n\t\t} else if (iValue instanceof Date) {\r\n\t\t\tfinal SimpleDateFormat dateFormat = new SimpleDateFormat(ORecordSerializerJSON.DEF_DATE_FORMAT);\r\n\t\t\tbuffer.append('\"');\r\n\t\t\tbuffer.append(dateFormat.format(iValue));\r\n\t\t\tbuffer.append('\"');\r\n\t\t} else if (iValue instanceof String) {\r\n\t\t\tfinal String v = (String) iValue;\r\n\t\t\tif (v.startsWith(\"\\\"\"))\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\telse {\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t\tbuffer.append(v);\r\n\t\t\t\tbuffer.append('\"');\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tbuffer.append(iValue.toString());\r\n\r\n\t\tif (iValue instanceof ORecordLazyMultiValue)\r\n\t\t\t((ORecordLazyMultiValue) iValue).setAutoConvertToRecord(oldAutoConvertSettings);\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static String generateString(final int iClusterId, final long iPosition) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(iClusterId);\r\n\t\tbuffer.append(SEPARATOR);\r\n\t\tbuffer.append(iPosition);\r\n\t\treturn buffer.toString();\r\n\t}","id":81867,"modified_method":"public static String generateString(final int iClusterId, final long iPosition) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder(8);\r\n\t\tbuffer.append(iClusterId);\r\n\t\tbuffer.append(SEPARATOR);\r\n\t\tbuffer.append(iPosition);\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String fieldToStream(final ODocument iRecord, final ODatabaseComplex<?> iDatabase,\r\n\t\t\tfinal OUserObject2RecordHandler iObjHandler, final OType iType, final OClass iLinkedClass, final OType iLinkedType,\r\n\t\t\tfinal String iName, final Object iValue, final Set<Integer> iMarshalledRecords, final boolean iSaveOnlyDirty) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\r\n\t\tswitch (iType) {\r\n\r\n\t\tcase LINK: {\r\n\t\t\tfinal Object link = linkToStream(buffer, iRecord, iValue);\r\n\t\t\tif (link != null)\r\n\t\t\t\t// OVERWRITE CONTENT\r\n\t\t\t\tiRecord.field(iName, link);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase LINKLIST: {\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_BEGIN);\r\n\r\n\t\t\tif (iValue != null) {\r\n\t\t\t\tObject link;\r\n\t\t\t\tint items = 0;\r\n\t\t\t\tList<Object> coll = (List<Object>) iValue;\r\n\t\t\t\tif (coll instanceof OLazyObjectList<?>) {\r\n\t\t\t\t\t((OLazyObjectList<?>) coll).setConvertToRecord(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tboolean autoConvert = false;\r\n\t\t\t\tif (coll instanceof ORecordLazyMultiValue) {\r\n\t\t\t\t\tautoConvert = ((ORecordLazyMultiValue) coll).isAutoConvertToRecord();\r\n\t\t\t\t\t((ORecordLazyMultiValue) coll).convertRecords2Links();\r\n\t\t\t\t\t((ORecordLazyMultiValue) coll).setAutoConvertToRecord(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// LINKED LIST\r\n\t\t\t\t\tfor (int i = 0; i < coll.size(); ++i) {\r\n\t\t\t\t\t\tif (items++ > 0)\r\n\t\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\t\t\tlink = linkToStream(buffer, iRecord, coll.get(i));\r\n\r\n\t\t\t\t\t\tif (link != null)\r\n\t\t\t\t\t\t\tcoll.set(i, link);\r\n\t\t\t\t\t}\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif (coll instanceof OLazyObjectList<?>) {\r\n\t\t\t\t\t\t((OLazyObjectList<?>) coll).setConvertToRecord(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (coll instanceof ORecordLazyMultiValue)\r\n\t\t\t\t\t((ORecordLazyMultiValue) coll).setAutoConvertToRecord(autoConvert);\r\n\t\t\t}\r\n\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_END);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase LINKSET: {\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_BEGIN);\r\n\r\n\t\t\tint items = 0;\r\n\r\n\t\t\tORecordLazySet coll;\r\n\t\t\tif (!(iValue instanceof ORecordLazySet)) {\r\n\t\t\t\t// FIRST TIME: CONVERT THE ENTIRE COLLECTION\r\n\t\t\t\tcoll = new ORecordLazySet(iRecord);\r\n\t\t\t\tcoll.addAll((Collection<? extends OIdentifiable>) iValue);\r\n\t\t\t\t((Collection<? extends OIdentifiable>) iValue).clear();\r\n\r\n\t\t\t\tiRecord.field(iName, coll);\r\n\t\t\t} else\r\n\t\t\t\tcoll = (ORecordLazySet) iValue;\r\n\r\n\t\t\t// LINKED SET\r\n\t\t\tfor (Iterator<OIdentifiable> it = coll.rawIterator(); it.hasNext();) {\r\n\t\t\t\tif (items++ > 0)\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\tlinkToStream(buffer, iRecord, it.next());\r\n\t\t\t}\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_END);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase LINKMAP: {\r\n\t\t\tbuffer.append(OStringSerializerHelper.MAP_BEGIN);\r\n\r\n\t\t\tObject link;\r\n\t\t\tint items = 0;\r\n\t\t\tMap<String, Object> map = (Map<String, Object>) iValue;\r\n\t\t\tboolean invalidMap = false;\r\n\r\n\t\t\t// LINKED MAP\r\n\t\t\tif (map instanceof OLazyObjectMap<?>) {\r\n\t\t\t\t((OLazyObjectMap<?>) map).setConvertToRecord(false);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tfor (Map.Entry<String, Object> entry : map.entrySet()) {\r\n\t\t\t\t\tif (items++ > 0)\r\n\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\t\tbuffer.append(fieldTypeToString(iDatabase, OType.STRING, entry.getKey()));\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\t\tlink = linkToStream(buffer, iRecord, entry.getValue());\r\n\r\n\t\t\t\t\tif (link != null && !invalidMap)\r\n\t\t\t\t\t\t// IDENTITY IS CHANGED, RE-SET INTO THE COLLECTION TO RECOMPUTE THE HASH\r\n\t\t\t\t\t\tinvalidMap = true;\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (map instanceof OLazyObjectMap<?>) {\r\n\t\t\t\t\t((OLazyObjectMap<?>) map).setConvertToRecord(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (invalidMap) {\r\n\t\t\t\tfinal ORecordLazyMap newMap = new ORecordLazyMap(iRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\t\t\t// REPLACE ALL CHANGED ITEMS\r\n\t\t\t\tfor (Map.Entry<String, Object> entry : map.entrySet()) {\r\n\t\t\t\t\tnewMap.put(entry.getKey(), entry.getValue());\r\n\t\t\t\t}\r\n\t\t\t\tmap.clear();\r\n\t\t\t\tiRecord.field(iName, newMap);\r\n\t\t\t}\r\n\r\n\t\t\tbuffer.append(OStringSerializerHelper.MAP_END);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase EMBEDDED:\r\n\t\t\tif (iValue instanceof ODocument) {\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_BEGIN);\r\n\t\t\t\tbuffer.append(toString((ODocument) iValue, null, iObjHandler, iMarshalledRecords));\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_END);\r\n\t\t\t} else if (iValue != null)\r\n\t\t\t\tbuffer.append(iValue.toString());\r\n\t\t\tbreak;\r\n\r\n\t\tcase EMBEDDEDLIST:\r\n\t\tcase EMBEDDEDSET: {\r\n\t\t\tbuffer.append(embeddedCollectionToStream(iDatabase, iObjHandler, iLinkedClass, iLinkedType, iValue, iMarshalledRecords,\r\n\t\t\t\t\tiSaveOnlyDirty));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase EMBEDDEDMAP: {\r\n\t\t\tbuffer.append(embeddedMapToStream(iDatabase, iObjHandler, iLinkedClass, iLinkedType, iValue, iMarshalledRecords,\r\n\t\t\t\t\tiSaveOnlyDirty));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tdefault:\r\n\t\t\treturn fieldTypeToString(iDatabase, iType, iValue);\r\n\t\t}\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":81868,"modified_method":"public String fieldToStream(final ODocument iRecord, final ODatabaseComplex<?> iDatabase,\r\n\t\t\tfinal OUserObject2RecordHandler iObjHandler, final OType iType, final OClass iLinkedClass, final OType iLinkedType,\r\n\t\t\tfinal String iName, final Object iValue, final Set<Integer> iMarshalledRecords, final boolean iSaveOnlyDirty) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\r\n\t\tswitch (iType) {\r\n\r\n\t\tcase LINK: {\r\n\t\t\tfinal Object link = linkToStream(buffer, iRecord, iValue);\r\n\t\t\tif (link != null)\r\n\t\t\t\t// OVERWRITE CONTENT\r\n\t\t\t\tiRecord.field(iName, link);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase LINKLIST: {\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_BEGIN);\r\n\r\n\t\t\tif (iValue != null) {\r\n\t\t\t\tObject link;\r\n\t\t\t\tint items = 0;\r\n\t\t\t\tList<Object> coll = (List<Object>) iValue;\r\n\t\t\t\tif (coll instanceof OLazyObjectList<?>) {\r\n\t\t\t\t\t((OLazyObjectList<?>) coll).setConvertToRecord(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tboolean autoConvert = false;\r\n\t\t\t\tif (coll instanceof ORecordLazyMultiValue) {\r\n\t\t\t\t\tautoConvert = ((ORecordLazyMultiValue) coll).isAutoConvertToRecord();\r\n\t\t\t\t\t((ORecordLazyMultiValue) coll).convertRecords2Links();\r\n\t\t\t\t\t((ORecordLazyMultiValue) coll).setAutoConvertToRecord(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// LINKED LIST\r\n\t\t\t\t\tfor (int i = 0; i < coll.size(); ++i) {\r\n\t\t\t\t\t\tif (items++ > 0)\r\n\t\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\t\t\tlink = linkToStream(buffer, iRecord, coll.get(i));\r\n\r\n\t\t\t\t\t\tif (link != null)\r\n\t\t\t\t\t\t\tcoll.set(i, link);\r\n\t\t\t\t\t}\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif (coll instanceof OLazyObjectList<?>) {\r\n\t\t\t\t\t\t((OLazyObjectList<?>) coll).setConvertToRecord(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (coll instanceof ORecordLazyMultiValue)\r\n\t\t\t\t\t((ORecordLazyMultiValue) coll).setAutoConvertToRecord(autoConvert);\r\n\t\t\t}\r\n\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_END);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase LINKSET: {\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_BEGIN);\r\n\r\n\t\t\tint items = 0;\r\n\r\n\t\t\tORecordLazySet coll;\r\n\t\t\tif (!(iValue instanceof ORecordLazySet)) {\r\n\t\t\t\t// FIRST TIME: CONVERT THE ENTIRE COLLECTION\r\n\t\t\t\tcoll = new ORecordLazySet(iRecord);\r\n\t\t\t\tcoll.addAll((Collection<? extends OIdentifiable>) iValue);\r\n\t\t\t\t((Collection<? extends OIdentifiable>) iValue).clear();\r\n\r\n\t\t\t\tiRecord.field(iName, coll);\r\n\t\t\t} else\r\n\t\t\t\tcoll = (ORecordLazySet) iValue;\r\n\r\n\t\t\t// LINKED SET\r\n\t\t\tfor (Iterator<OIdentifiable> it = coll.rawIterator(); it.hasNext();) {\r\n\t\t\t\tif (items++ > 0)\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\tlinkToStream(buffer, iRecord, it.next());\r\n\t\t\t}\r\n\t\t\tbuffer.append(OStringSerializerHelper.COLLECTION_END);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase LINKMAP: {\r\n\t\t\tbuffer.append(OStringSerializerHelper.MAP_BEGIN);\r\n\r\n\t\t\tObject link;\r\n\t\t\tint items = 0;\r\n\t\t\tMap<String, Object> map = (Map<String, Object>) iValue;\r\n\t\t\tboolean invalidMap = false;\r\n\r\n\t\t\t// LINKED MAP\r\n\t\t\tif (map instanceof OLazyObjectMap<?>) {\r\n\t\t\t\t((OLazyObjectMap<?>) map).setConvertToRecord(false);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tfor (Map.Entry<String, Object> entry : map.entrySet()) {\r\n\t\t\t\t\tif (items++ > 0)\r\n\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\t\tfieldTypeToString(buffer, iDatabase, OType.STRING, entry.getKey());\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\t\tlink = linkToStream(buffer, iRecord, entry.getValue());\r\n\r\n\t\t\t\t\tif (link != null && !invalidMap)\r\n\t\t\t\t\t\t// IDENTITY IS CHANGED, RE-SET INTO THE COLLECTION TO RECOMPUTE THE HASH\r\n\t\t\t\t\t\tinvalidMap = true;\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (map instanceof OLazyObjectMap<?>) {\r\n\t\t\t\t\t((OLazyObjectMap<?>) map).setConvertToRecord(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (invalidMap) {\r\n\t\t\t\tfinal ORecordLazyMap newMap = new ORecordLazyMap(iRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\t\t\t// REPLACE ALL CHANGED ITEMS\r\n\t\t\t\tfor (Map.Entry<String, Object> entry : map.entrySet()) {\r\n\t\t\t\t\tnewMap.put(entry.getKey(), entry.getValue());\r\n\t\t\t\t}\r\n\t\t\t\tmap.clear();\r\n\t\t\t\tiRecord.field(iName, newMap);\r\n\t\t\t}\r\n\r\n\t\t\tbuffer.append(OStringSerializerHelper.MAP_END);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase EMBEDDED:\r\n\t\t\tif (iValue instanceof ODocument) {\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_BEGIN);\r\n\t\t\t\tbuffer.append(toString((ODocument) iValue, null, iObjHandler, iMarshalledRecords));\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_END);\r\n\t\t\t} else if (iValue != null)\r\n\t\t\t\tbuffer.append(iValue.toString());\r\n\t\t\tbreak;\r\n\r\n\t\tcase EMBEDDEDLIST:\r\n\t\tcase EMBEDDEDSET: {\r\n\t\t\tbuffer.append(embeddedCollectionToStream(iDatabase, iObjHandler, iLinkedClass, iLinkedType, iValue, iMarshalledRecords,\r\n\t\t\t\t\tiSaveOnlyDirty));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase EMBEDDEDMAP: {\r\n\t\t\tbuffer.append(embeddedMapToStream(iDatabase, iObjHandler, iLinkedClass, iLinkedType, iValue, iMarshalledRecords,\r\n\t\t\t\t\tiSaveOnlyDirty));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tdefault:\r\n\t\t\tfieldTypeToString(buffer, iDatabase, iType, iValue);\r\n\t\t}\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String embeddedMapToStream(final ODatabaseComplex<?> iDatabase, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal OClass iLinkedClass, OType iLinkedType, final Object iValue, final Set<Integer> iMarshalledRecords,\r\n\t\t\tfinal boolean iSaveOnlyDirty) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(OStringSerializerHelper.MAP_BEGIN);\r\n\r\n\t\tif (iValue != null) {\r\n\t\t\tint items = 0;\r\n\t\t\t// EMBEDDED OBJECTS\r\n\t\t\tODocument record;\r\n\t\t\tfor (Entry<String, Object> o : ((Map<String, Object>) iValue).entrySet()) {\r\n\t\t\t\tif (items > 0)\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\tif (o != null) {\r\n\t\t\t\t\tbuffer.append(fieldTypeToString(iDatabase, OType.STRING, o.getKey()));\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\r\n\t\t\t\t\tif (o.getValue() instanceof ORecord<?>) {\r\n\t\t\t\t\t\tif (o.getValue() instanceof ODocument)\r\n\t\t\t\t\t\t\trecord = (ODocument) o.getValue();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\trecord = OObjectSerializerHelper.toStream(o.getValue(), new ODocument((ODatabaseRecord) iDatabase, o.getValue()\r\n\t\t\t\t\t\t\t\t\t.getClass().getSimpleName()),\r\n\t\t\t\t\t\t\t\t\tiDatabase instanceof ODatabaseObjectTx ? ((ODatabaseObjectTx) iDatabase).getEntityManager()\r\n\t\t\t\t\t\t\t\t\t\t\t: OEntityManagerInternal.INSTANCE, iLinkedClass, iObjHandler != null ? iObjHandler\r\n\t\t\t\t\t\t\t\t\t\t\t: new OUserObject2RecordHandler() {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic Object getUserObjectByRecord(ORecordInternal<?> iRecord, final String iFetchPlan) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn iRecord;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic ORecordInternal<?> getRecordByUserObject(Object iPojo, boolean iIsMandatory) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ODocument(iLinkedClass);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean existsUserObjectByRID(ORID iRID) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic void registerPojo(Object iObject, ORecordInternal<?> iRecord) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}, null, iSaveOnlyDirty);\r\n\r\n\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_BEGIN);\r\n\t\t\t\t\t\t// buffer.append(OStringSerializerHelper.fieldTypeToString(iLinkedType, record));\r\n\t\t\t\t\t\tbuffer.append(toString(record, null, iObjHandler, iMarshalledRecords));\r\n\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_END);\r\n\t\t\t\t\t} else if (o.getValue() instanceof Map<?, ?>) {\r\n\t\t\t\t\t\t// SUB MAP\r\n\t\t\t\t\t\tbuffer.append(fieldTypeToString(iDatabase, OType.EMBEDDEDMAP, o.getValue()));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// EMBEDDED LITERALS\r\n\t\t\t\t\t\tif (iLinkedType == null)\r\n\t\t\t\t\t\t\tiLinkedType = OType.getTypeByClass(o.getValue().getClass());\r\n\t\t\t\t\t\tbuffer.append(fieldTypeToString(iDatabase, iLinkedType, o.getValue()));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\titems++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbuffer.append(OStringSerializerHelper.MAP_END);\r\n\t\treturn buffer.toString();\r\n\t}","id":81869,"modified_method":"public String embeddedMapToStream(final ODatabaseComplex<?> iDatabase, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal OClass iLinkedClass, OType iLinkedType, final Object iValue, final Set<Integer> iMarshalledRecords,\r\n\t\t\tfinal boolean iSaveOnlyDirty) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(OStringSerializerHelper.MAP_BEGIN);\r\n\r\n\t\tif (iValue != null) {\r\n\t\t\tint items = 0;\r\n\t\t\t// EMBEDDED OBJECTS\r\n\t\t\tODocument record;\r\n\t\t\tfor (Entry<String, Object> o : ((Map<String, Object>) iValue).entrySet()) {\r\n\t\t\t\tif (items > 0)\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t\tif (o != null) {\r\n\t\t\t\t\tfieldTypeToString(buffer, iDatabase, OType.STRING, o.getKey());\r\n\t\t\t\t\tbuffer.append(OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\r\n\t\t\t\t\tif (o.getValue() instanceof ORecord<?>) {\r\n\t\t\t\t\t\tif (o.getValue() instanceof ODocument)\r\n\t\t\t\t\t\t\trecord = (ODocument) o.getValue();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\trecord = OObjectSerializerHelper.toStream(o.getValue(), new ODocument((ODatabaseRecord) iDatabase, o.getValue()\r\n\t\t\t\t\t\t\t\t\t.getClass().getSimpleName()),\r\n\t\t\t\t\t\t\t\t\tiDatabase instanceof ODatabaseObjectTx ? ((ODatabaseObjectTx) iDatabase).getEntityManager()\r\n\t\t\t\t\t\t\t\t\t\t\t: OEntityManagerInternal.INSTANCE, iLinkedClass, iObjHandler != null ? iObjHandler\r\n\t\t\t\t\t\t\t\t\t\t\t: new OUserObject2RecordHandler() {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic Object getUserObjectByRecord(ORecordInternal<?> iRecord, final String iFetchPlan) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn iRecord;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic ORecordInternal<?> getRecordByUserObject(Object iPojo, boolean iIsMandatory) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ODocument(iLinkedClass);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean existsUserObjectByRID(ORID iRID) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpublic void registerPojo(Object iObject, ORecordInternal<?> iRecord) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}, null, iSaveOnlyDirty);\r\n\r\n\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_BEGIN);\r\n\t\t\t\t\t\t// buffer.append(OStringSerializerHelper.fieldTypeToString(iLinkedType, record));\r\n\t\t\t\t\t\tbuffer.append(toString(record, null, iObjHandler, iMarshalledRecords));\r\n\t\t\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_END);\r\n\t\t\t\t\t} else if (o.getValue() instanceof Map<?, ?>) {\r\n\t\t\t\t\t\t// SUB MAP\r\n\t\t\t\t\t\tfieldTypeToString(buffer, iDatabase, OType.EMBEDDEDMAP, o.getValue());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// EMBEDDED LITERALS\r\n\t\t\t\t\t\tif (iLinkedType == null)\r\n\t\t\t\t\t\t\tiLinkedType = OType.getTypeByClass(o.getValue().getClass());\r\n\t\t\t\t\t\tfieldTypeToString(buffer, iDatabase, iLinkedType, o.getValue());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\titems++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbuffer.append(OStringSerializerHelper.MAP_END);\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String embeddedCollectionToStream(final ODatabaseComplex<?> iDatabase, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal OClass iLinkedClass, final OType iLinkedType, final Object iValue, final Set<Integer> iMarshalledRecords,\r\n\t\t\tfinal boolean iSaveOnlyDirty) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(OStringSerializerHelper.COLLECTION_BEGIN);\r\n\r\n\t\tfinal int size = iValue instanceof Collection<?> ? ((Collection<Object>) iValue).size() : Array.getLength(iValue);\r\n\t\tfinal Iterator<Object> iterator = iValue instanceof Collection<?> ? ((Collection<Object>) iValue).iterator() : null;\r\n\t\tObject o;\r\n\r\n\t\tfor (int i = 0; i < size; ++i) {\r\n\t\t\tif (iValue instanceof Collection<?>)\r\n\t\t\t\to = iterator.next();\r\n\t\t\telse\r\n\t\t\t\to = Array.get(iValue, i);\r\n\r\n\t\t\tif (i > 0)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tif (o == null)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tODocument document = null;\r\n\t\t\tfinal OClass linkedClass;\r\n\t\t\tif (!(o instanceof ORecord<?>)) {\r\n\t\t\t\tfinal String fieldBound = OObjectSerializerHelper.getDocumentBoundField(o.getClass());\r\n\t\t\t\tif (fieldBound != null) {\r\n\t\t\t\t\tOObjectSerializerHelper.invokeCallback(o, null, OBeforeSerialization.class);\r\n\t\t\t\t\tdocument = (ODocument) OObjectSerializerHelper.getFieldValue(o, fieldBound);\r\n\t\t\t\t\tOObjectSerializerHelper.invokeCallback(o, document, OAfterSerialization.class);\r\n\t\t\t\t}\r\n\t\t\t\tlinkedClass = iLinkedClass;\r\n\t\t\t} else {\r\n\t\t\t\tdocument = (ODocument) o;\r\n\r\n\t\t\t\tif (document.getIdentity().isTemporary())\r\n\t\t\t\t\tdocument.save();\r\n\r\n\t\t\t\tlinkedClass = document.getSchemaClass();\r\n\t\t\t}\r\n\r\n\t\t\tif (document != null && iLinkedType != OType.LINK)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_BEGIN);\r\n\r\n\t\t\tif (iLinkedType != OType.LINK && (linkedClass != null || document != null)) {\r\n\t\t\t\tif (document == null)\r\n\t\t\t\t\t// EMBEDDED OBJECTS\r\n\t\t\t\t\tdocument = OObjectSerializerHelper.toStream(o, new ODocument((ODatabaseRecord) iDatabase, o.getClass().getSimpleName()),\r\n\t\t\t\t\t\t\tiDatabase instanceof ODatabaseObjectTx ? ((ODatabaseObjectTx) iDatabase).getEntityManager()\r\n\t\t\t\t\t\t\t\t\t: OEntityManagerInternal.INSTANCE, iLinkedClass, iObjHandler != null ? iObjHandler\r\n\t\t\t\t\t\t\t\t\t: new OUserObject2RecordHandler() {\r\n\t\t\t\t\t\t\t\t\t\tpublic Object getUserObjectByRecord(ORecordInternal<?> iRecord, final String iFetchPlan) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn iRecord;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tpublic ORecordInternal<?> getRecordByUserObject(Object iPojo, boolean iIsMandatory) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn new ODocument(linkedClass);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tpublic boolean existsUserObjectByRID(ORID iRID) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tpublic void registerPojo(Object iObject, ORecordInternal<?> iRecord) {\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, null, iSaveOnlyDirty);\r\n\r\n\t\t\t\tbuffer.append(toString(document, null, iObjHandler, iMarshalledRecords));\r\n\t\t\t} else {\r\n\t\t\t\t// EMBEDDED LITERALS\r\n\t\t\t\tbuffer.append(fieldTypeToString(iDatabase, iLinkedType, o));\r\n\t\t\t}\r\n\r\n\t\t\tif (document != null && iLinkedType != OType.LINK)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_END);\r\n\t\t}\r\n\r\n\t\tbuffer.append(OStringSerializerHelper.COLLECTION_END);\r\n\t\treturn buffer.toString();\r\n\t}","id":81870,"modified_method":"public String embeddedCollectionToStream(final ODatabaseComplex<?> iDatabase, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal OClass iLinkedClass, final OType iLinkedType, final Object iValue, final Set<Integer> iMarshalledRecords,\r\n\t\t\tfinal boolean iSaveOnlyDirty) {\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(OStringSerializerHelper.COLLECTION_BEGIN);\r\n\r\n\t\tfinal int size = iValue instanceof Collection<?> ? ((Collection<Object>) iValue).size() : Array.getLength(iValue);\r\n\t\tfinal Iterator<Object> iterator = iValue instanceof Collection<?> ? ((Collection<Object>) iValue).iterator() : null;\r\n\t\tObject o;\r\n\r\n\t\tfor (int i = 0; i < size; ++i) {\r\n\t\t\tif (iValue instanceof Collection<?>)\r\n\t\t\t\to = iterator.next();\r\n\t\t\telse\r\n\t\t\t\to = Array.get(iValue, i);\r\n\r\n\t\t\tif (i > 0)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tif (o == null)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tODocument document = null;\r\n\t\t\tfinal OClass linkedClass;\r\n\t\t\tif (!(o instanceof ORecord<?>)) {\r\n\t\t\t\tfinal String fieldBound = OObjectSerializerHelper.getDocumentBoundField(o.getClass());\r\n\t\t\t\tif (fieldBound != null) {\r\n\t\t\t\t\tOObjectSerializerHelper.invokeCallback(o, null, OBeforeSerialization.class);\r\n\t\t\t\t\tdocument = (ODocument) OObjectSerializerHelper.getFieldValue(o, fieldBound);\r\n\t\t\t\t\tOObjectSerializerHelper.invokeCallback(o, document, OAfterSerialization.class);\r\n\t\t\t\t}\r\n\t\t\t\tlinkedClass = iLinkedClass;\r\n\t\t\t} else {\r\n\t\t\t\tdocument = (ODocument) o;\r\n\r\n\t\t\t\tif (document.getIdentity().isTemporary())\r\n\t\t\t\t\tdocument.save();\r\n\r\n\t\t\t\tlinkedClass = document.getSchemaClass();\r\n\t\t\t}\r\n\r\n\t\t\tif (document != null && iLinkedType != OType.LINK)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_BEGIN);\r\n\r\n\t\t\tif (iLinkedType != OType.LINK && (linkedClass != null || document != null)) {\r\n\t\t\t\tif (document == null)\r\n\t\t\t\t\t// EMBEDDED OBJECTS\r\n\t\t\t\t\tdocument = OObjectSerializerHelper.toStream(o, new ODocument((ODatabaseRecord) iDatabase, o.getClass().getSimpleName()),\r\n\t\t\t\t\t\t\tiDatabase instanceof ODatabaseObjectTx ? ((ODatabaseObjectTx) iDatabase).getEntityManager()\r\n\t\t\t\t\t\t\t\t\t: OEntityManagerInternal.INSTANCE, iLinkedClass, iObjHandler != null ? iObjHandler\r\n\t\t\t\t\t\t\t\t\t: new OUserObject2RecordHandler() {\r\n\t\t\t\t\t\t\t\t\t\tpublic Object getUserObjectByRecord(ORecordInternal<?> iRecord, final String iFetchPlan) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn iRecord;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tpublic ORecordInternal<?> getRecordByUserObject(Object iPojo, boolean iIsMandatory) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn new ODocument(linkedClass);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tpublic boolean existsUserObjectByRID(ORID iRID) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tpublic void registerPojo(Object iObject, ORecordInternal<?> iRecord) {\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, null, iSaveOnlyDirty);\r\n\r\n\t\t\t\tbuffer.append(toString(document, null, iObjHandler, iMarshalledRecords));\r\n\t\t\t} else {\r\n\t\t\t\t// EMBEDDED LITERALS\r\n\t\t\t\tfieldTypeToString(buffer, iDatabase, iLinkedType, o);\r\n\t\t\t}\r\n\r\n\t\t\tif (document != null && iLinkedType != OType.LINK)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.PARENTHESIS_END);\r\n\t\t}\r\n\r\n\t\tbuffer.append(OStringSerializerHelper.COLLECTION_END);\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Serialize the link.\r\n\t * \r\n\t * @param buffer\r\n\t * @param iParentRecord\r\n\t * @param iFieldName\r\n\t *          TODO\r\n\t * @param iLinked\r\n\t *          Can be an instance of ORID or a Record<?>\r\n\t * @return\r\n\t */\r\n\tprivate Object linkToStream(final StringBuilder buffer, final ORecordSchemaAware<?> iParentRecord, Object iLinked) {\r\n\t\tif (iLinked == null)\r\n\t\t\t// NULL REFERENCE\r\n\t\t\treturn null;\r\n\r\n\t\tObject resultRid = null;\r\n\t\tORID rid;\r\n\r\n\t\tif (iLinked instanceof ORID) {\r\n\t\t\t// JUST THE REFERENCE\r\n\t\t\trid = (ORID) iLinked;\r\n\t\t} else {\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>)) {\r\n\t\t\t\t// NOT RECORD: TRY TO EXTRACT THE DOCUMENT IF ANY\r\n\t\t\t\tfinal String boundDocumentField = OObjectSerializerHelper.getDocumentBoundField(iLinked.getClass());\r\n\t\t\t\tif (boundDocumentField != null)\r\n\t\t\t\t\tiLinked = OObjectSerializerHelper.getFieldValue(iLinked, boundDocumentField);\r\n\t\t\t}\r\n\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>))\r\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid object received. Expected a record but received type=\"\r\n\t\t\t\t\t\t+ iLinked.getClass().getName() + \" and value=\" + iLinked);\r\n\r\n\t\t\t// RECORD\r\n\t\t\tORecordInternal<?> iLinkedRecord = (ORecordInternal<?>) iLinked;\r\n\t\t\trid = iLinkedRecord.getIdentity();\r\n\r\n\t\t\tif (rid.isNew() || iLinkedRecord.isDirty()) {\r\n\t\t\t\tif (iLinkedRecord.getDatabase() == null)\r\n\t\t\t\t\t// OVERWRITE THE DATABASE TO THE SAME OF THE PARENT ONE\r\n\t\t\t\t\tiLinkedRecord.setDatabase(iParentRecord.getDatabase());\r\n\r\n\t\t\t\tif (iLinkedRecord instanceof ODocument) {\r\n\t\t\t\t\tfinal OClass schemaClass = ((ODocument) iLinkedRecord).getSchemaClass();\r\n\t\t\t\t\tiLinkedRecord.getDatabase().save(iLinkedRecord,\r\n\t\t\t\t\t\t\tschemaClass != null ? iLinkedRecord.getDatabase().getClusterNameById(schemaClass.getDefaultClusterId()) : null);\r\n\t\t\t\t} else\r\n\t\t\t\t\t// STORE THE TRAVERSED OBJECT TO KNOW THE RECORD ID. CALL THIS VERSION TO AVOID CLEAR OF STACK IN THREAD-LOCAL\r\n\t\t\t\t\tiLinkedRecord.getDatabase().save(iLinkedRecord);\r\n\r\n\t\t\t\tiLinkedRecord.getDatabase().registerPojo(iLinkedRecord.getDatabase().getUserObjectByRecord(iLinkedRecord, null),\r\n\t\t\t\t\t\tiLinkedRecord);\r\n\r\n\t\t\t\tresultRid = iLinkedRecord;\r\n\t\t\t}\r\n\r\n\t\t\tif (iParentRecord.getDatabase() instanceof ODatabaseRecord) {\r\n\t\t\t\tfinal ODatabaseRecord db = iParentRecord.getDatabase();\r\n\t\t\t\tif (!db.isRetainRecords())\r\n\t\t\t\t\t// REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r\n\t\t\t\t\tresultRid = iLinkedRecord.getIdentity();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (rid.isValid()) {\r\n\t\t\tbuffer.append(OStringSerializerHelper.LINK);\r\n\t\t\tbuffer.append(rid.toString());\r\n\t\t}\r\n\r\n\t\treturn resultRid;\r\n\t}","id":81871,"modified_method":"/**\r\n\t * Serialize the link.\r\n\t * \r\n\t * @param buffer\r\n\t * @param iParentRecord\r\n\t * @param iFieldName\r\n\t *          TODO\r\n\t * @param iLinked\r\n\t *          Can be an instance of ORID or a Record<?>\r\n\t * @return\r\n\t */\r\n\tprivate Object linkToStream(final StringBuilder buffer, final ORecordSchemaAware<?> iParentRecord, Object iLinked) {\r\n\t\tif (iLinked == null)\r\n\t\t\t// NULL REFERENCE\r\n\t\t\treturn null;\r\n\r\n\t\tObject resultRid = null;\r\n\t\tORID rid;\r\n\r\n\t\tif (iLinked instanceof ORID) {\r\n\t\t\t// JUST THE REFERENCE\r\n\t\t\trid = (ORID) iLinked;\r\n\t\t} else {\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>)) {\r\n\t\t\t\t// NOT RECORD: TRY TO EXTRACT THE DOCUMENT IF ANY\r\n\t\t\t\tfinal String boundDocumentField = OObjectSerializerHelper.getDocumentBoundField(iLinked.getClass());\r\n\t\t\t\tif (boundDocumentField != null)\r\n\t\t\t\t\tiLinked = OObjectSerializerHelper.getFieldValue(iLinked, boundDocumentField);\r\n\t\t\t}\r\n\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>))\r\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid object received. Expected a record but received type=\"\r\n\t\t\t\t\t\t+ iLinked.getClass().getName() + \" and value=\" + iLinked);\r\n\r\n\t\t\t// RECORD\r\n\t\t\tORecordInternal<?> iLinkedRecord = (ORecordInternal<?>) iLinked;\r\n\t\t\trid = iLinkedRecord.getIdentity();\r\n\r\n\t\t\tif (rid.isNew() || iLinkedRecord.isDirty()) {\r\n\t\t\t\tif (iLinkedRecord.getDatabase() == null)\r\n\t\t\t\t\t// OVERWRITE THE DATABASE TO THE SAME OF THE PARENT ONE\r\n\t\t\t\t\tiLinkedRecord.setDatabase(iParentRecord.getDatabase());\r\n\r\n\t\t\t\tif (iLinkedRecord instanceof ODocument) {\r\n\t\t\t\t\tfinal OClass schemaClass = ((ODocument) iLinkedRecord).getSchemaClass();\r\n\t\t\t\t\tiLinkedRecord.getDatabase().save(iLinkedRecord,\r\n\t\t\t\t\t\t\tschemaClass != null ? iLinkedRecord.getDatabase().getClusterNameById(schemaClass.getDefaultClusterId()) : null);\r\n\t\t\t\t} else\r\n\t\t\t\t\t// STORE THE TRAVERSED OBJECT TO KNOW THE RECORD ID. CALL THIS VERSION TO AVOID CLEAR OF STACK IN THREAD-LOCAL\r\n\t\t\t\t\tiLinkedRecord.getDatabase().save(iLinkedRecord);\r\n\r\n\t\t\t\tiLinkedRecord.getDatabase().registerPojo(iLinkedRecord.getDatabase().getUserObjectByRecord(iLinkedRecord, null),\r\n\t\t\t\t\t\tiLinkedRecord);\r\n\r\n\t\t\t\tresultRid = iLinkedRecord;\r\n\t\t\t}\r\n\r\n\t\t\tif (iParentRecord.getDatabase() instanceof ODatabaseRecord) {\r\n\t\t\t\tfinal ODatabaseRecord db = iParentRecord.getDatabase();\r\n\t\t\t\tif (!db.isRetainRecords())\r\n\t\t\t\t\t// REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r\n\t\t\t\t\tresultRid = iLinkedRecord.getIdentity();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (rid.isValid()) {\r\n\t\t\tbuffer.append(OStringSerializerHelper.LINK);\r\n\t\t\trid.toString(buffer);\r\n\t\t}\r\n\r\n\t\treturn resultRid;\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static String fieldTypeToString(final ODatabaseComplex<?> iDatabase, OType iType, final Object iValue) {\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tif (iType == null)\r\n\t\t\tiType = OType.EMBEDDED;\r\n\r\n\t\tswitch (iType) {\r\n\t\tcase STRING:\r\n\t\t\treturn \"\\\"\" + OStringSerializerHelper.encode(iValue.toString()) + \"\\\"\";\r\n\r\n\t\tcase BOOLEAN:\r\n\t\tcase INTEGER:\r\n\t\t\treturn String.valueOf(iValue);\r\n\r\n\t\tcase FLOAT:\r\n\t\t\treturn String.valueOf(iValue) + 'f';\r\n\t\tcase LONG:\r\n\t\t\treturn String.valueOf(iValue) + 'l';\r\n\t\tcase DOUBLE:\r\n\t\t\treturn String.valueOf(iValue) + 'd';\r\n\t\tcase SHORT:\r\n\t\t\treturn String.valueOf(iValue) + 's';\r\n\r\n\t\tcase BYTE:\r\n\t\t\tif (iValue instanceof Character)\r\n\t\t\t\treturn String.valueOf((int) ((Character) iValue).charValue()) + 'b';\r\n\t\t\telse if (iValue instanceof String)\r\n\t\t\t\treturn String.valueOf((int) ((String) iValue).charAt(0)) + 'b';\r\n\t\t\telse\r\n\t\t\t\treturn String.valueOf(iValue) + 'b';\r\n\r\n\t\tcase BINARY:\r\n\t\t\tfinal String str;\r\n\t\t\tif (iValue instanceof Byte)\r\n\t\t\t\tstr = new String(new byte[] { ((Byte) iValue).byteValue() });\r\n\t\t\telse\r\n\t\t\t\tstr = OBase64Utils.encodeBytes((byte[]) iValue);\r\n\t\t\treturn \"\\\"\" + str + \"\\\"\";\r\n\r\n\t\tcase DATE:\r\n\t\t\tif (iValue instanceof Date)\r\n\t\t\t\treturn String.valueOf(((Date) iValue).getTime()) + 't';\r\n\t\t\telse\r\n\t\t\t\treturn String.valueOf(iValue) + 't';\r\n\r\n\t\tcase LINK:\r\n\t\t\tif (iValue instanceof ORID)\r\n\t\t\t\treturn '#' + iValue.toString();\r\n\t\t\telse\r\n\t\t\t\treturn '#' + ((ORecord<?>) iValue).getIdentity().toString();\r\n\r\n\t\tcase EMBEDDEDMAP:\r\n\t\t\treturn ORecordSerializerSchemaAware2CSV.INSTANCE.embeddedMapToStream(iDatabase, null, null, null, iValue, null, true);\r\n\r\n\t\tcase EMBEDDED:\r\n\t\t\t// RECORD\r\n\t\t\treturn OStringSerializerAnyStreamable.INSTANCE.toStream(iDatabase, iValue);\r\n\t\t}\r\n\r\n\t\tthrow new IllegalArgumentException(\"Type \" + iType + \" not supported to convert value: \" + iValue);\r\n\t}","id":81872,"modified_method":"public static void fieldTypeToString(final StringBuilder iBuffer, final ODatabaseComplex<?> iDatabase, OType iType,\r\n\t\t\tfinal Object iValue) {\r\n\t\tif (iValue == null)\r\n\t\t\treturn;\r\n\r\n\t\tif (iType == null)\r\n\t\t\tiType = OType.EMBEDDED;\r\n\r\n\t\tswitch (iType) {\r\n\t\tcase STRING:\r\n\t\t\tiBuffer.append('\"');\r\n\t\t\tiBuffer.append(OStringSerializerHelper.encode(iValue.toString()));\r\n\t\t\tiBuffer.append('\"');\r\n\t\t\tbreak;\r\n\r\n\t\tcase BOOLEAN:\r\n\t\tcase INTEGER:\r\n\t\t\tiBuffer.append(String.valueOf(iValue));\r\n\t\t\tbreak;\r\n\r\n\t\tcase FLOAT:\r\n\t\t\tiBuffer.append(String.valueOf(iValue));\r\n\t\t\tiBuffer.append('f');\r\n\t\t\tbreak;\r\n\t\tcase LONG:\r\n\t\t\tiBuffer.append(String.valueOf(iValue));\r\n\t\t\tiBuffer.append('l');\r\n\t\t\tbreak;\r\n\t\tcase DOUBLE:\r\n\t\t\tiBuffer.append(String.valueOf(iValue));\r\n\t\t\tiBuffer.append('d');\r\n\t\t\tbreak;\r\n\t\tcase SHORT:\r\n\t\t\tiBuffer.append(String.valueOf(iValue));\r\n\t\t\tiBuffer.append('s');\r\n\t\t\tbreak;\r\n\r\n\t\tcase BYTE:\r\n\t\t\tif (iValue instanceof Character)\r\n\t\t\t\tiBuffer.append((int) ((Character) iValue).charValue());\r\n\t\t\telse if (iValue instanceof String)\r\n\t\t\t\tiBuffer.append(String.valueOf((int) ((String) iValue).charAt(0)));\r\n\t\t\telse\r\n\t\t\t\tiBuffer.append(String.valueOf(iValue));\r\n\t\t\tiBuffer.append('b');\r\n\t\t\tbreak;\r\n\r\n\t\tcase BINARY:\r\n\t\t\tiBuffer.append('\"');\r\n\t\t\tif (iValue instanceof Byte)\r\n\t\t\t\tiBuffer.append(new String(new byte[] { ((Byte) iValue).byteValue() }));\r\n\t\t\telse\r\n\t\t\t\tiBuffer.append(OBase64Utils.encodeBytes((byte[]) iValue));\r\n\t\t\tiBuffer.append('\"');\r\n\t\t\tbreak;\r\n\r\n\t\tcase DATE:\r\n\t\t\tif (iValue instanceof Date)\r\n\t\t\t\tiBuffer.append(((Date) iValue).getTime());\r\n\t\t\telse\r\n\t\t\t\tiBuffer.append(iValue);\r\n\t\t\tiBuffer.append('t');\r\n\t\t\tbreak;\r\n\r\n\t\tcase LINK:\r\n\t\t\tiBuffer.append('#');\r\n\t\t\tif (iValue instanceof ORecordId)\r\n\t\t\t\t((ORecordId) iValue).toString(iBuffer);\r\n\t\t\telse\r\n\t\t\t\t((ORecord<?>) iValue).getIdentity().toString(iBuffer);\r\n\t\t\tbreak;\r\n\r\n\t\tcase EMBEDDEDMAP:\r\n\t\t\tiBuffer\r\n\t\t\t\t\t.append(ORecordSerializerSchemaAware2CSV.INSTANCE.embeddedMapToStream(iDatabase, null, null, null, iValue, null, true));\r\n\t\t\tbreak;\r\n\r\n\t\tcase EMBEDDED:\r\n\t\t\t// RECORD\r\n\t\t\tiBuffer.append(OStringSerializerAnyStreamable.INSTANCE.toStream(iDatabase, iValue));\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new IllegalArgumentException(\"Type \" + iType + \" not supported to convert value: \" + iValue);\r\n\t\t}\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public byte[] toStream(final ODatabaseRecord iDatabase, final Object iObject) throws IOException {\r\n\t\tif (iObject == null)\r\n\t\t\treturn null;\r\n\r\n\t\treturn OBinaryProtocol.string2bytes(ORecordSerializerStringAbstract.fieldTypeToString(iDatabase,\r\n\t\t\t\tOType.getTypeByClass(iObject.getClass()), iObject));\r\n\t}","id":81873,"modified_method":"public byte[] toStream(final ODatabaseRecord iDatabase, final Object iObject) throws IOException {\r\n\t\tif (iObject == null)\r\n\t\t\treturn null;\r\n\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\t\tORecordSerializerStringAbstract.fieldTypeToString(buffer, iDatabase, OType.getTypeByClass(iObject.getClass()), iObject);\r\n\t\treturn OBinaryProtocol.string2bytes(buffer.toString());\r\n\t}","commit_id":"0b29af8a9e1a43c3ddf9f19b216867376c902522","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    protected void disconnectSensors() {\n        disconnectServiceUpIsRunning();\n        jmxFeed.stop();\n        httpFeed.stop();\n        super.disconnectSensors();\n    }","id":81874,"modified_method":"@Override\n    protected void disconnectSensors() {\n        disconnectServiceUpIsRunning();\n        if (jmxFeed != null) jmxFeed.stop();\n        if (httpFeed != null) httpFeed.stop();\n        super.disconnectSensors();\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected void connectSensors() {\n        super.connectSensors();\n        connectServiceUpIsRunning();\n        jmxFeed = getJmxFeed();\n        String uri = \"http://\" + getAttribute(HOSTNAME) + \":\" + CRATE_PORT;\n        setAttribute(MANAGEMENT_URI, uri);\n\n        httpFeed = HttpFeed.builder()\n                .entity(this)\n                .baseUri(uri)\n                .poll(new HttpPollConfig<String>(CrateNode.SERVER_NAME)\n                        .onSuccess(HttpValueFunctions.jsonContents(\"name\", String.class)))\n                .poll(new HttpPollConfig<Integer>(CrateNode.SERVER_STATUS)\n                        .onSuccess(HttpValueFunctions.jsonContents(\"status\", Integer.class)))\n                .poll(new HttpPollConfig<String>(CrateNode.SERVER_BUILD_TIMESTAMP)\n                        .onSuccess(HttpValueFunctions.jsonContents(new String[] {\"version\", \"build_timestamp\"}, String.class)))\n                .build();\n    }","id":81875,"modified_method":"@Override\n    protected void connectSensors() {\n        super.connectSensors();\n        connectServiceUpIsRunning();\n        jmxFeed = JavaAppUtils.connectMXBeanSensors(this);\n        setAttribute(DATASTORE_URL, \"crate://\" + getAttribute(HOSTNAME) + \":\" + getPort());\n        String url = \"http://\" + getAttribute(HOSTNAME) + \":\" + getHttpPort();\n        setAttribute(MANAGEMENT_URL, url);\n\n        httpFeed = HttpFeed.builder()\n                .entity(this)\n                .baseUri(url)\n                .poll(new HttpPollConfig<String>(SERVER_NAME)\n                        .onSuccess(HttpValueFunctions.jsonContents(\"name\", String.class)))\n                .poll(new HttpPollConfig<Integer>(SERVER_STATUS)\n                        .onSuccess(HttpValueFunctions.jsonContents(\"status\", Integer.class)))\n                .poll(new HttpPollConfig<Boolean>(SERVER_OK)\n                        .onSuccess(HttpValueFunctions.jsonContents(\"ok\", Boolean.class)))\n                .poll(new HttpPollConfig<String>(SERVER_BUILD_TIMESTAMP)\n                        .onSuccess(HttpValueFunctions.jsonContents(new String[]{\"version\", \"build_timestamp\"}, String.class)))\n                .poll(new HttpPollConfig<String>(SERVER_BUILD_HASH)\n                        .onSuccess(HttpValueFunctions.jsonContents(new String[]{\"version\", \"build_hash\"}, String.class)))\n                .poll(new HttpPollConfig<Boolean>(SERVER_IS_BUILD_SNAPSHOT)\n                        .onSuccess(HttpValueFunctions.jsonContents(new String[] {\"version\", \"build_snapshot\"}, Boolean.class)))\n                .poll(new HttpPollConfig<String>(SERVER_LUCENE_VERSION)\n                        .onSuccess(HttpValueFunctions.jsonContents(new String[] {\"version\", \"lucene_version\"}, String.class)))\n                .poll(new HttpPollConfig<String>(SERVER_ES_VERSION)\n                        .onSuccess(HttpValueFunctions.jsonContents(new String[] {\"version\", \"es_version\"}, String.class)))\n                .build();\n\n        addEnricher(Enrichers.builder().updatingMap(Attributes.SERVICE_NOT_UP_INDICATORS)\n                .from(SERVER_OK)\n                .computing(Functionals.ifNotEquals(true).value(\"Crate server reports it is not ok.\"))\n                .build());\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected String getPidFileLocation () {\n        return getRunDir() + \"/pid.txt\";\n    }","id":81876,"modified_method":"protected String getPidFileLocation () {\n        return Urls.mergePaths(getRunDir(), \"pid.txt\");\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n        StringBuilder command = new StringBuilder(getExpandedInstallDir())\n                .append(\"/bin/crate >\").append(getLogFileLocation())\n                .append(\" 2> err.log < /dev/null\")\n                .append(\" -d\")\n                .append(\" -p \").append(getPidFileLocation());\n        newScript(LAUNCHING)\n                .failOnNonZeroResultCode()\n                .body.append(command).execute();\n\n    }","id":81877,"modified_method":"@Override\n    public void launch() {\n        StringBuilder command = new StringBuilder(getExpandedInstallDir())\n                .append(\"/bin/crate \")\n                .append(\" -d\")\n                .append(\" -p \").append(getPidFileLocation())\n                .append(\" -Des.config=\").append(getConfigFileLocation());\n        newScript(LAUNCHING)\n                .failOnNonZeroResultCode()\n                .body.append(command).execute();\n\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected String getLogFileLocation() {\n        return getRunDir() + \"/server.log\";\n    }","id":81878,"modified_method":"@Override\n    public String getLogFileLocation() {\n        return Urls.mergePaths(getRunDir(), \"crate.log\");\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void stop() {\n        newScript (MutableMap.of(\"usePidFile\", getPidFileLocation()), STOPPING)\n                .execute();\n\n    }","id":81879,"modified_method":"@Override\n    public void stop() {\n        // See https://crate.io/docs/stable/cli.html#signal-handling.\n        newScript(STOPPING)\n                .body.append(\"kill -USR2 `cat \" + getPidFileLocation() + \"`\")\n                .execute();\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void customize() {\n\n    }","id":81880,"modified_method":"@Override\n    public void customize() {\n        newScript(CUSTOMIZING)\n                .body.append(\"mkdir -p \" + getDataLocation())\n                .execute();\n        copyTemplate(entity.getConfig(CrateNode.SERVER_CONFIG_URL), getConfigFileLocation());\n    }","commit_id":"743fd2d008d474157a0685357a8805d64b70be78","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  public void write(final int value) {\n    final int s = (int) size;\n    if(s == max) return;\n    if(s == buffer.length) buffer = Arrays.copyOf(buffer, Array.newSize(s));\n    buffer[s] = (byte) value;\n    size = s + 1;\n  }","id":81881,"modified_method":"@Override\n  public void write(final int value) {\n    final int s = (int) size;\n    if(s == max) return;\n\n    byte[] bffr = buffer;\n    if(s == bffr.length) bffr = Arrays.copyOf(bffr, Array.newSize(s));\n    bffr[s] = (byte) value;\n    buffer = bffr;\n    size = s + 1;\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Sets a status and sends an info message.\n   * @param code status code\n   * @param message info message\n   * @param error treat as error (use web server standard output)\n   * @throws IOException I/O exception\n   */\n  public void status(final int code, final String message, final boolean error) throws IOException {\n    try {\n      log(message, code);\n      res.resetBuffer();\n      if(code == SC_UNAUTHORIZED) res.setHeader(WWW_AUTHENTICATE, BASIC);\n\n      if(error && code >= SC_BAD_REQUEST) {\n        res.sendError(code, message);\n      } else {\n        res.setStatus(code);\n        if(message != null) res.getOutputStream().write(token(message));\n      }\n    } catch(final IllegalStateException ex) {\n      log(Util.message(ex), SC_INTERNAL_SERVER_ERROR);\n    }\n  }","id":81882,"modified_method":"/**\n   * Sets a status and sends an info message.\n   * @param code status code\n   * @param message info message\n   * @param error treat as error (use web server standard output)\n   * @throws IOException I/O exception\n   */\n  public void status(final int code, final String message, final boolean error) throws IOException {\n    try {\n      log(message, code);\n      res.resetBuffer();\n      if(code == SC_UNAUTHORIZED) res.setHeader(WWW_AUTHENTICATE, BASIC);\n\n      if(error && code >= SC_BAD_REQUEST) {\n        res.sendError(code, message);\n      } else {\n        res.setStatus(code);\n        if(message != null) {\n          res.setContentType(TEXT_PLAIN);\n          final ArrayOutput ao = new ArrayOutput();\n          ao.write(token(message));\n          res.getOutputStream().write(ao.normalize().finish());\n        }\n      }\n    } catch(final IllegalStateException ex) {\n      log(Util.message(ex), SC_INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses the HTTP payload and returns a result body element.\n   * @param error error flag\n   * @param ctype content type defined in the connection\n   * @param utype content type specified by the user\n   * @return body element\n   * @throws IOException I/O exception\n   * @throws QueryException query exception\n   */\n  public FElem parse(final boolean error, final String ctype, final String utype)\n      throws IOException, QueryException {\n\n    // error: use text/plain as content type\n    final String ct = error ? TEXT_PLAIN : utype != null ? utype : contentType(ctype);\n\n    final FElem body;\n    if(isMultipart(ct)) {\n      // multipart response\n      final byte[] boundary = boundary(ctype);\n      if(boundary == null) throw HC_REQ_X.get(info, \"No separation boundary specified\");\n\n      body = new FElem(Q_MULTIPART).add(MEDIA_TYPE, ct).add(BOUNDARY, boundary);\n      final ANodeList parts = new ANodeList();\n      extractParts(concat(DASHES, boundary), parts);\n      for(final ANode node : parts) body.add(node);\n    } else {\n      // single part response\n      body = new FElem(Q_BODY).add(MEDIA_TYPE, ct);\n      if(payloads != null) {\n        final byte[] pl = extract(ct, charset(ctype));\n        payloads.add(parse(pl, ct));\n      }\n    }\n    return body;\n  }","id":81883,"modified_method":"/**\n   * Parses the HTTP payload and returns a result body element.\n   * @param error error flag\n   * @param ctype content type defined in the connection\n   * @param utype content type specified by the user\n   * @return body element\n   * @throws IOException I/O exception\n   * @throws QueryException query exception\n   */\n  public FElem parse(final boolean error, final String ctype, final String utype)\n      throws IOException, QueryException {\n\n    // error: use text/plain as content type\n    final String ct = utype == null || error ? contentType(ctype) : utype;\n\n    final FElem body;\n    if(isMultipart(ct)) {\n      // multipart response\n      final byte[] boundary = boundary(ctype);\n      if(boundary == null) throw HC_REQ_X.get(info, \"No separation boundary specified\");\n\n      body = new FElem(Q_MULTIPART).add(MEDIA_TYPE, ct).add(BOUNDARY, boundary);\n      final ANodeList parts = new ANodeList();\n      extractParts(concat(DASHES, boundary), parts);\n      for(final ANode node : parts) body.add(node);\n    } else {\n      // single part response\n      body = new FElem(Q_BODY).add(MEDIA_TYPE, ct);\n      if(payloads != null) {\n        final byte[] pl = extract(ct, charset(ctype));\n        payloads.add(parse(pl, ct));\n      }\n    }\n    return body;\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Item item(final QueryContext qc, final InputInfo ii) throws QueryException {\n    final Result result = exec(qc);\n\n    final FElem root = new FElem(RESULT);\n    root.add(new FElem(OUTPUT).add(norm(result.output)));\n    root.add(new FElem(ERROR).add(norm(result.error)));\n    root.add(new FElem(CODE).add(token(result.code)));\n    return root;\n  }","id":81884,"modified_method":"@Override\n  public Item item(final QueryContext qc, final InputInfo ii) throws QueryException {\n    final Result result = exec(qc);\n\n    final FElem root = new FElem(RESULT);\n    root.add(new FElem(OUTPUT).add(result.output.normalize().finish()));\n    root.add(new FElem(ERROR).add(result.error.normalize().finish()));\n    root.add(new FElem(CODE).add(token(result.code)));\n    return root;\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the result of a command.\n   * @param qc query context\n   * @return result\n   * @throws QueryException query exception\n   */\n  final Result exec(final QueryContext qc) throws QueryException {\n    checkCreate(qc);\n\n    // arguments\n    final TokenList tl = new TokenList();\n    tl.add(toToken(exprs[0], qc));\n    if(exprs.length > 1) {\n      final Iter ir = qc.iter(exprs[1]);\n      for(Item it; (it = ir.next()) != null;) tl.add(toToken(it));\n    }\n    final String[] args = tl.toStringArray();\n\n    // encoding\n    final String c = exprs.length > 2 ? string(toToken(exprs[2], qc)) : Prop.ENCODING;\n    final Charset cs;\n    try {\n      cs = Charset.forName(c);\n    } catch(final Exception ex) {\n      throw BXPR_ENC_X.get(info, c);\n    }\n\n    final Result result = new Result();\n    final Process proc;\n    try {\n      proc = new ProcessBuilder(args).start();\n    } catch(final IOException ex) {\n      result.error.add(Util.message(ex));\n      result.code = 9999;\n      return result;\n    }\n\n    try {\n      final Thread outt = reader(proc.getInputStream(), result.output, cs);\n      final Thread errt = reader(proc.getErrorStream(), result.error, cs);\n      outt.start();\n      errt.start();\n      proc.waitFor();\n      outt.join();\n      errt.join();\n    } catch(final InterruptedException ex) {\n      result.error.add(Util.message(ex));\n    }\n    result.code = proc.exitValue();\n    return result;\n  }","id":81885,"modified_method":"/**\n   * Returns the result of a command.\n   * @param qc query context\n   * @return result\n   * @throws QueryException query exception\n   */\n  final Result exec(final QueryContext qc) throws QueryException {\n    checkCreate(qc);\n\n    // arguments\n    final TokenList tl = new TokenList();\n    tl.add(toToken(exprs[0], qc));\n    if(exprs.length > 1) {\n      final Iter ir = qc.iter(exprs[1]);\n      for(Item it; (it = ir.next()) != null;) tl.add(toToken(it));\n    }\n    final String[] args = tl.toStringArray();\n\n    // encoding\n    final String c = exprs.length > 2 ? string(toToken(exprs[2], qc)) : Prop.ENCODING;\n    final Charset cs;\n    try {\n      cs = Charset.forName(c);\n    } catch(final Exception ex) {\n      throw BXPR_ENC_X.get(info, c);\n    }\n\n    final Result result = new Result();\n    final Process proc;\n    try {\n      proc = new ProcessBuilder(args).start();\n    } catch(final IOException ex) {\n      try {\n        result.error.write(token(Util.message(ex)));\n      } catch(final IOException ignored) { }\n      result.code = 9999;\n      return result;\n    }\n\n    try {\n      final Thread outt = reader(proc.getInputStream(), result.output, cs);\n      final Thread errt = reader(proc.getErrorStream(), result.error, cs);\n      outt.start();\n      errt.start();\n      proc.waitFor();\n      outt.join();\n      errt.join();\n    } catch(final InterruptedException ex) {\n      try {\n        result.error.write(token(Util.message(ex)));\n      } catch(final IOException ignored) { }\n    }\n    result.code = proc.exitValue();\n    return result;\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a reader thread.\n   * @param in input stream\n   * @param tb cache\n   * @param cs charset\n   * @return result\n   */\n  private static Thread reader(final InputStream in, final TokenBuilder tb, final Charset cs) {\n    final InputStreamReader isr = new InputStreamReader(in, cs);\n    final BufferedReader br = new BufferedReader(isr);\n    return new Thread() {\n      @Override\n      public void run() {\n        try {\n          for(int b; (b = br.read()) != -1;) tb.add(b);\n        } catch(final IOException ex) {\n          Util.stack(ex);\n        }\n      }\n    };\n  }","id":81886,"modified_method":"/**\n   * Creates a reader thread.\n   * @param in input stream\n   * @param ao cache\n   * @param cs charset\n   * @return result\n   */\n  private static Thread reader(final InputStream in, final ArrayOutput ao, final Charset cs) {\n    final InputStreamReader isr = new InputStreamReader(in, cs);\n    final BufferedReader br = new BufferedReader(isr);\n    return new Thread() {\n      @Override\n      public void run() {\n        try {\n          for(int b; (b = br.read()) != -1;) ao.write(b);\n        } catch(final IOException ex) {\n          Util.stack(ex);\n        }\n      }\n    };\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Item item(final QueryContext qc, final InputInfo ii) throws QueryException {\n    final Result result = exec(qc);\n    if(result.code == 0) return Str.get(norm(result.output));\n\n    // create error message\n    final QNm name = new QNm(ErrType.BXPR + String.format(\"%04d\", result.code));\n    throw new QueryException(info, name, string(norm(result.error)));\n  }","id":81887,"modified_method":"@Override\n  public Item item(final QueryContext qc, final InputInfo ii) throws QueryException {\n    final Result result = exec(qc);\n    if(result.code == 0) {\n      return Str.get(result.output.normalize().finish());\n    }\n\n    // create error message\n    final QNm name = new QNm(ErrType.BXPR + String.format(\"%04d\", result.code));\n    result.error.normalize();\n    throw new QueryException(info, name, string(result.error.normalize().finish()));\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Serialization parameters and elements.\n   * @throws Exception exception\n   */\n  @Test\n  public void output() throws Exception {\n    // correct syntax\n    get(\"declare %R:path('') %output:method('text') function m:f() {'9'};\", \"\", \"9\");\n    // unknown serialization parameter\n    getE(\"declare %R:path('') %output:xyz('abc') function m:f() {'9'};\", \"\");\n    // parameter must contain single string\n    getE(\"declare %R:path('') %output:method function m:f() {'9'};\", \"\");\n    getE(\"declare %R:path('') %output:method('xml','html') function m:f() {'9'};\", \"\");\n\n    get(\"declare %R:path('') function m:f() { <R:response>\" +\n        \"  <output:serialization-parameters>\" +\n        \"    <output:method value='text'/>\" +\n        \"  <\/output:serialization-parameters>\" +\n        \"  <http:response status='200'/>\" +\n        \"<\/R:response>,\" +\n        \"<X>1<\/X> };\", \"\", \"1\");\n    get(\"declare %R:path('') %output:method('text') function m:f() {\" +\n        \"<R:response>\" +\n        \"  <output:serialization-parameters>\" +\n        \"    <output:method value='xml'/>\" +\n        \"  <\/output:serialization-parameters>\" +\n        \"  <http:response status='200'/>\" +\n        \"<\/R:response>,\" +\n        \"<X>1<\/X> };\", \"\", \"<X>1<\/X>\");\n  }","id":81888,"modified_method":"/**\n   * Serialization parameters and elements.\n   * @throws Exception exception\n   */\n  @Test\n  public void output() throws Exception {\n    // correct syntax\n    get(\"declare %R:path('') %output:method('text') function m:f() {'9'};\", \"\", \"9\");\n    // unknown serialization parameter\n    getE(\"declare %R:path('') %output:xyz('abc') function m:f() {'9'};\", \"\");\n    // parameter must contain single string\n    getE(\"declare %R:path('') %output:method function m:f() {'9'};\", \"\");\n    getE(\"declare %R:path('') %output:method('xml','html') function m:f() {'9'};\", \"\");\n\n    get(\"declare %R:path('') function m:f() { <R:response>\" +\n        \"  <output:serialization-parameters>\" +\n        \"    <output:method value='text'/>\" +\n        \"  <\/output:serialization-parameters>\" +\n        \"  <http:response status='200'/>\" +\n        \"<\/R:response>,\" +\n        \"<X>1<\/X> };\", \"\", \"1\");\n    get(\"declare %R:path('') %output:method('text') function m:f() {\" +\n        \"<R:response>\" +\n        \"  <output:serialization-parameters>\" +\n        \"    <output:method value='xml'/>\" +\n        \"  <\/output:serialization-parameters>\" +\n        \"  <http:response status='200'/>\" +\n        \"<\/R:response>,\" +\n        \"<X>1<\/X> };\", \"\", \"<X>1<\/X>\");\n    getE(\"declare %R:path('') %output:method('text') function m:f() {\" +\n        \"<R:response>\" +\n        \"  <output:serialization-parameters>\" +\n        \"    <output:method value='xml'/>\" +\n        \"  <\/output:serialization-parameters>\" +\n        \"  <http:response status='200'/>\" +\n        \"<\/R:response>,\" +\n        \"1+<a/> };\", \"\");\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Serializes the data from the specified iterator.\n   * @param ir data to serialize\n   * @param opts serialization parameters\n   * @param err error code\n   * @return result\n   * @throws QueryException query exception\n   */\n  protected byte[] serialize(final Iter ir, final SerializerOptions opts, final QueryError err)\n      throws QueryException {\n\n    try {\n      final ArrayOutput ao = new ArrayOutput();\n      final Serializer ser = Serializer.get(ao, opts);\n      for(Item it; (it = ir.next()) != null;) ser.serialize(it);\n      ser.close();\n      return delete(ao.finish(), '\\r');\n    } catch(final QueryIOException ex) {\n      throw ex.getCause(info);\n    } catch(final IOException ex) {\n      throw err.get(info, ex);\n    }\n  }","id":81889,"modified_method":"/**\n   * Serializes the data from the specified iterator.\n   * @param ir data to serialize\n   * @param opts serialization parameters\n   * @param err error code\n   * @return result\n   * @throws QueryException query exception\n   */\n  protected byte[] serialize(final Iter ir, final SerializerOptions opts, final QueryError err)\n      throws QueryException {\n\n    try {\n      final ArrayOutput ao = new ArrayOutput();\n      final Serializer ser = Serializer.get(ao, opts);\n      for(Item it; (it = ir.next()) != null;) ser.serialize(it);\n      ser.close();\n      return ao.normalize().finish();\n    } catch(final QueryIOException ex) {\n      throw ex.getCause(info);\n    } catch(final IOException ex) {\n      throw err.get(info, ex);\n    }\n  }","commit_id":"c296d126829d85660b9175ca42d10745788a906f","url":"https://github.com/BaseXdb/basex"},{"original_method":"static void buildContainer(SNode sampleNode, final SNode newNode) {\n    ListSequence.fromList(SLinkOperations.getTargets(IContainsStatementList_Behavior.call_getStatementList_1237545932619(sampleNode), \"statement\", true)).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        ListSequence.fromList(SLinkOperations.getTargets(IContainsStatementList_Behavior.call_getStatementList_1237545932619(newNode), \"statement\", true)).addElement(SNodeOperations.copyNode(it));\n      }\n    });\n\n    if (hasCondition(sampleNode) && hasCondition(newNode)) {\n      SNode originalCondition = AlterStatementListContainerFactoryUtils.getCondition(sampleNode);\n      if (originalCondition != null) {\n        if (SNodeOperations.isInstanceOf(newNode, \"jetbrains.mps.baseLanguage.structure.IfStatement\")) {\n          SLinkOperations.setTarget(SNodeOperations.cast(newNode, \"jetbrains.mps.baseLanguage.structure.IfStatement\"), \"condition\", SNodeOperations.copyNode(originalCondition), true);\n        } else if (SNodeOperations.isInstanceOf(newNode, \"jetbrains.mps.baseLanguage.structure.WhileStatement\")) {\n          SLinkOperations.setTarget(SNodeOperations.cast(newNode, \"jetbrains.mps.baseLanguage.structure.WhileStatement\"), \"condition\", SNodeOperations.copyNode(originalCondition), true);\n\n        } else if (SNodeOperations.isInstanceOf(newNode, \"jetbrains.mps.baseLanguage.structure.DoWhileStatement\")) {\n          SLinkOperations.setTarget(SNodeOperations.cast(newNode, \"jetbrains.mps.baseLanguage.structure.DoWhileStatement\"), \"condition\", SNodeOperations.copyNode(originalCondition), true);\n        }\n      }\n    }\n  }","id":81890,"modified_method":"static void buildContainer(SNode sampleNode, final SNode newNode) {\n    ListSequence.fromList(SLinkOperations.getTargets(IContainsStatementList_Behavior.call_getStatementList_1237545932619(sampleNode), \"statement\", true)).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        ListSequence.fromList(SLinkOperations.getTargets(IContainsStatementList_Behavior.call_getStatementList_1237545932619(newNode), \"statement\", true)).addElement(SNodeOperations.copyNode(it));\n      }\n    });\n    if (hasCondition(sampleNode) && hasCondition(newNode)) {\n      SNode originalCondition = getCondition(sampleNode);\n      if (originalCondition != null) {\n        SNodeOperations.replaceWithAnother(getCondition(newNode), SNodeOperations.copyNode(originalCondition));\n      }\n    }\n  }","commit_id":"153cc9c82a43c2f15eb2b2833b10825a921dc0e8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void buildContainerIfPossible(SNode sampleNode, SNode newNode) {\n    if (SNodeOperations.isInstanceOf(sampleNode, \"jetbrains.mps.baseLanguage.structure.IContainsStatementList\")) {\n      AlterStatementListContainerFactoryUtils.buildContainer(SNodeOperations.cast(sampleNode, \"jetbrains.mps.baseLanguage.structure.IContainsStatementList\"), newNode);\n    }\n  }","id":81891,"modified_method":"public static void buildContainerIfPossible(SNode sampleNode, SNode newNode) {\n    if (SNodeOperations.isInstanceOf(sampleNode, \"jetbrains.mps.baseLanguage.structure.IContainsStatementList\")) {\n      buildContainer(SNodeOperations.cast(sampleNode, \"jetbrains.mps.baseLanguage.structure.IContainsStatementList\"), newNode);\n    }\n  }","commit_id":"153cc9c82a43c2f15eb2b2833b10825a921dc0e8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      final SNode newInitializedInstance = SNodeFactoryOperations.createNewNode(NameUtil.nodeFQName(SNodeOperations.castConcept(myParameter, \"jetbrains.mps.baseLanguage.structure.IContainsStatementList\")), null);\n      ListSequence.fromList(SLinkOperations.getTargets(IContainsStatementList_Behavior.call_getStatementList_1237545932619(node), \"statement\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          ListSequence.fromList(SLinkOperations.getTargets(IContainsStatementList_Behavior.call_getStatementList_1237545932619(newInitializedInstance), \"statement\", true)).addElement(SNodeOperations.copyNode(it));\n        }\n      });\n\n      SNodeOperations.replaceWithAnother(node, newInitializedInstance);\n\n      if (IntentionUtils.hasCondition(node) && IntentionUtils.hasCondition(newInitializedInstance)) {\n        SNode originalCondition = IntentionUtils.getCondition(node);\n        if (originalCondition != null) {\n          SNodeOperations.replaceWithAnother(IntentionUtils.getCondition(newInitializedInstance), SNodeOperations.copyNode(originalCondition));\n        }\n      }\n\n      editorContext.selectWRTFocusPolicy(newInitializedInstance);\n    }","id":81892,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      SNode newInitializedInstance = SNodeFactoryOperations.createNewNode(NameUtil.nodeFQName(SNodeOperations.castConcept(myParameter, \"jetbrains.mps.baseLanguage.structure.IContainsStatementList\")), null);\n      AlterStatementListContainerFactoryUtils.buildContainerIfPossible(node, newInitializedInstance);\n      SNodeOperations.replaceWithAnother(node, newInitializedInstance);\n      editorContext.selectWRTFocusPolicy(newInitializedInstance);\n    }","commit_id":"153cc9c82a43c2f15eb2b2833b10825a921dc0e8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private FileStatus getFileStatus(final FileSystem fs, final Path path) {\n      try {\n        if (HFileLink.isHFileLink(path)) {\n          HFileLink link = new HFileLink(inputRoot, inputArchive, path);\n          return link.getFileStatus(fs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).getFileStatus(fs);\n        }\n        return fs.getFileStatus(path);\n      } catch (IOException e) {\n        LOG.warn(\"Unable to get the status for file=\" + path);\n        return null;\n      }\n    }","id":81893,"modified_method":"private FileStatus getFileStatus(final FileSystem fs, final Path path) {\n      try {\n        if (HFileLink.isHFileLink(path) || StoreFileInfo.isReference(path)) {\n          HFileLink link = new HFileLink(inputRoot, inputArchive, path);\n          return link.getFileStatus(fs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).getFileStatus(fs);\n        }\n        return fs.getFileStatus(path);\n      } catch (IOException e) {\n        LOG.warn(\"Unable to get the status for file=\" + path);\n        return null;\n      }\n    }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Returns the location where the inputPath will be copied.\n     *  - hfiles are encoded as hfile links hfile-region-table\n     *  - logs are encoded as serverName/logName\n     */\n    private Path getOutputPath(final Path inputPath) throws IOException {\n      Path path;\n      if (HFileLink.isHFileLink(inputPath)) {\n        String family = inputPath.getParent().getName();\n        String table = HFileLink.getReferencedTableName(inputPath.getName());\n        String region = HFileLink.getReferencedRegionName(inputPath.getName());\n        String hfile = HFileLink.getReferencedHFileName(inputPath.getName());\n        path = new Path(table, new Path(region, new Path(family, hfile)));\n      } else if (isHLogLinkPath(inputPath)) {\n        String logName = inputPath.getName();\n        path = new Path(new Path(outputRoot, HConstants.HREGION_OLDLOGDIR_NAME), logName);\n      } else {\n        path = inputPath;\n      }\n      return new Path(outputArchive, path);\n    }","id":81894,"modified_method":"/**\n     * Returns the location where the inputPath will be copied.\n     *  - hfiles are encoded as hfile links hfile-region-table\n     *  - logs are encoded as serverName/logName\n     */\n    private Path getOutputPath(final Path inputPath) throws IOException {\n      Path path;\n      if (HFileLink.isHFileLink(inputPath) || StoreFileInfo.isReference(inputPath)) {\n        String family = inputPath.getParent().getName();\n        String table = HFileLink.getReferencedTableName(inputPath.getName());\n        String region = HFileLink.getReferencedRegionName(inputPath.getName());\n        String hfile = HFileLink.getReferencedHFileName(inputPath.getName());\n        path = new Path(table, new Path(region, new Path(family, hfile)));\n      } else if (isHLogLinkPath(inputPath)) {\n        String logName = inputPath.getName();\n        path = new Path(new Path(outputRoot, HConstants.HREGION_OLDLOGDIR_NAME), logName);\n      } else {\n        path = inputPath;\n      }\n      return new Path(outputArchive, path);\n    }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"private FSDataInputStream openSourceFile(final Path path) {\n      try {\n        if (HFileLink.isHFileLink(path)) {\n          return new HFileLink(inputRoot, inputArchive, path).open(inputFs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).open(inputFs);\n        }\n        return inputFs.open(path);\n      } catch (IOException e) {\n        LOG.error(\"Unable to open source file=\" + path, e);\n        return null;\n      }\n    }","id":81895,"modified_method":"private FSDataInputStream openSourceFile(final Path path) {\n      try {\n        if (HFileLink.isHFileLink(path) || StoreFileInfo.isReference(path)) {\n          return new HFileLink(inputRoot, inputArchive, path).open(inputFs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).open(inputFs);\n        }\n        return inputFs.open(path);\n      } catch (IOException e) {\n        LOG.error(\"Unable to open source file=\" + path, e);\n        return null;\n      }\n    }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"private boolean copyFile(final Context context, final Path inputPath, final Path outputPath)\n        throws IOException {\n      FSDataInputStream in = openSourceFile(inputPath);\n      if (in == null) {\n        context.getCounter(Counter.MISSING_FILES).increment(1);\n        return false;\n      }\n\n      try {\n        // Verify if the input file exists\n        FileStatus inputStat = getFileStatus(inputFs, inputPath);\n        if (inputStat == null) return false;\n\n        // Verify if the output file exists and is the same that we want to copy\n        FileStatus outputStat = getFileStatus(outputFs, outputPath);\n        if (outputStat != null && sameFile(inputStat, outputStat)) {\n          LOG.info(\"Skip copy \" + inputPath + \" to \" + outputPath + \", same file.\");\n          return true;\n        }\n\n        context.getCounter(Counter.BYTES_EXPECTED).increment(inputStat.getLen());\n\n        // Ensure that the output folder is there and copy the file\n        outputFs.mkdirs(outputPath.getParent());\n        FSDataOutputStream out = outputFs.create(outputPath, true);\n        try {\n          if (!copyData(context, inputPath, in, outputPath, out, inputStat.getLen()))\n            return false;\n        } finally {\n          out.close();\n        }\n\n        // Preserve attributes\n        return preserveAttributes(outputPath, inputStat);\n      } finally {\n        in.close();\n      }\n    }","id":81896,"modified_method":"private boolean copyFile(final Context context, final Path inputPath, final Path outputPath)\n        throws IOException {\n      FSDataInputStream in = openSourceFile(inputPath);\n      if (in == null) {\n        context.getCounter(Counter.MISSING_FILES).increment(1);\n        return false;\n      }\n\n      try {\n        // Verify if the input file exists\n        FileStatus inputStat = getFileStatus(inputFs, inputPath);\n        if (inputStat == null) return false;\n\n        // Verify if the output file exists and is the same that we want to copy\n        if (outputFs.exists(outputPath)) {\n          FileStatus outputStat = outputFs.getFileStatus(outputPath);\n          if (sameFile(inputStat, outputStat)) {\n            LOG.info(\"Skip copy \" + inputPath + \" to \" + outputPath + \", same file.\");\n            return true;\n          }\n        }\n\n        context.getCounter(Counter.BYTES_EXPECTED).increment(inputStat.getLen());\n\n        // Ensure that the output folder is there and copy the file\n        outputFs.mkdirs(outputPath.getParent());\n        FSDataOutputStream out = outputFs.create(outputPath, true);\n        try {\n          if (!copyData(context, inputPath, in, outputPath, out, inputStat.getLen()))\n            return false;\n        } finally {\n          out.close();\n        }\n\n        // Preserve attributes\n        return preserveAttributes(outputPath, inputStat);\n      } finally {\n        in.close();\n      }\n    }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Create a table and take a snapshot of the table used by the export test.\n   */\n  @Before\n  public void setUp() throws Exception {\n    this.admin = TEST_UTIL.getHBaseAdmin();\n\n    long tid = System.currentTimeMillis();\n    tableName = Bytes.toBytes(\"testtb-\" + tid);\n    snapshotName = Bytes.toBytes(\"snaptb0-\" + tid);\n    emptySnapshotName = Bytes.toBytes(\"emptySnaptb0-\" + tid);\n\n    // create Table\n    HTableDescriptor htd = new HTableDescriptor(tableName);\n    htd.addFamily(new HColumnDescriptor(FAMILY));\n    admin.createTable(htd, null);\n\n    // Take an empty snapshot\n    admin.disableTable(tableName);\n    admin.snapshot(emptySnapshotName, tableName);\n    admin.enableTable(tableName);\n\n    // Add some rows\n    HTable table = new HTable(TEST_UTIL.getConfiguration(), tableName);\n    TEST_UTIL.loadTable(table, FAMILY);\n\n    // take a snapshot\n    admin.disableTable(tableName);\n    admin.snapshot(snapshotName, tableName);\n    admin.enableTable(tableName);\n  }","id":81897,"modified_method":"/**\n   * Create a table and take a snapshot of the table used by the export test.\n   */\n  @Before\n  public void setUp() throws Exception {\n    this.admin = TEST_UTIL.getHBaseAdmin();\n\n    long tid = System.currentTimeMillis();\n    tableName = Bytes.toBytes(\"testtb-\" + tid);\n    snapshotName = Bytes.toBytes(\"snaptb0-\" + tid);\n    emptySnapshotName = Bytes.toBytes(\"emptySnaptb0-\" + tid);\n\n    // create Table\n    HTableDescriptor htd = new HTableDescriptor(tableName);\n    htd.addFamily(new HColumnDescriptor(FAMILY));\n    admin.createTable(htd, null);\n\n    // Take an empty snapshot\n    admin.snapshot(emptySnapshotName, tableName);\n\n    // Add some rows\n    HTable table = new HTable(TEST_UTIL.getConfiguration(), tableName);\n    TEST_UTIL.loadTable(table, FAMILY);\n\n    // take a snapshot\n    admin.snapshot(snapshotName, tableName);\n  }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"private void verifyArchive(final FileSystem fs, final Path rootDir, final String snapshotName)\n      throws IOException {\n    final Path exportedSnapshot = new Path(rootDir,\n      new Path(HConstants.SNAPSHOT_DIR_NAME, snapshotName));\n    final Path exportedArchive = new Path(rootDir, \".archive\");\n    LOG.debug(listFiles(fs, exportedArchive, exportedArchive));\n    SnapshotReferenceUtil.visitReferencedFiles(fs, exportedSnapshot,\n        new SnapshotReferenceUtil.FileVisitor() {\n        public void storeFile (final String region, final String family, final String hfile)\n            throws IOException {\n          verifyNonEmptyFile(new Path(exportedArchive,\n            new Path(Bytes.toString(tableName), new Path(region, new Path(family, hfile)))));\n        }\n\n        public void recoveredEdits (final String region, final String logfile)\n            throws IOException {\n          verifyNonEmptyFile(new Path(exportedSnapshot,\n            new Path(Bytes.toString(tableName), new Path(region, logfile))));\n        }\n\n        public void logFile (final String server, final String logfile)\n            throws IOException {\n          verifyNonEmptyFile(new Path(exportedSnapshot, new Path(server, logfile)));\n        }\n\n        private void verifyNonEmptyFile(final Path path) throws IOException {\n          LOG.debug(path);\n          assertTrue(fs.exists(path));\n          assertTrue(fs.getFileStatus(path).getLen() > 0);\n        }\n    });\n  }","id":81898,"modified_method":"private void verifyArchive(final FileSystem fs, final Path rootDir,\n      final byte[] tableName, final String snapshotName) throws IOException {\n    final Path exportedSnapshot = new Path(rootDir,\n      new Path(HConstants.SNAPSHOT_DIR_NAME, snapshotName));\n    final Path exportedArchive = new Path(rootDir, HConstants.HFILE_ARCHIVE_DIRECTORY);\n    LOG.debug(listFiles(fs, exportedArchive, exportedArchive));\n    SnapshotReferenceUtil.visitReferencedFiles(fs, exportedSnapshot,\n        new SnapshotReferenceUtil.FileVisitor() {\n        public void storeFile (final String region, final String family, final String hfile)\n            throws IOException {\n          verifyNonEmptyFile(new Path(exportedArchive,\n            new Path(Bytes.toString(tableName), new Path(region, new Path(family, hfile)))));\n        }\n\n        public void recoveredEdits (final String region, final String logfile)\n            throws IOException {\n          verifyNonEmptyFile(new Path(exportedSnapshot,\n            new Path(Bytes.toString(tableName), new Path(region, logfile))));\n        }\n\n        public void logFile (final String server, final String logfile)\n            throws IOException {\n          verifyNonEmptyFile(new Path(exportedSnapshot, new Path(server, logfile)));\n        }\n\n        private void verifyNonEmptyFile(final Path path) throws IOException {\n          assertTrue(path + \" should exists\", fs.exists(path));\n          assertTrue(path + \" should not be empty\", fs.getFileStatus(path).getLen() > 0);\n        }\n    });\n  }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Test ExportSnapshot\n   */\n  private void testExportFileSystemState(final byte[] tableName, final byte[] snapshotName,\n      int filesExpected) throws Exception {\n    Path copyDir = TEST_UTIL.getDataTestDir(\"export-\" + System.currentTimeMillis());\n    URI hdfsUri = FileSystem.get(TEST_UTIL.getConfiguration()).getUri();\n    FileSystem fs = FileSystem.get(copyDir.toUri(), new Configuration());\n    copyDir = copyDir.makeQualified(fs);\n\n    // Export Snapshot\n    int res = ExportSnapshot.innerMain(TEST_UTIL.getConfiguration(), new String[] {\n      \"-snapshot\", Bytes.toString(snapshotName),\n      \"-copy-to\", copyDir.toString()\n    });\n    assertEquals(0, res);\n\n    // Verify File-System state\n    FileStatus[] rootFiles = fs.listStatus(copyDir);\n    assertEquals(filesExpected, rootFiles.length);\n    for (FileStatus fileStatus: rootFiles) {\n      String name = fileStatus.getPath().getName();\n      assertTrue(fileStatus.isDir());\n      assertTrue(name.equals(HConstants.SNAPSHOT_DIR_NAME) || name.equals(\".archive\"));\n    }\n\n    // compare the snapshot metadata and verify the hfiles\n    final FileSystem hdfs = FileSystem.get(hdfsUri, TEST_UTIL.getConfiguration());\n    final Path snapshotDir = new Path(HConstants.SNAPSHOT_DIR_NAME, Bytes.toString(snapshotName));\n    verifySnapshot(hdfs, new Path(TEST_UTIL.getDefaultRootDirPath(), snapshotDir),\n        fs, new Path(copyDir, snapshotDir));\n    verifyArchive(fs, copyDir, Bytes.toString(snapshotName));\n\n    // Remove the exported dir\n    fs.delete(copyDir, true);\n  }","id":81899,"modified_method":"/**\n   * Test ExportSnapshot\n   */\n  private void testExportFileSystemState(final byte[] tableName, final byte[] snapshotName,\n      int filesExpected) throws Exception {\n    Path copyDir = TEST_UTIL.getDataTestDir(\"export-\" + System.currentTimeMillis());\n    URI hdfsUri = FileSystem.get(TEST_UTIL.getConfiguration()).getUri();\n    FileSystem fs = FileSystem.get(copyDir.toUri(), new Configuration());\n    copyDir = copyDir.makeQualified(fs);\n\n    // Export Snapshot\n    int res = ExportSnapshot.innerMain(TEST_UTIL.getConfiguration(), new String[] {\n      \"-snapshot\", Bytes.toString(snapshotName),\n      \"-copy-to\", copyDir.toString()\n    });\n    assertEquals(0, res);\n\n    // Verify File-System state\n    FileStatus[] rootFiles = fs.listStatus(copyDir);\n    assertEquals(filesExpected, rootFiles.length);\n    for (FileStatus fileStatus: rootFiles) {\n      String name = fileStatus.getPath().getName();\n      assertTrue(fileStatus.isDir());\n      assertTrue(name.equals(HConstants.SNAPSHOT_DIR_NAME) || name.equals(\".archive\"));\n    }\n\n    // compare the snapshot metadata and verify the hfiles\n    final FileSystem hdfs = FileSystem.get(hdfsUri, TEST_UTIL.getConfiguration());\n    final Path snapshotDir = new Path(HConstants.SNAPSHOT_DIR_NAME, Bytes.toString(snapshotName));\n    verifySnapshot(hdfs, new Path(TEST_UTIL.getDefaultRootDirPath(), snapshotDir),\n        fs, new Path(copyDir, snapshotDir));\n    verifyArchive(fs, copyDir, tableName, Bytes.toString(snapshotName));\n    FSUtils.logFileSystemState(hdfs, snapshotDir, LOG);\n\n    // Remove the exported dir\n    fs.delete(copyDir, true);\n  }","commit_id":"7475f9088bf86d1d07957e169b04d16def486a0e","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            OptionFilter filter = new OptionFilter(ignore, cfnames);\n            Map<String, List<ColumnFamilyStoreMBean>> cfstoreMap = new HashMap<>();\n\n            // get a list of column family stores\n            Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> cfamilies = probe.getColumnFamilyStoreMBeanProxies();\n\n            while (cfamilies.hasNext())\n            {\n                Map.Entry<String, ColumnFamilyStoreMBean> entry = cfamilies.next();\n                String keyspaceName = entry.getKey();\n                ColumnFamilyStoreMBean cfsProxy = entry.getValue();\n\n                if (!cfstoreMap.containsKey(keyspaceName) && filter.isColumnFamilyIncluded(entry.getKey(), cfsProxy.getColumnFamilyName()))\n                {\n                    List<ColumnFamilyStoreMBean> columnFamilies = new ArrayList<>();\n                    columnFamilies.add(cfsProxy);\n                    cfstoreMap.put(keyspaceName, columnFamilies);\n                } else if (filter.isColumnFamilyIncluded(entry.getKey(), cfsProxy.getColumnFamilyName()))\n                {\n                    cfstoreMap.get(keyspaceName).add(cfsProxy);\n                }\n            }\n\n            // make sure all specified kss and cfs exist\n            filter.verifyKeyspaces(probe.getKeyspaces());\n            filter.verifyColumnFamilies();\n\n            // print out the table statistics\n            for (Map.Entry<String, List<ColumnFamilyStoreMBean>> entry : cfstoreMap.entrySet())\n            {\n                String keyspaceName = entry.getKey();\n                List<ColumnFamilyStoreMBean> columnFamilies = entry.getValue();\n                long keyspaceReadCount = 0;\n                long keyspaceWriteCount = 0;\n                int keyspacePendingFlushes = 0;\n                double keyspaceTotalReadTime = 0.0f;\n                double keyspaceTotalWriteTime = 0.0f;\n\n                System.out.println(\"Keyspace: \" + keyspaceName);\n                for (ColumnFamilyStoreMBean cfstore : columnFamilies)\n                {\n                    String cfName = cfstore.getColumnFamilyName();\n                    long writeCount = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteLatency\")).getCount();\n                    long readCount = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadLatency\")).getCount();\n\n                    if (readCount > 0)\n                    {\n                        keyspaceReadCount += readCount;\n                        keyspaceTotalReadTime += (long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadTotalLatency\");\n                    }\n                    if (writeCount > 0)\n                    {\n                        keyspaceWriteCount += writeCount;\n                        keyspaceTotalWriteTime += (long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteTotalLatency\");\n                    }\n                    keyspacePendingFlushes += (long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"PendingFlushes\");\n                }\n\n                double keyspaceReadLatency = keyspaceReadCount > 0\n                                             ? keyspaceTotalReadTime / keyspaceReadCount / 1000\n                                             : Double.NaN;\n                double keyspaceWriteLatency = keyspaceWriteCount > 0\n                                              ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000\n                                              : Double.NaN;\n\n                System.out.println(\"\\tRead Count: \" + keyspaceReadCount);\n                System.out.println(\"\\tRead Latency: \" + format(\"%s\", keyspaceReadLatency) + \" ms.\");\n                System.out.println(\"\\tWrite Count: \" + keyspaceWriteCount);\n                System.out.println(\"\\tWrite Latency: \" + format(\"%s\", keyspaceWriteLatency) + \" ms.\");\n                System.out.println(\"\\tPending Flushes: \" + keyspacePendingFlushes);\n\n                // print out column family statistics for this keyspace\n                for (ColumnFamilyStoreMBean cfstore : columnFamilies)\n                {\n                    String cfName = cfstore.getColumnFamilyName();\n                    if (cfName.contains(\".\"))\n                        System.out.println(\"\\t\\tTable (index): \" + cfName);\n                    else\n                        System.out.println(\"\\t\\tTable: \" + cfName);\n\n                    System.out.println(\"\\t\\tSSTable count: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"LiveSSTableCount\"));\n\n                    int[] leveledSStables = cfstore.getSSTableCountPerLevel();\n                    if (leveledSStables != null)\n                    {\n                        System.out.print(\"\\t\\tSSTables in each level: [\");\n                        for (int level = 0; level < leveledSStables.length; level++)\n                        {\n                            int count = leveledSStables[level];\n                            System.out.print(count);\n                            long maxCount = 4L; // for L0\n                            if (level > 0)\n                                maxCount = (long) Math.pow(10, level);\n                            //  show max threshold for level when exceeded\n                            if (count > maxCount)\n                                System.out.print(\"/\" + maxCount);\n\n                            if (level < leveledSStables.length - 1)\n                                System.out.print(\", \");\n                            else\n                                System.out.println(\"]\");\n                        }\n                    }\n                    System.out.println(\"\\t\\tSpace used (live), bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"LiveDiskSpaceUsed\"));\n                    System.out.println(\"\\t\\tSpace used (total), bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"TotalDiskSpaceUsed\"));\n                    System.out.println(\"\\t\\tSpace used by snapshots (total), bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"SnapshotsSize\"));\n                    System.out.println(\"\\t\\tSSTable Compression Ratio: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"CompressionRatio\"));\n                    System.out.println(\"\\t\\tMemtable cell count: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MemtableColumnsCount\"));\n                    System.out.println(\"\\t\\tMemtable data size, bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MemtableLiveDataSize\"));\n                    System.out.println(\"\\t\\tMemtable switch count: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MemtableSwitchCount\"));\n                    System.out.println(\"\\t\\tLocal read count: \" + ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadLatency\")).getCount());\n                    double localReadLatency = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadLatency\")).getMean() / 1000;\n                    double localRLatency = localReadLatency > 0 ? localReadLatency : Double.NaN;\n                    System.out.printf(\"\\t\\tLocal read latency: %01.3f ms%n\", localRLatency);\n                    System.out.println(\"\\t\\tLocal write count: \" + ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteLatency\")).getCount());\n                    double localWriteLatency = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteLatency\")).getMean() / 1000;\n                    double localWLatency = localWriteLatency > 0 ? localWriteLatency : Double.NaN;\n                    System.out.printf(\"\\t\\tLocal write latency: %01.3f ms%n\", localWLatency);\n                    System.out.println(\"\\t\\tPending flushes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"PendingFlushes\"));\n                    System.out.println(\"\\t\\tBloom filter false positives: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"BloomFilterFalsePositives\"));\n                    System.out.println(\"\\t\\tBloom filter false ratio: \" + format(\"%01.5f\", probe.getColumnFamilyMetric(keyspaceName, cfName, \"RecentBloomFilterFalseRatio\")));\n                    System.out.println(\"\\t\\tBloom filter space used, bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"BloomFilterDiskSpaceUsed\"));\n                    System.out.println(\"\\t\\tCompacted partition minimum bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MinRowSize\"));\n                    System.out.println(\"\\t\\tCompacted partition maximum bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MaxRowSize\"));\n                    System.out.println(\"\\t\\tCompacted partition mean bytes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MeanRowSize\"));\n                    JmxReporter.HistogramMBean histogram = (JmxReporter.HistogramMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"LiveScannedHistogram\");\n                    System.out.println(\"\\t\\tAverage live cells per slice (last five minutes): \" + histogram.getMean());\n                    System.out.println(\"\\t\\tMaximum live cells per slice (last five minutes): \" + histogram.getMax());\n                    histogram = (JmxReporter.HistogramMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"TombstoneScannedHistogram\");\n                    System.out.println(\"\\t\\tAverage tombstones per slice (last five minutes): \" + histogram.getMean());\n                    System.out.println(\"\\t\\tMaximum tombstones per slice (last five minutes): \" + histogram.getMax());\n\n                    System.out.println(\"\");\n                }\n                System.out.println(\"----------------\");\n            }\n        }","id":81900,"modified_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            OptionFilter filter = new OptionFilter(ignore, cfnames);\n            Map<String, List<ColumnFamilyStoreMBean>> cfstoreMap = new HashMap<>();\n\n            // get a list of column family stores\n            Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> cfamilies = probe.getColumnFamilyStoreMBeanProxies();\n\n            while (cfamilies.hasNext())\n            {\n                Map.Entry<String, ColumnFamilyStoreMBean> entry = cfamilies.next();\n                String keyspaceName = entry.getKey();\n                ColumnFamilyStoreMBean cfsProxy = entry.getValue();\n\n                if (!cfstoreMap.containsKey(keyspaceName) && filter.isColumnFamilyIncluded(entry.getKey(), cfsProxy.getColumnFamilyName()))\n                {\n                    List<ColumnFamilyStoreMBean> columnFamilies = new ArrayList<>();\n                    columnFamilies.add(cfsProxy);\n                    cfstoreMap.put(keyspaceName, columnFamilies);\n                } else if (filter.isColumnFamilyIncluded(entry.getKey(), cfsProxy.getColumnFamilyName()))\n                {\n                    cfstoreMap.get(keyspaceName).add(cfsProxy);\n                }\n            }\n\n            // make sure all specified kss and cfs exist\n            filter.verifyKeyspaces(probe.getKeyspaces());\n            filter.verifyColumnFamilies();\n\n            // print out the table statistics\n            for (Map.Entry<String, List<ColumnFamilyStoreMBean>> entry : cfstoreMap.entrySet())\n            {\n                String keyspaceName = entry.getKey();\n                List<ColumnFamilyStoreMBean> columnFamilies = entry.getValue();\n                long keyspaceReadCount = 0;\n                long keyspaceWriteCount = 0;\n                int keyspacePendingFlushes = 0;\n                double keyspaceTotalReadTime = 0.0f;\n                double keyspaceTotalWriteTime = 0.0f;\n\n                System.out.println(\"Keyspace: \" + keyspaceName);\n                for (ColumnFamilyStoreMBean cfstore : columnFamilies)\n                {\n                    String cfName = cfstore.getColumnFamilyName();\n                    long writeCount = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteLatency\")).getCount();\n                    long readCount = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadLatency\")).getCount();\n\n                    if (readCount > 0)\n                    {\n                        keyspaceReadCount += readCount;\n                        keyspaceTotalReadTime += (long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadTotalLatency\");\n                    }\n                    if (writeCount > 0)\n                    {\n                        keyspaceWriteCount += writeCount;\n                        keyspaceTotalWriteTime += (long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteTotalLatency\");\n                    }\n                    keyspacePendingFlushes += (long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"PendingFlushes\");\n                }\n\n                double keyspaceReadLatency = keyspaceReadCount > 0\n                                             ? keyspaceTotalReadTime / keyspaceReadCount / 1000\n                                             : Double.NaN;\n                double keyspaceWriteLatency = keyspaceWriteCount > 0\n                                              ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000\n                                              : Double.NaN;\n\n                System.out.println(\"\\tRead Count: \" + keyspaceReadCount);\n                System.out.println(\"\\tRead Latency: \" + String.format(\"%s\", keyspaceReadLatency) + \" ms.\");\n                System.out.println(\"\\tWrite Count: \" + keyspaceWriteCount);\n                System.out.println(\"\\tWrite Latency: \" + String.format(\"%s\", keyspaceWriteLatency) + \" ms.\");\n                System.out.println(\"\\tPending Flushes: \" + keyspacePendingFlushes);\n\n                // print out column family statistics for this keyspace\n                for (ColumnFamilyStoreMBean cfstore : columnFamilies)\n                {\n                    String cfName = cfstore.getColumnFamilyName();\n                    if (cfName.contains(\".\"))\n                        System.out.println(\"\\t\\tTable (index): \" + cfName);\n                    else\n                        System.out.println(\"\\t\\tTable: \" + cfName);\n\n                    System.out.println(\"\\t\\tSSTable count: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"LiveSSTableCount\"));\n\n                    int[] leveledSStables = cfstore.getSSTableCountPerLevel();\n                    if (leveledSStables != null)\n                    {\n                        System.out.print(\"\\t\\tSSTables in each level: [\");\n                        for (int level = 0; level < leveledSStables.length; level++)\n                        {\n                            int count = leveledSStables[level];\n                            System.out.print(count);\n                            long maxCount = 4L; // for L0\n                            if (level > 0)\n                                maxCount = (long) Math.pow(10, level);\n                            //  show max threshold for level when exceeded\n                            if (count > maxCount)\n                                System.out.print(\"/\" + maxCount);\n\n                            if (level < leveledSStables.length - 1)\n                                System.out.print(\", \");\n                            else\n                                System.out.println(\"]\");\n                        }\n                    }\n                    System.out.println(\"\\t\\tSpace used (live): \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"LiveDiskSpaceUsed\"), humanReadable));\n                    System.out.println(\"\\t\\tSpace used (total): \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"TotalDiskSpaceUsed\"), humanReadable));\n                    System.out.println(\"\\t\\tSpace used by snapshots (total): \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"SnapshotsSize\"), humanReadable));\n                    System.out.println(\"\\t\\tSSTable Compression Ratio: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"CompressionRatio\"));\n                    System.out.println(\"\\t\\tMemtable cell count: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MemtableColumnsCount\"));\n                    System.out.println(\"\\t\\tMemtable data size: \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"MemtableLiveDataSize\"), humanReadable));\n                    System.out.println(\"\\t\\tMemtable switch count: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"MemtableSwitchCount\"));\n                    System.out.println(\"\\t\\tLocal read count: \" + ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadLatency\")).getCount());\n                    double localReadLatency = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"ReadLatency\")).getMean() / 1000;\n                    double localRLatency = localReadLatency > 0 ? localReadLatency : Double.NaN;\n                    System.out.printf(\"\\t\\tLocal read latency: %01.3f ms%n\", localRLatency);\n                    System.out.println(\"\\t\\tLocal write count: \" + ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteLatency\")).getCount());\n                    double localWriteLatency = ((JmxReporter.TimerMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"WriteLatency\")).getMean() / 1000;\n                    double localWLatency = localWriteLatency > 0 ? localWriteLatency : Double.NaN;\n                    System.out.printf(\"\\t\\tLocal write latency: %01.3f ms%n\", localWLatency);\n                    System.out.println(\"\\t\\tPending flushes: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"PendingFlushes\"));\n                    System.out.println(\"\\t\\tBloom filter false positives: \" + probe.getColumnFamilyMetric(keyspaceName, cfName, \"BloomFilterFalsePositives\"));\n                    System.out.printf(\"\\t\\tBloom filter false ratio: %s%n\", String.format(\"%01.5f\", probe.getColumnFamilyMetric(keyspaceName, cfName, \"RecentBloomFilterFalseRatio\")));\n                    System.out.println(\"\\t\\tBloom filter space used: \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"BloomFilterDiskSpaceUsed\"), humanReadable));\n                    System.out.println(\"\\t\\tCompacted partition minimum bytes: \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"MinRowSize\"), humanReadable));\n                    System.out.println(\"\\t\\tCompacted partition maximum bytes: \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"MaxRowSize\"), humanReadable));\n                    System.out.println(\"\\t\\tCompacted partition mean bytes: \" + format((Long) probe.getColumnFamilyMetric(keyspaceName, cfName, \"MeanRowSize\"), humanReadable));\n                    JmxReporter.HistogramMBean histogram = (JmxReporter.HistogramMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"LiveScannedHistogram\");\n                    System.out.println(\"\\t\\tAverage live cells per slice (last five minutes): \" + histogram.getMean());\n                    System.out.println(\"\\t\\tMaximum live cells per slice (last five minutes): \" + histogram.getMax());\n                    histogram = (JmxReporter.HistogramMBean) probe.getColumnFamilyMetric(keyspaceName, cfName, \"TombstoneScannedHistogram\");\n                    System.out.println(\"\\t\\tAverage tombstones per slice (last five minutes): \" + histogram.getMean());\n                    System.out.println(\"\\t\\tMaximum tombstones per slice (last five minutes): \" + histogram.getMax());\n\n                    System.out.println(\"\");\n                }\n                System.out.println(\"----------------\");\n            }\n        }","commit_id":"1cef273ed3d77505bf3ad2afc9eef1a0b37405b3","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            int compactionThroughput = probe.getCompactionThroughput();\n            CompactionManagerMBean cm = probe.getCompactionManagerProxy();\n            System.out.println(\"pending tasks: \" + probe.getCompactionMetric(\"PendingTasks\"));\n            long remainingBytes = 0;\n            if (cm.getCompactions().size() > 0)\n            {\n                List<String[]> lines = new ArrayList<>();\n                int[] columnSizes = new int[] { 0, 0, 0, 0, 0, 0, 0 };\n\n                addLine(lines, columnSizes, \"compaction type\", \"keyspace\", \"table\", \"completed\", \"total\", \"unit\", \"progress\");\n                for (Map<String, String> c : cm.getCompactions())\n                {\n                    long total = Long.parseLong(c.get(\"total\"));\n                    long completed = Long.parseLong(c.get(\"completed\"));\n                    String taskType = c.get(\"taskType\");\n                    String keyspace = c.get(\"keyspace\");\n                    String columnFamily = c.get(\"columnfamily\");\n                    String unit = c.get(\"unit\");\n                    String percentComplete = total == 0 ? \"n/a\" : new DecimalFormat(\"0.00\").format((double) completed / total * 100) + \"%\";\n                    addLine(lines, columnSizes, taskType, keyspace, columnFamily, Long.toString(completed), Long.toString(total), unit, percentComplete);\n                    if (taskType.equals(OperationType.COMPACTION.toString()))\n                        remainingBytes += total - completed;\n                }\n\n                StringBuilder buffer = new StringBuilder();\n                for (int columnSize : columnSizes) {\n                    buffer.append(\"%\");\n                    buffer.append(columnSize + 3);\n                    buffer.append(\"s\");\n                }\n                buffer.append(\"%n\");\n                String format = buffer.toString();\n\n                for (String[] line : lines)\n                {\n                    System.out.printf(format, line[0], line[1], line[2], line[3], line[4], line[5], line[6]);\n                }\n\n                String remainingTime = \"n/a\";\n                if (compactionThroughput != 0)\n                {\n                    long remainingTimeInSecs = remainingBytes / (1024L * 1024L * compactionThroughput);\n                    remainingTime = format(\"%dh%02dm%02ds\", remainingTimeInSecs / 3600, (remainingTimeInSecs % 3600) / 60, (remainingTimeInSecs % 60));\n                }\n                System.out.printf(\"%25s%10s%n\", \"Active compaction remaining time : \", remainingTime);\n            }\n        }","id":81901,"modified_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            int compactionThroughput = probe.getCompactionThroughput();\n            CompactionManagerMBean cm = probe.getCompactionManagerProxy();\n            System.out.println(\"pending tasks: \" + probe.getCompactionMetric(\"PendingTasks\"));\n            long remainingBytes = 0;\n            if (cm.getCompactions().size() > 0)\n            {\n                List<String[]> lines = new ArrayList<>();\n                int[] columnSizes = new int[] { 0, 0, 0, 0, 0, 0, 0 };\n\n                addLine(lines, columnSizes, \"compaction type\", \"keyspace\", \"table\", \"completed\", \"total\", \"unit\", \"progress\");\n                for (Map<String, String> c : cm.getCompactions())\n                {\n                    long total = Long.parseLong(c.get(\"total\"));\n                    long completed = Long.parseLong(c.get(\"completed\"));\n                    String taskType = c.get(\"taskType\");\n                    String keyspace = c.get(\"keyspace\");\n                    String columnFamily = c.get(\"columnfamily\");\n                    String completedStr = humanReadable ? FileUtils.stringifyFileSize(completed) : Long.toString(completed);\n                    String totalStr = humanReadable ? FileUtils.stringifyFileSize(total) : Long.toString(total);\n                    String unit = c.get(\"unit\");\n                    String percentComplete = total == 0 ? \"n/a\" : new DecimalFormat(\"0.00\").format((double) completed / total * 100) + \"%\";\n                    addLine(lines, columnSizes, taskType, keyspace, columnFamily, completedStr, totalStr, unit, percentComplete);\n                    if (taskType.equals(OperationType.COMPACTION.toString()))\n                        remainingBytes += total - completed;\n                }\n\n                StringBuilder buffer = new StringBuilder();\n                for (int columnSize : columnSizes) {\n                    buffer.append(\"%\");\n                    buffer.append(columnSize + 3);\n                    buffer.append(\"s\");\n                }\n                buffer.append(\"%n\");\n                String format = buffer.toString();\n\n                for (String[] line : lines)\n                {\n                    System.out.printf(format, line[0], line[1], line[2], line[3], line[4], line[5], line[6]);\n                }\n\n                String remainingTime = \"n/a\";\n                if (compactionThroughput != 0)\n                {\n                    long remainingTimeInSecs = remainingBytes / (1024L * 1024L * compactionThroughput);\n                    remainingTime = format(\"%dh%02dm%02ds\", remainingTimeInSecs / 3600, (remainingTimeInSecs % 3600) / 60, (remainingTimeInSecs % 60));\n                }\n                System.out.printf(\"%25s%10s%n\", \"Active compaction remaining time : \", remainingTime);\n            }\n        }","commit_id":"1cef273ed3d77505bf3ad2afc9eef1a0b37405b3","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            boolean gossipInitialized = probe.isInitialized();\n\n            System.out.printf(\"%-17s: %s%n\", \"ID\", probe.getLocalHostId());\n            System.out.printf(\"%-17s: %s%n\", \"Gossip active\", gossipInitialized);\n            System.out.printf(\"%-17s: %s%n\", \"Thrift active\", probe.isThriftServerRunning());\n            System.out.printf(\"%-17s: %s%n\", \"Native Transport active\", probe.isNativeTransportRunning());\n            System.out.printf(\"%-17s: %s%n\", \"Load\", probe.getLoadString());\n            if (gossipInitialized)\n                System.out.printf(\"%-17s: %s%n\", \"Generation No\", probe.getCurrentGenerationNumber());\n            else\n                System.out.printf(\"%-17s: %s%n\", \"Generation No\", 0);\n\n            // Uptime\n            long secondsUp = probe.getUptime() / 1000;\n            System.out.printf(\"%-17s: %d%n\", \"Uptime (seconds)\", secondsUp);\n\n            // Memory usage\n            MemoryUsage heapUsage = probe.getHeapMemoryUsage();\n            double memUsed = (double) heapUsage.getUsed() / (1024 * 1024);\n            double memMax = (double) heapUsage.getMax() / (1024 * 1024);\n            System.out.printf(\"%-17s: %.2f / %.2f%n\", \"Heap Memory (MB)\", memUsed, memMax);\n\n            // Data Center/Rack\n            System.out.printf(\"%-17s: %s%n\", \"Data Center\", probe.getDataCenter());\n            System.out.printf(\"%-17s: %s%n\", \"Rack\", probe.getRack());\n\n            // Exceptions\n            System.out.printf(\"%-17s: %s%n\", \"Exceptions\", probe.getStorageMetric(\"Exceptions\"));\n\n            CacheServiceMBean cacheService = probe.getCacheServiceMBean();\n\n            // Key Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds\n            System.out.printf(\"%-17s: entries %d, size %d (bytes), capacity %d (bytes), %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n\",\n                    \"Key Cache\",\n                    probe.getCacheMetric(\"KeyCache\", \"Entries\"),\n                    probe.getCacheMetric(\"KeyCache\", \"Size\"),\n                    probe.getCacheMetric(\"KeyCache\", \"Capacity\"),\n                    probe.getCacheMetric(\"KeyCache\", \"Hits\"),\n                    probe.getCacheMetric(\"KeyCache\", \"Requests\"),\n                    probe.getCacheMetric(\"KeyCache\", \"HitRate\"),\n                    cacheService.getKeyCacheSavePeriodInSeconds());\n\n            // Row Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds\n            System.out.printf(\"%-17s: entries %d, size %d (bytes), capacity %d (bytes), %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n\",\n                    \"Row Cache\",\n                    probe.getCacheMetric(\"RowCache\", \"Entries\"),\n                    probe.getCacheMetric(\"RowCache\", \"Size\"),\n                    probe.getCacheMetric(\"RowCache\", \"Capacity\"),\n                    probe.getCacheMetric(\"RowCache\", \"Hits\"),\n                    probe.getCacheMetric(\"RowCache\", \"Requests\"),\n                    probe.getCacheMetric(\"RowCache\", \"HitRate\"),\n                    cacheService.getRowCacheSavePeriodInSeconds());\n\n            // Counter Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds\n            System.out.printf(\"%-17s: entries %d, size %d (bytes), capacity %d (bytes), %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n\",\n                    \"Counter Cache\",\n                    probe.getCacheMetric(\"CounterCache\", \"Entries\"),\n                    probe.getCacheMetric(\"CounterCache\", \"Size\"),\n                    probe.getCacheMetric(\"CounterCache\", \"Capacity\"),\n                    probe.getCacheMetric(\"CounterCache\", \"Hits\"),\n                    probe.getCacheMetric(\"CounterCache\", \"Requests\"),\n                    probe.getCacheMetric(\"CounterCache\", \"HitRate\"),\n                    cacheService.getCounterCacheSavePeriodInSeconds());\n\n            // Tokens\n            List<String> tokens = probe.getTokens();\n            if (tokens.size() == 1 || this.tokens)\n                for (String token : tokens)\n                    System.out.printf(\"%-17s: %s%n\", \"Token\", token);\n            else\n                System.out.printf(\"%-17s: (invoke with -T/--tokens to see all %d tokens)%n\", \"Token\", tokens.size());\n        }","id":81902,"modified_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            boolean gossipInitialized = probe.isInitialized();\n\n            System.out.printf(\"%-17s: %s%n\", \"ID\", probe.getLocalHostId());\n            System.out.printf(\"%-17s: %s%n\", \"Gossip active\", gossipInitialized);\n            System.out.printf(\"%-17s: %s%n\", \"Thrift active\", probe.isThriftServerRunning());\n            System.out.printf(\"%-17s: %s%n\", \"Native Transport active\", probe.isNativeTransportRunning());\n            System.out.printf(\"%-17s: %s%n\", \"Load\", probe.getLoadString());\n            if (gossipInitialized)\n                System.out.printf(\"%-17s: %s%n\", \"Generation No\", probe.getCurrentGenerationNumber());\n            else\n                System.out.printf(\"%-17s: %s%n\", \"Generation No\", 0);\n\n            // Uptime\n            long secondsUp = probe.getUptime() / 1000;\n            System.out.printf(\"%-17s: %d%n\", \"Uptime (seconds)\", secondsUp);\n\n            // Memory usage\n            MemoryUsage heapUsage = probe.getHeapMemoryUsage();\n            double memUsed = (double) heapUsage.getUsed() / (1024 * 1024);\n            double memMax = (double) heapUsage.getMax() / (1024 * 1024);\n            System.out.printf(\"%-17s: %.2f / %.2f%n\", \"Heap Memory (MB)\", memUsed, memMax);\n\n            // Data Center/Rack\n            System.out.printf(\"%-17s: %s%n\", \"Data Center\", probe.getDataCenter());\n            System.out.printf(\"%-17s: %s%n\", \"Rack\", probe.getRack());\n\n            // Exceptions\n            System.out.printf(\"%-17s: %s%n\", \"Exceptions\", probe.getStorageMetric(\"Exceptions\"));\n\n            CacheServiceMBean cacheService = probe.getCacheServiceMBean();\n\n            // Key Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds\n            System.out.printf(\"%-17s: entries %d, size %s, capacity %s, %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n\",\n                    \"Key Cache\",\n                    probe.getCacheMetric(\"KeyCache\", \"Entries\"),\n                    FileUtils.stringifyFileSize((long) probe.getCacheMetric(\"KeyCache\", \"Size\")),\n                    FileUtils.stringifyFileSize((long) probe.getCacheMetric(\"KeyCache\", \"Capacity\")),\n                    probe.getCacheMetric(\"KeyCache\", \"Hits\"),\n                    probe.getCacheMetric(\"KeyCache\", \"Requests\"),\n                    probe.getCacheMetric(\"KeyCache\", \"HitRate\"),\n                    cacheService.getKeyCacheSavePeriodInSeconds());\n\n            // Row Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds\n            System.out.printf(\"%-17s: entries %d, size %s, capacity %s, %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n\",\n                    \"Row Cache\",\n                    probe.getCacheMetric(\"RowCache\", \"Entries\"),\n                    FileUtils.stringifyFileSize((long) probe.getCacheMetric(\"RowCache\", \"Size\")),\n                    FileUtils.stringifyFileSize((long) probe.getCacheMetric(\"RowCache\", \"Capacity\")),\n                    probe.getCacheMetric(\"RowCache\", \"Hits\"),\n                    probe.getCacheMetric(\"RowCache\", \"Requests\"),\n                    probe.getCacheMetric(\"RowCache\", \"HitRate\"),\n                    cacheService.getRowCacheSavePeriodInSeconds());\n\n            // Counter Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds\n            System.out.printf(\"%-17s: entries %d, size %s, capacity %s, %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n\",\n                    \"Counter Cache\",\n                    probe.getCacheMetric(\"CounterCache\", \"Entries\"),\n                    FileUtils.stringifyFileSize((long) probe.getCacheMetric(\"CounterCache\", \"Size\")),\n                    FileUtils.stringifyFileSize((long) probe.getCacheMetric(\"CounterCache\", \"Capacity\")),\n                    probe.getCacheMetric(\"CounterCache\", \"Hits\"),\n                    probe.getCacheMetric(\"CounterCache\", \"Requests\"),\n                    probe.getCacheMetric(\"CounterCache\", \"HitRate\"),\n                    cacheService.getCounterCacheSavePeriodInSeconds());\n\n            // Tokens\n            List<String> tokens = probe.getTokens();\n            if (tokens.size() == 1 || this.tokens)\n                for (String token : tokens)\n                    System.out.printf(\"%-17s: %s%n\", \"Token\", token);\n            else\n                System.out.printf(\"%-17s: (invoke with -T/--tokens to see all %d tokens)%n\", \"Token\", tokens.size());\n        }","commit_id":"1cef273ed3d77505bf3ad2afc9eef1a0b37405b3","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            System.out.printf(\"Mode: %s%n\", probe.getOperationMode());\n            Set<StreamState> statuses = probe.getStreamStatus();\n            if (statuses.isEmpty())\n                System.out.println(\"Not sending any streams.\");\n            for (StreamState status : statuses)\n            {\n                System.out.printf(\"%s %s%n\", status.description, status.planId.toString());\n                for (SessionInfo info : status.sessions)\n                {\n                    System.out.printf(\"    %s%n\", info.peer.toString());\n                    if (!info.receivingSummaries.isEmpty())\n                    {\n                        System.out.printf(\"        Receiving %d files, %d bytes total%n\", info.getTotalFilesToReceive(), info.getTotalSizeToReceive());\n                        for (ProgressInfo progress : info.getReceivingFiles())\n                        {\n                            System.out.printf(\"            %s%n\", progress.toString());\n                        }\n                    }\n                    if (!info.sendingSummaries.isEmpty())\n                    {\n                        System.out.printf(\"        Sending %d files, %d bytes total%n\", info.getTotalFilesToSend(), info.getTotalSizeToSend());\n                        for (ProgressInfo progress : info.getSendingFiles())\n                        {\n                            System.out.printf(\"            %s%n\", progress.toString());\n                        }\n                    }\n                }\n            }\n\n            System.out.printf(\"Read Repair Statistics:%nAttempted: %d%nMismatch (Blocking): %d%nMismatch (Background): %d%n\", probe.getReadRepairAttempted(), probe.getReadRepairRepairedBlocking(), probe.getReadRepairRepairedBackground());\n\n            MessagingServiceMBean ms = probe.msProxy;\n            System.out.printf(\"%-25s\", \"Pool Name\");\n            System.out.printf(\"%10s\", \"Active\");\n            System.out.printf(\"%10s\", \"Pending\");\n            System.out.printf(\"%15s%n\", \"Completed\");\n\n            int pending;\n            long completed;\n\n            pending = 0;\n            for (int n : ms.getCommandPendingTasks().values())\n                pending += n;\n            completed = 0;\n            for (long n : ms.getCommandCompletedTasks().values())\n                completed += n;\n            System.out.printf(\"%-25s%10s%10s%15s%n\", \"Commands\", \"n/a\", pending, completed);\n\n            pending = 0;\n            for (int n : ms.getResponsePendingTasks().values())\n                pending += n;\n            completed = 0;\n            for (long n : ms.getResponseCompletedTasks().values())\n                completed += n;\n            System.out.printf(\"%-25s%10s%10s%15s%n\", \"Responses\", \"n/a\", pending, completed);\n        }","id":81903,"modified_method":"@Override\n        public void execute(NodeProbe probe)\n        {\n            System.out.printf(\"Mode: %s%n\", probe.getOperationMode());\n            Set<StreamState> statuses = probe.getStreamStatus();\n            if (statuses.isEmpty())\n                System.out.println(\"Not sending any streams.\");\n            for (StreamState status : statuses)\n            {\n                System.out.printf(\"%s %s%n\", status.description, status.planId.toString());\n                for (SessionInfo info : status.sessions)\n                {\n                    System.out.printf(\"    %s%n\", info.peer.toString());\n                    if (!info.receivingSummaries.isEmpty())\n                    {\n                        if (humanReadable)\n                            System.out.printf(\"        Receiving %d files, %s total%n\", info.getTotalFilesToReceive(), FileUtils.stringifyFileSize(info.getTotalSizeToReceive()));\n                        else\n                            System.out.printf(\"        Receiving %d files, %d bytes total%n\", info.getTotalFilesToReceive(), info.getTotalSizeToReceive());\n                        for (ProgressInfo progress : info.getReceivingFiles())\n                        {\n                            System.out.printf(\"            %s%n\", progress.toString());\n                        }\n                    }\n                    if (!info.sendingSummaries.isEmpty())\n                    {\n                        if (humanReadable)\n                            System.out.printf(\"        Sending %d files, %s total%n\", info.getTotalFilesToSend(), FileUtils.stringifyFileSize(info.getTotalSizeToSend()));\n                        else\n                            System.out.printf(\"        Sending %d files, %d bytes total%n\", info.getTotalFilesToSend(), info.getTotalSizeToSend());\n                        for (ProgressInfo progress : info.getSendingFiles())\n                        {\n                            System.out.printf(\"            %s%n\", progress.toString());\n                        }\n                    }\n                }\n            }\n\n            System.out.printf(\"Read Repair Statistics:%nAttempted: %d%nMismatch (Blocking): %d%nMismatch (Background): %d%n\", probe.getReadRepairAttempted(), probe.getReadRepairRepairedBlocking(), probe.getReadRepairRepairedBackground());\n\n            MessagingServiceMBean ms = probe.msProxy;\n            System.out.printf(\"%-25s\", \"Pool Name\");\n            System.out.printf(\"%10s\", \"Active\");\n            System.out.printf(\"%10s\", \"Pending\");\n            System.out.printf(\"%15s%n\", \"Completed\");\n\n            int pending;\n            long completed;\n\n            pending = 0;\n            for (int n : ms.getCommandPendingTasks().values())\n                pending += n;\n            completed = 0;\n            for (long n : ms.getCommandCompletedTasks().values())\n                completed += n;\n            System.out.printf(\"%-25s%10s%10s%15s%n\", \"Commands\", \"n/a\", pending, completed);\n\n            pending = 0;\n            for (int n : ms.getResponsePendingTasks().values())\n                pending += n;\n            completed = 0;\n            for (long n : ms.getResponseCompletedTasks().values())\n                completed += n;\n            System.out.printf(\"%-25s%10s%10s%15s%n\", \"Responses\", \"n/a\", pending, completed);\n        }","commit_id":"1cef273ed3d77505bf3ad2afc9eef1a0b37405b3","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Generate a stored credential from the given plain text credential.\n     *\n     * @param saltLength        Length of random salt to be generated and used\n     *                          as part of the transformation\n     * @param userCredential    The plain text credential\n     *\n     * @return  The credential to be stored\n     */\n    public String generate(int saltLength, String userCredential) {\n        byte[] salt = null;\n        int iterations = getIterations();\n        if (saltLength == 0) {\n            salt = new byte[0];\n        } else if (saltLength > 0) {\n            if (random == null) {\n                random = new SecureRandom();\n            }\n            salt = new byte[saltLength];\n            random.nextBytes(salt);\n        }\n\n        String serverCredential = mutate(userCredential, salt, iterations);\n\n        return HexUtils.toHexString(salt) + \"$\" + iterations + \"$\" + serverCredential;\n    }","id":81904,"modified_method":"/**\n     * Generate a stored credential from the given plain text credential.\n     *\n     * @param saltLength        Length of random salt to be generated and used\n     *                          as part of the transformation\n     * @param userCredential    The plain text credential\n     *\n     * @return  The credential to be stored\n     */\n    public String generate(int saltLength, String userCredential) {\n        byte[] salt = null;\n        int iterations = getIterations();\n        if (saltLength == 0) {\n            salt = new byte[0];\n        } else if (saltLength > 0) {\n            if (random == null) {\n                random = new SecureRandom();\n            }\n            salt = new byte[saltLength];\n            random.nextBytes(salt);\n        }\n\n        String serverCredential = mutate(userCredential, salt, iterations);\n\n        StringBuilder result =\n                new StringBuilder(saltLength << 1 + 10 + serverCredential.length() + 2);\n        result.append(HexUtils.toHexString(salt));\n        result.append('$');\n        result.append(iterations);\n        result.append('$');\n        result.append(serverCredential);\n\n        return result.toString();\n    }","commit_id":"3676dae4174e8b110c83b0652454b7c89f10347b","url":"https://github.com/apache/tomcat"},{"original_method":"public static String colorToString(int color) {\n\t\tif ((0xFF000000 & color) == 0xFF000000) {\n\t\t\tString c = Integer.toHexString(color & 0x00FFFFFF);\n\t\t\tc = c.length() <= 6 ? \"000000\".substring(c.length()) + c : c; //$NON-NLS-1$\n\t\t\treturn \"#\" + c; //$NON-NLS-1$\n\t\t} else {\n\t\t\treturn \"#\" + Integer.toHexString(color); //$NON-NLS-1$\n\t\t}\n\t}","id":81905,"modified_method":"public static String colorToString(int color) {\n\t\tString c = \"\";\n\t\tif ((0xFF000000 & color) == 0xFF000000) {\n\t\t\tc = Integer.toHexString(color & 0x00FFFFFF);\n\t\t\tc = c.length() <= 6 ? \"000000\".substring(c.length()) + c : c; //$NON-NLS-1$\n\t\t} else if ((0x00FFFFFF & color) == color) {\n\t\t\t//issue: if alpha=00 this is wrong\n\t\t\tc = Integer.toHexString(color);\n\t\t\tc = c.length() <= 6 ? \"000000\".substring(c.length()) + c : c; //$NON-NLS-1$\n\t\t} else {\n\t\t\tc = Integer.toHexString(color);\n\t\t\tc = c.length() <= 8 ? \"00000000\".substring(c.length()) + c : c; //$NON-NLS-1$\n\t\t}\n\t\treturn \"#\" + c; //$NON-NLS-1$\n\t}","commit_id":"4d49130002693bc88b2374431777f6b533b6262f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static String colorToString(int color) {\n\t\tif ((0xFF000000 & color) == 0xFF000000) {\n\t\t\treturn \"#\" + Integer.toHexString(color & 0x00FFFFFF); //$NON-NLS-1$\n\t\t} else {\n\t\t\treturn \"#\" + Integer.toHexString(color); //$NON-NLS-1$\n\t\t}\n\t}","id":81906,"modified_method":"public static String colorToString(int color) {\n\t\tif ((0xFF000000 & color) == 0xFF000000) {\n\t\t\treturn \"#\" + Integer.toHexString(color & 0x00FFFFFF); //$NON-NLS-1$\n\t\t} else {\n\t\t\tprivate final static String ZEROES = \"000000\";\n\t\t\tString c = Integer.toHexString(color);\n\t\t\treturn \"#\" + c.length() <= 6 ? ZEROES.substring(c.length()) + c : c; //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"a06ce588fc8e53d985c58f747a04d3217ec460c1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void selectSplitDistance() {\n\t\tfinal List<GpxDisplayGroup> groups = filterGroups(GpxDisplayItemType.TRACK_SEGMENT);\n\n\t\tView view = getMyActivity().getLayoutInflater().inflate(R.layout.selected_track_edit, null);\n\t\t\n\t\tfinal TIntArrayList list = new TIntArrayList();\n        final Spinner colorSpinner = (Spinner) view.findViewById(R.id.ColorSpinner);\n        ColorDialogs.setupColorSpinner(getActivity(), getGpx().getColor(), colorSpinner, list);\n\t\t\n\t\t\n\t\tfinal Spinner sp = (Spinner) view.findViewById(R.id.Spinner);\n\t\tBuilder bld = new AlertDialog.Builder(getMyActivity());\n\t\tfinal List<Double> distanceSplit = new ArrayList<Double>();\n\t\tfinal TIntArrayList timeSplit = new TIntArrayList();\n\t\tif(groups.size() == 0) {\n\t\t\tsp.setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.GpxSpinnerRow).setVisibility(View.GONE);\n\t\t} else {\n\t\t\tsp.setVisibility(View.VISIBLE);\n\n\t\t\tint[] checkedItem = new int[] { !groups.get(0).isSplitDistance() && !groups.get(0).isSplitTime() ? 0 : -1 };\n\t\t\tList<String> options = new ArrayList<String>();\n\t\t\t\n\n\t\t\toptions.add(app.getString(R.string.none));\n\t\t\tdistanceSplit.add(-1d);\n\t\t\ttimeSplit.add(-1);\n\t\t\taddOptionSplit(30, true, options, distanceSplit, timeSplit, checkedItem, groups); // 100 feet, 50 yards, 50\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m\n\t\t\taddOptionSplit(60, true, options, distanceSplit, timeSplit, checkedItem, groups); // 200 feet, 100 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 100 m\n\t\t\taddOptionSplit(150, true, options, distanceSplit, timeSplit, checkedItem, groups); // 500 feet, 200 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 200 m\n\t\t\taddOptionSplit(300, true, options, distanceSplit, timeSplit, checkedItem, groups); // 1000 feet, 500 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 500 m\n\t\t\taddOptionSplit(600, true, options, distanceSplit, timeSplit, checkedItem, groups); // 2000 feet, 1000 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1km\n\t\t\taddOptionSplit(1500, true, options, distanceSplit, timeSplit, checkedItem, groups); // 1mi, 2km\n\t\t\taddOptionSplit(3000, true, options, distanceSplit, timeSplit, checkedItem, groups); // 2mi, 5km\n\t\t\taddOptionSplit(8000, true, options, distanceSplit, timeSplit, checkedItem, groups); // 5mi, 10km\n\n\t\t\taddOptionSplit(15, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(30, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(60, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(120, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(150, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(300, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(600, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(900, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\n\t\t\tArrayAdapter<String> adapter = new ArrayAdapter<String>(getMyActivity(),\n\t\t\t\t\tandroid.R.layout.simple_spinner_item, options);\n\t\t\tadapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\t\tsp.setAdapter(adapter);\n\t\t\tif (checkedItem[0] > 0) {\n\t\t\t\tsp.setSelection(checkedItem[0]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal CheckBox vis = (CheckBox) view.findViewById(R.id.Visibility);\n\t\tvis.setChecked(app.getSelectedGpxHelper().getSelectedFileByPath(getGpx().path) != null);\n\t\t\n\t\tbld.setView(view);\n\t\tbld.setNegativeButton(R.string.shared_string_cancel, null);\n\t\tbld.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\tSelectedGpxFile sf = app.getSelectedGpxHelper().selectGpxFile(getGpx(), vis.isChecked(), false);\n\t\t\t\tint clr = list.get(colorSpinner.getSelectedItemPosition());\n\t\t\t\tif(clr != 0 ) {\n\t\t\t\t\tsf.getModifiableGpxFile().setColor(clr);\n\t\t\t\t\tsf.processPoints();\n\t\t\t\t}\n\t\t\t\tif (groups.size() > 0) {\n\t\t\t\t\tupdateSplit(groups, distanceSplit, timeSplit, sp.getSelectedItemPosition(), vis.isChecked() ? sf\n\t\t\t\t\t\t\t: null);\n\t\t\t\t}\n\t\t\t\tif(vis.isChecked() && sf.getGpxFile() != null) {\n\t\t\t\t\tWptPt wpt = sf.getGpxFile().findPointToShow();\n\t\t\t\t\tif (wpt != null) {\n\t\t\t\t\t\tapp.getSettings().setMapLocationToShow(wpt.getLatitude(), wpt.getLongitude(), 15, null, false,\n\t\t\t\t\t\t\t\tfalse); //$NON-NLS-1$\n\t\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(activity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tbld.show();\n\t\t\n\t}","id":81907,"modified_method":"protected void selectSplitDistance() {\n\t\tfinal List<GpxDisplayGroup> groups = filterGroups(GpxDisplayItemType.TRACK_SEGMENT);\n\n\t\tView view = getMyActivity().getLayoutInflater().inflate(R.layout.selected_track_edit, null);\n\t\t\n\t\tfinal TIntArrayList list = new TIntArrayList();\n        final Spinner colorSpinner = (Spinner) view.findViewById(R.id.ColorSpinner);\n        ColorDialogs.setupColorSpinner(getActivity(), getGpx().getColor(0), colorSpinner, list);\n\t\t\n\t\t\n\t\tfinal Spinner sp = (Spinner) view.findViewById(R.id.Spinner);\n\t\tBuilder bld = new AlertDialog.Builder(getMyActivity());\n\t\tfinal List<Double> distanceSplit = new ArrayList<Double>();\n\t\tfinal TIntArrayList timeSplit = new TIntArrayList();\n\t\tif(groups.size() == 0) {\n\t\t\tsp.setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.GpxSpinnerRow).setVisibility(View.GONE);\n\t\t} else {\n\t\t\tsp.setVisibility(View.VISIBLE);\n\n\t\t\tint[] checkedItem = new int[] { !groups.get(0).isSplitDistance() && !groups.get(0).isSplitTime() ? 0 : -1 };\n\t\t\tList<String> options = new ArrayList<String>();\n\t\t\t\n\n\t\t\toptions.add(app.getString(R.string.none));\n\t\t\tdistanceSplit.add(-1d);\n\t\t\ttimeSplit.add(-1);\n\t\t\taddOptionSplit(30, true, options, distanceSplit, timeSplit, checkedItem, groups); // 100 feet, 50 yards, 50\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m\n\t\t\taddOptionSplit(60, true, options, distanceSplit, timeSplit, checkedItem, groups); // 200 feet, 100 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 100 m\n\t\t\taddOptionSplit(150, true, options, distanceSplit, timeSplit, checkedItem, groups); // 500 feet, 200 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 200 m\n\t\t\taddOptionSplit(300, true, options, distanceSplit, timeSplit, checkedItem, groups); // 1000 feet, 500 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 500 m\n\t\t\taddOptionSplit(600, true, options, distanceSplit, timeSplit, checkedItem, groups); // 2000 feet, 1000 yards,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1km\n\t\t\taddOptionSplit(1500, true, options, distanceSplit, timeSplit, checkedItem, groups); // 1mi, 2km\n\t\t\taddOptionSplit(3000, true, options, distanceSplit, timeSplit, checkedItem, groups); // 2mi, 5km\n\t\t\taddOptionSplit(8000, true, options, distanceSplit, timeSplit, checkedItem, groups); // 5mi, 10km\n\n\t\t\taddOptionSplit(15, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(30, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(60, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(120, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(150, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(300, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(600, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\t\t\taddOptionSplit(900, false, options, distanceSplit, timeSplit, checkedItem, groups);\n\n\t\t\tArrayAdapter<String> adapter = new ArrayAdapter<String>(getMyActivity(),\n\t\t\t\t\tandroid.R.layout.simple_spinner_item, options);\n\t\t\tadapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\t\tsp.setAdapter(adapter);\n\t\t\tif (checkedItem[0] > 0) {\n\t\t\t\tsp.setSelection(checkedItem[0]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal CheckBox vis = (CheckBox) view.findViewById(R.id.Visibility);\n\t\tvis.setChecked(app.getSelectedGpxHelper().getSelectedFileByPath(getGpx().path) != null);\n\t\t\n\t\tbld.setView(view);\n\t\tbld.setNegativeButton(R.string.shared_string_cancel, null);\n\t\tbld.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\tSelectedGpxFile sf = app.getSelectedGpxHelper().selectGpxFile(getGpx(), vis.isChecked(), false);\n\t\t\t\tint clr = list.get(colorSpinner.getSelectedItemPosition());\n\t\t\t\tif(clr != 0 ) {\n\t\t\t\t\tsf.getModifiableGpxFile().setColor(clr);\n\t\t\t\t\tsf.processPoints();\n\t\t\t\t}\n\t\t\t\tif (groups.size() > 0) {\n\t\t\t\t\tupdateSplit(groups, distanceSplit, timeSplit, sp.getSelectedItemPosition(), vis.isChecked() ? sf\n\t\t\t\t\t\t\t: null);\n\t\t\t\t}\n\t\t\t\tif(vis.isChecked() && sf.getGpxFile() != null) {\n\t\t\t\t\tWptPt wpt = sf.getGpxFile().findPointToShow();\n\t\t\t\t\tif (wpt != null) {\n\t\t\t\t\t\tapp.getSettings().setMapLocationToShow(wpt.getLatitude(), wpt.getLongitude(), 15, null, false,\n\t\t\t\t\t\t\t\tfalse); //$NON-NLS-1$\n\t\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(activity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tbld.show();\n\t\t\n\t}","commit_id":"a06ce588fc8e53d985c58f747a04d3217ec460c1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void register() throws RegistrationException\n    {\n        ComponentReference ref = \n            MuleManager.getInstance().getRegistry().getComponentReferenceInstance();\n\n        if (endpoint != null)\n            ref.setParentId(endpoint.getRegistryId());\n        else\n            ref.setParentId(MuleManager.getInstance().getRegistryId());\n\n        ref.setType(\"UMOTransformer\");\n        ref.setComponent(this);\n\n        registryId = \n            MuleManager.getInstance().getRegistry().registerComponent(ref);\n    }","id":81908,"modified_method":"public void register() throws RegistrationException\n    {\n        Registry registry = MuleManager.getInstance().getRegistry();\n        if (registry == null) throw new RegistrationException(\"No registry available\");\n        \n        ComponentReference ref = registry.getComponentReferenceInstance();\n\n        if (endpoint != null)\n            ref.setParentId(endpoint.getRegistryId());\n        else\n            ref.setParentId(MuleManager.getInstance().getRegistryId());\n\n        ref.setType(\"UMOTransformer\");\n        ref.setComponent(this);\n\n        registryId = \n            MuleManager.getInstance().getRegistry().registerComponent(ref);\n    }","commit_id":"3f8f4fbd1d3ff1d673ad1f4fe81096cba692e041","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Deactivate a servlet context helper.\n     * @param contextInfo A context info\n     */\n    private void deactivate(final ContextHandler handler)\n    {\n        this.httpService.unregisterContext(handler);\n\n        // context listeners last\n        final Map<ServiceReference<ServletContextListener>, ServletContextListenerInfo> listeners = new TreeMap<ServiceReference<ServletContextListener>, ServletContextListenerInfo>();\n        final Iterator<Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>>> i = this.servicesMap.entrySet().iterator();\n        while ( i.hasNext() )\n        {\n            final Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>> entry = i.next();\n            if ( entry.getValue().remove(handler) )\n            {\n                if ( entry.getKey() instanceof ServletContextListenerInfo )\n                {\n                    final ServletContextListenerInfo info = (ServletContextListenerInfo)entry.getKey();\n                    listeners.put(info.getServiceReference(), info);\n                }\n                else\n                {\n                    this.unregisterWhiteboardService(handler, entry.getKey());\n                }\n                if ( entry.getValue().isEmpty() ) {\n                    i.remove();\n                }\n            }\n        }\n        for(final ServletContextListenerInfo info : listeners.values())\n        {\n            handler.destroyed(info);\n        }\n        handler.deactivate();\n    }","id":81909,"modified_method":"/**\n     * Deactivate a servlet context helper.\n     * @param contextInfo A context info\n     */\n    private void deactivate(final ContextHandler handler)\n    {\n        // context listeners last\n        final Map<ServiceReference<ServletContextListener>, ServletContextListenerInfo> listeners = new TreeMap<ServiceReference<ServletContextListener>, ServletContextListenerInfo>();\n        final Iterator<Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>>> i = this.servicesMap.entrySet().iterator();\n        while ( i.hasNext() )\n        {\n            final Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>> entry = i.next();\n            if ( entry.getValue().remove(handler) )\n            {\n                if ( entry.getKey() instanceof ServletContextListenerInfo )\n                {\n                    final ServletContextListenerInfo info = (ServletContextListenerInfo)entry.getKey();\n                    listeners.put(info.getServiceReference(), info);\n                }\n                else\n                {\n                    this.unregisterWhiteboardService(handler, entry.getKey());\n                }\n                if ( entry.getValue().isEmpty() ) {\n                    i.remove();\n                }\n            }\n        }\n        for(final ServletContextListenerInfo info : listeners.values())\n        {\n            handler.destroyed(info);\n        }\n        handler.deactivate();\n\n        this.httpService.unregisterContext(handler);\n\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Register a filter\n     * @param contextInfo The servlet context helper info\n     * @param filterInfo The filter info\n     */\n    public void registerFilter(@Nonnull  final ContextHandler contextHandler,\n            @Nonnull final FilterInfo filterInfo)\n    {\n        final Filter filter = this.bundleContext.getServiceObjects(filterInfo.getServiceReference()).getService();\n        // TODO create failure DTO if null\n        if ( filter != null )\n        {\n            final FilterHandler handler = new FilterHandler(contextHandler.getContextInfo(),\n                    contextHandler.getServletContext(filterInfo.getServiceReference().getBundle()),\n                    filter,\n                    filterInfo);\n            try {\n                this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addFilter(handler);\n                contextHandler.addWhiteboardService(filterInfo);\n            } catch (final ServletException e) {\n                // TODO create failure DTO\n            }\n        }\n    }","id":81910,"modified_method":"/**\n     * Register a filter\n     * @param contextInfo The servlet context helper info\n     * @param filterInfo The filter info\n     */\n    public void registerFilter(@Nonnull  final ContextHandler contextHandler,\n            @Nonnull final FilterInfo filterInfo)\n    {\n        final Filter filter = this.bundleContext.getServiceObjects(filterInfo.getServiceReference()).getService();\n        // TODO create failure DTO if null\n        if ( filter != null )\n        {\n            final FilterHandler handler = new FilterHandler(contextHandler.getContextInfo(),\n                    contextHandler.getServletContext(filterInfo.getServiceReference().getBundle()),\n                    filter,\n                    filterInfo);\n            try {\n                final PerContextHandlerRegistry registry = this.handlerRegistry.getRegistry(contextHandler.getContextInfo());\n                if (registry != null )\n                {\n                    registry.addFilter(handler);\n                    contextHandler.addWhiteboardService(filterInfo);\n                }\n            } catch (final ServletException e) {\n                // TODO create failure DTO\n            }\n        }\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Unregister a filter\n     * @param contextInfo The servlet context helper info\n     * @param filterInfo The filter info\n     */\n    public void unregisterFilter(@Nonnull final ContextHandler contextHandler, @Nonnull final FilterInfo filterInfo)\n    {\n        final Filter instance = this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).removeFilter(filterInfo, true);\n        if ( instance != null )\n        {\n            this.bundleContext.getServiceObjects(filterInfo.getServiceReference()).ungetService(instance);\n            contextHandler.ungetServletContext(filterInfo.getServiceReference().getBundle());\n            contextHandler.removeWhiteboardService(filterInfo);\n        }\n    }","id":81911,"modified_method":"/**\n     * Unregister a filter\n     * @param contextInfo The servlet context helper info\n     * @param filterInfo The filter info\n     */\n    public void unregisterFilter(@Nonnull final ContextHandler contextHandler, @Nonnull final FilterInfo filterInfo)\n    {\n        final PerContextHandlerRegistry registry = this.handlerRegistry.getRegistry(contextHandler.getContextInfo());\n        if (registry != null )\n        {\n            final Filter instance = registry.removeFilter(filterInfo, true);\n            if ( instance != null )\n            {\n                this.bundleContext.getServiceObjects(filterInfo.getServiceReference()).ungetService(instance);\n            }\n        }\n        contextHandler.ungetServletContext(filterInfo.getServiceReference().getBundle());\n        contextHandler.removeWhiteboardService(filterInfo);\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Register a servlet.\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void registerServlet(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ServletInfo servletInfo)\n    {\n        final ServiceObjects<Servlet> so = this.bundleContext.getServiceObjects(servletInfo.getServiceReference());\n        if ( so != null )\n        {\n            final Servlet servlet = so.getService();\n            // TODO create failure DTO if null\n            if ( servlet != null )\n            {\n                final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                        contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                        servletInfo,\n                        servlet);\n                try {\n                    this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addServlet(handler);\n                    contextHandler.addWhiteboardService(servletInfo);\n                } catch (final ServletException e) {\n                    so.ungetService(servlet);\n                    // TODO create failure DTO\n                }\n            }\n        }\n    }","id":81912,"modified_method":"/**\n     * Register a servlet.\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void registerServlet(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ServletInfo servletInfo)\n    {\n        final ServiceObjects<Servlet> so = this.bundleContext.getServiceObjects(servletInfo.getServiceReference());\n        if ( so != null )\n        {\n            final Servlet servlet = so.getService();\n            // TODO create failure DTO if null\n            if ( servlet != null )\n            {\n                final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                        contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                        servletInfo,\n                        servlet);\n                try {\n                    final PerContextHandlerRegistry registry = this.handlerRegistry.getRegistry(contextHandler.getContextInfo());\n                    if (registry != null )\n                    {\n                        registry.addServlet(handler);\n                        contextHandler.addWhiteboardService(servletInfo);\n                    }\n                } catch (final ServletException e) {\n                    so.ungetService(servlet);\n                    // TODO create failure DTO\n                }\n            }\n        }\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Unregister a servlet\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void unregisterServlet(@Nonnull final ContextHandler contextHandler, @Nonnull final ServletInfo servletInfo)\n    {\n        final Servlet instance = this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).removeServlet(servletInfo, true);\n        if ( instance != null )\n        {\n            this.bundleContext.getServiceObjects(servletInfo.getServiceReference()).ungetService(instance);\n            contextHandler.ungetServletContext(servletInfo.getServiceReference().getBundle());\n            contextHandler.removeWhiteboardService(servletInfo);\n        }\n    }","id":81913,"modified_method":"/**\n     * Unregister a servlet\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void unregisterServlet(@Nonnull final ContextHandler contextHandler, @Nonnull final ServletInfo servletInfo)\n    {\n        final PerContextHandlerRegistry registry = this.handlerRegistry.getRegistry(contextHandler.getContextInfo());\n        if (registry != null )\n        {\n            final Servlet instance = registry.removeServlet(servletInfo, true);\n            if ( instance != null )\n            {\n                this.bundleContext.getServiceObjects(servletInfo.getServiceReference()).ungetService(instance);\n            }\n        }\n        contextHandler.ungetServletContext(servletInfo.getServiceReference().getBundle());\n        contextHandler.removeWhiteboardService(servletInfo);\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Register a resource.\n     * @param contextInfo The servlet context helper info\n     * @param resourceInfo The resource info\n     */\n    public void registerResource(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ResourceInfo resourceInfo)\n    {\n        final ServletInfo servletInfo = new ServletInfo(resourceInfo);\n\n        final Servlet servlet = new ResourceServlet(resourceInfo.getPrefix());\n        final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                servletInfo,\n                servlet);\n        try {\n            this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addServlet(handler);\n            contextHandler.addWhiteboardService(resourceInfo);\n        } catch (ServletException e) {\n            // TODO create failure DTO\n        }\n    }","id":81914,"modified_method":"/**\n     * Register a resource.\n     * @param contextInfo The servlet context helper info\n     * @param resourceInfo The resource info\n     */\n    public void registerResource(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ResourceInfo resourceInfo)\n    {\n        final ServletInfo servletInfo = new ServletInfo(resourceInfo);\n\n        final Servlet servlet = new ResourceServlet(resourceInfo.getPrefix());\n        final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                servletInfo,\n                servlet);\n        try {\n            final PerContextHandlerRegistry registry = this.handlerRegistry.getRegistry(contextHandler.getContextInfo());\n            if (registry != null )\n            {\n                registry.addServlet(handler);\n                contextHandler.addWhiteboardService(resourceInfo);\n            }\n        } catch (ServletException e) {\n            // TODO create failure DTO\n        }\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Unregister a resource.\n     * @param contextInfo The servlet context helper info\n     * @param resourceInfo The resource info\n     */\n    public void unregisterResource(@Nonnull final ContextHandler contextHandler, @Nonnull final ResourceInfo resourceInfo)\n    {\n        final ServletInfo servletInfo = new ServletInfo(resourceInfo);\n        this.unregisterServlet(contextHandler, servletInfo);\n        contextHandler.removeWhiteboardService(resourceInfo);\n    }","id":81915,"modified_method":"/**\n     * Unregister a resource.\n     * @param contextInfo The servlet context helper info\n     * @param resourceInfo The resource info\n     */\n    public void unregisterResource(@Nonnull final ContextHandler contextHandler, @Nonnull final ResourceInfo resourceInfo)\n    {\n        final ServletInfo servletInfo = new ServletInfo(resourceInfo);\n        final PerContextHandlerRegistry registry = this.handlerRegistry.getRegistry(contextHandler.getContextInfo());\n        if (registry != null )\n        {\n            registry.removeServlet(servletInfo, true);\n        }\n        contextHandler.ungetServletContext(servletInfo.getServiceReference().getBundle());\n        contextHandler.removeWhiteboardService(servletInfo);\n    }","commit_id":"8ebc48f02d16f2c3603bd77d10d295cb5bd6afec","url":"https://github.com/apache/felix"},{"original_method":"private static int processChildren(boolean isJUnit4,\n                                     List listeners,\n                                     SegmentedOutputStream out,\n                                     SegmentedOutputStream err,\n                                     List parameters,\n                                     IdeaTestRunner testRunner,\n                                     List children,\n                                     int result,\n                                     boolean forkTillMethod, File workingDir, String classpath, String dynamicClasspath) throws IOException, InterruptedException {\n    for (int i = 0, argsLength = children.size(); i < argsLength; i++) {\n      final Object child = children.get(i);\n      final List childTests = testRunner.getChildTests(child);\n      final int childResult;\n      if (childTests.isEmpty() || !forkTillMethod) {\n        final int startIndex = testRunner.getRegistry().getKnownObject(child);\n        childResult =\n          runChild(isJUnit4, listeners, out, err, parameters, testRunner.getStartDescription(child), workingDir, String.valueOf(startIndex), classpath, dynamicClasspath);\n      }\n      else {\n        childResult =\n          processChildren(isJUnit4, listeners, out, err, parameters, testRunner, childTests, result, forkTillMethod, workingDir, classpath, dynamicClasspath);\n      }\n      result = Math.min(childResult, result);\n    }\n    return result;\n  }","id":81916,"modified_method":"private static int processChildren(boolean isJUnit4,\n                                     List listeners,\n                                     SegmentedOutputStream out,\n                                     SegmentedOutputStream err,\n                                     List parameters,\n                                     IdeaTestRunner testRunner,\n                                     List children,\n                                     int result,\n                                     boolean forkTillMethod, File workingDir, String classpath, String dynamicClasspath) throws IOException, InterruptedException {\n    for (int i = 0, argsLength = children.size(); i < argsLength; i++) {\n      final Object child = children.get(i);\n      final List childTests = testRunner.getChildTests(child);\n      final int childResult;\n      if (childTests.isEmpty() || !forkTillMethod) {\n        final OutputObjectRegistry registry = testRunner.getRegistry();\n        final int startIndex = registry != null ? registry.getKnownObject(child) : -1;\n        childResult =\n          runChild(isJUnit4, listeners, out, err, parameters, testRunner.getStartDescription(child), workingDir, String.valueOf(startIndex), classpath, dynamicClasspath);\n      }\n      else {\n        childResult =\n          processChildren(isJUnit4, listeners, out, err, parameters, testRunner, childTests, result, forkTillMethod, workingDir, classpath, dynamicClasspath);\n      }\n      result = Math.min(childResult, result);\n    }\n    return result;\n  }","commit_id":"75b1558d091d72eed42c006be72fc165eac654a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static int startForkedVMs(String workingDirsPath,\n                            String[] args,\n                            boolean isJUnit4,\n                            List listeners,\n                            String params, SegmentedOutputStream out,\n                            SegmentedOutputStream err,\n                            String forkMode,\n                            String path) throws Exception {\n    final List parameters = new ArrayList();\n    final BufferedReader bufferedReader = new BufferedReader(new FileReader(path));\n    final String dynamicClasspath = bufferedReader.readLine();\n    try {\n      String line;\n      while ((line = bufferedReader.readLine()) != null) {\n        parameters.add(line);\n      }\n    }\n    finally {\n      bufferedReader.close();\n    }\n\n    IdeaTestRunner testRunner = (IdeaTestRunner)JUnitStarter.getAgentClass(isJUnit4).newInstance();\n    testRunner.setStreams(out, err, 0);\n    final Object description = testRunner.getTestToStart(args, params);\n    if (description == null) return -1;\n\n    TreeSender.sendTree(testRunner, description, true);\n\n    long time = System.currentTimeMillis();\n\n    int result = 0;\n    if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {\n       final List children = testRunner.getChildTests(description);\n       final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n       result = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, 0, forkTillMethod, null, System.getProperty(\"java.class.path\"), dynamicClasspath);\n    } else {\n      final BufferedReader perDirReader = new BufferedReader(new FileReader(workingDirsPath));\n      try {\n        final String packageName = perDirReader.readLine();\n        String workingDir;\n        while ((workingDir = perDirReader.readLine()) != null) {\n          final String classpath = perDirReader.readLine();\n          try {\n\n            List classNames = new ArrayList();\n            final int classNamesSize = Integer.parseInt(perDirReader.readLine());\n            for (int i = 0; i < classNamesSize; i++) {\n              String className = perDirReader.readLine();\n              if (className == null) {\n                System.err.println(\"Class name is expected. Working dir: \" + workingDir);\n                return -1;\n              }\n              classNames.add(className);\n            }\n\n            final Object rootDescriptor = findByClassName(testRunner, (String)classNames.get(0), description);\n            final int childResult;\n            final File dir = new File(workingDir);\n            if (forkMode.equals(\"none\")) {\n              File tempFile = File.createTempFile(\"idea_junit\", \".tmp\");\n              tempFile.deleteOnExit();\n              JUnitStarter.printClassesList(classNames, packageName + \", working directory: \\'\" + workingDir + \"\\'\", \"\", tempFile);\n              childResult =\n                runChild(isJUnit4, listeners, out, err, parameters, \"@\" + tempFile.getAbsolutePath(), dir,\n                         String.valueOf(testRunner.getRegistry().getKnownObject(rootDescriptor) - 1), classpath, dynamicClasspath);\n            } else {\n              final List children = new ArrayList(testRunner.getChildTests(description));\n              for (Iterator iterator = children.iterator(); iterator.hasNext(); ) {\n                if (!classNames.contains(testRunner.getTestClassName(iterator.next()))) {\n                  iterator.remove();\n                }\n              }\n              final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n              childResult = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, result, forkTillMethod, dir, classpath, dynamicClasspath);\n            }\n            result = Math.min(childResult, result);\n          }\n          catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      finally {\n        perDirReader.close();\n      }\n    }\n\n    time = System.currentTimeMillis() - time;\n    new TimeSender(testRunner.getRegistry()).printHeader(time);\n    return result;\n  }","id":81917,"modified_method":"static int startForkedVMs(String workingDirsPath,\n                            String[] args,\n                            boolean isJUnit4,\n                            List listeners,\n                            String params, SegmentedOutputStream out,\n                            SegmentedOutputStream err,\n                            String forkMode,\n                            String path) throws Exception {\n    final List parameters = new ArrayList();\n    final BufferedReader bufferedReader = new BufferedReader(new FileReader(path));\n    final String dynamicClasspath = bufferedReader.readLine();\n    try {\n      String line;\n      while ((line = bufferedReader.readLine()) != null) {\n        parameters.add(line);\n      }\n    }\n    finally {\n      bufferedReader.close();\n    }\n\n    IdeaTestRunner testRunner = (IdeaTestRunner)JUnitStarter.getAgentClass(isJUnit4).newInstance();\n    testRunner.setStreams(out, err, 0);\n    final Object description = testRunner.getTestToStart(args, params);\n    if (description == null) return -1;\n\n    TreeSender.sendTree(testRunner, description, !JUnitStarter.SM_RUNNER);\n\n    long time = System.currentTimeMillis();\n\n    int result = 0;\n    if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {\n       final List children = testRunner.getChildTests(description);\n       final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n       result = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, 0, forkTillMethod, null, System.getProperty(\"java.class.path\"), dynamicClasspath);\n    } else {\n      final BufferedReader perDirReader = new BufferedReader(new FileReader(workingDirsPath));\n      try {\n        final String packageName = perDirReader.readLine();\n        String workingDir;\n        while ((workingDir = perDirReader.readLine()) != null) {\n          final String classpath = perDirReader.readLine();\n          try {\n\n            List classNames = new ArrayList();\n            final int classNamesSize = Integer.parseInt(perDirReader.readLine());\n            for (int i = 0; i < classNamesSize; i++) {\n              String className = perDirReader.readLine();\n              if (className == null) {\n                System.err.println(\"Class name is expected. Working dir: \" + workingDir);\n                return -1;\n              }\n              classNames.add(className);\n            }\n\n            final Object rootDescriptor = findByClassName(testRunner, (String)classNames.get(0), description);\n            final int childResult;\n            final File dir = new File(workingDir);\n            if (forkMode.equals(\"none\")) {\n              File tempFile = File.createTempFile(\"idea_junit\", \".tmp\");\n              tempFile.deleteOnExit();\n              JUnitStarter.printClassesList(classNames, packageName + \", working directory: \\'\" + workingDir + \"\\'\", \"\", tempFile);\n              final OutputObjectRegistry registry = testRunner.getRegistry();\n              final String startIndex = String.valueOf(registry != null ? registry.getKnownObject(rootDescriptor) - 1 : -1);\n              childResult =\n                runChild(isJUnit4, listeners, out, err, parameters, \"@\" + tempFile.getAbsolutePath(), dir, startIndex, classpath, dynamicClasspath);\n            } else {\n              final List children = new ArrayList(testRunner.getChildTests(description));\n              for (Iterator iterator = children.iterator(); iterator.hasNext(); ) {\n                if (!classNames.contains(testRunner.getTestClassName(iterator.next()))) {\n                  iterator.remove();\n                }\n              }\n              final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n              childResult = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, result, forkTillMethod, dir, classpath, dynamicClasspath);\n            }\n            result = Math.min(childResult, result);\n          }\n          catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      finally {\n        perDirReader.close();\n      }\n    }\n\n    time = System.currentTimeMillis() - time;\n    if (!JUnitStarter.SM_RUNNER) new TimeSender(testRunner.getRegistry()).printHeader(time);\n    return result;\n  }","commit_id":"75b1558d091d72eed42c006be72fc165eac654a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        String oldName = System.getProperty(SystemProperties.KARAF_NAME);\n        if (containerName == null) {\n            containerName = oldName;\n        }\n\n        if (resolver != null) {\n            System.setProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY, resolver);\n        }\n\n        if (manualIp != null) {\n            System.setProperty(ZkDefs.MANUAL_IP, manualIp);\n        }\n\n        if (bindAddress != null) {\n            System.setProperty(ZkDefs.BIND_ADDRESS, bindAddress);\n        }\n\n        zookeeperPassword = zookeeperPassword != null ? zookeeperPassword : ShellUtils.retrieveFabricZookeeperPassword(session);\n        System.setProperty(ZkDefs.MINIMUM_PORT, String.valueOf(minimumPort));\n        System.setProperty(ZkDefs.MAXIMUM_PORT, String.valueOf(maximumPort));\n\n        if (!containerName.equals(oldName)) {\n            if (force || permissionToRenameContainer()) {\n                if (!registerContainer(containerName, zookeeperPassword, profile, force)) {\n                    System.err.print(\"A container with the name: \" + containerName + \" is already member of the cluster. You can specify a different name as an argument.\");\n                    return null;\n                }\n\n                System.setProperty(SystemProperties.KARAF_NAME, containerName);\n                System.setProperty(\"zookeeper.url\", zookeeperUrl);\n                //Rename the container\n                File file = new File(System.getProperty(\"karaf.base\") + \"/etc/system.properties\");\n                org.apache.felix.utils.properties.Properties props = new org.apache.felix.utils.properties.Properties(file);\n                props.put(SystemProperties.KARAF_NAME, containerName);\n                props.put(\"zookeeper.url\", zookeeperUrl);\n                props.put(\"zookeeper.password\", zookeeperPassword);\n                props.save();\n                //Install required bundles\n                if (!nonManaged) {\n                    installBundles();\n                }\n                org.osgi.service.cm.Configuration config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\");\n                Hashtable<String, Object> properties = new Hashtable<String, Object>();\n                properties.put(\"zookeeper.url\", zookeeperUrl);\n                properties.put(\"zookeeper.password\", zookeeperPassword);\n                config.setBundleLocation(null);\n                config.update(properties);\n\n                //Restart the container\n                System.setProperty(\"karaf.restart\", \"true\");\n                System.setProperty(\"karaf.restart.clean\", \"false\");\n                bundleContext.getBundle(0).stop();\n\n                return null;\n            } else {\n                return null;\n            }\n        } else {\n            if (!registerContainer(containerName, zookeeperPassword, profile, force)) {\n                System.err.println(\"A container with the name: \" + containerName + \" is already member of the cluster. You can specify a different name as an argument.\");\n                return null;\n            }\n            org.osgi.service.cm.Configuration config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\");\n            Hashtable<String, Object> properties = new Hashtable<String, Object>();\n            properties.put(\"zookeeper.url\", zookeeperUrl);\n            properties.put(\"zookeeper.password\", zookeeperPassword);\n            config.setBundleLocation(null);\n            config.update(properties);\n\n            installBundles();\n\n            return null;\n        }\n    }","id":81918,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        String oldName = System.getProperty(SystemProperties.KARAF_NAME);\n        if (containerName == null) {\n            containerName = oldName;\n        }\n\n        if (resolver != null) {\n            System.setProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY, resolver);\n        }\n\n        if (manualIp != null) {\n            System.setProperty(ZkDefs.MANUAL_IP, manualIp);\n        }\n\n        if (bindAddress != null) {\n            System.setProperty(ZkDefs.BIND_ADDRESS, bindAddress);\n        }\n\n        zookeeperPassword = zookeeperPassword != null ? zookeeperPassword : ShellUtils.retrieveFabricZookeeperPassword(session);\n        System.setProperty(ZkDefs.MINIMUM_PORT, String.valueOf(minimumPort));\n        System.setProperty(ZkDefs.MAXIMUM_PORT, String.valueOf(maximumPort));\n\n        if (!containerName.equals(oldName)) {\n            if (force || permissionToRenameContainer()) {\n                if (!registerContainer(containerName, zookeeperPassword, profile, force)) {\n                    System.err.print(\"A container with the name: \" + containerName + \" is already member of the cluster. You can specify a different name as an argument.\");\n                    return null;\n                }\n\n                System.setProperty(SystemProperties.KARAF_NAME, containerName);\n                System.setProperty(\"zookeeper.url\", zookeeperUrl);\n                System.setProperty(\"zookeeper.password\", zookeeperPassword);\n                //Rename the container\n                File file = new File(System.getProperty(\"karaf.base\") + \"/etc/system.properties\");\n                org.apache.felix.utils.properties.Properties props = new org.apache.felix.utils.properties.Properties(file);\n                props.put(SystemProperties.KARAF_NAME, containerName);\n                //Also pass zookeeper information so that the container can auto-join after the restart.\n                props.put(\"zookeeper.url\", zookeeperUrl);\n                props.put(\"zookeeper.password\", zookeeperPassword);\n                props.save();\n\n                if (!nonManaged) {\n                    installBundles();\n                }\n                //Restart the container\n                System.setProperty(\"karaf.restart\", \"true\");\n                System.setProperty(\"karaf.restart.clean\", \"false\");\n                bundleContext.getBundle(0).stop();\n\n                return null;\n            } else {\n                return null;\n            }\n        } else {\n            if (!registerContainer(containerName, zookeeperPassword, profile, force)) {\n                System.err.println(\"A container with the name: \" + containerName + \" is already member of the cluster. You can specify a different name as an argument.\");\n                return null;\n            }\n            org.osgi.service.cm.Configuration config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\");\n            Hashtable<String, Object> properties = new Hashtable<String, Object>();\n            properties.put(\"zookeeper.url\", zookeeperUrl);\n            properties.put(\"zookeeper.password\", zookeeperPassword);\n            config.setBundleLocation(null);\n            config.update(properties);\n            if (!nonManaged) {\n                installBundles();\n            }\n            return null;\n        }\n    }","commit_id":"41a9801e5e6fa5bb455fe1ba8e5245694251446b","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void testMessageSerialization() throws Exception\n    {\n        ObjectToXml t1 = createObject(ObjectToXml.class);\n        t1.setAcceptMuleMessage(true);\n\n        Map props = new HashMap();\n        props.put(\"object\", new Apple());\n        props.put(\"string\", \"hello\");\n        MuleMessage msg = new DefaultMuleMessage(\"test\", muleContext);\n        msg.setEncoding(\"UTF-8\");\n        msg.setCorrelationId(\"1234\");\n        msg.setProperty(\"number\", new Integer(1), PropertyScope.INVOCATION);\n\n        String xml = (String) t1.transform(msg);\n        assertNotNull(xml);\n\n        XmlToObject t2 = createObject(XmlToObject.class);\n\n        Object result = t2.transform(xml);\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessage);\n\n        msg = (MuleMessage) result;\n//TODO RM*\n//        assertEquals(\"test\", msg.getPayload());\n//        assertEquals(new Apple(), msg.getProperty(\"object\", PropertyScope.OUTBOUND));\n//        assertEquals(\"hello\", msg.getProperty(\"object\"));\n//        assertEquals(new Integer(1), msg.getProperty(\"number\", PropertyScope.INVOCATION));\n//        assertEquals(\"1234\", msg.getCorrelationId());\n//        assertEquals(\"UTF-8\", msg.getEncoding());\n\n    }","id":81919,"modified_method":"public void testMessageSerialization() throws Exception\n    {\n        ObjectToXml t1 = createObject(ObjectToXml.class);\n        t1.setAcceptMuleMessage(true);\n\n        MuleMessage msg = new DefaultMuleMessage(\"test\", muleContext);\n        msg.setEncoding(\"UTF-8\");\n        msg.setCorrelationId(\"1234\");\n        msg.setProperty(\"number\", new Integer(1), PropertyScope.INVOCATION);\n        msg.setProperty(\"object\", new Apple(), PropertyScope.OUTBOUND);\n        msg.setProperty(\"string\", \"hello\", PropertyScope.OUTBOUND);\n\n        String xml = (String) t1.transform(msg);\n        assertNotNull(xml);\n\n        XmlToObject t2 = createObject(XmlToObject.class);\n\n        Object result = t2.transform(xml);\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessage);\n\n        msg = (MuleMessage) result;\n\n        assertEquals(\"test\", msg.getPayload());\n        assertEquals(new Apple(), msg.getProperty(\"object\", PropertyScope.OUTBOUND));\n        assertEquals(\"hello\", msg.getProperty(\"string\"));\n        assertEquals(new Integer(1), msg.getProperty(\"number\", PropertyScope.INVOCATION));\n        assertEquals(\"1234\", msg.getCorrelationId());\n        assertEquals(\"UTF-8\", msg.getEncoding());\n\n    }","commit_id":"ac7469c38351465667d3134887c24d20100de8d3","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object read(QName name, T input, Class type) {\n        return JAXBEncoderDecoder.unmarshall(getJAXBContext(), getSchema(), input, name, type, \n                                             getAttachmentUnmarshaller(), unwrapJAXBElement);\n    }","id":81920,"modified_method":"public Object read(QName name, T input, Class type) {\n        return JAXBEncoderDecoder.unmarshall(createUnmarshaller(), input,\n                                             name, type, \n                                             unwrapJAXBElement);\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"public Object read(MessagePartInfo part, T reader) {\n        boolean honorJaxbAnnotation = false;\n        if (part != null && part.getProperty(\"honor.jaxb.annotations\") != null) {\n            honorJaxbAnnotation = (Boolean)part.getProperty(\"honor.jaxb.annotations\");\n        }\n        Annotation[] anns = getJAXBAnnotation(part);\n        if (honorJaxbAnnotation && anns.length > 0) {\n            //RpcLit will use the JAXB Bridge to unmarshall part message when it is \n            //annotated with @XmlList,@XmlAttachmentRef,@XmlJavaTypeAdapter\n            //TODO:Cache the JAXBRIContext\n            QName qname = new QName(null, part.getConcreteName().getLocalPart());\n            TypeReference typeReference = new TypeReference(qname, part.getTypeClass(), anns);\n            return JAXBEncoderDecoder.unmarshalWithBridge(typeReference, \n                                                          contextClasses,\n                                                          reader,\n                                                          getAttachmentUnmarshaller());\n        }\n        \n        return JAXBEncoderDecoder.unmarshall(getJAXBContext(), getSchema(), reader, part, \n                                             getAttachmentUnmarshaller(), unwrapJAXBElement);\n    }","id":81921,"modified_method":"public Object read(MessagePartInfo part, T reader) {\n        boolean honorJaxbAnnotation = false;\n        if (part != null && part.getProperty(\"honor.jaxb.annotations\") != null) {\n            honorJaxbAnnotation = (Boolean)part.getProperty(\"honor.jaxb.annotations\");\n        }\n        Annotation[] anns = getJAXBAnnotation(part);\n        if (honorJaxbAnnotation && anns.length > 0) {\n            //RpcLit will use the JAXB Bridge to unmarshall part message when it is \n            //annotated with @XmlList,@XmlAttachmentRef,@XmlJavaTypeAdapter\n            //TODO:Cache the JAXBRIContext\n            QName qname = new QName(null, part.getConcreteName().getLocalPart());\n            TypeReference typeReference = new TypeReference(qname, part.getTypeClass(), anns);\n            return JAXBEncoderDecoder.unmarshalWithBridge(typeReference, \n                                                          databinding.getContextClasses(),\n                                                          reader,\n                                                          getAttachmentUnmarshaller());\n        }\n        \n        return JAXBEncoderDecoder.unmarshall(createUnmarshaller(), reader, part, \n                                             unwrapJAXBElement);\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"public void write(Object obj, MessagePartInfo part, T output) {\n        boolean honorJaxbAnnotation = false;\n        if (part != null && part.getProperty(\"honor.jaxb.annotations\") != null) {\n            honorJaxbAnnotation = (Boolean)part.getProperty(\"honor.jaxb.annotations\");\n        }\n        \n        if (obj != null\n            || !(part.getXmlSchema() instanceof XmlSchemaElement)) {\n            \n            if (obj instanceof Exception \n                && part != null\n                && Boolean.TRUE.equals(part.getProperty(JAXBDataBinding.class.getName() \n                                                        + \".CUSTOM_EXCEPTION\"))) {\n                JAXBEncoderDecoder.marshallException(getJAXBContext(), getSchema(), (Exception)obj,\n                                                     part, output, getAttachmentMarshaller(),\n                                                     marshallerProperties);                \n            } else {\n                Annotation[] anns = getJAXBAnnotation(part);\n                if (!honorJaxbAnnotation || anns.length == 0) {\n                    JAXBEncoderDecoder.marshall(getJAXBContext(), getSchema(), obj, part, output,\n                                                getAttachmentMarshaller(), marshallerProperties);\n                } else if (honorJaxbAnnotation && anns.length > 0) {\n                    //RpcLit will use the JAXB Bridge to marshall part message when it is \n                    //annotated with @XmlList,@XmlAttachmentRef,@XmlJavaTypeAdapter\n                    //TODO:Cache the JAXBRIContext\n                    QName qname = new QName(null, part.getConcreteName().getLocalPart());\n                    TypeReference typeReference = new TypeReference(qname, part.getTypeClass(), anns);\n                    JAXBEncoderDecoder.marshalWithBridge(typeReference, contextClasses, obj, \n                                                         output, getAttachmentMarshaller());\n                }\n            }\n        } else if (obj == null && needToRender(obj, part)) {\n            JAXBEncoderDecoder.marshallNullElement(getJAXBContext(), getSchema(), output, part,\n                                                   marshallerProperties);\n        }\n    }","id":81922,"modified_method":"public void write(Object obj, MessagePartInfo part, T output) {\n        boolean honorJaxbAnnotation = false;\n        if (part != null && part.getProperty(\"honor.jaxb.annotations\") != null) {\n            honorJaxbAnnotation = (Boolean)part.getProperty(\"honor.jaxb.annotations\");\n        }\n        \n        if (obj != null\n            || !(part.getXmlSchema() instanceof XmlSchemaElement)) {\n            \n            if (obj instanceof Exception \n                && part != null\n                && Boolean.TRUE.equals(part.getProperty(JAXBDataBinding.class.getName() \n                                                        + \".CUSTOM_EXCEPTION\"))) {\n                JAXBEncoderDecoder.marshallException(createMarshaller(obj, part),\n                                                     (Exception)obj,\n                                                     part, \n                                                     output);                \n            } else {\n                Annotation[] anns = getJAXBAnnotation(part);\n                if (!honorJaxbAnnotation || anns.length == 0) {\n                    JAXBEncoderDecoder.marshall(createMarshaller(obj, part), obj, part, output);\n                } else if (honorJaxbAnnotation && anns.length > 0) {\n                    //RpcLit will use the JAXB Bridge to marshall part message when it is \n                    //annotated with @XmlList,@XmlAttachmentRef,@XmlJavaTypeAdapter\n                    //TODO:Cache the JAXBRIContext\n                    QName qname = new QName(null, part.getConcreteName().getLocalPart());\n                    TypeReference typeReference = new TypeReference(qname, part.getTypeClass(), anns);\n                    \n                    JAXBEncoderDecoder.marshalWithBridge(typeReference, \n                                                         databinding.getContextClasses(), \n                                                         obj, \n                                                         output, \n                                                         getAttachmentMarshaller());\n                }\n            }\n        } else if (obj == null && needToRender(obj, part)) {\n            JAXBEncoderDecoder.marshallNullElement(createMarshaller(obj, part),\n                                                   output, part);\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"private NamespacePrefixMapper getNamespacePrefixMapper() {\n        Map<String, String> mappings = getDeclaredNamespaceMappings();\n        if (mappings == null) {\n            mappings = Collections.emptyMap();\n        }\n\n        final Map<String, String> closedMappings = mappings;\n\n        NamespacePrefixMapper mapper = new NamespacePrefixMapper() {\n            @Override\n            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {\n                String prefix = closedMappings.get(namespaceUri);\n                if (prefix != null) {\n                    return prefix;\n                }\n                return suggestion;\n            }\n        };\n        return mapper;\n    }","id":81923,"modified_method":"public NamespacePrefixMapper getNamespacePrefixMapper() {\n        Map<String, String> mappings = getDeclaredNamespaceMappings();\n        if (mappings == null) {\n            mappings = Collections.emptyMap();\n        }\n\n        final Map<String, String> closedMappings = mappings;\n\n        NamespacePrefixMapper mapper = new NamespacePrefixMapper() {\n            @Override\n            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {\n                String prefix = closedMappings.get(namespaceUri);\n                if (prefix != null) {\n                    return prefix;\n                }\n                return suggestion;\n            }\n        };\n        return mapper;\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public <T> DataWriter<T> createWriter(Class<T> c) {\n        Map<String, Object> currentMarshallerProperties = new HashMap<String, Object>();\n        if (!marshallerProperties.containsKey(\"com.sun.xml.bind.namespacePrefixMapper\")) {\n            currentMarshallerProperties.put(\"com.sun.xml.bind.namespacePrefixMapper\",\n                                            getNamespacePrefixMapper());\n        }\n        currentMarshallerProperties.putAll(marshallerProperties);\n\n        Integer mtomThresholdInt = new Integer(getMtomThreshold());\n        if (c == XMLStreamWriter.class) {\n            DataWriterImpl<XMLStreamWriter> r \n                = new DataWriterImpl<XMLStreamWriter>(\n                    context,\n                    currentMarshallerProperties,\n                    contextClasses);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        } else if (c == OutputStream.class) {\n            DataWriterImpl<OutputStream> r = new DataWriterImpl<OutputStream>(context,\n                                                                              currentMarshallerProperties,\n                                                                              contextClasses);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        } else if (c == XMLEventWriter.class) {\n            DataWriterImpl<XMLEventWriter> r = new DataWriterImpl<XMLEventWriter>(\n                                                                                  context,\n                                                                                  currentMarshallerProperties,\n                                                                                  contextClasses);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        } else if (c == Node.class) {\n            DataWriterImpl<Node> r = new DataWriterImpl<Node>(context, currentMarshallerProperties,\n                                                              contextClasses);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        }\n        return null;\n    }","id":81924,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public <T> DataWriter<T> createWriter(Class<T> c) {\n\n        Integer mtomThresholdInt = new Integer(getMtomThreshold());\n        if (c == XMLStreamWriter.class) {\n            DataWriterImpl<XMLStreamWriter> r \n                = new DataWriterImpl<XMLStreamWriter>(this);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        } else if (c == OutputStream.class) {\n            DataWriterImpl<OutputStream> r = new DataWriterImpl<OutputStream>(this);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        } else if (c == XMLEventWriter.class) {\n            DataWriterImpl<XMLEventWriter> r = new DataWriterImpl<XMLEventWriter>(this);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        } else if (c == Node.class) {\n            DataWriterImpl<Node> r = new DataWriterImpl<Node>(this);\n            r.setMtomThreshold(mtomThresholdInt);\n            return (DataWriter<T>)r;\n        }\n        return null;\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public <T> DataReader<T> createReader(Class<T> c) {\n        DataReader<T> dr = null;\n        if (c == XMLStreamReader.class) {\n            dr = (DataReader<T>)new DataReaderImpl<XMLStreamReader>(context, contextClasses);\n        } else if (c == XMLEventReader.class) {\n            dr = (DataReader<T>)new DataReaderImpl<XMLEventReader>(context, contextClasses);\n        } else if (c == Node.class) {\n            dr = (DataReader<T>)new DataReaderImpl<Node>(context, contextClasses);\n        }\n\n        return dr;\n    }","id":81925,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public <T> DataReader<T> createReader(Class<T> c) {\n        DataReader<T> dr = null;\n        if (c == XMLStreamReader.class) {\n            dr = (DataReader<T>)new DataReaderImpl<XMLStreamReader>(this);\n        } else if (c == XMLEventReader.class) {\n            dr = (DataReader<T>)new DataReaderImpl<XMLEventReader>(this);\n        } else if (c == Node.class) {\n            dr = (DataReader<T>)new DataReaderImpl<Node>(this);\n        }\n\n        return dr;\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDeclaredNamespaceMapping() throws Exception {\n        JAXBDataBinding db = new JAXBDataBinding();\n        Map<String, String> nsMap = new HashMap<String, String>();\n        nsMap.put(\"uri:ultima:thule\", \"greenland\");\n        db.setNamespaceMap(nsMap);\n        Map<String, Object> contextProperties = new HashMap<String, Object>();\n        contextProperties.put(JAXBRIContext.DEFAULT_NAMESPACE_REMAP, \"uri:ultima:thule\");\n        db.setContextProperties(contextProperties);\n        Set<Class<?>> classes = new HashSet<Class<?>>();\n        classes.add(QualifiedBean.class);\n        db.setContext(db.createJAXBContext(classes));\n        DataWriter<XMLStreamWriter> writer = db.createWriter(XMLStreamWriter.class);\n        XMLOutputFactory writerFactory = XMLOutputFactory.newInstance();\n        StringWriter stringWriter = new StringWriter();\n        XMLStreamWriter xmlWriter = writerFactory.createXMLStreamWriter(stringWriter);\n        QualifiedBean bean = new QualifiedBean();\n        bean.setAriadne(\"spider\");\n        writer.write(bean, xmlWriter);\n        xmlWriter.flush();\n        String xml = stringWriter.toString();\n        assertTrue(xml.contains(\"greenland=\\\"uri:ultima:thule\"));\n    }","id":81926,"modified_method":"@Test\n    public void testDeclaredNamespaceMapping() throws Exception {\n        JAXBDataBinding db = new JAXBDataBinding();\n        Map<String, String> nsMap = new HashMap<String, String>();\n        nsMap.put(\"uri:ultima:thule\", \"greenland\");\n        db.setNamespaceMap(nsMap);\n        Map<String, Object> contextProperties = new HashMap<String, Object>();\n        contextProperties.put(JAXBRIContext.DEFAULT_NAMESPACE_REMAP, \"uri:ultima:thule\");\n        db.setContextProperties(contextProperties);\n        Set<Class<?>> classes = new HashSet<Class<?>>();\n        classes.add(QualifiedBean.class);\n        db.setContext(db.createJAXBContext(classes));\n        DataWriter<XMLStreamWriter> writer = db.createWriter(XMLStreamWriter.class);\n        XMLOutputFactory writerFactory = XMLOutputFactory.newInstance();\n        StringWriter stringWriter = new StringWriter();\n        XMLStreamWriter xmlWriter = writerFactory.createXMLStreamWriter(stringWriter);\n        QualifiedBean bean = new QualifiedBean();\n        bean.setAriadne(\"spider\");\n        writer.write(bean, xmlWriter);\n        xmlWriter.flush();\n        String xml = stringWriter.toString();\n        assertTrue(xml, xml.contains(\"greenland=\\\"uri:ultima:thule\"));\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"private static XMLStreamWriter getStreamWriter(Object source) throws Fault {\n        if (source instanceof XMLStreamWriter) {\n            return (XMLStreamWriter)source;\n        } else if (source instanceof OutputStream) {\n            return StaxUtils.createXMLStreamWriter((OutputStream)source);\n        } else if (source instanceof Node) {\n            return new W3CDOMStreamWriter((Element)source);\n        }\n        throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n    }","id":81927,"modified_method":"private static XMLStreamWriter getStreamWriter(Object source) throws Fault {\n        if (source instanceof XMLStreamWriter) {\n            return (XMLStreamWriter)source;\n        } else if (source instanceof OutputStream) {\n            return StaxUtils.createXMLStreamWriter((OutputStream)source);\n        } else if (source instanceof Node) {\n            return new W3CDOMStreamWriter((Element)source);\n        }\n        throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static Object unmarshall(JAXBContext context, Schema schema, Object source, MessagePartInfo part,\n                                    AttachmentUnmarshaller au, boolean unwrap) {\n        Class<?> clazz = part != null ? (Class)part.getTypeClass() : null;\n        if (clazz != null && Exception.class.isAssignableFrom(clazz) && part != null\n            && Boolean.TRUE.equals(part.getProperty(JAXBDataBinding.class.getName() + \".CUSTOM_EXCEPTION\"))) {\n            return unmarshallException(context, schema, source, part, au);\n        }\n\n        QName elName = part != null ? part.getConcreteName() : null;\n        if (clazz != null && clazz.isArray() && part != null\n            && part.getXmlSchema() instanceof XmlSchemaElement) {\n            XmlSchemaElement el = (XmlSchemaElement)part.getXmlSchema();\n\n            if (el.getSchemaType() instanceof XmlSchemaSimpleType\n                && ((XmlSchemaSimpleType)el.getSchemaType()).getContent() \n                instanceof XmlSchemaSimpleTypeList) {\n\n                Object obj = unmarshall(context, schema, source, elName, null, au, unwrap);\n                if (clazz.isArray() && obj instanceof List) {\n                    return ((List)obj).toArray((Object[])Array.newInstance(clazz.getComponentType(),\n                                                                           ((List)obj).size()));\n                }\n\n                return obj;\n            } else if (part.getMessageInfo().getOperation().isUnwrapped() && el.getMaxOccurs() != 1) {\n                // must read ourselves....\n                List<Object> ret = unmarshallArray(context, schema, source, elName, clazz.getComponentType(),\n                                                   au, createList(part));\n                Object o = ret;\n                if (!isList(part)) {\n                    if (clazz.getComponentType().isPrimitive()) {\n                        o = java.lang.reflect.Array.newInstance(clazz.getComponentType(), ret.size());\n                        for (int x = 0; x < ret.size(); x++) {\n                            Array.set(o, x, ret.get(x));\n                        }\n                    } else {\n                        o = ret.toArray((Object[])Array.newInstance(clazz.getComponentType(), ret.size()));\n                    }\n                }\n                return o;\n            }\n        } else if (byte[].class == clazz && part != null && part.getTypeQName() != null\n                   && part.getTypeQName().getLocalPart().equals(\"hexBinary\")) {\n\n            String obj = (String)unmarshall(context, schema, source, elName, String.class, au, unwrap);\n            return new HexBinaryAdapter().unmarshal(obj);\n        }\n\n        Object o = unmarshall(context, schema, source, elName, clazz, au, unwrap);\n        if (o != null && o.getClass().isArray() && isList(part)) {\n            List<Object> ret = createList(part);\n            ret.addAll(Arrays.asList((Object[])o));\n            o = ret;\n        }\n        return o;\n    }","id":81928,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static Object unmarshall(Unmarshaller u, \n                                    Object source, \n                                    MessagePartInfo part,\n                                    boolean unwrap) {\n        Class<?> clazz = part != null ? (Class)part.getTypeClass() : null;\n        if (clazz != null && Exception.class.isAssignableFrom(clazz) && part != null\n            && Boolean.TRUE.equals(part.getProperty(JAXBDataBinding.class.getName() + \".CUSTOM_EXCEPTION\"))) {\n            return unmarshallException(u, source, part);\n        }\n\n        QName elName = part != null ? part.getConcreteName() : null;\n        if (clazz != null && clazz.isArray() && part != null\n            && part.getXmlSchema() instanceof XmlSchemaElement) {\n            XmlSchemaElement el = (XmlSchemaElement)part.getXmlSchema();\n\n            if (el.getSchemaType() instanceof XmlSchemaSimpleType\n                && ((XmlSchemaSimpleType)el.getSchemaType()).getContent() \n                instanceof XmlSchemaSimpleTypeList) {\n\n                Object obj = unmarshall(u, source, elName, null, unwrap);\n                if (clazz.isArray() && obj instanceof List) {\n                    return ((List)obj).toArray((Object[])Array.newInstance(clazz.getComponentType(),\n                                                                           ((List)obj).size()));\n                }\n\n                return obj;\n            } else if (part.getMessageInfo().getOperation().isUnwrapped() && el.getMaxOccurs() != 1) {\n                // must read ourselves....\n                List<Object> ret = unmarshallArray(u, source, elName, clazz.getComponentType(),\n                                                   createList(part));\n                Object o = ret;\n                if (!isList(part)) {\n                    if (clazz.getComponentType().isPrimitive()) {\n                        o = java.lang.reflect.Array.newInstance(clazz.getComponentType(), ret.size());\n                        for (int x = 0; x < ret.size(); x++) {\n                            Array.set(o, x, ret.get(x));\n                        }\n                    } else {\n                        o = ret.toArray((Object[])Array.newInstance(clazz.getComponentType(), ret.size()));\n                    }\n                }\n                return o;\n            }\n        } else if (byte[].class == clazz && part != null && part.getTypeQName() != null\n                   && part.getTypeQName().getLocalPart().equals(\"hexBinary\")) {\n\n            String obj = (String)unmarshall(u, source, elName, String.class, unwrap);\n            return new HexBinaryAdapter().unmarshal(obj);\n        }\n\n        Object o = unmarshall(u, source, elName, clazz, unwrap);\n        if (o != null && o.getClass().isArray() && isList(part)) {\n            List<Object> ret = createList(part);\n            ret.addAll(Arrays.asList((Object[])o));\n            o = ret;\n        }\n        return o;\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"private static void writeObject(Marshaller u, Object source, Object mObj) throws Fault, JAXBException {\n        if (source instanceof XMLStreamWriter) {\n            u.marshal(mObj, (XMLStreamWriter)source);\n        } else if (source instanceof OutputStream) {\n            u.marshal(mObj, (OutputStream)source);\n        } else if (source instanceof Node) {\n            u.marshal(mObj, (Node)source);\n        } else if (source instanceof XMLEventWriter) {\n            u.marshal(mObj, (XMLEventWriter)source);\n        } else {\n            throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n        }\n    }","id":81929,"modified_method":"private static void writeObject(Marshaller u, Object source, Object mObj) throws Fault, JAXBException {\n        if (source instanceof XMLStreamWriter) {\n            u.marshal(mObj, (XMLStreamWriter)source);\n        } else if (source instanceof OutputStream) {\n            u.marshal(mObj, (OutputStream)source);\n        } else if (source instanceof Node) {\n            u.marshal(mObj, (Node)source);\n        } else if (source instanceof XMLEventWriter) {\n            u.marshal(mObj, (XMLEventWriter)source);\n        } else {\n            throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"public static Object unmarshall(JAXBContext context, Schema schema, Object source, QName elName,\n                                    Class<?> clazz, AttachmentUnmarshaller au, boolean unwrap) {\n        Object obj = null;\n\n        try {\n            Unmarshaller u = createUnmarshaller(context, clazz);\n            u.setSchema(schema);\n            if (au != null) {\n                u.setAttachmentUnmarshaller(au);\n            }\n            boolean unmarshalWithClass = true;\n\n            if (clazz == null\n                || (!clazz.isPrimitive() && !clazz.isArray() && !clazz.isEnum() && (Modifier.isAbstract(clazz\n                    .getModifiers()) || Modifier.isInterface(clazz.getModifiers())))) {\n                unmarshalWithClass = false;\n            }\n\n            if (clazz != null\n                && (clazz.getName().equals(\"javax.xml.datatype.XMLGregorianCalendar\") || clazz.getName()\n                    .equals(\"javax.xml.datatype.Duration\"))) {\n                // special treat two jaxb defined built-in abstract types\n                unmarshalWithClass = true;\n            }\n            if (source instanceof Node) {\n                obj = unmarshalWithClass ? u.unmarshal((Node)source, clazz) : u.unmarshal((Node)source);\n            } else if (source instanceof XMLStreamReader) {\n\n                obj = unmarshalWithClass ? u.unmarshal((XMLStreamReader)source, clazz) : u\n                    .unmarshal((XMLStreamReader)source);\n            } else if (source instanceof XMLEventReader) {\n                obj = unmarshalWithClass ? u.unmarshal((XMLEventReader)source, clazz) : u\n                    .unmarshal((XMLEventReader)source);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n            }\n        } catch (Fault ex) {\n            ex.fillInStackTrace();\n            throw ex;\n        } catch (Throwable ex) {\n            if (ex instanceof javax.xml.bind.UnmarshalException) {\n                javax.xml.bind.UnmarshalException unmarshalEx = (javax.xml.bind.UnmarshalException)ex;\n                if (unmarshalEx.getLinkedException() != null) {\n                    throw new Fault(new Message(\"UNMARSHAL_ERROR\", BUNDLE, \n                                            unmarshalEx.getLinkedException().getMessage()), ex);\n                } else {\n                    throw new Fault(new Message(\"UNMARSHAL_ERROR\", BUNDLE, \n                                                unmarshalEx.getMessage()), ex);                    \n                }\n            } else {\n                throw new Fault(new Message(\"UNMARSHAL_ERROR\", BUNDLE, ex.getMessage()), ex);\n            }\n        }\n        return unwrap ? getElementValue(obj) : obj;\n    }","id":81930,"modified_method":"public static Object unmarshall(Unmarshaller u, Object source, QName elName,\n                                    Class<?> clazz, boolean unwrap) {\n        Object obj = null;\n\n        try {\n            boolean unmarshalWithClass = true;\n\n            if (clazz == null\n                || (!clazz.isPrimitive() && !clazz.isArray() && !clazz.isEnum() && (Modifier.isAbstract(clazz\n                    .getModifiers()) || Modifier.isInterface(clazz.getModifiers())))) {\n                unmarshalWithClass = false;\n            }\n\n            if (clazz != null\n                && (clazz.getName().equals(\"javax.xml.datatype.XMLGregorianCalendar\") || clazz.getName()\n                    .equals(\"javax.xml.datatype.Duration\"))) {\n                // special treat two jaxb defined built-in abstract types\n                unmarshalWithClass = true;\n            }\n            if (source instanceof Node) {\n                obj = unmarshalWithClass ? u.unmarshal((Node)source, clazz) : u.unmarshal((Node)source);\n            } else if (source instanceof XMLStreamReader) {\n\n                obj = unmarshalWithClass ? u.unmarshal((XMLStreamReader)source, clazz) : u\n                    .unmarshal((XMLStreamReader)source);\n            } else if (source instanceof XMLEventReader) {\n                obj = unmarshalWithClass ? u.unmarshal((XMLEventReader)source, clazz) : u\n                    .unmarshal((XMLEventReader)source);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n            }\n        } catch (Fault ex) {\n            ex.fillInStackTrace();\n            throw ex;\n        } catch (Throwable ex) {\n            if (ex instanceof javax.xml.bind.UnmarshalException) {\n                javax.xml.bind.UnmarshalException unmarshalEx = (javax.xml.bind.UnmarshalException)ex;\n                if (unmarshalEx.getLinkedException() != null) {\n                    throw new Fault(new Message(\"UNMARSHAL_ERROR\", LOG, \n                                            unmarshalEx.getLinkedException().getMessage()), ex);\n                } else {\n                    throw new Fault(new Message(\"UNMARSHAL_ERROR\", LOG, \n                                                unmarshalEx.getMessage()), ex);                    \n                }\n            } else {\n                throw new Fault(new Message(\"UNMARSHAL_ERROR\", LOG, ex.getMessage()), ex);\n            }\n        }\n        return unwrap ? getElementValue(obj) : obj;\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshallException(JAXBContext context, Schema schema, Exception elValue,\n                                         MessagePartInfo part, Object source, AttachmentMarshaller am,\n                                         Map<String, Object> marshallerProperties) {\n        XMLStreamWriter writer = getStreamWriter(source);\n        QName qn = part.getElementQName();\n        try {\n            writer.writeStartElement(\"ns1\", qn.getLocalPart(), qn.getNamespaceURI());\n            Class<?> cls = part.getTypeClass();\n            XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);\n            if (accessorType == null && cls.getPackage() != null) {\n                accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);\n            }\n            XmlAccessType accessType = accessorType != null\n                ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;\n            String namespace = part.getElementQName().getNamespaceURI();\n            \n            SchemaInfo sch = part.getMessageInfo().getOperation().getInterface()\n                .getService().getSchema(namespace);\n            if (!sch.isElementFormQualified()) {\n                namespace = null;\n            }\n            \n            \n            Marshaller u = createMarshaller(context, cls, marshallerProperties);\n            try {\n                // override anything the user asked us to set.\n                // The Marshaller.JAXB_FRAGMENT will tell the Marshaller not to\n                // generate the xml declaration.\n                u.setProperty(Marshaller.JAXB_FRAGMENT, true);\n                u.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, false);\n            } catch (javax.xml.bind.PropertyException e) {\n                // intentionally empty.\n            }\n\n            for (Field f : cls.getDeclaredFields()) {\n                if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {\n                    QName fname = new QName(namespace, f.getName());\n                    f.setAccessible(true);\n                    writeObject(u, writer, new JAXBElement(fname, String.class, f.get(elValue)));\n                }\n            }\n            for (Method m : cls.getMethods()) {\n                if (JAXBContextInitializer.isMethodAccepted(m, accessType)) {\n                    int idx = m.getName().startsWith(\"get\") ? 3 : 2;\n                    String name = m.getName().substring(idx);\n                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n                    QName mname = new QName(namespace, name);\n                    writeObject(u, writer, new JAXBElement(mname, String.class, m.invoke(elValue)));\n                }\n            }\n\n            writer.writeEndElement();\n            writer.flush();\n        } catch (Exception e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", BUNDLE, e.getMessage()), e);\n        }\n    }","id":81931,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshallException(Marshaller marshaller, Exception elValue,\n                                         MessagePartInfo part, Object source) {\n        XMLStreamWriter writer = getStreamWriter(source);\n        QName qn = part.getElementQName();\n        try {\n            writer.writeStartElement(\"ns1\", qn.getLocalPart(), qn.getNamespaceURI());\n            Class<?> cls = part.getTypeClass();\n            XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);\n            if (accessorType == null && cls.getPackage() != null) {\n                accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);\n            }\n            XmlAccessType accessType = accessorType != null\n                ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;\n            String namespace = part.getElementQName().getNamespaceURI();\n            \n            SchemaInfo sch = part.getMessageInfo().getOperation().getInterface()\n                .getService().getSchema(namespace);\n            if (!sch.isElementFormQualified()) {\n                namespace = null;\n            }\n            \n            for (Field f : cls.getDeclaredFields()) {\n                if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {\n                    QName fname = new QName(namespace, f.getName());\n                    f.setAccessible(true);\n                    writeObject(marshaller, writer, new JAXBElement(fname, String.class, f.get(elValue)));\n                }\n            }\n            for (Method m : cls.getMethods()) {\n                if (JAXBContextInitializer.isMethodAccepted(m, accessType)) {\n                    int idx = m.getName().startsWith(\"get\") ? 3 : 2;\n                    String name = m.getName().substring(idx);\n                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n                    QName mname = new QName(namespace, name);\n                    writeObject(marshaller, writer, new JAXBElement(mname, String.class, m.invoke(elValue)));\n                }\n            }\n\n            writer.writeEndElement();\n            writer.flush();\n        } catch (Exception e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, e.getMessage()), e);\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"public static void marshall(JAXBContext context, Schema schema, Object elValue, MessagePartInfo part,\n                                Object source, Map<String, Object> marshallerProperties) {\n        marshall(context, schema, elValue, part, source, null, marshallerProperties);\n    }","id":81932,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshall(Marshaller marshaller, \n                                Object elValue, \n                                MessagePartInfo part,\n                                Object source) {\n        try {\n            // The Marshaller.JAXB_FRAGMENT will tell the Marshaller not to\n            // generate the xml declaration.\n            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, false);\n        } catch (javax.xml.bind.PropertyException e) {\n            // intentionally empty.\n        }\n        \n        Class<?> cls = null;\n        if (part != null) {\n            cls = part.getTypeClass();\n        }\n\n        if (cls == null) {\n            cls = null != elValue ? elValue.getClass() : null;\n        }\n\n        if (cls != null && cls.isArray() && elValue instanceof Collection) {\n            Collection<?> col = (Collection<?>)elValue;\n            elValue = col.toArray((Object[])Array.newInstance(cls.getComponentType(), col.size()));\n        }\n\n        try {\n            Object mObj = elValue;\n            QName elName = null;\n            if (part != null) {\n                elName = part.getConcreteName();\n            }\n\n            if (null != elName) {\n\n                if (part != null && part.getXmlSchema() instanceof XmlSchemaElement) {\n\n                    XmlSchemaElement el = (XmlSchemaElement)part.getXmlSchema();\n\n                    if (mObj.getClass().isArray()\n                        && el.getSchemaType() instanceof XmlSchemaSimpleType\n                        && ((XmlSchemaSimpleType)el.getSchemaType()).\n                        getContent() instanceof XmlSchemaSimpleTypeList) {\n                        mObj = Arrays.asList((Object[])mObj);\n                        writeObject(marshaller, source, new JAXBElement(elName, cls, mObj));\n                    } else if (part.getMessageInfo().getOperation().isUnwrapped()\n                               && (mObj.getClass().isArray() || mObj instanceof List)\n                               && el.getMaxOccurs() != 1) {\n                        // Have to handle this ourselves.... which really\n                        // sucks.... but what can we do?\n                        Object objArray;\n                        if (mObj instanceof List) {\n                            List l = (List)mObj;\n                            objArray = l.toArray(new Object[l.size()]);\n                            cls = null;\n                        } else {\n                            objArray = mObj;\n                            cls = objArray.getClass().getComponentType();\n                        }\n                        int len = Array.getLength(objArray);\n                        for (int x = 0; x < len; x++) {\n                            Object o = Array.get(objArray, x);\n                            writeObject(marshaller, source, \n                                        new JAXBElement(elName, cls == null ? o.getClass() : cls,\n                                                                   o));\n                        }\n                    } else {\n                        writeObject(marshaller, source, new JAXBElement(elName, cls, mObj));\n                    }\n                } else if (byte[].class == cls && part.getTypeQName() != null\n                           && part.getTypeQName().getLocalPart().equals(\"hexBinary\")) {\n                    mObj = new HexBinaryAdapter().marshal((byte[])mObj);\n                    writeObject(marshaller, source, new JAXBElement(elName, String.class, mObj));\n                } else {\n                    writeObject(marshaller, source, new JAXBElement(elName, cls, mObj));\n                }\n            } else {\n                writeObject(marshaller, source, mObj);\n            }\n        } catch (Fault ex) {\n            throw (Fault)ex.fillInStackTrace();\n        } catch (Exception ex) {\n            if (ex instanceof javax.xml.bind.MarshalException) {\n                javax.xml.bind.MarshalException marshalEx = (javax.xml.bind.MarshalException)ex;\n                Message faultMessage = new Message(\"MARSHAL_ERROR\", LOG, marshalEx.getLinkedException()\n                    .getMessage());\n                throw new Fault(faultMessage, ex);\n            } else {\n                throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, ex.getMessage()), ex);\n            }\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"public static List<Object> unmarshallArray(JAXBContext context, Schema schema, Object source,\n                                               QName elName, Class<?> clazz, AttachmentUnmarshaller au,\n                                               List<Object> ret) {\n        try {\n            Unmarshaller u = createUnmarshaller(context, clazz);\n            u.setSchema(schema);\n            if (au != null) {\n                u.setAttachmentUnmarshaller(au);\n            }\n            XMLStreamReader reader;\n            if (source instanceof XMLStreamReader) {\n                reader = (XMLStreamReader)source;\n            } else if (source instanceof Element) {\n                reader = StaxUtils.createXMLStreamReader((Element)source);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n            }\n            while (reader.getName().equals(elName)) {\n                Object obj = u.unmarshal(reader, clazz);\n                if (obj instanceof JAXBElement) {\n                    obj = ((JAXBElement)obj).getValue();\n                }\n                ret.add(obj);\n                while (reader.getEventType() != XMLStreamConstants.START_ELEMENT \n                    && reader.getEventType() != XMLStreamConstants.END_ELEMENT) {\n                    reader.nextTag();\n                }\n            }\n            return ret;\n        } catch (Fault ex) {\n            ex.fillInStackTrace();\n            throw ex;\n        } catch (Exception ex) {\n            if (ex instanceof javax.xml.bind.UnmarshalException) {\n                javax.xml.bind.UnmarshalException unmarshalEx = (javax.xml.bind.UnmarshalException)ex;\n                throw new Fault(new Message(\"UNMARSHAL_ERROR\", BUNDLE, unmarshalEx.getLinkedException()\n                    .getMessage()), ex);\n            } else {\n                throw new Fault(new Message(\"UNMARSHAL_ERROR\", BUNDLE, ex.getMessage()), ex);\n            }\n        }\n    }","id":81933,"modified_method":"public static List<Object> unmarshallArray(Unmarshaller u, Object source,\n                                               QName elName, Class<?> clazz,\n                                               List<Object> ret) {\n        try {\n            XMLStreamReader reader;\n            if (source instanceof XMLStreamReader) {\n                reader = (XMLStreamReader)source;\n            } else if (source instanceof Element) {\n                reader = StaxUtils.createXMLStreamReader((Element)source);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n            }\n            while (reader.getName().equals(elName)) {\n                Object obj = u.unmarshal(reader, clazz);\n                if (obj instanceof JAXBElement) {\n                    obj = ((JAXBElement)obj).getValue();\n                }\n                ret.add(obj);\n                while (reader.getEventType() != XMLStreamConstants.START_ELEMENT \n                    && reader.getEventType() != XMLStreamConstants.END_ELEMENT) {\n                    reader.nextTag();\n                }\n            }\n            return ret;\n        } catch (Fault ex) {\n            ex.fillInStackTrace();\n            throw ex;\n        } catch (Exception ex) {\n            if (ex instanceof javax.xml.bind.UnmarshalException) {\n                javax.xml.bind.UnmarshalException unmarshalEx = (javax.xml.bind.UnmarshalException)ex;\n                throw new Fault(new Message(\"UNMARSHAL_ERROR\", LOG, unmarshalEx.getLinkedException()\n                    .getMessage()), ex);\n            } else {\n                throw new Fault(new Message(\"UNMARSHAL_ERROR\", LOG, ex.getMessage()), ex);\n            }\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshalWithBridge(TypeReference ref,\n                                         Set<Class<?>> ctxClasses,\n                                         Object elValue,\n                                         Object source, AttachmentMarshaller am) {\n        List<TypeReference> typeRefs = new ArrayList<TypeReference>();\n        typeRefs.add(ref);\n        List<Class<?>> clses = new ArrayList<Class<?>>(ctxClasses);\n        clses.add(ref.type.getClass());\n        try {\n            JAXBRIContext riContext = JAXBRIContext.newInstance(clses.toArray(new Class[clses.size()]),\n                                                                    typeRefs, null, null, true, null);\n            Bridge bridge = riContext.createBridge(ref);\n\n            if (source instanceof XMLStreamWriter) {\n                bridge.marshal(elValue, (XMLStreamWriter)source);\n            } else if (source instanceof OutputStream) {\n                //the namespace is missing when marshal the xsd:QName type \n                //to the OutputStream directly \n                java.io.StringWriter sw = new java.io.StringWriter();\n                StreamResult s1 = new StreamResult(sw);\n                bridge.marshal(elValue, s1);\n                ((OutputStream)source).write(sw.toString().getBytes());\n            } else if (source instanceof Node) {\n                bridge.marshal(elValue, (Node)source);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            if (ex instanceof javax.xml.bind.MarshalException) {\n                javax.xml.bind.MarshalException marshalEx = (javax.xml.bind.MarshalException)ex;\n                Message faultMessage = new Message(\"MARSHAL_ERROR\", BUNDLE, marshalEx.getLinkedException()\n                    .getMessage());\n                throw new Fault(faultMessage, ex);\n            } else {\n                throw new Fault(new Message(\"MARSHAL_ERROR\", BUNDLE, ex.getMessage()), ex);\n            }\n        }\n\n    }","id":81934,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshalWithBridge(TypeReference ref,\n                                         Set<Class<?>> ctxClasses,\n                                         Object elValue,\n                                         Object source, AttachmentMarshaller am) {\n        List<TypeReference> typeRefs = new ArrayList<TypeReference>();\n        typeRefs.add(ref);\n        List<Class<?>> clses = new ArrayList<Class<?>>(ctxClasses);\n        clses.add(ref.type.getClass());\n        try {\n            JAXBRIContext riContext = JAXBRIContext.newInstance(clses.toArray(new Class[clses.size()]),\n                                                                    typeRefs, null, null, true, null);\n            Bridge bridge = riContext.createBridge(ref);\n\n            if (source instanceof XMLStreamWriter) {\n                bridge.marshal(elValue, (XMLStreamWriter)source);\n            } else if (source instanceof OutputStream) {\n                //the namespace is missing when marshal the xsd:QName type \n                //to the OutputStream directly \n                java.io.StringWriter sw = new java.io.StringWriter();\n                StreamResult s1 = new StreamResult(sw);\n                bridge.marshal(elValue, s1);\n                ((OutputStream)source).write(sw.toString().getBytes());\n            } else if (source instanceof Node) {\n                bridge.marshal(elValue, (Node)source);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            if (ex instanceof javax.xml.bind.MarshalException) {\n                javax.xml.bind.MarshalException marshalEx = (javax.xml.bind.MarshalException)ex;\n                Message faultMessage = new Message(\"MARSHAL_ERROR\", LOG, marshalEx.getLinkedException()\n                    .getMessage());\n                throw new Fault(faultMessage, ex);\n            } else {\n                throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, ex.getMessage()), ex);\n            }\n        }\n\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static Object unmarshalWithBridge(TypeReference ref,\n                                             Set<Class<?>> ctxClasses,\n                                             Object source,\n                                             AttachmentUnmarshaller am) {\n        List<TypeReference> typeRefs = new ArrayList<TypeReference>();\n        typeRefs.add(ref);\n        List<Class<?>> clses = new ArrayList<Class<?>>(ctxClasses);\n        clses.add(ref.type.getClass());\n        try {\n            JAXBRIContext riContext = JAXBRIContext.newInstance(clses.toArray(new Class[clses.size()]),\n                                                                    typeRefs, null, null, true, null);\n            Bridge bridge = riContext.createBridge(ref);\n           \n            if (source instanceof XMLStreamReader) {\n                //DOMUtils.writeXml(StaxUtils.read((XMLStreamReader)source), System.out);\n                return bridge.unmarshal((XMLStreamReader)source);               \n            } else if (source instanceof InputStream) {\n                return bridge.unmarshal((InputStream)source);\n            } else if (source instanceof Node) {\n                return bridge.unmarshal((Node)source, am);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n            }\n        } catch (Exception ex) {\n            if (ex instanceof javax.xml.bind.MarshalException) {\n                javax.xml.bind.MarshalException marshalEx = (javax.xml.bind.MarshalException)ex;\n                Message faultMessage = new Message(\"MARSHAL_ERROR\", BUNDLE, marshalEx.getLinkedException()\n                    .getMessage());\n                throw new Fault(faultMessage, ex);\n            } else {\n                throw new Fault(new Message(\"MARSHAL_ERROR\", BUNDLE, ex.getMessage()), ex);\n            }\n        }\n\n    }","id":81935,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static Object unmarshalWithBridge(TypeReference ref,\n                                             Set<Class<?>> ctxClasses,\n                                             Object source,\n                                             AttachmentUnmarshaller am) {\n        List<TypeReference> typeRefs = new ArrayList<TypeReference>();\n        typeRefs.add(ref);\n        List<Class<?>> clses = new ArrayList<Class<?>>(ctxClasses);\n        clses.add(ref.type.getClass());\n        try {\n            JAXBRIContext riContext = JAXBRIContext.newInstance(clses.toArray(new Class[clses.size()]),\n                                                                    typeRefs, null, null, true, null);\n            Bridge bridge = riContext.createBridge(ref);\n           \n            if (source instanceof XMLStreamReader) {\n                //DOMUtils.writeXml(StaxUtils.read((XMLStreamReader)source), System.out);\n                return bridge.unmarshal((XMLStreamReader)source);               \n            } else if (source instanceof InputStream) {\n                return bridge.unmarshal((InputStream)source);\n            } else if (source instanceof Node) {\n                return bridge.unmarshal((Node)source, am);\n            } else {\n                throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n            }\n        } catch (Exception ex) {\n            if (ex instanceof javax.xml.bind.MarshalException) {\n                javax.xml.bind.MarshalException marshalEx = (javax.xml.bind.MarshalException)ex;\n                Message faultMessage = new Message(\"MARSHAL_ERROR\", LOG, marshalEx.getLinkedException()\n                    .getMessage());\n                throw new Fault(faultMessage, ex);\n            } else {\n                throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, ex.getMessage()), ex);\n            }\n        }\n\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static Exception unmarshallException(JAXBContext context, Schema schema, Object source,\n                                                MessagePartInfo part, AttachmentUnmarshaller au) {\n        XMLStreamReader reader;\n        if (source instanceof XMLStreamReader) {\n            reader = (XMLStreamReader)source;\n        } else if (source instanceof Element) {\n            reader = StaxUtils.createXMLStreamReader((Element)source);\n            try {\n                // advance into the node\n                reader.nextTag();\n            } catch (XMLStreamException e) {\n                // ignore\n            }\n        } else {\n            throw new Fault(new Message(\"UNKNOWN_SOURCE\", BUNDLE, source.getClass().getName()));\n        }\n        try {\n            QName qn = part.getElementQName();\n            if (!qn.equals(reader.getName())) {\n                throw new Fault(new Message(\"ELEMENT_NAME_MISMATCH\", BUNDLE, qn, reader.getName()));\n            }\n\n            Class<?> cls = part.getTypeClass();\n            Object obj = null;\n            try {\n                Constructor cons = cls.getConstructor();\n                obj = cons.newInstance();\n            } catch (NoSuchMethodException nse) {\n                Constructor cons = cls.getConstructor(new Class[] {String.class});\n                obj = cons.newInstance(new Object[1]);\n            }\n\n            XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);\n            if (accessorType == null && cls.getPackage() != null) {\n                accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);\n            }\n            XmlAccessType accessType = accessorType != null\n                ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;\n            Unmarshaller u = createUnmarshaller(context, cls);\n            try {\n                // The Marshaller.JAXB_FRAGMENT will tell the Marshaller not to\n                // generate the xml declaration.\n                u.setProperty(Marshaller.JAXB_FRAGMENT, true);\n                u.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, false);\n            } catch (javax.xml.bind.PropertyException e) {\n                // intentionally empty.\n            }\n            reader.nextTag();\n            while (reader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                QName q = reader.getName();\n                try {\n                    Field f = cls.getField(q.getLocalPart());\n                    if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {\n                        f.setAccessible(true);\n                        f.set(obj, u.unmarshal(reader, f.getType()));\n                    }\n                } catch (NoSuchFieldException ex) {\n                    String s = Character.toUpperCase(q.getLocalPart().charAt(0))\n                               + q.getLocalPart().substring(1);\n                    Method m = null;\n                    try {\n                        m = cls.getMethod(\"get\" + s);\n                    } catch (NoSuchMethodException mex) {\n                        m = cls.getMethod(\"is\" + s);\n                    }\n                    Method m2 = cls.getMethod(\"set\" + s, m.getReturnType());\n                    Object o = getElementValue(u.unmarshal(reader, m.getReturnType()));\n                    m2.invoke(obj, o);\n                }\n            }\n            return (Exception)obj;\n        } catch (Exception e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", BUNDLE, e.getMessage()), e);\n        }\n    }","id":81936,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static Exception unmarshallException(Unmarshaller u, \n                                                Object source,\n                                                MessagePartInfo part) {\n        XMLStreamReader reader;\n        if (source instanceof XMLStreamReader) {\n            reader = (XMLStreamReader)source;\n        } else if (source instanceof Element) {\n            reader = StaxUtils.createXMLStreamReader((Element)source);\n            try {\n                // advance into the node\n                reader.nextTag();\n            } catch (XMLStreamException e) {\n                // ignore\n            }\n        } else {\n            throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n        }\n        try {\n            QName qn = part.getElementQName();\n            if (!qn.equals(reader.getName())) {\n                throw new Fault(new Message(\"ELEMENT_NAME_MISMATCH\", LOG, qn, reader.getName()));\n            }\n\n            Class<?> cls = part.getTypeClass();\n            Object obj = null;\n            try {\n                Constructor cons = cls.getConstructor();\n                obj = cons.newInstance();\n            } catch (NoSuchMethodException nse) {\n                Constructor cons = cls.getConstructor(new Class[] {String.class});\n                obj = cons.newInstance(new Object[1]);\n            }\n\n            XmlAccessorType accessorType = cls.getAnnotation(XmlAccessorType.class);\n            if (accessorType == null && cls.getPackage() != null) {\n                accessorType = cls.getPackage().getAnnotation(XmlAccessorType.class);\n            }\n            XmlAccessType accessType = accessorType != null\n                ? accessorType.value() : XmlAccessType.PUBLIC_MEMBER;\n            reader.nextTag();\n            while (reader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                QName q = reader.getName();\n                try {\n                    Field f = cls.getField(q.getLocalPart());\n                    if (JAXBContextInitializer.isFieldAccepted(f, accessType)) {\n                        f.setAccessible(true);\n                        f.set(obj, u.unmarshal(reader, f.getType()));\n                    }\n                } catch (NoSuchFieldException ex) {\n                    String s = Character.toUpperCase(q.getLocalPart().charAt(0))\n                               + q.getLocalPart().substring(1);\n                    Method m = null;\n                    try {\n                        m = cls.getMethod(\"get\" + s);\n                    } catch (NoSuchMethodException mex) {\n                        m = cls.getMethod(\"is\" + s);\n                    }\n                    Method m2 = cls.getMethod(\"set\" + s, m.getReturnType());\n                    Object o = getElementValue(u.unmarshal(reader, m.getReturnType()));\n                    m2.invoke(obj, o);\n                }\n            }\n            return (Exception)obj;\n        } catch (Exception e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, e.getMessage()), e);\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshallNullElement(JAXBContext context, Schema schema, Object source,\n                                           MessagePartInfo part, Map<String, Object> marshallerProperties) {\n        Class<?> clazz = part != null ? (Class)part.getTypeClass() : null;\n        try {\n            Marshaller u = createMarshaller(context, clazz, marshallerProperties);\n            u.setSchema(schema);\n            try {\n                // The Marshaller.JAXB_FRAGMENT will tell the Marshaller not to\n                // generate the xml declaration.\n                u.setProperty(Marshaller.JAXB_FRAGMENT, true);\n                u.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, false);\n            } catch (javax.xml.bind.PropertyException e) {\n                // intentionally empty.\n            }\n            writeObject(u, source, new JAXBElement(part.getElementQName(), clazz, null));\n        } catch (JAXBException e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", BUNDLE, e.getMessage()), e);\n        }\n    }","id":81937,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public static void marshallNullElement(Marshaller marshaller,\n                                           Object source,\n                                           MessagePartInfo part) {\n        Class<?> clazz = part != null ? (Class)part.getTypeClass() : null;\n        try {\n            writeObject(marshaller, source, new JAXBElement(part.getElementQName(), clazz, null));\n        } catch (JAXBException e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, e.getMessage()), e);\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testMarshalRPCLit() throws Exception {\n        QName elName = new QName(\"http://test_jaxb_marshall\", \"in\");\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        \n\n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        JAXBEncoderDecoder.marshall(context, null, \n                                    new String(\"TestSOAPMessage\"), part,  elNode, emptyMarshallerProperties);\n        \n        assertNotNull(elNode.getChildNodes());\n        assertEquals(\"TestSOAPMessage\", elNode.getFirstChild().getFirstChild().getNodeValue());\n    }","id":81938,"modified_method":"@Test\n    public void testMarshalRPCLit() throws Exception {\n        QName elName = new QName(\"http://test_jaxb_marshall\", \"in\");\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        \n\n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        JAXBEncoderDecoder.marshall(context.createMarshaller(), \n                                    new String(\"TestSOAPMessage\"), part,  elNode);\n        \n        assertNotNull(elNode.getChildNodes());\n        assertEquals(\"TestSOAPMessage\", elNode.getFirstChild().getFirstChild().getNodeValue());\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUnMarshall() throws Exception {\n        //Hello World Wsdl generated namespace\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        part.setTypeClass(Class.forName(wrapperAnnotation.className()));\n        \n\n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        Element rtEl = doc.createElementNS(elName.getNamespaceURI(), \"requestType\");\n        elNode.appendChild(rtEl);\n        rtEl.appendChild(doc.createTextNode(\"Hello Test\"));\n\n        Object obj = JAXBEncoderDecoder.unmarshall(context, null,\n                         elNode, part, null, true);\n        assertNotNull(obj);\n\n        //Add a Node and then test\n        assertEquals(GreetMe.class,  obj.getClass());\n        assertEquals(\"Hello Test\", ((GreetMe)obj).getRequestType());\n        \n        part.setTypeClass(String.class);\n        Node n = null;\n        try {\n            JAXBEncoderDecoder.unmarshall(context, null, n, part, null, true);\n            fail(\"Should have received a Fault\");\n        } catch (Fault pe) {\n            //Expected Exception\n        } catch (Exception ex) {\n            fail(\"Should have received a Fault, not: \" + ex);\n        }\n        \n        // Now test schema validation during unmarshaling\n        elName = new QName(wrapperAnnotation.targetNamespace(),\n                           \"stringStruct\");\n        // Create an XML Tree of\n        // <StringStruct><arg1>World<\/arg1><\/StringStruct>\n//         elNode = soapElFactory.createElement(elName);\n//         elNode.addNamespaceDeclaration(\"\", elName.getNamespaceURI());\n\n        part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        part.setTypeClass(Class.forName(\"org.apache.hello_world_soap_http.types.StringStruct\"));\n        \n        doc = DOMUtils.createDocument();\n        elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        rtEl = doc.createElementNS(elName.getNamespaceURI(), \"arg1\");\n        elNode.appendChild(rtEl);\n        rtEl.appendChild(doc.createTextNode(\"World\"));\n        \n        // Should unmarshal without problems when no schema used.\n        obj = JAXBEncoderDecoder.unmarshall(context, null, elNode, part, null, true);\n        assertNotNull(obj);\n        assertEquals(StringStruct.class,  obj.getClass());\n        assertEquals(\"World\", ((StringStruct)obj).getArg1());\n        \n        try {\n            // unmarshal with schema should raise exception.\n            obj = JAXBEncoderDecoder.unmarshall(context, schema, elNode, part, null, true);\n            fail(\"Should have thrown a Fault\");\n        } catch (Fault ex) {\n            // expected - schema validation should fail.\n        }\n    }","id":81939,"modified_method":"@Test\n    public void testUnMarshall() throws Exception {\n        //Hello World Wsdl generated namespace\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        part.setTypeClass(Class.forName(wrapperAnnotation.className()));\n        \n\n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        Element rtEl = doc.createElementNS(elName.getNamespaceURI(), \"requestType\");\n        elNode.appendChild(rtEl);\n        rtEl.appendChild(doc.createTextNode(\"Hello Test\"));\n\n        Object obj = JAXBEncoderDecoder.unmarshall(context.createUnmarshaller(),\n                         elNode, part, true);\n        assertNotNull(obj);\n\n        //Add a Node and then test\n        assertEquals(GreetMe.class,  obj.getClass());\n        assertEquals(\"Hello Test\", ((GreetMe)obj).getRequestType());\n        \n        part.setTypeClass(String.class);\n        Node n = null;\n        try {\n            JAXBEncoderDecoder.unmarshall(context.createUnmarshaller(), n, part, true);\n            fail(\"Should have received a Fault\");\n        } catch (Fault pe) {\n            //Expected Exception\n        } catch (Exception ex) {\n            fail(\"Should have received a Fault, not: \" + ex);\n        }\n        \n        // Now test schema validation during unmarshaling\n        elName = new QName(wrapperAnnotation.targetNamespace(),\n                           \"stringStruct\");\n        // Create an XML Tree of\n        // <StringStruct><arg1>World<\/arg1><\/StringStruct>\n//         elNode = soapElFactory.createElement(elName);\n//         elNode.addNamespaceDeclaration(\"\", elName.getNamespaceURI());\n\n        part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        part.setTypeClass(Class.forName(\"org.apache.hello_world_soap_http.types.StringStruct\"));\n        \n        doc = DOMUtils.createDocument();\n        elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        rtEl = doc.createElementNS(elName.getNamespaceURI(), \"arg1\");\n        elNode.appendChild(rtEl);\n        rtEl.appendChild(doc.createTextNode(\"World\"));\n        \n        // Should unmarshal without problems when no schema used.\n        obj = JAXBEncoderDecoder.unmarshall(context.createUnmarshaller(), elNode, part, true);\n        assertNotNull(obj);\n        assertEquals(StringStruct.class,  obj.getClass());\n        assertEquals(\"World\", ((StringStruct)obj).getArg1());\n        \n        try {\n            // unmarshal with schema should raise exception.\n            Unmarshaller m = context.createUnmarshaller();\n            m.setSchema(schema);\n            obj = JAXBEncoderDecoder.unmarshall(m, elNode, part, true);\n            fail(\"Should have thrown a Fault\");\n        } catch (Fault ex) {\n            // expected - schema validation should fail.\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testMarshallWithFormQualifiedElement() throws Exception {\n        ObjectWithQualifiedElementElement testObject = new ObjectWithQualifiedElementElement();\n        testObject.setString1(\"twine\");\n        testObject.setString2(\"cord\");\n        \n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        \n        StringWriter stringWriter = new StringWriter();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(stringWriter);\n        JAXBEncoderDecoder.marshall(context, null, testObject, part, writer, emptyMarshallerProperties);\n        writer.flush();\n        writer.close();\n        String xmlResult = stringWriter.toString();\n        // the following is a bit of a crock, but, to tell the truth, this test case most exists\n        // so that it could be examined inside the debugger to see how JAXB works.\n        assertTrue(xmlResult.contains(\"ns3:string2\"));\n    }","id":81940,"modified_method":"@Test\n    public void testMarshallWithFormQualifiedElement() throws Exception {\n        ObjectWithQualifiedElementElement testObject = new ObjectWithQualifiedElementElement();\n        testObject.setString1(\"twine\");\n        testObject.setString2(\"cord\");\n        \n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        \n        StringWriter stringWriter = new StringWriter();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(stringWriter);\n        JAXBEncoderDecoder.marshall(context.createMarshaller(), testObject, part, writer);\n        writer.flush();\n        writer.close();\n        String xmlResult = stringWriter.toString();\n        // the following is a bit of a crock, but, to tell the truth, this test case most exists\n        // so that it could be examined inside the debugger to see how JAXB works.\n        assertTrue(xmlResult.contains(\"ns3:string2\"));\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testMarshallWithoutQNameInfo() throws Exception {\n        GreetMe obj = new GreetMe();\n        obj.setRequestType(\"Hello\");\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(baos);\n\n        //STARTDOCUMENT/ENDDOCUMENT is not required\n        //writer.add(eFactory.createStartDocument(\"utf-8\", \"1.0\"));        \n        JAXBEncoderDecoder.marshall(context, null, obj, writer, emptyMarshallerProperties);\n        //writer.add(eFactory.createEndDocument());\n        writer.flush();\n        writer.close();\n        \n        //System.out.println(baos.toString());\n        \n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        XMLInputFactory ipFactory = XMLInputFactory.newInstance();\n        XMLEventReader reader = ipFactory.createXMLEventReader(bais);\n        \n        Unmarshaller um = context.createUnmarshaller();        \n        Object val = um.unmarshal(reader, GreetMe.class);\n        assertTrue(val instanceof JAXBElement);\n        val = ((JAXBElement)val).getValue();\n        assertTrue(val instanceof GreetMe);\n        assertEquals(obj.getRequestType(), \n                     ((GreetMe)val).getRequestType());\n    }","id":81941,"modified_method":"@Test\n    public void testMarshallWithoutQNameInfo() throws Exception {\n        GreetMe obj = new GreetMe();\n        obj.setRequestType(\"Hello\");\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(baos);\n\n        //STARTDOCUMENT/ENDDOCUMENT is not required\n        //writer.add(eFactory.createStartDocument(\"utf-8\", \"1.0\"));        \n        JAXBEncoderDecoder.marshall(context.createMarshaller(), obj, null, writer);\n        //writer.add(eFactory.createEndDocument());\n        writer.flush();\n        writer.close();\n        \n        //System.out.println(baos.toString());\n        \n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        XMLInputFactory ipFactory = XMLInputFactory.newInstance();\n        XMLEventReader reader = ipFactory.createXMLEventReader(bais);\n        \n        Unmarshaller um = context.createUnmarshaller();        \n        Object val = um.unmarshal(reader, GreetMe.class);\n        assertTrue(val instanceof JAXBElement);\n        val = ((JAXBElement)val).getValue();\n        assertTrue(val instanceof GreetMe);\n        assertEquals(obj.getRequestType(), \n                     ((GreetMe)val).getRequestType());\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testCustomNamespaces() throws Exception {\n        Map<String, Object> marshallProps = new HashMap<String, Object>();\n        NamespacePrefixMapper mapper = new NamespacePrefixMapper() {\n\n            @Override\n            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {\n                if (\"http://apache.org/hello_world_soap_http/types\".equals(namespaceUri)) {\n                    return \"Omnia\";\n                } else if (\"http://cxf.apache.org/jaxb_form\".equals(namespaceUri)) {\n                    return \"Gallia\";\n                }\n                return suggestion;\n            } \n        };\n        marshallProps.put(\"com.sun.xml.bind.namespacePrefixMapper\", mapper);\n        ObjectWithQualifiedElementElement testObject = new ObjectWithQualifiedElementElement();\n        testObject.setString1(\"twine\");\n        testObject.setString2(\"cord\");\n        \n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        \n        StringWriter stringWriter = new StringWriter();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(stringWriter);\n        JAXBEncoderDecoder.marshall(context, null, testObject, part, writer, marshallProps);\n        writer.flush();\n        writer.close();\n        String xmlResult = stringWriter.toString();\n        // the following is a bit of a crock, but, to tell the truth, this test case most exists\n        // so that it could be examined inside the debugger to see how JAXB works.\n        assertTrue(xmlResult.contains(\"Gallia:string2\"));\n    }","id":81942,"modified_method":"@Test\n    public void testCustomNamespaces() throws Exception {\n        NamespacePrefixMapper mapper = new NamespacePrefixMapper() {\n\n            @Override\n            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {\n                if (\"http://apache.org/hello_world_soap_http/types\".equals(namespaceUri)) {\n                    return \"Omnia\";\n                } else if (\"http://cxf.apache.org/jaxb_form\".equals(namespaceUri)) {\n                    return \"Gallia\";\n                }\n                return suggestion;\n            } \n        };\n        ObjectWithQualifiedElementElement testObject = new ObjectWithQualifiedElementElement();\n        testObject.setString1(\"twine\");\n        testObject.setString2(\"cord\");\n        \n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n        \n        StringWriter stringWriter = new StringWriter();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(stringWriter);\n        Marshaller m = context.createMarshaller();\n        m.setProperty(\"com.sun.xml.bind.namespacePrefixMapper\", mapper);\n        \n        JAXBEncoderDecoder.marshall(m, testObject, part, writer);\n        writer.flush();\n        writer.close();\n        String xmlResult = stringWriter.toString();\n        // the following is a bit of a crock, but, to tell the truth, this test case most exists\n        // so that it could be examined inside the debugger to see how JAXB works.\n        assertTrue(xmlResult.contains(\"Gallia:string2\"));\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUnmarshallFromStax() throws Exception {\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n\n        InputStream is =  getClass().getResourceAsStream(\"resources/GreetMeDocLiteralReq.xml\");\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        XMLStreamReader reader = \n            factory.createXMLStreamReader(is);\n\n        QName[] tags = {SOAP_ENV, SOAP_BODY};\n        StaxStreamFilter filter = new StaxStreamFilter(tags);\n        reader = factory.createFilteredReader(reader, filter);\n\n        //Remove START_DOCUMENT & START_ELEMENT pertaining to Envelope and Body Tags.\n\n        part.setTypeClass(GreetMe.class);\n        Object val = JAXBEncoderDecoder.unmarshall(context, null, reader, part, null, true);\n        assertNotNull(val);\n        assertTrue(val instanceof GreetMe);\n        assertEquals(\"TestSOAPInputPMessage\", \n                     ((GreetMe)val).getRequestType());\n\n        is.close();\n    }","id":81943,"modified_method":"@Test\n    public void testUnmarshallFromStax() throws Exception {\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n\n        InputStream is =  getClass().getResourceAsStream(\"resources/GreetMeDocLiteralReq.xml\");\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        XMLStreamReader reader = \n            factory.createXMLStreamReader(is);\n\n        QName[] tags = {SOAP_ENV, SOAP_BODY};\n        StaxStreamFilter filter = new StaxStreamFilter(tags);\n        reader = factory.createFilteredReader(reader, filter);\n\n        //Remove START_DOCUMENT & START_ELEMENT pertaining to Envelope and Body Tags.\n\n        part.setTypeClass(GreetMe.class);\n        Object val = JAXBEncoderDecoder.unmarshall(context.createUnmarshaller(), reader, part, true);\n        assertNotNull(val);\n        assertTrue(val instanceof GreetMe);\n        assertEquals(\"TestSOAPInputPMessage\", \n                     ((GreetMe)val).getRequestType());\n\n        is.close();\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testMarshallIntoDOM() throws Exception {\n        String str = new String(\"Hello\");\n        QName inCorrectElName = new QName(\"http://test_jaxb_marshall\", \"requestType\");\n        MessagePartInfo part = new MessagePartInfo(inCorrectElName, null);\n        part.setElement(true);\n        part.setElementQName(inCorrectElName);\n        \n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(inCorrectElName.getNamespaceURI(), \n                                             inCorrectElName.getLocalPart());\n        assertNotNull(elNode);\n\n        Node node;\n        try {\n            JAXBEncoderDecoder.marshall(context, null, null, part, elNode, emptyMarshallerProperties);\n            fail(\"Should have thrown a Fault\");\n        } catch (Fault ex) {\n            //expected - not a valid object\n        }\n\n        GreetMe obj = new GreetMe();\n        obj.setRequestType(\"Hello\");\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        part.setElementQName(elName);\n        JAXBEncoderDecoder.marshall(context, null, obj, part, elNode, emptyMarshallerProperties);\n        node = elNode.getLastChild();\n        //The XML Tree Looks like\n        //<GreetMe><requestType>Hello<\/requestType><\/GreetMe>\n        assertEquals(Node.ELEMENT_NODE, node.getNodeType());\n        Node childNode = node.getFirstChild();\n        assertEquals(Node.ELEMENT_NODE, childNode.getNodeType());\n        childNode = childNode.getFirstChild();\n        assertEquals(Node.TEXT_NODE, childNode.getNodeType());\n        assertEquals(str, childNode.getNodeValue());\n\n        // Now test schema validation during marshaling\n        StringStruct stringStruct = new StringStruct();\n        // Don't initialize one of the structure members.\n        //stringStruct.setArg0(\"hello\");\n        stringStruct.setArg1(\"world\");\n        // Marshal without the schema should work.\n        JAXBEncoderDecoder.marshall(context, null, stringStruct, part,  elNode, emptyMarshallerProperties);\n        try {\n            // Marshal with the schema should get an exception.\n            JAXBEncoderDecoder.marshall(context, schema, stringStruct, part,  elNode, \n                                        emptyMarshallerProperties);\n            fail(\"Marshal with schema should have thrown a Fault\");\n        } catch (Fault ex) {\n            //expected - not a valid object\n        }\n    }","id":81944,"modified_method":"@Test\n    public void testMarshallIntoDOM() throws Exception {\n        String str = new String(\"Hello\");\n        QName inCorrectElName = new QName(\"http://test_jaxb_marshall\", \"requestType\");\n        MessagePartInfo part = new MessagePartInfo(inCorrectElName, null);\n        part.setElement(true);\n        part.setElementQName(inCorrectElName);\n        \n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(inCorrectElName.getNamespaceURI(), \n                                             inCorrectElName.getLocalPart());\n        assertNotNull(elNode);\n\n        Node node;\n        try {\n            JAXBEncoderDecoder.marshall(context.createMarshaller(), null, part, elNode);\n            fail(\"Should have thrown a Fault\");\n        } catch (Fault ex) {\n            //expected - not a valid object\n        }\n\n        GreetMe obj = new GreetMe();\n        obj.setRequestType(\"Hello\");\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        part.setElementQName(elName);\n        JAXBEncoderDecoder.marshall(context.createMarshaller(), obj, part, elNode);\n        node = elNode.getLastChild();\n        //The XML Tree Looks like\n        //<GreetMe><requestType>Hello<\/requestType><\/GreetMe>\n        assertEquals(Node.ELEMENT_NODE, node.getNodeType());\n        Node childNode = node.getFirstChild();\n        assertEquals(Node.ELEMENT_NODE, childNode.getNodeType());\n        childNode = childNode.getFirstChild();\n        assertEquals(Node.TEXT_NODE, childNode.getNodeType());\n        assertEquals(str, childNode.getNodeValue());\n\n        // Now test schema validation during marshaling\n        StringStruct stringStruct = new StringStruct();\n        // Don't initialize one of the structure members.\n        //stringStruct.setArg0(\"hello\");\n        stringStruct.setArg1(\"world\");\n        // Marshal without the schema should work.\n        JAXBEncoderDecoder.marshall(context.createMarshaller(), stringStruct, part,  elNode);\n        try {\n            Marshaller m = context.createMarshaller();\n            m.setSchema(schema);\n            // Marshal with the schema should get an exception.\n            JAXBEncoderDecoder.marshall(m, stringStruct, part,  elNode);\n            fail(\"Marshal with schema should have thrown a Fault\");\n        } catch (Fault ex) {\n            //expected - not a valid object\n        }\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUnmarshallWithoutClzInfo() throws Exception {\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n\n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        Element rtEl = doc.createElementNS(elName.getNamespaceURI(), \"requestType\");\n        elNode.appendChild(rtEl);\n        rtEl.appendChild(doc.createTextNode(\"Hello Test\"));\n       \n        Object obj = JAXBEncoderDecoder.unmarshall(context, null, elNode);\n        assertNotNull(obj);\n        assertEquals(GreetMe.class,  obj.getClass());\n        assertEquals(\"Hello Test\", ((GreetMe)obj).getRequestType());\n    }","id":81945,"modified_method":"@Test\n    public void testUnmarshallWithoutClzInfo() throws Exception {\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n\n        Document doc = DOMUtils.createDocument();\n        Element elNode = doc.createElementNS(elName.getNamespaceURI(), \n                                             elName.getLocalPart());\n        Element rtEl = doc.createElementNS(elName.getNamespaceURI(), \"requestType\");\n        elNode.appendChild(rtEl);\n        rtEl.appendChild(doc.createTextNode(\"Hello Test\"));\n       \n        Object obj = JAXBEncoderDecoder.unmarshall(context.createUnmarshaller(), \n                                                   elNode,\n                                                   null,\n                                                   true);\n        assertNotNull(obj);\n        assertEquals(GreetMe.class,  obj.getClass());\n        assertEquals(\"Hello Test\", ((GreetMe)obj).getRequestType());\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testMarshallIntoStax() throws Exception {\n        GreetMe obj = new GreetMe();\n        obj.setRequestType(\"Hello\");\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n                \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(baos);\n\n        //STARTDOCUMENT/ENDDOCUMENT is not required\n        //writer.add(eFactory.createStartDocument(\"utf-8\", \"1.0\"));        \n        JAXBEncoderDecoder.marshall(context, null, obj, part, writer, emptyMarshallerProperties);\n        //writer.add(eFactory.createEndDocument());\n        writer.flush();\n        writer.close();\n        \n        //System.out.println(baos.toString());\n        \n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        XMLInputFactory ipFactory = XMLInputFactory.newInstance();\n        XMLEventReader reader = ipFactory.createXMLEventReader(bais);\n        \n        Unmarshaller um = context.createUnmarshaller();        \n        Object val = um.unmarshal(reader, GreetMe.class);\n        assertTrue(val instanceof JAXBElement);\n        val = ((JAXBElement)val).getValue();\n        assertTrue(val instanceof GreetMe);\n        assertEquals(obj.getRequestType(), \n                     ((GreetMe)val).getRequestType());\n    }","id":81946,"modified_method":"@Test\n    public void testMarshallIntoStax() throws Exception {\n        GreetMe obj = new GreetMe();\n        obj.setRequestType(\"Hello\");\n        QName elName = new QName(wrapperAnnotation.targetNamespace(),\n                                 wrapperAnnotation.localName());\n        MessagePartInfo part = new MessagePartInfo(elName, null);\n        part.setElement(true);\n        part.setElementQName(elName);\n                \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        XMLOutputFactory opFactory = XMLOutputFactory.newInstance();\n        opFactory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        XMLEventWriter writer = opFactory.createXMLEventWriter(baos);\n\n        //STARTDOCUMENT/ENDDOCUMENT is not required\n        //writer.add(eFactory.createStartDocument(\"utf-8\", \"1.0\"));        \n        JAXBEncoderDecoder.marshall(context.createMarshaller(), obj, part, writer);\n        //writer.add(eFactory.createEndDocument());\n        writer.flush();\n        writer.close();\n        \n        //System.out.println(baos.toString());\n        \n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        XMLInputFactory ipFactory = XMLInputFactory.newInstance();\n        XMLEventReader reader = ipFactory.createXMLEventReader(bais);\n        \n        Unmarshaller um = context.createUnmarshaller();        \n        Object val = um.unmarshal(reader, GreetMe.class);\n        assertTrue(val instanceof JAXBElement);\n        val = ((JAXBElement)val).getValue();\n        assertTrue(val instanceof GreetMe);\n        assertEquals(obj.getRequestType(), \n                     ((GreetMe)val).getRequestType());\n    }","commit_id":"52a1b9167c42d88c7cf80c6e3253974529807106","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n   public void testWorkbenchPersistance() throws Exception {\n      // Clear out the workspace and make sure it's clear\n      WebElement menuItem = MenuNavigator.getMenuItem(driver_, \n            \"Session\", \"Clear Workspace...\");\n      menuItem.click();\n      DialogTestUtils.respondToModalDialog(driver_, \"Yes\");\n      \n      ConsoleTestUtils.beginConsoleInteraction(driver_);\n      (new Actions(driver_))\n         .sendKeys(Keys.ESCAPE + \"ls()\" + Keys.ENTER)\n         .perform();\n      \n      ConsoleTestUtils.waitForConsoleContainsText(driver_, \"character(0)\");\n      \n      // Add a variable to the workspace\n      (new Actions(driver_))\n         .sendKeys(Keys.ESCAPE + \"selenium <- function() { 42 }\" + Keys.ENTER)\n         .perform();\n\n      // Save the workspace \n      WebElement saveItem = MenuNavigator.getMenuItem(driver_, \n            \"Session\", \"Save Workspace As...\");\n      saveItem.click();\n      \n      WebElement saveDialog = DialogTestUtils.waitForModalToAppear(driver_);\n      DialogTestUtils.waitForFocusedInput(driver_, saveDialog);\n      \n      File tempFile = File.createTempFile(\"rstudio-selenium-workspace-\", \".RData\");\n      String workspaceFilePath = tempFile.getAbsolutePath();\n      tempFile.delete();\n      \n      (new Actions(driver_))\n         .sendKeys(workspaceFilePath + Keys.ENTER)\n         .perform();\n      \n      // TODO: Clear workspace again, load saved workspace, and verify that\n      // variable is present again\n   }","id":81947,"modified_method":"@Test\n   public void testWorkbenchPersistance() throws Exception {\n      clearWorkspace();\n      \n      // Add a variable to the workspace\n      (new Actions(driver_))\n         .sendKeys(Keys.ESCAPE + \"selenium <- function() { 42 }\" + Keys.ENTER)\n         .perform();\n\n      // Save the workspace \n      WebElement saveItem = MenuNavigator.getMenuItem(driver_, \n            \"Session\", \"Save Workspace As...\");\n      saveItem.click();\n      \n      WebElement saveDialog = DialogTestUtils.waitForModalToAppear(driver_);\n      DialogTestUtils.waitForFocusedInput(driver_, saveDialog);\n      \n      File tempFile = File.createTempFile(\"rstudio-selenium-workspace-\", \".RData\");\n      String workspaceFilePath = tempFile.getAbsolutePath();\n      tempFile.delete();\n      \n      (new Actions(driver_))\n         .sendKeys(workspaceFilePath + Keys.ENTER)\n         .perform();\n      \n      DialogTestUtils.waitForModalToDisappear(driver_);\n      \n      // Clear the workspace and load it again\n      clearWorkspace();\n      \n      WebElement loadItem = MenuNavigator.getMenuItem(driver_,  \n            \"Session\", \"Load Workspace...\");\n      loadItem.click();\n      \n      WebElement loadDialog = DialogTestUtils.waitForModalToAppear(driver_);\n      DialogTestUtils.waitForFocusedInput(driver_, loadDialog);\n      \n      (new Actions(driver_))\n         .sendKeys(workspaceFilePath + Keys.ENTER)\n         .perform();\n\n      DialogTestUtils.waitForModalToDisappear(driver_);\n      \n      // List the workspace and see if the variable is present\n      ConsoleTestUtils.beginConsoleInteraction(driver_);\n      (new Actions(driver_))\n         .sendKeys(Keys.chord(Keys.CONTROL + \"l\"))\n         .sendKeys(Keys.ESCAPE + \"ls()\" + Keys.ENTER)\n         .perform();\n      \n      ConsoleTestUtils.waitForConsoleContainsText(driver_, \"selenium\");\n   }","commit_id":"6e0cafbd937a705532dbe07c15ef57b34ad8089e","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n    public Configuration getConfiguration(final ServletContext context) {\n        String contextPath = context.getContextPath();\n        // NB: inbound rules are processed in order, outbound rules in reverse order (as of Rewrite 3.0.0.Alpha1)\n        return ConfigurationBuilder.begin()\n\n                // TODO test this\n                .addRule()\n                .when(Direction.isInbound().and(Path.matches(\"/seam/resource/restv1/{path}\")))\n                .perform(Forward.to(\"/rest/{path}\"))\n                .where(\"path\").matches(\".*\")\n\n                .addRule()\n                .when(Direction.isInbound().and(Path.matches(\"/iteration/files/{projectSlug}/{iterationSlug}\")))\n                .perform(Redirect.permanent(contextPath + \"/iteration/view/{projectSlug}/{iterationSlug}/documents\"))\n\n                .addRule()\n                .when(Direction.isInbound().and(Path.matches(\"/iteration/source_files/{projectSlug}/{iterationSlug}\")))\n                .perform(Redirect.permanent(contextPath + \"/iteration/view/{projectSlug}/{iterationSlug}/documents\"))\n\n\n                .addRule(Join.path(\"/\").to(\"/home.seam\"))\n                .addRule(Join.path(\"/account/activate/{key}\").to(\"/account/activate.seam\"))\n                //.addRule(Join.path(\"/account/changepassword\").to(\"/account/changepassword.seam\"))\n                .addRule(Join.path(\"/account/google_password_reset_request\").to(\"/account/google_password_reset_request.seam\"))\n                .addRule(Join.path(\"/account/password_reset/{key}\").to(\"/account/password_reset.seam\"))\n                .addRule(Join.path(\"/account/password_reset_request\").to(\"/account/password_reset_request.seam\"))\n                .addRule(Join.path(\"/account/inactive\").to(\"/account/inactive_account.seam\"))\n                .addRule(Join.path(\"/account/klogin\").to(\"/account/klogin.seam\"))\n                .addRule(Join.path(\"/account/sign_in\").to(\"/account/login.seam\"))\n                .addRule(Join.path(\"/account/register\").to(\"/account/register.seam\"))\n                .addRule(Join.path(\"/account/sign_out\").to(\"/account/logout.seam\"))\n                .addRule(Join.path(\"/account/validate_email/{key}\").to(\"/account/email_validation.seam\"))\n                .addRule(Join.path(\"/admin/\").to(\"/admin/home.seam\"))\n                .addRule(Join.pathNonBinding(\"/admin/{page}\").to(\"/admin/{page}.seam\"))\n                .addRule(Join.path(\"/dashboard/\").to(\"/dashboard/home.seam\"))\n                .addRule(Join.path(\"/error/\").to(\"/error.seam\"))\n                .addRule(Join.pathNonBinding(\"/error/{path}\").to(\"/error/{path}.seam\"))\n                .addRule(Join.path(\"/glossary/\").to(\"/glossary/view.seam\"))\n                //.addRule(Join.path(\"/help/view\").to(\"/help/view.seam\"))\n                .addRule(Join.path(\"/iteration/view/{projectSlug}/{iterationSlug}\").to(\"/iteration/view.seam\"))\n                .addRule(Join.path(\"/iteration/view/{projectSlug}/{iterationSlug}/{section}\").to(\"/iteration/view.seam\"))\n                .when(Direction.isInbound())\n                .where(\"section\").matches(\".*\")\n\n                /* JSF serves zanata-assets with suffix of .seam only.\n                   This is to make sure any reference to zanata-assets\n                   without .seam can access the resource.\n                   e.g. jars/assets/style.css forwards to\n                   jars/assets/style.css.seam\n                */\n                .addRule(Join.path(\"/javax.faces.resource/jars/assets/{path}\")\n                        .to(\"/javax.faces.resource/jars/assets/{path}.seam\"))\n                .when(Direction.isInbound())\n                .where(\"path\").matches(\".*(?<!.seam)\")\n\n                .addRule(Join.path(\"/language/list/\").to(\"/language/home.seam\"))\n                .addRule(Join.path(\"/language/view/{id}\").to(\"/language/language.seam\"))\n                .addRule(Join.path(\"/profile/\").to(\"/profile/home.seam\"))\n                .addRule(Join.path(\"/profile/add_identity\").to(\"/profile/add_identity.seam\"))\n                .addRule(Join.path(\"/profile/create\").to(\"/profile/create_user.seam\"))\n                .addRule(Join.path(\"/profile/edit\").to(\"/profile/edit.seam\"))\n                .addRule(Join.path(\"/profile/merge_account\").to(\"/profile/merge_account.seam\"))\n                .addRule(Join.path(\"/profile/view/{username}\").to(\"/profile/home.seam\"))\n                .addRule(Join.path(\"/project/add_iteration/{projectSlug}\").to(\"/project/add_iteration.seam\"))\n                .addRule(Join.path(\"/project/add_iteration/{projectSlug}/{copyFromVersionSlug}\").to(\"/project/add_iteration.seam\"))\n                .addRule(Join.path(\"/project/create\").to(\"/project/create_project.seam\"))\n                .addRule(Join.path(\"/project/list/\").to(\"/project/home.seam\"))\n                .addRule(Join.path(\"/project/view/{slug}\").to(\"/project/project.seam\"))\n                .addRule(Join.path(\"/project/view/{slug}/{section}\").to(\"/project/project.seam\"))\n                .when(Direction.isInbound())\n                .where(\"section\").matches(\".*\")\n\n                // generate zanata.xml config\n                .addRule(Join.path(\"/project/view/{projectSlug}/iter/{iterationSlug}/config/\").\n                        to(\"/project/project.seam?actionMethod=project%2Fproject.xhtml%3AconfigurationAction.getData\"))\n                // TODO fix this\n                .addRule(Join.path(\"/rest/\").to(\"/rest/index.xrd\"))\n                .addRule(Join.path(\"/search/{query}\").to(\"/search.seam\"))\n                // Translation Memory\n                .addRule(Join.path(\"/tm/\").to(\"/tm/home.seam\"))\n                .addRule(Join.path(\"/tm/create\").to(\"/tm/create.seam\"))\n                .addRule(Join.path(\"/version-group/create\").to(\"/version-group/create_version_group.seam\"))\n                .addRule(Join.path(\"/version-group/list/\").to(\"/version-group/home.seam\"))\n                .addRule(Join.path(\"/version-group/view/{versionGroupSlug}\").to(\"/version-group/version_group.seam\"))\n                .addRule(Join.path(\"/webtrans/Application.html\").to(\"/webtrans/Application.seam\")).when(Direction.isInbound())\n                .addRule(Join.path(\"/webtrans/translate\").to(\"/webtrans/Application.seam\"))\n                ;\n    }","id":81948,"modified_method":"@Override\n    public Configuration getConfiguration(final ServletContext context) {\n        String contextPath = context.getContextPath();\n        // NB: inbound rules are processed in order, outbound rules in reverse order (as of Rewrite 3.0.0.Alpha1)\n        return ConfigurationBuilder.begin()\n\n                // strip trailling slash as recommended:\n                // https://github.com/ocpsoft/rewrite/issues/158#issuecomment-154597796\n                .addRule()\n                .when(Path.matches(\"/{path}/\"))\n                .perform(Redirect.permanent(contextPath + \"/{path}\"))\n                .where(\"path\").matches(\"[.*]\")\n\n                // TODO test this\n                .addRule()\n                .when(Direction.isInbound().and(Path.matches(\"/seam/resource/restv1/{path}\")))\n                .perform(Forward.to(\"/rest/{path}\"))\n                .where(\"path\").matches(\".*\")\n\n                .addRule()\n                .when(Direction.isInbound().and(Path.matches(\"/iteration/files/{projectSlug}/{iterationSlug}\")))\n                .perform(Redirect.permanent(contextPath + \"/iteration/view/{projectSlug}/{iterationSlug}/documents\"))\n\n                .addRule()\n                .when(Direction.isInbound().and(Path.matches(\"/iteration/source_files/{projectSlug}/{iterationSlug}\")))\n                .perform(Redirect.permanent(contextPath + \"/iteration/view/{projectSlug}/{iterationSlug}/documents\"))\n\n\n                .addRule(Join.path(\"/\").to(\"/home.seam\"))\n                .addRule(Join.path(\"/account/activate/{key}\").to(\"/account/activate.seam\"))\n                //.addRule(Join.path(\"/account/changepassword\").to(\"/account/changepassword.seam\"))\n                .addRule(Join.path(\"/account/google_password_reset_request\").to(\"/account/google_password_reset_request.seam\"))\n                .addRule(Join.path(\"/account/password_reset/{key}\").to(\"/account/password_reset.seam\"))\n                .addRule(Join.path(\"/account/password_reset_request\").to(\"/account/password_reset_request.seam\"))\n                .addRule(Join.path(\"/account/inactive\").to(\"/account/inactive_account.seam\"))\n                .addRule(Join.path(\"/account/klogin\").to(\"/account/klogin.seam\"))\n                .addRule(Join.path(\"/account/sign_in\").to(\"/account/login.seam\"))\n                .addRule(Join.path(\"/account/register\").to(\"/account/register.seam\"))\n                .addRule(Join.path(\"/account/sign_out\").to(\"/account/logout.seam\"))\n                .addRule(Join.path(\"/account/validate_email/{key}\").to(\"/account/email_validation.seam\"))\n                .addRule(Join.path(\"/admin\").to(\"/admin/home.seam\"))\n                .addRule(Join.pathNonBinding(\"/admin/{page}\").to(\"/admin/{page}.seam\"))\n                .addRule(Join.path(\"/dashboard\").to(\"/dashboard/home.seam\"))\n                .addRule(Join.path(\"/error\").to(\"/error.seam\"))\n                .addRule(Join.pathNonBinding(\"/error/{path}\").to(\"/error/{path}.seam\"))\n                .addRule(Join.path(\"/glossary\").to(\"/glossary/view.seam\"))\n                //.addRule(Join.path(\"/help/view\").to(\"/help/view.seam\"))\n                .addRule(Join.path(\"/iteration/view/{projectSlug}/{iterationSlug}\").to(\"/iteration/view.seam\"))\n                .addRule(Join.path(\"/iteration/view/{projectSlug}/{iterationSlug}/{section}\").to(\"/iteration/view.seam\"))\n                .when(Direction.isInbound())\n                .where(\"section\").matches(\".*\")\n\n                /* JSF serves zanata-assets with suffix of .seam only.\n                   This is to make sure any reference to zanata-assets\n                   without .seam can access the resource.\n                   e.g. jars/assets/style.css forwards to\n                   jars/assets/style.css.seam\n                */\n                .addRule(Join.path(\"/javax.faces.resource/jars/assets/{path}\")\n                        .to(\"/javax.faces.resource/jars/assets/{path}.seam\"))\n                .when(Direction.isInbound())\n                .where(\"path\").matches(\".*(?<!.seam)\")\n\n                .addRule(Join.path(\"/language/list\").to(\"/language/home.seam\"))\n                .addRule(Join.path(\"/language/view/{id}\").to(\"/language/language.seam\"))\n                .addRule(Join.path(\"/profile\").to(\"/profile/home.seam\"))\n                .addRule(Join.path(\"/profile/add_identity\").to(\"/profile/add_identity.seam\"))\n                .addRule(Join.path(\"/profile/create\").to(\"/profile/create_user.seam\"))\n                .addRule(Join.path(\"/profile/edit\").to(\"/profile/edit.seam\"))\n                .addRule(Join.path(\"/profile/merge_account\").to(\"/profile/merge_account.seam\"))\n                .addRule(Join.path(\"/profile/view/{username}\").to(\"/profile/home.seam\"))\n                .addRule(Join.path(\"/project/add_iteration/{projectSlug}\").to(\"/project/add_iteration.seam\"))\n                .addRule(Join.path(\"/project/add_iteration/{projectSlug}/{copyFromVersionSlug}\").to(\"/project/add_iteration.seam\"))\n                .addRule(Join.path(\"/project/create\").to(\"/project/create_project.seam\"))\n                .addRule(Join.path(\"/project/list\").to(\"/project/home.seam\"))\n                .addRule(Join.path(\"/project/view/{slug}\").to(\"/project/project.seam\"))\n                .addRule(Join.path(\"/project/view/{slug}/{section}\").to(\"/project/project.seam\"))\n                .when(Direction.isInbound())\n                .where(\"section\").matches(\".*\")\n\n                // generate zanata.xml config\n                .addRule(Join.path(\"/project/view/{projectSlug}/iter/{iterationSlug}/config\").\n                        to(\"/project/project.seam?actionMethod=project%2Fproject.xhtml%3AconfigurationAction.getData\"))\n                // TODO fix this\n                .addRule(Join.path(\"/rest\").to(\"/rest/index.xrd\"))\n                .addRule(Join.path(\"/search/{query}\").to(\"/search.seam\"))\n                // Translation Memory\n                .addRule(Join.path(\"/tm\").to(\"/tm/home.seam\"))\n                .addRule(Join.path(\"/tm/create\").to(\"/tm/create.seam\"))\n                .addRule(Join.path(\"/version-group/create\").to(\"/version-group/create_version_group.seam\"))\n                .addRule(Join.path(\"/version-group/list\").to(\"/version-group/home.seam\"))\n                .addRule(Join.path(\"/version-group/view/{versionGroupSlug}\").to(\"/version-group/version_group.seam\"))\n                .addRule(Join.path(\"/webtrans/Application.html\").to(\"/webtrans/Application.seam\")).when(Direction.isInbound())\n                .addRule(Join.path(\"/webtrans/translate\").to(\"/webtrans/Application.seam\"))\n                ;\n    }","commit_id":"453459b737fbcd74cd48021298976dc95ace4628","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public InitiateResponseMessage processInitiateTask(\n            TransactionState txnState,\n            final VoltMessage task)\n    {\n        final InitiateTaskMessage itask = (InitiateTaskMessage)task;\n        final VoltProcedure wrapper = procs.get(itask.getStoredProcedureName());\n\n        final InitiateResponseMessage response = new InitiateResponseMessage(itask);\n\n        // feasible to receive a transaction initiated with an earlier catalog.\n        if (wrapper == null) {\n            response.setResults(\n                new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                       new VoltTable[] {},\n                                       \"Procedure does not exist: \" + itask.getStoredProcedureName()));\n        }\n        else {\n            try {\n                Object[] callerParams = null;\n                /*\n                 * Parameters are lazily deserialized. We may not find out until now\n                 * that the parameter set is corrupt\n                 */\n                try {\n                    callerParams = itask.getParameters();\n                } catch (RuntimeException e) {\n                    Writer result = new StringWriter();\n                    PrintWriter pw = new PrintWriter(result);\n                    e.printStackTrace(pw);\n                    response.setResults(\n                            new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                                   new VoltTable[] {},\n                                                   \"Exception while deserializing procedure params\\n\" +\n                                                   result.toString()));\n                }\n                if (callerParams != null) {\n                    ClientResponseImpl cr = null;\n                    if (wrapper instanceof VoltSystemProcedure) {\n                        final Object[] combinedParams = new Object[callerParams.length + 1];\n                        combinedParams[0] = m_systemProcedureContext;\n                        for (int i=0; i < callerParams.length; ++i) combinedParams[i+1] = callerParams[i];\n                        cr = wrapper.call(txnState, combinedParams);\n                        response.setResults(cr, itask);\n                    }\n                    else {\n                        cr = wrapper.call(txnState, itask.getParameters());\n                        response.setResults(cr, itask);\n                    }\n                    // if enabled, send a record of this invocation to the secondary/dr cluster\n                    // if not enabled, should be a noop\n                    m_partitionDRGateway.onSuccessfulProcedureCall(itask.getTxnId(), itask.getStoredProcedureInvocation(), cr);\n                }\n            }\n            catch (final ExpectedProcedureException e) {\n                log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n                response.setResults(\n                                    new ClientResponseImpl(\n                                                           ClientResponse.GRACEFUL_FAILURE,\n                                                           new VoltTable[]{},\n                                                           e.toString()));\n            }\n            catch (final Exception e) {\n                // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n                // and converted them to error responses. Java errors are re-thrown, and not caught by this\n                // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n                hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n                VoltDB.crashVoltDB();\n            }\n        }\n        log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        return response;\n    }","id":81949,"modified_method":"@Override\n    public InitiateResponseMessage processInitiateTask(\n            TransactionState txnState,\n            final VoltMessage task)\n    {\n        final InitiateTaskMessage itask = (InitiateTaskMessage)task;\n        final VoltProcedure wrapper = procs.get(itask.getStoredProcedureName());\n\n        final InitiateResponseMessage response = new InitiateResponseMessage(itask);\n\n        // feasible to receive a transaction initiated with an earlier catalog.\n        if (wrapper == null) {\n            response.setResults(\n                new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                       new VoltTable[] {},\n                                       \"Procedure does not exist: \" + itask.getStoredProcedureName()));\n        }\n        else {\n            try {\n                Object[] callerParams = null;\n                /*\n                 * Parameters are lazily deserialized. We may not find out until now\n                 * that the parameter set is corrupt\n                 */\n                try {\n                    callerParams = itask.getParameters();\n                } catch (RuntimeException e) {\n                    Writer result = new StringWriter();\n                    PrintWriter pw = new PrintWriter(result);\n                    e.printStackTrace(pw);\n                    response.setResults(\n                            new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                                   new VoltTable[] {},\n                                                   \"Exception while deserializing procedure params\\n\" +\n                                                   result.toString()));\n                }\n                if (callerParams != null) {\n                    ClientResponseImpl cr = null;\n                    if (wrapper instanceof VoltSystemProcedure) {\n                        final Object[] combinedParams = new Object[callerParams.length + 1];\n                        combinedParams[0] = m_systemProcedureContext;\n                        for (int i=0; i < callerParams.length; ++i) combinedParams[i+1] = callerParams[i];\n                        cr = wrapper.call(txnState, combinedParams);\n                        response.setResults(cr, itask);\n                    }\n                    else {\n                        cr = wrapper.call(txnState, itask.getParameters());\n                        response.setResults(cr, itask);\n                    }\n                    // if enabled, send a record of this invocation to the secondary/dr cluster\n                    // if not enabled, should be a noop\n                    // also only send write txns\n                    if (itask.isReadOnly() == false)\n                        m_partitionDRGateway.onSuccessfulProcedureCall(itask.getTxnId(), itask.getStoredProcedureInvocation(), cr);\n                }\n            }\n            catch (final ExpectedProcedureException e) {\n                log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n                response.setResults(\n                                    new ClientResponseImpl(\n                                                           ClientResponse.GRACEFUL_FAILURE,\n                                                           new VoltTable[]{},\n                                                           e.toString()));\n            }\n            catch (final Exception e) {\n                // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n                // and converted them to error responses. Java errors are re-thrown, and not caught by this\n                // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n                hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n                VoltDB.crashVoltDB();\n            }\n        }\n        log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        return response;\n    }","commit_id":"6f81d7aedb003b3c09a0258b92856fd8746025c4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public InitiateResponseMessage processInitiateTask(\n            TransactionState txnState,\n            final VoltMessage task)\n    {\n        final InitiateTaskMessage itask = (InitiateTaskMessage)task;\n        final VoltProcedure wrapper = procs.get(itask.getStoredProcedureName());\n\n        final InitiateResponseMessage response = new InitiateResponseMessage(itask);\n\n        // feasible to receive a transaction initiated with an earlier catalog.\n        if (wrapper == null) {\n            response.setResults(\n                new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                       new VoltTable[] {},\n                                       \"Procedure does not exist: \" + itask.getStoredProcedureName()));\n        }\n        else {\n            try {\n                Object[] callerParams = null;\n                /*\n                 * Parameters are lazily deserialized. We may not find out until now\n                 * that the parameter set is corrupt\n                 */\n                try {\n                    callerParams = itask.getParameters();\n                } catch (RuntimeException e) {\n                    Writer result = new StringWriter();\n                    PrintWriter pw = new PrintWriter(result);\n                    e.printStackTrace(pw);\n                    response.setResults(\n                            new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                                   new VoltTable[] {},\n                                                   \"Exception while deserializing procedure params\\n\" +\n                                                   result.toString()));\n                }\n                if (callerParams != null) {\n                    ClientResponseImpl cr = null;\n                    if (wrapper instanceof VoltSystemProcedure) {\n                        final Object[] combinedParams = new Object[callerParams.length + 1];\n                        combinedParams[0] = m_systemProcedureContext;\n                        for (int i=0; i < callerParams.length; ++i) combinedParams[i+1] = callerParams[i];\n                        cr = wrapper.call(txnState, combinedParams);\n                        response.setResults(cr, itask);\n                    }\n                    else {\n                        cr = wrapper.call(txnState, itask.getParameters());\n                        response.setResults(cr, itask);\n                    }\n                    // if enabled, send a record of this invocation to the secondary/dr cluster\n                    // if not enabled, should be a noop\n                    m_partitionDRGateway.onSuccessfulProcedureCall(itask.getTxnId(), itask.getStoredProcedureInvocation(), cr);\n                }\n            }\n            catch (final ExpectedProcedureException e) {\n                log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n                response.setResults(\n                                    new ClientResponseImpl(\n                                                           ClientResponse.GRACEFUL_FAILURE,\n                                                           new VoltTable[]{},\n                                                           e.toString()));\n            }\n            catch (final Exception e) {\n                // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n                // and converted them to error responses. Java errors are re-thrown, and not caught by this\n                // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n                hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n                VoltDB.crashVoltDB();\n            }\n        }\n        log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        return response;\n    }","id":81950,"modified_method":"@Override\n    public InitiateResponseMessage processInitiateTask(\n            TransactionState txnState,\n            final VoltMessage task)\n    {\n        final InitiateTaskMessage itask = (InitiateTaskMessage)task;\n        final VoltProcedure wrapper = procs.get(itask.getStoredProcedureName());\n\n        final InitiateResponseMessage response = new InitiateResponseMessage(itask);\n\n        // feasible to receive a transaction initiated with an earlier catalog.\n        if (wrapper == null) {\n            response.setResults(\n                new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                       new VoltTable[] {},\n                                       \"Procedure does not exist: \" + itask.getStoredProcedureName()));\n        }\n        else {\n            try {\n                Object[] callerParams = null;\n                /*\n                 * Parameters are lazily deserialized. We may not find out until now\n                 * that the parameter set is corrupt\n                 */\n                try {\n                    callerParams = itask.getParameters();\n                } catch (RuntimeException e) {\n                    Writer result = new StringWriter();\n                    PrintWriter pw = new PrintWriter(result);\n                    e.printStackTrace(pw);\n                    response.setResults(\n                            new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                                   new VoltTable[] {},\n                                                   \"Exception while deserializing procedure params\\n\" +\n                                                   result.toString()));\n                }\n                if (callerParams != null) {\n                    ClientResponseImpl cr = null;\n                    if (wrapper instanceof VoltSystemProcedure) {\n                        final Object[] combinedParams = new Object[callerParams.length + 1];\n                        combinedParams[0] = m_systemProcedureContext;\n                        for (int i=0; i < callerParams.length; ++i) combinedParams[i+1] = callerParams[i];\n                        cr = wrapper.call(txnState, combinedParams);\n                        response.setResults(cr, itask);\n                    }\n                    else {\n                        cr = wrapper.call(txnState, itask.getParameters());\n                        response.setResults(cr, itask);\n                    }\n                    // if enabled, send a record of this invocation to the secondary/dr cluster\n                    // if not enabled, should be a noop\n                    if (!itask.isReadOnly()) {\n                        m_partitionDRGateway.onSuccessfulProcedureCall(itask.getTxnId(), itask.getStoredProcedureInvocation(), cr);\n                    }\n                }\n            }\n            catch (final ExpectedProcedureException e) {\n                log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n                response.setResults(\n                                    new ClientResponseImpl(\n                                                           ClientResponse.GRACEFUL_FAILURE,\n                                                           new VoltTable[]{},\n                                                           e.toString()));\n            }\n            catch (final Exception e) {\n                // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n                // and converted them to error responses. Java errors are re-thrown, and not caught by this\n                // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n                hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n                VoltDB.crashVoltDB();\n            }\n        }\n        log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        return response;\n    }","commit_id":"73a98077f65ae389f479d3545d13a261f167e742","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public InitiateResponseMessage processInitiateTask(\n            TransactionState txnState,\n            final VoltMessage task)\n    {\n        final InitiateTaskMessage itask = (InitiateTaskMessage)task;\n        final VoltProcedure wrapper = procs.get(itask.getStoredProcedureName());\n\n        final InitiateResponseMessage response = new InitiateResponseMessage(itask);\n\n        // feasible to receive a transaction initiated with an earlier catalog.\n        if (wrapper == null) {\n            response.setResults(\n                new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                       new VoltTable[] {},\n                                       \"Procedure does not exist: \" + itask.getStoredProcedureName()));\n        }\n        else {\n            try {\n                Object[] callerParams = null;\n                /*\n                 * Parameters are lazily deserialized. We may not find out until now\n                 * that the parameter set is corrupt\n                 */\n                try {\n                    callerParams = itask.getParameters();\n                } catch (RuntimeException e) {\n                    Writer result = new StringWriter();\n                    PrintWriter pw = new PrintWriter(result);\n                    e.printStackTrace(pw);\n                    response.setResults(\n                            new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                                   new VoltTable[] {},\n                                                   \"Exception while deserializing procedure params\\n\" +\n                                                   result.toString()));\n                }\n                if (callerParams != null) {\n                    ClientResponseImpl cr = null;\n                    if (wrapper instanceof VoltSystemProcedure) {\n                        final Object[] combinedParams = new Object[callerParams.length + 1];\n                        combinedParams[0] = m_systemProcedureContext;\n                        for (int i=0; i < callerParams.length; ++i) combinedParams[i+1] = callerParams[i];\n                        cr = wrapper.call(txnState, combinedParams);\n                        response.setResults(cr, itask);\n                    }\n                    else {\n                        cr = wrapper.call(txnState, itask.getParameters());\n                        response.setResults(cr, itask);\n                    }\n                    // if enabled, send a record of this invocation to the secondary/dr cluster\n                    // if not enabled, should be a noop\n                    m_partitionDRGateway.onSuccessfulProcedureCall(itask.getTxnId(), itask.getStoredProcedureInvocation(), cr);\n                }\n            }\n            catch (final ExpectedProcedureException e) {\n                log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n                response.setResults(\n                                    new ClientResponseImpl(\n                                                           ClientResponse.GRACEFUL_FAILURE,\n                                                           new VoltTable[]{},\n                                                           e.toString()));\n            }\n            catch (final Exception e) {\n                // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n                // and converted them to error responses. Java errors are re-thrown, and not caught by this\n                // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n                hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n                VoltDB.crashVoltDB();\n            }\n        }\n        log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        return response;\n    }","id":81951,"modified_method":"@Override\n    public InitiateResponseMessage processInitiateTask(\n            TransactionState txnState,\n            final VoltMessage task)\n    {\n        final InitiateTaskMessage itask = (InitiateTaskMessage)task;\n        final VoltProcedure wrapper = procs.get(itask.getStoredProcedureName());\n\n        final InitiateResponseMessage response = new InitiateResponseMessage(itask);\n\n        // feasible to receive a transaction initiated with an earlier catalog.\n        if (wrapper == null) {\n            response.setResults(\n                new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                       new VoltTable[] {},\n                                       \"Procedure does not exist: \" + itask.getStoredProcedureName()));\n        }\n        else {\n            try {\n                Object[] callerParams = null;\n                /*\n                 * Parameters are lazily deserialized. We may not find out until now\n                 * that the parameter set is corrupt\n                 */\n                try {\n                    callerParams = itask.getParameters();\n                } catch (RuntimeException e) {\n                    Writer result = new StringWriter();\n                    PrintWriter pw = new PrintWriter(result);\n                    e.printStackTrace(pw);\n                    response.setResults(\n                            new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                                   new VoltTable[] {},\n                                                   \"Exception while deserializing procedure params\\n\" +\n                                                   result.toString()));\n                }\n                if (callerParams != null) {\n                    ClientResponseImpl cr = null;\n                    if (wrapper instanceof VoltSystemProcedure) {\n                        final Object[] combinedParams = new Object[callerParams.length + 1];\n                        combinedParams[0] = m_systemProcedureContext;\n                        for (int i=0; i < callerParams.length; ++i) combinedParams[i+1] = callerParams[i];\n                        cr = wrapper.call(txnState, combinedParams);\n                        response.setResults(cr, itask);\n                    }\n                    else {\n                        cr = wrapper.call(txnState, itask.getParameters());\n                        response.setResults(cr, itask);\n                    }\n                    // if enabled, send a record of this invocation to the secondary/dr cluster\n                    // if not enabled, should be a noop\n                    if (!itask.isReadOnly()) {\n                        m_partitionDRGateway.onSuccessfulProcedureCall(itask.getTxnId(), itask.getStoredProcedureInvocation(), cr);\n                    }\n                }\n            }\n            catch (final ExpectedProcedureException e) {\n                log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n                response.setResults(\n                                    new ClientResponseImpl(\n                                                           ClientResponse.GRACEFUL_FAILURE,\n                                                           new VoltTable[]{},\n                                                           e.toString()));\n            }\n            catch (final Exception e) {\n                // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n                // and converted them to error responses. Java errors are re-thrown, and not caught by this\n                // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n                hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n                VoltDB.crashVoltDB();\n            }\n        }\n        log.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        return response;\n    }","commit_id":"cd402b6aef1dd4b9e60288fd613c8cda0796ddd7","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   */\n  public final void deleteAt(final int index) {\n    Array.move(list, index + 1, -1, --size - index);\n  }","id":81952,"modified_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   * @return deleted element\n   */\n  public final int deleteAt(final int index) {\n    final int l = list[index];\n    Array.move(list, index + 1, -1, --size - index);\n    return l;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks the file contents.\n   * @param input input path\n   * @param content content pattern\n   * @param matches set with matches\n   * @return maximum number of results reached\n   */\n  private boolean filterContent(final byte[] input, final int[] content, final TokenSet matches) {\n    // accept file; check file contents\n    if(filterContent(input, content) && !matches.contains(input)) {\n      matches.add(input);\n      if(matches.size() >= MAXHITS) return true;\n    }\n    return false;\n  }","id":81953,"modified_method":"/**\n   * Adds a file to the matches if the specified string is found.\n   * Checks the file contents.\n   * @param path file path\n   * @param search search string\n   * @param results search result\n   * @return maximum number of results reached\n   */\n  private boolean filterContent(final byte[] path, final int[] search, final TokenSet results) {\n    // accept file; check file contents\n    if(filterContent(path, search) && !results.contains(path)) {\n      results.add(path);\n      if(results.size() >= MAXHITS) return true;\n    }\n    return false;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param content content pattern\n   * @param thread current thread id\n   * @param matches set with matches\n   * @return success flag\n   */\n  private boolean filter(final String pattern, final int[] content, final int thread,\n      final TokenSet matches) {\n\n    // glob pattern\n    if(pattern.contains(\"*\") || pattern.contains(\"?\")) {\n      final Pattern pt = Pattern.compile(IOFile.regex(pattern));\n      for(final byte[] input : cache) {\n        final int offset = offset(input, true);\n        if(pt.matcher(Token.string(Token.substring(input, offset))).matches() &&\n            filterContent(input, content, matches)) return true;\n        if(thread != threadID) return false;\n      }\n    }\n    // starts-with, contains, camel case\n    final byte[] patt = Token.token(pattern);\n    for(int i = 0; i < 3; i++) {\n      if(!filter(patt, content, thread, i, matches)) return false;\n    }\n    return true;\n  }","id":81954,"modified_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param search search string\n   * @param thread current thread id\n   * @param results search result\n   * @return success flag\n   */\n  private boolean filter(final String pattern, final int[] search, final int thread,\n      final TokenSet results) {\n\n    // glob pattern\n    if(pattern.contains(\"*\") || pattern.contains(\"?\")) {\n      final Pattern pt = Pattern.compile(IOFile.regex(pattern));\n      for(final byte[] input : cache) {\n        final int offset = offset(input, true);\n        if(pt.matcher(Token.string(Token.substring(input, offset))).matches() &&\n            filterContent(input, search, results)) return true;\n        if(thread != threadID) return false;\n      }\n    }\n\n    // starts-with, contains, camel case\n    final byte[] patt = Token.token(pattern);\n    final TokenSet exclude = new TokenSet();\n    for(int i = 0; i < 3; i++) {\n      if(!filter(patt, search, thread, i, results, exclude)) return false;\n    }\n    return true;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Filters the entries.\n   * @param pattern files pattern\n   * @param content contents pattern\n   * @param thread thread id\n   */\n  void filter(final String pattern, final String content, final int thread) {\n    // wait when command is still running\n    while(running) {\n      Thread.yield();\n      // newer thread has arrived\n      if(threadID != thread) return;\n    }\n\n    // thread is accepted; start filtering\n    running = true;\n    files.setCursor(CURSORWAIT);\n    contents.setCursor(CURSORWAIT);\n    init(thread);\n\n    // collect matches\n    final TokenSet matches = new TokenSet();\n    final IntList il = new IntList();\n    final TokenParser tp = new TokenParser(Token.token(content));\n    while(tp.more()) il.add(Token.lc(tp.next()));\n    if(filter(pattern, il.toArray(), thread, matches)) {\n      project.list.setElements(matches, content.isEmpty() ? null : content);\n    }\n\n    files.setCursor(CURSORTEXT);\n    contents.setCursor(CURSORTEXT);\n    running = false;\n  }","id":81955,"modified_method":"/**\n   * Filters the entries.\n   * @param file file search string\n   * @param content content search string\n   * @param thread thread id\n   */\n  void filter(final String file, final String content, final int thread) {\n    // wait when command is still running\n    while(running) {\n      Thread.yield();\n      // newer thread has arrived\n      if(threadID != thread) return;\n    }\n\n    // thread is accepted; start filtering\n    running = true;\n    files.setCursor(CURSORWAIT);\n    contents.setCursor(CURSORWAIT);\n    init(thread);\n\n    // collect matches\n    final TokenSet results = new TokenSet();\n    final IntList il = new IntList();\n    final TokenParser tp = new TokenParser(Token.token(content));\n    while(tp.more()) il.add(Token.lc(tp.next()));\n    if(filter(file, il.toArray(), thread, results)) {\n      project.list.setElements(results, content.isEmpty() ? null : content);\n    }\n\n    files.setCursor(CURSORTEXT);\n    contents.setCursor(CURSORTEXT);\n    running = false;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Searches a string in a file.\n   * @param path file path\n   * @param cont file contents\n   * @return result of check\n   */\n  private boolean filterContent(final byte[] path, final int[] cont) {\n    final int cl = cont.length;\n    if(cl == 0) return true;\n\n    TextInput ti = null;\n    try {\n      ti = new TextInput(new IOFile(Token.string(path)));\n      for(int c = 0, cp = 0; (cp = ti.read()) != -1;) {\n        if(!XMLToken.valid(cp)) break;\n        if(Token.lc(cp) == cont[c]) {\n          if(++c == cl) return true;\n        } else {\n          c = 0;\n        }\n      }\n    } catch(final IOException ex) {\n      // file may not be accessible\n      Util.debug(ex);\n    } finally {\n      if(ti != null) try { ti.close(); } catch(final IOException ignored) { }\n    }\n    return false;\n  }","id":81956,"modified_method":"/**\n   * Searches a string in a file.\n   * @param path file path\n   * @param search search string\n   * @return success flag\n   */\n  private boolean filterContent(final byte[] path, final int[] search) {\n    final int cl = search.length;\n    if(cl == 0) return true;\n\n    try {\n      final TextInput ti = new TextInput(new IOFile(Token.string(path)));\n      try {\n        final IntList il = new IntList(cl - 1);\n        int c = 0;\n        while(true) {\n          if(!il.isEmpty()) {\n            if(il.deleteAt(0) == search[c++]) continue;\n            c = 0;\n          }\n          while(true) {\n            final int cp = ti.read();\n            if(cp == -1 || !XMLToken.valid(cp)) return false;\n            final int lc = Token.lc(cp);\n            if(c > 0) il.add(lc);\n            if(lc == search[c]) {\n              if(++c == cl) return true;\n            } else {\n              c = 0;\n              break;\n            }\n          }\n        }\n      } finally {\n        ti.close();\n      }\n    } catch(final IOException ex) {\n      // file may not be accessible\n      Util.debug(ex);\n      return false;\n    }\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param cont content pattern\n   * @param thread current thread id\n   * @param mode search mode (0-2)\n   * @param matches set with matches\n   * @return success flag\n   */\n  private boolean filter(final byte[] pattern, final int[] cont, final int thread, final int mode,\n      final TokenSet matches) {\n\n    if(matches.size() < MAXHITS) {\n      final boolean path = Token.indexOf(pattern, '\\\\') != -1 || Token.indexOf(pattern, '/') != -1;\n      for(final byte[] input : cache) {\n        // check if current file matches the pattern\n        final int offset = offset(input, path);\n        if(mode == 0 && Token.startsWith(input, pattern, offset) ||\n           mode == 1 && Token.contains(input, pattern, offset) ||\n           matches(input, pattern, offset)) {\n          if(filterContent(input, cont, matches)) return true;\n        }\n        if(thread != threadID) return false;\n      }\n    }\n    return true;\n  }","id":81957,"modified_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param search search string\n   * @param thread current thread id\n   * @param mode search mode (0-2)\n   * @param results search result\n   * @param exclude exclude file from content search\n   * @return success flag\n   */\n  private boolean filter(final byte[] pattern, final int[] search, final int thread, final int mode,\n      final TokenSet results, final TokenSet exclude) {\n\n    if(results.size() < MAXHITS) {\n      final boolean path = Token.indexOf(pattern, '\\\\') != -1 || Token.indexOf(pattern, '/') != -1;\n      for(final byte[] input : cache) {\n        // check if current file matches the pattern\n        final int offset = offset(input, path);\n        if(mode == 0 && Token.startsWith(input, pattern, offset) ||\n           mode == 1 && Token.contains(input, pattern, offset) ||\n           matches(input, pattern, offset)) {\n          if(!exclude.contains(input)) {\n            exclude.add(input);\n            if(filterContent(input, search, results)) return true;\n          }\n        }\n        if(thread != threadID) return false;\n      }\n    }\n    return true;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Assigns the specified list entries and selects the first entry.\n   * @param matches entries to set\n   * @param srch content search string\n   */\n  void setElements(final TokenSet matches, final String srch) {\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        // set new values and selections\n        final int is = matches.size();\n        final String[] list = new String[is];\n        for(int i = 0; i < is; i++) list[i] = Token.string(matches.key(i + 1));\n        if(changed(list)) {\n          // check which old values had been selected\n          final Object[] old = getSelectedValues();\n          final IntList il = new IntList();\n          for(final Object o : old) {\n            for(int i = 0; i < is; i++) {\n              if(o.equals(matches.key(i + 1))) {\n                il.add(i);\n                break;\n              }\n            }\n          }\n          setListData(list);\n          setSelectedIndices(il.toArray());\n        }\n        search = srch;\n      }\n    });\n  }","id":81958,"modified_method":"/**\n   * Assigns the specified list entries and selects the first entry.\n   * @param elements result elements\n   * @param srch content search string\n   */\n  void setElements(final TokenSet elements, final String srch) {\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        // set new values and selections\n        final int is = elements.size();\n        final String[] list = new String[is];\n        for(int i = 0; i < is; i++) list[i] = Token.string(elements.key(i + 1));\n        if(changed(list)) {\n          // check which old values had been selected\n          final Object[] old = getSelectedValues();\n          final IntList il = new IntList();\n          for(final Object o : old) {\n            for(int i = 0; i < is; i++) {\n              if(o.equals(elements.key(i + 1))) {\n                il.add(i);\n                break;\n              }\n            }\n          }\n          setListData(list);\n          setSelectedIndices(il.toArray());\n        }\n        search = srch;\n      }\n    });\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes the specified element.\n   * @param index index of element to be deleted\n   */\n  public final void deleteAt(final int index) {\n    Array.move(list, index + 1, -1, --size - index);\n  }","id":81959,"modified_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   * @return deleted element\n   */\n  public final String deleteAt(final int index) {\n    final String l = list[index];\n    Array.move(list, index + 1, -1, --size - index);\n    return l;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   */\n  public void deleteAt(final int index) {\n    Array.move(list, index + 1, -1, --size - index);\n  }","id":81960,"modified_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   * @return deleted element\n   */\n  public byte[] deleteAt(final int index) {\n    final byte[] l = list[index];\n    Array.move(list, index + 1, -1, --size - index);\n    return l;\n  }","commit_id":"db8ae47cd428d2057af8babc01d47132bdcb2038","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Test method. */\n  @Test\n  public void create() {\n    execute(new Close());\n\n    // create DB without initial content\n    query(_DB_CREATE.args(NAME));\n    query(_DB_EXISTS.args(NAME), true);\n\n    // create DB w/ initial content\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // create DB w/ initial content via document constructor\n    query(_DB_CREATE.args(NAME, \" document { <dummy/> }\", \"t2.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // create DB w/ initial content given as string\n    query(_DB_CREATE.args(NAME, \"\\\"<dummy/>\\\"\", \"t1.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // create DB w/ initial content multiple times\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\"));\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // try to create DB twice during same query\n    error(_DB_CREATE.args(NAME) + ',' + _DB_CREATE.args(NAME), BXDB_ONCE_X_X);\n\n    // create DB from file\n    query(_DB_CREATE.args(NAME, XML, \"in/\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/in/input.xml\") + \"/html\"), \"1\");\n\n    // create DB from folder\n    query(_DB_CREATE.args(NAME, FLDR, \"test/dir\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/dir\")), XMLFILES);\n\n    // create DB w/ more than one input\n    query(_DB_CREATE.args(NAME, \"(<a/>,<b/>)\", \"('1.xml','2.xml')\"));\n    query(_DB_CREATE.args(NAME, \"(<a/>,'\" + XML + \"')\", \"('1.xml','2.xml')\"));\n\n    error(_DB_CREATE.args(NAME, \"()\", \"1.xml\"), BXDB_CREATEARGS_X_X);\n    error(_DB_CREATE.args(NAME, \"(<a/>,<b/>)\", \"1.xml\"), BXDB_CREATEARGS_X_X);\n\n    // create and drop more than one database\n    query(\"for $i in 1 to 5 return \" + _DB_CREATE.args(\" '\" + NAME + \"' || $i\"));\n    query(\"for $i in 1 to 5 return \" + _DB_DROP.args(\" '\" + NAME + \"' || $i\"));\n\n    // create DB with initial EMPTY content\n    error(_DB_CREATE.args(\"\"), BXDB_NAME_X);\n\n    // try to access non-existing DB\n    query(_DB_DROP.args(NAME));\n    error(_DB_CREATE.args(NAME) + ',' + _DB_DROP.args(NAME), BXDB_WHICH_X);\n\n    // run update on existing DB then drop it and create a new one\n    query(_DB_CREATE.args(NAME, \"<a/>\", \"a.xml\"));\n    query(\"insert node <dummy/> into \" + _DB_OPEN.args(NAME));\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\") +\n        \", insert node <dummy/> into \" + _DB_OPEN.args(NAME) + ',' +\n        _DB_DROP.args(NAME));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // eventually drop database\n    query(_DB_DROP.args(NAME));\n\n    // specify index options\n    for(final boolean b : new boolean[] { false, true }) {\n      query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { 'updindex':\" + b + \"() }\"));\n      query(_DB_INFO.args(NAME) + \"//updindex/text()\", b);\n    }\n    assertEquals(context.options.get(MainOptions.UPDINDEX), false);\n\n    final String[] nopt = { \"maxcats\", \"maxlen\", \"indexsplitsize\", \"ftindexsplitsize\" };\n    for(final String k : nopt) {\n      query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + k + \"':1 }\"));\n    }\n    final String[] bopt = { \"textindex\", \"attrindex\", \"ftindex\", \"stemming\",\n        \"casesens\", \"diacritics\" };\n    for(final String k : bopt) {\n      for(final boolean v : new boolean[] { true, false }) {\n        query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + k + \"':\" + v + \"() }\"));\n      }\n    }\n    final String[] sopt = { \"language\", \"stopwords\" };\n    for(final String k : sopt) {\n      query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + k + \"':'' }\"));\n    }\n\n    // specify parsing options\n    query(_DB_CREATE.args(NAME, \" '<a> <\/a>'\", \"a.xml\", \" map { 'chop':true() }\"));\n    query(_DB_OPEN.args(NAME), \"<a/>\");\n    query(_DB_CREATE.args(NAME, \" '<a> <\/a>'\", \"a.xml\", \" map { 'chop':false() }\"));\n    query(_DB_OPEN.args(NAME), \"<a> <\/a>\");\n\n    // specify unknown or invalid options\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { 'xyz':'abc' }\"), BASX_OPTIONS_X);\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { 'maxlen':-1 }\"), BASX_VALUE_X_X);\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { 'maxlen':'a' }\"), BASX_VALUE_X_X);\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { 'textindex':'nope' }\"), BASX_VALUE_X_X);\n  }","id":81961,"modified_method":"/** Test method. */\n  @Test\n  public void create() {\n    execute(new Close());\n\n    // create DB without initial content\n    query(_DB_CREATE.args(NAME));\n    query(_DB_EXISTS.args(NAME), true);\n\n    // create DB w/ initial content\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // create DB w/ initial content via document constructor\n    query(_DB_CREATE.args(NAME, \" document { <dummy/> }\", \"t2.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // create DB w/ initial content given as string\n    query(_DB_CREATE.args(NAME, \"\\\"<dummy/>\\\"\", \"t1.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // create DB w/ initial content multiple times\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\"));\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\"));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // try to create DB twice during same query\n    error(_DB_CREATE.args(NAME) + ',' + _DB_CREATE.args(NAME), BXDB_ONCE_X_X);\n\n    // create DB from file\n    query(_DB_CREATE.args(NAME, XML, \"in/\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/in/input.xml\") + \"/html\"), \"1\");\n\n    // create DB from folder\n    query(_DB_CREATE.args(NAME, FLDR, \"test/dir\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/dir\")), XMLFILES);\n\n    // create DB w/ more than one input\n    query(_DB_CREATE.args(NAME, \"(<a/>,<b/>)\", \"('1.xml','2.xml')\"));\n    query(_DB_CREATE.args(NAME, \"(<a/>,'\" + XML + \"')\", \"('1.xml','2.xml')\"));\n\n    error(_DB_CREATE.args(NAME, \"()\", \"1.xml\"), BXDB_CREATEARGS_X_X);\n    error(_DB_CREATE.args(NAME, \"(<a/>,<b/>)\", \"1.xml\"), BXDB_CREATEARGS_X_X);\n\n    // create and drop more than one database\n    query(\"for $i in 1 to 5 return \" + _DB_CREATE.args(\" '\" + NAME + \"' || $i\"));\n    query(\"for $i in 1 to 5 return \" + _DB_DROP.args(\" '\" + NAME + \"' || $i\"));\n\n    // create DB with initial EMPTY content\n    error(_DB_CREATE.args(\"\"), BXDB_NAME_X);\n\n    // try to access non-existing DB\n    query(_DB_DROP.args(NAME));\n    error(_DB_CREATE.args(NAME) + ',' + _DB_DROP.args(NAME), BXDB_WHICH_X);\n\n    // run update on existing DB then drop it and create a new one\n    query(_DB_CREATE.args(NAME, \"<a/>\", \"a.xml\"));\n    query(\"insert node <dummy/> into \" + _DB_OPEN.args(NAME));\n    query(_DB_CREATE.args(NAME, \"<dummy/>\", \"t1.xml\") +\n        \", insert node <dummy/> into \" + _DB_OPEN.args(NAME) + ',' +\n        _DB_DROP.args(NAME));\n    query(_DB_OPEN.args(NAME) + \"/root()\", \"<dummy/>\");\n\n    // eventually drop database\n    query(_DB_DROP.args(NAME));\n\n    // specify index options\n    for(final boolean b : new boolean[] { false, true }) {\n      query(_DB_CREATE.args(NAME, \"()\", \"()\",\n          \" map { '\" + lc(MainOptions.UPDINDEX) + \"':\" + b + \"() }\"));\n      query(_DB_INFO.args(NAME) + \"//\" + lc(MainOptions.UPDINDEX) + \"/text()\", b);\n    }\n    assertEquals(context.options.get(MainOptions.UPDINDEX), false);\n\n    final String[] numberOptions = lc(MainOptions.MAXCATS, MainOptions.MAXLEN,\n        MainOptions.SPLITSIZE);\n    final String[] boolOptions = lc(MainOptions.TEXTINDEX, MainOptions.ATTRINDEX,\n        MainOptions.TOKENINDEX, MainOptions.FTINDEX, MainOptions.STEMMING,\n        MainOptions.CASESENS, MainOptions.DIACRITICS);\n    final String[] stringOptions = lc(MainOptions.LANGUAGE, MainOptions.STOPWORDS);\n\n    for(final String option : numberOptions) {\n      query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + option + \"':1 }\"));\n    }\n    for(final String option : boolOptions) {\n      for(final boolean v : new boolean[] { true, false }) {\n        query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + option + \"':\" + v + \"() }\"));\n      }\n    }\n    for(final String option : stringOptions) {\n      query(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + option + \"':'' }\"));\n    }\n\n    // specify parsing options\n    query(_DB_CREATE.args(NAME, \" '<a> <\/a>'\", \"a.xml\",\n        \" map { '\" + lc(MainOptions.CHOP) + \"':true() }\"));\n    query(_DB_OPEN.args(NAME), \"<a/>\");\n    query(_DB_CREATE.args(NAME, \" '<a> <\/a>'\", \"a.xml\",\n        \" map { '\" + lc(MainOptions.CHOP) + \"':false() }\"));\n    query(_DB_OPEN.args(NAME), \"<a> <\/a>\");\n\n    // specify unknown or invalid options\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { 'xyz':'abc' }\"), BASX_OPTIONS_X);\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + lc(MainOptions.MAXLEN) + \"':-1 }\"),\n        BASX_VALUE_X_X);\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + lc(MainOptions.MAXLEN) + \"':'a' }\"),\n        BASX_VALUE_X_X);\n    error(_DB_CREATE.args(NAME, \"()\", \"()\", \" map { '\" + lc(MainOptions.TEXTINDEX) + \"':'nope' }\"),\n        BASX_VALUE_X_X);\n  }","commit_id":"2f6ba3d405ecb719908b604f7cab31adb13facec","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns lower-case representations of the specified options.\n   * @param options options\n   * @return string\n   */\n  private String[] lc(final Option<?>... options) {\n    final StringList sl = new StringList();\n    for(final Option<?> option : options) sl.add(option.name().toLowerCase(Locale.ENGLISH));\n    return sl.finish();\n  }","id":81962,"modified_method":"/**\n   * Returns lower-case representations of the specified options.\n   * @param options options\n   * @return string\n   */\n  private String[] lc(final Option<?>... options) {\n    final StringList sl = new StringList();\n    for(final Option<?> option : options) sl.add(lc(option));\n    return sl.finish();\n  }","commit_id":"2f6ba3d405ecb719908b604f7cab31adb13facec","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Test method. */\n  @Test\n  public void add() {\n    query(COUNT.args(COLLECTION.args(NAME)), \"1\");\n    query(_DB_ADD.args(NAME, XML));\n    query(COUNT.args(COLLECTION.args(NAME)), \"2\");\n\n    query(_DB_ADD.args(NAME, \"\\\"<root/>\\\"\", \"t1.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/t1.xml\") + \"/root\"), \"1\");\n\n    query(_DB_ADD.args(NAME, \" document { <root/> }\", \"t2.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/t2.xml\") + \"/root\"), \"1\");\n\n    query(_DB_ADD.args(NAME, \" <root/>\", \"test/t3.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/t3.xml\") + \"/root\"), \"1\");\n\n    query(_DB_ADD.args(NAME, XML, \"in/\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/in/input.xml\") + \"/html\"), \"1\");\n\n    query(_DB_ADD.args(NAME, XML, \"test/t4.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/t4.xml\") + \"/html\"), \"1\");\n\n    query(_DB_ADD.args(NAME, FLDR, \"test/dir\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/dir\")), XMLFILES);\n\n    query(\"for $f in \" + _FILE_LIST.args(FLDR, true, \"*.xml\") +\n        \" return \" + _DB_ADD.args(NAME, \" '\" + FLDR + \"' || $f\", \"dir\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/dir\")), XMLFILES);\n\n    query(\"for $i in 1 to 3 return \" +\n        _DB_ADD.args(NAME, \"\\\"<root/>\\\"\", \"\\\"doc\\\" || $i\"));\n    query(COUNT.args(\" for $i in 1 to 3 return \" +\n        COLLECTION.args('\"' + NAME + \"/doc\\\" || $i\")), 3);\n\n    // specify parsing options\n    query(_DB_ADD.args(NAME, \" '<a> <\/a>'\", \"chop.xml\", \" map { 'chop':true() }\"));\n    query(_DB_OPEN.args(NAME, \"chop.xml\"), \"<a/>\");\n    query(_DB_ADD.args(NAME, \" '<a> <\/a>'\", \"nochop.xml\", \" map { 'chop':false() }\"));\n    query(_DB_OPEN.args(NAME, \"nochop.xml\"), \"<a> <\/a>\");\n\n    // specify parsing options\n    query(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': 'header=true' }\"));\n    query(EXISTS.args(_DB_OPEN.args(NAME, \"csv.xml\") + \"//City\"), \"true\");\n    query(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'header': 'true' } }\"));\n    query(EXISTS.args(_DB_OPEN.args(NAME, \"csv.xml\") + \"//City\"), \"true\");\n    query(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'header': true() } }\"));\n    query(EXISTS.args(_DB_OPEN.args(NAME, \"csv.xml\") + \"//City\"), \"true\");\n\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':('csv','html') }\"), INVALIDOPT_X);\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'header': ('true','false') } }\"), INVALIDOPT_X);\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'headr': 'true' } }\"), BASX_WHICH_X);\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': 'headr=true' }\"), BASX_WHICH_X);\n  }","id":81963,"modified_method":"/** Test method. */\n  @Test\n  public void add() {\n    query(COUNT.args(COLLECTION.args(NAME)), \"1\");\n    query(_DB_ADD.args(NAME, XML));\n    query(COUNT.args(COLLECTION.args(NAME)), \"2\");\n\n    query(_DB_ADD.args(NAME, \"\\\"<root/>\\\"\", \"t1.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/t1.xml\") + \"/root\"), \"1\");\n\n    query(_DB_ADD.args(NAME, \" document { <root/> }\", \"t2.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/t2.xml\") + \"/root\"), \"1\");\n\n    query(_DB_ADD.args(NAME, \" <root/>\", \"test/t3.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/t3.xml\") + \"/root\"), \"1\");\n\n    query(_DB_ADD.args(NAME, XML, \"in/\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/in/input.xml\") + \"/html\"), \"1\");\n\n    query(_DB_ADD.args(NAME, XML, \"test/t4.xml\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/t4.xml\") + \"/html\"), \"1\");\n\n    query(_DB_ADD.args(NAME, FLDR, \"test/dir\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/test/dir\")), XMLFILES);\n\n    query(\"for $f in \" + _FILE_LIST.args(FLDR, true, \"*.xml\") +\n        \" return \" + _DB_ADD.args(NAME, \" '\" + FLDR + \"' || $f\", \"dir\"));\n    query(COUNT.args(COLLECTION.args(NAME + \"/dir\")), XMLFILES);\n\n    query(\"for $i in 1 to 3 return \" +\n        _DB_ADD.args(NAME, \"\\\"<root/>\\\"\", \"\\\"doc\\\" || $i\"));\n    query(COUNT.args(\" for $i in 1 to 3 return \" +\n        COLLECTION.args('\"' + NAME + \"/doc\\\" || $i\")), 3);\n\n    // specify parsing options\n    query(_DB_ADD.args(NAME, \" '<a> <\/a>'\", \"chop.xml\",\n        \" map { '\" + lc(MainOptions.CHOP) + \"':true() }\"));\n    query(_DB_OPEN.args(NAME, \"chop.xml\"), \"<a/>\");\n    query(_DB_ADD.args(NAME, \" '<a> <\/a>'\", \"nochop.xml\",\n        \" map { '\" + lc(MainOptions.CHOP) + \"':false() }\"));\n    query(_DB_OPEN.args(NAME, \"nochop.xml\"), \"<a> <\/a>\");\n\n    // specify parsing options\n    query(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': 'header=true' }\"));\n    query(EXISTS.args(_DB_OPEN.args(NAME, \"csv.xml\") + \"//City\"), \"true\");\n    query(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'header': 'true' } }\"));\n    query(EXISTS.args(_DB_OPEN.args(NAME, \"csv.xml\") + \"//City\"), \"true\");\n    query(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'header': true() } }\"));\n    query(EXISTS.args(_DB_OPEN.args(NAME, \"csv.xml\") + \"//City\"), \"true\");\n\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':('csv','html') }\"), INVALIDOPT_X);\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'header': ('true','false') } }\"), INVALIDOPT_X);\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': map { 'headr': 'true' } }\"), BASX_WHICH_X);\n    error(_DB_ADD.args(NAME, CSV, \"csv.xml\",\n        \" map { 'parser':'csv','csvparser': 'headr=true' }\"), BASX_WHICH_X);\n  }","commit_id":"2f6ba3d405ecb719908b604f7cab31adb13facec","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Test method. */\n  @Test\n  public void optimize() {\n    // simple optimize call\n    query(_DB_OPTIMIZE.args(NAME));\n    query(_DB_OPTIMIZE.args(NAME));\n    // opened database cannot be fully optimized\n    error(_DB_OPTIMIZE.args(NAME, true), UPDBOPTERR_X);\n    execute(new Close());\n    query(_DB_OPTIMIZE.args(NAME, true));\n\n    // commands\n    final CmdIndex[] cis = { CmdIndex.TEXT, CmdIndex.ATTRIBUTE, CmdIndex.TOKEN, CmdIndex.FULLTEXT };\n    // options\n    final String[] numberOptions = lc(MainOptions.MAXCATS, MainOptions.MAXLEN,\n        MainOptions.SPLITSIZE);\n    final String[] boolOptions = lc(MainOptions.TEXTINDEX, MainOptions.ATTRINDEX,\n        MainOptions.TOKENINDEX, MainOptions.FTINDEX, MainOptions.STEMMING,\n        MainOptions.CASESENS, MainOptions.DIACRITICS);\n    final String[] stringOptions = lc(MainOptions.LANGUAGE, MainOptions.STOPWORDS);\n    final String[] indexes = lc(MainOptions.TEXTINDEX, MainOptions.ATTRINDEX,\n        MainOptions.TOKENINDEX, MainOptions.FTINDEX);\n    final String[] includes = lc(MainOptions.TEXTINCLUDE, MainOptions.ATTRINCLUDE,\n        MainOptions.TOKENINCLUDE, MainOptions.FTINCLUDE);\n\n    // check single options\n    for(final String option : numberOptions)\n      query(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + option + \"': 1 }\"));\n    for(final String option : boolOptions) {\n      for(final boolean bool : new boolean[] { true, false })\n        query(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + option + \"':\" + bool + \"() }\"));\n    }\n    for(final String option : stringOptions)\n      query(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + option + \"':'' }\"));\n    // ensure that option in context was not changed\n    assertEquals(context.options.get(MainOptions.TEXTINDEX), true);\n\n    // check invalid options\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { 'xyz': 'abc' }\"), BASX_OPTIONS_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { 'updindex': 1 }\"), BASX_OPTIONS_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { 'maxlen': -1 }\"), BASX_VALUE_X_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { 'maxlen': 'a' }\"), BASX_VALUE_X_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { 'textindex':'nope' }\"), BASX_VALUE_X_X);\n\n    // check if optimize call adopts original options\n    query(_DB_OPTIMIZE.args(NAME));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"false\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"\");\n\n    // check if options in context are adopted\n    execute(new Open(NAME));\n    for(final String inc : includes) execute(new Set(inc, \"a\"));\n    for(final CmdIndex ci : cis) execute(new CreateIndex(ci));\n    execute(new Close());\n    query(_DB_OPTIMIZE.args(NAME));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"true\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"a\");\n\n    // check if options in context are adopted, even if database is closed (reset options)\n    execute(new Open(NAME));\n    for(final String inc : includes) execute(new Set(inc, \"\"));\n    for(final CmdIndex cmd : cis) execute(new DropIndex(cmd));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"false\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"\");\n    execute(new Close());\n    query(_DB_OPTIMIZE.args(NAME));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"false\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"\");\n\n    // check if options specified in map are adopted\n    query(_DB_OPTIMIZE.args(NAME, true, \" map {\"\n        + \"'textindex':true(),'attrindex':true(),'ftindex':true(),'tokenindex':true(),\"\n        + \"'updindex':true(),'textinclude':'a','attrinclude':'a','tokeninclude':'a','ftinclude':'a'\"\n        + \" }\"));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"true\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"a\");\n    query(_DB_INFO.args(NAME) + \"//updindex/text()\", \"true\");\n  }","id":81964,"modified_method":"/** Test method. */\n  @Test\n  public void optimize() {\n    // simple optimize call\n    query(_DB_OPTIMIZE.args(NAME));\n    query(_DB_OPTIMIZE.args(NAME));\n    // opened database cannot be fully optimized\n    error(_DB_OPTIMIZE.args(NAME, true), UPDBOPTERR_X);\n    execute(new Close());\n    query(_DB_OPTIMIZE.args(NAME, true));\n\n    // commands\n    final CmdIndex[] cis = { CmdIndex.TEXT, CmdIndex.ATTRIBUTE, CmdIndex.TOKEN, CmdIndex.FULLTEXT };\n    // options\n    final String[] indexes = lc(MainOptions.TEXTINDEX, MainOptions.ATTRINDEX,\n        MainOptions.TOKENINDEX, MainOptions.FTINDEX);\n    final String[] includes = lc(MainOptions.TEXTINCLUDE, MainOptions.ATTRINCLUDE,\n        MainOptions.TOKENINCLUDE, MainOptions.FTINCLUDE);\n    final String[] boolOptions = new StringList(indexes).add(lc(MainOptions.STEMMING,\n        MainOptions.CASESENS, MainOptions.DIACRITICS)).finish();\n    final String[] stringOptions = lc(MainOptions.LANGUAGE, MainOptions.STOPWORDS);\n    final String[] numberOptions = lc(MainOptions.MAXCATS, MainOptions.MAXLEN,\n        MainOptions.SPLITSIZE);\n\n    // check single options\n    for(final String option : numberOptions)\n      query(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + option + \"': 1 }\"));\n    for(final String option : boolOptions) {\n      for(final boolean bool : new boolean[] { true, false })\n        query(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + option + \"':\" + bool + \"() }\"));\n    }\n    for(final String option : stringOptions)\n      query(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + option + \"':'' }\"));\n    // ensure that option in context was not changed\n    assertEquals(context.options.get(MainOptions.TEXTINDEX), true);\n\n    // check invalid options\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { 'xyz': 'abc' }\"), BASX_OPTIONS_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + lc(MainOptions.UPDINDEX) + \"': 1 }\"),\n        BASX_OPTIONS_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + lc(MainOptions.MAXLEN) + \"': -1 }\"),\n        BASX_VALUE_X_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + lc(MainOptions.MAXLEN) + \"': 'a' }\"),\n        BASX_VALUE_X_X);\n    error(_DB_OPTIMIZE.args(NAME, false, \" map { '\" + lc(MainOptions.TEXTINDEX) + \"':'nope' }\"),\n        BASX_VALUE_X_X);\n\n    // check if optimize call adopts original options\n    query(_DB_OPTIMIZE.args(NAME));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"false\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"\");\n\n    // check if options in context are adopted\n    execute(new Open(NAME));\n    for(final String inc : includes) execute(new Set(inc, \"a\"));\n    for(final CmdIndex ci : cis) execute(new CreateIndex(ci));\n    execute(new Close());\n    query(_DB_OPTIMIZE.args(NAME));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"true\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"a\");\n\n    // check if options in context are adopted, even if database is closed (reset options)\n    execute(new Open(NAME));\n    for(final String inc : includes) execute(new Set(inc, \"\"));\n    for(final CmdIndex cmd : cis) execute(new DropIndex(cmd));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"false\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"\");\n    execute(new Close());\n    query(_DB_OPTIMIZE.args(NAME));\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"false\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"\");\n\n    // check if options specified in map are adopted\n    final StringBuilder options = new StringBuilder();\n    for(final String option : indexes) options.append(\"'\").append(option).append(\"':true(),\");\n    for(final String option : includes) options.append(\"'\").append(option).append(\"':'a',\");\n    options.append(\"'\").append(lc(MainOptions.UPDINDEX)).append(\"':true()\");\n    query(_DB_OPTIMIZE.args(NAME, true, \" map { \" + options + \"}\"));\n\n    for(final String ind : indexes) query(_DB_INFO.args(NAME) + \"//\" + ind + \"/text()\", \"true\");\n    for(final String inc : includes) query(_DB_INFO.args(NAME) + \"//\" + inc + \"/text()\", \"a\");\n    query(_DB_INFO.args(NAME) + \"//\" + lc(MainOptions.UPDINDEX) + \"/text()\", \"true\");\n  }","commit_id":"2f6ba3d405ecb719908b604f7cab31adb13facec","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   */\n  public final void deleteAt(final int index) {\n    Array.move(list, index + 1, -1, --size - index);\n  }","id":81965,"modified_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   * @return deleted element\n   */\n  public final int deleteAt(final int index) {\n    final int l = list[index];\n    Array.move(list, index + 1, -1, --size - index);\n    return l;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Filters the entries.\n   * @param pattern files pattern\n   * @param content contents pattern\n   * @param thread thread id\n   */\n  void filter(final String pattern, final String content, final int thread) {\n    // wait when command is still running\n    while(running) {\n      Thread.yield();\n      // newer thread has arrived\n      if(threadID != thread) return;\n    }\n\n    // thread is accepted; start filtering\n    running = true;\n    files.setCursor(CURSORWAIT);\n    contents.setCursor(CURSORWAIT);\n    init(thread);\n\n    // collect matches\n    final TokenSet matches = new TokenSet();\n    final IntList il = new IntList();\n    final TokenParser tp = new TokenParser(Token.token(content));\n    while(tp.more()) il.add(Token.lc(tp.next()));\n    if(filter(pattern, il.toArray(), thread, matches)) {\n      project.list.setElements(matches, content.isEmpty() ? null : content);\n    }\n\n    files.setCursor(CURSORTEXT);\n    contents.setCursor(CURSORTEXT);\n    running = false;\n  }","id":81966,"modified_method":"/**\n   * Filters the entries.\n   * @param file file search string\n   * @param content content search string\n   * @param thread thread id\n   */\n  void filter(final String file, final String content, final int thread) {\n    // wait when command is still running\n    while(running) {\n      Thread.yield();\n      // newer thread has arrived\n      if(threadID != thread) return;\n    }\n\n    // thread is accepted; start filtering\n    running = true;\n    files.setCursor(CURSORWAIT);\n    contents.setCursor(CURSORWAIT);\n    init(thread);\n\n    // collect matches\n    final TokenSet results = new TokenSet();\n    final IntList il = new IntList();\n    final TokenParser tp = new TokenParser(Token.token(content));\n    while(tp.more()) il.add(Token.lc(tp.next()));\n    if(filter(file, il.toArray(), thread, results)) {\n      project.list.setElements(results, content.isEmpty() ? null : content);\n    }\n\n    files.setCursor(CURSORTEXT);\n    contents.setCursor(CURSORTEXT);\n    running = false;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Searches a string in a file.\n   * @param path file path\n   * @param cont file contents\n   * @return result of check\n   */\n  private boolean filterContent(final byte[] path, final int[] cont) {\n    final int cl = cont.length;\n    if(cl == 0) return true;\n\n    TextInput ti = null;\n    try {\n      ti = new TextInput(new IOFile(Token.string(path)));\n      for(int c = 0, cp = 0; (cp = ti.read()) != -1;) {\n        if(!XMLToken.valid(cp)) break;\n        if(Token.lc(cp) == cont[c]) {\n          if(++c == cl) return true;\n        } else {\n          c = 0;\n        }\n      }\n    } catch(final IOException ex) {\n      // file may not be accessible\n      Util.debug(ex);\n    } finally {\n      if(ti != null) try { ti.close(); } catch(final IOException ignored) { }\n    }\n    return false;\n  }","id":81967,"modified_method":"/**\n   * Searches a string in a file.\n   * @param path file path\n   * @param search search string\n   * @return success flag\n   */\n  private boolean filterContent(final byte[] path, final int[] search) {\n    final int cl = search.length;\n    if(cl == 0) return true;\n\n    try {\n      final TextInput ti = new TextInput(new IOFile(Token.string(path)));\n      try {\n        final IntList il = new IntList(cl - 1);\n        int c = 0;\n        while(true) {\n          if(!il.isEmpty()) {\n            if(il.deleteAt(0) == search[c++]) continue;\n            c = 0;\n          }\n          while(true) {\n            final int cp = ti.read();\n            if(cp == -1 || !XMLToken.valid(cp)) return false;\n            final int lc = Token.lc(cp);\n            if(c > 0) il.add(lc);\n            if(lc == search[c]) {\n              if(++c == cl) return true;\n            } else {\n              c = 0;\n              break;\n            }\n          }\n        }\n      } finally {\n        ti.close();\n      }\n    } catch(final IOException ex) {\n      // file may not be accessible\n      Util.debug(ex);\n      return false;\n    }\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks the file contents.\n   * @param input input path\n   * @param content content pattern\n   * @param matches set with matches\n   * @return maximum number of results reached\n   */\n  private boolean filterContent(final byte[] input, final int[] content, final TokenSet matches) {\n    // accept file; check file contents\n    if(filterContent(input, content) && !matches.contains(input)) {\n      matches.add(input);\n      if(matches.size() >= MAXHITS) return true;\n    }\n    return false;\n  }","id":81968,"modified_method":"/**\n   * Adds a file to the matches if the specified string is found.\n   * Checks the file contents.\n   * @param path file path\n   * @param search search string\n   * @param results search result\n   * @return maximum number of results reached\n   */\n  private boolean filterContent(final byte[] path, final int[] search, final TokenSet results) {\n    // accept file; check file contents\n    if(filterContent(path, search) && !results.contains(path)) {\n      results.add(path);\n      if(results.size() >= MAXHITS) return true;\n    }\n    return false;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param content content pattern\n   * @param thread current thread id\n   * @param matches set with matches\n   * @return success flag\n   */\n  private boolean filter(final String pattern, final int[] content, final int thread,\n      final TokenSet matches) {\n\n    // glob pattern\n    if(pattern.contains(\"*\") || pattern.contains(\"?\")) {\n      final Pattern pt = Pattern.compile(IOFile.regex(pattern));\n      for(final byte[] input : cache) {\n        final int offset = offset(input, true);\n        if(pt.matcher(Token.string(Token.substring(input, offset))).matches() &&\n            filterContent(input, content, matches)) return true;\n        if(thread != threadID) return false;\n      }\n    }\n    // starts-with, contains, camel case\n    final byte[] patt = Token.token(pattern);\n    for(int i = 0; i < 3; i++) {\n      if(!filter(patt, content, thread, i, matches)) return false;\n    }\n    return true;\n  }","id":81969,"modified_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param search search string\n   * @param thread current thread id\n   * @param results search result\n   * @return success flag\n   */\n  private boolean filter(final String pattern, final int[] search, final int thread,\n      final TokenSet results) {\n\n    // glob pattern\n    if(pattern.contains(\"*\") || pattern.contains(\"?\")) {\n      final Pattern pt = Pattern.compile(IOFile.regex(pattern));\n      for(final byte[] input : cache) {\n        final int offset = offset(input, true);\n        if(pt.matcher(Token.string(Token.substring(input, offset))).matches() &&\n            filterContent(input, search, results)) return true;\n        if(thread != threadID) return false;\n      }\n    }\n\n    // starts-with, contains, camel case\n    final byte[] patt = Token.token(pattern);\n    final TokenSet exclude = new TokenSet();\n    for(int i = 0; i < 3; i++) {\n      if(!filter(patt, search, thread, i, results, exclude)) return false;\n    }\n    return true;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param cont content pattern\n   * @param thread current thread id\n   * @param mode search mode (0-2)\n   * @param matches set with matches\n   * @return success flag\n   */\n  private boolean filter(final byte[] pattern, final int[] cont, final int thread, final int mode,\n      final TokenSet matches) {\n\n    if(matches.size() < MAXHITS) {\n      final boolean path = Token.indexOf(pattern, '\\\\') != -1 || Token.indexOf(pattern, '/') != -1;\n      for(final byte[] input : cache) {\n        // check if current file matches the pattern\n        final int offset = offset(input, path);\n        if(mode == 0 && Token.startsWith(input, pattern, offset) ||\n           mode == 1 && Token.contains(input, pattern, offset) ||\n           matches(input, pattern, offset)) {\n          if(filterContent(input, cont, matches)) return true;\n        }\n        if(thread != threadID) return false;\n      }\n    }\n    return true;\n  }","id":81970,"modified_method":"/**\n   * Chooses tokens from the file cache that match the specified pattern.\n   * @param pattern file pattern\n   * @param search search string\n   * @param thread current thread id\n   * @param mode search mode (0-2)\n   * @param results search result\n   * @param exclude exclude file from content search\n   * @return success flag\n   */\n  private boolean filter(final byte[] pattern, final int[] search, final int thread, final int mode,\n      final TokenSet results, final TokenSet exclude) {\n\n    if(results.size() < MAXHITS) {\n      final boolean path = Token.indexOf(pattern, '\\\\') != -1 || Token.indexOf(pattern, '/') != -1;\n      for(final byte[] input : cache) {\n        // check if current file matches the pattern\n        final int offset = offset(input, path);\n        if(mode == 0 && Token.startsWith(input, pattern, offset) ||\n           mode == 1 && Token.contains(input, pattern, offset) ||\n           matches(input, pattern, offset)) {\n          if(!exclude.contains(input)) {\n            exclude.add(input);\n            if(filterContent(input, search, results)) return true;\n          }\n        }\n        if(thread != threadID) return false;\n      }\n    }\n    return true;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Assigns the specified list entries and selects the first entry.\n   * @param matches entries to set\n   * @param srch content search string\n   */\n  void setElements(final TokenSet matches, final String srch) {\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        // set new values and selections\n        final int is = matches.size();\n        final String[] list = new String[is];\n        for(int i = 0; i < is; i++) list[i] = Token.string(matches.key(i + 1));\n        if(changed(list)) {\n          // check which old values had been selected\n          final Object[] old = getSelectedValues();\n          final IntList il = new IntList();\n          for(final Object o : old) {\n            for(int i = 0; i < is; i++) {\n              if(o.equals(matches.key(i + 1))) {\n                il.add(i);\n                break;\n              }\n            }\n          }\n          setListData(list);\n          setSelectedIndices(il.toArray());\n        }\n        search = srch;\n      }\n    });\n  }","id":81971,"modified_method":"/**\n   * Assigns the specified list entries and selects the first entry.\n   * @param elements result elements\n   * @param srch content search string\n   */\n  void setElements(final TokenSet elements, final String srch) {\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        // set new values and selections\n        final int is = elements.size();\n        final String[] list = new String[is];\n        for(int i = 0; i < is; i++) list[i] = Token.string(elements.key(i + 1));\n        if(changed(list)) {\n          // check which old values had been selected\n          final Object[] old = getSelectedValues();\n          final IntList il = new IntList();\n          for(final Object o : old) {\n            for(int i = 0; i < is; i++) {\n              if(o.equals(elements.key(i + 1))) {\n                il.add(i);\n                break;\n              }\n            }\n          }\n          setListData(list);\n          setSelectedIndices(il.toArray());\n        }\n        search = srch;\n      }\n    });\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes the specified element.\n   * @param index index of element to be deleted\n   */\n  public final void deleteAt(final int index) {\n    Array.move(list, index + 1, -1, --size - index);\n  }","id":81972,"modified_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   * @return deleted element\n   */\n  public final String deleteAt(final int index) {\n    final String l = list[index];\n    Array.move(list, index + 1, -1, --size - index);\n    return l;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   */\n  public void deleteAt(final int index) {\n    Array.move(list, index + 1, -1, --size - index);\n  }","id":81973,"modified_method":"/**\n   * Deletes the element at the specified position.\n   * @param index index of the element to delete\n   * @return deleted element\n   */\n  public byte[] deleteAt(final int index) {\n    final byte[] l = list[index];\n    Array.move(list, index + 1, -1, --size - index);\n    return l;\n  }","commit_id":"e99528fd2f3066c9aaf63211ad7cd8034dd7cac1","url":"https://github.com/BaseXdb/basex"},{"original_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n\n    final GrCondition condition = ifStatement.getCondition();\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n\n    InstructionImpl conditionEnd = null;\n    InstructionImpl thenEnd = null;\n    InstructionImpl elseEnd = null;\n\n    if (condition != null) {\n      condition.accept(this);\n      conditionEnd = myHead;\n    }\n\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(ifStatement);\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      thenEnd = myHead;\n      interruptFlow();\n    }\n\n    myHead = reduceAllNegationsIntoInstruction(ifStatement, negations);\n    if (negations.isEmpty() && conditionEnd != null) {\n      myHead = conditionEnd;\n    }\n    if (elseBranch != null) {\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n      elseEnd = myHead;\n      interruptFlow();\n    }\n\n    if (thenBranch != null || elseBranch != null) {\n      final InstructionImpl end = new IfEndInstruction(ifStatement);\n      addNode(end);\n      if (thenEnd != null) addEdge(thenEnd, end);\n      if (elseEnd != null) {\n        addEdge(elseEnd, end);\n      }\n      else {\n        addEdge(conditionEnd != null ? conditionEnd : ifInstruction, end);\n      }\n    }\n\n    finishNode(ifInstruction);\n  }","id":81974,"modified_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n\n    final GrCondition condition = ifStatement.getCondition();\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n\n    InstructionImpl conditionEnd = null;\n    InstructionImpl thenEnd = null;\n    InstructionImpl elseEnd = null;\n\n    if (condition != null) {\n      condition.accept(this);\n      conditionEnd = myHead;\n    }\n\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(ifStatement);\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      thenEnd = myHead;\n      interruptFlow();\n    }\n\n    myHead = reduceAllNegationsIntoInstruction(ifStatement, negations);\n    if (myHead == null && conditionEnd != null) {\n      myHead = conditionEnd;\n    }\n    if (elseBranch != null) {\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n      elseEnd = myHead;\n      interruptFlow();\n    }\n\n    if (thenBranch != null || elseBranch != null) {\n      final InstructionImpl end = new IfEndInstruction(ifStatement);\n      addNode(end);\n      if (thenEnd != null) addEdge(thenEnd, end);\n      if (elseEnd != null) {\n        addEdge(elseEnd, end);\n      }\n      else {\n        addEdge(conditionEnd != null ? conditionEnd : ifInstruction, end);\n      }\n    }\n\n    finishNode(ifInstruction);\n  }","commit_id":"fa20240ba8eefe810409b3e998608c0608550ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitElvisExpression(GrElvisExpression expression) {\n    GrExpression condition = expression.getCondition();\n    GrExpression elseBranch = expression.getElseBranch();\n\n    condition.accept(this);\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n    addPendingEdge(expression, myHead);\n\n    if (elseBranch != null) {\n      myHead = reduceAllNegationsIntoInstruction(expression, negations);\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n    }\n  }","id":81975,"modified_method":"@Override\n  public void visitElvisExpression(GrElvisExpression expression) {\n    GrExpression condition = expression.getCondition();\n    GrExpression elseBranch = expression.getElseBranch();\n\n    condition.accept(this);\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n    addPendingEdge(expression, myHead);\n\n    if (elseBranch != null) {\n      InstructionImpl head = reduceAllNegationsIntoInstruction(expression, negations);\n      if (head != null) myHead = head;\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n    }\n  }","commit_id":"fa20240ba8eefe810409b3e998608c0608550ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    final GrExpression right = expression.getRightOperand();\n    final IElementType opType = expression.getOperationTokenType();\n\n    if (opType != mLOR && opType != mLAND) {\n      left.accept(this);\n      if (right != null) {\n        right.accept(this);\n      }\n      visitCall(expression);\n      return;\n    }\n\n    ConditionInstruction condition = new ConditionInstruction(expression);\n    addNodeAndCheckPending(condition);\n    registerCondition(condition);\n\n    left.accept(this);\n\n    if (right == null) return;\n\n    final List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    visitCall(expression);\n\n    if (opType == mLAND) {\n      for (GotoInstruction negation : negations) {\n        addPendingEdge(expression, negation);\n      }\n      if (negations.isEmpty()) {\n        InstructionImpl head = myHead;\n        NegatingGotoInstruction negation = addNode(new NegatingGotoInstruction(expression, condition));\n        addPendingEdge(expression, negation);\n        myHead = head;\n      }\n    }\n    else /*if (opType == mLOR)*/ {\n      addNodeAndCheckPending(new InstructionImpl(expression)); //collect all pending edges from left argument\n      addPendingEdge(expression, myHead);\n\n      myHead = reduceAllNegationsIntoInstruction(expression, negations);\n      //addNode(new NegatingGotoInstruction(expression, myInstructionNumber++, condition));\n    }\n    myConditions.removeFirstOccurrence(condition);\n\n    right.accept(this);\n  }","id":81976,"modified_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    final GrExpression right = expression.getRightOperand();\n    final IElementType opType = expression.getOperationTokenType();\n\n    if (opType != mLOR && opType != mLAND) {\n      left.accept(this);\n      if (right != null) {\n        right.accept(this);\n      }\n      visitCall(expression);\n      return;\n    }\n\n    ConditionInstruction condition = new ConditionInstruction(expression);\n    addNodeAndCheckPending(condition);\n    registerCondition(condition);\n\n    left.accept(this);\n\n    if (right == null) return;\n\n    final List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    visitCall(expression);\n\n    if (opType == mLAND) {\n      for (GotoInstruction negation : negations) {\n        addPendingEdge(expression, negation);\n      }\n      if (negations.isEmpty()) {\n        InstructionImpl head = myHead;\n        NegatingGotoInstruction negation = addNode(new NegatingGotoInstruction(expression, condition));\n        addPendingEdge(expression, negation);\n        myHead = head;\n      }\n    }\n    else /*if (opType == mLOR)*/ {\n      addNodeAndCheckPending(new InstructionImpl(expression)); //collect all pending edges from left argument\n      addPendingEdge(expression, myHead);\n\n      InstructionImpl head = reduceAllNegationsIntoInstruction(expression, negations);\n      if (head != null) myHead = head;\n      //addNode(new NegatingGotoInstruction(expression, myInstructionNumber++, condition));\n    }\n    myConditions.removeFirstOccurrence(condition);\n\n    right.accept(this);\n  }","commit_id":"fa20240ba8eefe810409b3e998608c0608550ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand == null) return;\n\n    if (expression.getOperationTokenType() != mLNOT) {\n      operand.accept(this);\n      visitCall(expression);\n      return;\n    }\n\n    ConditionInstruction cond = new ConditionInstruction(expression);\n    addNodeAndCheckPending(cond);\n    registerCondition(cond);\n\n    operand.accept(this);\n    visitCall(expression);\n\n    myConditions.removeFirstOccurrence(cond);\n\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    addPendingEdge(expression, addNodeAndCheckPending(new PositiveGotoInstruction(expression, cond)));\n\n    myHead = reduceAllNegationsIntoInstruction(expression, negations);\n  }","id":81977,"modified_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand == null) return;\n\n    if (expression.getOperationTokenType() != mLNOT) {\n      operand.accept(this);\n      visitCall(expression);\n      return;\n    }\n\n    ConditionInstruction cond = new ConditionInstruction(expression);\n    addNodeAndCheckPending(cond);\n    registerCondition(cond);\n\n    operand.accept(this);\n    visitCall(expression);\n\n    myConditions.removeFirstOccurrence(cond);\n\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    InstructionImpl head = myHead;\n    addPendingEdge(expression, addNodeAndCheckPending(new PositiveGotoInstruction(expression, cond)));\n\n    if (negations.isEmpty()) {\n      myHead = head;\n    }\n    else {\n      myHead = reduceAllNegationsIntoInstruction(expression, negations);\n    }\n  }","commit_id":"fa20240ba8eefe810409b3e998608c0608550ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitConditionalExpression(GrConditionalExpression expression) {\n    GrExpression condition = expression.getCondition();\n    GrExpression thenBranch = expression.getThenBranch();\n    GrExpression elseBranch = expression.getElseBranch();\n\n    condition.accept(this);\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      addPendingEdge(expression, myHead);\n    }\n\n    if (elseBranch != null) {\n      myHead = reduceAllNegationsIntoInstruction(expression, negations);\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n    }\n  }","id":81978,"modified_method":"@Override\n  public void visitConditionalExpression(GrConditionalExpression expression) {\n    GrExpression condition = expression.getCondition();\n    GrExpression thenBranch = expression.getThenBranch();\n    GrExpression elseBranch = expression.getElseBranch();\n\n    condition.accept(this);\n    InstructionImpl conditionEnd = myHead;\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      addPendingEdge(expression, myHead);\n    }\n\n    if (elseBranch != null) {\n      InstructionImpl head = reduceAllNegationsIntoInstruction(expression, negations);\n      myHead = head != null ? head : conditionEnd;\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n    }\n  }","commit_id":"fa20240ba8eefe810409b3e998608c0608550ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean containsSegment(long msb, long lsb) {\n        for (TarFile file : files.toArray(new TarFile[0])) {\n            try {\n                ByteBuffer buffer = file.readEntry(msb, lsb);\n                if (buffer != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to access file \" + file, e);\n            }\n        }\n        return false;\n    }","id":81979,"modified_method":"private boolean containsSegment(long msb, long lsb) {\n        for (TarReader reader : readers) {\n            if (reader.containsEntry(msb, lsb)) {\n                return true;\n            }\n        }\n        synchronized (this) {\n            return writer.containsEntry(msb, lsb);\n        }\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void flush() throws IOException {\n        synchronized (persistedHead) {\n            RecordId before = persistedHead.get();\n            RecordId after = head.get();\n            if (!after.equals(before)) {\n                // needs to happen outside the synchronization block below to\n                // avoid a deadlock with another thread flushing the writer\n                tracker.getWriter().flush();\n\n                synchronized (this) {\n                    boolean success = true;\n                    for (TarFile file : files) {\n                        success = success && file.flush();\n                    }\n                    if (!success) {\n                        log.warn(\"Failed to sync one ore more tar files with\"\n                                + \" the underlying file system, possibly because of\"\n                                + \" http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6539707.\"\n                                + \" Will retry later.\");\n                    }\n                    journalFile.writeBytes(after + \" root\\n\");\n                    journalFile.getChannel().force(false);\n                    persistedHead.set(after);\n                }\n            }\n        }\n    }","id":81980,"modified_method":"public void flush() throws IOException {\n        synchronized (persistedHead) {\n            RecordId before = persistedHead.get();\n            RecordId after = head.get();\n            if (!after.equals(before)) {\n                // needs to happen outside the synchronization block below to\n                // avoid a deadlock with another thread flushing the writer\n                tracker.getWriter().flush();\n\n                synchronized (this) {\n                    writer.flush();\n                    journalFile.writeBytes(after + \" root\\n\");\n                    journalFile.getChannel().force(false);\n                    persistedHead.set(after);\n                }\n            }\n        }\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void close() {\n        try {\n            // avoid deadlocks while joining the flush thread\n            timeToClose.countDown();\n            try {\n                flushThread.join();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"Interrupted while joining the TarMK flush thread\", e);\n            }\n\n            synchronized (this) {\n                flush();\n\n                journalFile.close();\n\n                for (TarFile file : files) {\n                    file.close();\n                }\n                files.clear();\n\n                System.gc(); // for any memory-mappings that are no longer used\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\n                    \"Failed to close the TarMK at \" + directory, e);\n        }\n    }","id":81981,"modified_method":"@Override\n    public void close() {\n        try {\n            // avoid deadlocks while joining the flush thread\n            timeToClose.countDown();\n            try {\n                flushThread.join();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"Interrupted while joining the TarMK flush thread\", e);\n            }\n\n            synchronized (this) {\n                flush();\n\n                writer.close();\n                journalFile.close();\n\n                List<TarReader> list = readers;\n                readers = newArrayList();\n                for (TarReader reader : list) {\n                    reader.close();\n                }\n\n                System.gc(); // for any memory-mappings that are no longer used\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\n                    \"Failed to close the TarMK at \" + directory, e);\n        }\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public synchronized void writeSegment(\n            SegmentId id, byte[] data, int offset, int length) {\n        try {\n            UUID uuid = new UUID(\n                    id.getMostSignificantBits(),\n                    id.getLeastSignificantBits());\n            if (files.isEmpty() || !files.get(files.size() - 1).writeEntry(\n                    uuid, data, offset, length)) {\n                String name = format(FILE_NAME_FORMAT, files.size(), \"a\");\n                File file = new File(directory, name);\n                TarFile last = new TarFile(file, maxFileSize, memoryMapping);\n                checkState(last.writeEntry(uuid, data, offset, length));\n                files.add(last);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":81982,"modified_method":"@Override\n    public synchronized void writeSegment(\n            SegmentId id, byte[] data, int offset, int length) {\n        try {\n            long size = writer.writeEntry(\n                    id.getMostSignificantBits(),\n                    id.getLeastSignificantBits(),\n                    data, offset, length);\n            if (size >= maxFileSize) {\n                writer.close();\n\n                List<TarReader> list =\n                        newArrayListWithCapacity(1 + readers.size());\n                list.add(new TarReader(writeFile, memoryMapping));\n                list.addAll(readers);\n                readers = list;\n\n                writeNumber++;\n                writeFile = new File(\n                        directory,\n                        String.format(FILE_NAME_FORMAT, writeNumber, \"a\"));\n                writer = new TarWriter(writeFile);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public FileStore(\n            BlobStore blobStore, final File directory, NodeState initial,\n            int maxFileSizeMB, int cacheSizeMB, boolean memoryMapping)\n            throws IOException {\n        checkNotNull(directory).mkdirs();\n        if (cacheSizeMB > 0) {\n            this.tracker = new SegmentTracker(this, cacheSizeMB);\n        } else {\n            this.tracker = new SegmentTracker(this);\n        }\n        this.blobStore = blobStore;\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        Map<Integer, File> map = collectFiles(directory);\n        List<TarFile> list = newArrayListWithCapacity(map.size());\n        Integer[] indices = map.keySet().toArray(new Integer[map.size()]);\n        Arrays.sort(indices);\n        for (Integer index : indices) {\n            File file = map.get(index);\n            list.add(new TarFile(file, maxFileSize, memoryMapping));\n        }\n        this.files = newCopyOnWriteArrayList(list);\n\n        journalFile = new RandomAccessFile(\n                new File(directory, JOURNAL_FILE_NAME), \"rw\");\n\n        LinkedList<RecordId> heads = newLinkedList();\n        String line = journalFile.readLine();\n        while (line != null) {\n            int space = line.indexOf(' ');\n            if (space != -1) {\n                heads.add(RecordId.fromString(tracker, line.substring(0, space)));\n            }\n            line = journalFile.readLine();\n        }\n\n        RecordId id = null;\n        while (id == null && !heads.isEmpty()) {\n            RecordId last = heads.removeLast();\n            SegmentId segmentId = last.getSegmentId();\n            if (containsSegment(\n                    segmentId.getMostSignificantBits(),\n                    segmentId.getLeastSignificantBits())) {\n                id = last;\n            } else {\n                log.warn(\"Unable to access revision {}, rewinding...\", last);\n            }\n        }\n\n        if (id != null) {\n            head = new AtomicReference<RecordId>(id);\n            persistedHead = new AtomicReference<RecordId>(id);\n        } else {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", initial);\n            head = new AtomicReference<RecordId>(tracker.getWriter().writeNode(\n                    builder.getNodeState()).getRecordId());\n            persistedHead = new AtomicReference<RecordId>(null);\n        }\n\n        this.flushThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    timeToClose.await(1, SECONDS);\n                    while (timeToClose.getCount() > 0) {\n                        try {\n                            flush();\n                        } catch (IOException e) {\n                            log.warn(\"Failed to flush the TarMK at\" +\n                                    directory, e);\n                        }\n                        timeToClose.await(5, SECONDS);\n                    }\n                } catch (InterruptedException e) {\n                    log.warn(\"TarMK flush thread interrupted\");\n                }\n            }\n        });\n        flushThread.setName(\"TarMK flush thread: \" + directory);\n        flushThread.setDaemon(true);\n        flushThread.setPriority(Thread.MIN_PRIORITY);\n        flushThread.start();\n    }","id":81983,"modified_method":"public FileStore(\n            BlobStore blobStore, final File directory, NodeState initial,\n            int maxFileSizeMB, int cacheSizeMB, boolean memoryMapping)\n            throws IOException {\n        checkNotNull(directory).mkdirs();\n        if (cacheSizeMB > 0) {\n            this.tracker = new SegmentTracker(this, cacheSizeMB);\n        } else {\n            this.tracker = new SegmentTracker(this);\n        }\n        this.blobStore = blobStore;\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        Map<Integer, File> map = collectFiles(directory);\n        this.readers = newArrayListWithCapacity(map.size());\n        Integer[] indices = map.keySet().toArray(new Integer[map.size()]);\n        Arrays.sort(indices);\n        for (int i = indices.length - 1; i >= 0; i--) {\n            readers.add(TarReader.open(\n                    singletonMap('a', map.get(indices[i])), memoryMapping));\n        }\n\n        if (indices.length > 0) {\n            this.writeNumber = indices[indices.length - 1] + 1;\n        } else {\n            this.writeNumber = 0;\n        }\n        this.writeFile = new File(\n                directory,\n                String.format(FILE_NAME_FORMAT, writeNumber, \"a\"));\n        this.writer = new TarWriter(writeFile);\n\n        journalFile = new RandomAccessFile(\n                new File(directory, JOURNAL_FILE_NAME), \"rw\");\n\n        LinkedList<RecordId> heads = newLinkedList();\n        String line = journalFile.readLine();\n        while (line != null) {\n            int space = line.indexOf(' ');\n            if (space != -1) {\n                heads.add(RecordId.fromString(tracker, line.substring(0, space)));\n            }\n            line = journalFile.readLine();\n        }\n\n        RecordId id = null;\n        while (id == null && !heads.isEmpty()) {\n            RecordId last = heads.removeLast();\n            SegmentId segmentId = last.getSegmentId();\n            if (containsSegment(\n                    segmentId.getMostSignificantBits(),\n                    segmentId.getLeastSignificantBits())) {\n                id = last;\n            } else {\n                log.warn(\"Unable to access revision {}, rewinding...\", last);\n            }\n        }\n\n        if (id != null) {\n            head = new AtomicReference<RecordId>(id);\n            persistedHead = new AtomicReference<RecordId>(id);\n        } else {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", initial);\n            head = new AtomicReference<RecordId>(tracker.getWriter().writeNode(\n                    builder.getNodeState()).getRecordId());\n            persistedHead = new AtomicReference<RecordId>(null);\n        }\n\n        this.flushThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    timeToClose.await(1, SECONDS);\n                    while (timeToClose.getCount() > 0) {\n                        try {\n                            flush();\n                        } catch (IOException e) {\n                            log.warn(\"Failed to flush the TarMK at\" +\n                                    directory, e);\n                        }\n                        timeToClose.await(5, SECONDS);\n                    }\n                } catch (InterruptedException e) {\n                    log.warn(\"TarMK flush thread interrupted\");\n                }\n            }\n        });\n        flushThread.setName(\"TarMK flush thread: \" + directory);\n        flushThread.setDaemon(true);\n        flushThread.setPriority(Thread.MIN_PRIORITY);\n        flushThread.start();\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Iterable<SegmentId> getSegmentIds() {\n        List<SegmentId> ids = newArrayList();\n        for (TarFile file : files) {\n            for (UUID uuid : file.getUUIDs()) {\n                ids.add(tracker.getSegmentId(\n                        uuid.getMostSignificantBits(),\n                        uuid.getLeastSignificantBits()));\n            }\n        }\n        return ids;\n    }","id":81984,"modified_method":"public synchronized Iterable<SegmentId> getSegmentIds() {\n        List<SegmentId> ids = newArrayList();\n        for (UUID uuid : writer.getUUIDs()) {\n            ids.add(tracker.getSegmentId(\n                    uuid.getMostSignificantBits(),\n                    uuid.getLeastSignificantBits()));\n        }\n        for (TarReader reader : readers) {\n            for (UUID uuid : reader.getUUIDs()) {\n                ids.add(tracker.getSegmentId(\n                        uuid.getMostSignificantBits(),\n                        uuid.getLeastSignificantBits()));\n            }\n        }\n        return ids;\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Segment readSegment(SegmentId id) {\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n\n        for (TarFile file : files) {\n            try {\n                ByteBuffer buffer = file.readEntry(msb, lsb);\n                if (buffer != null) {\n                    return new Segment(tracker, id, buffer);\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to access file \" + file, e);\n            }\n        }\n\n        throw new IllegalStateException(\"Segment \" + id + \" not found\");\n    }","id":81985,"modified_method":"@Override\n    public Segment readSegment(SegmentId id) {\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n\n        for (TarReader reader : readers) {\n            try {\n                ByteBuffer buffer = reader.readEntry(msb, lsb);\n                if (buffer != null) {\n                    return new Segment(tracker, id, buffer);\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to read from tar file \" + reader, e);\n            }\n        }\n\n        synchronized (this) {\n            ByteBuffer buffer = writer.readEntry(msb, lsb);\n            if (buffer != null) {\n                return new Segment(tracker, id, buffer);\n            }\n        }\n\n        for (TarReader reader : readers) {\n            try {\n                ByteBuffer buffer = reader.readEntry(msb, lsb);\n                if (buffer != null) {\n                    return new Segment(tracker, id, buffer);\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to read from tar file \" + reader, e);\n            }\n        }\n\n        throw new IllegalStateException(\"Segment \" + id + \" not found\");\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testRecovery() throws IOException {\n        FileStore store = new FileStore(directory, 1);\n        store.flush(); // first 1kB\n\n        SegmentNodeState base = store.getHead();\n        SegmentNodeBuilder builder = base.builder();\n        builder.setProperty(\"step\", \"a\");\n        store.setHead(base, builder.getNodeState());\n        store.flush(); // second 1kB\n\n        base = store.getHead();\n        builder = base.builder();\n        builder.setProperty(\"step\", \"b\");\n        store.setHead(base, builder.getNodeState());\n        store.close(); // third 1kB\n\n        store = new FileStore(directory, 1);\n        assertEquals(\"b\", store.getHead().getString(\"step\"));\n        store.close();\n\n        RandomAccessFile file = new RandomAccessFile(\n                new File(directory, \"data00000a.tar\"), \"rw\");\n        file.seek(2048);\n        file.write(new byte[1024], 0, 1024);\n        file.close();\n\n        store = new FileStore(directory, 1);\n        assertEquals(\"a\", store.getHead().getString(\"step\"));\n        store.close();\n\n        file = new RandomAccessFile(\n                new File(directory, \"data00000a.tar\"), \"rw\");\n        file.seek(1024);\n        file.write(new byte[1024], 0, 1024);\n        file.close();\n\n        store = new FileStore(directory, 1);\n        assertFalse(store.getHead().hasProperty(\"step\"));\n        store.close();\n    }","id":81986,"modified_method":"@Test\n    public void testRecovery() throws IOException {\n        FileStore store = new FileStore(directory, 1, false);\n        store.flush(); // first 1kB\n\n        SegmentNodeState base = store.getHead();\n        SegmentNodeBuilder builder = base.builder();\n        builder.setProperty(\"step\", \"a\");\n        store.setHead(base, builder.getNodeState());\n        store.flush(); // second 1kB\n\n        base = store.getHead();\n        builder = base.builder();\n        builder.setProperty(\"step\", \"b\");\n        store.setHead(base, builder.getNodeState());\n        store.close(); // third 1kB\n\n        store = new FileStore(directory, 1, false);\n        assertEquals(\"b\", store.getHead().getString(\"step\"));\n        store.close();\n\n        RandomAccessFile file = new RandomAccessFile(\n                new File(directory, \"data00000a.tar\"), \"rw\");\n        file.setLength(2048);\n        file.close();\n\n        store = new FileStore(directory, 1, false);\n        assertEquals(\"a\", store.getHead().getString(\"step\"));\n        store.close();\n\n        file = new RandomAccessFile(\n                new File(directory, \"data00000a.tar\"), \"rw\");\n        file.setLength(1024);\n        file.close();\n\n        store = new FileStore(directory, 1, false);\n        assertFalse(store.getHead().hasProperty(\"step\"));\n        store.close();\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Segment(SegmentTracker tracker, SegmentId id, ByteBuffer data) {\r\n        this.tracker = checkNotNull(tracker);\r\n        this.id = checkNotNull(id);\r\n        this.data = checkNotNull(data);\r\n\r\n        if (id.isDataSegmentId()) {\r\n            this.refids = new SegmentId[getRefCount()];\r\n            refids[0] = id;\r\n        } else {\r\n            this.refids = null;\r\n        }\r\n    }","id":81987,"modified_method":"public Segment(SegmentTracker tracker, SegmentId id, ByteBuffer data) {\r\n        this.tracker = checkNotNull(tracker);\r\n        this.id = checkNotNull(id);\r\n        this.data = checkNotNull(data);\r\n\r\n        if (id.isDataSegmentId()) {\r\n            checkState(data.get(0) == '0'\r\n                    && data.get(1) == 'a'\r\n                    && data.get(2) == 'K'\r\n                    && data.get(3) == '\\n');\r\n            this.refids = new SegmentId[getRefCount()];\r\n            refids[0] = id;\r\n        } else {\r\n            this.refids = null;\r\n        }\r\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testWriteAndRead() throws IOException {\n        UUID id = UUID.randomUUID();\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n        byte[] data = \"Hello, World!\".getBytes(UTF_8);\n\n        TarFile tar = new TarFile(file, 10240, false);\n        try {\n            tar.writeEntry(id, data, 0, data.length);\n            assertEquals(ByteBuffer.wrap(data), tar.readEntry(msb, lsb));\n        } finally {\n            tar.close();\n        }\n\n        assertEquals(10240, file.length());\n\n        tar = new TarFile(file, 10240, false);\n        try {\n            assertEquals(ByteBuffer.wrap(data), tar.readEntry(msb, lsb));\n        } finally {\n            tar.close();\n        }\n    }","id":81988,"modified_method":"@Test\n    public void testWriteAndRead() throws IOException {\n        UUID id = UUID.randomUUID();\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n        byte[] data = \"Hello, World!\".getBytes(UTF_8);\n\n        TarWriter writer = new TarWriter(file);\n        try {\n            writer.writeEntry(\n                    id.getMostSignificantBits(),\n                    id.getLeastSignificantBits(),\n                    data, 0, data.length);\n            assertEquals(ByteBuffer.wrap(data), writer.readEntry(msb, lsb));\n        } finally {\n            writer.close();\n        }\n\n        assertEquals(3072, file.length());\n\n        TarReader reader = new TarReader(file, false);\n        try {\n            assertEquals(ByteBuffer.wrap(data), reader.readEntry(msb, lsb));\n        } finally {\n            reader.close();\n        }\n\n        reader = new TarReader(file, false);\n        try {\n            assertEquals(ByteBuffer.wrap(data), reader.readEntry(msb, lsb));\n        } finally {\n            reader.close();\n        }\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Before\n    public void setUp() throws IOException {\n        file = File.createTempFile(\"TarFileTest\", \".tar\");\n    }","id":81989,"modified_method":"@Before\n    public void setUp() throws IOException {\n        file = File.createTempFile(\"TarFileTest\", \".tar\", new File(\"target\"));\n    }","commit_id":"53647db8fb79d34dfd1305521bfe7c5d5912c227","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public FileStore(\n            BlobStore blobStore, final File directory, NodeState initial,\n            int maxFileSizeMB, int cacheSizeMB, boolean memoryMapping)\n            throws IOException {\n        checkNotNull(directory).mkdirs();\n        if (cacheSizeMB > 0) {\n            this.tracker = new SegmentTracker(this, cacheSizeMB);\n        } else {\n            this.tracker = new SegmentTracker(this);\n        }\n        this.blobStore = blobStore;\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"bulk\", i, \"a\");\n            File file = new File(directory, name);\n            if (!file.isFile()) {\n                name = String.format(FILE_NAME_FORMAT, \"bulk\", i, \"\");\n                file = new File(directory, name);\n            }\n            if (file.isFile()) {\n                bulkFiles.add(new TarFile(file, maxFileSize, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"data\", i, \"a\");\n            File file = new File(directory, name);\n            if (!file.isFile()) {\n                name = String.format(FILE_NAME_FORMAT, \"data\", i, \"\");\n                file = new File(directory, name);\n            }\n            if (file.isFile()) {\n                dataFiles.add(new TarFile(file, maxFileSize, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        journalFile = new RandomAccessFile(\n                new File(directory, JOURNAL_FILE_NAME), \"rw\");\n\n        RecordId id = null;\n        String line = journalFile.readLine();\n        while (line != null) {\n            int space = line.indexOf(' ');\n            if (space != -1) {\n                id = RecordId.fromString(tracker, line.substring(0, space));\n            }\n            line = journalFile.readLine();\n        }\n\n        if (id != null) {\n            head = new AtomicReference<RecordId>(id);\n            persistedHead = new AtomicReference<RecordId>(id);\n        } else {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", initial);\n            head = new AtomicReference<RecordId>(tracker.getWriter().writeNode(\n                    builder.getNodeState()).getRecordId());\n            persistedHead = new AtomicReference<RecordId>(null);\n        }\n\n        this.flushThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    timeToClose.await(1, SECONDS);\n                    while (timeToClose.getCount() > 0) {\n                        try {\n                            flush();\n                        } catch (IOException e) {\n                            log.warn(\"Failed to flush the TarMK at\" +\n                                    directory, e);\n                        }\n                        timeToClose.await(5, SECONDS);\n                    }\n                } catch (InterruptedException e) {\n                    log.warn(\"TarMK flush thread interrupted\");\n                }\n            }\n        });\n        flushThread.setName(\"TarMK flush thread: \" + directory);\n        flushThread.setDaemon(true);\n        flushThread.setPriority(Thread.MIN_PRIORITY);\n        flushThread.start();\n    }","id":81990,"modified_method":"public FileStore(\n            BlobStore blobStore, final File directory, NodeState initial,\n            int maxFileSizeMB, int cacheSizeMB, boolean memoryMapping)\n            throws IOException {\n        checkNotNull(directory).mkdirs();\n        if (cacheSizeMB > 0) {\n            this.tracker = new SegmentTracker(this, cacheSizeMB);\n        } else {\n            this.tracker = new SegmentTracker(this);\n        }\n        this.blobStore = blobStore;\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"bulk\", i, \"a\");\n            File file = new File(directory, name);\n            if (!file.isFile()) {\n                name = String.format(FILE_NAME_FORMAT, \"bulk\", i, \"\");\n                file = new File(directory, name);\n            }\n            if (file.isFile()) {\n                bulkFiles.add(new TarFile(file, maxFileSize, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"data\", i, \"a\");\n            File file = new File(directory, name);\n            if (!file.isFile()) {\n                name = String.format(FILE_NAME_FORMAT, \"data\", i, \"\");\n                file = new File(directory, name);\n            }\n            if (file.isFile()) {\n                dataFiles.add(new TarFile(file, maxFileSize, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        journalFile = new RandomAccessFile(\n                new File(directory, JOURNAL_FILE_NAME), \"rw\");\n\n        LinkedList<RecordId> heads = newLinkedList();\n        String line = journalFile.readLine();\n        while (line != null) {\n            int space = line.indexOf(' ');\n            if (space != -1) {\n                heads.add(RecordId.fromString(tracker, line.substring(0, space)));\n            }\n            line = journalFile.readLine();\n        }\n\n        RecordId id = null;\n        while (id == null && !heads.isEmpty()) {\n            RecordId last = heads.removeLast();\n            if (containsSegment(last.getSegmentId(), dataFiles)) {\n                id = last;\n            } else {\n                log.warn(\"Unable to committed revision {}, rewinding...\", last);\n            }\n        }\n\n        if (id != null) {\n            head = new AtomicReference<RecordId>(id);\n            persistedHead = new AtomicReference<RecordId>(id);\n        } else {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", initial);\n            head = new AtomicReference<RecordId>(tracker.getWriter().writeNode(\n                    builder.getNodeState()).getRecordId());\n            persistedHead = new AtomicReference<RecordId>(null);\n        }\n\n        this.flushThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    timeToClose.await(1, SECONDS);\n                    while (timeToClose.getCount() > 0) {\n                        try {\n                            flush();\n                        } catch (IOException e) {\n                            log.warn(\"Failed to flush the TarMK at\" +\n                                    directory, e);\n                        }\n                        timeToClose.await(5, SECONDS);\n                    }\n                } catch (InterruptedException e) {\n                    log.warn(\"TarMK flush thread interrupted\");\n                }\n            }\n        });\n        flushThread.setName(\"TarMK flush thread: \" + directory);\n        flushThread.setDaemon(true);\n        flushThread.setPriority(Thread.MIN_PRIORITY);\n        flushThread.start();\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Segment loadSegment(SegmentId id, List<TarFile> files) {\n        UUID uuid = new UUID(\n                id.getMostSignificantBits(),\n                id.getLeastSignificantBits());\n        for (TarFile file : files) {\n            try {\n                ByteBuffer buffer = file.readEntry(uuid);\n                if (buffer != null) {\n                    return new Segment(tracker, id, buffer);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\n                        \"Failed to access file \" + file, e);\n            }\n        }\n\n        throw new IllegalStateException(\"Segment \" + id + \" not found\");\n    }","id":81991,"modified_method":"private Segment loadSegment(SegmentId id, List<TarFile> files) {\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n        for (TarFile file : files) {\n            try {\n                ByteBuffer buffer = file.readEntry(msb, lsb);\n                if (buffer != null) {\n                    return new Segment(tracker, id, buffer);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\n                        \"Failed to access file \" + file, e);\n            }\n        }\n\n        throw new IllegalStateException(\"Segment \" + id + \" not found\");\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean containsSegment(SegmentId id, List<TarFile> files) {\n        UUID uuid = new UUID(\n                id.getMostSignificantBits(),\n                id.getLeastSignificantBits());\n        for (TarFile file : files) {\n            try {\n                ByteBuffer buffer = file.readEntry(uuid);\n                if (buffer != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\n                        \"Failed to access file \" + file, e);\n            }\n        }\n        return false;\n    }","id":81992,"modified_method":"private boolean containsSegment(SegmentId id, List<TarFile> files) {\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n        for (TarFile file : files) {\n            try {\n                ByteBuffer buffer = file.readEntry(msb, lsb);\n                if (buffer != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\n                        \"Failed to access file \" + file, e);\n            }\n        }\n        return false;\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"ByteBuffer readEntry(UUID uuid) throws IOException {\n        TarEntry entry = entries.get(uuid);\n        if (entry != null) {\n            return access.read(entry.offset(), entry.size());\n        } else {\n            return null;\n        }\n    }","id":81993,"modified_method":"ByteBuffer readEntry(long msb, long lsb) throws IOException {\n        TarEntry entry = indexLookup(msb, lsb);\n        if (entry != null) {\n            return access.read(entry.offset(), entry.size());\n        } else {\n            return null;\n        }\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"synchronized boolean writeEntry(\n            UUID uuid, byte[] b, int offset, int size) throws IOException {\n        int indexSize = entries.size() * 24 + 4;\n        if (position\n                + getEntrySize(size)      // this entry\n                + getEntrySize(indexSize) // index entry\n                + 2 * BLOCK_SIZE          // two zero blocks at the end\n                > maxFileSize) {\n            writeEntryHeader(\n                    indexEntryName, maxFileSize - 3 * BLOCK_SIZE - position);\n            ByteBuffer index = ByteBuffer.allocate(indexSize);\n            SortedMap<UUID, TarEntry> sorted = newTreeMap();\n            sorted.putAll(entries);\n            for (Map.Entry<UUID, TarEntry> entry : sorted.entrySet()) {\n                index.putLong(entry.getKey().getMostSignificantBits());\n                index.putLong(entry.getKey().getLeastSignificantBits());\n                index.putInt(entry.getValue().offset());\n                index.putInt(entry.getValue().size());\n            }\n            index.putInt(sorted.size());\n            access.write(\n                    maxFileSize - 2 * BLOCK_SIZE - indexSize,\n                    index.array(), 0, indexSize);\n            position = maxFileSize - 2 * BLOCK_SIZE;\n            return false;\n        }\n\n        writeEntryHeader(uuid.toString().getBytes(UTF_8), size);\n        position += BLOCK_SIZE;\n\n        access.write(position, b, offset, size);\n        entries.put(uuid, new TarEntry(position, size));\n        position += size;\n\n        int padding = BLOCK_SIZE - position % BLOCK_SIZE;\n        if (padding < BLOCK_SIZE) {\n            access.write(position, ZERO_BYTES, 0, padding);\n            position += padding;\n        }\n\n        return true;\n    }","id":81994,"modified_method":"synchronized boolean writeEntry(\n            UUID uuid, byte[] b, int offset, int size) throws IOException {\n        if (entries == null) {\n            return false;\n        }\n\n        int length = access.length();\n        int indexSize = entries.size() * 24 + 16;\n        if (position\n                + getEntrySize(size)           // this entry\n                + getEntrySize(indexSize + 24) // index with one extra entry\n                + 2 * BLOCK_SIZE               // two zero blocks at the end\n                > length) {\n            int bytes = length - position - 3 * BLOCK_SIZE;\n            writeEntryHeader(indexEntryName, bytes);\n\n            ByteBuffer index = ByteBuffer.allocate(indexSize);\n\n            SortedMap<UUID, TarEntry> sorted = newTreeMap();\n            sorted.putAll(entries);\n            for (Map.Entry<UUID, TarEntry> entry : sorted.entrySet()) {\n                index.putLong(entry.getKey().getMostSignificantBits());\n                index.putLong(entry.getKey().getLeastSignificantBits());\n                index.putInt(entry.getValue().offset());\n                index.putInt(entry.getValue().size());\n            }\n\n            CRC32 checksum = new CRC32();\n            checksum.update(index.array(), 0, index.position());\n            index.putInt((int) checksum.getValue());\n            index.putInt(entries.size());\n            index.putInt(bytes);\n            index.putInt(INDEX_MAGIC);\n\n            access.write(\n                    length - 2 * BLOCK_SIZE - indexSize,\n                    index.array(), 0, indexSize);\n            position = length - 2 * BLOCK_SIZE;\n            return false;\n        }\n\n        writeEntryHeader(uuid.toString().getBytes(UTF_8), size);\n        access.write(position + BLOCK_SIZE, b, offset, size);\n        entries.put(uuid, new TarEntry(position + BLOCK_SIZE, size));\n        position += getEntrySize(size);\n\n        return true;\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"TarFile(File file, int maxFileSize, boolean memoryMapping)\n            throws IOException {\n        long len = file.length();\n        checkState(len <= Integer.MAX_VALUE);\n        this.maxFileSize = Math.max((int) len, maxFileSize);\n        checkState(maxFileSize % BLOCK_SIZE == 0);\n        checkState(maxFileSize > 5 * BLOCK_SIZE);\n        this.indexEntryName = (file.getName() + \".idx\").getBytes(UTF_8);\n\n        this.file = file;\n        RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n        if (memoryMapping) {\n            this.access = new MappedAccess(f, this.maxFileSize);\n        } else {\n            this.access = new RandomAccess(f);\n        }\n\n        this.position = 0;\n        if (len == 0) {\n            // allocate the full file by writing one big index entry\n            writeEntryHeader(indexEntryName, maxFileSize - 3 * BLOCK_SIZE);\n            // zero-out the last four bytes to indicate an empty index\n            access.write(\n                    maxFileSize - (ZERO_BYTES.length * 2 + 4),\n                    ZERO_BYTES, 0, 4);\n            // tar format expects the last two blocks to be zero\n            access.write(\n                    maxFileSize - ZERO_BYTES.length * 2,\n                    ZERO_BYTES, 0, ZERO_BYTES.length);\n            access.write(\n                    maxFileSize - ZERO_BYTES.length,\n                    ZERO_BYTES, 0, ZERO_BYTES.length);\n        } else {\n            readIndex(len);\n        }\n    }","id":81995,"modified_method":"TarFile(File file, int maxFileSize, boolean memoryMapping)\n            throws IOException {\n        long len = file.length();\n        checkState(len <= Integer.MAX_VALUE);\n        maxFileSize = Math.max((int) len, maxFileSize);\n        checkState(maxFileSize % BLOCK_SIZE == 0);\n        checkState(maxFileSize > 5 * BLOCK_SIZE);\n        this.indexEntryName = (file.getName() + \".idx\").getBytes(UTF_8);\n\n        this.file = file;\n        RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n        if (memoryMapping) {\n            this.access = new MappedAccess(f, maxFileSize);\n        } else {\n            this.access = new RandomAccess(f);\n        }\n\n        this.position = 0;\n        if (len == 0) {\n            // allocate the full file by writing one big index entry\n            writeEntryHeader(indexEntryName, maxFileSize - 3 * BLOCK_SIZE);\n            // zero-out the last 16 bytes to indicate an empty index\n            access.write(\n                    maxFileSize - (ZERO_BYTES.length * 2 + 16),\n                    ZERO_BYTES, 0, 16);\n            // tar format expects the last two blocks to be zero\n            access.write(\n                    maxFileSize - ZERO_BYTES.length * 2,\n                    ZERO_BYTES, 0, ZERO_BYTES.length);\n            access.write(\n                    maxFileSize - ZERO_BYTES.length,\n                    ZERO_BYTES, 0, ZERO_BYTES.length);\n\n            this.index = null;\n            this.entries = newConcurrentMap();\n        } else {\n            this.index = loadAndValidateIndex();\n            if (index == null) {\n                this.entries = loadEntryMap();\n            } else {\n                this.entries = null;\n            }\n        }\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testWriteAndRead() throws IOException {\n        UUID id = UUID.randomUUID();\n        byte[] data = \"Hello, World!\".getBytes(UTF_8);\n\n        TarFile tar = new TarFile(file, 10240, false);\n        try {\n            tar.writeEntry(id, data, 0, data.length);\n            assertEquals(ByteBuffer.wrap(data), tar.readEntry(id));\n        } finally {\n            tar.close();\n        }\n\n        assertEquals(10240, file.length());\n\n        tar = new TarFile(file, 10240, false);\n        try {\n            assertEquals(ByteBuffer.wrap(data), tar.readEntry(id));\n        } finally {\n            tar.close();\n        }\n    }","id":81996,"modified_method":"@Test\n    public void testWriteAndRead() throws IOException {\n        UUID id = UUID.randomUUID();\n        long msb = id.getMostSignificantBits();\n        long lsb = id.getLeastSignificantBits();\n        byte[] data = \"Hello, World!\".getBytes(UTF_8);\n\n        TarFile tar = new TarFile(file, 10240, false);\n        try {\n            tar.writeEntry(id, data, 0, data.length);\n            assertEquals(ByteBuffer.wrap(data), tar.readEntry(msb, lsb));\n        } finally {\n            tar.close();\n        }\n\n        assertEquals(10240, file.length());\n\n        tar = new TarFile(file, 10240, false);\n        try {\n            assertEquals(ByteBuffer.wrap(data), tar.readEntry(msb, lsb));\n        } finally {\n            tar.close();\n        }\n    }","commit_id":"876c51aeb8dfa229111f76e5892ee2dfd8535768","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n\tpublic void moveTrashEntry(\n\t\t\tlong userId, long classPK, long containerModelId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(classPK);\n\t\tWikiPage parentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\tcontainerModelId);\n\n\t\tString parentPageTitle = parentPage.getTitle();\n\n\t\tif (parentPage.isInTrash()) {\n\t\t\tparentPageTitle = StringPool.BLANK;\n\t\t}\n\n\t\tWikiPageLocalServiceUtil.changeParentAndRestoreFromTrash(\n\t\t\tuserId, page.getNodeId(), page.getTitle(), parentPageTitle,\n\t\t\tserviceContext);\n\t}","id":81997,"modified_method":"@Override\n\tpublic void moveTrashEntry(\n\t\t\tlong userId, long classPK, long containerModelId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(classPK);\n\n\t\tString parentPageTitle = StringPool.BLANK;\n\n\t\ttry {\n\t\t\tWikiPage parentPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t\tcontainerModelId);\n\n\t\t\tparentPageTitle = parentPage.getTitle();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tWikiPageLocalServiceUtil.changeParentAndRestoreFromTrash(\n\t\t\tuserId, page.getNodeId(), page.getTitle(), parentPageTitle,\n\t\t\tserviceContext);\n\t}","commit_id":"3df1493c678982606cfd98267bab612f296552d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getTrashContainerModelName(long classPK)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tWikiPageLocalServiceUtil.getPage(classPK);\n\n\t\t\treturn \"wiki-page\";\n\t\t}\n\t\tcatch (NoSuchPageException nspe) {\n\t\t}\n\n\t\treturn getTrashContainerModelName();\n\t}","id":81998,"modified_method":"public long getDestinationContainerModelId(\n\t\tlong classPK, long destinationContainerModelId) {\n\n\t\tif (destinationContainerModelId == 0) {\n\t\t\ttry {\n\t\t\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(classPK);\n\n\t\t\t\treturn page.getNodeId();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\n\t\treturn destinationContainerModelId;\n\t}","commit_id":"3df1493c678982606cfd98267bab612f296552d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<TrashRenderer> getTrashContainerModelTrashRenderers(\n\t\t\tlong classPK, int start, int end)\n\t\tthrows PortalException {\n\n\t\tList<TrashRenderer> trashRenderers = new ArrayList<TrashRenderer>();\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(classPK);\n\n\t\tList<WikiPage> pages = WikiPageLocalServiceUtil.getTrashedChildren(\n\t\t\tpage.getNodeId(), true, page.getTitle());\n\n\t\tfor (WikiPage curPage : pages) {\n\t\t\tTrashHandler trashHandler =\n\t\t\t\tTrashHandlerRegistryUtil.getTrashHandler(\n\t\t\t\t\tWikiPage.class.getName());\n\n\t\t\tTrashRenderer trashRenderer = trashHandler.getTrashRenderer(\n\t\t\t\tcurPage.getResourcePrimKey());\n\n\t\t\ttrashRenderers.add(trashRenderer);\n\t\t}\n\n\t\treturn trashRenderers;\n\t}","id":81999,"modified_method":"@Override\n\tpublic List<TrashRenderer> getTrashContainerModelTrashRenderers(\n\t\t\tlong classPK, int start, int end)\n\t\tthrows PortalException {\n\n\t\tList<TrashRenderer> trashRenderers = new ArrayList<TrashRenderer>();\n\n\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(classPK);\n\n\t\tList<WikiPage> pages = WikiPageLocalServiceUtil.getChildren(\n\t\t\tpage.getNodeId(), true, page.getTitle(),\n\t\t\tWorkflowConstants.STATUS_IN_TRASH);\n\n\t\tfor (WikiPage curPage : pages) {\n\t\t\tTrashHandler trashHandler =\n\t\t\t\tTrashHandlerRegistryUtil.getTrashHandler(\n\t\t\t\t\tWikiPage.class.getName());\n\n\t\t\tTrashRenderer trashRenderer = trashHandler.getTrashRenderer(\n\t\t\t\tcurPage.getResourcePrimKey());\n\n\t\t\ttrashRenderers.add(trashRenderer);\n\t\t}\n\n\t\treturn trashRenderers;\n\t}","commit_id":"3df1493c678982606cfd98267bab612f296552d6","url":"https://github.com/liferay/liferay-portal"}]