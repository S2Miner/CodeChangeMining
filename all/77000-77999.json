[{"original_method":"private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (fileID != null) {\n            int index = groupPane.getGrouping().fileIds().indexOf(fileID);\n            final int size = groupPane.getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(groupPane.getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(groupPane.getGrouping().fileIds().get(0));\n        }\n    }","id":77000,"modified_method":"@ThreadConfined(type = ThreadType.JFX)\n    private void cycleSlideShowImage(int d) {\n        stopVideo();\n        if (getFileID() != null) {\n            int index = getGroupPane().getGrouping().fileIds().indexOf(getFileID());\n            final int size = getGroupPane().getGrouping().fileIds().size();\n            index = (index + d) % size;\n            if (index < 0) {\n                index += size;\n            }\n            setFile(getGroupPane().getGrouping().fileIds().get(index));\n\n        } else {\n            setFile(getGroupPane().getGrouping().fileIds().get(0));\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategoryBorder() {\n        final Category category = super.updateCategoryBorder();\n        ToggleButton toggleForCategory = getToggleForCategory(category);\n\n        Runnable r = () -> {\n            toggleForCategory.setSelected(true);\n        };\n        if (Platform.isFxApplicationThread()) {\n            r.run();\n        } else {\n            Platform.runLater(r);\n        }\n\n        return category;\n    }","id":77001,"modified_method":"@Override\n    @ThreadConfined(type = ThreadType.ANY)\n    public Category updateCategoryBorder() {\n        final Category category = getFile().getCategory();\n        final Border border = hasHashHit() && (category == Category.ZERO)\n                ? HASH_BORDER\n                : getCategoryBorder(category);\n        ToggleButton toggleForCategory = getToggleForCategory(category);\n\n        Platform.runLater(() -> {\n            getCategoryBorderRegion().setBorder(border);\n            toggleForCategory.setSelected(true);\n        });\n\n        return category;\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {\n            if (t1) {\n                FileIDSelectionModel.getInstance().clearAndSelect(fileID);\n                new CategorizeAction().addTag(cat.getTagName(), \"\");\n            }\n        }","id":77002,"modified_method":"@Override\n        public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {\n            if (t1) {\n                FileIDSelectionModel.getInstance().clearAndSelect(getFileID());\n                new CategorizeAction().addTag(cat.getTagName(), \"\");\n            }\n        }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void setFile(final Long fileID) {\n        super.setFile(fileID);\n        if (this.fileID != null) {\n            groupPane.makeSelection(false, this.fileID);\n        }\n    }","id":77003,"modified_method":"@Override\n    synchronized public void setFile(final Long fileID) {\n        super.setFile(fileID);\n        if (this.getFileID() != null) {\n            getGroupPane().makeSelection(false, this.getFileID());\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@ThreadConfined(type = ThreadType.ANY)\n    private void syncButtonVisibility() {\n        try {\n            final boolean hasMultipleFiles = groupPane.getGrouping().fileIds().size() > 1;\n            Platform.runLater(() -> {\n                rightButton.setVisible(hasMultipleFiles);\n                leftButton.setVisible(hasMultipleFiles);\n                rightButton.setManaged(hasMultipleFiles);\n                leftButton.setManaged(hasMultipleFiles);\n            });\n        } catch (NullPointerException ex) {\n            // The case has likely been closed\n            LOGGER.log(Level.WARNING, \"Error accessing groupPane\");\n        }\n    }","id":77004,"modified_method":"@ThreadConfined(type = ThreadType.ANY)\n    private void syncButtonVisibility() {\n        try {\n            final boolean hasMultipleFiles = getGroupPane().getGrouping().fileIds().size() > 1;\n            Platform.runLater(() -> {\n                rightButton.setVisible(hasMultipleFiles);\n                leftButton.setVisible(hasMultipleFiles);\n                rightButton.setManaged(hasMultipleFiles);\n                leftButton.setManaged(hasMultipleFiles);\n            });\n        } catch (NullPointerException ex) {\n            // The case has likely been closed\n            LOGGER.log(Level.WARNING, \"Error accessing groupPane\");\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @return supplemental text to include in the label, specifically: \"image x\n     *         of y\"\n     */\n    private String getSupplementalText() {\n        return \" ( \" + (groupPane.getGrouping().fileIds().indexOf(fileID) + 1) + \" of \" + groupPane.getGrouping().fileIds().size() + \" in group )\";\n    }","id":77005,"modified_method":"/**\n     * @return supplemental text to include in the label, specifically: \"image x\n     *         of y\"\n     */\n    private String getSupplementalText() {\n        return \" ( \" + (getGroupPane().getGrouping().fileIds().indexOf(getFileID()) + 1) + \" of \" + getGroupPane().getGrouping().fileIds().size() + \" in group )\";\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    protected Runnable getContentUpdateRunnable() {\n        if (file.isVideo()) {\n            return () -> {\n                imageBorder.setCenter(MediaControl.create((VideoFile<?>) file));\n            };\n        } else {\n            ImageView imageView = new ImageView(((ImageFile<?>) file).getFullSizeImage());\n            imageView.setPreserveRatio(true);\n            imageView.fitWidthProperty().bind(imageBorder.widthProperty().subtract(CAT_BORDER_WIDTH * 2));\n            imageView.fitHeightProperty().bind(this.heightProperty().subtract(CAT_BORDER_WIDTH * 4).subtract(footer.heightProperty()).subtract(toolBar.heightProperty()));\n            return () -> {\n                imageBorder.setCenter(imageView);\n            };\n        }\n    }","id":77006,"modified_method":"@Override\n    protected Runnable getContentUpdateRunnable() {\n        if (getFile().isVideo()) {\n            return () -> {\n                imageBorder.setCenter(MediaControl.create((VideoFile<?>) getFile()));\n            };\n        } else {\n            ImageView imageView = new ImageView(((ImageFile<?>) getFile()).getFullSizeImage());\n            imageView.setPreserveRatio(true);\n            imageView.fitWidthProperty().bind(imageBorder.widthProperty().subtract(CAT_BORDER_WIDTH * 2));\n            imageView.fitHeightProperty().bind(this.heightProperty().subtract(CAT_BORDER_WIDTH * 4).subtract(footer.heightProperty()).subtract(toolBar.heightProperty()));\n            return () -> {\n                imageBorder.setCenter(imageView);\n            };\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@FXML\n    @Override\n    protected void initialize() {\n        super.initialize();\n        assert cat0Toggle != null : \"fx:id=\\\"cat0Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat1Toggle != null : \"fx:id=\\\"cat1Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat2Toggle != null : \"fx:id=\\\"cat2Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat3Toggle != null : \"fx:id=\\\"cat3Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat4Toggle != null : \"fx:id=\\\"cat4Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat5Toggle != null : \"fx:id=\\\"cat5Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert leftButton != null : \"fx:id=\\\"leftButton\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert rightButton != null : \"fx:id=\\\"rightButton\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert tagSplitButton != null : \"fx:id=\\\"tagSplitButton\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n\n        Platform.runLater(() -> {\n            HBox.setHgrow(spring, Priority.ALWAYS);\n            spring.setMinWidth(Region.USE_PREF_SIZE);\n        });\n\n        tagSplitButton.setOnAction((ActionEvent t) -> {\n            try {\n                TagUtils.createSelTagMenuItem(TagUtils.getFollowUpTagName(), tagSplitButton).getOnAction().handle(t);\n            } catch (TskCoreException ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        });\n\n        tagSplitButton.setGraphic(new ImageView(DrawableAttribute.TAGS.getIcon()));\n        tagSplitButton.showingProperty().addListener((ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) -> {\n            if (t1) {\n                ArrayList<MenuItem> selTagMenues = new ArrayList<>();\n                for (final TagName tn : TagUtils.getNonCategoryTagNames()) {\n                    MenuItem menuItem = TagUtils.createSelTagMenuItem(tn, tagSplitButton);\n                    selTagMenues.add(menuItem);\n                }\n                tagSplitButton.getItems().setAll(selTagMenues);\n            }\n        });\n        cat0Toggle.setBorder(new Border(new BorderStroke(Category.ZERO.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat1Toggle.setBorder(new Border(new BorderStroke(Category.ONE.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat2Toggle.setBorder(new Border(new BorderStroke(Category.TWO.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat3Toggle.setBorder(new Border(new BorderStroke(Category.THREE.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat4Toggle.setBorder(new Border(new BorderStroke(Category.FOUR.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat5Toggle.setBorder(new Border(new BorderStroke(Category.FIVE.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n\n        cat0Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.ZERO));\n        cat1Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.ONE));\n        cat2Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.TWO));\n        cat3Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.THREE));\n        cat4Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.FOUR));\n        cat5Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.FIVE));\n\n        cat0Toggle.toggleGroupProperty().addListener((o, oldGroup, newGroup) -> {\n            newGroup.selectedToggleProperty().addListener((ov, oldToggle, newToggle) -> {\n                if (newToggle == null) {\n                    oldToggle.setSelected(true);\n                }\n            });\n        });\n\n        leftButton.setOnAction((ActionEvent t) -> {\n            cycleSlideShowImage(-1);\n        });\n        rightButton.setOnAction((ActionEvent t) -> {\n            cycleSlideShowImage(1);\n        });\n\n        //set up key listener equivalents of buttons\n        addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent t) -> {\n\n            if (t.getEventType() == KeyEvent.KEY_PRESSED) {\n\n                switch (t.getCode()) {\n                    case LEFT:\n                        cycleSlideShowImage(-1);\n                        t.consume();\n                        break;\n                    case RIGHT:\n                        cycleSlideShowImage(1);\n                        t.consume();\n                        break;\n                }\n            }\n        });\n\n        syncButtonVisibility();\n\n        groupPane.grouping().addListener((Observable observable) -> {\n            syncButtonVisibility();\n            if (groupPane.getGrouping() != null) {\n                groupPane.getGrouping().fileIds().addListener((Observable observable1) -> {\n                    syncButtonVisibility();\n                });\n            }\n        });\n    }","id":77007,"modified_method":"@FXML\n    @Override\n    protected void initialize() {\n        super.initialize();\n        assert cat0Toggle != null : \"fx:id=\\\"cat0Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat1Toggle != null : \"fx:id=\\\"cat1Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat2Toggle != null : \"fx:id=\\\"cat2Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat3Toggle != null : \"fx:id=\\\"cat3Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat4Toggle != null : \"fx:id=\\\"cat4Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert cat5Toggle != null : \"fx:id=\\\"cat5Toggle\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert leftButton != null : \"fx:id=\\\"leftButton\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert rightButton != null : \"fx:id=\\\"rightButton\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n        assert tagSplitButton != null : \"fx:id=\\\"tagSplitButton\\\" was not injected: check your FXML file 'SlideShow.fxml'.\";\n\n        Platform.runLater(() -> {\n            HBox.setHgrow(spring, Priority.ALWAYS);\n            spring.setMinWidth(Region.USE_PREF_SIZE);\n        });\n\n        tagSplitButton.setOnAction((ActionEvent t) -> {\n            try {\n                TagUtils.createSelTagMenuItem(TagUtils.getFollowUpTagName(), tagSplitButton).getOnAction().handle(t);\n            } catch (TskCoreException ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        });\n\n        tagSplitButton.setGraphic(new ImageView(DrawableAttribute.TAGS.getIcon()));\n        tagSplitButton.showingProperty().addListener((ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) -> {\n            if (t1) {\n                ArrayList<MenuItem> selTagMenues = new ArrayList<>();\n                for (final TagName tn : TagUtils.getNonCategoryTagNames()) {\n                    MenuItem menuItem = TagUtils.createSelTagMenuItem(tn, tagSplitButton);\n                    selTagMenues.add(menuItem);\n                }\n                tagSplitButton.getItems().setAll(selTagMenues);\n            }\n        });\n        cat0Toggle.setBorder(new Border(new BorderStroke(Category.ZERO.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat1Toggle.setBorder(new Border(new BorderStroke(Category.ONE.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat2Toggle.setBorder(new Border(new BorderStroke(Category.TWO.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat3Toggle.setBorder(new Border(new BorderStroke(Category.THREE.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat4Toggle.setBorder(new Border(new BorderStroke(Category.FOUR.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n        cat5Toggle.setBorder(new Border(new BorderStroke(Category.FIVE.getColor(), BorderStrokeStyle.SOLID, new CornerRadii(1), new BorderWidths(1))));\n\n        cat0Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.ZERO));\n        cat1Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.ONE));\n        cat2Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.TWO));\n        cat3Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.THREE));\n        cat4Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.FOUR));\n        cat5Toggle.selectedProperty().addListener(new CategorizeToggleHandler(Category.FIVE));\n\n        cat0Toggle.toggleGroupProperty().addListener((o, oldGroup, newGroup) -> {\n            newGroup.selectedToggleProperty().addListener((ov, oldToggle, newToggle) -> {\n                if (newToggle == null) {\n                    oldToggle.setSelected(true);\n                }\n            });\n        });\n\n        leftButton.setOnAction((ActionEvent t) -> {\n            cycleSlideShowImage(-1);\n        });\n        rightButton.setOnAction((ActionEvent t) -> {\n            cycleSlideShowImage(1);\n        });\n\n        //set up key listener equivalents of buttons\n        addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent t) -> {\n\n            if (t.getEventType() == KeyEvent.KEY_PRESSED) {\n\n                switch (t.getCode()) {\n                    case LEFT:\n                        cycleSlideShowImage(-1);\n                        t.consume();\n                        break;\n                    case RIGHT:\n                        cycleSlideShowImage(1);\n                        t.consume();\n                        break;\n                }\n            }\n        });\n\n        syncButtonVisibility();\n\n        getGroupPane().grouping().addListener((Observable observable) -> {\n            syncButtonVisibility();\n            if (getGroupPane().getGrouping() != null) {\n                getGroupPane().getGrouping().fileIds().addListener((Observable observable1) -> {\n                    syncButtonVisibility();\n                });\n            }\n        });\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String[] _exec(String cmd) throws Exception {\n\t\tProcess process = Runtime.getRuntime().exec(cmd);\n\n\t\tString[] stdout = _getExecOutput(process.getInputStream());\n\t\tString[] stderr = _getExecOutput(process.getErrorStream());\n\n\t\tif (stderr.length > 0) {\n\t\t\tStringBundler sb = new StringBundler(stderr.length * 3 + 3);\n\n\t\t\tsb.append(\"Received errors in executing '\");\n\t\t\tsb.append(cmd);\n\t\t\tsb.append(\"'\\n\");\n\n\t\t\tfor (String err : stderr) {\n\t\t\t\tsb.append(\"\\t\");\n\t\t\t\tsb.append(err);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\n\t\t\tthrow new Exception(sb.toString());\n\t\t}\n\n\t\treturn stdout;\n\t}","id":77008,"modified_method":"private String[] _exec(String cmd) throws Exception {\n\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\tProcess process = runtime.exec(cmd);\n\n\t\tString[] stdout = _getExecOutput(process.getInputStream());\n\t\tString[] stderr = _getExecOutput(process.getErrorStream());\n\n\t\tif (stderr.length > 0) {\n\t\t\tStringBundler sb = new StringBundler(stderr.length * 3 + 3);\n\n\t\t\tsb.append(\"Received errors in executing '\");\n\t\t\tsb.append(cmd);\n\t\t\tsb.append(\"'\\n\");\n\n\t\t\tfor (String err : stderr) {\n\t\t\t\tsb.append(\"\\t\");\n\t\t\t\tsb.append(err);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\n\t\t\tthrow new Exception(sb.toString());\n\t\t}\n\n\t\treturn stdout;\n\t}","commit_id":"f89eaa5d5a2b0bf158a0f73ba270418794cb80bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@NotNull\n  public static String getActionName() {\n    return SystemInfo.isMac ? \"Show in Finder\" : \"Show in Explorer\";\n  }","id":77009,"modified_method":"@NotNull\n  public static String getActionName() {\n    return SystemInfo.isMac ? \"Reveal in Finder\" : \"Show in Explorer\";\n  }","commit_id":"bd9f0b3b864942181a7150caa146e1b2fe798f50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void open(final File ioFile, File toSelect) {\n    if (SystemInfo.isMac) {\n      String cmd = \"open\";\n      String path = ioFile.getAbsolutePath();\n      try {\n        File parent = ioFile.getParentFile();\n        if (parent != null) {\n          Runtime.getRuntime().exec(cmd + \" \" + path, ArrayUtil.EMPTY_STRING_ARRAY, parent);\n        }\n        else {\n          Runtime.getRuntime().exec(cmd + \" \" + path);\n        }\n      }\n      catch (IOException e) {\n        LOG.warn(e);\n      }\n\n    }\n    else if (isJava6orLater()) {\n      try {\n        final Object desktopObject = Class.forName(\"java.awt.Desktop\").getMethod(\"getDesktop\").invoke(null);\n        desktopObject.getClass().getMethod(\"open\", File.class).invoke(desktopObject, ioFile);\n      }\n      catch (Exception e) {\n        LOG.debug(e);\n      }\n    }\n    else {\n      throw new UnsupportedOperationException();\n    }\n\n  }","id":77010,"modified_method":"public static void open(final File ioFile, File toSelect) {\n    if (SystemInfo.isMac) {\n      Runtime runtime = Runtime.getRuntime();\n      String path = toSelect == null ? ioFile.getAbsolutePath() : toSelect.exists() ? toSelect.getAbsolutePath() : ioFile.getAbsolutePath();\n      final String script = String.format(\n        \"tell application \\\"Finder\\\"\\n\" +\n        \"\\treveal {\\\"%s\\\"} as POSIX file\\n\" +\n        \"\\tactivate\\n\" +\n        \"end tell\", path);\n      \n      String[] args = {\"osascript\", \"-e\", script};\n\n      try {\n        runtime.exec(args);\n      }\n      catch (IOException e) {\n        LOG.warn(e);\n      }\n    }\n    else if (isJava6orLater()) {\n      try {\n        final Object desktopObject = Class.forName(\"java.awt.Desktop\").getMethod(\"getDesktop\").invoke(null);\n        desktopObject.getClass().getMethod(\"open\", File.class).invoke(desktopObject, ioFile);\n      }\n      catch (Exception e) {\n        LOG.debug(e);\n      }\n    }\n    else {\n      throw new UnsupportedOperationException();\n    }\n\n  }","commit_id":"bd9f0b3b864942181a7150caa146e1b2fe798f50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String _getThreadDumpFromJstack() {\n\n\t\tString vendorURL = System.getProperty(\"java.vendor.url\");\n\n\t\tif (!vendorURL.equals(\"http://java.sun.com/\") &&\n\t\t\t!vendorURL.equals(\"http://java.oracle.com/\")) {\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString name = ManagementFactory.getRuntimeMXBean().getName();\n\n\t\tif (Validator.isNull(name)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tint pos = name.indexOf(CharPool.AT);\n\n\t\tif (pos == -1) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString pidString = name.substring(0, pos);\n\n\t\tif (!Validator.isNumber(pidString)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tint pid = GetterUtil.getInteger(pidString);\n\n\t\tString[] cmd = new String[] {\n\t\t\t\"jstack\", String.valueOf(pid)\n\t\t};\n\n\t\tUnsyncByteArrayOutputStream outputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\ttry {\n\t\t\tProcess p = Runtime.getRuntime().exec(cmd);\n\n\t\t\tInputStream inputStream = p.getInputStream();\n\n\t\t\tStreamUtil.transfer(inputStream, outputStream);\n\t\t}\n\t\tcatch (Exception e) {\n\n\t\t}\n\n\t\treturn outputStream.toString();\n\t}","id":77011,"modified_method":"private static String _getThreadDumpFromJstack() {\n\t\tUnsyncByteArrayOutputStream outputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\ttry {\n\t\t\tString vendorURL = System.getProperty(\"java.vendor.url\");\n\n\t\t\tif (!vendorURL.equals(\"http://java.oracle.com/\") &&\n\t\t\t\t!vendorURL.equals(\"http://java.sun.com/\")) {\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tRuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n\n\t\t\tString name = runtimeMXBean.getName();\n\n\t\t\tif (Validator.isNull(name)) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tint pos = name.indexOf(CharPool.AT);\n\n\t\t\tif (pos == -1) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tString pidString = name.substring(0, pos);\n\n\t\t\tif (!Validator.isNumber(pidString)) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\t\tint pid = GetterUtil.getInteger(pidString);\n\n\t\t\tString[] cmd = new String[] {\"jstack\", String.valueOf(pid)};\n\n\t\t\tProcess process = runtime.exec(cmd);\n\n\t\t\tInputStream inputStream = process.getInputStream();\n\n\t\t\tStreamUtil.transfer(inputStream, outputStream);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn outputStream.toString();\n\t}","commit_id":"772b863755a9611f03dcf3d1112885b275165fca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String threadDump() {\n\n\t\tString threadDump = _getThreadDumpFromJstack();\n\n\t\tif (Validator.isNull(threadDump)) {\n\t\t\tthreadDump = _getThreadDumpFromStackTraces();\n\t\t}\n\n\t\treturn \"\\n\\n\".concat(threadDump);\n\t}","id":77012,"modified_method":"public static String threadDump() {\n\n\t\tString threadDump = _getThreadDumpFromJstack();\n\n\t\tif (Validator.isNull(threadDump)) {\n\t\t\tthreadDump = _getThreadDumpFromStackTrace();\n\t\t}\n\n\t\treturn \"\\n\\n\".concat(threadDump);\n\t}","commit_id":"772b863755a9611f03dcf3d1112885b275165fca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _getThreadDumpFromStackTraces() {\n\n\t\tString jvm =\n\t\t\tSystem.getProperty(\"java.vm.name\") + \" \" +\n\t\t\t\tSystem.getProperty(\"java.vm.version\");\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\t\"Full thread dump of \" + jvm + \" on \" + String.valueOf(new Date()) +\n\t\t\t\t\"\\n\\n\");\n\n\t\tMap<Thread, StackTraceElement[]> stackTraces =\n\t\t\tThread.getAllStackTraces();\n\n\t\tfor (Map.Entry<Thread, StackTraceElement[]> entry :\n\t\t\t\tstackTraces.entrySet()) {\n\n\t\t\tThread thread = entry.getKey();\n\t\t\tStackTraceElement[] elements = entry.getValue();\n\n\t\t\tsb.append(StringPool.QUOTE);\n\t\t\tsb.append(thread.getName());\n\t\t\tsb.append(StringPool.QUOTE);\n\n\t\t\tif (thread.getThreadGroup() != null) {\n\t\t\t\tsb.append(StringPool.SPACE);\n\t\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\t\tsb.append(thread.getThreadGroup().getName());\n\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\t\t}\n\n\t\t\tsb.append(\", priority=\");\n\t\t\tsb.append(thread.getPriority());\n\t\t\tsb.append(\", id=\");\n\t\t\tsb.append(thread.getId());\n\t\t\tsb.append(\", state=\");\n\t\t\tsb.append(thread.getState());\n\t\t\tsb.append(\"\\n\");\n\n\t\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\t\tsb.append(\"\\t\");\n\t\t\t\tsb.append(elements[i]);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":77013,"modified_method":"private static String _getThreadDumpFromStackTrace() {\n\t\tString jvm =\n\t\t\tSystem.getProperty(\"java.vm.name\") + \" \" +\n\t\t\t\tSystem.getProperty(\"java.vm.version\");\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\t\"Full thread dump of \" + jvm + \" on \" + String.valueOf(new Date()) +\n\t\t\t\t\"\\n\\n\");\n\n\t\tMap<Thread, StackTraceElement[]> stackTraces =\n\t\t\tThread.getAllStackTraces();\n\n\t\tfor (Map.Entry<Thread, StackTraceElement[]> entry :\n\t\t\t\tstackTraces.entrySet()) {\n\n\t\t\tThread thread = entry.getKey();\n\t\t\tStackTraceElement[] elements = entry.getValue();\n\n\t\t\tsb.append(StringPool.QUOTE);\n\t\t\tsb.append(thread.getName());\n\t\t\tsb.append(StringPool.QUOTE);\n\n\t\t\tif (thread.getThreadGroup() != null) {\n\t\t\t\tsb.append(StringPool.SPACE);\n\t\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\t\tsb.append(thread.getThreadGroup().getName());\n\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\t\t}\n\n\t\t\tsb.append(\", priority=\");\n\t\t\tsb.append(thread.getPriority());\n\t\t\tsb.append(\", id=\");\n\t\t\tsb.append(thread.getId());\n\t\t\tsb.append(\", state=\");\n\t\t\tsb.append(thread.getState());\n\t\t\tsb.append(\"\\n\");\n\n\t\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\t\tsb.append(\"\\t\");\n\t\t\t\tsb.append(elements[i]);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"772b863755a9611f03dcf3d1112885b275165fca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setBrowserOption() {\n\t\tString command = null;\n\t\tString commandSetBrowserOption =\n\t\t\tTestPropsValues.SELENIUM_SET_BROWSER_OPTION;\n\n\t\tif (_BROWSER_TYPE.equals(\"*chrome\") ||\n\t\t\t_BROWSER_TYPE.equals(\"*firefox\")) {\n\n\t\t\ttry {\n\t\t\t\tcommand = RuntimeVariables.replace(\n\t\t\t\t\t_SELENIUM_EXECUTABLE_DIR + commandSetBrowserOption);\n\n\t\t\t\tRuntime.getRuntime().exec(command);\n\n\t\t\t\tThread.sleep(10000);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":77014,"modified_method":"public void setBrowserOption() {\n\t\tif (!_BROWSER_TYPE.equals(\"*chrome\") &&\n\t\t\t!_BROWSER_TYPE.equals(\"*firefox\")) {\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tString command = RuntimeVariables.replace(\n\t\t\t\t_SELENIUM_EXECUTABLE_DIR +\n\t\t\t\t\tTestPropsValues.SELENIUM_SET_BROWSER_OPTION);\n\n\t\t\tRuntime runtime = Runtime.getRuntime();\n\t\t\t\n\t\t\truntime.exec(command);\n\n\t\t\tThread.sleep(10000);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"a9ff2e0e0e7f2975a2c7d6a13eda9cf731698b19","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void downloadFile(String value) {\n\t\tString[] command = null;\n\n\t\tString commandDownloadFile = TestPropsValues.SELENIUM_DOWNLOAD_FILE;\n\t\tString downloadFile = TestPropsValues.OUTPUT_DIR + value;\n\n\t\tif (_BROWSER_TYPE.equals(\"*chrome\") ||\n\t\t\t_BROWSER_TYPE.equals(\"*firefox\") ||\n\t\t\t_BROWSER_TYPE.equals(\"*iehta\") ||\n\t\t\t_BROWSER_TYPE.equals(\"*iexplore\")) {\n\n\t\t\ttry {\n\t\t\t\tcommand = new String[] {\n\t\t\t\t\t_SELENIUM_EXECUTABLE_DIR + commandDownloadFile, downloadFile\n\t\t\t\t};\n\n\t\t\t\tcommand[0] = RuntimeVariables.replace(command[0]);\n\n\t\t\t\tRuntime.getRuntime().exec(command);\n\n\t\t\t\tThread.sleep(10000);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":77015,"modified_method":"public void downloadFile(String value) {\n\t\tif (!_BROWSER_TYPE.equals(\"*chrome\") &&\n\t\t\t!_BROWSER_TYPE.equals(\"*firefox\") &&\n\t\t\t!_BROWSER_TYPE.equals(\"*iehta\") &&\n\t\t\t!_BROWSER_TYPE.equals(\"*iexplore\")) {\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tString[] commands = {\n\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t_SELENIUM_EXECUTABLE_DIR +\n\t\t\t\t\t\tTestPropsValues.SELENIUM_DOWNLOAD_FILE),\n\t\t\t\tTestPropsValues.OUTPUT_DIR + value\n\t\t\t};\n\n\t\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\t\truntime.exec(commands);\n\n\t\t\tThread.sleep(10000);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"a9ff2e0e0e7f2975a2c7d6a13eda9cf731698b19","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE); \n\t\tsetContentView(R.layout.search_main);\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\t\n\t\tButton backButton = (Button) findViewById(R.id.search_back_button);\n\t\tbackButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tSearchActivity.this.finish();\n\t\t\t}\n\t\t});\n\t\t\n\t\tspinner = (Spinner) findViewById(R.id.SpinnerLocation);\n\t\tspinnerAdapter = new ArrayAdapter<String>(this, R.layout.my_spinner_text, \n\t\t\t\tnew ArrayList<String>(Arrays.asList(new String[]{\n\t\t\t\t\t\tgetString(R.string.search_position_undefined),\n\t\t\t\t\t\tgetString(R.string.search_position_current_location),\n\t\t\t\t\t\tgetString(R.string.search_position_map_view),\n\t\t\t\t\t\tgetString(R.string.search_position_favorites),\n\t\t\t\t\t\tgetString(R.string.search_position_address)\n\t\t\t\t\t}))\n\t\t\t\t) {\n\t\t\t@Override\n\t\t\tpublic View getDropDownView(int position, View convertView,\n\t\t\t\t\tViewGroup parent) {\n\t\t\t\tView dropDownView = super.getDropDownView(position,\n\t\t\t\t\t\tconvertView, parent);\n\t\t\t\tif (dropDownView instanceof TextView) {\n\t\t\t\t\t((TextView) dropDownView).setTextColor(getResources()\n\t\t\t\t\t\t\t.getColor(R.color.color_black));\n\t\t\t\t}\n\t\t\t\treturn dropDownView;\n\t\t\t}\n\t\t};\n\t\tspinnerAdapter.setDropDownViewResource(R.layout.my_spinner_text);\n\t\t\n\t\t\n\t\tTabWidget tabs = (TabWidget) findViewById(android.R.id.tabs);\n\t\ttabs.setBackgroundResource(R.drawable.tab_icon_background);\n\t\tTabHost host = getTabHost(); \n\t\thost.addTab(host.newTabSpec(\"Search_POI\").setIndicator(getTabIndicator(R.drawable.tab_search_poi_icon, R.string.poi)).\n\t\t\t\tsetContent(new Intent(this, SearchPoiFilterActivity.class))); //$NON-NLS-1$\n\t\t\n\t\taddressSpec = host.newTabSpec(\"Search_Address\").\n                    setIndicator(getTabIndicator(R.drawable.tab_search_address_icon, R.string.address));\n\t\t\n\t\tsetAddressSpecContent();\n\n\t\thost.addTab(addressSpec);\n\t\thost.addTab(host.newTabSpec(\"Search_Location\").setIndicator(getTabIndicator(R.drawable.tab_search_location_icon, R.string.search_tabs_location)).setContent(createIntent(NavigatePointActivity.class))); //$NON-NLS-1$\n\t\tTabSpec transportTab = host.newTabSpec(\"Search_Transport\").setIndicator(getTabIndicator(R.drawable.tab_search_transport_icon, R.string.transport)).setContent(createIntent(SearchTransportActivity.class));\n\t\thost.addTab(transportTab); //$NON-NLS-1$\n\t\thost.addTab(host.newTabSpec(\"Search_Favorites\").setIndicator(getTabIndicator(R.drawable.tab_search_favorites_icon, R.string.favorite)).setContent(createIntent(FavouritesListActivity.class))); //$NON-NLS-1$\n\t\thost.addTab(host.newTabSpec(\"Search_History\").setIndicator(getTabIndicator(R.drawable.tab_search_history_icon, R.string.history)).setContent(createIntent(SearchHistoryActivity.class))); //$NON-NLS-1$\n\t\thost.setCurrentTab(POI_TAB_INDEX);\n\t\t\n\t\t\n\t\tspinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\tspinner.setAdapter(spinnerAdapter);\n\t\tspinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tif (position != 0) {\n\t\t\t\t\tif (position == POSITION_CURRENT_LOCATION) {\n\t\t\t\t\t\tstartSearchCurrentLocation();\n\t\t\t\t\t\tsearchAroundCurrentLocation = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsearchAroundCurrentLocation = false;\n\t\t\t\t\t\tendSearchCurrentLocation();\n\t\t\t\t\t\tif (position == POSITION_LAST_MAP_VIEW) {\n\t\t\t\t\t\t\tupdateSearchPoint(settings.getLastKnownMapLocation(), getString(R.string.search_position_fixed), true);\n\t\t\t\t\t\t} else if (position == POSITION_FAVORITES) {\n\t\t\t\t\t\t\tIntent intent = new Intent(SearchActivity.this, FavouritesListActivity.class);\n\t\t\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\t\t\t\tintent.putExtra(FavouritesListActivity.SELECT_FAVORITE_POINT_INTENT_KEY, (Serializable) null);\n\t\t\t\t\t\t\tstartActivityForResult(intent, REQUEST_FAVORITE_SELECT);\n\t\t\t\t\t\t\tspinner.setSelection(0);\n\t\t\t\t\t\t} else if (position == POSITION_ADDRESS) {\n\t\t\t\t\t\t\tIntent intent = new Intent(SearchActivity.this, SearchAddressActivity.class);\n\t\t\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\t\t\t\tintent.putExtra(SearchAddressActivity.SELECT_ADDRESS_POINT_INTENT_KEY, (String) null);\n\t\t\t\t\t\t\tstartActivityForResult(intent, REQUEST_ADDRESS_SELECT);\n\t\t\t\t\t\t\tspinner.setSelection(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\t}","id":77016,"modified_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE); \n\t\tsetContentView(R.layout.search_main);\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\t\n\t\tButton backButton = (Button) findViewById(R.id.search_back_button);\n\t\tbackButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tSearchActivity.this.finish();\n\t\t\t}\n\t\t});\n\n\t\tfinal TextView tabinfo  = (TextView) findViewById(R.id.textViewADesc);\n\t\tspinner = (Spinner) findViewById(R.id.SpinnerLocation);\n\t\tspinnerAdapter = new ArrayAdapter<String>(this, R.layout.my_spinner_text, \n\t\t\t\tnew ArrayList<String>(Arrays.asList(new String[]{\n\t\t\t\t\t\tgetString(R.string.search_position_undefined),\n\t\t\t\t\t\tgetString(R.string.search_position_current_location),\n\t\t\t\t\t\tgetString(R.string.search_position_map_view),\n\t\t\t\t\t\tgetString(R.string.search_position_favorites),\n\t\t\t\t\t\tgetString(R.string.search_position_address)\n\t\t\t\t\t}))\n\t\t\t\t) {\n\t\t\t@Override\n\t\t\tpublic View getDropDownView(int position, View convertView,\n\t\t\t\t\tViewGroup parent) {\n\t\t\t\tView dropDownView = super.getDropDownView(position,\n\t\t\t\t\t\tconvertView, parent);\n\t\t\t\tif (dropDownView instanceof TextView) {\n\t\t\t\t\t((TextView) dropDownView).setTextColor(getResources()\n\t\t\t\t\t\t\t.getColor(R.color.color_black));\n\t\t\t\t}\n\t\t\t\treturn dropDownView;\n\t\t\t}\n\t\t};\n\t\tspinnerAdapter.setDropDownViewResource(R.layout.my_spinner_text);\n\t\t\n\t\t\n\t\tTabWidget tabs = (TabWidget) findViewById(android.R.id.tabs);\n\t\ttabs.setBackgroundResource(R.drawable.tab_icon_background);\n\t\tTabHost host = getTabHost(); \n\t\thost.addTab(host.newTabSpec(SEARCH_POI).setIndicator(getTabIndicator(R.drawable.tab_search_poi_icon, R.string.poi)).\n\t\t\t\tsetContent(new Intent(this, SearchPoiFilterActivity.class))); //$NON-NLS-1$\n\t\t\n\t\taddressSpec = host.newTabSpec(SEARCH_ADDRESS).\n                    setIndicator(getTabIndicator(R.drawable.tab_search_address_icon, R.string.address));\n\t\t\n\t\tsetAddressSpecContent();\n\n\t\thost.addTab(addressSpec);\n\t\thost.addTab(host.newTabSpec(SEARCH_LOCATION).setIndicator(getTabIndicator(R.drawable.tab_search_location_icon, R.string.search_tabs_location)).setContent(createIntent(NavigatePointActivity.class))); //$NON-NLS-1$\n\t\tTabSpec transportTab = host.newTabSpec(SEARCH_TRANSPORT).setIndicator(getTabIndicator(R.drawable.tab_search_transport_icon, R.string.transport)).setContent(createIntent(SearchTransportActivity.class));\n\t\thost.addTab(transportTab); //$NON-NLS-1$\n\t\thost.addTab(host.newTabSpec(SEARCH_FAVORITES).setIndicator(getTabIndicator(R.drawable.tab_search_favorites_icon, R.string.favorite)).setContent(createIntent(FavouritesListActivity.class))); //$NON-NLS-1$\n\t\thost.addTab(host.newTabSpec(SEARCH_HISTORY).setIndicator(getTabIndicator(R.drawable.tab_search_history_icon, R.string.history)).setContent(createIntent(SearchHistoryActivity.class))); //$NON-NLS-1$\n\t\thost.setCurrentTab(POI_TAB_INDEX);\n\t\thost.setOnTabChangedListener(new OnTabChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onTabChanged(String tabId) {\n\t\t\t\tif (SEARCH_POI.equals(tabId)) {\n\t\t\t\t\ttabinfo.setText(R.string.poi_search_desc);\n\t\t\t\t} else\tif (SEARCH_ADDRESS.equals(tabId)) {\n\t\t\t\t\ttabinfo.setText(R.string.address_search_desc);\n\t\t\t\t} else\tif (SEARCH_LOCATION.equals(tabId)) {\n\t\t\t\t\ttabinfo.setText(R.string.navpoint_search_desc);\n\t\t\t\t} else\tif (SEARCH_TRANSPORT.equals(tabId)) {\n\t\t\t\t\ttabinfo.setText(R.string.transport_search_desc);\n\t\t\t\t} else\tif (SEARCH_FAVORITES.equals(tabId)) {\n\t\t\t\t\ttabinfo.setText(R.string.favourites_search_desc);\n\t\t\t\t} else\tif (SEARCH_HISTORY.equals(tabId)) {\n\t\t\t\t\ttabinfo.setText(R.string.history_search_desc);\n\t\t\t\t} \n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\tspinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\tspinner.setAdapter(spinnerAdapter);\n\t\tspinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tif (position != 0) {\n\t\t\t\t\tif (position == POSITION_CURRENT_LOCATION) {\n\t\t\t\t\t\tstartSearchCurrentLocation();\n\t\t\t\t\t\tsearchAroundCurrentLocation = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsearchAroundCurrentLocation = false;\n\t\t\t\t\t\tendSearchCurrentLocation();\n\t\t\t\t\t\tif (position == POSITION_LAST_MAP_VIEW) {\n\t\t\t\t\t\t\tupdateSearchPoint(settings.getLastKnownMapLocation(), getString(R.string.search_position_fixed), true);\n\t\t\t\t\t\t} else if (position == POSITION_FAVORITES) {\n\t\t\t\t\t\t\tIntent intent = new Intent(SearchActivity.this, FavouritesListActivity.class);\n\t\t\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\t\t\t\tintent.putExtra(FavouritesListActivity.SELECT_FAVORITE_POINT_INTENT_KEY, (Serializable) null);\n\t\t\t\t\t\t\tstartActivityForResult(intent, REQUEST_FAVORITE_SELECT);\n\t\t\t\t\t\t\tspinner.setSelection(0);\n\t\t\t\t\t\t} else if (position == POSITION_ADDRESS) {\n\t\t\t\t\t\t\tIntent intent = new Intent(SearchActivity.this, SearchAddressActivity.class);\n\t\t\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\t\t\t\tintent.putExtra(SearchAddressActivity.SELECT_ADDRESS_POINT_INTENT_KEY, (String) null);\n\t\t\t\t\t\t\tstartActivityForResult(intent, REQUEST_ADDRESS_SELECT);\n\t\t\t\t\t\t\tspinner.setSelection(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\t}","commit_id":"f1454b3d8b2417f506e6997cfd3c0d8d71086702","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static List<? extends LookupElement> createLookupElements(CompletionElement completionElement, PsiJavaReference reference) {\n    Object completion = completionElement.getElement();\n    assert !(completion instanceof LookupElement);\n\n    if (reference instanceof PsiJavaCodeReferenceElement) {\n      if (completion instanceof PsiMethod &&\n          ((PsiJavaCodeReferenceElement)reference).getParent() instanceof PsiImportStaticStatement) {\n        return Collections.singletonList(JavaLookupElementBuilder.forMethod((PsiMethod)completion, PsiSubstitutor.EMPTY));\n      }\n\n      if (completion instanceof PsiClass) {\n        return JavaClassNameCompletionContributor.createClassLookupItems((PsiClass)completion,\n                                                                         JavaClassNameCompletionContributor.AFTER_NEW.accepts(reference),\n                                                                         JavaClassNameInsertHandler.JAVA_CLASS_INSERT_HANDLER,\n                                                                         Conditions.<PsiClass>alwaysTrue());\n      }\n    }\n    \n    if (reference instanceof PsiMethodReferenceExpression && completion instanceof PsiMethod && ((PsiMethod)completion).isConstructor()) {\n      return Collections.singletonList(JavaLookupElementBuilder.forMethod((PsiMethod)completion, \"new\", PsiSubstitutor.EMPTY, null));\n    }\n\n    LookupElement _ret = LookupItemUtil.objectToLookupItem(completion);\n    if (_ret == null || !(_ret instanceof LookupItem)) return Collections.emptyList();\n\n    final PsiSubstitutor substitutor = completionElement.getSubstitutor();\n    if (substitutor != null) {\n      ((LookupItem<?>)_ret).setAttribute(LookupItem.SUBSTITUTOR, substitutor);\n    }\n\n    return Collections.singletonList(_ret);\n  }","id":77017,"modified_method":"private static List<? extends LookupElement> createLookupElements(CompletionElement completionElement, PsiJavaReference reference) {\n    Object completion = completionElement.getElement();\n    assert !(completion instanceof LookupElement);\n\n    if (reference instanceof PsiJavaCodeReferenceElement) {\n      if (completion instanceof PsiMethod &&\n          ((PsiJavaCodeReferenceElement)reference).getParent() instanceof PsiImportStaticStatement) {\n        return Collections.singletonList(JavaLookupElementBuilder.forMethod((PsiMethod)completion, PsiSubstitutor.EMPTY));\n      }\n\n      if (completion instanceof PsiClass) {\n        return JavaClassNameCompletionContributor.createClassLookupItems((PsiClass)completion,\n                                                                         JavaClassNameCompletionContributor.AFTER_NEW.accepts(reference),\n                                                                         JavaClassNameInsertHandler.JAVA_CLASS_INSERT_HANDLER,\n                                                                         Conditions.<PsiClass>alwaysTrue());\n      }\n    }\n    \n    if (reference instanceof PsiMethodReferenceExpression && completion instanceof PsiMethod && ((PsiMethod)completion).isConstructor()) {\n      return Collections.singletonList(JavaLookupElementBuilder.forMethod((PsiMethod)completion, \"new\", PsiSubstitutor.EMPTY, null));\n    }\n\n    LookupElement _ret = LookupItemUtil.objectToLookupItem(completion);\n    if (_ret instanceof LookupItem) {\n      final PsiSubstitutor substitutor = completionElement.getSubstitutor();\n      if (substitutor != null) {\n        ((LookupItem<?>)_ret).setAttribute(LookupItem.SUBSTITUTOR, substitutor);\n      }\n    }\n    return Collections.singletonList(_ret);\n  }","commit_id":"acf1d5fbaf1e7e8f9b7a7e572ab544fad746b1d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaDocCompletionContributor() {\n    extend(CompletionType.BASIC, PsiJavaPatterns.psiElement(JavaDocTokenType.DOC_TAG_NAME), new TagChooser());\n\n    extend(CompletionType.BASIC, PsiJavaPatterns.psiElement().inside(PsiDocComment.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        boolean isArg = PsiJavaPatterns.psiElement().afterLeaf(\"(\").accepts(position);\n        PsiDocTag tag = PsiTreeUtil.getParentOfType(position, PsiDocTag.class);\n        boolean onlyConstants = !isArg && tag != null && tag.getName().equals(VALUE_TAG);\n\n        final PsiReference ref = position.getContainingFile().findReferenceAt(parameters.getOffset());\n        if (ref instanceof PsiJavaReference) {\n          result.stopHere();\n\n          final JavaCompletionProcessor processor = new JavaCompletionProcessor(position, TrueFilter.INSTANCE, JavaCompletionProcessor.Options.CHECK_NOTHING, Conditions.<String>alwaysTrue());\n          ((PsiJavaReference) ref).processVariants(processor);\n\n          for (final CompletionElement _item : processor.getResults()) {\n            final Object element = _item.getElement();\n            LookupItem item = createLookupItem(element);\n            if (onlyConstants) {\n              Object o = item.getObject();\n              if (!(o instanceof PsiField)) continue;\n              PsiField field = (PsiField) o;\n              if (!(field.hasModifierProperty(PsiModifier.STATIC) && field.getInitializer() != null &&\n                  JavaConstantExpressionEvaluator.computeConstantExpression(field.getInitializer(), false) != null)) continue;\n            }\n\n            item.putUserData(LookupItem.FORCE_SHOW_SIGNATURE_ATTR, Boolean.TRUE);\n            if (isArg) {\n              item.setAutoCompletionPolicy(AutoCompletionPolicy.NEVER_AUTOCOMPLETE);\n            }\n            result.addElement(item);\n          }\n\n          JavaCompletionContributor.addAllClasses(parameters, result, new InheritorsHolder(result));\n        }\n\n        if (tag != null && \"author\".equals(tag.getName())) {\n          result.addElement(LookupElementBuilder.create(SystemProperties.getUserName()));\n        }\n      }\n\n      private LookupItem createLookupItem(final Object element) {\n        if (element instanceof PsiMethod) {\n          return new JavaMethodCallElement((PsiMethod)element) {\n            @Override\n            public void handleInsert(InsertionContext context) {\n              new MethodSignatureInsertHandler().handleInsert(context, this);\n            }\n          };\n        }\n        if (element instanceof PsiClass) {\n          JavaPsiClassReferenceElement classElement = new JavaPsiClassReferenceElement((PsiClass)element);\n          classElement.setInsertHandler(JavaClassNameInsertHandler.JAVA_CLASS_INSERT_HANDLER);\n          return classElement;\n        }\n\n        return (LookupItem)LookupItemUtil.objectToLookupItem(element);\n      }\n    });\n  }","id":77018,"modified_method":"public JavaDocCompletionContributor() {\n    extend(CompletionType.BASIC, PsiJavaPatterns.psiElement(JavaDocTokenType.DOC_TAG_NAME), new TagChooser());\n\n    extend(CompletionType.BASIC, PsiJavaPatterns.psiElement().inside(PsiDocComment.class), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result) {\n        final PsiElement position = parameters.getPosition();\n        boolean isArg = PsiJavaPatterns.psiElement().afterLeaf(\"(\").accepts(position);\n        PsiDocTag tag = PsiTreeUtil.getParentOfType(position, PsiDocTag.class);\n        boolean onlyConstants = !isArg && tag != null && tag.getName().equals(VALUE_TAG);\n\n        final PsiReference ref = position.getContainingFile().findReferenceAt(parameters.getOffset());\n        if (ref instanceof PsiJavaReference) {\n          result.stopHere();\n\n          final JavaCompletionProcessor processor = new JavaCompletionProcessor(position, TrueFilter.INSTANCE, JavaCompletionProcessor.Options.CHECK_NOTHING, Conditions.<String>alwaysTrue());\n          ((PsiJavaReference) ref).processVariants(processor);\n\n          for (final CompletionElement _item : processor.getResults()) {\n            final Object element = _item.getElement();\n            LookupElement item = createLookupItem(element);\n            if (onlyConstants) {\n              Object o = item.getObject();\n              if (!(o instanceof PsiField)) continue;\n              PsiField field = (PsiField) o;\n              if (!(field.hasModifierProperty(PsiModifier.STATIC) && field.getInitializer() != null &&\n                  JavaConstantExpressionEvaluator.computeConstantExpression(field.getInitializer(), false) != null)) continue;\n            }\n\n            item.putUserData(LookupItem.FORCE_SHOW_SIGNATURE_ATTR, Boolean.TRUE);\n            if (isArg) {\n              item = AutoCompletionPolicy.NEVER_AUTOCOMPLETE.applyPolicy(item);\n            }\n            result.addElement(item);\n          }\n\n          JavaCompletionContributor.addAllClasses(parameters, result, new InheritorsHolder(result));\n        }\n\n        if (tag != null && \"author\".equals(tag.getName())) {\n          result.addElement(LookupElementBuilder.create(SystemProperties.getUserName()));\n        }\n      }\n\n      private LookupElement createLookupItem(final Object element) {\n        if (element instanceof PsiMethod) {\n          return new JavaMethodCallElement((PsiMethod)element) {\n            @Override\n            public void handleInsert(InsertionContext context) {\n              new MethodSignatureInsertHandler().handleInsert(context, this);\n            }\n          };\n        }\n        if (element instanceof PsiClass) {\n          JavaPsiClassReferenceElement classElement = new JavaPsiClassReferenceElement((PsiClass)element);\n          classElement.setInsertHandler(JavaClassNameInsertHandler.JAVA_CLASS_INSERT_HANDLER);\n          return classElement;\n        }\n\n        return LookupItemUtil.objectToLookupItem(element);\n      }\n    });\n  }","commit_id":"acf1d5fbaf1e7e8f9b7a7e572ab544fad746b1d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PackageLookupItem(PsiPackage pkg) {\n    super(pkg, StringUtil.notNullize(pkg.getName()));\n    setTailType(TailType.DOT);\n  }","id":77019,"modified_method":"public PackageLookupItem(PsiPackage pkg) {\n    myPackage = pkg;\n    myString = StringUtil.notNullize(myPackage.getName());\n  }","commit_id":"acf1d5fbaf1e7e8f9b7a7e572ab544fad746b1d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void handleInsert(InsertionContext context) {\n    super.handleInsert(context);\n    if (getTailType() == TailType.DOT || context.getCompletionChar() == '.') {\n      AutoPopupController.getInstance(context.getProject()).scheduleAutoPopup(context.getEditor());\n    }\n  }","id":77020,"modified_method":"@Override\n  public void handleInsert(InsertionContext context) {\n    PsiFile file = context.getFile();\n    boolean addDot = !(file instanceof PsiJavaCodeReferenceCodeFragment) || ((PsiJavaCodeReferenceCodeFragment)file).isClassesAccepted();\n    if (addDot) {\n      context.setAddCompletionChar(false);\n      TailType.DOT.processTail(context.getEditor(), context.getTailOffset());\n    }\n    if (addDot || context.getCompletionChar() == '.') {\n      AutoPopupController.getInstance(context.getProject()).scheduleAutoPopup(context.getEditor());\n    }\n  }","commit_id":"acf1d5fbaf1e7e8f9b7a7e572ab544fad746b1d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public DocumentContent create(@NotNull String text, @Nullable FileType type) {\n    Document document = EditorFactory.getInstance().createDocument(StringUtil.convertLineSeparators(text));\n    document.setReadOnly(true);\n    return new DocumentContentImpl(document, type, null, null, null);\n  }","id":77021,"modified_method":"@Override\n  @NotNull\n  public DocumentContent create(@NotNull String text, @Nullable FileType type) {\n    return create(text, type, true);\n  }","commit_id":"7de61fbcaa9f8694b8eac572e21fba1e7dfa4fd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public DocumentContent createClipboardContent(@NotNull DocumentContent mainContent) {\n    String text = CopyPasteManager.getInstance().getContents(DataFlavor.stringFlavor);\n    Document document = EditorFactory.getInstance().createDocument(StringUtil.convertLineSeparators(StringUtil.notNullize(text)));\n    return new DocumentContentWrapper(document, mainContent);\n  }","id":77022,"modified_method":"@Override\n  @NotNull\n  public DocumentContent createClipboardContent(@Nullable DocumentContent mainContent) {\n    String text = CopyPasteManager.getInstance().getContents(DataFlavor.stringFlavor);\n\n    FileType type = mainContent != null ? mainContent.getContentType() : null;\n    VirtualFile highlightFile = mainContent != null ? mainContent.getHighlightFile() : null;\n\n    return createImpl(StringUtil.notNullize(text), type, highlightFile, null, true, false);\n  }","commit_id":"7de61fbcaa9f8694b8eac572e21fba1e7dfa4fd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public DiffContent createClipboardContent() {\n    String text = CopyPasteManager.getInstance().getContents(DataFlavor.stringFlavor);\n    Document document = EditorFactory.getInstance().createDocument(StringUtil.convertLineSeparators(StringUtil.notNullize(text)));\n    return new DocumentContentImpl(document); // TODO: show difference in line separators ?\n  }","id":77023,"modified_method":"@Override\n  @NotNull\n  public DiffContent createClipboardContent() {\n    return createClipboardContent(null);\n  }","commit_id":"7de61fbcaa9f8694b8eac572e21fba1e7dfa4fd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static DiffContent fromPsiElement(@NotNull PsiElement psiElement) {\n    if (psiElement instanceof PsiFile) {\n      return DiffContentFactory.getInstance().create(psiElement.getProject(), ((PsiFile)psiElement).getVirtualFile());\n    }\n    else if (psiElement instanceof PsiDirectory) {\n      return DiffContentFactory.getInstance().create(psiElement.getProject(), ((PsiDirectory)psiElement).getVirtualFile());\n    }\n    PsiFile containingFile = psiElement.getContainingFile();\n    if (containingFile == null) {\n      String text = psiElement.getText();\n      if (text == null) return null;\n      return DiffContentFactory.getInstance().create(text, psiElement.getLanguage().getAssociatedFileType());\n    }\n    DocumentContent wholeFileContent = DiffContentFactory.getInstance().createDocument(psiElement.getProject(), containingFile.getVirtualFile());\n    if (wholeFileContent == null) return null;\n    return new DocumentFragmentContent(psiElement.getProject(), wholeFileContent, psiElement.getTextRange());\n  }","id":77024,"modified_method":"@Nullable\n  private static DiffContent fromPsiElement(@NotNull PsiElement psiElement) {\n    if (psiElement instanceof PsiFile) {\n      return DiffContentFactory.getInstance().create(psiElement.getProject(), ((PsiFile)psiElement).getVirtualFile());\n    }\n    else if (psiElement instanceof PsiDirectory) {\n      return DiffContentFactory.getInstance().create(psiElement.getProject(), ((PsiDirectory)psiElement).getVirtualFile());\n    }\n    PsiFile containingFile = psiElement.getContainingFile();\n    if (containingFile == null) {\n      String text = psiElement.getText();\n      if (text == null) return null;\n      return DiffContentFactory.getInstance().create(text, psiElement.getLanguage().getAssociatedFileType(), false);\n    }\n    DocumentContent wholeFileContent = DiffContentFactory.getInstance().createDocument(psiElement.getProject(), containingFile.getVirtualFile());\n    if (wholeFileContent == null) return null;\n    return new DocumentFragmentContent(psiElement.getProject(), wholeFileContent, psiElement.getTextRange());\n  }","commit_id":"7de61fbcaa9f8694b8eac572e21fba1e7dfa4fd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Import readImport(UnitInputStream in) throws IOException {\n    int qualifier = 0;\n    int len = DataInputOutputUtil.readINT(in);\n    for (int i = 0; i < len - 1; i++) {\n      qualifier = in.names.qualifiedName(qualifier, in.readInt());\n    }\n    int lastId = in.readInt();\n    int flags = in.readByte();\n    int alias = BitUtil.isSet(flags, HAS_ALIAS) ? in.readInt() : 0;\n\n    boolean onDemand = BitUtil.isSet(flags, IS_ON_DEMAND);\n    boolean isStatic = BitUtil.isSet(flags, IS_STATIC);\n\n    int shortName;\n    if (onDemand) {\n      shortName = 0;\n      qualifier = in.names.qualifiedName(qualifier, lastId);\n    } else {\n      shortName = lastId;\n    }\n\n    return obtainImport(qualifier, shortName, alias, isStatic);\n  }","id":77025,"modified_method":"private Import readImport(UnitInputStream in) throws IOException {\n    int qualifier = in.readInt();\n    int flags = in.readByte();\n    int shortName = BitUtil.isSet(flags, IS_ON_DEMAND) ? 0 : in.readInt();\n    int alias = BitUtil.isSet(flags, HAS_ALIAS) ? in.readInt() : 0;\n\n    return obtainImport(qualifier, shortName, alias, BitUtil.isSet(flags, IS_STATIC));\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void writeImport(@NotNull DataOutput out, IndexTree.Import anImport) throws IOException {\n    SerializedUnit.writeQualifiedName(out, anImport.myFullname);\n    boolean hasAlias = anImport.myAlias != 0;\n    int flags = 0;\n    flags = BitUtil.set(flags, IS_STATIC, anImport.myStaticImport);\n    flags = BitUtil.set(flags, IS_ON_DEMAND, anImport.myOnDemand);\n    flags = BitUtil.set(flags, HAS_ALIAS, hasAlias);\n    out.writeByte(flags);\n    if (hasAlias) {\n      out.writeInt(anImport.myAlias);\n    }\n  }","id":77026,"modified_method":"private static void writeImport(@NotNull DataOutput out, IndexTree.Import anImport) throws IOException {\n    out.writeInt(NameEnvironment.fromString(anImport.myQualifier));\n    boolean hasAlias = anImport.myAlias != null;\n    int flags = 0;\n    flags = BitUtil.set(flags, IS_STATIC, anImport.myStaticImport);\n    flags = BitUtil.set(flags, IS_ON_DEMAND, anImport.myOnDemand);\n    flags = BitUtil.set(flags, HAS_ALIAS, hasAlias);\n    out.writeByte(flags);\n    if (anImport.myImportedName != null) {\n      out.writeInt(NameEnvironment.hashIdentifier(anImport.myImportedName));\n    }\n    if (hasAlias) {\n      out.writeInt(NameEnvironment.hashIdentifier(anImport.myAlias));\n    }\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Import(String fullname, boolean staticImport, boolean onDemand, @Nullable String alias) {\n      this(hashQualifiedName(fullname), staticImport, onDemand, hashIdentifier(alias));\n    }","id":77027,"modified_method":"public Import(String fullname, boolean staticImport, boolean onDemand, @Nullable String alias) {\n      myQualifier = onDemand ? fullname : StringUtil.getPackageName(fullname);\n      myImportedName = onDemand ? null : StringUtil.getShortName(fullname);\n      myStaticImport = staticImport;\n      myOnDemand = onDemand;\n      myAlias = alias;\n    }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Unit(@Nullable String packageName, byte unitType, Import[] imports, ClassDecl[] decls) {\n      this(hashQualifiedName(StringUtil.notNullize(packageName)), unitType, imports, decls);\n    }","id":77028,"modified_method":"public Unit(@Nullable String packageName, byte unitType, Import[] imports, ClassDecl[] decls) {\n      myPackageName = StringUtil.notNullize(packageName);\n      myUnitType = unitType;\n      this.imports = imports;\n      myDecls = decls;\n    }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClassDecl(int stubId, int mods, @Nullable String name, String[] supers, Decl[] decls) {\n      this(stubId, mods, hashIdentifier(name), hashQualifiedNameArray(supers), decls);\n    }","id":77029,"modified_method":"public ClassDecl(int stubId, int mods, @Nullable String name, String[] supers, Decl[] decls) {\n      super(decls);\n      assert stubId > 0;\n      myStubId = stubId;\n      myMods = mods;\n      myName = name;\n      mySupers = supers;\n    }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@QNameHash int fromString(String s) {\n    int id = 0;\n    for (int shortName : IndexTree.hashQualifiedName(s)) {\n      id = qualifiedName(id, shortName);\n    }\n    return id;\n  }","id":77030,"modified_method":"static @QNameHash int fromString(String s) {\n    int id = 0;\n    for (int shortName : hashQualifiedName(s)) {\n      id = qualifiedName(id, shortName);\n    }\n    return id;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ClassSymbol readClassDecl(UnitInputStream in, UnitInfo info, Symbol owner, @QNameHash int ownerName) throws IOException {\n    int stubId = DataInputOutputUtil.readINT(in);\n    int mods = DataInputOutputUtil.readINT(in);\n    @ShortName int name = in.readInt();\n    @CompactArray(QualifiedName.class) Object superNames = readSupers(in, info.isCompiled());\n\n    @QNameHash int qname = in.names.memberQualifiedName(ownerName, name);\n    ClassSymbol symbol = in.stubEnter.classEnter(info, owner, stubId, mods, name, superNames, qname, in.fileId);\n\n    readMembers(in, info, qname, symbol);\n    return symbol;\n  }","id":77031,"modified_method":"private static ClassSymbol readClassDecl(UnitInputStream in, UnitInfo info, Symbol owner, @QNameHash int ownerName) throws IOException {\n    int stubId = DataInputOutputUtil.readINT(in);\n    int mods = DataInputOutputUtil.readINT(in);\n    @ShortName int name = in.readInt();\n    @CompactArray(QualifiedName.class) Object superNames = readSupers(in, info.isCompiled());\n\n    @QNameHash int qname = NameEnvironment.memberQualifiedName(ownerName, name);\n    ClassSymbol symbol = in.stubEnter.classEnter(info, owner, stubId, mods, name, superNames, qname, in.fileId);\n\n    readMembers(in, info, qname, symbol);\n    return symbol;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static QualifiedName readSuperName(UnitInputStream in, boolean intern) throws IOException {\n    return intern ? new QualifiedName.Interned(in.names.readQualifiedName(in)) : readNameComponents(in);\n  }","id":77032,"modified_method":"private static QualifiedName readSuperName(UnitInputStream in, boolean intern) throws IOException {\n    return intern ? new QualifiedName.Interned(in.readInt()) : readNameComponents(in);\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void saveClassDecl(@NotNull DataOutput out, IndexTree.ClassDecl value) throws IOException {\n    DataInputOutputUtil.writeINT(out, value.myStubId);\n    DataInputOutputUtil.writeINT(out, value.myMods);\n    out.writeInt(value.myName);\n    writeSupers(out, value);\n    writeMembers(out, value.myDecls);\n  }","id":77033,"modified_method":"private static void saveClassDecl(@NotNull DataOutput out, IndexTree.ClassDecl value, boolean compiled) throws IOException {\n    DataInputOutputUtil.writeINT(out, value.myStubId);\n    DataInputOutputUtil.writeINT(out, value.myMods);\n    out.writeInt(NameEnvironment.hashIdentifier(value.myName));\n    writeSupers(out, value, compiled);\n    writeMembers(out, value.myDecls, compiled);\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"UnitInputStream(InputStream in, int fileId, StubEnter stubEnter) {\n    super(in);\n    this.fileId = fileId;\n    this.stubEnter = stubEnter;\n    this.names = stubEnter.myNameEnvironment;\n  }","id":77034,"modified_method":"UnitInputStream(InputStream in, int fileId, StubEnter stubEnter) {\n    super(in);\n    this.fileId = fileId;\n    this.stubEnter = stubEnter;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void writeSupers(@NotNull DataOutput out, IndexTree.ClassDecl value) throws IOException {\n    DataInputOutputUtil.writeINT(out, value.mySupers.length);\n    for (int[] aSuper : value.mySupers) {\n      writeQualifiedName(out, aSuper);\n    }\n  }","id":77035,"modified_method":"private static void writeSupers(@NotNull DataOutput out, IndexTree.ClassDecl value, boolean interned) throws IOException {\n    DataInputOutputUtil.writeINT(out, value.mySupers.length);\n    for (String aSuper : value.mySupers) {\n      writeSuperName(out, interned, aSuper);\n    }\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void writeUnit(@NotNull DataOutput out, IndexTree.Unit value) throws IOException {\n    writeQualifiedName(out, value.myPackageName);\n    out.writeByte(value.myUnitType);\n    if (value.myUnitType != IndexTree.BYTECODE) {\n      Imports.writeImports(out, value);\n    }\n    // class Declaration\n    DataInputOutputUtil.writeINT(out, value.myDecls.length);\n    for (IndexTree.ClassDecl def : value.myDecls) {\n      saveClassDecl(out, def);\n    }\n  }","id":77036,"modified_method":"private static void writeUnit(@NotNull DataOutput out, IndexTree.Unit value) throws IOException {\n    writeNameComponents(out, value.myPackageName);\n    out.writeByte(value.myUnitType);\n    boolean compiled = value.myUnitType == IndexTree.BYTECODE;\n    if (!compiled) {\n      Imports.writeImports(out, value);\n    }\n    // class Declaration\n    DataInputOutputUtil.writeINT(out, value.myDecls.length);\n    for (IndexTree.ClassDecl def : value.myDecls) {\n      saveClassDecl(out, def, compiled);\n    }\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void saveDecl(@NotNull DataOutput out, IndexTree.Decl value) throws IOException {\n    if (value instanceof IndexTree.ClassDecl) {\n      out.writeBoolean(true);\n      saveClassDecl(out, (IndexTree.ClassDecl)value);\n    } else if (value instanceof IndexTree.MemberDecl) {\n      out.writeBoolean(false);\n      writeMembers(out, ((IndexTree.MemberDecl)value).myDecls);\n    }\n  }","id":77037,"modified_method":"private static void saveDecl(@NotNull DataOutput out, IndexTree.Decl value, boolean compiled) throws IOException {\n    if (value instanceof IndexTree.ClassDecl) {\n      out.writeBoolean(true);\n      saveClassDecl(out, (IndexTree.ClassDecl)value, compiled);\n    } else if (value instanceof IndexTree.MemberDecl) {\n      out.writeBoolean(false);\n      writeMembers(out, ((IndexTree.MemberDecl)value).myDecls, compiled);\n    }\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void writeMembers(@NotNull DataOutput out, IndexTree.Decl[] decls) throws IOException {\n    DataInputOutputUtil.writeINT(out, decls.length);\n    for (IndexTree.Decl def : decls) {\n      saveDecl(out, def);\n    }\n  }","id":77038,"modified_method":"private static void writeMembers(@NotNull DataOutput out, IndexTree.Decl[] decls, boolean compiled) throws IOException {\n    DataInputOutputUtil.writeINT(out, decls.length);\n    for (IndexTree.Decl def : decls) {\n      saveDecl(out, def, compiled);\n    }\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"StubEnter(Symbols symbols) {\n    myNameEnvironment = symbols.myNameEnvironment;\n    mySymbols = symbols;\n    myStubHierarchyConnector = new StubHierarchyConnector(myNameEnvironment, symbols);\n  }","id":77039,"modified_method":"StubEnter(Symbols symbols) {\n    mySymbols = symbols;\n    myStubHierarchyConnector = new StubHierarchyConnector(symbols);\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"PackageSymbol readPackageName(DataInput in) throws IOException {\n    PackageSymbol pkg = mySymbols.myRootPackage;\n    int qname = 0;\n    int len = DataInputOutputUtil.readINT(in);\n    for (int i = 0; i < len; i++) {\n      int shortName = in.readInt();\n      qname = myNameEnvironment.qualifiedName(qname, shortName);\n      pkg = mySymbols.enterPackage(qname, shortName, pkg);\n    }\n    return pkg;\n  }","id":77040,"modified_method":"PackageSymbol readPackageName(DataInput in) throws IOException {\n    PackageSymbol pkg = mySymbols.myRootPackage;\n    int qname = 0;\n    int len = DataInputOutputUtil.readINT(in);\n    for (int i = 0; i < len; i++) {\n      int shortName = in.readInt();\n      qname = NameEnvironment.qualifiedName(qname, shortName);\n      pkg = mySymbols.enterPackage(qname, shortName, pkg);\n    }\n    return pkg;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isJavaLangObject(Symbol s) {\n    return s.myShortName == NameEnvironment.OBJECT_NAME &&\n           s.myOwner instanceof Symbol.PackageSymbol &&\n           ((Symbol.PackageSymbol)s.myOwner).myQualifiedName == myNameEnvironment.java_lang;\n  }","id":77041,"modified_method":"private static boolean isJavaLangObject(Symbol s) {\n    return s.myShortName == NameEnvironment.OBJECT_NAME &&\n           s.myOwner instanceof Symbol.PackageSymbol &&\n           ((Symbol.PackageSymbol)s.myOwner).myQualifiedName == NameEnvironment.java_lang;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected StubHierarchyConnector(NameEnvironment nameEnvironment, Symbols symbols) {\n    this.myNameEnvironment = nameEnvironment;\n    myResolve = new StubResolver(symbols, this);\n  }","id":77042,"modified_method":"protected StubHierarchyConnector(Symbols symbols) {\n    myResolve = new StubResolver(symbols, this);\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getVersion() {\n    return IndexTree.STUB_HIERARCHY_ENABLED ? 7 + Arrays.stream(ourIndexers).mapToInt(StubHierarchyIndexer::getVersion).sum() : 0;\n  }","id":77043,"modified_method":"@Override\n  public int getVersion() {\n    return IndexTree.STUB_HIERARCHY_ENABLED ? 8 + Arrays.stream(ourIndexers).mapToInt(StubHierarchyIndexer::getVersion).sum() : 0;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleImport(Import anImport, @ShortName int name, Set<Symbol> symbols) throws IncompleteHierarchyException {\n    if (anImport.isOnDemand()) {\n      if (anImport.isStatic) {\n        for (Symbol.ClassSymbol p : findGlobalType(anImport.qualifier))\n          importNamedStatic(p, name, symbols);\n      }\n      else {\n        importAll(anImport.qualifier, name, symbols);\n      }\n    }\n    else {\n      @ShortName int importedName = anImport.getAlias() != 0 ? anImport.getAlias() : anImport.importedName;\n      if (name != importedName) return;\n\n      if (anImport.isStatic) {\n          for (Symbol.ClassSymbol s : findGlobalType(anImport.qualifier))\n            importNamedStatic(s, anImport.importedName, symbols);\n      }\n      else {\n        Collections.addAll(symbols, findGlobalType(myNameEnvironment.qualifiedName(anImport.qualifier, anImport.importedName)));\n      }\n    }\n  }","id":77044,"modified_method":"public void handleImport(Import anImport, @ShortName int name, Set<Symbol> symbols) throws IncompleteHierarchyException {\n    if (anImport.isOnDemand()) {\n      if (anImport.isStatic) {\n        for (Symbol.ClassSymbol p : findGlobalType(anImport.qualifier))\n          importNamedStatic(p, name, symbols);\n      }\n      else {\n        importAll(anImport.qualifier, name, symbols);\n      }\n    }\n    else {\n      @ShortName int importedName = anImport.getAlias() != 0 ? anImport.getAlias() : anImport.importedName;\n      if (name != importedName) return;\n\n      if (anImport.isStatic) {\n          for (Symbol.ClassSymbol s : findGlobalType(anImport.qualifier))\n            importNamedStatic(s, anImport.importedName, symbols);\n      }\n      else {\n        Collections.addAll(symbols, findGlobalType(NameEnvironment.qualifiedName(anImport.qualifier, anImport.importedName)));\n      }\n    }\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findGlobalType(UnitInfo info, @ShortName int name, Set<Symbol> symbols) throws IncompleteHierarchyException {\n    for (Import anImport : Translator.getDefaultImports(info.type, myNameEnvironment))\n      handleImport(anImport, name, symbols);\n    for (Import anImport : info.imports)\n      handleImport(anImport, name, symbols);\n  }","id":77045,"modified_method":"private void findGlobalType(UnitInfo info, @ShortName int name, Set<Symbol> symbols) throws IncompleteHierarchyException {\n    for (Import anImport : getDefaultImports(info.type))\n      handleImport(anImport, name, symbols);\n    for (Import anImport : info.imports)\n      handleImport(anImport, name, symbols);\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StubResolver(Symbols symbols, StubHierarchyConnector connector) {\n    this.mySymbols = symbols;\n    this.myNameEnvironment = symbols.myNameEnvironment;\n    myConnector = connector;\n  }","id":77046,"modified_method":"public StubResolver(Symbols symbols, StubHierarchyConnector connector) {\n    this.mySymbols = symbols;\n    myConnector = connector;\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findIdentInPackage(Symbol.PackageSymbol pck, @ShortName int name, boolean processPackages, Set<Symbol> symbols) {\n    @QNameHash int fullname = mySymbols.myNameEnvironment.qualifiedName(pck.myQualifiedName, name);\n    if (processPackages) {\n      ContainerUtil.addIfNotNull(symbols, mySymbols.getPackage(fullname));\n    }\n    Collections.addAll(symbols, findGlobalType(fullname));\n  }","id":77047,"modified_method":"private void findIdentInPackage(Symbol.PackageSymbol pck, @ShortName int name, boolean processPackages, Set<Symbol> symbols) {\n    @QNameHash int fullname = NameEnvironment.qualifiedName(pck.myQualifiedName, name);\n    if (processPackages) {\n      ContainerUtil.addIfNotNull(symbols, mySymbols.getPackage(fullname));\n    }\n    Collections.addAll(symbols, findGlobalType(fullname));\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void importAll(@QNameHash int prefix, @ShortName int suffix, final Set<Symbol> symbols) {\n    Collections.addAll(symbols, findGlobalType(myNameEnvironment.qualifiedName(prefix, suffix)));\n  }","id":77048,"modified_method":"private void importAll(@QNameHash int prefix, @ShortName int suffix, final Set<Symbol> symbols) {\n    Collections.addAll(symbols, findGlobalType(NameEnvironment.qualifiedName(prefix, suffix)));\n  }","commit_id":"e7b814c5496468630cd040f24954f01fc3d8d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setFinishedReportText() {\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n        String reportText = \"These reports were generated on \" + dateFormat.format(new Date()) + \".\";\n        statusLabel.setText(reportText);\n        \n        final JPanel tempPanel = new JPanel(new GridBagLayout());\n        //tempPanel.setMinimumSize(new Dimension(540,240));\n        SwingUtilities.invokeLater(new Runnable() {\n\n            GridBagConstraints c = new GridBagConstraints();\n\n            @Override\n            public void run() {\n                HashMap<ReportModule, String> reports = rpa.getReports();\n                int cc = 0;\n                for (Map.Entry<ReportModule, String> entry : reports.entrySet()) {\n                    c.fill = GridBagConstraints.HORIZONTAL;\n                    c.weightx = 1;\n                    c.gridwidth = 1;\n                    c.gridx = 0;\n                    c.gridy = cc;\n                    c.insets = new Insets(0, 0, 0, 0); // remove padding\n                    String info = entry.getKey().getName() + \" report\";\n                    JLabel infoLabel = new JLabel(info);\n                    tempPanel.add(infoLabel, c);\n                    \n                    c.fill = GridBagConstraints.BASELINE_TRAILING;\n                    c.weightx = 0.0;\n                    c.gridwidth = 1;\n                    c.gridheight = 1;\n                    c.gridx = 1;\n                    c.gridy = cc;\n                    JButton viewButton = new JButton(\"View Report\");\n                    final ReportModule rep = entry.getKey();\n                    final String path = entry.getValue();\n                    viewButton.addActionListener(new ActionListener() {\n                        @Override\n                        public void actionPerformed(ActionEvent e) {\n                            rep.getPreview(path);\n                        }\n                    });\n                    tempPanel.add(viewButton, c);\n                    \n                    c.fill = GridBagConstraints.HORIZONTAL;\n                    c.weightx = 1;\n                    c.gridwidth = 3;\n                    c.gridheight = 1;\n                    c.gridx = 0;\n                    c.gridy = ++cc;\n                    c.insets = new Insets(0, 0, 15, 0); // row padding\n                    JLabel pathLabel = new JLabel(path);\n                    tempPanel.add(pathLabel, c);\n                    \n                    tempPanel.revalidate();\n                    tempPanel.repaint();\n                    cc++;\n                }\n            }\n        });\n        reportSummaryPanel.setLayout(new GridLayout(0, 1));\n        reportSummaryPanel.add(tempPanel, 0);\n        //reportScrollPane.revalidate();\n        //reportScrollPane.repaint();\n        \n    }","id":77049,"modified_method":"public void setFinishedReportText() {\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n        String reportText = \"These reports were generated on \" + dateFormat.format(new Date()) + \".\";\n        String loc = \"Reports extracted to: \" + Case.getCurrentCase().getCaseDirectory() + File.separator + \"Reports\";\n        statusLabel.setText(reportText);\n        LABEL_LOC.setText(loc);\n        \n        final JPanel tempPanel = new JPanel(new GridBagLayout());\n        //tempPanel.setMinimumSize(new Dimension(540,240));\n        SwingUtilities.invokeLater(new Runnable() {\n\n            GridBagConstraints c = new GridBagConstraints();\n\n            @Override\n            public void run() {\n                HashMap<ReportModule, String> reports = rpa.getReports();\n                int cc = 0;\n                for (Map.Entry<ReportModule, String> entry : reports.entrySet()) {\n                    c.fill = GridBagConstraints.HORIZONTAL;\n                    c.weightx = 1;\n                    c.gridwidth = 1;\n                    c.gridx = 0;\n                    c.gridy = cc;\n                    c.insets = new Insets(0, 0, 0, 0); // remove padding\n                    String info = entry.getKey().getName() + \" report\";\n                    JLabel infoLabel = new JLabel(info);\n                    tempPanel.add(infoLabel, c);\n                    \n                    c.fill = GridBagConstraints.BASELINE_TRAILING;\n                    c.weightx = 0.0;\n                    c.gridwidth = 1;\n                    c.gridheight = 1;\n                    c.gridx = 1;\n                    c.gridy = cc;\n                    JButton viewButton = new JButton(\"View Report\");\n                    final ReportModule rep = entry.getKey();\n                    final String path = entry.getValue();\n                    viewButton.addActionListener(new ActionListener() {\n                        @Override\n                        public void actionPerformed(ActionEvent e) {\n                            rep.getPreview(path);\n                        }\n                    });\n                    tempPanel.add(viewButton, c);\n                    \n                    c.fill = GridBagConstraints.HORIZONTAL;\n                    c.weightx = 1;\n                    c.gridwidth = 3;\n                    c.gridheight = 1;\n                    c.gridx = 0;\n                    c.gridy = ++cc;\n                    c.insets = new Insets(0, 0, 15, 0); // row padding\n                    JLabel pathLabel = new JLabel(path);\n                    //tempPanel.add(pathLabel, c);\n                    \n                    tempPanel.revalidate();\n                    tempPanel.repaint();\n                    cc++;\n                }\n            }\n        });\n        reportSummaryPanel.setLayout(new GridLayout(0, 1));\n        reportSummaryPanel.add(tempPanel, 0);\n        //reportScrollPane.revalidate();\n        //reportScrollPane.repaint();\n        \n    }","commit_id":"cd7a4bb6ff5d1bd6f538db9cf2f3c8bcd339d60a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        reportScrollPane = new javax.swing.JScrollPane();\n        reportSummaryPanel = new javax.swing.JPanel();\n        closeButton = new javax.swing.JButton();\n        exportButton = new javax.swing.JButton();\n        statusLabel = new javax.swing.JLabel();\n\n        reportScrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.reportScrollPane.border.title\"))); // NOI18N\n\n        javax.swing.GroupLayout reportSummaryPanelLayout = new javax.swing.GroupLayout(reportSummaryPanel);\n        reportSummaryPanel.setLayout(reportSummaryPanelLayout);\n        reportSummaryPanelLayout.setHorizontalGroup(\n            reportSummaryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 675, Short.MAX_VALUE)\n        );\n        reportSummaryPanelLayout.setVerticalGroup(\n            reportSummaryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 214, Short.MAX_VALUE)\n        );\n\n        reportScrollPane.setViewportView(reportSummaryPanel);\n\n        org.openide.awt.Mnemonics.setLocalizedText(closeButton, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.closeButton.text_1\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(exportButton, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.exportButton.text\")); // NOI18N\n        exportButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exportButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(statusLabel, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.statusLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(reportScrollPane)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addGap(0, 493, Short.MAX_VALUE)\n                        .addComponent(exportButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(closeButton))\n                    .addComponent(statusLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(reportScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 241, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(statusLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(closeButton)\n                    .addComponent(exportButton))\n                .addContainerGap())\n        );\n    }","id":77050,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        reportScrollPane = new javax.swing.JScrollPane();\n        reportSummaryPanel = new javax.swing.JPanel();\n        closeButton = new javax.swing.JButton();\n        exportButton = new javax.swing.JButton();\n        statusLabel = new javax.swing.JLabel();\n        LABEL_LOC = new javax.swing.JLabel();\n\n        reportScrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.reportScrollPane.border.title\"))); // NOI18N\n\n        javax.swing.GroupLayout reportSummaryPanelLayout = new javax.swing.GroupLayout(reportSummaryPanel);\n        reportSummaryPanel.setLayout(reportSummaryPanelLayout);\n        reportSummaryPanelLayout.setHorizontalGroup(\n            reportSummaryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 675, Short.MAX_VALUE)\n        );\n        reportSummaryPanelLayout.setVerticalGroup(\n            reportSummaryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 214, Short.MAX_VALUE)\n        );\n\n        reportScrollPane.setViewportView(reportSummaryPanel);\n\n        org.openide.awt.Mnemonics.setLocalizedText(closeButton, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.closeButton.text_1\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(exportButton, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.exportButton.text\")); // NOI18N\n        exportButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exportButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(statusLabel, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.statusLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(LABEL_LOC, org.openide.util.NbBundle.getMessage(ReportPanel.class, \"ReportPanel.LABEL_LOC.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(reportScrollPane)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(LABEL_LOC)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(exportButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(closeButton))\n                    .addComponent(statusLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(reportScrollPane)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(statusLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(closeButton)\n                        .addComponent(exportButton))\n                    .addComponent(LABEL_LOC))\n                .addContainerGap())\n        );\n    }","commit_id":"cd7a4bb6ff5d1bd6f538db9cf2f3c8bcd339d60a","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jButton2 = new javax.swing.JButton();\n        progBar = new javax.swing.JProgressBar();\n        jButton1 = new javax.swing.JButton();\n        cancelButton = new javax.swing.JButton();\n        updateLabel = new javax.swing.JLabel();\n\n        jButton2.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton2.text\")); // NOI18N\n        jButton2.setActionCommand(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton2.actionCommand\")); // NOI18N\n        jButton2.setLabel(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton2.label\")); // NOI18N\n\n        setPreferredSize(new java.awt.Dimension(500, 75));\n\n        progBar.setDoubleBuffered(true);\n        progBar.setEnabled(false);\n        progBar.setName(\"\"); // NOI18N\n        progBar.setPreferredSize(new java.awt.Dimension(146, 15));\n        progBar.setString(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.progBar.string\")); // NOI18N\n        progBar.setStringPainted(true);\n\n        jButton1.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton1.text\")); // NOI18N\n        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseReleased(java.awt.event.MouseEvent evt) {\n                jButton1MouseReleased(evt);\n            }\n        });\n        jButton1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton1ActionPerformed(evt);\n            }\n        });\n\n        cancelButton.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.cancelButton.text\")); // NOI18N\n        cancelButton.setActionCommand(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.cancelButton.actionCommand\")); // NOI18N\n        cancelButton.setEnabled(false);\n        cancelButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cancelButtonActionPerformed(evt);\n            }\n        });\n\n        updateLabel.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.updateLabel.text\")); // NOI18N\n        updateLabel.setToolTipText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.updateLabel.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jButton1)\n                        .addGap(18, 18, 18)\n                        .addComponent(updateLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 272, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(progBar, javax.swing.GroupLayout.DEFAULT_SIZE, 332, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(cancelButton)))\n                .addGap(24, 24, 24))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(19, 19, 19)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jButton1)\n                    .addComponent(updateLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 51, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(cancelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(progBar, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(39, Short.MAX_VALUE))\n        );\n    }","id":77051,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jButton2 = new javax.swing.JButton();\n        progBar = new javax.swing.JProgressBar();\n        jButton1 = new javax.swing.JButton();\n        cancelButton = new javax.swing.JButton();\n        updateLabel = new javax.swing.JLabel();\n\n        jButton2.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton2.text\")); // NOI18N\n        jButton2.setActionCommand(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton2.actionCommand\")); // NOI18N\n        jButton2.setLabel(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton2.label\")); // NOI18N\n\n        setPreferredSize(new java.awt.Dimension(500, 75));\n\n        progBar.setDoubleBuffered(true);\n        progBar.setEnabled(false);\n        progBar.setName(\"\"); // NOI18N\n        progBar.setPreferredSize(new java.awt.Dimension(146, 15));\n        progBar.setString(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.progBar.string\")); // NOI18N\n        progBar.setStringPainted(true);\n\n        jButton1.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.jButton1.text\")); // NOI18N\n        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseReleased(java.awt.event.MouseEvent evt) {\n                jButton1MouseReleased(evt);\n            }\n        });\n        jButton1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButton1ActionPerformed(evt);\n            }\n        });\n\n        cancelButton.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.cancelButton.text\")); // NOI18N\n        cancelButton.setActionCommand(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.cancelButton.actionCommand\")); // NOI18N\n        cancelButton.setEnabled(false);\n        cancelButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cancelButtonActionPerformed(evt);\n            }\n        });\n\n        updateLabel.setText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.updateLabel.text\")); // NOI18N\n        updateLabel.setToolTipText(org.openide.util.NbBundle.getMessage(ReportFilter.class, \"ReportFilter.updateLabel.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(updateLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addContainerGap())\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jButton1)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(progBar, javax.swing.GroupLayout.DEFAULT_SIZE, 395, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(cancelButton)))\n                        .addGap(24, 24, 24))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(19, 19, 19)\n                .addComponent(jButton1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(cancelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(progBar, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(updateLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n    }","commit_id":"e3d129188f3c27689d614fbdc4083eb288c7acfd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        btnOk = new javax.swing.JButton();\n        jLabel1 = new javax.swing.JLabel();\n        lblVersion = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n\n        setTitle(\"About MAGE\");\n\n        btnOk.setText(\"OK\");\n        btnOk.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnOkActionPerformed(evt);\n            }\n        });\n\n        jLabel1.setText(\"MAGE client\");\n\n        lblVersion.setText(\"0.0.0\");\n\n        jLabel2.setText(\"Courtesy: BetaSteward@googlemail.com. Site: www.magefree.com\");\n\n        jLabel3.setText(\"Devs: BetaSteward, Nantuko84, Eugen.Rivniy, North, maurer.it, Viserion\");\n\n        jLabel4.setText(\"Thanks: i_no_k, soulless, arching.\");\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 353, Short.MAX_VALUE)\n                    .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, 353, Short.MAX_VALUE)\n                    .addComponent(btnOk, javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(lblVersion))\n                    .addComponent(jLabel2))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel1)\n                    .addComponent(lblVersion))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel2)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 28, Short.MAX_VALUE)\n                .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, 28, Short.MAX_VALUE)\n                .addGap(18, 18, 18)\n                .addComponent(btnOk)\n                .addContainerGap())\n        );\n\n        pack();\n    }","id":77052,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        btnOk = new javax.swing.JButton();\n        jLabel1 = new javax.swing.JLabel();\n        lblVersion = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n\n        setTitle(\"About MAGE\");\n\n        btnOk.setText(\"OK\");\n        btnOk.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnOkActionPerformed(evt);\n            }\n        });\n\n        jLabel1.setText(\"MAGE client\");\n\n        lblVersion.setText(\"0.0.0\");\n\n        jLabel2.setText(\"Courtesy: BetaSteward@googlemail.com. Site: www.magefree.com\");\n\n        jLabel3.setText(\"Devs: BetaSteward, Nantuko84, Eugen.Rivniy, North, maurer.it, Rafbill, Alvin. \");\n\n        jLabel4.setText(\"Thanks: i_no_k, soulless, arching, Rahan.\");\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                        .addComponent(jLabel1)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(lblVersion))\n                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(btnOk)\n                    .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel1)\n                    .addComponent(lblVersion))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel2)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jLabel4)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 22, Short.MAX_VALUE)\n                .addComponent(btnOk)\n                .addContainerGap())\n        );\n\n        pack();\n    }","commit_id":"3e0e1e6ecdb671e707af0d87409892fbb51a2796","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n \t    public int compare(User u1, User u2) {\n \t    \treturn u1.getFirstName().compareTo(u2.getFirstName());\n \t    }","id":77053,"modified_method":"@Override\n \t    public int compare(User u1, User u2) {\n \t    \treturn new CompareToBuilder()\n\t\t\t.append(u1.getFirstName(), u2.getFirstName())\n\t\t\t.append(u1.getLastName(), u2.getLastName())\n\t\t\t.toComparison();\n \t    }","commit_id":"e65301e37d7b08c19ab538b713f9aade428112ce","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\t    public int compare(User u1, User u2) {\n\t    \treturn u1.getLastName().compareTo(u2.getLastName());\n\t    }","id":77054,"modified_method":"@Override\n\t    public int compare(User u1, User u2) {\n\t    \treturn new CompareToBuilder()\n\t\t\t.append(u1.getLastName(), u2.getLastName())\n\t\t\t.append(u1.getFirstName(), u2.getFirstName())\n\t\t\t.toComparison();\n\t    }","commit_id":"e65301e37d7b08c19ab538b713f9aade428112ce","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n    public int compareTo(Repository o) {\n      return name.toLowerCase().compareTo(o.name.toLowerCase());\n    }","id":77055,"modified_method":"@Override\n    public int compareTo(Repository o) {\n      return new CompareToBuilder()\n        .append(name.toLowerCase(), o.name.toLowerCase())\n        .append(key, o.key)\n        .toComparison();\n    }","commit_id":"b744cf2b9ce3293a9f84c07ef7b41ea433a9125a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n\t * Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\n\t * or more than one beans are found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * @param clazz\n\t *            bean class\n\t * @param annot\n\t *            the SpringBean annotation\n\t * @throws IllegalStateException\n\t * @return spring name of the bean\n\t */\n\tprivate final String getBeanNameOfClass(final ApplicationContext ctx, final Class<?> clazz,\n\t\tfinal SpringBean annot)\n\t{\n\t\t// get the list of all possible matching beans\n\t\tList<String> names = new ArrayList<String>(\n\t\t\tArrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));\n\n\t\t// filter out beans that are not candidates for autowiring\n\t\tif (ctx instanceof AbstractApplicationContext)\n\t\t{\n\t\t\tIterator<String> it = names.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t{\n\t\t\t\tfinal String possibility = it.next();\n\t\t\t\tBeanDefinition beanDef = getBeanDefinition(\n\t\t\t\t\t((AbstractApplicationContext)ctx).getBeanFactory(), possibility);\n\t\t\t\tif (BeanFactoryUtils.isFactoryDereference(possibility) ||\n\t\t\t\t\tpossibility.startsWith(\"scopedTarget.\") ||\n\t\t\t\t\t(beanDef != null && !beanDef.isAutowireCandidate()))\n\t\t\t\t{\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (names.isEmpty())\n\t\t{\n\t\t\tif (annot.required())\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\telse if (names.size() > 1)\n\t\t{\n\t\t\tif (ctx instanceof AbstractApplicationContext)\n\t\t\t{\n\t\t\t\tList<String> primaries = new ArrayList<String>();\n\t\t\t\tfor (String name : names)\n\t\t\t\t{\n\t\t\t\t\tBeanDefinition beanDef = getBeanDefinition(\n\t\t\t\t\t\t((AbstractApplicationContext)ctx).getBeanFactory(), name);\n\t\t\t\t\tif (beanDef instanceof AbstractBeanDefinition)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (beanDef.isPrimary())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprimaries.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (primaries.size() == 1)\n\t\t\t\t{\n\t\t\t\t\treturn primaries.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\tmsg.append(\"More than one bean of type [\");\n\t\t\tmsg.append(clazz.getName());\n\t\t\tmsg.append(\"] found, you have to specify the name of the bean \");\n\t\t\tmsg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\n\t\t\tmsg.append(\"Matched beans: \");\n\t\t\tmsg.append(Strings.join(\",\", names.toArray(new String[names.size()])));\n\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn names.get(0);\n\t\t}\n\t}","id":77056,"modified_method":"/**\n\t * Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\n\t * or more than one beans are found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * @param clazz\n\t *            bean class\n\t * @param required\n\t *            true if the value is required\n\t * @throws IllegalStateException\n\t * @return spring name of the bean\n\t */\n\tprivate final String getBeanNameOfClass(final ApplicationContext ctx, final Class<?> clazz,\n\t\tfinal boolean required)\n\t{\n\t\t// get the list of all possible matching beans\n\t\tList<String> names = new ArrayList<String>(\n\t\t\tArrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));\n\n\t\t// filter out beans that are not candidates for autowiring\n\t\tif (ctx instanceof AbstractApplicationContext)\n\t\t{\n\t\t\tIterator<String> it = names.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t{\n\t\t\t\tfinal String possibility = it.next();\n\t\t\t\tBeanDefinition beanDef = getBeanDefinition(\n\t\t\t\t\t((AbstractApplicationContext)ctx).getBeanFactory(), possibility);\n\t\t\t\tif (BeanFactoryUtils.isFactoryDereference(possibility) ||\n\t\t\t\t\tpossibility.startsWith(\"scopedTarget.\") ||\n\t\t\t\t\t(beanDef != null && !beanDef.isAutowireCandidate()))\n\t\t\t\t{\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (names.isEmpty())\n\t\t{\n\t\t\tif (required)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\telse if (names.size() > 1)\n\t\t{\n\t\t\tif (ctx instanceof AbstractApplicationContext)\n\t\t\t{\n\t\t\t\tList<String> primaries = new ArrayList<String>();\n\t\t\t\tfor (String name : names)\n\t\t\t\t{\n\t\t\t\t\tBeanDefinition beanDef = getBeanDefinition(\n\t\t\t\t\t\t((AbstractApplicationContext)ctx).getBeanFactory(), name);\n\t\t\t\t\tif (beanDef instanceof AbstractBeanDefinition)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (beanDef.isPrimary())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprimaries.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (primaries.size() == 1)\n\t\t\t\t{\n\t\t\t\t\treturn primaries.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\tmsg.append(\"More than one bean of type [\");\n\t\t\tmsg.append(clazz.getName());\n\t\t\tmsg.append(\"] found, you have to specify the name of the bean \");\n\t\t\tmsg.append(\"(@SpringBean(name=\\\"foo\\\")) or (@Named(\\\"foo\\\") if using @javax.inject classes) in order to resolve this conflict. \");\n\t\t\tmsg.append(\"Matched beans: \");\n\t\t\tmsg.append(Strings.join(\",\", names.toArray(new String[names.size()])));\n\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn names.get(0);\n\t\t}\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @param field\n\t * @return bean name\n\t */\n\tprivate String getBeanName(final Field field)\n\t{\n\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n\n\t\tString name = annot.name();\n\t\tif (Strings.isEmpty(name))\n\t\t{\n\t\t\tname = beanNameCache.get(field.getType());\n\t\t\tif (name == null)\n\t\t\t{\n\t\t\t\tname = getBeanNameOfClass(contextLocator.getSpringContext(), field.getType(), annot);\n\n\t\t\t\tif (name != null)\n\t\t\t\t{\n\t\t\t\t\tbeanNameCache.put(field.getType(), name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn name;\n\t}","id":77057,"modified_method":"/**\n\t * \n\t * @param field\n\t * @return bean name\n\t */\n\tprivate String getBeanName(final Field field)\n\t{\n\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n\t\t\n\t\tString name;\n\t\tboolean required;\n\t\tif (annot != null) {\n\t\t\tname = annot.name();\n\t\t\trequired = annot.required();\n\t\t} else {\n\t\t\tNamed named = field.getAnnotation(Named.class);\n\t\t\tname = named != null ? named.value() : \"\";\n\t\t\trequired = false;\n\t\t}\n\n\t\tif (Strings.isEmpty(name))\n\t\t{\n\t\t\tname = beanNameCache.get(field.getType());\n\t\t\tif (name == null)\n\t\t\t{\n\t\t\t\tname = getBeanNameOfClass(contextLocator.getSpringContext(), field.getType(), required);\n\n\t\t\t\tif (name != null)\n\t\t\t\t{\n\t\t\t\t\tbeanNameCache.put(field.getType(), name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn name;\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.injection.IFieldValueFactory#supportsField(java.lang.reflect.Field)\n\t */\n\tpublic boolean supportsField(final Field field)\n\t{\n\t\treturn field.isAnnotationPresent(SpringBean.class);\n\t}","id":77058,"modified_method":"/**\n\t * @see org.apache.wicket.injection.IFieldValueFactory#supportsField(java.lang.reflect.Field)\n\t */\n\tpublic boolean supportsField(final Field field)\n\t{\n\t\treturn field.isAnnotationPresent(SpringBean.class) || field.isAnnotationPresent(Inject.class);\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic Object getFieldValue(final Field field, final Object fieldOwner)\n\t{\n\t\tObject target = null;\n\n\t\tif (supportsField(field))\n\t\t{\n\t\t\tInject injectAnnotation = field.getAnnotation(Inject.class);\n\t\t\tif (!Modifier.isStatic(field.getModifiers()) && (injectAnnotation != null))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(field.getAnnotations());\n\t\t\t\t\tfinal IProxyTargetLocator locator = new GuiceProxyTargetLocator(field,\n\t\t\t\t\t\tbindingAnnotation, injectAnnotation.optional());\n\n\t\t\t\t\tif (wrapInProxies)\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = locator.locateProxyTarget();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!field.isAccessible())\n\t\t\t\t\t{\n\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tfield.set(fieldOwner, target);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\"Error Guice-injecting field \" +\n\t\t\t\t\t\tfield.getName() + \" in \" + fieldOwner, e);\n\t\t\t\t}\n\t\t\t\tcatch (MoreThanOneBindingException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on field \" + field.getName() +\n\t\t\t\t\t\t\t\" of class \" + fieldOwner.getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}","id":77059,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic Object getFieldValue(final Field field, final Object fieldOwner)\n\t{\n\t\tObject target = null;\n\n\t\tif (supportsField(field))\n\t\t{\n\t\t\tInject injectAnnotation = field.getAnnotation(Inject.class);\n\t\t\tjavax.inject.Inject javaxInjectAnnotation = field.getAnnotation(javax.inject.Inject.class);\n\t\t\tif (!Modifier.isStatic(field.getModifiers()) && (injectAnnotation != null || javaxInjectAnnotation != null))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(field.getAnnotations());\n\t\t\t\t\tfinal IProxyTargetLocator locator = new GuiceProxyTargetLocator(field,\n\t\t\t\t\t\tbindingAnnotation, injectAnnotation != null ? injectAnnotation.optional() : false);\n\n\t\t\t\t\tif (wrapInProxies)\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = locator.locateProxyTarget();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!field.isAccessible())\n\t\t\t\t\t{\n\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tfield.set(fieldOwner, target);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\"Error Guice-injecting field \" +\n\t\t\t\t\t\tfield.getName() + \" in \" + fieldOwner, e);\n\t\t\t\t}\n\t\t\t\tcatch (MoreThanOneBindingException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on field \" + field.getName() +\n\t\t\t\t\t\t\t\" of class \" + fieldOwner.getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic boolean supportsField(final Field field)\n\t{\n\t\treturn field.isAnnotationPresent(Inject.class);\n\t}","id":77060,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic boolean supportsField(final Field field)\n\t{\n\t\treturn field.isAnnotationPresent(Inject.class) || field.isAnnotationPresent(javax.inject.Inject.class);\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * testInjectionAndSerialization()\n\t */\n\t@Test\n\tpublic void testInjectionAndSerialization()\n\t{\n\t\tMockApplication app = new MockApplication();\n\t\tapp.setServletContext(new MockServletContext(app, null));\n\t\ttry\n\t\t{\n\t\t\tThreadContext.setApplication(app);\n\n\t\t\tapp.setName(getClass().getName());\n\t\t\tapp.initApplication();\n\n\t\t\tSession session = new WebSession(new MockWebRequest(Url.parse(\"/\")));\n\t\t\tapp.getSessionStore().bind(null, session);\n\t\t\tThreadContext.setSession(session);\n\n\t\t\tGuiceComponentInjector injector = new GuiceComponentInjector(app, new Module()\n\t\t\t{\n\n\t\t\t\tpublic void configure(final Binder binder)\n\t\t\t\t{\n\t\t\t\t\tbinder.bind(ITestService.class).to(TestService.class);\n\t\t\t\t\tbinder.bind(ITestService.class)\n\t\t\t\t\t\t.annotatedWith(Red.class)\n\t\t\t\t\t\t.to(TestServiceRed.class);\n\t\t\t\t\tbinder.bind(ITestService.class)\n\t\t\t\t\t\t.annotatedWith(Blue.class)\n\t\t\t\t\t\t.to(TestServiceBlue.class);\n\t\t\t\t\tbinder.bind(new TypeLiteral<Map<String, String>>()\n\t\t\t\t\t{\n\t\t\t\t\t}).toProvider(new Provider<Map<String, String>>()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic Map<String, String> get()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMap<String, String> strings = new HashMap<String, String>();\n\n\t\t\t\t\t\t\tstrings.put(ITestService.RESULT, ITestService.RESULT);\n\n\t\t\t\t\t\t\treturn strings;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t});\n\t\t\tapp.getComponentInstantiationListeners().add(injector);\n\n\t\t\t// Create a new component, which should be automatically injected,\n\t\t\t// and test to make sure the injection has worked.\n\t\t\tTestComponent testComponent = new TestComponent(\"id\");\n\t\t\tdoChecksForComponent(testComponent);\n\n\t\t\t// Serialize and deserialize the object, and check it still works.\n\t\t\tTestComponent clonedComponent = (TestComponent)WicketObjects.cloneObject(testComponent);\n\t\t\tdoChecksForComponent(clonedComponent);\n\n\t\t\t// Test injection of a class that does not extend Component\n\t\t\tTestNoComponent noncomponent = new TestNoComponent();\n\t\t\tdoChecksForNoComponent(noncomponent);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tapp.internalDestroy();\n\t\t\tThreadContext.detach();\n\t\t}\n\t}","id":77061,"modified_method":"/**\n\t * testInjectionAndSerialization()\n\t */\n\t@Test\n\tpublic void testInjectionAndSerialization()\n\t{\n\t\tMockApplication app = new MockApplication();\n\t\tapp.setServletContext(new MockServletContext(app, null));\n\t\ttry\n\t\t{\n\t\t\tThreadContext.setApplication(app);\n\n\t\t\tapp.setName(getClass().getName());\n\t\t\tapp.initApplication();\n\n\t\t\tSession session = new WebSession(new MockWebRequest(Url.parse(\"/\")));\n\t\t\tapp.getSessionStore().bind(null, session);\n\t\t\tThreadContext.setSession(session);\n\n\t\t\tGuiceComponentInjector injector = new GuiceComponentInjector(app, new Module()\n\t\t\t{\n\n\t\t\t\tpublic void configure(final Binder binder)\n\t\t\t\t{\n\t\t\t\t\tbinder.bind(ITestService.class).to(TestService.class);\n\t\t\t\t\tbinder.bind(ITestService.class)\n\t\t\t\t\t\t.annotatedWith(Red.class)\n\t\t\t\t\t\t.to(TestServiceRed.class);\n\t\t\t\t\tbinder.bind(ITestService.class)\n\t\t\t\t\t\t.annotatedWith(Blue.class)\n\t\t\t\t\t\t.to(TestServiceBlue.class);\n\t\t\t\t\tbinder.bind(new TypeLiteral<Map<String, String>>()\n\t\t\t\t\t{\n\t\t\t\t\t}).toProvider(new Provider<Map<String, String>>()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic Map<String, String> get()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMap<String, String> strings = new HashMap<String, String>();\n\n\t\t\t\t\t\t\tstrings.put(ITestService.RESULT, ITestService.RESULT);\n\n\t\t\t\t\t\t\treturn strings;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t});\n\t\t\tapp.getComponentInstantiationListeners().add(injector);\n\n\t\t\t// Create a new component, which should be automatically injected,\n\t\t\t// and test to make sure the injection has worked.\n\t\t\tTestComponentInterface testComponent = newTestComponent(\"id\");\n\t\t\tdoChecksForComponent(testComponent);\n\n\t\t\t// Serialize and deserialize the object, and check it still works.\n\t\t\tTestComponentInterface clonedComponent = (TestComponentInterface)WicketObjects.cloneObject(testComponent);\n\t\t\tdoChecksForComponent(clonedComponent);\n\n\t\t\t// Test injection of a class that does not extend Component\n\t\t\tTestNoComponentInterface noncomponent = newTestNoComponent();\n\t\t\tdoChecksForNoComponent(noncomponent);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tapp.internalDestroy();\n\t\t\tThreadContext.detach();\n\t\t}\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"private void doChecksForNoComponent(final TestNoComponent component)\n\t{\n\t\tassertEquals(ITestService.RESULT_RED, component.getString());\n\t}","id":77062,"modified_method":"private void doChecksForNoComponent(final TestNoComponentInterface noncomponent)\n\t{\n\t\tassertEquals(ITestService.RESULT_RED, noncomponent.getString());\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"private void doChecksForComponent(final TestComponent component)\n\t{\n\t\tassertEquals(ITestService.RESULT, component.getInjectedField().getString());\n\t\tassertEquals(null, component.getInjectedOptionalField());\n\t\tassertEquals(ITestService.RESULT_RED, component.getInjectedFieldRed().getString());\n\t\tassertEquals(ITestService.RESULT_BLUE, component.getInjectedFieldBlue().getString());\n\n\t\tassertEquals(ITestService.RESULT, component.getInjectedFieldProvider().get().getString());\n\n\t\tassertEquals(ITestService.RESULT,\n\t\t\tcomponent.getInjectedTypeLiteralField().get(ITestService.RESULT));\n\t}","id":77063,"modified_method":"private void doChecksForComponent(final TestComponentInterface component)\n\t{\n\t\tassertEquals(ITestService.RESULT, component.getInjectedField().getString());\n\t\tassertEquals(null, component.getInjectedOptionalField());\n\t\tassertEquals(ITestService.RESULT_RED, component.getInjectedFieldRed().getString());\n\t\tassertEquals(ITestService.RESULT_BLUE, component.getInjectedFieldBlue().getString());\n\n\t\tassertEquals(ITestService.RESULT, component.getInjectedFieldProvider().get().getString());\n\n\t\tassertEquals(ITestService.RESULT,\n\t\t\tcomponent.getInjectedTypeLiteralField().get(ITestService.RESULT));\n\t}","commit_id":"6e78fcd80a4c05796cf75fe856f6447ef763c03c","url":"https://github.com/apache/wicket"},{"original_method":"private String[] splitDef(final String definition) {\n\t\treturn definition.split(\"(?<!\\\\\\\\):\");\n\t}","id":77064,"modified_method":"private String[] splitDef(final String definition) {\n\t\t// log().debug(\"splitDef(\" + definition + \")\");\n\t\tfinal String[] def;\n\t\tif (File.separatorChar == '\\\\') {\n\t\t\t// log().debug(\"windows\");\n\t\t\t// Windows, make sure the beginning isn't eg: C:\\\\foo\\\\bar\n\t\t\tif (definition.matches(\"[^=]*=[a-zA-Z]:.*\")) {\n\t\t\t\tfinal String[] tempDef = definition.split(\"(?<!\\\\\\\\):\");\n\t\t\t\tdef = new String[tempDef.length - 1];\n\t\t\t\tdef[0] = tempDef[0] + ':' + tempDef[1];\n\t\t\t\tif (tempDef.length > 2) {\n\t\t\t\t\tfor (int i = 2; i < tempDef.length; i++) {\n\t\t\t\t\t\tdef[i-1] = tempDef[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// log().debug(\"no match\");\n\t\t\t\tdef = definition.split(\"(?<!\\\\\\\\):\");\n\t\t\t}\n\t\t} else {\n\t\t\tdef = definition.split(\"(?<!\\\\\\\\):\");\n\t\t}\n\t\t// log().debug(\"returning: \" + Arrays.toString(def));\n\t\treturn def;\n\t}","commit_id":"089c30817adcbfbcb726c7e47a17f1538b496577","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>createGraphDef<\/p>\n     *\n     * @param workDir a {@link java.io.File} object.\n     * @param commandArray an array of {@link java.lang.String} objects.\n     * @return a {@link org.jrobin.graph.RrdGraphDef} object.\n     * @throws org.jrobin.core.RrdException if any.\n     */\n    protected RrdGraphDef createGraphDef(final File workDir, final String[] inputArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        Map<String,List<String>> defs = new LinkedHashMap<String,List<String>>();\n        // Map<String,List<String>> cdefs = new HashMap<String,List<String>>();\n        \n        final String[] commandArray;\n        if (inputArray[0].contains(\"rrdtool\") && inputArray[1].equals(\"graph\") && inputArray[2].equals(\"-\")) {\n        \tcommandArray = Arrays.copyOfRange(inputArray, 3, inputArray.length);\n        } else {\n        \tcommandArray = inputArray;\n        }\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+width);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+width);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = splitDef(definition);\n                String[] ds = def[0].split(\"=\");\n                File dsFile = new File(workDir, ds[1].replace(\"\\\\\", \"\"));\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n                List<String> defBits = new ArrayList<String>();\n                defBits.add(dsFile.getAbsolutePath());\n                defBits.add(def[1]);\n                defBits.add(def[2]);\n                defs.put(ds[0], defBits);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n                List<String> cdefBits = new ArrayList<String>();\n                cdefBits.add(cdef[1]);\n                defs.put(cdef[0], cdefBits);\n            } else if (arg.startsWith(\"VDEF:\")) {\n                String definition = arg.substring(\"VDEF:\".length());\n                String[] vdef = tokenize(definition, \"=\", true);\n                String[] expressionTokens = tokenize(vdef[1], \",\", false);\n                addVdefDs(graphDef, vdef[0], expressionTokens, start, end, defs);\n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n\n            } else if (arg.endsWith(\"/rrdtool\") || arg.equals(\"graph\") || arg.equals(\"-\")) {\n            \t// ignore, this is just a leftover from the rrdtool-specific options\n\n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","id":77065,"modified_method":"/**\n     * <p>createGraphDef<\/p>\n     *\n     * @param workDir a {@link java.io.File} object.\n     * @param commandArray an array of {@link java.lang.String} objects.\n     * @return a {@link org.jrobin.graph.RrdGraphDef} object.\n     * @throws org.jrobin.core.RrdException if any.\n     */\n    protected RrdGraphDef createGraphDef(final File workDir, final String[] inputArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        Map<String,List<String>> defs = new LinkedHashMap<String,List<String>>();\n        // Map<String,List<String>> cdefs = new HashMap<String,List<String>>();\n        \n        final String[] commandArray;\n        if (inputArray[0].contains(\"rrdtool\") && inputArray[1].equals(\"graph\") && inputArray[2].equals(\"-\")) {\n        \tcommandArray = Arrays.copyOfRange(inputArray, 3, inputArray.length);\n        } else {\n        \tcommandArray = inputArray;\n        }\n        \n        log().debug(\"command array = \" + Arrays.toString(commandArray));\n\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+width);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+width);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = splitDef(definition);\n                String[] ds = def[0].split(\"=\");\n                // log().debug(\"ds = \" + Arrays.toString(ds));\n                final String replaced = ds[1].replaceAll(\"\\\\\\\\(.)\", \"$1\");\n                // log().debug(\"replaced = \" + replaced);\n                \n                final File dsFile;\n                File rawPathFile = new File(replaced);\n                if (rawPathFile.isAbsolute()) {\n                \tdsFile = rawPathFile;\n                } else {\n                \tdsFile = new File(workDir, replaced);\n                }\n                // log().debug(\"dsFile = \" + dsFile + \", ds[1] = \" + ds[1]);\n                \n                final String absolutePath = (File.separatorChar == '\\\\')? dsFile.getAbsolutePath().replace(\"\\\\\", \"\\\\\\\\\") : dsFile.getAbsolutePath();\n                // log().debug(\"absolutePath = \" + absolutePath);\n                graphDef.datasource(ds[0], absolutePath, def[1], def[2]);\n\n                List<String> defBits = new ArrayList<String>();\n                defBits.add(absolutePath);\n                defBits.add(def[1]);\n                defBits.add(def[2]);\n                defs.put(ds[0], defBits);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n                List<String> cdefBits = new ArrayList<String>();\n                cdefBits.add(cdef[1]);\n                defs.put(cdef[0], cdefBits);\n            } else if (arg.startsWith(\"VDEF:\")) {\n                String definition = arg.substring(\"VDEF:\".length());\n                String[] vdef = tokenize(definition, \"=\", true);\n                String[] expressionTokens = tokenize(vdef[1], \",\", false);\n                addVdefDs(graphDef, vdef[0], expressionTokens, start, end, defs);\n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n\n            } else if (arg.endsWith(\"/rrdtool\") || arg.equals(\"graph\") || arg.equals(\"-\")) {\n            \t// ignore, this is just a leftover from the rrdtool-specific options\n\n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","commit_id":"089c30817adcbfbcb726c7e47a17f1538b496577","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDefWithEscapedCharacters() throws Exception {\n        long end = System.currentTimeMillis() / 1000;\n        long start = end - (24 * 60 * 60);\n        final String[] command = new String[] {\n                \"--start=\" + (start - 300),\n                \"--end=\" + (end + 300),\n                \"DEF:baz=response/fe80\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\%5/dns.jrb:bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n\n        Throwable t = null;\n        try {\n        \t((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        } catch (final org.jrobin.core.RrdException e) {\n        \tt = e;\n        }\n        assertNotNull(t);\n    \tassertTrue(t.getMessage().contains(\"Could not open /response/fe80:0000:0000:0000:0000:0000:0000:0000%5/dns.jrb\"));\n    }","id":77066,"modified_method":"@Test\n    public void testDefWithEscapedCharacters() throws Exception {\n        long end = System.currentTimeMillis() / 1000;\n        long start = end - (24 * 60 * 60);\n        final String[] command = new String[] {\n                \"--start=\" + (start - 300),\n                \"--end=\" + (end + 300),\n                \"DEF:baz=response/fe80\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\%5/dns.jrb:bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n\n        Throwable t = null;\n        try {\n        \t((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        } catch (final org.jrobin.core.RrdException e) {\n        \tt = e;\n        }\n        assertNotNull(t);\n        \n    \tassertTrue(\"message was \" + t.getMessage(), t.getMessage().contains(\"Could not open \"));\n    \tassertTrue(\"message was \" + t.getMessage(), t.getMessage().contains(\"fe80:0000:0000:0000:0000:0000:0000:0000%5\"));\n    }","commit_id":"089c30817adcbfbcb726c7e47a17f1538b496577","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        // Make sure that AWT headless mode is enabled\n        System.setProperty(\"java.awt.headless\", \"true\");\n        \n        MockLogAppender.setupLogging();\n        \n        m_strategy = new JRobinRrdStrategy();\n\n        // Don't initialize by default since not all tests need it.\n        m_fileAnticipator = new FileAnticipator(false);\n    }","id":77067,"modified_method":"@Before\n    public void setUp() throws Exception {\n        // Make sure that AWT headless mode is enabled\n        System.setProperty(\"java.awt.headless\", \"true\");\n        \n        MockLogAppender.setupLogging(true, \"DEBUG\");\n        \n        m_strategy = new JRobinRrdStrategy();\n\n        // Don't initialize by default since not all tests need it.\n        m_fileAnticipator = new FileAnticipator(false);\n    }","commit_id":"089c30817adcbfbcb726c7e47a17f1538b496577","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSampleVDEFPercentile() throws Exception {\n        Double[] vals = {\n                39.0, 94.0, 95.0, 101.0, 155.0, 262.0, 274.0, 302.0, 319.0, 402.0, 466.0, 468.0, 494.0, 549.0, 550.0, 575.0, 600.0, 615.0, 625.0, 703.0, 729.0, 824.0, 976.0, 1018.0, 1036.0, 1138.0, 1195.0, 1265.0, 1287.0, 1323.0, 1410.0, 1443.0, 1516.0, 1538.0, 1664.0, 1686.0, 1801.0, 1912.0, 1921.0, 1929.0, 1936.0, 1941.0, 1985.0, 2003.0, 2010.0, 2013.0, 2082.0, 2106.0, 2213.0, 2358.0, 2394.0, 2572.0, 2616.0, 2627.0, 2676.0, 2694.0, 2736.0, 2740.0, 2966.0, 3005.0, 3037.0, 3041.0, 3146.0, 3194.0, 3228.0, 3235.0, 3243.0, 3339.0, 3365.0, 3414.0, 3440.0, 3454.0, 3567.0, 3570.0, 3615.0, 3619.0, 3802.0, 3831.0, 3864.0, 4061.0, 4084.0, 4106.0, 4233.0, 4328.0, 4362.0, 4372.0, 4376.0, 4388.0, 4413.0, 4527.0, 4612.0, 4643.0, 4684.0, 4750.0, 4799.0, 4810.0, 4824.0, 4825.0, 4871.0, 4932.0, 5028.0, 5112.0, 5118.0, 5163.0, 5198.0, 5256.0, 5296.0, 5413.0, 5471.0, 5568.0, 5628.0, 5645.0, 5733.0, 5790.0, 5851.0, 5886.0, 5927.0, 5937.0, 6018.0, 6027.0, 6046.0, 6145.0, 6147.0, 6289.0, 6371.0, 6384.0, 6393.0, 6431.0, 6469.0, 6543.0, 6649.0, 6772.0, 6864.0, 6943.0, 7009.0, 7014.0, 7037.0, 7258.0, 7356.0, 7364.0, 7386.0, 7387.0, 7399.0, 7450.0, 7519.0, 7527.0, 7578.0, 7632.0, 7709.0, 7849.0, 7896.0, 7952.0, 7980.0, 8050.0, 8126.0, 8152.0, 8165.0, 8332.0, 8347.0, 8520.0, 8522.0, 8542.0, 8587.0, 8621.0, 8678.0, 8721.0, 8739.0, 8765.0, 8889.0, 8951.0, 8962.0, 9082.0, 9149.0, 9199.0, 9278.0, 9334.0, 9339.0, 9345.0, 9365.0, 9383.0, 9402.0, 9471.0, 9483.0, 9492.0, 9496.0, 9532.0, 9553.0, 9563.0, 9571.0, 9574.0, 100000.0, 120000.0, 150000.0, 200000.0, 500000.0, 1000000.0, 2000000.0, 4000000.0, 8000000.0, 16000000.0\n        };\n        File rrdFile = createRrdFile();\n        RrdDb openedFile = m_strategy.openFile(rrdFile.getAbsolutePath());\n        \n        // This file's step size is 300\n        int endTime = (int)(System.currentTimeMillis() / 1000);\n        endTime -= (endTime % 300);\n        int startTime = endTime - (200 * 300);\n        \n        // Got to throw away the first sample\n        m_strategy.updateFile(openedFile, \"huh?\", (startTime - 300) + \":\" + \"0.0\");\n\n        int sampleTime = startTime;\n        for (double val : vals) {\n            m_strategy.updateFile(openedFile, \"huh?\", sampleTime + \":\" + val);\n            sampleTime += 300;\n        }\n        m_strategy.closeFile(openedFile);\n        \n        String[] command;\n        RrdGraphDef graphDef;\n        RrdGraph graph;\n        RrdGraphInfo info;\n        String[] printLines;\n        \n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath() + \":bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - DEF\", printLines);\n        assertEquals(\"graph printLines - DEF size\", 5, printLines.length);\n        assertEquals(\"graph printLines - DEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - DEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - DEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - DEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - DEF item 4\", \"9.574000e+03\", printLines[4]);\n\n        // Now do it with a CDEF\n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath() + \":bar:AVERAGE\",\n                \"CDEF:bazX1=baz,1,*\",\n                \"CDEF:bazX1P0=bazX1,0,+\",\n                \"VDEF:avg=bazX1,AVERAGE\",\n                \"VDEF:min=bazX1,MIN\",\n                \"VDEF:max=bazX1,MAX\",\n                \"VDEF:tot=bazX1,TOTAL\",\n                \"VDEF:nfp=bazX1,95,PERCENT\",\n                \"VDEF:nfp2=bazX1P0,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp2:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - CDEF\", printLines);\n        assertEquals(\"graph printLines - CDEF size\", 6, printLines.length);\n        assertEquals(\"graph printLines - CDEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - CDEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - CDEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - CDEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - CDEF item 4\", \"9.574000e+03\", printLines[4]);\n        assertEquals(\"graph printLines - CDEF item 5\", \"9.574000e+03\", printLines[5]);\n        \n    }","id":77068,"modified_method":"@Test\n    public void testSampleVDEFPercentile() throws Exception {\n        Double[] vals = {\n                39.0, 94.0, 95.0, 101.0, 155.0, 262.0, 274.0, 302.0, 319.0, 402.0, 466.0, 468.0, 494.0, 549.0, 550.0, 575.0, 600.0, 615.0, 625.0, 703.0, 729.0, 824.0, 976.0, 1018.0, 1036.0, 1138.0, 1195.0, 1265.0, 1287.0, 1323.0, 1410.0, 1443.0, 1516.0, 1538.0, 1664.0, 1686.0, 1801.0, 1912.0, 1921.0, 1929.0, 1936.0, 1941.0, 1985.0, 2003.0, 2010.0, 2013.0, 2082.0, 2106.0, 2213.0, 2358.0, 2394.0, 2572.0, 2616.0, 2627.0, 2676.0, 2694.0, 2736.0, 2740.0, 2966.0, 3005.0, 3037.0, 3041.0, 3146.0, 3194.0, 3228.0, 3235.0, 3243.0, 3339.0, 3365.0, 3414.0, 3440.0, 3454.0, 3567.0, 3570.0, 3615.0, 3619.0, 3802.0, 3831.0, 3864.0, 4061.0, 4084.0, 4106.0, 4233.0, 4328.0, 4362.0, 4372.0, 4376.0, 4388.0, 4413.0, 4527.0, 4612.0, 4643.0, 4684.0, 4750.0, 4799.0, 4810.0, 4824.0, 4825.0, 4871.0, 4932.0, 5028.0, 5112.0, 5118.0, 5163.0, 5198.0, 5256.0, 5296.0, 5413.0, 5471.0, 5568.0, 5628.0, 5645.0, 5733.0, 5790.0, 5851.0, 5886.0, 5927.0, 5937.0, 6018.0, 6027.0, 6046.0, 6145.0, 6147.0, 6289.0, 6371.0, 6384.0, 6393.0, 6431.0, 6469.0, 6543.0, 6649.0, 6772.0, 6864.0, 6943.0, 7009.0, 7014.0, 7037.0, 7258.0, 7356.0, 7364.0, 7386.0, 7387.0, 7399.0, 7450.0, 7519.0, 7527.0, 7578.0, 7632.0, 7709.0, 7849.0, 7896.0, 7952.0, 7980.0, 8050.0, 8126.0, 8152.0, 8165.0, 8332.0, 8347.0, 8520.0, 8522.0, 8542.0, 8587.0, 8621.0, 8678.0, 8721.0, 8739.0, 8765.0, 8889.0, 8951.0, 8962.0, 9082.0, 9149.0, 9199.0, 9278.0, 9334.0, 9339.0, 9345.0, 9365.0, 9383.0, 9402.0, 9471.0, 9483.0, 9492.0, 9496.0, 9532.0, 9553.0, 9563.0, 9571.0, 9574.0, 100000.0, 120000.0, 150000.0, 200000.0, 500000.0, 1000000.0, 2000000.0, 4000000.0, 8000000.0, 16000000.0\n        };\n        File rrdFile = createRrdFile();\n        RrdDb openedFile = m_strategy.openFile(rrdFile.getAbsolutePath());\n        \n        // This file's step size is 300\n        int endTime = (int)(System.currentTimeMillis() / 1000);\n        endTime -= (endTime % 300);\n        int startTime = endTime - (200 * 300);\n        \n        // Got to throw away the first sample\n        m_strategy.updateFile(openedFile, \"huh?\", (startTime - 300) + \":\" + \"0.0\");\n\n        int sampleTime = startTime;\n        for (double val : vals) {\n            m_strategy.updateFile(openedFile, \"huh?\", sampleTime + \":\" + val);\n            sampleTime += 300;\n        }\n        m_strategy.closeFile(openedFile);\n        \n        String[] command;\n        RrdGraphDef graphDef;\n        RrdGraph graph;\n        RrdGraphInfo info;\n        String[] printLines;\n        \n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath().replace(\"\\\\\", \"\\\\\\\\\") + \":bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - DEF\", printLines);\n        assertEquals(\"graph printLines - DEF size\", 5, printLines.length);\n        assertEquals(\"graph printLines - DEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - DEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - DEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - DEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - DEF item 4\", \"9.574000e+03\", printLines[4]);\n\n        // Now do it with a CDEF\n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath().replace(\"\\\\\", \"\\\\\\\\\") + \":bar:AVERAGE\",\n                \"CDEF:bazX1=baz,1,*\",\n                \"CDEF:bazX1P0=bazX1,0,+\",\n                \"VDEF:avg=bazX1,AVERAGE\",\n                \"VDEF:min=bazX1,MIN\",\n                \"VDEF:max=bazX1,MAX\",\n                \"VDEF:tot=bazX1,TOTAL\",\n                \"VDEF:nfp=bazX1,95,PERCENT\",\n                \"VDEF:nfp2=bazX1P0,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp2:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - CDEF\", printLines);\n        assertEquals(\"graph printLines - CDEF size\", 6, printLines.length);\n        assertEquals(\"graph printLines - CDEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - CDEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - CDEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - CDEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - CDEF item 4\", \"9.574000e+03\", printLines[4]);\n        assertEquals(\"graph printLines - CDEF item 5\", \"9.574000e+03\", printLines[5]);\n        \n    }","commit_id":"089c30817adcbfbcb726c7e47a17f1538b496577","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static ConcurrentHashMap<String, String> table(final Iterator<String> li) {\r\n    \tString line;\r\n    \tfinal ConcurrentHashMap<String, String> props = new ConcurrentHashMap<String, String>();\r\n    \twhile (li.hasNext()) {\r\n        \tint pos = 0;\r\n    \t\tline = li.next().trim();\r\n    \t\tif (line.length() > 0 && line.charAt(0) == '#') continue; // exclude comments\r\n    \t\tdo {\r\n    \t\t\t// search for unescaped =\r\n    \t\t\tpos = line.indexOf('=', pos+1);\r\n    \t\t} while ( pos > 0 && line.charAt(pos-1) == '\\\\');\r\n    \t\tif (pos > 0) {\r\n    \t\t    //String key = escaped_equal.matcher(line.substring(0, pos).trim()).replaceAll(\"=\");\r\n    \t\t\tfinal String key = line.substring(0, pos).trim().replace(\"\\\\=\", \"=\").replace(\"\\\\n\", \"\\n\").replace(\"\\\\\", \"\\\\\");\r\n    \t\t\tfinal String value = line.substring(pos + 1).trim().replace(\"\\\\n\", \"\\n\").replace(\"\\\\\\\\\", \"\\\\\");\r\n        \t\tprops.put(key, value);\r\n    \t\t}\r\n    \t}\r\n    \treturn props;\r\n\t}","id":77069,"modified_method":"public static ConcurrentHashMap<String, String> table(final Iterator<String> li) {\r\n        String line;\r\n        final ConcurrentHashMap<String, String> props = new ConcurrentHashMap<String, String>();\r\n        while (li.hasNext()) {\r\n            int pos = 0;\r\n            line = li.next().trim();\r\n            if (line.length() > 0 && line.charAt(0) == '#') continue; // exclude comments\r\n            do {\r\n                // search for unescaped =\r\n                pos = line.indexOf('=', pos + 1);\r\n            } while ( pos > 0 && line.charAt(pos - 1) == '\\\\');\r\n            if (pos > 0) {\r\n                String key = escaped_equal.matcher(line.substring(0, pos).trim()).replaceAll(\"=\");\r\n                key = escaped_newline.matcher(key).replaceAll(\"\\n\");\r\n                key = escaped_backslash.matcher(key).replaceAll(\"\\\\\");\r\n                String value = escaped_newline.matcher(line.substring(pos + 1).trim()).replaceAll(\"\\n\");\r\n                value = value.replace(\"\\\\\\\\\", \"\\\\\"); // does not work: escaped_backslashbackslash.matcher(value).replaceAll(\"\\\\\");\r\n                props.put(key, value);\r\n            }\r\n        }\r\n        return props;\r\n    }","commit_id":"eb9c9edb01a7bb0c70421cf9970029168b7fe021","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n    * Starts up the whole application. Sets up all datastructures and starts\r\n    * the main threads.\r\n    *\r\n    * @param homePath Root-path where all information is to be found.\r\n    * @param startupFree free memory at startup time, to be used later for statistics\r\n    */\r\n    private static void startup(final File dataHome, final File appHome, final long startupMemFree, final long startupMemTotal, final boolean gui) {\r\n        try {\r\n            // start up\r\n            System.out.println(copyright);\r\n            System.out.println(hline);\r\n\r\n            // check java version\r\n            try {\r\n                \"a\".codePointAt(0); // needs at least Java 1.5\r\n            } catch (final NoSuchMethodError e) {\r\n                System.err.println(\"STARTUP: Java Version too low. You need at least Java 1.5 to run YaCy\"); // TODO: is 1.6 now\r\n                Thread.sleep(3000);\r\n                System.exit(-1);\r\n            }\r\n\r\n            // ensure that there is a DATA directory, if not, create one and if that fails warn and die\r\n            mkdirsIfNeseccary(dataHome);\r\n            mkdirsIfNeseccary(appHome);\r\n            File f = new File(dataHome, \"DATA/\");\r\n            mkdirsIfNeseccary(f);\r\n\t\t\tif (!(f.exists())) {\r\n\t\t\t\tSystem.err.println(\"Error creating DATA-directory in \" + dataHome.toString() + \" . Please check your write-permission for this folder. YaCy will now terminate.\");\r\n\t\t\t\tSystem.exit(-1);\r\n\t\t\t}\r\n\r\n            // setting up logging\r\n\t\t\tf = new File(dataHome, \"DATA/LOG/\");\r\n            mkdirsIfNeseccary(f);\r\n\t\t\tf = new File(dataHome, \"DATA/LOG/yacy.logging\");\r\n\t\t\tfinal File f0 = new File(appHome, \"yacy.logging\");\r\n\t\t\tif (!f.exists() || f0.lastModified() > f.lastModified()) try {\r\n\t\t\t    FileUtils.copy(f0, f);\r\n            } catch (final IOException e){\r\n                System.out.println(\"could not copy yacy.logging\");\r\n            }\r\n            try{\r\n                Log.configureLogging(dataHome, appHome, new File(dataHome, \"DATA/LOG/yacy.logging\"));\r\n            } catch (final IOException e) {\r\n                System.out.println(\"could not find logging properties in homePath=\" + dataHome);\r\n                Log.logException(e);\r\n            }\r\n            Log.logConfig(\"STARTUP\", \"YaCy version: \" + yacyBuildProperties.getVersion() + \"/\" + yacyBuildProperties.getSVNRevision());\r\n            Log.logConfig(\"STARTUP\", \"Java version: \" + System.getProperty(\"java.version\", \"no-java-version\"));\r\n            Log.logConfig(\"STARTUP\", \"Operation system: \" + System.getProperty(\"os.name\",\"unknown\"));\r\n            Log.logConfig(\"STARTUP\", \"Application root-path: \" + appHome);\r\n            Log.logConfig(\"STARTUP\", \"Data root-path: \" + dataHome);\r\n            Log.logConfig(\"STARTUP\", \"Time zone: UTC\" + GenericFormatter.UTCDiffString() + \"; UTC+0000 is \" + System.currentTimeMillis());\r\n            Log.logConfig(\"STARTUP\", \"Maximum file system path length: \" + OS.maxPathLength);\r\n\r\n            f = new File(dataHome, \"DATA/yacy.running\");\r\n            if (f.exists()) {                // another instance running? VM crash? User will have to care about this\r\n                Log.logSevere(\"STARTUP\", \"WARNING: the file \" + f + \" exists, this usually means that a YaCy instance is still running\");\r\n                delete(f);\r\n            }\r\n            if(!f.createNewFile())\r\n                Log.logSevere(\"STARTUP\", \"WARNING: the file \" + f + \" can not be created!\");\r\n            try { new FileOutputStream(f).write(Integer.toString(OS.getPID()).getBytes()); } catch (final Exception e) { } // write PID\r\n            f.deleteOnExit();\r\n\r\n            final String oldconf = \"DATA/SETTINGS/httpProxy.conf\".replace(\"/\", File.separator);\r\n            final String newconf = \"DATA/SETTINGS/yacy.conf\".replace(\"/\", File.separator);\r\n            final File oldconffile = new File(dataHome, oldconf);\r\n            if (oldconffile.exists()) {\r\n            \tfinal File newconfFile = new File(dataHome, newconf);\r\n                if(!oldconffile.renameTo(newconfFile))\r\n                    Log.logSevere(\"STARTUP\", \"WARNING: the file \" + oldconffile + \" can not be renamed to \"+ newconfFile +\"!\");\r\n            }\r\n            try {\r\n                sb = new Switchboard(dataHome, appHome, \"defaults/yacy.init\".replace(\"/\", File.separator), newconf);\r\n            } catch (final RuntimeException e) {\r\n                Log.logSevere(\"STARTUP\", \"YaCy cannot start: \" + e.getMessage());\r\n                System.exit(-1);\r\n            }\r\n            //sbSync.V(); // signal that the sb reference was set\r\n\r\n            // switch the memory strategy\r\n            MemoryControl.setStandardStrategy(sb.getConfigBool(\"memory.standardStrategy\", true));\r\n\r\n            // save information about available memory at startup time\r\n            sb.setConfig(\"memoryFreeAfterStartup\", startupMemFree);\r\n            sb.setConfig(\"memoryTotalAfterStartup\", startupMemTotal);\r\n\r\n            // start gui if wanted\r\n            if (gui) YaCyApp.start(\"localhost\", (int) sb.getConfigLong(\"port\", 8090));\r\n\r\n            // hardcoded, forced, temporary value-migration\r\n            sb.setConfig(\"htTemplatePath\", \"htroot/env/templates\");\r\n\r\n            int oldRev;\r\n    \t    try {\r\n                oldRev = Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            } catch (final NumberFormatException e) {\r\n                oldRev = 0;\r\n    \t    }\r\n            final int newRev = Integer.parseInt(yacyBuildProperties.getSVNRevision());\r\n            sb.setConfig(\"svnRevision\", yacyBuildProperties.getSVNRevision());\r\n            sb.setConfig(\"applicationRoot\", appHome.toString());\r\n            sb.setConfig(\"dataRoot\", dataHome.toString());\r\n            yacyVersion.latestRelease = version;\r\n\r\n            // read environment\r\n            final int timeout = Math.max(5000, Integer.parseInt(sb.getConfig(\"httpdTimeout\", \"5000\")));\r\n\r\n            // create some directories\r\n            final File htRootPath = new File(appHome, sb.getConfig(\"htRootPath\", \"htroot\"));\r\n            final File htDocsPath = sb.getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT);\r\n            mkdirIfNeseccary(htDocsPath);\r\n            //final File htTemplatePath = new File(homePath, sb.getConfig(\"htTemplatePath\",\"htdocs\"));\r\n\r\n            // create default notifier picture\r\n            //TODO: Use templates instead of copying images ...\r\n            if (!((new File(htDocsPath, \"notifier.gif\")).exists())) try {\r\n                FileUtils.copy(new File(htRootPath, \"env/grafics/empty.gif\"),\r\n                                     new File(htDocsPath, \"notifier.gif\"));\r\n            } catch (final IOException e) {}\r\n\r\n            final File htdocsReadme = new File(htDocsPath, \"readme.txt\");\r\n            if (!(htdocsReadme.exists())) try {FileUtils.copy((\r\n                    \"This is your root directory for individual Web Content\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Please place your html files into the www subdirectory.\\r\\n\" +\r\n                    \"The URL of that path is either\\r\\n\" +\r\n                    \"http://www.<your-peer-name>.yacy    or\\r\\n\" +\r\n                    \"http://<your-ip>:<your-port>/www\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Other subdirectories may be created; they map to corresponding sub-domains.\\r\\n\" +\r\n                    \"This directory shares it's content with the applications htroot path, so you\\r\\n\" +\r\n                    \"may access your yacy search page with\\r\\n\" +\r\n                    \"http://<your-peer-name>.yacy/\\r\\n\" +\r\n                    \"\\r\\n\").getBytes(), htdocsReadme);} catch (final IOException e) {\r\n                        System.out.println(\"Error creating htdocs readme: \" + e.getMessage());\r\n                    }\r\n\r\n            final File wwwDefaultPath = new File(htDocsPath, \"www\");\r\n            mkdirIfNeseccary(wwwDefaultPath);\r\n\r\n\r\n            final File shareDefaultPath = new File(htDocsPath, \"share\");\r\n            mkdirIfNeseccary(shareDefaultPath);\r\n\r\n            migration.migrate(sb, oldRev, newRev);\r\n\r\n            // delete old release files\r\n            final int deleteOldDownloadsAfterDays = (int) sb.getConfigLong(\"update.deleteOld\", 30);\r\n            yacyRelease.deleteOldDownloads(sb.releasePath, deleteOldDownloadsAfterDays );\r\n\r\n            // set user-agent\r\n            HTTPClient.setDefaultUserAgent(ClientIdentification.getUserAgent());\r\n\r\n            // start main threads\r\n            final String port = sb.getConfig(\"port\", \"8090\");\r\n            try {\r\n                final HTTPDemon protocolHandler = new HTTPDemon(sb);\r\n                final serverCore server = new serverCore(\r\n                        timeout /*control socket timeout in milliseconds*/,\r\n                        true /* block attacks (wrong protocol) */,\r\n                        protocolHandler /*command class*/,\r\n                        sb,\r\n                        30000 /*command max length incl. GET args*/);\r\n                server.setName(\"httpd:\"+port);\r\n                server.setPriority(Thread.MAX_PRIORITY);\r\n                server.setObeyIntermission(false);\r\n\r\n                // start the server\r\n                sb.deployThread(\"10_httpd\", \"HTTPD Server/Proxy\", \"the HTTPD, used as web server and proxy\", null, server, 0, 0, 0, 0);\r\n                //server.start();\r\n\r\n                // open the browser window\r\n                final boolean browserPopUpTrigger = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_TRIGGER, \"true\").equals(\"true\");\r\n                if (browserPopUpTrigger) try {\r\n                    final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n                    //boolean properPW = (sb.getConfig(\"adminAccount\", \"\").length() == 0) && (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0);\r\n                    //if (!properPW) browserPopUpPage = \"ConfigBasic.html\";\r\n                    Browser.openBrowser((server.withSSL()?\"https\":\"http\") + \"://localhost:\" + serverCore.getPortNr(port) + \"/\" + browserPopUpPage);\r\n                } catch (final RuntimeException e) {\r\n                    // cannot open browser. This may be normal in headless environments\r\n                    //Log.logException(e);\r\n                }\r\n\r\n                // unlock yacyTray browser popup\r\n                Tray.lockBrowserPopup = false;\r\n\r\n                // Copy the shipped locales into DATA, existing files are overwritten\r\n                final File locale_work   = sb.getDataPath(\"locale.work\", \"DATA/LOCALE/locales\");\r\n                final File locale_source = sb.getAppPath(\"locale.source\", \"locales\");\r\n                try{\r\n                    final File[] locale_source_files = locale_source.listFiles();\r\n                    mkdirsIfNeseccary(locale_work);\r\n                    File target;\r\n                    for (final File locale_source_file : locale_source_files) {\r\n                    \ttarget = new File(locale_work, locale_source_file.getName());\r\n                        if (locale_source_file.getName().endsWith(\".lng\")) {\r\n                        \tif (target.exists()) delete(target);\r\n                            FileUtils.copy(locale_source_file, target);\r\n                        }\r\n                    }\r\n                    Log.logInfo(\"STARTUP\", \"Copied the default locales to \" + locale_work.toString());\r\n                }catch(final NullPointerException e){\r\n                    Log.logSevere(\"STARTUP\", \"Nullpointer Exception while copying the default Locales\");\r\n                }\r\n\r\n                //regenerate Locales from Translationlist, if needed\r\n                final String lang = sb.getConfig(\"locale.language\", \"\");\r\n                if (!lang.equals(\"\") && !lang.equals(\"default\")) { //locale is used\r\n                    String currentRev = \"\";\r\n                    try{\r\n                        final BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(sb.getDataPath(\"locale.translated_html\", \"DATA/LOCALE/htroot\"), lang+\"/version\" ))));\r\n                        currentRev = br.readLine();\r\n                        br.close();\r\n                    }catch(final IOException e){\r\n                        //Error\r\n                    }\r\n\r\n                    if (!currentRev.equals(sb.getConfig(\"svnRevision\", \"\"))) try { //is this another version?!\r\n                        final File sourceDir = new File(sb.getConfig(\"htRootPath\", \"htroot\"));\r\n                        final File destDir = new File(sb.getDataPath(\"locale.translated_html\", \"DATA/LOCALE/htroot\"), lang);\r\n                        if (Translator.translateFilesRecursive(sourceDir, destDir, new File(locale_work, lang + \".lng\"), \"html,template,inc\", \"locale\")){ //translate it\r\n                            //write the new Versionnumber\r\n                            final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(new File(destDir, \"version\"))));\r\n                            bw.write(sb.getConfig(\"svnRevision\", \"Error getting Version\"));\r\n                            bw.close();\r\n                        }\r\n                    } catch (final IOException e) {}\r\n                }\r\n                // initialize number formatter with this locale\r\n                Formatter.setLocale(lang);\r\n\r\n                // registering shutdown hook\r\n                Log.logConfig(\"STARTUP\", \"Registering Shutdown Hook\");\r\n                final Runtime run = Runtime.getRuntime();\r\n                run.addShutdownHook(new shutdownHookThread(Thread.currentThread(), sb));\r\n\r\n                // save information about available memory after all initializations\r\n                //try {\r\n                    sb.setConfig(\"memoryFreeAfterInitBGC\", MemoryControl.free());\r\n                    sb.setConfig(\"memoryTotalAfterInitBGC\", MemoryControl.total());\r\n                    System.gc();\r\n                    sb.setConfig(\"memoryFreeAfterInitAGC\", MemoryControl.free());\r\n                    sb.setConfig(\"memoryTotalAfterInitAGC\", MemoryControl.total());\r\n                //} catch (ConcurrentModificationException e) {}\r\n\r\n                // wait for server shutdown\r\n                try {\r\n                    sb.waitForShutdown();\r\n                } catch (final Exception e) {\r\n                    Log.logSevere(\"MAIN CONTROL LOOP\", \"PANIC: \" + e.getMessage(),e);\r\n                }\r\n                // shut down\r\n                Array.terminate();\r\n                Log.logConfig(\"SHUTDOWN\", \"caught termination signal\");\r\n                server.terminate(false);\r\n                server.interrupt();\r\n                server.close();\r\n                /*\r\n                if (server.isAlive()) try {\r\n                    // TODO only send request, don't read response (cause server is already down resulting in error)\r\n                    final DigestURI u = new DigestURI((server.withSSL()?\"https\":\"http\")+\"://localhost:\" + serverCore.getPortNr(port), null);\r\n                    Client.wget(u.toString(), null, 10000); // kick server\r\n                    Log.logConfig(\"SHUTDOWN\", \"sent termination signal to server socket\");\r\n                } catch (final IOException ee) {\r\n                    Log.logConfig(\"SHUTDOWN\", \"termination signal to server socket missed (server shutdown, ok)\");\r\n                }\r\n                */\r\n//                Client.closeAllConnections();\r\n//                MultiThreadedHttpConnectionManager.shutdownAll();\r\n\r\n                // idle until the processes are down\r\n                if (server.isAlive()) {\r\n                    //Thread.sleep(2000); // wait a while\r\n                    server.interrupt();\r\n//                    MultiThreadedHttpConnectionManager.shutdownAll();\r\n                }\r\n//                MultiThreadedHttpConnectionManager.shutdownAll();\r\n                Log.logConfig(\"SHUTDOWN\", \"server has terminated\");\r\n                sb.close();\r\n            } catch (final Exception e) {\r\n                Log.logSevere(\"STARTUP\", \"Unexpected Error: \" + e.getClass().getName(),e);\r\n                //System.exit(1);\r\n            }\r\n        } catch (final Exception ee) {\r\n            Log.logSevere(\"STARTUP\", \"FATAL ERROR: \" + ee.getMessage(),ee);\r\n        } finally {\r\n        }\r\n        Log.logConfig(\"SHUTDOWN\", \"goodbye. (this is the last line)\");\r\n        Log.shutdown();\r\n        shutdownSemaphore.release(1000);\r\n        try {\r\n            System.exit(0);\r\n        } catch (final Exception e) {} // was once stopped by de.anomic.net.ftpc$sm.checkExit(ftpc.java:1790)\r\n    }","id":77070,"modified_method":"/**\r\n    * Starts up the whole application. Sets up all datastructures and starts\r\n    * the main threads.\r\n    *\r\n    * @param homePath Root-path where all information is to be found.\r\n    * @param startupFree free memory at startup time, to be used later for statistics\r\n    */\r\n    private static void startup(final File dataHome, final File appHome, final long startupMemFree, final long startupMemTotal, final boolean gui) {\r\n        try {\r\n            // start up\r\n            System.out.println(copyright);\r\n            System.out.println(hline);\r\n\r\n            // check java version\r\n            try {\r\n                \"a\".codePointAt(0); // needs at least Java 1.5\r\n            } catch (final NoSuchMethodError e) {\r\n                System.err.println(\"STARTUP: Java Version too low. You need at least Java 1.5 to run YaCy\"); // TODO: is 1.6 now\r\n                Thread.sleep(3000);\r\n                System.exit(-1);\r\n            }\r\n\r\n            // ensure that there is a DATA directory, if not, create one and if that fails warn and die\r\n            mkdirsIfNeseccary(dataHome);\r\n            mkdirsIfNeseccary(appHome);\r\n            File f = new File(dataHome, \"DATA/\");\r\n            mkdirsIfNeseccary(f);\r\n\t\t\tif (!(f.exists())) {\r\n\t\t\t\tSystem.err.println(\"Error creating DATA-directory in \" + dataHome.toString() + \" . Please check your write-permission for this folder. YaCy will now terminate.\");\r\n\t\t\t\tSystem.exit(-1);\r\n\t\t\t}\r\n\r\n            // setting up logging\r\n\t\t\tf = new File(dataHome, \"DATA/LOG/\");\r\n            mkdirsIfNeseccary(f);\r\n\t\t\tf = new File(dataHome, \"DATA/LOG/yacy.logging\");\r\n\t\t\tfinal File f0 = new File(appHome, \"yacy.logging\");\r\n\t\t\tif (!f.exists() || f0.lastModified() > f.lastModified()) try {\r\n\t\t\t    FileUtils.copy(f0, f);\r\n            } catch (final IOException e){\r\n                System.out.println(\"could not copy yacy.logging\");\r\n            }\r\n            try{\r\n                Log.configureLogging(dataHome, appHome, new File(dataHome, \"DATA/LOG/yacy.logging\"));\r\n            } catch (final IOException e) {\r\n                System.out.println(\"could not find logging properties in homePath=\" + dataHome);\r\n                Log.logException(e);\r\n            }\r\n            Log.logConfig(\"STARTUP\", \"YaCy version: \" + yacyBuildProperties.getVersion() + \"/\" + yacyBuildProperties.getSVNRevision());\r\n            Log.logConfig(\"STARTUP\", \"Java version: \" + System.getProperty(\"java.version\", \"no-java-version\"));\r\n            Log.logConfig(\"STARTUP\", \"Operation system: \" + System.getProperty(\"os.name\",\"unknown\"));\r\n            Log.logConfig(\"STARTUP\", \"Application root-path: \" + appHome);\r\n            Log.logConfig(\"STARTUP\", \"Data root-path: \" + dataHome);\r\n            Log.logConfig(\"STARTUP\", \"Time zone: UTC\" + GenericFormatter.UTCDiffString() + \"; UTC+0000 is \" + System.currentTimeMillis());\r\n            Log.logConfig(\"STARTUP\", \"Maximum file system path length: \" + OS.maxPathLength);\r\n\r\n            f = new File(dataHome, \"DATA/yacy.running\");\r\n            if (f.exists()) {                // another instance running? VM crash? User will have to care about this\r\n                Log.logSevere(\"STARTUP\", \"WARNING: the file \" + f + \" exists, this usually means that a YaCy instance is still running\");\r\n                delete(f);\r\n            }\r\n            if(!f.createNewFile())\r\n                Log.logSevere(\"STARTUP\", \"WARNING: the file \" + f + \" can not be created!\");\r\n            try { new FileOutputStream(f).write(Integer.toString(OS.getPID()).getBytes()); } catch (final Exception e) { } // write PID\r\n            f.deleteOnExit();\r\n\r\n            final String oldconf = \"DATA/SETTINGS/httpProxy.conf\".replace(\"/\", File.separator);\r\n            final String newconf = \"DATA/SETTINGS/yacy.conf\".replace(\"/\", File.separator);\r\n            final File oldconffile = new File(dataHome, oldconf);\r\n            if (oldconffile.exists()) {\r\n            \tfinal File newconfFile = new File(dataHome, newconf);\r\n                if(!oldconffile.renameTo(newconfFile))\r\n                    Log.logSevere(\"STARTUP\", \"WARNING: the file \" + oldconffile + \" can not be renamed to \"+ newconfFile +\"!\");\r\n            }\r\n            try {\r\n                sb = new Switchboard(dataHome, appHome, \"defaults/yacy.init\".replace(\"/\", File.separator), newconf);\r\n            } catch (final RuntimeException e) {\r\n                Log.logSevere(\"STARTUP\", \"YaCy cannot start: \" + e.getMessage(), e);\r\n                System.exit(-1);\r\n            }\r\n            //sbSync.V(); // signal that the sb reference was set\r\n\r\n            // switch the memory strategy\r\n            MemoryControl.setStandardStrategy(sb.getConfigBool(\"memory.standardStrategy\", true));\r\n\r\n            // save information about available memory at startup time\r\n            sb.setConfig(\"memoryFreeAfterStartup\", startupMemFree);\r\n            sb.setConfig(\"memoryTotalAfterStartup\", startupMemTotal);\r\n\r\n            // start gui if wanted\r\n            if (gui) YaCyApp.start(\"localhost\", (int) sb.getConfigLong(\"port\", 8090));\r\n\r\n            // hardcoded, forced, temporary value-migration\r\n            sb.setConfig(\"htTemplatePath\", \"htroot/env/templates\");\r\n\r\n            int oldRev;\r\n    \t    try {\r\n                oldRev = Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            } catch (final NumberFormatException e) {\r\n                oldRev = 0;\r\n    \t    }\r\n            final int newRev = Integer.parseInt(yacyBuildProperties.getSVNRevision());\r\n            sb.setConfig(\"svnRevision\", yacyBuildProperties.getSVNRevision());\r\n            sb.setConfig(\"applicationRoot\", appHome.toString());\r\n            sb.setConfig(\"dataRoot\", dataHome.toString());\r\n            yacyVersion.latestRelease = version;\r\n\r\n            // read environment\r\n            final int timeout = Math.max(5000, Integer.parseInt(sb.getConfig(\"httpdTimeout\", \"5000\")));\r\n\r\n            // create some directories\r\n            final File htRootPath = new File(appHome, sb.getConfig(\"htRootPath\", \"htroot\"));\r\n            final File htDocsPath = sb.getDataPath(SwitchboardConstants.HTDOCS_PATH, SwitchboardConstants.HTDOCS_PATH_DEFAULT);\r\n            mkdirIfNeseccary(htDocsPath);\r\n            //final File htTemplatePath = new File(homePath, sb.getConfig(\"htTemplatePath\",\"htdocs\"));\r\n\r\n            // create default notifier picture\r\n            //TODO: Use templates instead of copying images ...\r\n            if (!((new File(htDocsPath, \"notifier.gif\")).exists())) try {\r\n                FileUtils.copy(new File(htRootPath, \"env/grafics/empty.gif\"),\r\n                                     new File(htDocsPath, \"notifier.gif\"));\r\n            } catch (final IOException e) {}\r\n\r\n            final File htdocsReadme = new File(htDocsPath, \"readme.txt\");\r\n            if (!(htdocsReadme.exists())) try {FileUtils.copy((\r\n                    \"This is your root directory for individual Web Content\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Please place your html files into the www subdirectory.\\r\\n\" +\r\n                    \"The URL of that path is either\\r\\n\" +\r\n                    \"http://www.<your-peer-name>.yacy    or\\r\\n\" +\r\n                    \"http://<your-ip>:<your-port>/www\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Other subdirectories may be created; they map to corresponding sub-domains.\\r\\n\" +\r\n                    \"This directory shares it's content with the applications htroot path, so you\\r\\n\" +\r\n                    \"may access your yacy search page with\\r\\n\" +\r\n                    \"http://<your-peer-name>.yacy/\\r\\n\" +\r\n                    \"\\r\\n\").getBytes(), htdocsReadme);} catch (final IOException e) {\r\n                        System.out.println(\"Error creating htdocs readme: \" + e.getMessage());\r\n                    }\r\n\r\n            final File wwwDefaultPath = new File(htDocsPath, \"www\");\r\n            mkdirIfNeseccary(wwwDefaultPath);\r\n\r\n\r\n            final File shareDefaultPath = new File(htDocsPath, \"share\");\r\n            mkdirIfNeseccary(shareDefaultPath);\r\n\r\n            migration.migrate(sb, oldRev, newRev);\r\n\r\n            // delete old release files\r\n            final int deleteOldDownloadsAfterDays = (int) sb.getConfigLong(\"update.deleteOld\", 30);\r\n            yacyRelease.deleteOldDownloads(sb.releasePath, deleteOldDownloadsAfterDays );\r\n\r\n            // set user-agent\r\n            HTTPClient.setDefaultUserAgent(ClientIdentification.getUserAgent());\r\n\r\n            // start main threads\r\n            final String port = sb.getConfig(\"port\", \"8090\");\r\n            try {\r\n                final HTTPDemon protocolHandler = new HTTPDemon(sb);\r\n                final serverCore server = new serverCore(\r\n                        timeout /*control socket timeout in milliseconds*/,\r\n                        true /* block attacks (wrong protocol) */,\r\n                        protocolHandler /*command class*/,\r\n                        sb,\r\n                        30000 /*command max length incl. GET args*/);\r\n                server.setName(\"httpd:\"+port);\r\n                server.setPriority(Thread.MAX_PRIORITY);\r\n                server.setObeyIntermission(false);\r\n\r\n                // start the server\r\n                sb.deployThread(\"10_httpd\", \"HTTPD Server/Proxy\", \"the HTTPD, used as web server and proxy\", null, server, 0, 0, 0, 0);\r\n                //server.start();\r\n\r\n                // open the browser window\r\n                final boolean browserPopUpTrigger = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_TRIGGER, \"true\").equals(\"true\");\r\n                if (browserPopUpTrigger) try {\r\n                    final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n                    //boolean properPW = (sb.getConfig(\"adminAccount\", \"\").length() == 0) && (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0);\r\n                    //if (!properPW) browserPopUpPage = \"ConfigBasic.html\";\r\n                    Browser.openBrowser((server.withSSL()?\"https\":\"http\") + \"://localhost:\" + serverCore.getPortNr(port) + \"/\" + browserPopUpPage);\r\n                } catch (final RuntimeException e) {\r\n                    // cannot open browser. This may be normal in headless environments\r\n                    //Log.logException(e);\r\n                }\r\n\r\n                // unlock yacyTray browser popup\r\n                Tray.lockBrowserPopup = false;\r\n\r\n                // Copy the shipped locales into DATA, existing files are overwritten\r\n                final File locale_work   = sb.getDataPath(\"locale.work\", \"DATA/LOCALE/locales\");\r\n                final File locale_source = sb.getAppPath(\"locale.source\", \"locales\");\r\n                try{\r\n                    final File[] locale_source_files = locale_source.listFiles();\r\n                    mkdirsIfNeseccary(locale_work);\r\n                    File target;\r\n                    for (final File locale_source_file : locale_source_files) {\r\n                    \ttarget = new File(locale_work, locale_source_file.getName());\r\n                        if (locale_source_file.getName().endsWith(\".lng\")) {\r\n                        \tif (target.exists()) delete(target);\r\n                            FileUtils.copy(locale_source_file, target);\r\n                        }\r\n                    }\r\n                    Log.logInfo(\"STARTUP\", \"Copied the default locales to \" + locale_work.toString());\r\n                }catch(final NullPointerException e){\r\n                    Log.logSevere(\"STARTUP\", \"Nullpointer Exception while copying the default Locales\");\r\n                }\r\n\r\n                //regenerate Locales from Translationlist, if needed\r\n                final String lang = sb.getConfig(\"locale.language\", \"\");\r\n                if (!lang.equals(\"\") && !lang.equals(\"default\")) { //locale is used\r\n                    String currentRev = \"\";\r\n                    try{\r\n                        final BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(sb.getDataPath(\"locale.translated_html\", \"DATA/LOCALE/htroot\"), lang+\"/version\" ))));\r\n                        currentRev = br.readLine();\r\n                        br.close();\r\n                    }catch(final IOException e){\r\n                        //Error\r\n                    }\r\n\r\n                    if (!currentRev.equals(sb.getConfig(\"svnRevision\", \"\"))) try { //is this another version?!\r\n                        final File sourceDir = new File(sb.getConfig(\"htRootPath\", \"htroot\"));\r\n                        final File destDir = new File(sb.getDataPath(\"locale.translated_html\", \"DATA/LOCALE/htroot\"), lang);\r\n                        if (Translator.translateFilesRecursive(sourceDir, destDir, new File(locale_work, lang + \".lng\"), \"html,template,inc\", \"locale\")){ //translate it\r\n                            //write the new Versionnumber\r\n                            final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(new File(destDir, \"version\"))));\r\n                            bw.write(sb.getConfig(\"svnRevision\", \"Error getting Version\"));\r\n                            bw.close();\r\n                        }\r\n                    } catch (final IOException e) {}\r\n                }\r\n                // initialize number formatter with this locale\r\n                Formatter.setLocale(lang);\r\n\r\n                // registering shutdown hook\r\n                Log.logConfig(\"STARTUP\", \"Registering Shutdown Hook\");\r\n                final Runtime run = Runtime.getRuntime();\r\n                run.addShutdownHook(new shutdownHookThread(Thread.currentThread(), sb));\r\n\r\n                // save information about available memory after all initializations\r\n                //try {\r\n                    sb.setConfig(\"memoryFreeAfterInitBGC\", MemoryControl.free());\r\n                    sb.setConfig(\"memoryTotalAfterInitBGC\", MemoryControl.total());\r\n                    System.gc();\r\n                    sb.setConfig(\"memoryFreeAfterInitAGC\", MemoryControl.free());\r\n                    sb.setConfig(\"memoryTotalAfterInitAGC\", MemoryControl.total());\r\n                //} catch (ConcurrentModificationException e) {}\r\n\r\n                // wait for server shutdown\r\n                try {\r\n                    sb.waitForShutdown();\r\n                } catch (final Exception e) {\r\n                    Log.logSevere(\"MAIN CONTROL LOOP\", \"PANIC: \" + e.getMessage(),e);\r\n                }\r\n                // shut down\r\n                Array.terminate();\r\n                Log.logConfig(\"SHUTDOWN\", \"caught termination signal\");\r\n                server.terminate(false);\r\n                server.interrupt();\r\n                server.close();\r\n                /*\r\n                if (server.isAlive()) try {\r\n                    // TODO only send request, don't read response (cause server is already down resulting in error)\r\n                    final DigestURI u = new DigestURI((server.withSSL()?\"https\":\"http\")+\"://localhost:\" + serverCore.getPortNr(port), null);\r\n                    Client.wget(u.toString(), null, 10000); // kick server\r\n                    Log.logConfig(\"SHUTDOWN\", \"sent termination signal to server socket\");\r\n                } catch (final IOException ee) {\r\n                    Log.logConfig(\"SHUTDOWN\", \"termination signal to server socket missed (server shutdown, ok)\");\r\n                }\r\n                */\r\n//                Client.closeAllConnections();\r\n//                MultiThreadedHttpConnectionManager.shutdownAll();\r\n\r\n                // idle until the processes are down\r\n                if (server.isAlive()) {\r\n                    //Thread.sleep(2000); // wait a while\r\n                    server.interrupt();\r\n//                    MultiThreadedHttpConnectionManager.shutdownAll();\r\n                }\r\n//                MultiThreadedHttpConnectionManager.shutdownAll();\r\n                Log.logConfig(\"SHUTDOWN\", \"server has terminated\");\r\n                sb.close();\r\n            } catch (final Exception e) {\r\n                Log.logSevere(\"STARTUP\", \"Unexpected Error: \" + e.getClass().getName(),e);\r\n                //System.exit(1);\r\n            }\r\n        } catch (final Exception ee) {\r\n            Log.logSevere(\"STARTUP\", \"FATAL ERROR: \" + ee.getMessage(),ee);\r\n        } finally {\r\n        }\r\n        Log.logConfig(\"SHUTDOWN\", \"goodbye. (this is the last line)\");\r\n        Log.shutdown();\r\n        shutdownSemaphore.release(1000);\r\n        try {\r\n            System.exit(0);\r\n        } catch (final Exception e) {} // was once stopped by de.anomic.net.ftpc$sm.checkExit(ftpc.java:1790)\r\n    }","commit_id":"eb9c9edb01a7bb0c70421cf9970029168b7fe021","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private String[] splitDef(final String definition) {\n\t\treturn definition.split(\"(?<!\\\\\\\\):\");\n\t}","id":77071,"modified_method":"private String[] splitDef(final String definition) {\n\t\t// log().debug(\"splitDef(\" + definition + \")\");\n\t\tfinal String[] def;\n\t\tif (File.separatorChar == '\\\\') {\n\t\t\t// log().debug(\"windows\");\n\t\t\t// Windows, make sure the beginning isn't eg: C:\\\\foo\\\\bar\n\t\t\tif (definition.matches(\"[^=]*=[a-zA-Z]:.*\")) {\n\t\t\t\tfinal String[] tempDef = definition.split(\"(?<!\\\\\\\\):\");\n\t\t\t\tdef = new String[tempDef.length - 1];\n\t\t\t\tdef[0] = tempDef[0] + ':' + tempDef[1];\n\t\t\t\tif (tempDef.length > 2) {\n\t\t\t\t\tfor (int i = 2; i < tempDef.length; i++) {\n\t\t\t\t\t\tdef[i-1] = tempDef[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// log().debug(\"no match\");\n\t\t\t\tdef = definition.split(\"(?<!\\\\\\\\):\");\n\t\t\t}\n\t\t} else {\n\t\t\tdef = definition.split(\"(?<!\\\\\\\\):\");\n\t\t}\n\t\t// log().debug(\"returning: \" + Arrays.toString(def));\n\t\treturn def;\n\t}","commit_id":"34ebdc8e011e4e14dd10070f8bdd643d6b76fda3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>createGraphDef<\/p>\n     *\n     * @param workDir a {@link java.io.File} object.\n     * @param commandArray an array of {@link java.lang.String} objects.\n     * @return a {@link org.jrobin.graph.RrdGraphDef} object.\n     * @throws org.jrobin.core.RrdException if any.\n     */\n    protected RrdGraphDef createGraphDef(final File workDir, final String[] inputArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        Map<String,List<String>> defs = new LinkedHashMap<String,List<String>>();\n        // Map<String,List<String>> cdefs = new HashMap<String,List<String>>();\n        \n        final String[] commandArray;\n        if (inputArray[0].contains(\"rrdtool\") && inputArray[1].equals(\"graph\") && inputArray[2].equals(\"-\")) {\n        \tcommandArray = Arrays.copyOfRange(inputArray, 3, inputArray.length);\n        } else {\n        \tcommandArray = inputArray;\n        }\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+width);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+width);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = splitDef(definition);\n                String[] ds = def[0].split(\"=\");\n                File dsFile = new File(workDir, ds[1].replace(\"\\\\\", \"\"));\n                graphDef.datasource(ds[0], dsFile.getAbsolutePath(), def[1], def[2]);\n                List<String> defBits = new ArrayList<String>();\n                defBits.add(dsFile.getAbsolutePath());\n                defBits.add(def[1]);\n                defBits.add(def[2]);\n                defs.put(ds[0], defBits);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n                List<String> cdefBits = new ArrayList<String>();\n                cdefBits.add(cdef[1]);\n                defs.put(cdef[0], cdefBits);\n            } else if (arg.startsWith(\"VDEF:\")) {\n                String definition = arg.substring(\"VDEF:\".length());\n                String[] vdef = tokenize(definition, \"=\", true);\n                String[] expressionTokens = tokenize(vdef[1], \",\", false);\n                addVdefDs(graphDef, vdef[0], expressionTokens, start, end, defs);\n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n\n            } else if (arg.endsWith(\"/rrdtool\") || arg.equals(\"graph\") || arg.equals(\"-\")) {\n            \t// ignore, this is just a leftover from the rrdtool-specific options\n\n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","id":77072,"modified_method":"/**\n     * <p>createGraphDef<\/p>\n     *\n     * @param workDir a {@link java.io.File} object.\n     * @param commandArray an array of {@link java.lang.String} objects.\n     * @return a {@link org.jrobin.graph.RrdGraphDef} object.\n     * @throws org.jrobin.core.RrdException if any.\n     */\n    protected RrdGraphDef createGraphDef(final File workDir, final String[] inputArray) throws RrdException {\n        RrdGraphDef graphDef = new RrdGraphDef();\n        graphDef.setImageFormat(\"PNG\");\n        long start = 0;\n        long end = 0;\n        int height = 100;\n        int width = 400;\n        double lowerLimit = Double.NaN;\n        double upperLimit = Double.NaN;\n        boolean rigid = false;\n        Map<String,List<String>> defs = new LinkedHashMap<String,List<String>>();\n        // Map<String,List<String>> cdefs = new HashMap<String,List<String>>();\n        \n        final String[] commandArray;\n        if (inputArray[0].contains(\"rrdtool\") && inputArray[1].equals(\"graph\") && inputArray[2].equals(\"-\")) {\n        \tcommandArray = Arrays.copyOfRange(inputArray, 3, inputArray.length);\n        } else {\n        \tcommandArray = inputArray;\n        }\n        \n        log().debug(\"command array = \" + Arrays.toString(commandArray));\n\n        for (int i = 0; i < commandArray.length; i++) {\n            String arg = commandArray[i];\n            if (arg.startsWith(\"--start=\")) {\n                start = Long.parseLong(arg.substring(\"--start=\".length()));\n                log().debug(\"JRobin start time: \" + start);\n            } else if (arg.equals(\"--start\")) {\n                if (i + 1 < commandArray.length) {\n                    start = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin start time: \" + start);\n                } else {\n                    throw new IllegalArgumentException(\"--start must be followed by a start time\");\n                }\n                \n            } else if (arg.startsWith(\"--end=\")) {\n                end = Long.parseLong(arg.substring(\"--end=\".length()));\n                log().debug(\"JRobin end time: \" + end);\n            } else if (arg.equals(\"--end\")) {\n                if (i + 1 < commandArray.length) {\n                    end = Long.parseLong(commandArray[++i]);\n                    log().debug(\"JRobin end time: \" + end);\n                } else {\n                    throw new IllegalArgumentException(\"--end must be followed by an end time\");\n                }\n                \n            } else if (arg.startsWith(\"--title=\")) {\n                String[] title = tokenize(arg, \"=\", true);\n                graphDef.setTitle(title[1]);\n            } else if (arg.equals(\"--title\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setTitle(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--title must be followed by a title\");\n                }\n                \n            } else if (arg.startsWith(\"--color=\")) {\n                String[] color = tokenize(arg, \"=\", true);\n                parseGraphColor(graphDef, color[1]);\n            } else if (arg.equals(\"--color\") || arg.equals(\"-c\")) {\n                if (i + 1 < commandArray.length) {\n                    parseGraphColor(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--color must be followed by a color\");\n                }\n                \n            } else if (arg.startsWith(\"--vertical-label=\")) {\n                String[] label = tokenize(arg, \"=\", true);\n                graphDef.setVerticalLabel(label[1]);\n            } else if (arg.equals(\"--vertical-label\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setVerticalLabel(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--vertical-label must be followed by a label\");\n                }\n                \n            } else if (arg.startsWith(\"--height=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                height = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin height: \"+height);\n            } else if (arg.equals(\"--height\")) {\n                if (i + 1 < commandArray.length) {\n                    height = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin height: \"+height);\n                } else {\n                    throw new IllegalArgumentException(\"--height must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--width=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                width = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin width: \"+width);\n            } else if (arg.equals(\"--width\")) {\n                if (i + 1 < commandArray.length) {\n                    width = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin width: \"+width);\n                } else {\n                    throw new IllegalArgumentException(\"--width must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--units-exponent=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                int exponent = Integer.parseInt(argParm[1]);\n                log().debug(\"JRobin units exponent: \"+exponent);\n                graphDef.setUnitsExponent(exponent);\n            } else if (arg.equals(\"--units-exponent\")) {\n                if (i + 1 < commandArray.length) {\n                    int exponent = Integer.parseInt(commandArray[++i]);\n                    log().debug(\"JRobin units exponent: \"+exponent);\n                    graphDef.setUnitsExponent(exponent);\n                } else {\n                    throw new IllegalArgumentException(\"--units-exponent must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--lower-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                lowerLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin lower limit: \"+lowerLimit);\n            } else if (arg.equals(\"--lower-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    lowerLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin lower limit: \"+lowerLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--lower-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--upper-limit=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                upperLimit = Double.parseDouble(argParm[1]);\n                log().debug(\"JRobin upp limit: \"+upperLimit);\n            } else if (arg.equals(\"--upper-limit\")) {\n                if (i + 1 < commandArray.length) {\n                    upperLimit = Double.parseDouble(commandArray[++i]);\n                    log().debug(\"JRobin upper limit: \"+upperLimit);\n                } else {\n                    throw new IllegalArgumentException(\"--upper-limit must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--base=\")) {\n                String[] argParm = tokenize(arg, \"=\", true);\n                graphDef.setBase(Double.parseDouble(argParm[1]));\n            } else if (arg.equals(\"--base\")) {\n                if (i + 1 < commandArray.length) {\n                    graphDef.setBase(Double.parseDouble(commandArray[++i]));\n                } else {\n                    throw new IllegalArgumentException(\"--base must be followed by a number\");\n                }\n            \n            } else if (arg.startsWith(\"--font=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tprocessRrdFontArgument(graphDef, argParm[1]);\n            } else if (arg.equals(\"--font\")) {\n                if (i + 1 < commandArray.length) {\n                \tprocessRrdFontArgument(graphDef, commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--font must be followed by an argument\");\n                }\n            } else if (arg.startsWith(\"--imgformat=\")) {\n            \tString[] argParm = tokenize(arg, \"=\", true);\n            \tgraphDef.setImageFormat(argParm[1]);\n            } else if (arg.equals(\"--imgformat\")) {\n                if (i + 1 < commandArray.length) {\n                \tgraphDef.setImageFormat(commandArray[++i]);\n                } else {\n                    throw new IllegalArgumentException(\"--imgformat must be followed by an argument\");\n                }\n            \n            } else if (arg.equals(\"--rigid\")) {\n                rigid = true;\n            \n            } else if (arg.startsWith(\"DEF:\")) {\n                String definition = arg.substring(\"DEF:\".length());\n                String[] def = splitDef(definition);\n                String[] ds = def[0].split(\"=\");\n                // log().debug(\"ds = \" + Arrays.toString(ds));\n                final String replaced = ds[1].replaceAll(\"\\\\\\\\(.)\", \"$1\");\n                // log().debug(\"replaced = \" + replaced);\n                \n                final File dsFile;\n                File rawPathFile = new File(replaced);\n                if (rawPathFile.isAbsolute()) {\n                \tdsFile = rawPathFile;\n                } else {\n                \tdsFile = new File(workDir, replaced);\n                }\n                // log().debug(\"dsFile = \" + dsFile + \", ds[1] = \" + ds[1]);\n                \n                final String absolutePath = (File.separatorChar == '\\\\')? dsFile.getAbsolutePath().replace(\"\\\\\", \"\\\\\\\\\") : dsFile.getAbsolutePath();\n                // log().debug(\"absolutePath = \" + absolutePath);\n                graphDef.datasource(ds[0], absolutePath, def[1], def[2]);\n\n                List<String> defBits = new ArrayList<String>();\n                defBits.add(absolutePath);\n                defBits.add(def[1]);\n                defBits.add(def[2]);\n                defs.put(ds[0], defBits);\n            \n            } else if (arg.startsWith(\"CDEF:\")) {\n                String definition = arg.substring(\"CDEF:\".length());\n                String[] cdef = tokenize(definition, \"=\", true);\n                graphDef.datasource(cdef[0], cdef[1]);\n                List<String> cdefBits = new ArrayList<String>();\n                cdefBits.add(cdef[1]);\n                defs.put(cdef[0], cdefBits);\n            } else if (arg.startsWith(\"VDEF:\")) {\n                String definition = arg.substring(\"VDEF:\".length());\n                String[] vdef = tokenize(definition, \"=\", true);\n                String[] expressionTokens = tokenize(vdef[1], \",\", false);\n                addVdefDs(graphDef, vdef[0], expressionTokens, start, end, defs);\n            } else if (arg.startsWith(\"LINE1:\")) {\n                String definition = arg.substring(\"LINE1:\".length());\n                String[] line1 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line1[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line1.length > 1 ? line1[1] : \"\"));\n            \n            } else if (arg.startsWith(\"LINE2:\")) {\n                String definition = arg.substring(\"LINE2:\".length());\n                String[] line2 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line2[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line2.length > 1 ? line2[1] : \"\"), 2);\n\n            } else if (arg.startsWith(\"LINE3:\")) {\n                String definition = arg.substring(\"LINE3:\".length());\n                String[] line3 = tokenize(definition, \":\", true);\n                String[] color = tokenize(line3[0], \"#\", true);\n                graphDef.line(color[0], getColorOrInvisible(color, 1), (line3.length > 1 ? line3[1] : \"\"), 3);\n\n            } else if (arg.startsWith(\"GPRINT:\")) {\n                String definition = arg.substring(\"GPRINT:\".length());\n                String gprint[] = tokenize(definition, \":\", true);\n                String format = gprint[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + gprint[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.gprint(gprint[0], gprint[1], format);\n                \n            } else if (arg.startsWith(\"PRINT:\")) {\n                String definition = arg.substring(\"PRINT:\".length());\n                String print[] = tokenize(definition, \":\", true);\n                String format = print[2];\n                //format = format.replaceAll(\"%(\\\\d*\\\\.\\\\d*)lf\", \"@$1\");\n                //format = format.replaceAll(\"%s\", \"@s\");\n                //format = format.replaceAll(\"%%\", \"%\");\n                //log.debug(\"gprint: oldformat = \" + print[2] + \" newformat = \" + format);\n                format = format.replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.print(print[0], print[1], format);\n\n            } else if (arg.startsWith(\"COMMENT:\")) {\n                String comments[] = tokenize(arg, \":\", true);\n                String format = comments[1].replaceAll(\"\\\\n\", \"\\\\\\\\l\");\n                graphDef.comment(format);\n            } else if (arg.startsWith(\"AREA:\")) {\n                String definition = arg.substring(\"AREA:\".length());\n                String area[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(area[0], \"#\", true);\n                if (area.length > 1) {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1), area[1]);\n                } else {\n                    graphDef.area(color[0], getColorOrInvisible(color, 1));\n                }\n\n            } else if (arg.startsWith(\"STACK:\")) {\n                String definition = arg.substring(\"STACK:\".length());\n                String stack[] = tokenize(definition, \":\", true);\n                String[] color = tokenize(stack[0], \"#\", true);\n                graphDef.stack(color[0], getColor(color[1]), (stack.length > 1 ? stack[1] : \"\"));\n\n            } else if (arg.endsWith(\"/rrdtool\") || arg.equals(\"graph\") || arg.equals(\"-\")) {\n            \t// ignore, this is just a leftover from the rrdtool-specific options\n\n            } else {\n                log().warn(\"JRobin: Unrecognized graph argument: \" + arg);\n            }\n        }\n        \n        graphDef.setTimeSpan(start, end);\n        graphDef.setMinValue(lowerLimit);\n        graphDef.setMaxValue(upperLimit);\n        graphDef.setRigid(rigid);\n        graphDef.setHeight(height);\n        graphDef.setWidth(width);\n        // graphDef.setSmallFont(new Font(\"Monospaced\", Font.PLAIN, 10));\n        // graphDef.setLargeFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        log().debug(\"JRobin Finished tokenizing checking: start time: \" + start + \"; end time: \" + end);\n        log().debug(\"large font = \" + graphDef.getLargeFont() + \", small font = \" + graphDef.getSmallFont());\n        return graphDef;\n    }","commit_id":"34ebdc8e011e4e14dd10070f8bdd643d6b76fda3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSampleVDEFPercentile() throws Exception {\n        Double[] vals = {\n                39.0, 94.0, 95.0, 101.0, 155.0, 262.0, 274.0, 302.0, 319.0, 402.0, 466.0, 468.0, 494.0, 549.0, 550.0, 575.0, 600.0, 615.0, 625.0, 703.0, 729.0, 824.0, 976.0, 1018.0, 1036.0, 1138.0, 1195.0, 1265.0, 1287.0, 1323.0, 1410.0, 1443.0, 1516.0, 1538.0, 1664.0, 1686.0, 1801.0, 1912.0, 1921.0, 1929.0, 1936.0, 1941.0, 1985.0, 2003.0, 2010.0, 2013.0, 2082.0, 2106.0, 2213.0, 2358.0, 2394.0, 2572.0, 2616.0, 2627.0, 2676.0, 2694.0, 2736.0, 2740.0, 2966.0, 3005.0, 3037.0, 3041.0, 3146.0, 3194.0, 3228.0, 3235.0, 3243.0, 3339.0, 3365.0, 3414.0, 3440.0, 3454.0, 3567.0, 3570.0, 3615.0, 3619.0, 3802.0, 3831.0, 3864.0, 4061.0, 4084.0, 4106.0, 4233.0, 4328.0, 4362.0, 4372.0, 4376.0, 4388.0, 4413.0, 4527.0, 4612.0, 4643.0, 4684.0, 4750.0, 4799.0, 4810.0, 4824.0, 4825.0, 4871.0, 4932.0, 5028.0, 5112.0, 5118.0, 5163.0, 5198.0, 5256.0, 5296.0, 5413.0, 5471.0, 5568.0, 5628.0, 5645.0, 5733.0, 5790.0, 5851.0, 5886.0, 5927.0, 5937.0, 6018.0, 6027.0, 6046.0, 6145.0, 6147.0, 6289.0, 6371.0, 6384.0, 6393.0, 6431.0, 6469.0, 6543.0, 6649.0, 6772.0, 6864.0, 6943.0, 7009.0, 7014.0, 7037.0, 7258.0, 7356.0, 7364.0, 7386.0, 7387.0, 7399.0, 7450.0, 7519.0, 7527.0, 7578.0, 7632.0, 7709.0, 7849.0, 7896.0, 7952.0, 7980.0, 8050.0, 8126.0, 8152.0, 8165.0, 8332.0, 8347.0, 8520.0, 8522.0, 8542.0, 8587.0, 8621.0, 8678.0, 8721.0, 8739.0, 8765.0, 8889.0, 8951.0, 8962.0, 9082.0, 9149.0, 9199.0, 9278.0, 9334.0, 9339.0, 9345.0, 9365.0, 9383.0, 9402.0, 9471.0, 9483.0, 9492.0, 9496.0, 9532.0, 9553.0, 9563.0, 9571.0, 9574.0, 100000.0, 120000.0, 150000.0, 200000.0, 500000.0, 1000000.0, 2000000.0, 4000000.0, 8000000.0, 16000000.0\n        };\n        File rrdFile = createRrdFile();\n        RrdDb openedFile = m_strategy.openFile(rrdFile.getAbsolutePath());\n        \n        // This file's step size is 300\n        int endTime = (int)(System.currentTimeMillis() / 1000);\n        endTime -= (endTime % 300);\n        int startTime = endTime - (200 * 300);\n        \n        // Got to throw away the first sample\n        m_strategy.updateFile(openedFile, \"huh?\", (startTime - 300) + \":\" + \"0.0\");\n\n        int sampleTime = startTime;\n        for (double val : vals) {\n            m_strategy.updateFile(openedFile, \"huh?\", sampleTime + \":\" + val);\n            sampleTime += 300;\n        }\n        m_strategy.closeFile(openedFile);\n        \n        String[] command;\n        RrdGraphDef graphDef;\n        RrdGraph graph;\n        RrdGraphInfo info;\n        String[] printLines;\n        \n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath() + \":bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - DEF\", printLines);\n        assertEquals(\"graph printLines - DEF size\", 5, printLines.length);\n        assertEquals(\"graph printLines - DEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - DEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - DEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - DEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - DEF item 4\", \"9.574000e+03\", printLines[4]);\n\n        // Now do it with a CDEF\n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath() + \":bar:AVERAGE\",\n                \"CDEF:bazX1=baz,1,*\",\n                \"CDEF:bazX1P0=bazX1,0,+\",\n                \"VDEF:avg=bazX1,AVERAGE\",\n                \"VDEF:min=bazX1,MIN\",\n                \"VDEF:max=bazX1,MAX\",\n                \"VDEF:tot=bazX1,TOTAL\",\n                \"VDEF:nfp=bazX1,95,PERCENT\",\n                \"VDEF:nfp2=bazX1P0,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp2:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - CDEF\", printLines);\n        assertEquals(\"graph printLines - CDEF size\", 6, printLines.length);\n        assertEquals(\"graph printLines - CDEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - CDEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - CDEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - CDEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - CDEF item 4\", \"9.574000e+03\", printLines[4]);\n        assertEquals(\"graph printLines - CDEF item 5\", \"9.574000e+03\", printLines[5]);\n        \n    }","id":77073,"modified_method":"@Test\n    public void testSampleVDEFPercentile() throws Exception {\n        Double[] vals = {\n                39.0, 94.0, 95.0, 101.0, 155.0, 262.0, 274.0, 302.0, 319.0, 402.0, 466.0, 468.0, 494.0, 549.0, 550.0, 575.0, 600.0, 615.0, 625.0, 703.0, 729.0, 824.0, 976.0, 1018.0, 1036.0, 1138.0, 1195.0, 1265.0, 1287.0, 1323.0, 1410.0, 1443.0, 1516.0, 1538.0, 1664.0, 1686.0, 1801.0, 1912.0, 1921.0, 1929.0, 1936.0, 1941.0, 1985.0, 2003.0, 2010.0, 2013.0, 2082.0, 2106.0, 2213.0, 2358.0, 2394.0, 2572.0, 2616.0, 2627.0, 2676.0, 2694.0, 2736.0, 2740.0, 2966.0, 3005.0, 3037.0, 3041.0, 3146.0, 3194.0, 3228.0, 3235.0, 3243.0, 3339.0, 3365.0, 3414.0, 3440.0, 3454.0, 3567.0, 3570.0, 3615.0, 3619.0, 3802.0, 3831.0, 3864.0, 4061.0, 4084.0, 4106.0, 4233.0, 4328.0, 4362.0, 4372.0, 4376.0, 4388.0, 4413.0, 4527.0, 4612.0, 4643.0, 4684.0, 4750.0, 4799.0, 4810.0, 4824.0, 4825.0, 4871.0, 4932.0, 5028.0, 5112.0, 5118.0, 5163.0, 5198.0, 5256.0, 5296.0, 5413.0, 5471.0, 5568.0, 5628.0, 5645.0, 5733.0, 5790.0, 5851.0, 5886.0, 5927.0, 5937.0, 6018.0, 6027.0, 6046.0, 6145.0, 6147.0, 6289.0, 6371.0, 6384.0, 6393.0, 6431.0, 6469.0, 6543.0, 6649.0, 6772.0, 6864.0, 6943.0, 7009.0, 7014.0, 7037.0, 7258.0, 7356.0, 7364.0, 7386.0, 7387.0, 7399.0, 7450.0, 7519.0, 7527.0, 7578.0, 7632.0, 7709.0, 7849.0, 7896.0, 7952.0, 7980.0, 8050.0, 8126.0, 8152.0, 8165.0, 8332.0, 8347.0, 8520.0, 8522.0, 8542.0, 8587.0, 8621.0, 8678.0, 8721.0, 8739.0, 8765.0, 8889.0, 8951.0, 8962.0, 9082.0, 9149.0, 9199.0, 9278.0, 9334.0, 9339.0, 9345.0, 9365.0, 9383.0, 9402.0, 9471.0, 9483.0, 9492.0, 9496.0, 9532.0, 9553.0, 9563.0, 9571.0, 9574.0, 100000.0, 120000.0, 150000.0, 200000.0, 500000.0, 1000000.0, 2000000.0, 4000000.0, 8000000.0, 16000000.0\n        };\n        File rrdFile = createRrdFile();\n        RrdDb openedFile = m_strategy.openFile(rrdFile.getAbsolutePath());\n        \n        // This file's step size is 300\n        int endTime = (int)(System.currentTimeMillis() / 1000);\n        endTime -= (endTime % 300);\n        int startTime = endTime - (200 * 300);\n        \n        // Got to throw away the first sample\n        m_strategy.updateFile(openedFile, \"huh?\", (startTime - 300) + \":\" + \"0.0\");\n\n        int sampleTime = startTime;\n        for (double val : vals) {\n            m_strategy.updateFile(openedFile, \"huh?\", sampleTime + \":\" + val);\n            sampleTime += 300;\n        }\n        m_strategy.closeFile(openedFile);\n        \n        String[] command;\n        RrdGraphDef graphDef;\n        RrdGraph graph;\n        RrdGraphInfo info;\n        String[] printLines;\n        \n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath().replace(\"\\\\\", \"\\\\\\\\\") + \":bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - DEF\", printLines);\n        assertEquals(\"graph printLines - DEF size\", 5, printLines.length);\n        assertEquals(\"graph printLines - DEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - DEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - DEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - DEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - DEF item 4\", \"9.574000e+03\", printLines[4]);\n\n        // Now do it with a CDEF\n        command = new String[] {\n                \"--start=\" + (startTime - 300),\n                \"--end=\" + (endTime + 300),\n                \"DEF:baz=\" + rrdFile.getAbsolutePath().replace(\"\\\\\", \"\\\\\\\\\") + \":bar:AVERAGE\",\n                \"CDEF:bazX1=baz,1,*\",\n                \"CDEF:bazX1P0=bazX1,0,+\",\n                \"VDEF:avg=bazX1,AVERAGE\",\n                \"VDEF:min=bazX1,MIN\",\n                \"VDEF:max=bazX1,MAX\",\n                \"VDEF:tot=bazX1,TOTAL\",\n                \"VDEF:nfp=bazX1,95,PERCENT\",\n                \"VDEF:nfp2=bazX1P0,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp2:AVERAGE:\\\"%le\\\"\"\n        };\n        graphDef = ((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        graph = new RrdGraph(graphDef);\n        assertNotNull(\"graph object\", graph);\n        \n        info = graph.getRrdGraphInfo();\n        assertNotNull(\"graph info object\", info);\n        \n        printLines = info.getPrintLines();\n        assertNotNull(\"graph printLines - CDEF\", printLines);\n        assertEquals(\"graph printLines - CDEF size\", 6, printLines.length);\n        assertEquals(\"graph printLines - CDEF item 0\", \"1.649453e+05\", printLines[0]);\n        assertEquals(\"graph printLines - CDEF item 1\", \"3.900000e+01\", printLines[1]);\n        assertEquals(\"graph printLines - CDEF item 2\", \"1.600000e+07\", printLines[2]);\n        assertEquals(\"graph printLines - CDEF item 3\", \"9.896721e+09\", printLines[3]);\n        assertEquals(\"graph printLines - CDEF item 4\", \"9.574000e+03\", printLines[4]);\n        assertEquals(\"graph printLines - CDEF item 5\", \"9.574000e+03\", printLines[5]);\n        \n    }","commit_id":"34ebdc8e011e4e14dd10070f8bdd643d6b76fda3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDefWithEscapedCharacters() throws Exception {\n        long end = System.currentTimeMillis() / 1000;\n        long start = end - (24 * 60 * 60);\n        final String[] command = new String[] {\n                \"--start=\" + (start - 300),\n                \"--end=\" + (end + 300),\n                \"DEF:baz=response/fe80\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\%5/dns.jrb:bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n\n        Throwable t = null;\n        try {\n        \t((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        } catch (final org.jrobin.core.RrdException e) {\n        \tt = e;\n        }\n        assertNotNull(t);\n    \tassertTrue(t.getMessage().contains(\"Could not open /response/fe80:0000:0000:0000:0000:0000:0000:0000%5/dns.jrb\"));\n    }","id":77074,"modified_method":"@Test\n    public void testDefWithEscapedCharacters() throws Exception {\n        long end = System.currentTimeMillis() / 1000;\n        long start = end - (24 * 60 * 60);\n        final String[] command = new String[] {\n                \"--start=\" + (start - 300),\n                \"--end=\" + (end + 300),\n                \"DEF:baz=response/fe80\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\:0000\\\\%5/dns.jrb:bar:AVERAGE\",\n                \"VDEF:avg=baz,AVERAGE\",\n                \"VDEF:min=baz,MIN\",\n                \"VDEF:max=baz,MAX\",\n                \"VDEF:tot=baz,TOTAL\",\n                \"VDEF:nfp=baz,95,PERCENT\",\n                \"PRINT:avg:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:min:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:max:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:tot:AVERAGE:\\\"%le\\\"\",\n                \"PRINT:nfp:AVERAGE:\\\"%le\\\"\"\n        };\n\n        Throwable t = null;\n        try {\n        \t((JRobinRrdStrategy)m_strategy).createGraphDef(new File(\"\"), command);\n        } catch (final org.jrobin.core.RrdException e) {\n        \tt = e;\n        }\n        assertNotNull(t);\n        \n    \tassertTrue(\"message was \" + t.getMessage(), t.getMessage().contains(\"Could not open \"));\n    \tassertTrue(\"message was \" + t.getMessage(), t.getMessage().contains(\"fe80:0000:0000:0000:0000:0000:0000:0000%5\"));\n    }","commit_id":"34ebdc8e011e4e14dd10070f8bdd643d6b76fda3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        // Make sure that AWT headless mode is enabled\n        System.setProperty(\"java.awt.headless\", \"true\");\n        \n        MockLogAppender.setupLogging();\n        \n        m_strategy = new JRobinRrdStrategy();\n\n        // Don't initialize by default since not all tests need it.\n        m_fileAnticipator = new FileAnticipator(false);\n    }","id":77075,"modified_method":"@Before\n    public void setUp() throws Exception {\n        // Make sure that AWT headless mode is enabled\n        System.setProperty(\"java.awt.headless\", \"true\");\n        \n        MockLogAppender.setupLogging(true, \"DEBUG\");\n        \n        m_strategy = new JRobinRrdStrategy();\n\n        // Don't initialize by default since not all tests need it.\n        m_fileAnticipator = new FileAnticipator(false);\n    }","commit_id":"34ebdc8e011e4e14dd10070f8bdd643d6b76fda3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void addAliasQName(QName aliasQName) {\n\t\t_aliasQNames.put(PortletQNameUtil.getKey(aliasQName), aliasQName);\n\t}","id":77076,"modified_method":"public void addAliasQName(QName aliasQName) {\n\t\t_qNames.add(aliasQName);\n\t}","commit_id":"fdd0b44c07ddbf5a4c7a311b675e1507b83e21cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public EventDefinitionImpl(\n\t\tQName qName, String valueType, PortletApp portletApp) {\n\n\t\t_qName = qName;\n\t\t_valueType = valueType;\n\t\t_portletApp = portletApp;\n\t}","id":77077,"modified_method":"public EventDefinitionImpl(\n\t\tQName qName, String valueType, PortletApp portletApp) {\n\n\t\t_qName = qName;\n\t\t_valueType = valueType;\n\t\t_portletApp = portletApp;\n\n\t\t_qNames = new HashSet<QName>();\n\n\t\t_qNames.add(_qName);\n\t}","commit_id":"fdd0b44c07ddbf5a4c7a311b675e1507b83e21cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _processEvents(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tList<Event> events)\n\t\tthrows PortletContainerException {\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tList<LayoutTypePortlet> layoutTypePortlets = getLayoutTypePortlets(\n\t\t\tlayout);\n\n\t\tfor (LayoutTypePortlet layoutTypePortlet : layoutTypePortlets) {\n\t\t\tList<Portlet> portlets = null;\n\n\t\t\ttry {\n\t\t\t\tportlets = layoutTypePortlet.getAllPortlets();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new PortletContainerException(e);\n\t\t\t}\n\n\t\t\tlayout = layoutTypePortlet.getLayout();\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tfor (Event event : events) {\n\t\t\t\t\tjavax.xml.namespace.QName qName = event.getQName();\n\n\t\t\t\t\tString namespaceURI = qName.getNamespaceURI();\n\t\t\t\t\tString localPart = qName.getLocalPart();\n\n\t\t\t\t\tQName processingQName = portlet.getProcessingEvent(\n\t\t\t\t\t\tnamespaceURI, localPart);\n\n\t\t\t\t\tif (processingQName != null) {\n\t\t\t\t\t\tprocessEvent(request, response, portlet, layout, event);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\t\t\t\t\tSet<EventDefinition> eventDefinitions =\n\t\t\t\t\t\t\tportletApp.getEventDefinitions();\n\n\t\t\t\t\t\tfor (EventDefinition eventDefinition :\n\t\t\t\t\t\t\t\teventDefinitions) {\n\n\t\t\t\t\t\t\tQName aliasQName = eventDefinition.getAliasQName(\n\t\t\t\t\t\t\t\tnamespaceURI, localPart);\n\n\t\t\t\t\t\t\tif (aliasQName == null) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tQName eventQName = eventDefinition.getQName();\n\n\t\t\t\t\t\t\tprocessingQName = portlet.getProcessingEvent(\n\t\t\t\t\t\t\t\teventQName.getNamespaceURI(),\n\t\t\t\t\t\t\t\teventQName.getLocalPart());\n\n\t\t\t\t\t\t\tif (processingQName == null) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLiferayEvent liferayEvent = (LiferayEvent)event;\n\n\t\t\t\t\t\t\tEvent aliasedEvent = liferayEvent.clone(qName);\n\n\t\t\t\t\t\t\tprocessEvent(\n\t\t\t\t\t\t\t\trequest, response, portlet, layout,\n\t\t\t\t\t\t\t\taliasedEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":77078,"modified_method":"private static void _processEvents(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tList<Event> events)\n\t\tthrows PortletContainerException {\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tList<LayoutTypePortlet> layoutTypePortlets = getLayoutTypePortlets(\n\t\t\tlayout);\n\n\t\tfor (LayoutTypePortlet layoutTypePortlet : layoutTypePortlets) {\n\t\t\tList<Portlet> portlets = null;\n\n\t\t\ttry {\n\t\t\t\tportlets = layoutTypePortlet.getAllPortlets();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new PortletContainerException(e);\n\t\t\t}\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tfor (Event event : events) {\n\t\t\t\t\tjavax.xml.namespace.QName qName = event.getQName();\n\n\t\t\t\t\tQName processingQName = portlet.getProcessingEvent(\n\t\t\t\t\t\tqName.getNamespaceURI(), qName.getLocalPart());\n\n\t\t\t\t\tif (processingQName == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessEvent(\n\t\t\t\t\t\trequest, response, portlet,\n\t\t\t\t\t\tlayoutTypePortlet.getLayout(), event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"fdd0b44c07ddbf5a4c7a311b675e1507b83e21cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _readPortletXML(\n\t\tString servletContextName, Map<String, Portlet> portletsPool,\n\t\tPluginPackage pluginPackage, PortletApp portletApp,\n\t\tSet<String> portletIds, long timestamp, Element portletElement) {\n\n\t\tString portletName = portletElement.elementText(\"portlet-name\");\n\n\t\tString portletId = portletName;\n\n\t\tif (Validator.isNotNull(servletContextName)) {\n\t\t\tportletId = portletId.concat(PortletConstants.WAR_SEPARATOR).concat(\n\t\t\t\tservletContextName);\n\t\t}\n\n\t\tportletId = PortalUtil.getJsSafePortletId(portletId);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Reading portlet \" + portletId);\n\t\t}\n\n\t\tportletIds.add(portletId);\n\n\t\tPortlet portletModel = portletsPool.get(portletId);\n\n\t\tif (portletModel == null) {\n\t\t\tportletModel = new PortletImpl(CompanyConstants.SYSTEM, portletId);\n\n\t\t\tportletsPool.put(portletId, portletModel);\n\t\t}\n\n\t\tportletModel.setTimestamp(timestamp);\n\n\t\tportletModel.setPluginPackage(pluginPackage);\n\t\tportletModel.setPortletApp(portletApp);\n\n\t\tportletModel.setPortletName(portletName);\n\t\tportletModel.setDisplayName(\n\t\t\tGetterUtil.getString(\n\t\t\t\tportletElement.elementText(\"display-name\"),\n\t\t\t\tportletModel.getDisplayName()));\n\t\tportletModel.setPortletClass(\n\t\t\tGetterUtil.getString(portletElement.elementText(\"portlet-class\")));\n\n\t\tMap<String, String> initParams = new HashMap<String, String>();\n\n\t\tfor (Element initParamElement : portletElement.elements(\"init-param\")) {\n\t\t\tinitParams.put(\n\t\t\t\tinitParamElement.elementText(\"name\"),\n\t\t\t\tinitParamElement.elementText(\"value\"));\n\t\t}\n\n\t\tportletModel.setInitParams(initParams);\n\n\t\tElement expirationCacheElement = portletElement.element(\n\t\t\t\"expiration-cache\");\n\n\t\tif (expirationCacheElement != null) {\n\t\t\tportletModel.setExpCache(\n\t\t\t\tGetterUtil.getInteger(expirationCacheElement.getText()));\n\t\t}\n\n\t\tMap<String, Set<String>> portletModes =\n\t\t\tnew HashMap<String, Set<String>>();\n\t\tMap<String, Set<String>> windowStates =\n\t\t\tnew HashMap<String, Set<String>>();\n\n\t\tfor (Element supportsElement : portletElement.elements(\"supports\")) {\n\t\t\tString mimeType = supportsElement.elementText(\"mime-type\");\n\n\t\t\tSet<String> mimeTypePortletModes = new HashSet<String>();\n\n\t\t\tmimeTypePortletModes.add(PortletMode.VIEW.toString().toLowerCase());\n\n\t\t\tfor (Element portletModeElement :\n\t\t\t\t\tsupportsElement.elements(\"portlet-mode\")) {\n\n\t\t\t\tmimeTypePortletModes.add(\n\t\t\t\t\tportletModeElement.getTextTrim().toLowerCase());\n\t\t\t}\n\n\t\t\tportletModes.put(mimeType, mimeTypePortletModes);\n\n\t\t\tSet<String> mimeTypeWindowStates = new HashSet<String>();\n\n\t\t\tmimeTypeWindowStates.add(\n\t\t\t\tWindowState.NORMAL.toString().toLowerCase());\n\n\t\t\tList<Element> windowStateElements = supportsElement.elements(\n\t\t\t\t\"window-state\");\n\n\t\t\tif (windowStateElements.isEmpty()) {\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tWindowState.MAXIMIZED.toString().toLowerCase());\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tWindowState.MINIMIZED.toString().toLowerCase());\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tLiferayWindowState.EXCLUSIVE.toString().toLowerCase());\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tLiferayWindowState.POP_UP.toString().toLowerCase());\n\t\t\t}\n\n\t\t\tfor (Element windowStateElement : windowStateElements) {\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\twindowStateElement.getTextTrim().toLowerCase());\n\t\t\t}\n\n\t\t\twindowStates.put(mimeType, mimeTypeWindowStates);\n\t\t}\n\n\t\tportletModel.setPortletModes(portletModes);\n\t\tportletModel.setWindowStates(windowStates);\n\n\t\tSet<String> supportedLocales = new HashSet<String>();\n\n\t\t//supportedLocales.add(\n\t\t//\tLocaleUtil.toLanguageId(LocaleUtil.getDefault()));\n\n\t\tfor (Element supportedLocaleElement : portletElement.elements(\n\t\t\t\t\"supported-locale\")) {\n\n\t\t\tString supportedLocale = supportedLocaleElement.getText();\n\n\t\t\tsupportedLocales.add(supportedLocale);\n\t\t}\n\n\t\tportletModel.setSupportedLocales(supportedLocales);\n\n\t\tportletModel.setResourceBundle(\n\t\t\tportletElement.elementText(\"resource-bundle\"));\n\n\t\tElement portletInfoElement = portletElement.element(\"portlet-info\");\n\n\t\tString portletInfoTitle = null;\n\t\tString portletInfoShortTitle = null;\n\t\tString portletInfoKeyWords = null;\n\t\tString portletInfoDescription = null;\n\n\t\tif (portletInfoElement != null) {\n\t\t\tportletInfoTitle = portletInfoElement.elementText(\"title\");\n\t\t\tportletInfoShortTitle = portletInfoElement.elementText(\n\t\t\t\t\"short-title\");\n\t\t\tportletInfoKeyWords = portletInfoElement.elementText(\"keywords\");\n\t\t}\n\n\t\tPortletInfo portletInfo = new PortletInfo(\n\t\t\tportletInfoTitle, portletInfoShortTitle, portletInfoKeyWords,\n\t\t\tportletInfoDescription);\n\n\t\tportletModel.setPortletInfo(portletInfo);\n\n\t\tElement portletPreferencesElement = portletElement.element(\n\t\t\t\"portlet-preferences\");\n\n\t\tString defaultPreferences = null;\n\t\tString preferencesValidator = null;\n\n\t\tif (portletPreferencesElement != null) {\n\t\t\tElement preferencesValidatorElement =\n\t\t\t\tportletPreferencesElement.element(\"preferences-validator\");\n\n\t\t\tif (preferencesValidatorElement != null) {\n\t\t\t\tpreferencesValidator = preferencesValidatorElement.getText();\n\n\t\t\t\tportletPreferencesElement.remove(preferencesValidatorElement);\n\t\t\t}\n\n\t\t\tdefaultPreferences = portletPreferencesElement.asXML();\n\t\t}\n\n\t\tportletModel.setDefaultPreferences(defaultPreferences);\n\t\tportletModel.setPreferencesValidator(preferencesValidator);\n\n\t\tif (!portletApp.isWARFile() &&\n\t\t\tValidator.isNotNull(preferencesValidator) &&\n\t\t\tPropsValues.PREFERENCE_VALIDATE_ON_STARTUP) {\n\n\t\t\ttry {\n\t\t\t\tPreferencesValidator preferencesValidatorObj =\n\t\t\t\t\tPortalUtil.getPreferencesValidator(portletModel);\n\n\t\t\t\tpreferencesValidatorObj.validate(\n\t\t\t\t\tPortletPreferencesFactoryUtil.fromDefaultXML(\n\t\t\t\t\t\tdefaultPreferences));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Portlet with the name \" + portletId +\n\t\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<String> unlinkedRoles = new HashSet<String>();\n\n\t\tfor (Element roleElement :\n\t\t\t\tportletElement.elements(\"security-role-ref\")) {\n\n\t\t\tunlinkedRoles.add(roleElement.elementText(\"role-name\"));\n\t\t}\n\n\t\tportletModel.setUnlinkedRoles(unlinkedRoles);\n\n\t\tSet<QName> processingEvents = new HashSet<QName>();\n\n\t\tfor (Element supportedProcessingEventElement :\n\t\t\t\tportletElement.elements(\"supported-processing-event\")) {\n\n\t\t\tElement qNameElement = supportedProcessingEventElement.element(\n\t\t\t\t\"qname\");\n\t\t\tElement nameElement = supportedProcessingEventElement.element(\n\t\t\t\t\"name\");\n\n\t\t\tQName qName = PortletQNameUtil.getQName(\n\t\t\t\tqNameElement, nameElement, portletApp.getDefaultNamespace());\n\n\t\t\tprocessingEvents.add(qName);\n\t\t}\n\n\t\tportletModel.setProcessingEvents(processingEvents);\n\n\t\tSet<QName> publishingEvents = new HashSet<QName>();\n\n\t\tfor (Element supportedPublishingEventElement :\n\t\t\t\tportletElement.elements(\"supported-publishing-event\")) {\n\n\t\t\tElement qNameElement = supportedPublishingEventElement.element(\n\t\t\t\t\"qname\");\n\t\t\tElement nameElement = supportedPublishingEventElement.element(\n\t\t\t\t\"name\");\n\n\t\t\tQName qName = PortletQNameUtil.getQName(\n\t\t\t\tqNameElement, nameElement, portletApp.getDefaultNamespace());\n\n\t\t\tpublishingEvents.add(qName);\n\t\t}\n\n\t\tportletModel.setPublishingEvents(publishingEvents);\n\n\t\tSet<PublicRenderParameter> publicRenderParameters =\n\t\t\tnew HashSet<PublicRenderParameter>();\n\n\t\tfor (Element supportedPublicRenderParameter :\n\t\t\t\tportletElement.elements(\"supported-public-render-parameter\")) {\n\n\t\t\tString identifier = supportedPublicRenderParameter.getTextTrim();\n\n\t\t\tPublicRenderParameter publicRenderParameter =\n\t\t\t\tportletApp.getPublicRenderParameter(identifier);\n\n\t\t\tif (publicRenderParameter == null) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Supported public render parameter references \" +\n\t\t\t\t\t\t\"unnknown identifier \" + identifier);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpublicRenderParameters.add(publicRenderParameter);\n\t\t}\n\n\t\tportletModel.setPublicRenderParameters(publicRenderParameters);\n\t}","id":77079,"modified_method":"private void _readPortletXML(\n\t\tString servletContextName, Map<String, Portlet> portletsPool,\n\t\tPluginPackage pluginPackage, PortletApp portletApp,\n\t\tSet<String> portletIds, long timestamp, Element portletElement) {\n\n\t\tString portletName = portletElement.elementText(\"portlet-name\");\n\n\t\tString portletId = portletName;\n\n\t\tif (Validator.isNotNull(servletContextName)) {\n\t\t\tportletId = portletId.concat(PortletConstants.WAR_SEPARATOR).concat(\n\t\t\t\tservletContextName);\n\t\t}\n\n\t\tportletId = PortalUtil.getJsSafePortletId(portletId);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Reading portlet \" + portletId);\n\t\t}\n\n\t\tportletIds.add(portletId);\n\n\t\tPortlet portletModel = portletsPool.get(portletId);\n\n\t\tif (portletModel == null) {\n\t\t\tportletModel = new PortletImpl(CompanyConstants.SYSTEM, portletId);\n\n\t\t\tportletsPool.put(portletId, portletModel);\n\t\t}\n\n\t\tportletModel.setTimestamp(timestamp);\n\n\t\tportletModel.setPluginPackage(pluginPackage);\n\t\tportletModel.setPortletApp(portletApp);\n\n\t\tportletModel.setPortletName(portletName);\n\t\tportletModel.setDisplayName(\n\t\t\tGetterUtil.getString(\n\t\t\t\tportletElement.elementText(\"display-name\"),\n\t\t\t\tportletModel.getDisplayName()));\n\t\tportletModel.setPortletClass(\n\t\t\tGetterUtil.getString(portletElement.elementText(\"portlet-class\")));\n\n\t\tMap<String, String> initParams = new HashMap<String, String>();\n\n\t\tfor (Element initParamElement : portletElement.elements(\"init-param\")) {\n\t\t\tinitParams.put(\n\t\t\t\tinitParamElement.elementText(\"name\"),\n\t\t\t\tinitParamElement.elementText(\"value\"));\n\t\t}\n\n\t\tportletModel.setInitParams(initParams);\n\n\t\tElement expirationCacheElement = portletElement.element(\n\t\t\t\"expiration-cache\");\n\n\t\tif (expirationCacheElement != null) {\n\t\t\tportletModel.setExpCache(\n\t\t\t\tGetterUtil.getInteger(expirationCacheElement.getText()));\n\t\t}\n\n\t\tMap<String, Set<String>> portletModes =\n\t\t\tnew HashMap<String, Set<String>>();\n\t\tMap<String, Set<String>> windowStates =\n\t\t\tnew HashMap<String, Set<String>>();\n\n\t\tfor (Element supportsElement : portletElement.elements(\"supports\")) {\n\t\t\tString mimeType = supportsElement.elementText(\"mime-type\");\n\n\t\t\tSet<String> mimeTypePortletModes = new HashSet<String>();\n\n\t\t\tmimeTypePortletModes.add(PortletMode.VIEW.toString().toLowerCase());\n\n\t\t\tfor (Element portletModeElement :\n\t\t\t\t\tsupportsElement.elements(\"portlet-mode\")) {\n\n\t\t\t\tmimeTypePortletModes.add(\n\t\t\t\t\tportletModeElement.getTextTrim().toLowerCase());\n\t\t\t}\n\n\t\t\tportletModes.put(mimeType, mimeTypePortletModes);\n\n\t\t\tSet<String> mimeTypeWindowStates = new HashSet<String>();\n\n\t\t\tmimeTypeWindowStates.add(\n\t\t\t\tWindowState.NORMAL.toString().toLowerCase());\n\n\t\t\tList<Element> windowStateElements = supportsElement.elements(\n\t\t\t\t\"window-state\");\n\n\t\t\tif (windowStateElements.isEmpty()) {\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tWindowState.MAXIMIZED.toString().toLowerCase());\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tWindowState.MINIMIZED.toString().toLowerCase());\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tLiferayWindowState.EXCLUSIVE.toString().toLowerCase());\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\tLiferayWindowState.POP_UP.toString().toLowerCase());\n\t\t\t}\n\n\t\t\tfor (Element windowStateElement : windowStateElements) {\n\t\t\t\tmimeTypeWindowStates.add(\n\t\t\t\t\twindowStateElement.getTextTrim().toLowerCase());\n\t\t\t}\n\n\t\t\twindowStates.put(mimeType, mimeTypeWindowStates);\n\t\t}\n\n\t\tportletModel.setPortletModes(portletModes);\n\t\tportletModel.setWindowStates(windowStates);\n\n\t\tSet<String> supportedLocales = new HashSet<String>();\n\n\t\t//supportedLocales.add(\n\t\t//\tLocaleUtil.toLanguageId(LocaleUtil.getDefault()));\n\n\t\tfor (Element supportedLocaleElement : portletElement.elements(\n\t\t\t\t\"supported-locale\")) {\n\n\t\t\tString supportedLocale = supportedLocaleElement.getText();\n\n\t\t\tsupportedLocales.add(supportedLocale);\n\t\t}\n\n\t\tportletModel.setSupportedLocales(supportedLocales);\n\n\t\tportletModel.setResourceBundle(\n\t\t\tportletElement.elementText(\"resource-bundle\"));\n\n\t\tElement portletInfoElement = portletElement.element(\"portlet-info\");\n\n\t\tString portletInfoTitle = null;\n\t\tString portletInfoShortTitle = null;\n\t\tString portletInfoKeyWords = null;\n\t\tString portletInfoDescription = null;\n\n\t\tif (portletInfoElement != null) {\n\t\t\tportletInfoTitle = portletInfoElement.elementText(\"title\");\n\t\t\tportletInfoShortTitle = portletInfoElement.elementText(\n\t\t\t\t\"short-title\");\n\t\t\tportletInfoKeyWords = portletInfoElement.elementText(\"keywords\");\n\t\t}\n\n\t\tPortletInfo portletInfo = new PortletInfo(\n\t\t\tportletInfoTitle, portletInfoShortTitle, portletInfoKeyWords,\n\t\t\tportletInfoDescription);\n\n\t\tportletModel.setPortletInfo(portletInfo);\n\n\t\tElement portletPreferencesElement = portletElement.element(\n\t\t\t\"portlet-preferences\");\n\n\t\tString defaultPreferences = null;\n\t\tString preferencesValidator = null;\n\n\t\tif (portletPreferencesElement != null) {\n\t\t\tElement preferencesValidatorElement =\n\t\t\t\tportletPreferencesElement.element(\"preferences-validator\");\n\n\t\t\tif (preferencesValidatorElement != null) {\n\t\t\t\tpreferencesValidator = preferencesValidatorElement.getText();\n\n\t\t\t\tportletPreferencesElement.remove(preferencesValidatorElement);\n\t\t\t}\n\n\t\t\tdefaultPreferences = portletPreferencesElement.asXML();\n\t\t}\n\n\t\tportletModel.setDefaultPreferences(defaultPreferences);\n\t\tportletModel.setPreferencesValidator(preferencesValidator);\n\n\t\tif (!portletApp.isWARFile() &&\n\t\t\tValidator.isNotNull(preferencesValidator) &&\n\t\t\tPropsValues.PREFERENCE_VALIDATE_ON_STARTUP) {\n\n\t\t\ttry {\n\t\t\t\tPreferencesValidator preferencesValidatorObj =\n\t\t\t\t\tPortalUtil.getPreferencesValidator(portletModel);\n\n\t\t\t\tpreferencesValidatorObj.validate(\n\t\t\t\t\tPortletPreferencesFactoryUtil.fromDefaultXML(\n\t\t\t\t\t\tdefaultPreferences));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Portlet with the name \" + portletId +\n\t\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<String> unlinkedRoles = new HashSet<String>();\n\n\t\tfor (Element roleElement :\n\t\t\t\tportletElement.elements(\"security-role-ref\")) {\n\n\t\t\tunlinkedRoles.add(roleElement.elementText(\"role-name\"));\n\t\t}\n\n\t\tportletModel.setUnlinkedRoles(unlinkedRoles);\n\n\t\tSet<QName> processingEvents = new HashSet<QName>();\n\n\t\tfor (Element supportedProcessingEventElement :\n\t\t\t\tportletElement.elements(\"supported-processing-event\")) {\n\n\t\t\tElement qNameElement = supportedProcessingEventElement.element(\n\t\t\t\t\"qname\");\n\t\t\tElement nameElement = supportedProcessingEventElement.element(\n\t\t\t\t\"name\");\n\n\t\t\tQName qName = PortletQNameUtil.getQName(\n\t\t\t\tqNameElement, nameElement, portletApp.getDefaultNamespace());\n\n\t\t\tprocessingEvents.add(qName);\n\n\t\t\tSet<EventDefinition> eventDefinitions =\n\t\t\t\tportletApp.getEventDefinitions();\n\n\t\t\tfor (EventDefinition eventDefinition : eventDefinitions) {\n\t\t\t\tSet<QName> qNames = eventDefinition.getQNames();\n\n\t\t\t\tif (qNames.contains(qName)) {\n\t\t\t\t\tprocessingEvents.addAll(qNames);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tportletModel.setProcessingEvents(processingEvents);\n\n\t\tSet<QName> publishingEvents = new HashSet<QName>();\n\n\t\tfor (Element supportedPublishingEventElement :\n\t\t\t\tportletElement.elements(\"supported-publishing-event\")) {\n\n\t\t\tElement qNameElement = supportedPublishingEventElement.element(\n\t\t\t\t\"qname\");\n\t\t\tElement nameElement = supportedPublishingEventElement.element(\n\t\t\t\t\"name\");\n\n\t\t\tQName qName = PortletQNameUtil.getQName(\n\t\t\t\tqNameElement, nameElement, portletApp.getDefaultNamespace());\n\n\t\t\tpublishingEvents.add(qName);\n\t\t}\n\n\t\tportletModel.setPublishingEvents(publishingEvents);\n\n\t\tSet<PublicRenderParameter> publicRenderParameters =\n\t\t\tnew HashSet<PublicRenderParameter>();\n\n\t\tfor (Element supportedPublicRenderParameter :\n\t\t\t\tportletElement.elements(\"supported-public-render-parameter\")) {\n\n\t\t\tString identifier = supportedPublicRenderParameter.getTextTrim();\n\n\t\t\tPublicRenderParameter publicRenderParameter =\n\t\t\t\tportletApp.getPublicRenderParameter(identifier);\n\n\t\t\tif (publicRenderParameter == null) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Supported public render parameter references \" +\n\t\t\t\t\t\t\"unnknown identifier \" + identifier);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpublicRenderParameters.add(publicRenderParameter);\n\t\t}\n\n\t\tportletModel.setPublicRenderParameters(publicRenderParameters);\n\t}","commit_id":"fdd0b44c07ddbf5a4c7a311b675e1507b83e21cb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public XMLResource getSchema(String targetNamespace) throws XMLDBException {\n\t\tString filename = getSchemaFilename(targetNamespace);\n\t\tif (filename != null)\n\t\t\treturn (XMLResource) getSchemasCollection().getResource(filename);\n\t\telse\n\t\t\treturn null;\n\t}","id":77080,"modified_method":"/**\n\t * Retrieves the schema as an XML resources.\n\t * @return the schema with targetNamespace or null if that schema is not known.\n\t */\n\tpublic XMLResource getSchema(String targetNamespace) throws XMLDBException {\n\t\tString filename = getSchemaFilename(targetNamespace);\n\t\tif (filename != null)\n\t\t\treturn (XMLResource) getSchemasCollection().getResource(filename);\n\t\telse\n\t\t\treturn null;\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"private XMLResource getIndexResource() throws XMLDBException {\n\t\tXMLResource index = null;\n\t\ttry {\n\t\t\tindex = (XMLResource) getSchemasCollection().getResource(INDEX_RESOURCE_NAME);\n\t\t} catch (XMLDBException e) {\n\t\t}\n\t\tif (index == null) {\n\t\t\tindex = (XMLResource) schemasCollection.createResource(INDEX_RESOURCE_NAME, \"XMLResource\");\n\t\t\tindex.setContent(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><schema-index/>\");\n\t\t\tgetSchemasCollection().storeResource(index);\n\t\t}\n\t\treturn index;\n\t}","id":77081,"modified_method":"/**\n\t * Test whether the index resource \".index\" already exists. If not, creates it and\n\t * fills it with skeleton contents. Returns the (possible newly created) resource.\n\t * @return\n\t * @throws XMLDBException\n\t */\n\tprotected XMLResource testAndCreateIndexResource() throws XMLDBException {\n\t\tXMLResource index = null;\n\t\ttry {\n\t\t\tindex = (XMLResource) getSchemasCollection().getResource(INDEX_RESOURCE_NAME);\n\t\t} catch (XMLDBException e) {\n\t\t}\n\t\tif (index == null) {\n\t\t\tindex = (XMLResource) schemasCollection.createResource(INDEX_RESOURCE_NAME, \"XMLResource\");\n\t\t\tindex.setContent(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><schema-index/>\");\n\t\t\tgetSchemasCollection().storeResource(index);\n\t\t}\n\t\treturn index;\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"private String getSchemaFilename(String targetNamespace) throws XMLDBException {\n\t\tif (targetNamespace == null)\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"null is not a valid namespace!\");\n\n\t\tXMLResource index = getIndexResource();\n\t\tString filename = null;\n\n\t\tNode root = index.getContentAsDOM();\n\n\t\tif (\"schema-index\".equals(root.getNodeName())) {\n\t\t\tNodeList schemas = root.getChildNodes();\n\t\t\tfor (int i = 0; i < schemas.getLength(); i++) {\n\t\t\t\tNode schema = schemas.item(i);\n\t\t\t\tif (\"schema\".equals(schema.getNodeName())) {\n\t\t\t\t\tNode targetNamespaceAttr = schema.getAttributes().getNamedItem(\"targetNamespace\");\n\t\t\t\t\tif ((targetNamespaceAttr != null) && (targetNamespace.equals(targetNamespaceAttr.getNodeValue())))\n\t\t\t\t\t\treturn schema.getAttributes().getNamedItem(\"resourceName\").getNodeValue();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"invalid schema index. Unexpected root element \" + root.getNodeName(), null);\n\t\t}\n\t\treturn filename;\n\t}","id":77082,"modified_method":"/**\n\t * Retrieve the filename of the resource that stores the schema for <code>targetNamespace<\/code>\n\t * @param targetNamespace\n\t * @return the resource name or null if the schema is not in the index.\n\t * @throws XMLDBException\n\t */\n  protected String getSchemaFilename(String targetNamespace) throws XMLDBException {\n    if (targetNamespace == null)\n      throw new XMLDBException(ErrorCodes.VENDOR_ERROR, \"null is not a valid namespace!\");\n    // make sure, the index resource exists:\n    testAndCreateIndexResource();\n    // try to find the name of the resource that stores the respective schema:  \n    String query = getRetrieveIndexRecordQuery(targetNamespace) + \"/@resourceName\";\n    ResourceSet set = getXQueryService().queryResource(INDEX_RESOURCE_NAME, query);\n    if (set.getSize() == 1) {\n      ResourceIterator iterator = set.getIterator();\n      return iterator.nextResource().getContent().toString();\n    } else if (set.getSize() == 0) {\n      return null;\n    } else\n      throw new XMLDBException(ErrorCodes.VENDOR_ERROR,\n          \"Multiple index entries for one targetNamespace in the schema index. The index is corrupt.\");\n  }","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"private String findTargetNamespace(String schemaContents) throws XMLDBException {\n\t\tString targetNamespace = null;\n\t\tDOMParser parser = new DOMParser();\n\t\ttry {\n\t\t\tparser.parse(new InputSource(new StringReader(schemaContents)));\n\t\t\tNode rootNode = parser.getDocument().getDocumentElement();\n\t\t\tNode targetNamespaceAttr = rootNode.getAttributes().getNamedItem(\"targetNamespace\");\n\t\t\tif (targetNamespaceAttr != null)\n\t\t\t\ttargetNamespace = targetNamespaceAttr.getNodeValue();\n\t\t} catch (SAXException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error parsing schema: \" + e.getMessage(), e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error parsing schema: \" + e.getMessage(), e);\n\t\t}\n\t\treturn targetNamespace;\n\t}","id":77083,"modified_method":"/**\n\t * Finds the target namespace in the given schema.\n\t * @param schemaContents\n\t * @return\n\t * @throws XMLDBException\n\t */\n\tprotected String findTargetNamespace(String schemaContents) throws XMLDBException {\n\t\tString targetNamespace = null;\n\t\tDOMParser parser = new DOMParser();\n\t\ttry {\n\t\t\tparser.parse(new InputSource(new StringReader(schemaContents)));\n\t\t\tNode rootNode = parser.getDocument().getDocumentElement();\n\t\t\tNode targetNamespaceAttr = rootNode.getAttributes().getNamedItem(\"targetNamespace\");\n\t\t\tif (targetNamespaceAttr != null)\n\t\t\t\ttargetNamespace = targetNamespaceAttr.getNodeValue();\n\t\t} catch (SAXException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error parsing schema: \" + e.getMessage(), e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error parsing schema: \" + e.getMessage(), e);\n\t\t}\n\t\treturn targetNamespace;\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @return the attribute by name qname or null if no such attribute is known.\n\t */\n\tpublic AttributeDecl getAttribute(QName qname) throws XMLDBException {\n\t\tString xquery =\n\t\t\t\"declare namespace xs=\\\"\"\n\t\t\t\t+ W3C_XML_SCHEMA\n\t\t\t\t+ \"\\\";\"\n\t\t\t\t+ \"/xs:schema[@targetNamespace=\\\"\"\n\t\t\t\t+ qname.getNamespaceURI()\n\t\t\t\t+ \"\\\"]/xs:attribute[@name=\\\"\"\n\t\t\t\t+ qname.getLocalPart()\n\t\t\t\t+ \"\\\"]\";\n\t\tXQueryService service = (XQueryService) getSchemasCollection().getService(\"XQueryService\", \"1.0\");\n\t\tResourceSet result = service.query(xquery);\n\t\tif (result.getSize() == 0)\n\t\t\treturn null;\n\t\telse if (result.getSize() > 1)\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Found multiple types by name \" + qname, null);\n\t\telse {\n\t\t\t//return result.getResource(0);\n\t\t\treturn null;\n\t\t}\n\t}","id":77084,"modified_method":"/**\n\t * @return the attribute by name qname or null if no such attribute is known.\n\t */\n\tpublic AttributeDecl getAttribute(QName qname) throws XMLDBException {\n\t\treturn getCastorSchema(qname.getNamespaceURI()).getAttribute(qname.getLocalPart());\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"public void putSchema(String schemaContents) throws XMLDBException {\n\n\t\tCollection schemasCollection = getSchemasCollection();\n\t\tString targetNamespace = findTargetNamespace(schemaContents);\n\t\tString filename = getSchemaFilename(targetNamespace);\n\t\tResource schemaResource = null;\n\t\tif (filename == null) {\n\t\t\tfilename = String.valueOf(System.currentTimeMillis());\n\t\t\tschemaResource = schemasCollection.createResource(filename, \"XMLResource\");\n\t\t\taddToIndex(targetNamespace, filename);\n\t\t} else\n\t\t\tschemaResource = (XMLResource) schemasCollection.getResource(filename);\n\t\tschemaResource.setContent(schemaContents);\n\t\tschemasCollection.storeResource(schemaResource);\n\t\tschemasCollection.close();\n\t}","id":77085,"modified_method":"/**\n\t * Add a schema to the schema store. The schema must have a target namespace because it can otherwise not\n\t * be indexed.\n\t */\n\tpublic void putSchema(String schemaContents) throws XMLDBException {\n\t\tCollection schemasCollection = getSchemasCollection();\n\t\tString targetNamespace = findTargetNamespace(schemaContents);\n\t\tString filename = getSchemaFilename(targetNamespace);\n\t\tResource schemaResource = null;\n\t\tif (filename == null) {\n\t\t\tfilename = String.valueOf(System.currentTimeMillis());\n\t\t\tschemaResource = schemasCollection.createResource(filename, \"XMLResource\");\n\t\t\taddToIndex(targetNamespace, filename);\n\t\t} else\n\t\t\tschemaResource = (XMLResource) schemasCollection.getResource(filename);\n\t\tschemaResource.setContent(schemaContents);\n\t\tschemasCollection.storeResource(schemaResource);\n\t\tschemasCollection.close();\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean validateContents(String contents) throws XMLDBException {\n\t\ttry {\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tfactory.setNamespaceAware(true);\n\t\t\tDocumentBuilder docBuilder = factory.newDocumentBuilder();\n\t\t\tValidationErrorHandler errorHandler = new ValidationErrorHandler();\n\t\t\tdocBuilder.setErrorHandler(errorHandler);\n\t\t\tDocument document = docBuilder.parse(new StringInputStream(contents));\n\t\t\tSet namespaces = new TreeSet();\n\t\t\tfindNamespaces(document.getDocumentElement(), namespaces);\n\t\t\tSchemaService schemaService = (SchemaService) getParentCollection().getService(\"SchemaService\", \"1.0\");\n\t\t\tArrayList schemas = new ArrayList();\n\t\t\tLOG.debug(\"Getting schemas for validation (\" + namespaces.size() + \"): \");\n\t\t\tfor (Iterator i = namespaces.iterator(); i.hasNext();) {\n\t\t\t\tString namespaceURI = (String) i.next();\n\t\t\t\tXMLResource resource = schemaService.getSchema(namespaceURI);\n\t\t\t\tif (resource != null) {\n\t\t\t\t\tschemas.add((String) resource.getContent());\n\t\t\t\t\tLOG.info(namespaceURI);\n\t\t\t\t} else\n\t\t\t\t\tLOG.warn(\"No schema for target namespace \" + namespaceURI + \" found.\");\n\t\t\t}\n\n\t\t\tfactory.setValidating(true);\n\t\t\ttry {\n\t\t\t\tfactory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\n\t\t\t\tInputSource[] schemaSources = new InputSource[schemas.size() + getTransientSchemas().size()];\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < schemas.size(); i++)\n\t\t\t\t\tschemaSources[i] = new InputSource(new StringReader((String) schemas.get(i)));\n\t\t\t\tfor (Iterator iter = getTransientSchemas().iterator(); iter.hasNext(); i++)\n\t\t\t\t\tschemaSources[i] = new InputSource(new StringReader((String) iter.next()));\n\t\t\t\tfactory.setAttribute(JAXP_SCHEMA_SOURCE, schemaSources);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Parser does not support JAXP 1.2\", e);\n\t\t\t}\n\t\t\tdocBuilder = factory.newDocumentBuilder();\n\t\t\tdocBuilder.setErrorHandler(errorHandler);\n\t\t\tdocBuilder.parse(new StringInputStream(contents));\n\t\t\tif (errorHandler.getErrors().size() > 0)\n\t\t\t\tthrow errorHandler.toException();\n\t\t\treturn true;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Parser config error validating contents.\", e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"SAX error reading contents.\", e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"IO error reading contents\", e);\n\t\t}\n\t}","id":77086,"modified_method":"/**\n\t * Validates the passed contents. Schemas are automatically obtained from the schema store. You can\n\t * add transient (\"temporary\") schemas with the <code>registerTransientSchema<\/code> method.\n\t * @throws XMLDBException if a database error occurs or the contents contains validation errors (these are\n\t * wrapped in XMLDBExceptions).\n\t */\n\tpublic boolean validateContents(String contents) throws XMLDBException {\n\t\ttry {\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tfactory.setNamespaceAware(true);\n\t\t\tDocumentBuilder docBuilder = factory.newDocumentBuilder();\n\t\t\tValidationErrorHandler errorHandler = new ValidationErrorHandler();\n\t\t\tdocBuilder.setErrorHandler(errorHandler);\n\t\t\tDocument document = docBuilder.parse(new StringInputStream(contents));\n\t\t\tSet namespaces = new TreeSet();\n\t\t\tfindNamespaces(document.getDocumentElement(), namespaces);\n\t\t\tSchemaService schemaService = (SchemaService) getParentCollection().getService(\"SchemaService\", \"1.0\");\n\t\t\tArrayList schemas = new ArrayList();\n\t\t\tLOG.debug(\"Getting schemas for validation (\" + namespaces.size() + \"): \");\n\t\t\tfor (Iterator i = namespaces.iterator(); i.hasNext();) {\n\t\t\t\tString namespaceURI = (String) i.next();\n\t\t\t\tXMLResource resource = schemaService.getSchema(namespaceURI);\n\t\t\t\tif (resource != null) {\n\t\t\t\t\tschemas.add((String) resource.getContent());\n\t\t\t\t\tLOG.info(namespaceURI);\n\t\t\t\t} else\n\t\t\t\t\tLOG.warn(\"No schema for target namespace \" + namespaceURI + \" found.\");\n\t\t\t}\n\n\t\t\tfactory.setValidating(true);\n\t\t\ttry {\n\t\t\t\tfactory.setAttribute(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);\n\t\t\t\tInputSource[] schemaSources = new InputSource[schemas.size() + getTransientSchemas().size()];\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < schemas.size(); i++)\n\t\t\t\t\tschemaSources[i] = new InputSource(new StringReader((String) schemas.get(i)));\n\t\t\t\tfor (Iterator iter = getTransientSchemas().iterator(); iter.hasNext(); i++)\n\t\t\t\t\tschemaSources[i] = new InputSource(new StringReader((String) iter.next()));\n\t\t\t\tfactory.setAttribute(JAXP_SCHEMA_SOURCE, schemaSources);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Parser does not support JAXP 1.2\", e);\n\t\t\t}\n\t\t\tdocBuilder = factory.newDocumentBuilder();\n\t\t\tdocBuilder.setErrorHandler(errorHandler);\n\t\t\tdocBuilder.parse(new StringInputStream(contents));\n\t\t\tif (errorHandler.getErrors().size() > 0)\n\t\t\t\tthrow errorHandler.toException();\n\t\t\treturn true;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Parser config error validating contents.\", e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"SAX error reading contents.\", e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"IO error reading contents\", e);\n\t\t}\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"private void addToIndex(String targetNamespace, String filename) throws XMLDBException {\n\t\tXMLResource index = getIndexResource();\n\t\tNode rootNode = index.getContentAsDOM();\n\t\tDocument doc = rootNode.getOwnerDocument();\n\t\tElement schemaNode = doc.createElement(\"schema\");\n//\t\tAttr targetNamespaceAttr = doc.createAttribute(\"targetNamespace\");\n//\t\t// jmv: targetNamespaceAttr.setNodeValue(targetNamespace);\n//\t\ttargetNamespaceAttr.setValue(targetNamespace); // jmv\n//\t\tAttr resourceNameAttr = doc.createAttribute(\"resourceName\");\n//\t\tresourceNameAttr.setValue(filename); // jmv\n//\t\tschemaNode.getAttributes().setNamedItem(targetNamespaceAttr);\n//\t\tschemaNode.getAttributes().setNamedItem(resourceNameAttr);\n\t\tschemaNode.setAttribute(\"targetNamespace\", targetNamespace);\n\t\tschemaNode.setAttribute(\"resourceName\", filename);\n\t\t\n\t\trootNode.appendChild(schemaNode);\n\t\tindex.setContentAsDOM(rootNode);\n\t\tgetSchemasCollection().storeResource(index); // jmv: this doesn't update the .index document ???!!!\n\t}","id":77087,"modified_method":"/**\n\t * Insert a new element in the schema-index. This method is called only if a new schema with a previously\n\t * unknown target namespace is indexed. Known schemas are indexed by updating the existent resource.  \n\t * @param targetNamespace of the schema\n\t * @param resourceName the name of the resource that stores the schema\n\t * @throws XMLDBException\n\t *\n   */\n  protected void addToIndex(String targetNamespace, String resourceName) throws XMLDBException {\n    getXUpdateService().update(getAppendSchemaXUpdate(targetNamespace, resourceName));\n  }","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @return the element by name qname or null if no such element is known.\n\t */\n\tpublic ElementDecl getElement(QName qname) throws XMLDBException {\n\t\tString xquery =\n\t\t\t\"declare namespace xs=\\\"\"\n\t\t\t\t+ W3C_XML_SCHEMA\n\t\t\t\t+ \"\\\";\"\n\t\t\t\t+ \"/xs:schema[@targetNamespace=\\\"\"\n\t\t\t\t+ qname.getNamespaceURI()\n\t\t\t\t+ \"\\\"]/xs:element[@name=\\\"\"\n\t\t\t\t+ qname.getLocalPart()\n\t\t\t\t+ \"\\\"]\";\n\t\tXQueryService service = (XQueryService) getSchemasCollection().getService(\"XQueryService\", \"1.0\");\n\t\tResourceSet result = service.query(xquery);\n\t\tif (result.getSize() == 0)\n\t\t\treturn null;\n\t\telse if (result.getSize() > 1)\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Found multiple types by name \" + qname, null);\n\t\telse {\n\t\t\t//return result.getResource(0);\n\t\t\treturn null;\n\t\t}\n\t}","id":77088,"modified_method":"/**\n\t * @return the element by name qname or null if no such element is known.\n\t */\n\tpublic ElementDecl getElement(QName qname) throws XMLDBException {\n\t\treturn getCastorSchema(qname.getNamespaceURI()).getElementDecl(qname.getLocalPart());\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean validateResource(String id) throws XMLDBException {\n\t\tResource doc = getParentCollection().getResource(id);\n\t\tif ((\"XMLResource\".equals(doc.getResourceType())) || (\"XMLView\".equals(doc.getResourceType()))) {\n\t\t\tXMLResource xmlResource = (XMLResource) doc;\n\t\t\tNode root = xmlResource.getContentAsDOM();\n\t\t\ttry {\n\t\t\t\treturn validateContents((String) xmlResource.getContent());\n\t\t\t} catch (XMLDBException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error validating resource \" + id, e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new XMLDBException(\n\t\t\t\tErrorCodes.WRONG_CONTENT_TYPE,\n\t\t\t\t\"Can only validate XML documents, but \" + id + \" is a \" + doc.getResourceType(),\n\t\t\t\tnull);\n\t\t}\n\t}","id":77089,"modified_method":"/**\n\t * Validates a resource given its id. Uses <code>validateContents<\/code>.\n\t */\n\tpublic boolean validateResource(String id) throws XMLDBException {\n\t\tResource doc = getParentCollection().getResource(id);\n\t\tif ((\"XMLResource\".equals(doc.getResourceType())) || (\"XMLView\".equals(doc.getResourceType()))) {\n\t\t\tXMLResource xmlResource = (XMLResource) doc;\n\t\t\tNode root = xmlResource.getContentAsDOM();\n\t\t\ttry {\n\t\t\t\treturn validateContents((String) xmlResource.getContent());\n\t\t\t} catch (XMLDBException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error validating resource \" + id, e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new XMLDBException(\n\t\t\t\tErrorCodes.WRONG_CONTENT_TYPE,\n\t\t\t\t\"Can only validate XML documents, but \" + id + \" is a \" + doc.getResourceType(),\n\t\t\t\tnull);\n\t\t}\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"private Collection getSchemasCollection() throws XMLDBException {\n\t\tif (schemasCollection == null) {\n\t\t\tCollection parent = getParentCollection();\n\t\t\twhile (parent.getParentCollection() != null)\n\t\t\t\tparent = parent.getParentCollection();\n\n\t\t\tschemasCollection = parent.getChildCollection(\"system\").getChildCollection(\"schema\");\n\t\t\tif (schemasCollection == null) {\n\t\t\t\tCollectionManagementService cms =\n\t\t\t\t\t(CollectionManagementService) getParentCollection().getService(\"CollectionManagementService\", \"1.0\");\n\t\t\t\tif (cms != null) {\n\t\t\t\t\tcms.setCollection(parent.getChildCollection(\"system\"));\n\t\t\t\t\tschemasCollection = cms.createCollection(\"schema\");\n\t\t\t\t} else {\n\t\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Could not get CollectionManagementService.\", null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn schemasCollection;\n\t}","id":77090,"modified_method":"protected Collection getSchemasCollection() throws XMLDBException {\n\t\tif (schemasCollection == null) {\n\t\t\tCollection parent = getParentCollection();\n\t\t\twhile (parent.getParentCollection() != null)\n\t\t\t\tparent = parent.getParentCollection();\n\n\t\t\tschemasCollection = parent.getChildCollection(\"system\").getChildCollection(\"schema\");\n\t\t\tif (schemasCollection == null) {\n\t\t\t\tCollectionManagementService cms =\n\t\t\t\t\t(CollectionManagementService) getParentCollection().getService(\"CollectionManagementService\", \"1.0\");\n\t\t\t\tif (cms != null) {\n\t\t\t\t\tcms.setCollection(parent.getChildCollection(\"system\"));\n\t\t\t\t\tschemasCollection = cms.createCollection(\"schema\");\n\t\t\t\t} else {\n\t\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Could not get CollectionManagementService.\", null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn schemasCollection;\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @return the type-definition by name qname or null if no such type-definition is known.\n\t */\n\tpublic XMLType getType(QName qname) throws XMLDBException {\n\t\t/*String xquery = \"declare namespace xs=\\\"\" + W3C_XML_SCHEMA + \"\\\";\" + \n\t\t\t\"/xs:schema[@targetNamespace=\\\"\" + qname.getNamespaceURI() + \n\t\t\t\"\\\"]/(xs:complexType|xs:simpleType)[@name=\\\"\" + qname.getLocalPart() + \"\\\"]\";\n\t\tXQueryService service = (XQueryService) getSchemasCollection().getService(\"XQueryService\", \"1.0\");\n\t\tResourceSet result = service.query(xquery);\n\t\tif (result.getSize() == 0) return null;\n\t\telse if (result.getSize() > 1) throw new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Found multiple types by name \" + qname, null);\n\t\telse {\n\t\t\t//return result.getResource(0);\n\t\t\treturn new Object();\t\t\t\n\t\t}*/\n\t\tXMLResource resource = getSchema(qname.getNamespaceURI());\n\t\ttry {\n\t\t\tSchema schema = (new SchemaReader((String) resource.getContent())).read();\n\t\t\treturn schema.getType(qname.getLocalPart());\n\t\t} catch (IOException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, \"Error reading schema information for target namespace: \" + qname.getNamespaceURI(), e);\n\t\t}\n\t}","id":77091,"modified_method":"/**\n\t * @return the type-definition by name qname or null if no such type-definition is known.\n\t */\n\tpublic XMLType getType(QName qname) throws XMLDBException {\n\t\treturn getCastorSchema(qname.getNamespaceURI()).getType(qname.getLocalPart());\n\t}","commit_id":"a4701b11e36b025643bf48271d7c04c18ba331cc","url":"https://github.com/eXist-db/exist"},{"original_method":"private double compute_auc() {\n    if (_fps[_nBins-1] == 0) return 1.0; //special case\n\n    // All math is computed scaled by TP and FP.  We'll descale once at the\n    // end.  Trapezoids from (tps[i-1],fps[i-1]) to (tps[i],fps[i])\n    double tp0 = 0, fp0 = 0;\n    double area = 0;\n    for( int i=0; i<_nBins; i++ ) {\n      area += (_fps[i]-fp0)*(_tps[i]+tp0)/2.0; // Trapezoid\n      tp0 = _tps[i];  fp0 = _fps[i];\n    }\n    // Descale\n    return area/_p/_n;\n  }","id":77092,"modified_method":"private double compute_auc() {\n    if (_fps[_nBins-1] == 0) return 1.0; //special case\n    if (_tps[_nBins-1] == 0) return 0.0; //special case\n\n    // All math is computed scaled by TP and FP.  We'll descale once at the\n    // end.  Trapezoids from (tps[i-1],fps[i-1]) to (tps[i],fps[i])\n    double tp0 = 0, fp0 = 0;\n    double area = 0;\n    for( int i=0; i<_nBins; i++ ) {\n      area += (_fps[i]-fp0)*(_tps[i]+tp0)/2.0; // Trapezoid\n      tp0 = _tps[i];  fp0 = _fps[i];\n    }\n    // Descale\n    return area/_p/_n;\n  }","commit_id":"fcda60d9ec8df230b0372e43f8912ff4527ec6d4","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** @return the error of the default CM */\n  public double defaultErr( ) { return ((double)fp(_max_idx)+fn(_max_idx))/(_p+_n); }","id":77093,"modified_method":"/** @return the error of the default CM */\n  public double defaultErr( ) { return _max_idx == -1 ? Double.NaN : (fp(_max_idx)+fn(_max_idx))/(_p+_n); }","commit_id":"fcda60d9ec8df230b0372e43f8912ff4527ec6d4","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public AUC2( AUCBuilder bldr ) { \n    // Copy result arrays into base object, shrinking to match actual bins\n    _nBins = bldr._n;\n    _ths = Arrays.copyOf(bldr._ths,_nBins);\n    _tps = Arrays.copyOf(bldr._tps,_nBins);\n    _fps = Arrays.copyOf(bldr._fps,_nBins);\n    // Reverse everybody; thresholds from 1 down to 0, easier to read\n    for( int i=0; i<((_nBins)>>1); i++ ) {\n      double tmp= _ths[i];  _ths[i] = _ths[_nBins-1-i]; _ths[_nBins-1-i] = tmp ;\n      double tmpt = _tps[i];  _tps[i] = _tps[_nBins-1-i]; _tps[_nBins-1-i] = tmpt;\n      double tmpf = _fps[i];  _fps[i] = _fps[_nBins-1-i]; _fps[_nBins-1-i] = tmpf;\n    }\n\n    // Rollup counts, so that computing the rates are easier.\n    // The AUC is (TPR,FPR) as the thresholds roll about\n    long p=0, n=0;\n    for( int i=0; i<_nBins; i++ ) { \n      p += _tps[i]; _tps[i] = p;\n      n += _fps[i]; _fps[i] = n;\n    }\n    _p = p;  _n = n;\n    _auc = compute_auc();\n    _gini = 2*_auc-1;\n    _max_idx = DEFAULT_CM.max_criterion_idx(this);\n  }","id":77094,"modified_method":"public AUC2( AUCBuilder bldr ) { \n    // Copy result arrays into base object, shrinking to match actual bins\n    _nBins = bldr._n;\n    _ths = Arrays.copyOf(bldr._ths,_nBins);\n    _tps = Arrays.copyOf(bldr._tps,_nBins);\n    _fps = Arrays.copyOf(bldr._fps,_nBins);\n    // Reverse everybody; thresholds from 1 down to 0, easier to read\n    for( int i=0; i<((_nBins)>>1); i++ ) {\n      double tmp= _ths[i];  _ths[i] = _ths[_nBins-1-i]; _ths[_nBins-1-i] = tmp ;\n      double tmpt = _tps[i];  _tps[i] = _tps[_nBins-1-i]; _tps[_nBins-1-i] = tmpt;\n      double tmpf = _fps[i];  _fps[i] = _fps[_nBins-1-i]; _fps[_nBins-1-i] = tmpf;\n    }\n\n    // Rollup counts, so that computing the rates are easier.\n    // The AUC is (TPR,FPR) as the thresholds roll about\n    double p=0, n=0;\n    for( int i=0; i<_nBins; i++ ) { \n      p += _tps[i]; _tps[i] = p;\n      n += _fps[i]; _fps[i] = n;\n    }\n    _p = p;  _n = n;\n    _auc = compute_auc();\n    _gini = 2*_auc-1;\n    _max_idx = DEFAULT_CM.max_criterion_idx(this);\n  }","commit_id":"fcda60d9ec8df230b0372e43f8912ff4527ec6d4","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public final void map(Chunk [] chunks, NewChunk [] outputs){\n    if(_jobKey != null && !Job.isRunning(_jobKey))throw new JobCancelledException();\n    final int nrows = chunks[0]._len;\n    final long offset = chunks[0].start();\n    chunkInit();\n\n    Random skip_rng = null; //random generator for skipping rows\n\n    //Example:\n    // _useFraction = 0.8 -> 1 repeat with fraction = 0.8\n    // _useFraction = 1.0 -> 1 repeat with fraction = 1.0\n    // _useFraction = 1.1 -> 2 repeats with fraction = 0.55\n    // _useFraction = 2.1 -> 3 repeats with fraction = 0.7\n    // _useFraction = 3.0 -> 3 repeats with fraction = 1.0\n    final int repeats = (int)Math.ceil(_useFraction);\n    final float fraction = _useFraction / repeats;\n\n    // have non-trivial ?\n    final boolean nontrivial_weights = _dinfo._weights && !_dinfo._adaptedFrame.vecs()[_dinfo.weightChunkId()].isConst();\n\n    if (fraction < 1.0 || nontrivial_weights) {\n      skip_rng = RandomUtils.getRNG(_seed+offset);\n    }\n    long[] shuf_map = null;\n    if (_shuffle && !nontrivial_weights) { //we are already shuffling when using nontrivial_weights\n      shuf_map = new long[nrows];\n      for (int i=0;i<nrows;++i)\n        shuf_map[i] = i;\n      ArrayUtils.shuffleArray(shuf_map, new Random(_seed+offset).nextLong());\n    }\n    DataInfo.Row row = _dinfo.newDenseRow();\n    float[] weight_map = null;\n    float weight_sum;\n    //TODO: store node-local helper arrays in _dinfo -> avoid re-allocation and construction\n    if (nontrivial_weights) {\n      weight_map = new float[nrows];\n      weight_sum = 0;\n      for (int i=0;i<nrows;++i) {\n        row = _dinfo.extractDenseRow(chunks, i, row);\n        weight_sum+=row.weight;\n        weight_map[i]=weight_sum;\n      }\n      if (weight_sum > 0)\n        ArrayUtils.div(weight_map, weight_sum); //normalize to 0...1\n      else return; //nothing to do here - all rows have 0 weight\n    }\n\n    double num_processed_rows = 0;\n    for(int rrr = 0; rrr < repeats; ++rrr) {\n      OUTER:\n      for(int rr = 0; rr < nrows; ++rr){\n        int r = 0; //index of local training row in this chunk to process\n\n        // only train with a given number of training samples (fraction*nrows)\n        if (skip_rng != null && skip_rng.nextFloat() > fraction) {\n          // we need to pick at least one row per map pass\n          if (rrr==repeats-1 && rr==nrows-1 && num_processed_rows == 0) {\n            r = -1; //marker\n          } else {\n            continue; //toss of coin\n          }\n        }\n\n        if (nontrivial_weights) {\n          // importance sampling based on inverse of cumulative distribution\n          float key = skip_rng.nextFloat();\n          r = Arrays.binarySearch(weight_map, 0, nrows, key);\n//          Log.info(Arrays.toString(weight_map));\n//          Log.info(\"key: \" + key + \" idx: \" + (r >= 0 ? r : (-r-1)));\n          if (r<0) r=-r-1;\n        } else if (r == -1){\n          // uniformly pick one row\n          r = skip_rng.nextInt(nrows);\n        } else if (r != -1){\n          r = shuf_map != null ? (int) shuf_map[rr] : rr;\n        }\n        assert(r >= 0 && r<=nrows);\n\n        row = _dinfo.extractDenseRow(chunks, r, row);\n        if(!row.bad) {\n          long seed = offset + rrr * nrows + r;\n          if (outputs != null && outputs.length > 0)\n            processRow(seed++, row, outputs);\n          else\n            processRow(seed++, row);\n        }\n        assert(row.weight > 0); //check that we never process a row that was held out via row.weight = 0\n        num_processed_rows += row.weight;\n      }\n    }\n    chunkDone(num_processed_rows);\n  }","id":77095,"modified_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public final void map(Chunk [] chunks, NewChunk [] outputs){\n    if(_jobKey != null && !Job.isRunning(_jobKey))throw new JobCancelledException();\n    final int nrows = chunks[0]._len;\n    final long offset = chunks[0].start();\n    chunkInit();\n\n    Random skip_rng = null; //random generator for skipping rows\n\n    final boolean nontrivial_weights = _dinfo._weights && !_dinfo._adaptedFrame.vecs()[_dinfo.weightChunkId()].isConst();\n    final double global_weight_sum = nontrivial_weights ? _dinfo._adaptedFrame.vecs()[_dinfo.weightChunkId()].mean() * _dinfo._adaptedFrame.numRows() : 0;\n\n    DataInfo.Row row = _dinfo.newDenseRow();\n    double[] weight_map = null;\n    double relative_chunk_weight = 1;\n    //TODO: store node-local helper arrays in _dinfo -> avoid re-allocation and construction\n    if (nontrivial_weights) {\n      weight_map = new double[nrows];\n      double weight_sum = 0;\n      for (int i=0;i<nrows;++i) {\n        row = _dinfo.extractDenseRow(chunks, i, row);\n        weight_sum+=row.weight;\n        weight_map[i]=weight_sum;\n        assert(i == 0 || weight_map[i] > weight_map[i-1]);\n      }\n      if (weight_sum > 0) {\n        ArrayUtils.div(weight_map, weight_sum); //normalize to 0...1\n        relative_chunk_weight = global_weight_sum / _dinfo._adaptedFrame.anyVec().nChunks() / weight_sum;\n      }\n      else return; //nothing to do here - all rows have 0 weight\n    }\n\n    //Example:\n    // _useFraction = 0.8 -> 1 repeat with fraction = 0.8\n    // _useFraction = 1.0 -> 1 repeat with fraction = 1.0\n    // _useFraction = 1.1 -> 2 repeats with fraction = 0.55\n    // _useFraction = 2.1 -> 3 repeats with fraction = 0.7\n    // _useFraction = 3.0 -> 3 repeats with fraction = 1.0\n    final int repeats = (int)Math.ceil(_useFraction * relative_chunk_weight);\n    final float fraction = (float)(_useFraction * relative_chunk_weight) / repeats;\n    assert(fraction <= 1.0);\n\n    if (fraction < 1.0 || nontrivial_weights) {\n      skip_rng = RandomUtils.getRNG(_seed+offset);\n    }\n\n    double num_processed_rows = 0;\n    for(int rep = 0; rep < repeats; ++rep) {\n      for(int row_idx = 0; row_idx < nrows; ++row_idx){\n        int r = _shuffle ? -1 : 0;\n\n        // only train with a given number of training samples (fraction*nrows)\n        if (skip_rng != null && skip_rng.nextDouble() > fraction) {\n          // we need to pick at least one row per map pass\n          if (rep==repeats-1 && row_idx==nrows-1 && num_processed_rows == 0) {\n            r = -1; //do random sampling\n          } else {\n            continue;\n          }\n        }\n\n        if (nontrivial_weights) { // && row_idx % 2 == 0) { //every second row is totally random\n          // importance sampling based on inverse of cumulative distribution\n          double key = skip_rng.nextDouble();\n          r = Arrays.binarySearch(weight_map, 0, nrows, key);\n//          Log.info(Arrays.toString(weight_map));\n//          Log.info(\"key: \" + key + \" idx: \" + (r >= 0 ? r : (-r-1)));\n          if (r<0) r=-r-1;\n        } else if (r == -1){\n          r = skip_rng.nextInt(nrows); //random sampling (with replacement)\n        } else {\n          r = row_idx; //linear scan - slightly faster\n        }\n        assert(r >= 0 && r<=nrows);\n\n        row = _dinfo.extractDenseRow(chunks, r, row);\n        if(!row.bad) {\n          long seed = offset + rep * nrows + r;\n          if (outputs != null && outputs.length > 0)\n            processRow(seed++, row, outputs);\n          else\n            processRow(seed++, row);\n        }\n        assert(row.weight > 0); //check that we never process a row that was held out via row.weight = 0\n        num_processed_rows += row.weight;\n      }\n    }\n    chunkDone(num_processed_rows);\n  }","commit_id":"fcda60d9ec8df230b0372e43f8912ff4527ec6d4","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected float[] score0(double[] data, float[] preds) {\n      float sum = 0;\n      float[] p = super.score0(data, preds);\n      if (nclasses()>1) { // classification\n        for(int k=0; k<p.length;k++)\n          sum+=(p[k]=(float)Math.exp(p[k]));\n        if( !Float.isInfinite(sum) ) div(p,sum);\n        else {                  // Math.exp leads to Infinities alot...\n          // If one of the probs was large and the others all small, the\n          // Math.exp shot up to infinity... and the division will bring us\n          // back down to a single 1.0 and the rest 0.0.\n          boolean only_one=false;\n          for(int k=0; k<p.length;k++)\n            if( Float.isInfinite(p[k])) {\n              assert !only_one;  only_one = true;\n              p[k] = 1.0f;      // Class predicts spot on\n            } else p[k]=0.0f;   // Anything divided by infinity\n        }\n      } else { // regression\n        // do nothing for regression\n      }\n      return p;\n    }","id":77096,"modified_method":"@Override protected float[] score0(double[] data, float[] preds) {\n      float sum = 0;\n      float[] p = super.score0(data, preds);\n      if (nclasses()>1) { // classification\n        // Because we call Math.exp, we have to be numerically stable or else\n        // we get Infinities, and then shortly NaN's.  Rescale the data so the\n        // largest value is +/-1 and the other values are smaller.  \n        float rescale=0; \n        for(int k=0; k<p.length;k++) rescale = Math.max(rescale,Math.abs(p[k]));\n        if( rescale < 1.0f ) rescale=1.0f;\n        float dsum=0;\n        for(int k=0; k<p.length;k++)\n          dsum+=(p[k]=(float)Math.exp(p[k]/rescale));\n        div(p,dsum);\n      } else { // regression\n        // do nothing for regression\n      }\n      return p;\n    }","commit_id":"9abac0d67a329a9d39b0b313c4b0f3abfc5e3300","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n     * Helper method for the rejoin process. This is called by nodes inside the cluster\n     * to initiate a connection to nodes re-joining the cluster.\n     *\n     * @param hostId The calling node's host id.\n     * @param address The address the re-joining node is listening on.\n     * @return A connected SocketChannel to the re-joining node, or null on failure.\n     */\n    static SocketChannel connect(int hostId, InetSocketAddress address) {\n        SocketChannel remoteConnection = null;\n        try {\n            // open a connection to the re-joining node\n            remoteConnection = SocketChannel.open(address);\n\n            // create helper streams for IO\n            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(remoteConnection.socket().getOutputStream()));\n            DataInputStream in = new DataInputStream(new BufferedInputStream(remoteConnection.socket().getInputStream()));\n\n            // write the id of this host\n            out.writeInt(hostId);\n            out.flush();\n\n            // read in the command to acknowledge connection and to request the time\n            int command = in.readInt();\n            if (command != COMMAND_SENDTIME_AND_CRC)\n                throw new Exception(String.format(\"Unexpected command (%d) from joining node.\", command));\n\n            // write the current time so the re-join node can measure skew\n            out.writeLong(System.currentTimeMillis());\n            out.flush();\n\n            // read the confirmation command\n            long maxDiffMS = in.readLong();\n            System.out.printf(\"Re-joining node reports %d ms skew.\\n\", maxDiffMS);\n            command = in.readInt();\n            if (command == COMMAND_COMPLETE)\n                return remoteConnection;\n            else {\n                String msg = String.format(\"Unable to re-join node. Error No. %d.\", command);\n                throw new Exception(msg);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            remoteConnection = null;\n        }\n        return remoteConnection;\n    }","id":77097,"modified_method":"/**\n     * Helper method for the rejoin process. This is called by nodes inside the cluster\n     * to initiate a connection to nodes re-joining the cluster.\n     *\n     * @param hostId The calling node's host id.\n     * @param address The address the re-joining node is listening on.\n     * @return A connected SocketChannel to the re-joining node, or null on failure.\n     */\n    static SocketChannel connect(int hostId, InetSocketAddress address) {\n        SocketChannel remoteConnection = null;\n        try {\n            // open a connection to the re-joining node\n            remoteConnection = SocketChannel.open(address);\n            remoteConnection.socket().setSoTimeout(1000);\n\n            // create helper streams for IO\n            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(remoteConnection.socket().getOutputStream()));\n            DataInputStream in = new DataInputStream(new BufferedInputStream(remoteConnection.socket().getInputStream()));\n\n            // write the id of this host\n            out.writeInt(hostId);\n            out.flush();\n\n            // read in the command to acknowledge connection and to request the time\n            int command = in.readInt();\n            if (command != COMMAND_SENDTIME_AND_CRC)\n                throw new Exception(String.format(\"Unexpected command (%d) from joining node.\", command));\n\n            // write the current time so the re-join node can measure skew\n            out.writeLong(System.currentTimeMillis());\n            out.flush();\n\n            // read the confirmation command\n            long maxDiffMS = in.readLong();\n            System.out.printf(\"Re-joining node reports %d ms skew.\\n\", maxDiffMS);\n            command = in.readInt();\n            if (command == COMMAND_COMPLETE)\n                return remoteConnection;\n            else {\n                String msg = String.format(\"Unable to re-join node. Error No. %d.\", command);\n                throw new Exception(msg);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            remoteConnection = null;\n        }\n        return remoteConnection;\n    }","commit_id":"6ac836b2c4c16286d8222b58b4e70723b77a36e4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"boolean failNext(int i) throws Exception {\n        Context context = getServerReadyToReceiveNewNode();\n\n        Client client = ClientFactory.createClient();\n        client.createConnection(\"localhost\", null, null);\n\n        ServerSocketChannel listener = null;\n        try {\n            listener = ServerSocketChannel.open();\n            listener.socket().bind(new InetSocketAddress(VoltDB.DEFAULT_INTERNAL_PORT + 1));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        SyncCallback scb = new SyncCallback();\n        boolean success = false;\n        while (!success) {\n            success = client.callProcedure(scb, \"@Rejoin\", \"localhost\", VoltDB.DEFAULT_INTERNAL_PORT + 1);\n            if (!success) Thread.sleep(100);\n        }\n\n        SocketChannel socket = listener.accept();\n        listener.close();\n        DataOutputStream out = new DataOutputStream(new BufferedOutputStream(socket.socket().getOutputStream()));\n        DataInputStream in = new DataInputStream(new BufferedInputStream(socket.socket().getInputStream()));\n\n        int hostId = in.readInt();\n        assertEquals(hostId, 1);\n\n        //COMMAND_SENDTIME_AND_CRC\n        out.writeInt(4);\n        out.flush();\n        // ignore what the other host says the time is\n        in.readLong();\n        // fake a clock skew of 1ms\n        out.writeLong(1);\n        // COMMAND_COMPLETE\n        out.writeInt(3);\n        out.flush();\n\n        //Thread.sleep(100000);\n\n        scb.waitForResponse();\n        @SuppressWarnings(\"unused\")\n        ClientResponse response = scb.getResponse();\n\n        socket.close();\n        context.localServer.shutdown();\n        context.localServer.join();\n\n        // this means there is nothing else to try\n        return false;\n    }","id":77098,"modified_method":"boolean failNext(int failType) throws Exception {\n        Context context = getServerReadyToReceiveNewNode();\n\n        Client client = ClientFactory.createClient();\n        client.createConnection(\"localhost\", null, null);\n\n        ServerSocketChannel listener = null;\n        if (failType != FAIL_NO_OPEN_SOCKET) {\n            try {\n                listener = ServerSocketChannel.open();\n                listener.socket().bind(new InetSocketAddress(VoltDB.DEFAULT_INTERNAL_PORT + 1));\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        }\n\n        SyncCallback scb = new SyncCallback();\n        boolean success = false;\n        while (!success) {\n            success = client.callProcedure(scb, \"@Rejoin\", \"localhost\", VoltDB.DEFAULT_INTERNAL_PORT + 1);\n            if (!success) Thread.sleep(100);\n        }\n\n        SocketChannel socket = null;\n        if (failType != FAIL_NO_OPEN_SOCKET) {\n            socket = listener.accept();\n            listener.close();\n            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(socket.socket().getOutputStream()));\n            DataInputStream in = new DataInputStream(new BufferedInputStream(socket.socket().getInputStream()));\n\n            int hostId = in.readInt();\n            assertEquals(hostId, 1);\n\n            if (failType != FAIL_TIMEOUT_ON_SOCKET) {\n                //COMMAND_SENDTIME_AND_CRC\n                out.writeInt(4);\n                out.flush();\n                // ignore what the other host says the time is\n                in.readLong();\n                // fake a clock skew of 1ms\n                if (failType == FAIL_SKEW) {\n                    out.writeLong(100000);\n                    // COMMAND_NTPFAIL\n                    out.writeInt(5);\n                }\n                else {\n                    out.writeLong(1);\n                    // COMMAND_COMPLETE\n                    out.writeInt(3);\n                }\n                out.flush();\n            }\n        }\n\n        scb.waitForResponse();\n        ClientResponse response = scb.getResponse();\n\n        switch (failType) {\n            case FAIL_NO_OPEN_SOCKET:\n                assertTrue(response.getStatus() != ClientResponse.SUCCESS);\n                break;\n            case FAIL_TIMEOUT_ON_SOCKET:\n                assertTrue(response.getStatus() != ClientResponse.SUCCESS);\n                break;\n            case FAIL_SKEW:\n                assertTrue(response.getStatus() != ClientResponse.SUCCESS);\n                break;\n            case DONT_FAIL:\n                assertTrue(response.getStatus() == ClientResponse.SUCCESS);\n                break;\n        }\n\n        if (failType != FAIL_NO_OPEN_SOCKET)\n            socket.close();\n        context.localServer.shutdown();\n        context.localServer.join();\n\n        // this means there is nothing else to try\n        return failType != DONT_FAIL;\n    }","commit_id":"6ac836b2c4c16286d8222b58b4e70723b77a36e4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public final Operation setReplicaIndex(int replicaIndex) {\n        if (replicaIndex < 0 || replicaIndex >= InternalPartition.MAX_REPLICA_COUNT) {\n            throw new IllegalArgumentException(\"Replica index is out of range [0-\"\n                    + (InternalPartition.MAX_REPLICA_COUNT - 1) + \"]\");\n        }\n        this.replicaIndex = replicaIndex;\n        return this;\n    }","id":77099,"modified_method":"public final Operation setReplicaIndex(int replicaIndex) {\n        if (replicaIndex < 0 || replicaIndex >= InternalPartition.MAX_REPLICA_COUNT) {\n            throw new IllegalArgumentException(\"Replica index is out of range [0-\"\n                    + (InternalPartition.MAX_REPLICA_COUNT - 1) + \"]\");\n        }\n\n        setFlag(replicaIndex != 0, BITMASK_REPLICA_INDEX_SET);\n        this.replicaIndex = replicaIndex;\n        return this;\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final Operation setPartitionId(int partitionId) {\n        this.partitionId = partitionId;\n        return this;\n    }","id":77100,"modified_method":"public final Operation setPartitionId(int partitionId) {\n        this.partitionId = partitionId;\n        setFlag(partitionId > Short.MAX_VALUE, BITMASK_PARTITION_ID_32_BIT);\n        return this;\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"final Operation setCallTimeout(long callTimeout) {\n        this.callTimeout = callTimeout;\n        return this;\n    }","id":77101,"modified_method":"final Operation setCallTimeout(long callTimeout) {\n        this.callTimeout = callTimeout;\n        setFlag(callTimeout > Integer.MAX_VALUE, BITMASK_CALL_TIMEOUT_64_BIT);\n        return this;\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean validatesTarget() {\n        return validateTarget;\n    }","id":77102,"modified_method":"public boolean validatesTarget() {\n        return isFlagSet(BITMASK_VALIDATE_TARGET);\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Operation setCallerUuid(String callerUuid) {\n        this.callerUuid = callerUuid;\n        return this;\n    }","id":77103,"modified_method":"public Operation setCallerUuid(String callerUuid) {\n        this.callerUuid = callerUuid;\n        setFlag(callerUuid != null, BITMASK_CALLER_UUID_SET);\n        return this;\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public final void readData(ObjectDataInput in) throws IOException {\n        // THIS HAS TO BE THE FIRST VALUE IN THE STREAM! DO NOT CHANGE!\n        // It is used to return deserialization exceptions to the caller\n        callId = in.readLong();\n\n        serviceName = in.readUTF();\n        partitionId = in.readInt();\n        replicaIndex = in.readByte();\n        validateTarget = in.readBoolean();\n        invocationTime = in.readLong();\n        callTimeout = in.readLong();\n        waitTimeout = in.readLong();\n        callerUuid = in.readUTF();\n        executorName = in.readUTF();\n        readInternal(in);\n    }","id":77104,"modified_method":"@Override\n    public final void readData(ObjectDataInput in) throws IOException {\n        // THIS HAS TO BE THE FIRST VALUE IN THE STREAM! DO NOT CHANGE!\n        // It is used to return deserialization exceptions to the caller\n        callId = in.readLong();\n\n        flags = in.readByte();\n\n        serviceName = in.readUTF();\n\n        if (isFlagSet(BITMASK_PARTITION_ID_32_BIT)) {\n            partitionId = in.readInt();\n        } else {\n            partitionId = in.readShort();\n        }\n\n        if (isFlagSet(BITMASK_REPLICA_INDEX_SET)) {\n            replicaIndex = in.readByte();\n        }\n\n        invocationTime = in.readLong();\n\n        if (isFlagSet(BITMASK_CALL_TIMEOUT_64_BIT)) {\n            callTimeout = in.readLong();\n        } else {\n            callTimeout = in.readInt();\n        }\n\n        if (isFlagSet(BITMASK_WAIT_TIMEOUT_SET)) {\n            waitTimeout = in.readLong();\n        }\n\n        if (isFlagSet(BITMASK_CALLER_UUID_SET)) {\n            callerUuid = in.readUTF();\n        }\n\n        executorName = in.readUTF();\n        readInternal(in);\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public final void writeData(ObjectDataOutput out) throws IOException {\n        // THIS HAS TO BE THE FIRST VALUE IN THE STREAM! DO NOT CHANGE!\n        // It is used to return deserialization exceptions to the caller\n        out.writeLong(callId);\n\n        out.writeUTF(serviceName);\n        out.writeInt(partitionId);\n        out.writeByte(replicaIndex);\n        out.writeBoolean(validateTarget);\n        out.writeLong(invocationTime);\n        out.writeLong(callTimeout);\n        out.writeLong(waitTimeout);\n        out.writeUTF(callerUuid);\n        out.writeUTF(executorName);\n        writeInternal(out);\n    }","id":77105,"modified_method":"@Override\n    public final void writeData(ObjectDataOutput out) throws IOException {\n        // THIS HAS TO BE THE FIRST VALUE IN THE STREAM! DO NOT CHANGE!\n        // It is used to return deserialization exceptions to the caller\n        out.writeLong(callId);\n\n        // write state next, so that it is first available on reading.\n        out.writeByte(flags);\n\n        out.writeUTF(serviceName);\n\n        if (isFlagSet(BITMASK_PARTITION_ID_32_BIT)) {\n            out.writeInt(partitionId);\n        } else {\n            out.writeShort(partitionId);\n        }\n\n        if (isFlagSet(BITMASK_REPLICA_INDEX_SET)) {\n            out.writeByte(replicaIndex);\n        }\n\n        out.writeLong(invocationTime);\n\n        if (isFlagSet(BITMASK_CALL_TIMEOUT_64_BIT)) {\n            out.writeLong(callTimeout);\n        } else {\n            out.writeInt((int) callTimeout);\n        }\n\n        if (isFlagSet(BITMASK_WAIT_TIMEOUT_SET)) {\n            out.writeLong(waitTimeout);\n        }\n\n        if (isFlagSet(BITMASK_CALLER_UUID_SET)) {\n            out.writeUTF(callerUuid);\n        }\n\n        out.writeUTF(executorName);\n        writeInternal(out);\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void setWaitTimeout(long timeout) {\n        this.waitTimeout = timeout;\n    }","id":77106,"modified_method":"public final void setWaitTimeout(long timeout) {\n        this.waitTimeout = timeout;\n        setFlag(timeout != -1, BITMASK_WAIT_TIMEOUT_SET);\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final Operation setValidateTarget(boolean validateTarget) {\n        this.validateTarget = validateTarget;\n        return this;\n    }","id":77107,"modified_method":"public final Operation setValidateTarget(boolean validateTarget) {\n        setFlag(validateTarget, BITMASK_VALIDATE_TARGET);\n        return this;\n    }","commit_id":"788d94ff11b79cb7e09b5bae4763dc33e69a4534","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void executeTask()\n        throws MojoExecutionException\n    {\n        try\n        {\n            getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_INITIALIZED );\n        }\n        catch ( IOException e )\n        {\n            getLog().warn( \"Error writing checkpoint.\", e );\n        }\n\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE ) )\n        {\n            checkForLocalModifications();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().resolveVersion( project );\n\n                    getScmRewriter().rewriteScmInfo( project, getTagLabel() );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    checkForPresenceOfSnapshots( project );\n\n                    transformPomToReleaseVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n\n            }\n\n            generateReleasePoms();\n\n            checkInRelease();\n\n            tagRelease();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().incrementVersion( project );\n\n                    getScmRewriter().restoreScmInfo( project );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    transformPomToSnapshotVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir,\n                                                     ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n\n            removeReleasePoms();\n\n            checkInNextSnapshot();\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_PREPARED_RELEASE );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":77108,"modified_method":"protected void executeTask()\n        throws MojoExecutionException\n    {\n        try\n        {\n            getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_INITIALIZED );\n        }\n        catch ( IOException e )\n        {\n            getLog().warn( \"Error writing checkpoint.\", e );\n        }\n\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE ) )\n        {\n            checkForLocalModifications();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().resolveVersion( project );\n\n                    getScmRewriter().rewriteScmInfo( project, getTagLabel() );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    checkForPresenceOfSnapshots( project );\n\n                    transformPomToReleaseVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n\n            }\n\n            generateReleasePoms();\n\n            checkInRelease();\n\n            tagRelease();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().incrementVersion( project );\n\n                    getScmRewriter().restoreScmInfo( project );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    transformPomToSnapshotVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir,\n                                                     ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n\n//            removeReleasePoms();\n\n            checkInNextSnapshot();\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_PREPARED_RELEASE );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"private void generateReleasePoms()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM ) )\n        {\n            String canonicalBasedir;\n\n            try\n            {\n                canonicalBasedir = trimPathForScmCalculation( new File( basedir ) );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot canonicalize basedir: \" + basedir, e );\n            }\n\n            for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                MavenProject releaseProject = new MavenProject( project );\n                Model releaseModel = releaseProject.getOriginalModel();\n                fixNullValueInModel( releaseModel, project.getOriginalModel() );\n                \n                // Remove parent\n/* TODO: put this back after it is properly resolved again\n                if ( releaseModel.getParent() != null )\n                {\n                    releaseModel.setParent( null );\n                }\n\n*/\n                Set artifacts = releaseProject.getArtifacts();\n\n                if ( artifacts != null )\n                {\n                    //Rewrite dependencies section\n                    List newdeps = new ArrayList();\n\n                    for ( Iterator i = releaseProject.getArtifacts().iterator(); i.hasNext(); )\n                    {\n                        Artifact artifact = (Artifact) i.next();\n\n                        Dependency newdep = new Dependency();\n\n                        newdep.setArtifactId( artifact.getArtifactId() );\n                        newdep.setGroupId( artifact.getGroupId() );\n                        newdep.setVersion( artifact.getVersion() );\n                        newdep.setType( artifact.getType() );\n                        newdep.setScope( artifact.getScope() );\n                        newdep.setClassifier( artifact.getClassifier() );\n\n                        newdeps.add( newdep );\n                    }\n\n                    releaseModel.setDependencies( newdeps );\n                }\n\n                // Use original - don't want the lifecycle introduced ones\n                // TODO: but is it the right settings?\n                Build originalModel = releaseProject.getOriginalModel().getBuild();\n                List plugins = originalModel != null ? originalModel.getPlugins() : null;\n\n                if ( plugins != null )\n                {\n                    //Rewrite plugins version\n                    Map pluginArtifacts = releaseProject.getPluginArtifactMap();\n\n                    for ( Iterator i = plugins.iterator(); i.hasNext(); )\n                    {\n                        Plugin plugin = (Plugin) i.next();\n\n                        Artifact artifact = (Artifact) pluginArtifacts.get( plugin.getKey() );\n\n                        String version = resolveVersion( artifact, \"plugin\", releaseProject );\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List reports = releaseProject.getReportPlugins();\n\n                if ( reports != null )\n                {\n                    //Rewrite report version\n                    Map reportArtifacts = releaseProject.getReportArtifactMap();\n                    \n                    getLog().info( \"Using report-artifact map with \" + reportArtifacts.size() + \" entries.\" );\n\n                    for ( Iterator i = reports.iterator(); i.hasNext(); )\n                    {\n                        ReportPlugin plugin = (ReportPlugin) i.next();\n\n                        String pluginKey = plugin.getKey();\n                        \n                        getLog().info( \"Looking up report artifact for: \\'\" + pluginKey + \"\\'\" );\n                        \n                        Artifact artifact = (Artifact) reportArtifacts.get( pluginKey );\n\n                        String version = resolveVersion( artifact, \"report\", releaseProject );\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List extensions = releaseProject.getBuildExtensions();\n\n                if ( extensions != null )\n                {\n                    //Rewrite extension version\n                    Map extensionArtifacts = releaseProject.getExtensionArtifactMap();\n\n                    for ( Iterator i = extensions.iterator(); i.hasNext(); )\n                    {\n                        Extension ext = (Extension) i.next();\n\n                        String extensionId = ArtifactUtils.versionlessKey( ext.getGroupId(), ext.getArtifactId() );\n\n                        Artifact artifact = (Artifact) extensionArtifacts.get( extensionId );\n\n                        String version = resolveVersion( artifact, \"extension\", releaseProject );\n\n                        ext.setVersion( version );\n                    }\n                }\n\n                File releasePomFile = new File( releaseProject.getFile().getParentFile(), RELEASE_POM );\n\n                Writer writer = null;\n\n                try\n                {\n                    writer = new FileWriter( releasePomFile );\n\n                    releaseProject.writeOriginalModel( writer );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot write release-pom to: \" + releasePomFile, e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n\n                try\n                {\n                    String releasePomPath = trimPathForScmCalculation( releasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir );\n\n                    scm.add( releasePomPath );\n                }\n                catch ( ScmException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_GENERATED_RELEASE_POM );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n        }\n    }","id":77109,"modified_method":"private void generateReleasePoms()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM ) )\n        {\n            String canonicalBasedir;\n\n            try\n            {\n                canonicalBasedir = trimPathForScmCalculation( new File( basedir ) );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot canonicalize basedir: \" + basedir, e );\n            }\n\n            for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                MavenProject releaseProject = new MavenProject( project );\n                Model releaseModel = releaseProject.getModel();\n                fixNullValueInModel( releaseModel, project.getModel() );\n                \n                String projectVersion = releaseModel.getVersion();\n                if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                {\n                    String snapshotVersion = projectVersion;\n                    \n                    projectVersion = getVersionResolver().getResolvedVersion( releaseModel.getGroupId(), releaseModel.getArtifactId() );\n                    \n                    if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                    {\n                        throw new MojoExecutionException( \"MAJOR PROBLEM!!! Cannot find resolved version to be used in releasing project: \" + releaseProject.getId() );\n                    }\n                    \n                    releaseModel.setVersion( projectVersion );\n                    \n                    String finalName = releaseModel.getBuild().getFinalName();\n                    \n                    if ( finalName.equals( releaseModel.getArtifactId() + \"-\" + snapshotVersion ) )\n                    {\n                        releaseModel.getBuild().setFinalName( releaseModel.getArtifactId() + \"-\" + projectVersion );\n                    }\n                    else if ( finalName.indexOf( \"SNAPSHOT\" ) > -1 )\n                    {\n                        throw new MojoExecutionException( \"Cannot reliably adjust the finalName of project: \" + releaseProject.getId() );\n                    }\n                }\n                \n                releaseModel.setParent( null );\n\n                Set artifacts = releaseProject.getArtifacts();\n\n                if ( artifacts != null )\n                {\n                    //Rewrite dependencies section\n                    List newdeps = new ArrayList();\n\n                    for ( Iterator i = releaseProject.getArtifacts().iterator(); i.hasNext(); )\n                    {\n                        Artifact artifact = (Artifact) i.next();\n                        \n                        Dependency newdep = new Dependency();\n\n                        newdep.setArtifactId( artifact.getArtifactId() );\n                        newdep.setGroupId( artifact.getGroupId() );\n                        \n                        String version = artifact.getVersion();\n                        if ( artifact.isSnapshot() )\n                        {\n                            version = getVersionResolver().getResolvedVersion(artifact.getGroupId(), artifact.getArtifactId() );\n                            \n                            if ( ArtifactUtils.isSnapshot( version ) )\n                            {\n                                throw new MojoExecutionException( \"Unresolved SNAPSHOT version of: \" + artifact.getId() + \". Cannot proceed with release.\" );\n                            }\n                        }\n                        \n                        newdep.setVersion( version );\n                        newdep.setType( artifact.getType() );\n                        newdep.setScope( artifact.getScope() );\n                        newdep.setClassifier( artifact.getClassifier() );\n\n                        newdeps.add( newdep );\n                    }\n\n                    releaseModel.setDependencies( newdeps );\n                }\n\n                // Use original - don't want the lifecycle introduced ones\n                // TODO: but is it the right settings?\n                Build model = releaseProject.getModel().getBuild();\n                List plugins = model != null ? model.getPlugins() : null;\n\n                if ( plugins != null )\n                {\n                    //Rewrite plugins version\n                    for ( Iterator i = plugins.iterator(); i.hasNext(); )\n                    {\n                        Plugin plugin = (Plugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolvePluginVersion( plugin.getGroupId(), plugin.getArtifactId(), project, settings, localRepository );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException( \"Cannot resolve version for plugin: \" + plugin );\n                        }\n                        \n                        if ( ArtifactUtils.isSnapshot(version))\n                        {\n                            throw new MojoExecutionException( \"Resolved version of plugin is a snapshot. Please release this plugin before releasing this project.\\n\\nGroupId: \" + plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() + \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List reports = releaseProject.getReportPlugins();\n\n                if ( reports != null )\n                {\n                    //Rewrite report version\n                    for ( Iterator i = reports.iterator(); i.hasNext(); )\n                    {\n                        ReportPlugin plugin = (ReportPlugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolvePluginVersion( plugin.getGroupId(), plugin\n                                .getArtifactId(), project, settings, localRepository, true );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException( \"Cannot resolve version for report plugin: \" + plugin );\n                        }\n                        \n                        if ( ArtifactUtils.isSnapshot(version))\n                        {\n                            throw new MojoExecutionException( \"Resolved version of plugin is a snapshot. Please release this report plugin before releasing this project.\\n\\nGroupId: \" + plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() + \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List extensions = releaseProject.getBuildExtensions();\n\n                if ( extensions != null )\n                {\n                    //Rewrite extension version\n                    Map extensionArtifacts = releaseProject.getExtensionArtifactMap();\n\n                    for ( Iterator i = extensions.iterator(); i.hasNext(); )\n                    {\n                        Extension ext = (Extension) i.next();\n\n                        String extensionId = ArtifactUtils.versionlessKey( ext.getGroupId(), ext.getArtifactId() );\n\n                        Artifact artifact = (Artifact) extensionArtifacts.get( extensionId );\n\n                        String version = resolveVersion( artifact, \"extension\", releaseProject );\n\n                        ext.setVersion( version );\n                    }\n                }\n                \n                try\n                {\n                    relativizeBuildPaths( model, project.getFile().getParentFile().getCanonicalPath() );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot relativize build paths for: \" + project.getId(), e );\n                }\n\n                File releasePomFile = new File( releaseProject.getFile().getParentFile(), RELEASE_POM );\n\n                Writer writer = null;\n\n                try\n                {\n                    writer = new FileWriter( releasePomFile );\n\n                    releaseProject.writeModel( writer );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot write release-pom to: \" + releasePomFile, e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n\n                try\n                {\n                    String releasePomPath = trimPathForScmCalculation( releasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir );\n\n                    scm.add( releasePomPath );\n                }\n                catch ( ScmException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_GENERATED_RELEASE_POM );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n        }\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"private String resolveVersion( Artifact artifact, String artifactUsage, MavenProject project )\n        throws MojoExecutionException\n    {\n        getLog().info( \"Resolving version for: \" + artifact );\n        String resolvedVersion = getVersionResolver().getResolvedVersion( artifact.getGroupId(),\n                                                                          artifact.getArtifactId() );\n\n        if ( resolvedVersion == null )\n        {\n            if ( artifact.getFile() == null )\n            {\n                try\n                {\n                    artifactMetadataSource.retrieve( artifact, localRepository,\n                                                     project.getPluginArtifactRepositories() );\n                }\n                catch ( ArtifactMetadataRetrievalException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve \" + artifactUsage + \": \" + artifact.getId(), e );\n                }\n            }\n\n            resolvedVersion = artifact.getVersion();\n        }\n\n        return resolvedVersion;\n    }","id":77110,"modified_method":"private String resolveVersion( Artifact artifact, String artifactUsage, MavenProject project )\n        throws MojoExecutionException\n    {\n        String resolvedVersion = getVersionResolver().getResolvedVersion( artifact.getGroupId(),\n                                                                          artifact.getArtifactId() );\n\n        if ( resolvedVersion == null )\n        {\n            if ( artifact.getFile() == null )\n            {\n                try\n                {\n                    artifactMetadataSource.retrieve( artifact, localRepository,\n                                                     project.getPluginArtifactRepositories() );\n                }\n                catch ( ArtifactMetadataRetrievalException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve \" + artifactUsage + \": \" + artifact.getId(), e );\n                }\n            }\n\n            resolvedVersion = artifact.getVersion();\n        }\n\n        return resolvedVersion;\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"private void rewriteScmConnection( Scm scm, String tag )\n    {\n        if ( scm != null )\n        {\n            String scmConnection = scm.getConnection();\n            if ( scmConnection != null && scmConnection.startsWith( \"scm:svn\" ) )\n            {\n                scm.setConnection( convertSvnConnectionString( scmConnection, tag ) );\n                scm.setDeveloperConnection( convertSvnConnectionString( scm.getDeveloperConnection(), tag ) );\n                scm.setUrl( convertSvnConnectionString( scm.getUrl(), tag ) );\n            }\n        }\n    }","id":77111,"modified_method":"private void rewriteScmConnection( Scm scm, String tag )\n    {\n        if ( scm != null )\n        {\n            String scmConnection = scm.getConnection();\n            if ( scmConnection != null && scmConnection.startsWith( \"scm:svn\" ) )\n            {\n                scm.setConnection( convertSvnConnectionString( scmConnection, tag ) );\n                \n                String devConnection = scm.getDeveloperConnection();\n                if ( devConnection != null )\n                {\n                    scm.setDeveloperConnection( convertSvnConnectionString( devConnection, tag ) );\n                }\n                \n                String url = scm.getUrl();\n                if ( url != null )\n                {\n                    scm.setUrl( convertSvnConnectionString( url, tag ) );\n                }\n            }\n        }\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"public void rewriteScmInfo( MavenProject project, String tagLabel )\n        throws MojoExecutionException\n    {\n        String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n\n        if ( project.getScm() == null )\n        {\n            throw new MojoExecutionException(\n                \"Project: \" + projectId + \" does not have a SCM section! Cannot proceed with release.\" );\n        }\n\n        Model model = project.getOriginalModel();\n\n        Scm scm = model.getScm();\n        // If SCM is null in original model, it is inherited, no mods needed\n        if ( scm != null )\n        {\n            releaseProgress.addOriginalScmInfo( projectId, scm );\n\n            rewriteScmConnection( scm, tagLabel );\n        }\n    }","id":77112,"modified_method":"public void rewriteScmInfo( MavenProject project, String tagLabel )\n        throws MojoExecutionException\n    {\n        String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n\n        Model model = project.getOriginalModel();\n\n        Scm scm = model.getScm();\n        // If SCM is null in original model, it is inherited, no mods needed\n        if ( scm != null )\n        {\n            releaseProgress.addOriginalScmInfo( projectId, scm );\n\n            rewriteScmConnection( scm, tagLabel );\n        }\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"public void addOriginalScmInfo( String projectId, Scm scm )\n    {\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".connection\", scm.getConnection() );\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".developerConnection\",\n                                       scm.getDeveloperConnection() );\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".url\", scm.getUrl() );\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".tag\", scm.getTag() );\n    }","id":77113,"modified_method":"public void addOriginalScmInfo( String projectId, Scm scm )\n    {\n        String connection = scm.getConnection();\n        if ( connection != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".connection\", connection );\n        }\n        \n        String devConnection = scm.getDeveloperConnection();\n        if ( devConnection != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".developerConnection\",\n                                           devConnection );\n        }\n        \n        String url = scm.getUrl();\n        if ( url != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".url\", url );\n        }\n        \n        String tag = scm.getTag();\n        if ( tag != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".tag\", tag );\n        }\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"public void restoreScmInfo( String projectId, Scm scm )\n    {\n        String connection = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".connection\" );\n        if ( connection == null )\n        {\n            throw new IllegalArgumentException(\n                \"Project \\'\" + projectId + \"\\' has not had its SCM info cached. Cannot restore uncached SCM info.\" );\n        }\n        scm.setConnection( connection );\n        scm.setDeveloperConnection(\n            releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".developerConnection\" ) );\n        scm.setUrl( releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".url\" ) );\n        scm.setTag( releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".tag\" ) );\n    }","id":77114,"modified_method":"public void restoreScmInfo( String projectId, Scm scm )\n    {\n        String connection = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".connection\" );\n        if ( connection != null )\n        {\n            scm.setConnection( connection );\n        }\n        \n        String devConnection = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".connection\" );\n        if ( devConnection != null )\n        {\n            scm.setDeveloperConnection( devConnection );\n        }\n        \n        String url = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".url\" );\n        if ( url != null )\n        {\n            scm.setUrl( url );\n        }\n        \n        String tag = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".tag\" );\n        if ( tag != null )\n        {\n            scm.setTag( tag );\n        }\n    }","commit_id":"23af50ef4ab0fdecdb5e02904bf824d84ac5da7a","url":"https://github.com/apache/maven"},{"original_method":"private void generateReleasePoms()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM ) )\n        {\n            String canonicalBasedir;\n\n            try\n            {\n                canonicalBasedir = trimPathForScmCalculation( new File( basedir ) );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot canonicalize basedir: \" + basedir, e );\n            }\n\n            for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                MavenProject releaseProject = new MavenProject( project );\n                Model releaseModel = releaseProject.getOriginalModel();\n                fixNullValueInModel( releaseModel, project.getOriginalModel() );\n                \n                // Remove parent\n/* TODO: put this back after it is properly resolved again\n                if ( releaseModel.getParent() != null )\n                {\n                    releaseModel.setParent( null );\n                }\n\n*/\n                Set artifacts = releaseProject.getArtifacts();\n\n                if ( artifacts != null )\n                {\n                    //Rewrite dependencies section\n                    List newdeps = new ArrayList();\n\n                    for ( Iterator i = releaseProject.getArtifacts().iterator(); i.hasNext(); )\n                    {\n                        Artifact artifact = (Artifact) i.next();\n\n                        Dependency newdep = new Dependency();\n\n                        newdep.setArtifactId( artifact.getArtifactId() );\n                        newdep.setGroupId( artifact.getGroupId() );\n                        newdep.setVersion( artifact.getVersion() );\n                        newdep.setType( artifact.getType() );\n                        newdep.setScope( artifact.getScope() );\n                        newdep.setClassifier( artifact.getClassifier() );\n\n                        newdeps.add( newdep );\n                    }\n\n                    releaseModel.setDependencies( newdeps );\n                }\n\n                // Use original - don't want the lifecycle introduced ones\n                // TODO: but is it the right settings?\n                Build originalModel = releaseProject.getOriginalModel().getBuild();\n                List plugins = originalModel != null ? originalModel.getPlugins() : null;\n\n                if ( plugins != null )\n                {\n                    //Rewrite plugins version\n                    Map pluginArtifacts = releaseProject.getPluginArtifactMap();\n\n                    for ( Iterator i = plugins.iterator(); i.hasNext(); )\n                    {\n                        Plugin plugin = (Plugin) i.next();\n\n                        Artifact artifact = (Artifact) pluginArtifacts.get( plugin.getKey() );\n\n                        String version = resolveVersion( artifact, \"plugin\", releaseProject );\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List reports = releaseProject.getReportPlugins();\n\n                if ( reports != null )\n                {\n                    //Rewrite report version\n                    Map reportArtifacts = releaseProject.getReportArtifactMap();\n                    \n                    getLog().info( \"Using report-artifact map with \" + reportArtifacts.size() + \" entries.\" );\n\n                    for ( Iterator i = reports.iterator(); i.hasNext(); )\n                    {\n                        ReportPlugin plugin = (ReportPlugin) i.next();\n\n                        String pluginKey = plugin.getKey();\n                        \n                        getLog().info( \"Looking up report artifact for: \\'\" + pluginKey + \"\\'\" );\n                        \n                        Artifact artifact = (Artifact) reportArtifacts.get( pluginKey );\n\n                        String version = resolveVersion( artifact, \"report\", releaseProject );\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List extensions = releaseProject.getBuildExtensions();\n\n                if ( extensions != null )\n                {\n                    //Rewrite extension version\n                    Map extensionArtifacts = releaseProject.getExtensionArtifactMap();\n\n                    for ( Iterator i = extensions.iterator(); i.hasNext(); )\n                    {\n                        Extension ext = (Extension) i.next();\n\n                        String extensionId = ArtifactUtils.versionlessKey( ext.getGroupId(), ext.getArtifactId() );\n\n                        Artifact artifact = (Artifact) extensionArtifacts.get( extensionId );\n\n                        String version = resolveVersion( artifact, \"extension\", releaseProject );\n\n                        ext.setVersion( version );\n                    }\n                }\n\n                File releasePomFile = new File( releaseProject.getFile().getParentFile(), RELEASE_POM );\n\n                Writer writer = null;\n\n                try\n                {\n                    writer = new FileWriter( releasePomFile );\n\n                    releaseProject.writeOriginalModel( writer );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot write release-pom to: \" + releasePomFile, e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n\n                try\n                {\n                    String releasePomPath = trimPathForScmCalculation( releasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir );\n\n                    scm.add( releasePomPath );\n                }\n                catch ( ScmException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_GENERATED_RELEASE_POM );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n        }\n    }","id":77115,"modified_method":"private void generateReleasePoms()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM ) )\n        {\n            String canonicalBasedir;\n\n            try\n            {\n                canonicalBasedir = trimPathForScmCalculation( new File( basedir ) );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot canonicalize basedir: \" + basedir, e );\n            }\n\n            for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                MavenProject releaseProject = new MavenProject( project );\n                Model releaseModel = releaseProject.getModel();\n                fixNullValueInModel( releaseModel, project.getModel() );\n                \n                String projectVersion = releaseModel.getVersion();\n                if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                {\n                    String snapshotVersion = projectVersion;\n                    \n                    projectVersion = getVersionResolver().getResolvedVersion( releaseModel.getGroupId(), releaseModel.getArtifactId() );\n                    \n                    if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                    {\n                        throw new MojoExecutionException( \"MAJOR PROBLEM!!! Cannot find resolved version to be used in releasing project: \" + releaseProject.getId() );\n                    }\n                    \n                    releaseModel.setVersion( projectVersion );\n                    \n                    String finalName = releaseModel.getBuild().getFinalName();\n                    \n                    if ( finalName.equals( releaseModel.getArtifactId() + \"-\" + snapshotVersion ) )\n                    {\n                        releaseModel.getBuild().setFinalName( releaseModel.getArtifactId() + \"-\" + projectVersion );\n                    }\n                    else if ( finalName.indexOf( \"SNAPSHOT\" ) > -1 )\n                    {\n                        throw new MojoExecutionException( \"Cannot reliably adjust the finalName of project: \" + releaseProject.getId() );\n                    }\n                }\n                \n                releaseModel.setParent( null );\n\n                Set artifacts = releaseProject.getArtifacts();\n\n                if ( artifacts != null )\n                {\n                    //Rewrite dependencies section\n                    List newdeps = new ArrayList();\n\n                    for ( Iterator i = releaseProject.getArtifacts().iterator(); i.hasNext(); )\n                    {\n                        Artifact artifact = (Artifact) i.next();\n                        \n                        Dependency newdep = new Dependency();\n\n                        newdep.setArtifactId( artifact.getArtifactId() );\n                        newdep.setGroupId( artifact.getGroupId() );\n                        \n                        String version = artifact.getVersion();\n                        if ( artifact.isSnapshot() )\n                        {\n                            version = getVersionResolver().getResolvedVersion(artifact.getGroupId(), artifact.getArtifactId() );\n                            \n                            if ( ArtifactUtils.isSnapshot( version ) )\n                            {\n                                throw new MojoExecutionException( \"Unresolved SNAPSHOT version of: \" + artifact.getId() + \". Cannot proceed with release.\" );\n                            }\n                        }\n                        \n                        newdep.setVersion( version );\n                        newdep.setType( artifact.getType() );\n                        newdep.setScope( artifact.getScope() );\n                        newdep.setClassifier( artifact.getClassifier() );\n\n                        newdeps.add( newdep );\n                    }\n\n                    releaseModel.setDependencies( newdeps );\n                }\n\n                // Use original - don't want the lifecycle introduced ones\n                // TODO: but is it the right settings?\n                Build model = releaseProject.getModel().getBuild();\n                List plugins = model != null ? model.getPlugins() : null;\n\n                if ( plugins != null )\n                {\n                    //Rewrite plugins version\n                    for ( Iterator i = plugins.iterator(); i.hasNext(); )\n                    {\n                        Plugin plugin = (Plugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolvePluginVersion( plugin.getGroupId(), plugin.getArtifactId(), project, settings, localRepository );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException( \"Cannot resolve version for plugin: \" + plugin );\n                        }\n                        \n                        if ( ArtifactUtils.isSnapshot(version))\n                        {\n                            throw new MojoExecutionException( \"Resolved version of plugin is a snapshot. Please release this plugin before releasing this project.\\n\\nGroupId: \" + plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() + \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List reports = releaseProject.getReportPlugins();\n\n                if ( reports != null )\n                {\n                    //Rewrite report version\n                    for ( Iterator i = reports.iterator(); i.hasNext(); )\n                    {\n                        ReportPlugin plugin = (ReportPlugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolvePluginVersion( plugin.getGroupId(), plugin\n                                .getArtifactId(), project, settings, localRepository, true );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException( \"Cannot resolve version for report plugin: \" + plugin );\n                        }\n                        \n                        if ( ArtifactUtils.isSnapshot(version))\n                        {\n                            throw new MojoExecutionException( \"Resolved version of plugin is a snapshot. Please release this report plugin before releasing this project.\\n\\nGroupId: \" + plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() + \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List extensions = releaseProject.getBuildExtensions();\n\n                if ( extensions != null )\n                {\n                    //Rewrite extension version\n                    Map extensionArtifacts = releaseProject.getExtensionArtifactMap();\n\n                    for ( Iterator i = extensions.iterator(); i.hasNext(); )\n                    {\n                        Extension ext = (Extension) i.next();\n\n                        String extensionId = ArtifactUtils.versionlessKey( ext.getGroupId(), ext.getArtifactId() );\n\n                        Artifact artifact = (Artifact) extensionArtifacts.get( extensionId );\n\n                        String version = resolveVersion( artifact, \"extension\", releaseProject );\n\n                        ext.setVersion( version );\n                    }\n                }\n                \n                try\n                {\n                    relativizeBuildPaths( model, project.getFile().getParentFile().getCanonicalPath() );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot relativize build paths for: \" + project.getId(), e );\n                }\n\n                File releasePomFile = new File( releaseProject.getFile().getParentFile(), RELEASE_POM );\n\n                Writer writer = null;\n\n                try\n                {\n                    writer = new FileWriter( releasePomFile );\n\n                    releaseProject.writeModel( writer );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot write release-pom to: \" + releasePomFile, e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n\n                try\n                {\n                    String releasePomPath = trimPathForScmCalculation( releasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir );\n\n                    scm.add( releasePomPath );\n                }\n                catch ( ScmException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_GENERATED_RELEASE_POM );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n        }\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void executeTask()\n        throws MojoExecutionException\n    {\n        try\n        {\n            getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_INITIALIZED );\n        }\n        catch ( IOException e )\n        {\n            getLog().warn( \"Error writing checkpoint.\", e );\n        }\n\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE ) )\n        {\n            checkForLocalModifications();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().resolveVersion( project );\n\n                    getScmRewriter().rewriteScmInfo( project, getTagLabel() );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    checkForPresenceOfSnapshots( project );\n\n                    transformPomToReleaseVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n\n            }\n\n            generateReleasePoms();\n\n            checkInRelease();\n\n            tagRelease();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().incrementVersion( project );\n\n                    getScmRewriter().restoreScmInfo( project );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    transformPomToSnapshotVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir,\n                                                     ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n\n            removeReleasePoms();\n\n            checkInNextSnapshot();\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_PREPARED_RELEASE );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":77116,"modified_method":"protected void executeTask()\n        throws MojoExecutionException\n    {\n        try\n        {\n            getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_INITIALIZED );\n        }\n        catch ( IOException e )\n        {\n            getLog().warn( \"Error writing checkpoint.\", e );\n        }\n\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE ) )\n        {\n            checkForLocalModifications();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().resolveVersion( project );\n\n                    getScmRewriter().rewriteScmInfo( project, getTagLabel() );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    checkForPresenceOfSnapshots( project );\n\n                    transformPomToReleaseVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n\n            }\n\n            generateReleasePoms();\n\n            checkInRelease();\n\n            tagRelease();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    getVersionResolver().incrementVersion( project );\n\n                    getScmRewriter().restoreScmInfo( project );\n                }\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    transformPomToSnapshotVersionPom( project );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir,\n                                                     ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n\n//            removeReleasePoms();\n\n            checkInNextSnapshot();\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir, ReleaseProgressTracker.CP_PREPARED_RELEASE );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"private String resolveVersion( Artifact artifact, String artifactUsage, MavenProject project )\n        throws MojoExecutionException\n    {\n        getLog().info( \"Resolving version for: \" + artifact );\n        String resolvedVersion = getVersionResolver().getResolvedVersion( artifact.getGroupId(),\n                                                                          artifact.getArtifactId() );\n\n        if ( resolvedVersion == null )\n        {\n            if ( artifact.getFile() == null )\n            {\n                try\n                {\n                    artifactMetadataSource.retrieve( artifact, localRepository,\n                                                     project.getPluginArtifactRepositories() );\n                }\n                catch ( ArtifactMetadataRetrievalException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve \" + artifactUsage + \": \" + artifact.getId(), e );\n                }\n            }\n\n            resolvedVersion = artifact.getVersion();\n        }\n\n        return resolvedVersion;\n    }","id":77117,"modified_method":"private String resolveVersion( Artifact artifact, String artifactUsage, MavenProject project )\n        throws MojoExecutionException\n    {\n        String resolvedVersion = getVersionResolver().getResolvedVersion( artifact.getGroupId(),\n                                                                          artifact.getArtifactId() );\n\n        if ( resolvedVersion == null )\n        {\n            if ( artifact.getFile() == null )\n            {\n                try\n                {\n                    artifactMetadataSource.retrieve( artifact, localRepository,\n                                                     project.getPluginArtifactRepositories() );\n                }\n                catch ( ArtifactMetadataRetrievalException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve \" + artifactUsage + \": \" + artifact.getId(), e );\n                }\n            }\n\n            resolvedVersion = artifact.getVersion();\n        }\n\n        return resolvedVersion;\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void rewriteScmInfo( MavenProject project, String tagLabel )\n        throws MojoExecutionException\n    {\n        String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n\n        if ( project.getScm() == null )\n        {\n            throw new MojoExecutionException(\n                \"Project: \" + projectId + \" does not have a SCM section! Cannot proceed with release.\" );\n        }\n\n        Model model = project.getOriginalModel();\n\n        Scm scm = model.getScm();\n        // If SCM is null in original model, it is inherited, no mods needed\n        if ( scm != null )\n        {\n            releaseProgress.addOriginalScmInfo( projectId, scm );\n\n            rewriteScmConnection( scm, tagLabel );\n        }\n    }","id":77118,"modified_method":"public void rewriteScmInfo( MavenProject project, String tagLabel )\n        throws MojoExecutionException\n    {\n        String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n\n        Model model = project.getOriginalModel();\n\n        Scm scm = model.getScm();\n        // If SCM is null in original model, it is inherited, no mods needed\n        if ( scm != null )\n        {\n            releaseProgress.addOriginalScmInfo( projectId, scm );\n\n            rewriteScmConnection( scm, tagLabel );\n        }\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void rewriteScmConnection( Scm scm, String tag )\n    {\n        if ( scm != null )\n        {\n            String scmConnection = scm.getConnection();\n            if ( scmConnection != null && scmConnection.startsWith( \"scm:svn\" ) )\n            {\n                scm.setConnection( convertSvnConnectionString( scmConnection, tag ) );\n                scm.setDeveloperConnection( convertSvnConnectionString( scm.getDeveloperConnection(), tag ) );\n                scm.setUrl( convertSvnConnectionString( scm.getUrl(), tag ) );\n            }\n        }\n    }","id":77119,"modified_method":"private void rewriteScmConnection( Scm scm, String tag )\n    {\n        if ( scm != null )\n        {\n            String scmConnection = scm.getConnection();\n            if ( scmConnection != null && scmConnection.startsWith( \"scm:svn\" ) )\n            {\n                scm.setConnection( convertSvnConnectionString( scmConnection, tag ) );\n                \n                String devConnection = scm.getDeveloperConnection();\n                if ( devConnection != null )\n                {\n                    scm.setDeveloperConnection( convertSvnConnectionString( devConnection, tag ) );\n                }\n                \n                String url = scm.getUrl();\n                if ( url != null )\n                {\n                    scm.setUrl( convertSvnConnectionString( url, tag ) );\n                }\n            }\n        }\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void addOriginalScmInfo( String projectId, Scm scm )\n    {\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".connection\", scm.getConnection() );\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".developerConnection\",\n                                       scm.getDeveloperConnection() );\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".url\", scm.getUrl() );\n        releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".tag\", scm.getTag() );\n    }","id":77120,"modified_method":"public void addOriginalScmInfo( String projectId, Scm scm )\n    {\n        String connection = scm.getConnection();\n        if ( connection != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".connection\", connection );\n        }\n        \n        String devConnection = scm.getDeveloperConnection();\n        if ( devConnection != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".developerConnection\",\n                                           devConnection );\n        }\n        \n        String url = scm.getUrl();\n        if ( url != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".url\", url );\n        }\n        \n        String tag = scm.getTag();\n        if ( tag != null )\n        {\n            releaseProperties.setProperty( SCM_INFO_PREFIX + projectId + \".tag\", tag );\n        }\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void restoreScmInfo( String projectId, Scm scm )\n    {\n        String connection = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".connection\" );\n        if ( connection == null )\n        {\n            throw new IllegalArgumentException(\n                \"Project \\'\" + projectId + \"\\' has not had its SCM info cached. Cannot restore uncached SCM info.\" );\n        }\n        scm.setConnection( connection );\n        scm.setDeveloperConnection(\n            releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".developerConnection\" ) );\n        scm.setUrl( releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".url\" ) );\n        scm.setTag( releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".tag\" ) );\n    }","id":77121,"modified_method":"public void restoreScmInfo( String projectId, Scm scm )\n    {\n        String connection = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".connection\" );\n        if ( connection != null )\n        {\n            scm.setConnection( connection );\n        }\n        \n        String devConnection = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".connection\" );\n        if ( devConnection != null )\n        {\n            scm.setDeveloperConnection( devConnection );\n        }\n        \n        String url = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".url\" );\n        if ( url != null )\n        {\n            scm.setUrl( url );\n        }\n        \n        String tag = releaseProperties.getProperty( SCM_INFO_PREFIX + projectId + \".tag\" );\n        if ( tag != null )\n        {\n            scm.setTag( tag );\n        }\n    }","commit_id":"a5bc6f1dd05baa382f86a695b54b3240c9a246c3","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setContentLengthLong(long len) {\n\t\tif (len > Integer.MAX_VALUE) {\n\t\t\tthrow new IllegalArgumentException(\"Content-Length exceeds ShallowEtagHeaderFilter's maximum (\" +\n\t\t\t\t\tInteger.MAX_VALUE + \"): \" + len);\n\t\t}\n\t\tint lenInt = (int) len;\n\t\tthis.content.resize(lenInt);\n\t\tthis.contentLength = lenInt;\n\t}","id":77122,"modified_method":"public void setContentLengthLong(long len) {\n\t\tif (len > Integer.MAX_VALUE) {\n\t\t\tthrow new IllegalArgumentException(\"Content-Length exceeds ShallowEtagHeaderFilter's maximum (\" +\n\t\t\t\t\tInteger.MAX_VALUE + \"): \" + len);\n\t\t}\n\t\tint lenInt = (int) len;\n\t\tif (lenInt > this.content.size()) {\n\t\t\tthis.content.resize(lenInt);\n\t\t}\n\t\tthis.contentLength = lenInt;\n\t}","commit_id":"43d72e2079d94edd6a8bcd26e59ed7ef2c4ca996","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void setContentLength(int len) {\n\t\tthis.content.resize(len);\n\t\tthis.contentLength = len;\n\t}","id":77123,"modified_method":"@Override\n\tpublic void setContentLength(int len) {\n\t\tif (len > this.content.size()) {\n\t\t\tthis.content.resize(len);\n\t\t}\n\t\tthis.contentLength = len;\n\t}","commit_id":"43d72e2079d94edd6a8bcd26e59ed7ef2c4ca996","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void setBufferSize(int size) {\n\t\tthis.content.resize(size);\n\t}","id":77124,"modified_method":"@Override\n\tpublic void setBufferSize(int size) {\n\t\tif (size > this.content.size()) {\n\t\t\tthis.content.resize(size);\n\t\t}\n\t}","commit_id":"43d72e2079d94edd6a8bcd26e59ed7ef2c4ca996","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/** Sets the current screen. {@link Screen#hide()} is called on any old screen, and {@link Screen#show()} is called on the new\r\n\t * screen. */\r\n\tpublic void setScreen (Screen screen) {\r\n\t\tif (this.screen != null) this.screen.hide();\r\n\t\tthis.screen = screen;\r\n\t\tscreen.show();\r\n\t\tscreen.resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t}","id":77125,"modified_method":"/** Sets the current screen. {@link Screen#hide()} is called on any old screen, and {@link Screen#show()} is called on the new\r\n\t * screen, if any.\r\n\t * @param screen may be {@code null}\r\n\t */\r\n\tpublic void setScreen (Screen screen) {\r\n\t\tif (this.screen != null) this.screen.hide();\r\n\t\tthis.screen = screen;\r\n\t\tif (this.screen != null) {\r\n\t\t\tscreen.show();\r\n\t\t\tscreen.resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\t}\r\n\t}","commit_id":"7e2443e367166f5944ae8a6c4cd8339456c55158","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void buildMipmap () {\r\n\t\tBitmap obitmap = null;\r\n\t\tif (file != null)\r\n\t\t\tobitmap = loadBitmap(file);\r\n\t\telse\r\n\t\t\tobitmap = this.bitmap;\r\n\t\tBitmap bitmap = obitmap;\r\n\r\n\t\tint level = 0;\r\n\t\tint height = bitmap.getHeight();\r\n\t\tint width = bitmap.getWidth();\r\n\t\tLog.d(\"texture\", \"creating texture mipmaps: \" + bitmap.getWidth() + \", \" + bitmap.getHeight());\r\n\r\n\t\tif (!isPowerOfTwo(bitmap.getWidth()) || !isPowerOfTwo(bitmap.getHeight()))\r\n\t\t\tthrow new GdxRuntimeException(\"Dimensions have to be a power of two\");\r\n\r\n\t\twhile (height >= 1 || width >= 1 && level < 4) {\r\n\t\t\tGLUtils.texImage2D(GL10.GL_TEXTURE_2D, level, bitmap, 0);\r\n\t\t\tif (height == 1 || width == 1 || isMipMap == false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tlevel++;\r\n\t\t\tif (height > 1) height /= 2;\r\n\t\t\tif (width > 1) width /= 2;\r\n\r\n\t\t\tBitmap bitmap2 = Bitmap.createScaledBitmap(bitmap, width, height, true);\r\n\t\t\tif (level > 1) bitmap.recycle();\r\n\t\t\tbitmap = bitmap2;\r\n\t\t}\r\n\r\n\t\tif (file != null) obitmap.recycle();\r\n\t}","id":77126,"modified_method":"private void buildMipmap () {\r\n\t\tBitmap obitmap = null;\r\n\t\tif (file != null)\r\n\t\t\tobitmap = loadBitmap(file);\r\n\t\telse\r\n\t\t\tobitmap = this.bitmap;\r\n\t\tBitmap bitmap = obitmap;\r\n\r\n\t\tint level = 0;\r\n\t\tint height = bitmap.getHeight();\r\n\t\tint width = bitmap.getWidth();\r\n\t\tLog.d(\"texture\", \"creating texture mipmaps: \" + bitmap.getWidth() + \", \" + bitmap.getHeight());\r\n\r\n\t\tif (!MathUtils.isPowerOfTwo(bitmap.getWidth()) || !MathUtils.isPowerOfTwo(bitmap.getHeight()))\r\n\t\t\tthrow new GdxRuntimeException(\"Dimensions have to be a power of two\");\r\n\r\n\t\twhile (height >= 1 || width >= 1 && level < 4) {\r\n\t\t\tGLUtils.texImage2D(GL10.GL_TEXTURE_2D, level, bitmap, 0);\r\n\t\t\tif (height == 1 || width == 1 || isMipMap == false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tlevel++;\r\n\t\t\tif (height > 1) height /= 2;\r\n\t\t\tif (width > 1) width /= 2;\r\n\r\n\t\t\tBitmap bitmap2 = Bitmap.createScaledBitmap(bitmap, width, height, true);\r\n\t\t\tif (level > 1) bitmap.recycle();\r\n\t\t\tbitmap = bitmap2;\r\n\t\t}\r\n\r\n\t\tif (file != null) obitmap.recycle();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void dispose () {\r\n\t\tgui.destroy();\r\n\t}","id":77127,"modified_method":"@Override public void dispose () {\r\n\t\ttwl.dispose();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void create () {\r\n\t\tif (gui != null) return;\r\n\r\n\t\tButton button = new Button(\"Click Me\");\r\n\t\tFPSCounter fpsCounter = new FPSCounter(4, 2);\r\n\r\n\t\tDialogLayout layout = new DialogLayout();\r\n\t\tlayout.setTheme(\"\");\r\n\t\tlayout.setHorizontalGroup(layout.createParallelGroup().addWidgets(button, fpsCounter));\r\n\t\tlayout.setVerticalGroup(layout.createSequentialGroup().addWidget(button).addGap(5).addWidget(fpsCounter).addGap(5));\r\n\r\n\t\ttwl = new TwlRenderer();\r\n\t\tgui = new GUI(layout, twl, null);\r\n\t\ttwl.applyTheme(gui, \"data/widgets.xml\", FileType.Internal);\r\n\r\n\t\tguiInputListener = new TwlInputProcessor(gui);\r\n\t}","id":77128,"modified_method":"@Override public void create () {\r\n\t\tButton button = new Button(\"Click Me\");\r\n\t\tFPSCounter fpsCounter = new FPSCounter(4, 2);\r\n\r\n\t\tLayout layout = new Layout();\r\n\t\tlayout.horizontal().sequence(0).parallel(button, fpsCounter).end().gap();\r\n\t\tlayout.vertical().sequence(0, button, 5, fpsCounter, 0);\r\n\r\n\t\ttwl = new TWL(\"data/widgets.xml\", FileType.Internal, layout);\r\n\r\n\t\tinput.addProcessor(twl);\r\n\t\tinput.addProcessor(this);\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void render () {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\r\n\t\tGdx.input.processEvents(guiInputListener);\r\n\t\tgui.update();\r\n\t}","id":77129,"modified_method":"@Override public void render () {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\r\n\t\tGdx.input.processEvents(input);\r\n\t\ttwl.render();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void resize (int width, int height) {\r\n\t\tgui.setSize();\r\n\t\ttwl.setSize();\r\n\t}","id":77130,"modified_method":"@Override public void resize (int width, int height) {\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setScreen(Screen screen) {\r\n\t\tthis.screen.dispose();\r\n\t\tthis.screen = screen;\r\n\t}","id":77131,"modified_method":"public void setScreen (Screen screen) {\r\n\t\tif (this.screen != null) this.screen.hide();\r\n\t\tthis.screen = screen;\r\n\t\tscreen.show();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void resume() {\r\n\t\tscreen.resume();\t\t\r\n\t}","id":77132,"modified_method":"@Override public void resume () {\r\n\t\tif (screen != null) screen.resume();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void dispose() {\t\t\r\n\t\tscreen.dispose();\r\n\t}","id":77133,"modified_method":"@Override public void dispose () {\r\n\t\tif (screen != null) screen.hide();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void resize(int width, int height) {\r\n\t\tscreen.resize(width,height);\r\n\t}","id":77134,"modified_method":"@Override public void resize (int width, int height) {\r\n\t\tif (screen != null) screen.resize(width, height);\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void render() {\r\n\t\tscreen.render(Gdx.graphics.getDeltaTime());\r\n\t}","id":77135,"modified_method":"@Override public void render () {\r\n\t\tif (screen != null) screen.render(Gdx.graphics.getDeltaTime());\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void pause() {\r\n\t\tscreen.pause();\r\n\t}","id":77136,"modified_method":"@Override public void pause () {\r\n\t\tif (screen != null) screen.pause();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"GdxCacheContext (TwlRenderer renderer) {\n\t\tthis.renderer = renderer;\n\t}","id":77137,"modified_method":"GdxCacheContext (GdxRenderer renderer) {\n\t\tthis.renderer = renderer;\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GdxFont (TwlRenderer renderer, BitmapFont bitmapFont, Map<String, String> params, Collection<FontParameter> condParams) {\n\t\tthis.bitmapFont = bitmapFont;\n\t\tthis.renderer = renderer;\n\t\tyOffset = bitmapFont.getLineHeight() - bitmapFont.getBaseLine();\n\n\t\tArrayList<FontState> states = new ArrayList<FontState>();\n\t\tfor (FontParameter p : condParams) {\n\t\t\tHashMap<String, String> effective = new HashMap<String, String>(params);\n\t\t\teffective.putAll(p.getParams());\n\t\t\tstates.add(new FontState(p.getCondition(), effective));\n\t\t}\n\t\tstates.add(new FontState(null, params));\n\t\tthis.fontStates = states.toArray(new FontState[states.size()]);\n\t}","id":77138,"modified_method":"public GdxFont (GdxRenderer renderer, BitmapFont bitmapFont, Map<String, String> params, Collection<FontParameter> condParams) {\n\t\tthis.bitmapFont = bitmapFont;\n\t\tthis.renderer = renderer;\n\t\tyOffset = bitmapFont.getLineHeight() - bitmapFont.getBaseLine();\n\n\t\tArrayList<FontState> states = new ArrayList<FontState>();\n\t\tfor (FontParameter p : condParams) {\n\t\t\tHashMap<String, String> effective = new HashMap<String, String>(params);\n\t\t\teffective.putAll(p.getParams());\n\t\t\tstates.add(new FontState(p.getCondition(), effective));\n\t\t}\n\t\tstates.add(new FontState(null, params));\n\t\tthis.fontStates = states.toArray(new FontState[states.size()]);\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GdxImage (TwlRenderer renderer, Texture texture, int srcX, int srcY, int srcWidth, int srcHeight, Color color,\r\n\t\tboolean tile) {\r\n\t\tthis.renderer = renderer;\r\n\t\twidth = Math.abs(srcWidth);\r\n\t\theight = Math.abs(srcHeight);\r\n\t\tthis.tintColor = color == null ? Color.WHITE : color;\r\n\t\tthis.tile = tile;\r\n\t\tsprite = new Sprite(texture, srcX, srcY, srcWidth, srcHeight);\r\n\t\tsprite.flip(false, true);\r\n\t}","id":77139,"modified_method":"public GdxImage (GdxRenderer renderer, Texture texture, int srcX, int srcY, int srcWidth, int srcHeight, Color color,\r\n\t\tboolean tile) {\r\n\t\tthis.renderer = renderer;\r\n\t\twidth = Math.abs(srcWidth);\r\n\t\theight = Math.abs(srcHeight);\r\n\t\tthis.tintColor = color == null ? Color.WHITE : color;\r\n\t\tthis.tile = tile;\r\n\t\tsprite = new Sprite(texture, srcX, srcY, srcWidth, srcHeight);\r\n\t\tsprite.flip(false, true);\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GdxTexture (TwlRenderer renderer, FileHandle textureFile) {\n\t\tthis.renderer = renderer;\n\t\ttexture = Gdx.graphics.newTexture(textureFile, TextureFilter.Linear, TextureFilter.Linear, TextureWrap.ClampToEdge,\n\t\t\tTextureWrap.ClampToEdge);\n\t}","id":77140,"modified_method":"public GdxTexture (GdxRenderer renderer, FileHandle textureFile) {\n\t\tthis.renderer = renderer;\n\t\ttexture = Gdx.graphics.newTexture(textureFile, TextureFilter.Linear, TextureFilter.Linear, TextureWrap.ClampToEdge,\n\t\t\tTextureWrap.ClampToEdge);\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public abstract void resize(int width, int height);","id":77141,"modified_method":"public void resize (int width, int height) {\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public abstract void resume();","id":77142,"modified_method":"public void resume () {\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public abstract void pause();","id":77143,"modified_method":"public void pause () {\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"public abstract void dispose();","id":77144,"modified_method":"public void dispose () {\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void render () {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\t\tGdx.input.processEvents(guiInputListener);\r\n\t\tgui.update();\r\n\t}","id":77145,"modified_method":"@Override public void render () {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\t\tGdx.input.processEvents(twl);\r\n\t\ttwl.render();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void dispose () {\r\n\t\tgui.destroy();\r\n\t}","id":77146,"modified_method":"@Override public void dispose () {\r\n\t\ttwl.dispose();\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void resize (int width, int height) {\r\n\t\tgui.setSize();\r\n\t\ttwl.setSize();\r\n\t}","id":77147,"modified_method":"@Override public void resize (int width, int height) {\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void create () {\r\n\t\tif (gui != null) return;\r\n\r\n\t\tfinal HTMLTextAreaModel htmlText = new HTMLTextAreaModel();\r\n\t\tTextArea textArea = new TextArea(htmlText);\r\n\t\thtmlText\r\n\t\t\t.setHtml(\"<div style='font-family:heading;text-align:center'>TWL TextAreaTest<\/div><a href='badlogic'><img src='badlogic' id='badlogic' style='float:right; margin:10px'/><\/a>Lorem ipsum dolor sit amet, douchebagus joglus. Sed fermentum gravida turpis, sit amet gravida justo laoreet non. Donec ultrices suscipit metus a mollis. Mollis varius egestas quisque feugiat pellentesque mi, quis scelerisque velit bibendum eget. Nulla orci in enim nisl mattis varius dignissim fringilla.<br/><br/><img src='twllogo' style='float:left; margin:10px'/>Curabitur purus leo, ultricies ut cursus eget, adipiscing in quam. Duis non velit vel mauris vulputate fringilla et quis.<br/><br/>Suspendisse lobortis iaculis tellus id fermentum. Integer fermentum varius pretium. Nullam libero magna, mattis vel placerat ac, dignissim sed lacus. Mauris varius libero id neque auctor a auctor odio fringilla.<br/><br/><div>Mauris orci arcu, porta eget porttitor luctus, malesuada nec metus. Nunc fermentum viverra leo eu pretium. Curabitur vitae nibh massa, imperdiet egestas lectus. Nulla odio quam, lobortis eget fermentum non, faucibus ac mi. Morbi et libero nulla. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam sit amet rhoncus nulla. Morbi consectetur ante convallis ante tristique et porta ligula hendrerit. Donec rhoncus ornare augue, sit amet lacinia nulla auctor venenatis.<\/div><br/><div>Etiam semper egestas porta. Proin luctus porta faucibus. Curabitur sagittis, lorem nec imperdiet ullamcorper, sem risus consequat purus, non faucibus turpis lorem ut arcu. Nunc tempus lobortis enim vitae facilisis. Morbi posuere quam nec sem aliquam eleifend.<\/div>\");\r\n\t\tScrollPane scrollPane = new ScrollPane(textArea);\r\n\t\tscrollPane.setFixed(ScrollPane.Fixed.HORIZONTAL);\r\n\t\tFPSCounter fpsCounter = new FPSCounter(4, 2);\r\n\r\n\t\tDialogLayout layout = new DialogLayout();\r\n\t\tlayout.setTheme(\"\");\r\n\t\tlayout.setHorizontalGroup(layout.createParallelGroup().addWidgets(scrollPane, fpsCounter));\r\n\t\tlayout.setVerticalGroup(layout.createSequentialGroup().addWidget(scrollPane).addGap(5).addWidget(fpsCounter).addGap(5));\r\n\r\n\t\ttwl = new TwlRenderer();\r\n\t\tgui = new GUI(layout, twl, null);\r\n\t\ttwl.applyTheme(gui, \"data/widgets.xml\", FileType.Internal);\r\n\r\n\t\ttextArea.addCallback(new TextArea.Callback() {\r\n\t\t\tTimer timer;\r\n\t\t\tint speed = 8, size = 256;\r\n\r\n\t\t\tpublic void handleLinkClicked (String href) {\r\n\t\t\t\tfinal Element element = htmlText.getElementById(\"badlogic\");\r\n\t\t\t\tif (timer == null) {\r\n\t\t\t\t\ttimer = gui.createTimer();\r\n\t\t\t\t\ttimer.setDelay(32);\r\n\t\t\t\t\ttimer.setContinuous(true);\r\n\t\t\t\t\ttimer.setCallback(new Runnable() {\r\n\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\tsize += speed;\r\n\t\t\t\t\t\t\tif (size == 256 || size == 128) timer.stop();\r\n\t\t\t\t\t\t\tStyle style = element.getStyle();\r\n\t\t\t\t\t\t\tstyle = style.with(StyleAttribute.WIDTH, new Value(size, Value.Unit.PX));\r\n\t\t\t\t\t\t\tstyle = style.with(StyleAttribute.HEIGHT, new Value(size, Value.Unit.PX));\r\n\t\t\t\t\t\t\telement.setStyle(style);\r\n\t\t\t\t\t\t\thtmlText.domModified();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tif (timer.isRunning()) return;\r\n\t\t\t\ttimer.start();\r\n\t\t\t\tSystem.out.println();\r\n\t\t\t\tspeed = -speed;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tguiInputListener = new TwlInputProcessor(gui);\r\n\t}","id":77148,"modified_method":"@Override public void create () {\r\n\t\tfinal HTMLTextAreaModel htmlText = new HTMLTextAreaModel();\r\n\t\tTextArea textArea = new TextArea(htmlText);\r\n\t\thtmlText\r\n\t\t\t.setHtml(\"<div style='font-family:heading;text-align:center'>TWL TextAreaTest<\/div><a href='badlogic'><img src='badlogic' id='badlogic' style='float:right; margin:10px'/><\/a>Lorem ipsum dolor sit amet, douchebagus joglus. Sed fermentum gravida turpis, sit amet gravida justo laoreet non. Donec ultrices suscipit metus a mollis. Mollis varius egestas quisque feugiat pellentesque mi, quis scelerisque velit bibendum eget. Nulla orci in enim nisl mattis varius dignissim fringilla.<br/><br/><img src='twllogo' style='float:left; margin:10px'/>Curabitur purus leo, ultricies ut cursus eget, adipiscing in quam. Duis non velit vel mauris vulputate fringilla et quis.<br/><br/>Suspendisse lobortis iaculis tellus id fermentum. Integer fermentum varius pretium. Nullam libero magna, mattis vel placerat ac, dignissim sed lacus. Mauris varius libero id neque auctor a auctor odio fringilla.<br/><br/><div>Mauris orci arcu, porta eget porttitor luctus, malesuada nec metus. Nunc fermentum viverra leo eu pretium. Curabitur vitae nibh massa, imperdiet egestas lectus. Nulla odio quam, lobortis eget fermentum non, faucibus ac mi. Morbi et libero nulla. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam sit amet rhoncus nulla. Morbi consectetur ante convallis ante tristique et porta ligula hendrerit. Donec rhoncus ornare augue, sit amet lacinia nulla auctor venenatis.<\/div><br/><div>Etiam semper egestas porta. Proin luctus porta faucibus. Curabitur sagittis, lorem nec imperdiet ullamcorper, sem risus consequat purus, non faucibus turpis lorem ut arcu. Nunc tempus lobortis enim vitae facilisis. Morbi posuere quam nec sem aliquam eleifend.<\/div>\");\r\n\t\tScrollPane scrollPane = new ScrollPane(textArea);\r\n\t\tscrollPane.setFixed(ScrollPane.Fixed.HORIZONTAL);\r\n\t\tFPSCounter fpsCounter = new FPSCounter(4, 2);\r\n\r\n\t\tLayout layout = new Layout();\r\n\t\tlayout.horizontal().parallel(scrollPane, fpsCounter);\r\n\t\tlayout.vertical().sequence(scrollPane, 5, fpsCounter, 5);\r\n\r\n\t\ttwl = new TWL(\"data/widgets.xml\", FileType.Internal, layout);\r\n\r\n\t\ttextArea.addCallback(new TextArea.Callback() {\r\n\t\t\tTimer timer;\r\n\t\t\tint speed = 8, size = 256;\r\n\r\n\t\t\tpublic void handleLinkClicked (String href) {\r\n\t\t\t\tfinal Element element = htmlText.getElementById(\"badlogic\");\r\n\t\t\t\tif (timer == null) {\r\n\t\t\t\t\ttimer = twl.getGUI().createTimer();\r\n\t\t\t\t\ttimer.setDelay(32);\r\n\t\t\t\t\ttimer.setContinuous(true);\r\n\t\t\t\t\ttimer.setCallback(new Runnable() {\r\n\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\tsize += speed;\r\n\t\t\t\t\t\t\tif (size == 256 || size == 128) timer.stop();\r\n\t\t\t\t\t\t\tStyle style = element.getStyle();\r\n\t\t\t\t\t\t\tstyle = style.with(StyleAttribute.WIDTH, new Value(size, Value.Unit.PX));\r\n\t\t\t\t\t\t\tstyle = style.with(StyleAttribute.HEIGHT, new Value(size, Value.Unit.PX));\r\n\t\t\t\t\t\t\telement.setStyle(style);\r\n\t\t\t\t\t\t\thtmlText.domModified();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tif (timer.isRunning()) return;\r\n\t\t\t\ttimer.start();\r\n\t\t\t\tSystem.out.println();\r\n\t\t\t\tspeed = -speed;\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"9b9e3f501405fc21dd39824c1ac07ecdc1fc2736","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Starts the embedded web application server.\n     */\n    public synchronized void start() throws Exception {\n        if (server!=null) throw new IllegalStateException(\"\"+this+\" already running\");\n\n        if (actualPort==-1){\n            actualPort = LocalhostMachineProvisioningLocation.obtainPort(getAddress(), httpsEnabled?httpsPort:port);\n        }\n\n        if(httpsEnabled){\n            log.info(\"Starting secured Brooklyn console at \"+getRootUrl()+\", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        } else{\n            log.info(\"Starting unsecured Brooklyn console at \" + getRootUrl() + \", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        }\n\n        server = new Server(actualPort);\n\n        if(httpsEnabled){\n            //by default the server is configured with a http connector, this needs to be removed since we are going\n            //to provide https\n            for(Connector c: server.getConnectors()){\n                server.removeConnector(c);\n            }\n\n            SslContextFactory sslContextFactory = new SslContextFactory();\n            sslContextFactory.setKeyStore(checkFileExists(keystorePath, \"keystore\"));\n            sslContextFactory.setKeyStorePassword(keystorePassword);\n            if (!Strings.isEmpty(truststorePath)) {\n                sslContextFactory.setTrustStore(checkFileExists(truststorePath, \"truststore\"));\n                sslContextFactory.setTrustStorePassword(trustStorePassword);\n            }\n\n            SslSocketConnector sslSocketConnector = new SslSocketConnector(sslContextFactory);\n            sslSocketConnector.setPort(actualPort);\n            server.addConnector(sslSocketConnector);\n        }\n\n        addShutdownHook();\n\n        for (Map.Entry<String, String> entry : wars.entrySet()) {\n            String pathSpec = entry.getKey();\n            String warUrl = entry.getValue();\n            deploy(pathSpec, warUrl);\n        }\n\n        deploy(\"/\", war);\n\n        server.setHandler(handlers);\n        server.start();\n        //reinit required because grails wipes our language extension bindings\n        BrooklynLanguageExtensions.reinit();\n\n        if(httpsEnabled){\n            log.info(\"Started secured Brooklyn console at \"+getRootUrl()+\", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        }else{\n            log.info(\"Started unsecured Brooklyn console at \"+getRootUrl()+\", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        }\n    }","id":77149,"modified_method":"/**\n     * Starts the embedded web application server.\n     */\n    public synchronized void start() throws Exception {\n        if (server!=null) throw new IllegalStateException(\"\"+this+\" already running\");\n\n        if (actualPort==-1){\n            actualPort = LocalhostMachineProvisioningLocation.obtainPort(getAddress(), httpsEnabled?httpsPort:port);\n            if (actualPort == -1) \n                throw new IllegalStateException(\"Unable to provision port for web console (wanted \"+(httpsEnabled?httpsPort:port)+\")\");\n        }\n\n        if(httpsEnabled){\n            log.info(\"Starting secured Brooklyn console at \"+getRootUrl()+\", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        } else{\n            log.info(\"Starting unsecured Brooklyn console at \" + getRootUrl() + \", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        }\n\n        server = new Server(actualPort);\n\n        if(httpsEnabled){\n            //by default the server is configured with a http connector, this needs to be removed since we are going\n            //to provide https\n            for(Connector c: server.getConnectors()){\n                server.removeConnector(c);\n            }\n\n            SslContextFactory sslContextFactory = new SslContextFactory();\n            sslContextFactory.setKeyStore(checkFileExists(keystorePath, \"keystore\"));\n            sslContextFactory.setKeyStorePassword(keystorePassword);\n            if (!Strings.isEmpty(truststorePath)) {\n                sslContextFactory.setTrustStore(checkFileExists(truststorePath, \"truststore\"));\n                sslContextFactory.setTrustStorePassword(trustStorePassword);\n            }\n\n            SslSocketConnector sslSocketConnector = new SslSocketConnector(sslContextFactory);\n            sslSocketConnector.setPort(actualPort);\n            server.addConnector(sslSocketConnector);\n        }\n\n        addShutdownHook();\n\n        for (Map.Entry<String, String> entry : wars.entrySet()) {\n            String pathSpec = entry.getKey();\n            String warUrl = entry.getValue();\n            deploy(pathSpec, warUrl);\n        }\n\n        deploy(\"/\", war);\n\n        server.setHandler(handlers);\n        server.start();\n        //reinit required because grails wipes our language extension bindings\n        BrooklynLanguageExtensions.reinit();\n\n        if(httpsEnabled){\n            log.info(\"Started secured Brooklyn console at \"+getRootUrl()+\", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        }else{\n            log.info(\"Started unsecured Brooklyn console at \"+getRootUrl()+\", running \" + war + (wars != null ? \" and \" + wars.values() : \"\"));\n        }\n    }","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** method used for calls such as   entity.effector(arg1, arg2)\n     * get routed here from AbstractEntity.invokeMethod */\n    private static Object[] prepareArgsForEffectorFromArray(Effector<?> eff, Object args[]) {\n        int newArgsNeeded = eff.getParameters().size();\n        if (args.length==1 && args[0] instanceof Map)\n            if (newArgsNeeded!=1 || !eff.getParameters().get(0).getParameterClass().isAssignableFrom(args[0].getClass()))\n                // treat a map in an array as a map passed directly (unless the method takes a single-arg map)\n                // this is to support   effector(param1: val1)\n                return prepareArgsForEffectorFromMap(eff, (Map)args[0]);\n        \n        List l = Lists.newArrayList();\n        l.addAll(Arrays.asList(args));\n        List newArgs = Lists.newArrayList();\n\n        for (int index = 0; index < eff.getParameters().size(); index++) {\n            ParameterType<?> it = eff.getParameters().get(index);\n            \n            if (l.size() >= newArgsNeeded)\n                //all supplied (unnamed) arguments must be used; ignore map\n                newArgs.add(l.remove(0));\n            // TODO do we ignore arguments in the same order that groovy does?\n            else if (!l.isEmpty() && it.getParameterClass().isInstance(l.get(0))) {\n                //if there are parameters supplied, and type is correct, they get applied before default values\n                //(this is akin to groovy)\n                newArgs.add(l.remove(0));\n            } else if (it instanceof BasicParameterType && ((BasicParameterType)it).hasDefaultValue()) {\n                //finally, default values are used to make up for missing parameters\n                newArgs.add(((BasicParameterType)it).getDefaultValue());\n            } else {\n                throw new IllegalArgumentException(\"Invalid arguments (count mismatch) for effector \"+eff+\": \"+args);\n            }\n\n            newArgsNeeded--;\n        }\n        if (newArgsNeeded>0)\n            throw new IllegalArgumentException(\"Invalid arguments (missing \"+newArgsNeeded+\") for effector \"+eff+\": \"+args);\n        if (!l.isEmpty())\n            throw new IllegalArgumentException(\"Invalid arguments (\"+l.size()+\" extra) for effector \"+eff+\": \"+args);\n        return newArgs.toArray(new Object[newArgs.size()]);    \n    }","id":77150,"modified_method":"/** method used for calls such as   entity.effector(arg1, arg2)\n     * get routed here from AbstractEntity.invokeMethod */\n    private static Object[] prepareArgsForEffectorFromArray(Effector<?> eff, Object args[]) {\n        int newArgsNeeded = eff.getParameters().size();\n        if (args.length==1 && args[0] instanceof Map)\n            if (newArgsNeeded!=1 || !eff.getParameters().get(0).getParameterClass().isAssignableFrom(args[0].getClass()))\n                // treat a map in an array as a map passed directly (unless the method takes a single-arg map)\n                // this is to support   effector(param1: val1)\n                return prepareArgsForEffectorFromMap(eff, (Map)args[0]);\n        \n        return prepareArgsForEffectorAsMapFromArray(eff, args).values().toArray(new Object[0]);\n    }","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** invokes the given effector with the given named arguments on the entitiesToCall, from the calling context of the callingEntity;\n\t * intended for use only from the callingEntity\n\t * @return ParallelTask containing a results from each invocation; calling get() on the result will block until all complete,\n\t * and throw error if any threw error   \n\t */\n\tpublic static <T> Task<List<T>> invokeEffectorList(EntityLocal callingEntity, Iterable<Entity> entitiesToCall, \n\t        final Effector<T> effector, final Map<String,?> parameters) {\n        // formulation is complicated, but it is building up a list of tasks, without blocking on them initially,\n        // but ensuring that when the parallel task is gotten it does block on all of them\n\t    // TODO why not just get list of tasks with `entity.invoke(effector, parameters))`?\n\t    //      What is advantage of invoking in callingEntity's context?\n        \n\t\tif (entitiesToCall == null || Iterables.isEmpty(entitiesToCall)) return null;\n\t\tList<Callable<T>> tasks = Lists.newArrayList();\n\t\t\n\t\tfor (final Entity entity : entitiesToCall) {\n\t\t    tasks.add(new Callable<T>() {\n\t\t        public T call() throws Exception {\n\t\t            return entity.invoke(effector, parameters).get();\n\t\t        }});\n\t\t}\n\t    ParallelTask<T> invoke = new ParallelTask<T>(tasks);\n\t    callingEntity.getManagementSupport().getExecutionContext().submit(invoke);\n\t    return invoke;\n\t}","id":77151,"modified_method":"/** invokes the given effector with the given named arguments on the entitiesToCall, from the calling context of the callingEntity;\n\t * intended for use only from the callingEntity.\n\t * @return ParallelTask containing a results from each invocation; calling get() on the result will block until all complete,\n\t * and throw error if any threw error   \n\t */\n\tpublic static <T> Task<List<T>> invokeEffectorList(EntityLocal callingEntity, Iterable<? extends Entity> entitiesToCall, \n\t        final Effector<T> effector, final Map<String,?> parameters) {\n        // formulation is complicated, but it is building up a list of tasks, without blocking on them initially,\n        // but ensuring that when the parallel task is gotten it does block on all of them\n\t    // TODO why not just get list of tasks with `entity.invoke(effector, parameters))`?\n\t    //      What is advantage of invoking in callingEntity's context?\n        \n\t\tif (entitiesToCall == null || Iterables.isEmpty(entitiesToCall)) return null;\n\t\tList<Callable<T>> tasks = Lists.newArrayList();\n\t\t\n\t\tfor (final Entity entity : entitiesToCall) {\n\t\t    tasks.add(new Callable<T>() {\n\t\t        public T call() throws Exception {\n\t\t            return entity.invoke(effector, parameters).get();\n\t\t        }});\n\t\t}\n\t    ParallelTask<T> invoke = new ParallelTask<T>(tasks);\n\t    callingEntity.getManagementSupport().getExecutionContext().submit(invoke);\n\t    return invoke;\n\t}","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** stops, destroys, and unmanages the given entity -- does as many as are valid given the type and state */\n    public static void destroy(Entity e) {\n        if (isManaged(e)) {\n            if (e instanceof Startable) ((Startable)e).stop();\n            if (e instanceof AbstractEntity) ((AbstractEntity)e).destroy();\n            unmanage(e);\n        }\n    }","id":77152,"modified_method":"/** stops, destroys, and unmanages the given entity -- does as many as are valid given the type and state */\n    public static void destroy(Entity e) {\n        if (isManaged(e)) {\n            if (e instanceof Startable) Entities.invokeEffector((EntityLocal)e, e, Startable.STOP);\n            if (e instanceof AbstractEntity) ((AbstractEntity)e).destroy();\n            unmanage(e);\n        }\n    }","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static <T> Task<List<T>> invokeEffectorList(EntityLocal callingEntity, Iterable<Entity> entitiesToCall, \n            final Effector<T> effector) {\n        return invokeEffectorList(callingEntity, entitiesToCall, effector, Collections.<String,Object>emptyMap());\n    }","id":77153,"modified_method":"public static <T> Task<List<T>> invokeEffectorList(EntityLocal callingEntity, Iterable<? extends Entity> entitiesToCall, \n            final Effector<T> effector) {\n        return invokeEffectorList(callingEntity, entitiesToCall, effector, Collections.<String,Object>emptyMap());\n    }","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** convenience for starting an entity, esp a new Startable instance which has been created dynamically\n     * (after the application is started) */\n    public static void start(Entity e, Collection<Location> locations) {\n        if (!manage(e)) {\n            log.warn(\"Using discouraged Entities.start(Application, Locations) -- should create and use the preferred management context\");\n            startManagement(e);\n        }\n        if (e instanceof Startable) ((Startable)e).start(locations);\n    }","id":77154,"modified_method":"/** convenience for starting an entity, esp a new Startable instance which has been created dynamically\n     * (after the application is started) */\n    public static void start(Entity e, Collection<Location> locations) {\n        if (!isManaged(e) && !manage(e)) {\n            log.warn(\"Using discouraged mechanism to start management -- Entities.start(Application, Locations) -- caller should create and use the preferred management context\");\n            startManagement(e);\n        }\n        if (e instanceof Startable) Entities.invokeEffectorWithMap((EntityLocal)e, e, Startable.START,\n                MutableMap.of(\"locations\", locations)).getUnchecked();\n    }","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** Common implementation for restart in parent nodes; just invokes stop on all children of the entity */\n    public static void restart(EntityLocal e) {\n        log.debug(\"Restarting entity \"+e);\n        Iterable<Entity> startables = Iterables.filter(e.getOwnedChildren(), Predicates.instanceOf(Startable.class));\n        \n        if (!Iterables.isEmpty(startables)) {\n            Task task = Entities.invokeEffectorList(e, startables, Startable.RESTART);\n            try {\n                task.get();\n            } catch (ExecutionException ee) {\n                throw Throwables.propagate(ee.getCause());\n            } catch (InterruptedException ee) {\n                Thread.currentThread().interrupt();\n                throw Throwables.propagate(ee);\n            }\n        }\n        if (log.isDebugEnabled()) log.debug(\"Restarted entity \"+e);\n    }","id":77155,"modified_method":"/** Common implementation for restart in parent nodes; just invokes stop on all children of the entity */\n    public static void restart(EntityLocal e) {\n        log.debug(\"Restarting entity \"+e);\n        Iterable<Entity> startables = Iterables.filter(e.getOwnedChildren(), Predicates.instanceOf(Startable.class));\n        \n        if (!Iterables.isEmpty(startables)) {\n            Entities.invokeEffectorList(e, startables, Startable.RESTART).getUnchecked();\n        }\n        if (log.isDebugEnabled()) log.debug(\"Restarted entity \"+e);\n    }","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** Common implementation for start in parent nodes; just invokes start on all children of the entity */\n\tpublic static void start(EntityLocal e, Collection<? extends Location> locations) {\n        log.info(\"Starting entity \"+e+\" at \"+locations);\n        Iterable<Entity> startables = Iterables.filter(e.getOwnedChildren(), Predicates.instanceOf(Startable.class));\n\n        if (!Iterables.isEmpty(startables) && truth(locations) && !locations.isEmpty()) {\n\t        Task start = Entities.invokeEffectorList(e, startables, Startable.START, MutableMap.of(\"locations\", locations));\n\t        try {\n\t            start.get();\n\t        } catch (ExecutionException ee) {\n\t            throw Throwables.propagate(ee.getCause());\n\t        } catch (InterruptedException ee) {\n\t            Thread.currentThread().interrupt();\n\t            throw Throwables.propagate(ee);\n            }\n        }\n\t}","id":77156,"modified_method":"/** Common implementation for start in parent nodes; just invokes start on all children of the entity */\n\tpublic static void start(EntityLocal e, Collection<? extends Location> locations) {\n        log.info(\"Starting entity \"+e+\" at \"+locations);\n        Iterable<Entity> startables = Iterables.filter(e.getOwnedChildren(), Predicates.instanceOf(Startable.class));\n\n        if (!Iterables.isEmpty(startables)) {\n\t        Entities.invokeEffectorList(e, startables, Startable.START, MutableMap.of(\"locations\", locations)).getUnchecked();\n        }\n\t}","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** Common implementation for stop in parent nodes; just invokes stop on all children of the entity */\n\tpublic static void stop(EntityLocal e) {\n        log.debug(\"Stopping entity \"+e);\n        Iterable<Entity> startables = Iterables.filter(e.getOwnedChildren(), Predicates.instanceOf(Startable.class));\n\t\t\n\t\tif (!Iterables.isEmpty(startables)) {\n\t\t\tTask task = Entities.invokeEffectorList(e, startables, Startable.STOP);\n\t\t\ttry {\n\t\t\t\ttask.get();\n            } catch (ExecutionException ee) {\n                throw Throwables.propagate(ee.getCause());\n            } catch (InterruptedException ee) {\n                Thread.currentThread().interrupt();\n                throw Throwables.propagate(ee);\n\t\t\t}\n\t\t}\n        if (log.isDebugEnabled()) log.debug(\"Stopped entity \"+e);\n\t}","id":77157,"modified_method":"/** Common implementation for stop in parent nodes; just invokes stop on all children of the entity */\n\tpublic static void stop(EntityLocal e) {\n        log.debug(\"Stopping entity \"+e);\n        Iterable<Entity> startables = Iterables.filter(e.getOwnedChildren(), Predicates.instanceOf(Startable.class));\n\t\t\n\t\tif (!Iterables.isEmpty(startables)) {\n\t\t\tEntities.invokeEffectorList(e, startables, Startable.STOP).getUnchecked();\n\t\t}\n        if (log.isDebugEnabled()) log.debug(\"Stopped entity \"+e);\n\t}","commit_id":"50d51704609d638f177161e533528b3f64cef37e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Nullable\n  public HgCommandResult execute() {\n    HgCommandExecutor commandExecutor = new HgCommandExecutor(project);\n    commandExecutor.setShowOutput(true);\n    List<String> arguments = new LinkedList<String>();\n    if (StringUtils.isNotBlank(revision)) {\n      arguments.add(\"--rev\");\n      arguments.add(revision);\n    } else if (StringUtils.isNotBlank(branch)) {\n      arguments.add(branch);\n    }\n    return commandExecutor.executeInCurrentThread(repo, \"merge\", arguments);\n  }","id":77158,"modified_method":"@Nullable\n  public HgCommandResult execute() {\n    HgCommandExecutor commandExecutor = new HgCommandExecutor(project);\n    commandExecutor.setShowOutput(true);\n    List<String> arguments = new LinkedList<String>();\n    if (StringUtils.isNotBlank(revision)) {\n      arguments.add(\"--rev\");\n      arguments.add(revision);\n    } else if (StringUtils.isNotBlank(branch)) {\n      arguments.add(branch);\n    }\n    final HgCommandResult result = commandExecutor.executeInCurrentThread(repo, \"merge\", arguments);\n    project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project);\n    return result;\n  }","commit_id":"7e2cd43a4011a1cee9597d6ccf905a296ff136eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void continueRebase() {\n    new HgCommandExecutor(project).execute(repo, \"rebase\", Arrays.asList(\"--continue\"), null);\n  }","id":77159,"modified_method":"public void continueRebase() {\n    new HgCommandExecutor(project).execute(repo, \"rebase\", Arrays.asList(\"--continue\"), null);\n    project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project);\n  }","commit_id":"7e2cd43a4011a1cee9597d6ccf905a296ff136eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(HgFile hgFile, HgRevisionNumber vcsRevisionNumber, boolean backupFile) {\n    List<String> arguments = new LinkedList<String>();\n\n    if (vcsRevisionNumber != null) {\n      arguments.add(\"--rev\");\n      if (StringUtils.isNotBlank(vcsRevisionNumber.getChangeset())) {\n        arguments.add(vcsRevisionNumber.getChangeset());\n      }\n      else {\n        arguments.add(vcsRevisionNumber.getRevision());\n      }\n    }\n\n    if (!backupFile) {\n      arguments.add(\"--no-backup\");\n    }\n\n    ContainerUtil.addAll(arguments, hgFile.getRelativePath());\n\n    new HgCommandExecutor(project).execute(hgFile.getRepo(), \"revert\", arguments, null);\n  }","id":77160,"modified_method":"public void execute(HgFile hgFile, HgRevisionNumber vcsRevisionNumber, boolean backupFile) {\n    List<String> arguments = new LinkedList<String>();\n\n    if (vcsRevisionNumber != null) {\n      arguments.add(\"--rev\");\n      if (StringUtils.isNotBlank(vcsRevisionNumber.getChangeset())) {\n        arguments.add(vcsRevisionNumber.getChangeset());\n      }\n      else {\n        arguments.add(vcsRevisionNumber.getRevision());\n      }\n    }\n\n    if (!backupFile) {\n      arguments.add(\"--no-backup\");\n    }\n\n    ContainerUtil.addAll(arguments, hgFile.getRelativePath());\n\n    new HgCommandExecutor(project).execute(hgFile.getRepo(), \"revert\", arguments, null);\n    project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project);\n  }","commit_id":"7e2cd43a4011a1cee9597d6ccf905a296ff136eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public HgCommandResult execute() {\n    List<String> arguments = new LinkedList<String>();\n    if (clean) {\n      arguments.add(\"--clean\");\n    }\n\n    if (StringUtils.isNotBlank(revision)) {\n      arguments.add(\"--rev\");\n      arguments.add(revision);\n    } else if (StringUtils.isNotBlank(branch)) {\n      arguments.add(branch);\n    }\n\n    final HgCommandExecutor executor = new HgCommandExecutor(project);\n    executor.setShowOutput(true);\n    return executor.executeInCurrentThread(repo, \"update\", arguments);\n  }","id":77161,"modified_method":"@Nullable\n  public HgCommandResult execute() {\n    List<String> arguments = new LinkedList<String>();\n    if (clean) {\n      arguments.add(\"--clean\");\n    }\n\n    if (StringUtils.isNotBlank(revision)) {\n      arguments.add(\"--rev\");\n      arguments.add(revision);\n    } else if (StringUtils.isNotBlank(branch)) {\n      arguments.add(branch);\n    }\n\n    final HgCommandExecutor executor = new HgCommandExecutor(project);\n    executor.setShowOutput(true);\n    final HgCommandResult result = executor.executeInCurrentThread(repo, \"update\", arguments);\n    project.getMessageBus().syncPublisher(HgVcs.BRANCH_TOPIC).update(project);\n    return result;\n  }","commit_id":"7e2cd43a4011a1cee9597d6ccf905a296ff136eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void registrationTerminated() {\n        synchronized (channels) {\n            // Copy off the set to avoid ConcurrentModificationException\n            final Set<T> copy = new HashSet<T>(channels);\n            for (T channel : copy) {\n                closeChannelOnShutdown(channel);\n            }\n        }\n    }","id":77162,"modified_method":"@Override\n    public void registrationTerminated() {\n        final Set<T> copy;\n        synchronized (channels) {\n            // Copy off the set to avoid ConcurrentModificationException\n            copy = new HashSet<T>(channels);\n        }\n        for (final T channel : copy) {\n            closeChannelOnShutdown(channel);\n        }\n    }","commit_id":"5e28783ff034389f47a126060dc591e1795899e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void createHostRegistry(final ManagementResourceRegistration root, final HostControllerConfigurationPersister configurationPersister,\n                                          final HostControllerEnvironment environment, final HostRunningModeControl runningModeControl,\n                                          final HostFileRepository localFileRepository,\n                                          final LocalHostControllerInfoImpl hostControllerInfo, final ServerInventory serverInventory,\n                                          final HostFileRepository remoteFileRepository,\n                                          final ContentRepository contentRepository,\n                                          final DomainController domainController,\n                                          final ExtensionRegistry extensionRegistry,\n                                          final AbstractVaultReader vaultReader,\n                                          final IgnoredDomainResourceRegistry ignoredRegistry,\n                                          final ControlledProcessState processState) {\n        // Add of the host itself\n        ManagementResourceRegistration hostRegistration = root.registerSubModel(PathElement.pathElement(HOST), HostDescriptionProviders.HOST_ROOT_PROVIDER);\n        LocalHostAddHandler handler = new LocalHostAddHandler(environment, ignoredRegistry);\n        hostRegistration.registerOperationHandler(LocalHostAddHandler.OPERATION_NAME, handler, handler, false, OperationEntry.EntryType.PRIVATE);\n\n        // Global operations\n        EnumSet<OperationEntry.Flag> flags = EnumSet.of(OperationEntry.Flag.READ_ONLY);\n        root.registerOperationHandler(READ_RESOURCE_OPERATION, GlobalOperationHandlers.READ_RESOURCE, CommonProviders.READ_RESOURCE_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_ATTRIBUTE_OPERATION, GlobalOperationHandlers.READ_ATTRIBUTE, CommonProviders.READ_ATTRIBUTE_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_NAMES, CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_RESOURCES, CommonProviders.READ_CHILDREN_RESOURCES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(UNDEFINE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.UNDEFINE_ATTRIBUTE, CommonProviders.UNDEFINE_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.WRITE_ATTRIBUTE, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(ValidateOperationHandler.OPERATION_NAME, ValidateOperationHandler.INSTANCE, ValidateOperationHandler.INSTANCE, false, EntryType.PUBLIC, EnumSet.of(Flag.READ_ONLY));\n        root.registerOperationHandler(WhoAmIOperation.OPERATION_NAME, WhoAmIOperation.INSTANCE, WhoAmIOperation.INSTANCE, true);\n\n        // Other root resource operations\n        root.registerOperationHandler(CompositeOperationHandler.NAME, CompositeOperationHandler.INSTANCE, CompositeOperationHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        // Host root resource operations\n        XmlMarshallingHandler xmh = new HostXmlMarshallingHandler(configurationPersister.getHostPersister(), hostControllerInfo);\n        hostRegistration.registerOperationHandler(XmlMarshallingHandler.OPERATION_NAME, xmh, xmh, false, OperationEntry.EntryType.PUBLIC, flags);\n\n        hostRegistration.registerReadWriteAttribute(HostRootDescription.DIRECTORY_GROUPING, null, new ReloadRequiredWriteAttributeHandler(HostRootDescription.DIRECTORY_GROUPING));\n\n        hostRegistration.registerOperationHandler(NamespaceAddHandler.OPERATION_NAME, NamespaceAddHandler.INSTANCE, NamespaceAddHandler.INSTANCE, false);\n        hostRegistration.registerOperationHandler(NamespaceRemoveHandler.OPERATION_NAME, NamespaceRemoveHandler.INSTANCE, NamespaceRemoveHandler.INSTANCE, false);\n        hostRegistration.registerOperationHandler(SchemaLocationAddHandler.OPERATION_NAME, SchemaLocationAddHandler.INSTANCE, SchemaLocationAddHandler.INSTANCE, false);\n        hostRegistration.registerOperationHandler(SchemaLocationRemoveHandler.OPERATION_NAME, SchemaLocationRemoveHandler.INSTANCE, SchemaLocationRemoveHandler.INSTANCE, false);\n\n        hostRegistration.registerReadWriteAttribute(NAME, environment.getProcessNameReadHandler(), environment.getProcessNameWriteHandler(), Storage.CONFIGURATION);\n        hostRegistration.registerReadOnlyAttribute(MASTER, IsMasterHandler.INSTANCE, Storage.RUNTIME);\n        hostRegistration.registerReadOnlyAttribute(HOST_STATE, new ProcessStateAttributeHandler(processState), Storage.RUNTIME);\n\n        StartServersHandler ssh = new StartServersHandler(environment, serverInventory, runningModeControl);\n        hostRegistration.registerOperationHandler(StartServersHandler.OPERATION_NAME, ssh, ssh, false, OperationEntry.EntryType.PRIVATE);\n\n        HostShutdownHandler hsh = new HostShutdownHandler(domainController);\n        hostRegistration.registerOperationHandler(HostShutdownHandler.OPERATION_NAME, hsh, hsh);\n\n        hostRegistration.registerOperationHandler(ResolveExpressionHandler.OPERATION_NAME, ResolveExpressionHandler.INSTANCE,\n                ResolveExpressionHandler.INSTANCE, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        hostRegistration.registerOperationHandler(ResolveExpressionOnHostHandler.OPERATION_NAME, ResolveExpressionOnHostHandler.INSTANCE,\n                ResolveExpressionOnHostHandler.INSTANCE, EnumSet.of(OperationEntry.Flag.READ_ONLY, OperationEntry.Flag.DOMAIN_PUSH_TO_SERVERS));\n\n        HostProcessReloadHandler reloadHandler = new HostProcessReloadHandler(HostControllerService.HC_SERVICE_NAME, runningModeControl, HostRootDescription.getResourceDescriptionResolver(\"host\"));\n        hostRegistration.registerOperationHandler(ProcessReloadHandler.OPERATION_NAME, reloadHandler, reloadHandler);\n        RunningModeReadHandler.createAndRegister(runningModeControl, hostRegistration);\n\n        DomainServerLifecycleHandlers.initializeServerInventory(serverInventory);\n\n        hostRegistration.registerOperationHandler(SpecifiedInterfaceResolveHandler.OPERATION_NAME, SpecifiedInterfaceResolveHandler.INSTANCE, SpecifiedInterfaceResolveHandler.INSTANCE);\n        ValidateOperationHandler validateOperationHandler = hostControllerInfo.isMasterDomainController() ? ValidateOperationHandler.INSTANCE : ValidateOperationHandler.SLAVE_HC_INSTANCE;\n        hostRegistration.registerOperationHandler(ValidateOperationHandler.OPERATION_NAME, validateOperationHandler, validateOperationHandler, false, EntryType.PRIVATE, EnumSet.of(Flag.READ_ONLY));\n\n\n        // System Properties\n        ManagementResourceRegistration sysProps = hostRegistration.registerSubModel(PathElement.pathElement(SYSTEM_PROPERTY), HostDescriptionProviders.SYSTEM_PROPERTIES_PROVIDER);\n        sysProps.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, false);\n        sysProps.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        sysProps.registerReadWriteAttribute(VALUE, null, SystemPropertyValueWriteAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        sysProps.registerReadWriteAttribute(BOOT_TIME, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n\n        /////////////////////////////////////////\n        // Core Services\n\n        //vault\n        ManagementResourceRegistration vault = hostRegistration.registerSubModel(PathElement.pathElement(CORE_SERVICE, VAULT), CommonProviders.VAULT_PROVIDER);\n        VaultAddHandler vah = new VaultAddHandler(vaultReader);\n        vault.registerOperationHandler(VaultAddHandler.OPERATION_NAME, vah, vah, false);\n        VaultRemoveHandler vrh = new VaultRemoveHandler(vaultReader);\n        vault.registerOperationHandler(VaultRemoveHandler.OPERATION_NAME, vrh, vrh, false);\n        VaultWriteAttributeHandler.INSTANCE.registerAttributes(vault);\n\n        // Central Management\n        ManagementResourceRegistration management = hostRegistration.registerSubModel(PathElement.pathElement(CORE_SERVICE, MANAGEMENT), CommonProviders.MANAGEMENT_WITH_INTERFACES_PROVIDER);\n        management.registerSubModel(SecurityRealmResourceDefinition.INSTANCE);\n        management.registerSubModel(LdapConnectionResourceDefinition.INSTANCE);\n        management.registerSubModel(new NativeManagementResourceDefinition(hostControllerInfo));\n        management.registerSubModel(new HttpManagementResourceDefinition(hostControllerInfo, environment));\n\n        // Other core services\n        // TODO get a DumpServicesHandler that works on the domain\n//        ManagementResourceRegistration serviceContainer = hostRegistration.registerSubModel(PathElement.pathElement(CORE_SERVICE, SERVICE_CONTAINER), CommonProviders.SERVICE_CONTAINER_PROVIDER);\n//        serviceContainer.registerOperationHandler(DumpServicesHandler.OPERATION_NAME, DumpServicesHandler.INSTANCE, DumpServicesHandler.INSTANCE, false);\n\n        // Platform MBeans\n        PlatformMBeanResourceRegistrar.registerPlatformMBeanResources(hostRegistration);\n\n        //host-environment\n        hostRegistration.registerSubModel(HostControllerResourceDescription.of(environment));\n\n\n\n        LocalDomainControllerAddHandler localDcAddHandler = LocalDomainControllerAddHandler.getInstance(root, hostControllerInfo,\n                configurationPersister, localFileRepository, contentRepository, domainController, extensionRegistry);\n        hostRegistration.registerOperationHandler(LocalDomainControllerAddHandler.OPERATION_NAME, localDcAddHandler, localDcAddHandler, false);\n        hostRegistration.registerOperationHandler(LocalDomainControllerRemoveHandler.OPERATION_NAME, LocalDomainControllerRemoveHandler.INSTANCE, LocalDomainControllerRemoveHandler.INSTANCE, false);\n        RemoteDomainControllerAddHandler remoteDcAddHandler = new RemoteDomainControllerAddHandler(root, hostControllerInfo,\n                configurationPersister, contentRepository, remoteFileRepository, extensionRegistry, ignoredRegistry);\n        hostRegistration.registerOperationHandler(RemoteDomainControllerAddHandler.OPERATION_NAME, remoteDcAddHandler, remoteDcAddHandler, false);\n        hostRegistration.registerOperationHandler(RemoteDomainControllerRemoveHandler.OPERATION_NAME, RemoteDomainControllerRemoveHandler.INSTANCE, RemoteDomainControllerRemoveHandler.INSTANCE, false);\n\n        ignoredRegistry.registerResources(hostRegistration);\n\n        SnapshotDeleteHandler snapshotDelete = new SnapshotDeleteHandler(configurationPersister.getHostPersister());\n        hostRegistration.registerOperationHandler(SnapshotDeleteHandler.OPERATION_NAME, snapshotDelete, snapshotDelete, false);\n        SnapshotListHandler snapshotList = new SnapshotListHandler(configurationPersister.getHostPersister());\n        hostRegistration.registerOperationHandler(SnapshotListHandler.OPERATION_NAME, snapshotList, snapshotList, false);\n        SnapshotTakeHandler snapshotTake = new SnapshotTakeHandler(configurationPersister.getHostPersister());\n        hostRegistration.registerOperationHandler(SnapshotTakeHandler.OPERATION_NAME, snapshotTake, snapshotTake, false);\n\n        // Jvms\n        final ManagementResourceRegistration jvms = hostRegistration.registerSubModel(PathElement.pathElement(JVM), CommonProviders.JVM_PROVIDER);\n        JVMHandlers.register(jvms);\n\n        //Paths\n        ManagementResourceRegistration paths = hostRegistration.registerSubModel(PathElement.pathElement(PATH), CommonProviders.SPECIFIED_PATH_PROVIDER);\n        paths.registerOperationHandler(PathAddHandler.OPERATION_NAME, PathAddHandler.SPECIFIED_INSTANCE, PathAddHandler.SPECIFIED_INSTANCE, false);\n        paths.registerOperationHandler(PathRemoveHandler.OPERATION_NAME, PathRemoveHandler.SPECIFIED_INSTANCE, PathRemoveHandler.SPECIFIED_INSTANCE, false);\n\n        //interface\n        ManagementResourceRegistration interfaces = hostRegistration.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        HostSpecifiedInterfaceAddHandler hsiah = new HostSpecifiedInterfaceAddHandler();\n        interfaces.registerOperationHandler(InterfaceAddHandler.OPERATION_NAME, hsiah, hsiah, false);\n        HostSpecifiedInterfaceRemoveHandler sirh = new HostSpecifiedInterfaceRemoveHandler();\n        interfaces.registerOperationHandler(InterfaceRemoveHandler.OPERATION_NAME, sirh, sirh, false);\n        InterfaceCriteriaWriteHandler.UPDATE_RUNTIME.register(interfaces);\n        interfaces.registerOperationHandler(SpecifiedInterfaceResolveHandler.OPERATION_NAME, SpecifiedInterfaceResolveHandler.INSTANCE, SpecifiedInterfaceResolveHandler.INSTANCE);\n\n        //server\n        ManagementResourceRegistration servers = hostRegistration.registerSubModel(PathElement.pathElement(SERVER_CONFIG), HostDescriptionProviders.SERVER_PROVIDER);\n        servers.registerOperationHandler(ServerAddHandler.OPERATION_NAME, ServerAddHandler.INSTANCE, ServerAddHandler.INSTANCE, false, EnumSet.of(Flag.HOST_CONTROLLER_ONLY));\n        servers.registerOperationHandler(ServerRemoveHandler.OPERATION_NAME, ServerRemoveHandler.INSTANCE, ServerRemoveHandler.INSTANCE, false, EnumSet.of(Flag.HOST_CONTROLLER_ONLY));\n        servers.registerReadWriteAttribute(AUTO_START, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(SOCKET_BINDING_GROUP, null, ServerRestartRequiredServerConfigWriteAttributeHandler.SOCKET_BINDING_GROUP_INSTANCE, Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(SOCKET_BINDING_PORT_OFFSET, null, ServerRestartRequiredServerConfigWriteAttributeHandler.SOCKET_BINDING_PORT_OFFSET_INSTANCE, Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(PRIORITY, null, new WriteAttributeHandlers.IntRangeValidatingHandler(0), Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(CPU_AFFINITY, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1), Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(GROUP, null, ServerRestartRequiredServerConfigWriteAttributeHandler.GROUP_INSTANCE, Storage.CONFIGURATION);\n\n        // Register server runtime operation handlers\n        servers.registerMetric(ServerStatusHandler.ATTRIBUTE_NAME, new ServerStatusHandler(serverInventory));\n        ServerStartHandler startHandler = new ServerStartHandler(serverInventory);\n        servers.registerOperationHandler(ServerStartHandler.OPERATION_NAME, startHandler, startHandler, EnumSet.of(OperationEntry.Flag.HOST_CONTROLLER_ONLY));\n        ServerRestartHandler restartHandler = new ServerRestartHandler(serverInventory);\n        servers.registerOperationHandler(ServerRestartHandler.OPERATION_NAME, restartHandler, restartHandler,  EnumSet.of(OperationEntry.Flag.HOST_CONTROLLER_ONLY));\n        ServerStopHandler stopHandler = new ServerStopHandler(serverInventory);\n        servers.registerOperationHandler(ServerStopHandler.OPERATION_NAME, stopHandler, stopHandler, EnumSet.of(OperationEntry.Flag.HOST_CONTROLLER_ONLY));\n\n        //server paths\n        ManagementResourceRegistration serverPaths = servers.registerSubModel(PathElement.pathElement(PATH), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        serverPaths.registerOperationHandler(PathAddHandler.OPERATION_NAME, PathAddHandler.SPECIFIED_NO_SERVICES_INSTANCE, PathAddHandler.SPECIFIED_NO_SERVICES_INSTANCE, false);\n        serverPaths.registerOperationHandler(PathRemoveHandler.OPERATION_NAME, PathRemoveHandler.SPECIFIED_NO_SERVICES_INSTANCE, PathRemoveHandler.SPECIFIED_NO_SERVICES_INSTANCE, false);\n        //server interfaces\n        ManagementResourceRegistration serverInterfaces = servers.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        serverInterfaces.registerOperationHandler(InterfaceAddHandler.OPERATION_NAME, SpecifiedInterfaceAddHandler.INSTANCE, SpecifiedInterfaceAddHandler.INSTANCE, false);\n        serverInterfaces.registerOperationHandler(InterfaceRemoveHandler.OPERATION_NAME, SpecifiedInterfaceRemoveHandler.INSTANCE, SpecifiedInterfaceRemoveHandler.INSTANCE, false);\n        InterfaceCriteriaWriteHandler.CONFIG_ONLY.register(serverInterfaces);\n\n        // Server system Properties\n        ManagementResourceRegistration serverSysProps = servers.registerSubModel(PathElement.pathElement(SYSTEM_PROPERTY), HostDescriptionProviders.SERVER_SYSTEM_PROPERTIES_PROVIDER);\n        serverSysProps.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, false);\n        serverSysProps.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        serverSysProps.registerReadWriteAttribute(VALUE, null, SystemPropertyValueWriteAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        serverSysProps.registerReadWriteAttribute(BOOT_TIME, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n\n        // Server jvm\n        final ManagementResourceRegistration serverVMs = servers.registerSubModel(PathElement.pathElement(JVM), JVMHandlers.SERVER_MODEL_PROVIDER);\n        JVMHandlers.register(serverVMs, true);\n    }","id":77163,"modified_method":"public static void createHostRegistry(final ManagementResourceRegistration root, final HostControllerConfigurationPersister configurationPersister,\n                                          final HostControllerEnvironment environment, final HostRunningModeControl runningModeControl,\n                                          final HostFileRepository localFileRepository,\n                                          final LocalHostControllerInfoImpl hostControllerInfo, final ServerInventory serverInventory,\n                                          final HostFileRepository remoteFileRepository,\n                                          final ContentRepository contentRepository,\n                                          final DomainController domainController,\n                                          final ExtensionRegistry extensionRegistry,\n                                          final AbstractVaultReader vaultReader,\n                                          final IgnoredDomainResourceRegistry ignoredRegistry,\n                                          final ControlledProcessState processState) {\n        // Add of the host itself\n        ManagementResourceRegistration hostRegistration = root.registerSubModel(PathElement.pathElement(HOST), HostDescriptionProviders.HOST_ROOT_PROVIDER);\n        LocalHostAddHandler handler = new LocalHostAddHandler(environment, ignoredRegistry);\n        hostRegistration.registerOperationHandler(LocalHostAddHandler.OPERATION_NAME, handler, handler, false, OperationEntry.EntryType.PRIVATE);\n\n        // Global operations\n        EnumSet<OperationEntry.Flag> flags = EnumSet.of(OperationEntry.Flag.READ_ONLY);\n        root.registerOperationHandler(READ_RESOURCE_OPERATION, GlobalOperationHandlers.READ_RESOURCE, CommonProviders.READ_RESOURCE_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_ATTRIBUTE_OPERATION, GlobalOperationHandlers.READ_ATTRIBUTE, CommonProviders.READ_ATTRIBUTE_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_NAMES, CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_RESOURCES, CommonProviders.READ_CHILDREN_RESOURCES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true, OperationEntry.EntryType.PUBLIC, flags);\n        root.registerOperationHandler(UNDEFINE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.UNDEFINE_ATTRIBUTE, CommonProviders.UNDEFINE_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.WRITE_ATTRIBUTE, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(ValidateOperationHandler.OPERATION_NAME, ValidateOperationHandler.INSTANCE, ValidateOperationHandler.INSTANCE, false, EntryType.PUBLIC, EnumSet.of(Flag.READ_ONLY));\n        root.registerOperationHandler(WhoAmIOperation.OPERATION_NAME, WhoAmIOperation.INSTANCE, WhoAmIOperation.INSTANCE, true);\n\n        // Other root resource operations\n        root.registerOperationHandler(CompositeOperationHandler.NAME, CompositeOperationHandler.INSTANCE, CompositeOperationHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        // Host root resource operations\n        XmlMarshallingHandler xmh = new HostXmlMarshallingHandler(configurationPersister.getHostPersister(), hostControllerInfo);\n        hostRegistration.registerOperationHandler(XmlMarshallingHandler.OPERATION_NAME, xmh, xmh, false, OperationEntry.EntryType.PUBLIC, flags);\n\n        hostRegistration.registerReadWriteAttribute(HostRootDescription.DIRECTORY_GROUPING, null, new ReloadRequiredWriteAttributeHandler(HostRootDescription.DIRECTORY_GROUPING));\n\n        hostRegistration.registerOperationHandler(NamespaceAddHandler.OPERATION_NAME, NamespaceAddHandler.INSTANCE, NamespaceAddHandler.INSTANCE, false);\n        hostRegistration.registerOperationHandler(NamespaceRemoveHandler.OPERATION_NAME, NamespaceRemoveHandler.INSTANCE, NamespaceRemoveHandler.INSTANCE, false);\n        hostRegistration.registerOperationHandler(SchemaLocationAddHandler.OPERATION_NAME, SchemaLocationAddHandler.INSTANCE, SchemaLocationAddHandler.INSTANCE, false);\n        hostRegistration.registerOperationHandler(SchemaLocationRemoveHandler.OPERATION_NAME, SchemaLocationRemoveHandler.INSTANCE, SchemaLocationRemoveHandler.INSTANCE, false);\n\n        hostRegistration.registerReadWriteAttribute(NAME, environment.getProcessNameReadHandler(), environment.getProcessNameWriteHandler(), Storage.CONFIGURATION);\n        hostRegistration.registerReadOnlyAttribute(MASTER, IsMasterHandler.INSTANCE, Storage.RUNTIME);\n        hostRegistration.registerReadOnlyAttribute(HOST_STATE, new ProcessStateAttributeHandler(processState), Storage.RUNTIME);\n\n        StartServersHandler ssh = new StartServersHandler(environment, serverInventory, runningModeControl);\n        hostRegistration.registerOperationHandler(StartServersHandler.OPERATION_NAME, ssh, ssh, false, OperationEntry.EntryType.PRIVATE);\n\n        HostShutdownHandler hsh = new HostShutdownHandler(domainController);\n        hostRegistration.registerOperationHandler(HostShutdownHandler.OPERATION_NAME, hsh, hsh);\n\n        hostRegistration.registerOperationHandler(ResolveExpressionHandler.OPERATION_NAME, ResolveExpressionHandler.INSTANCE,\n                ResolveExpressionHandler.INSTANCE, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        hostRegistration.registerOperationHandler(ResolveExpressionOnHostHandler.OPERATION_NAME, ResolveExpressionOnHostHandler.INSTANCE,\n                ResolveExpressionOnHostHandler.INSTANCE, EnumSet.of(OperationEntry.Flag.READ_ONLY, OperationEntry.Flag.DOMAIN_PUSH_TO_SERVERS));\n\n        HostProcessReloadHandler reloadHandler = new HostProcessReloadHandler(HostControllerService.HC_SERVICE_NAME, runningModeControl, HostRootDescription.getResourceDescriptionResolver(\"host\"));\n        hostRegistration.registerOperationHandler(ProcessReloadHandler.OPERATION_NAME, reloadHandler, reloadHandler, EnumSet.of(Flag.HOST_CONTROLLER_ONLY));\n        RunningModeReadHandler.createAndRegister(runningModeControl, hostRegistration);\n\n        DomainServerLifecycleHandlers.initializeServerInventory(serverInventory);\n\n        hostRegistration.registerOperationHandler(SpecifiedInterfaceResolveHandler.OPERATION_NAME, SpecifiedInterfaceResolveHandler.INSTANCE, SpecifiedInterfaceResolveHandler.INSTANCE);\n        ValidateOperationHandler validateOperationHandler = hostControllerInfo.isMasterDomainController() ? ValidateOperationHandler.INSTANCE : ValidateOperationHandler.SLAVE_HC_INSTANCE;\n        hostRegistration.registerOperationHandler(ValidateOperationHandler.OPERATION_NAME, validateOperationHandler, validateOperationHandler, false, EntryType.PRIVATE, EnumSet.of(Flag.READ_ONLY));\n\n\n        // System Properties\n        ManagementResourceRegistration sysProps = hostRegistration.registerSubModel(PathElement.pathElement(SYSTEM_PROPERTY), HostDescriptionProviders.SYSTEM_PROPERTIES_PROVIDER);\n        sysProps.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, false);\n        sysProps.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        sysProps.registerReadWriteAttribute(VALUE, null, SystemPropertyValueWriteAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        sysProps.registerReadWriteAttribute(BOOT_TIME, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n\n        /////////////////////////////////////////\n        // Core Services\n\n        //vault\n        ManagementResourceRegistration vault = hostRegistration.registerSubModel(PathElement.pathElement(CORE_SERVICE, VAULT), CommonProviders.VAULT_PROVIDER);\n        VaultAddHandler vah = new VaultAddHandler(vaultReader);\n        vault.registerOperationHandler(VaultAddHandler.OPERATION_NAME, vah, vah, false);\n        VaultRemoveHandler vrh = new VaultRemoveHandler(vaultReader);\n        vault.registerOperationHandler(VaultRemoveHandler.OPERATION_NAME, vrh, vrh, false);\n        VaultWriteAttributeHandler.INSTANCE.registerAttributes(vault);\n\n        // Central Management\n        ManagementResourceRegistration management = hostRegistration.registerSubModel(PathElement.pathElement(CORE_SERVICE, MANAGEMENT), CommonProviders.MANAGEMENT_WITH_INTERFACES_PROVIDER);\n        management.registerSubModel(SecurityRealmResourceDefinition.INSTANCE);\n        management.registerSubModel(LdapConnectionResourceDefinition.INSTANCE);\n        management.registerSubModel(new NativeManagementResourceDefinition(hostControllerInfo));\n        management.registerSubModel(new HttpManagementResourceDefinition(hostControllerInfo, environment));\n\n        // Other core services\n        // TODO get a DumpServicesHandler that works on the domain\n//        ManagementResourceRegistration serviceContainer = hostRegistration.registerSubModel(PathElement.pathElement(CORE_SERVICE, SERVICE_CONTAINER), CommonProviders.SERVICE_CONTAINER_PROVIDER);\n//        serviceContainer.registerOperationHandler(DumpServicesHandler.OPERATION_NAME, DumpServicesHandler.INSTANCE, DumpServicesHandler.INSTANCE, false);\n\n        // Platform MBeans\n        PlatformMBeanResourceRegistrar.registerPlatformMBeanResources(hostRegistration);\n\n        //host-environment\n        hostRegistration.registerSubModel(HostControllerResourceDescription.of(environment));\n\n\n\n        LocalDomainControllerAddHandler localDcAddHandler = LocalDomainControllerAddHandler.getInstance(root, hostControllerInfo,\n                configurationPersister, localFileRepository, contentRepository, domainController, extensionRegistry);\n        hostRegistration.registerOperationHandler(LocalDomainControllerAddHandler.OPERATION_NAME, localDcAddHandler, localDcAddHandler, false);\n        hostRegistration.registerOperationHandler(LocalDomainControllerRemoveHandler.OPERATION_NAME, LocalDomainControllerRemoveHandler.INSTANCE, LocalDomainControllerRemoveHandler.INSTANCE, false);\n        RemoteDomainControllerAddHandler remoteDcAddHandler = new RemoteDomainControllerAddHandler(root, hostControllerInfo,\n                configurationPersister, contentRepository, remoteFileRepository, extensionRegistry, ignoredRegistry);\n        hostRegistration.registerOperationHandler(RemoteDomainControllerAddHandler.OPERATION_NAME, remoteDcAddHandler, remoteDcAddHandler, false);\n        hostRegistration.registerOperationHandler(RemoteDomainControllerRemoveHandler.OPERATION_NAME, RemoteDomainControllerRemoveHandler.INSTANCE, RemoteDomainControllerRemoveHandler.INSTANCE, false);\n\n        ignoredRegistry.registerResources(hostRegistration);\n\n        SnapshotDeleteHandler snapshotDelete = new SnapshotDeleteHandler(configurationPersister.getHostPersister());\n        hostRegistration.registerOperationHandler(SnapshotDeleteHandler.OPERATION_NAME, snapshotDelete, snapshotDelete, false);\n        SnapshotListHandler snapshotList = new SnapshotListHandler(configurationPersister.getHostPersister());\n        hostRegistration.registerOperationHandler(SnapshotListHandler.OPERATION_NAME, snapshotList, snapshotList, false);\n        SnapshotTakeHandler snapshotTake = new SnapshotTakeHandler(configurationPersister.getHostPersister());\n        hostRegistration.registerOperationHandler(SnapshotTakeHandler.OPERATION_NAME, snapshotTake, snapshotTake, false);\n\n        // Jvms\n        final ManagementResourceRegistration jvms = hostRegistration.registerSubModel(PathElement.pathElement(JVM), CommonProviders.JVM_PROVIDER);\n        JVMHandlers.register(jvms);\n\n        //Paths\n        ManagementResourceRegistration paths = hostRegistration.registerSubModel(PathElement.pathElement(PATH), CommonProviders.SPECIFIED_PATH_PROVIDER);\n        paths.registerOperationHandler(PathAddHandler.OPERATION_NAME, PathAddHandler.SPECIFIED_INSTANCE, PathAddHandler.SPECIFIED_INSTANCE, false);\n        paths.registerOperationHandler(PathRemoveHandler.OPERATION_NAME, PathRemoveHandler.SPECIFIED_INSTANCE, PathRemoveHandler.SPECIFIED_INSTANCE, false);\n\n        //interface\n        ManagementResourceRegistration interfaces = hostRegistration.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        HostSpecifiedInterfaceAddHandler hsiah = new HostSpecifiedInterfaceAddHandler();\n        interfaces.registerOperationHandler(InterfaceAddHandler.OPERATION_NAME, hsiah, hsiah, false);\n        HostSpecifiedInterfaceRemoveHandler sirh = new HostSpecifiedInterfaceRemoveHandler();\n        interfaces.registerOperationHandler(InterfaceRemoveHandler.OPERATION_NAME, sirh, sirh, false);\n        InterfaceCriteriaWriteHandler.UPDATE_RUNTIME.register(interfaces);\n        interfaces.registerOperationHandler(SpecifiedInterfaceResolveHandler.OPERATION_NAME, SpecifiedInterfaceResolveHandler.INSTANCE, SpecifiedInterfaceResolveHandler.INSTANCE);\n\n        //server\n        ManagementResourceRegistration servers = hostRegistration.registerSubModel(PathElement.pathElement(SERVER_CONFIG), HostDescriptionProviders.SERVER_PROVIDER);\n        servers.registerOperationHandler(ServerAddHandler.OPERATION_NAME, ServerAddHandler.INSTANCE, ServerAddHandler.INSTANCE, false, EnumSet.of(Flag.HOST_CONTROLLER_ONLY));\n        servers.registerOperationHandler(ServerRemoveHandler.OPERATION_NAME, ServerRemoveHandler.INSTANCE, ServerRemoveHandler.INSTANCE, false, EnumSet.of(Flag.HOST_CONTROLLER_ONLY));\n        servers.registerReadWriteAttribute(AUTO_START, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(SOCKET_BINDING_GROUP, null, ServerRestartRequiredServerConfigWriteAttributeHandler.SOCKET_BINDING_GROUP_INSTANCE, Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(SOCKET_BINDING_PORT_OFFSET, null, ServerRestartRequiredServerConfigWriteAttributeHandler.SOCKET_BINDING_PORT_OFFSET_INSTANCE, Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(PRIORITY, null, new WriteAttributeHandlers.IntRangeValidatingHandler(0), Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(CPU_AFFINITY, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1), Storage.CONFIGURATION);\n        servers.registerReadWriteAttribute(GROUP, null, ServerRestartRequiredServerConfigWriteAttributeHandler.GROUP_INSTANCE, Storage.CONFIGURATION);\n\n        // Register server runtime operation handlers\n        servers.registerMetric(ServerStatusHandler.ATTRIBUTE_NAME, new ServerStatusHandler(serverInventory));\n        ServerStartHandler startHandler = new ServerStartHandler(serverInventory);\n        servers.registerOperationHandler(ServerStartHandler.OPERATION_NAME, startHandler, startHandler, EnumSet.of(OperationEntry.Flag.HOST_CONTROLLER_ONLY));\n        ServerRestartHandler restartHandler = new ServerRestartHandler(serverInventory);\n        servers.registerOperationHandler(ServerRestartHandler.OPERATION_NAME, restartHandler, restartHandler,  EnumSet.of(OperationEntry.Flag.HOST_CONTROLLER_ONLY));\n        ServerStopHandler stopHandler = new ServerStopHandler(serverInventory);\n        servers.registerOperationHandler(ServerStopHandler.OPERATION_NAME, stopHandler, stopHandler, EnumSet.of(OperationEntry.Flag.HOST_CONTROLLER_ONLY));\n\n        //server paths\n        ManagementResourceRegistration serverPaths = servers.registerSubModel(PathElement.pathElement(PATH), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        serverPaths.registerOperationHandler(PathAddHandler.OPERATION_NAME, PathAddHandler.SPECIFIED_NO_SERVICES_INSTANCE, PathAddHandler.SPECIFIED_NO_SERVICES_INSTANCE, false);\n        serverPaths.registerOperationHandler(PathRemoveHandler.OPERATION_NAME, PathRemoveHandler.SPECIFIED_NO_SERVICES_INSTANCE, PathRemoveHandler.SPECIFIED_NO_SERVICES_INSTANCE, false);\n        //server interfaces\n        ManagementResourceRegistration serverInterfaces = servers.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        serverInterfaces.registerOperationHandler(InterfaceAddHandler.OPERATION_NAME, SpecifiedInterfaceAddHandler.INSTANCE, SpecifiedInterfaceAddHandler.INSTANCE, false);\n        serverInterfaces.registerOperationHandler(InterfaceRemoveHandler.OPERATION_NAME, SpecifiedInterfaceRemoveHandler.INSTANCE, SpecifiedInterfaceRemoveHandler.INSTANCE, false);\n        InterfaceCriteriaWriteHandler.CONFIG_ONLY.register(serverInterfaces);\n\n        // Server system Properties\n        ManagementResourceRegistration serverSysProps = servers.registerSubModel(PathElement.pathElement(SYSTEM_PROPERTY), HostDescriptionProviders.SERVER_SYSTEM_PROPERTIES_PROVIDER);\n        serverSysProps.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, SystemPropertyAddHandler.INSTANCE_WITH_BOOTTIME, false);\n        serverSysProps.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        serverSysProps.registerReadWriteAttribute(VALUE, null, SystemPropertyValueWriteAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        serverSysProps.registerReadWriteAttribute(BOOT_TIME, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n\n        // Server jvm\n        final ManagementResourceRegistration serverVMs = servers.registerSubModel(PathElement.pathElement(JVM), JVMHandlers.SERVER_MODEL_PROVIDER);\n        JVMHandlers.register(serverVMs, true);\n    }","commit_id":"5e28783ff034389f47a126060dc591e1795899e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Handle a connection closed event.\n     */\n    private void connectionClosed() {\n        if(! reconnect.get()) {\n            return; // Nothing to do\n        }\n        // Wait until the connection is closed before reconnecting\n        final Connection connection = this.connection;\n        if(connection != null) {\n            if(channel == null) {\n                connection.closeAsync();\n            }\n        } else {\n            HostControllerLogger.ROOT_LOGGER.lostRemoteDomainConnection();\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    final ReconnectPolicy policy = reconnectPolicy;\n                    for(;;) {\n                        try {\n                            // Wait before reconnecting\n                            policy.wait(reconnectionCount++);\n                            // Check if the connection was closed\n                            if(! reconnect.get()) {\n                                return;\n                            }\n                            // reconnect\n                            HostControllerLogger.ROOT_LOGGER.debugf(\"trying to reconnect to remote host-controller\");\n                            final RegistrationResult result = connectSync();\n                            if(result.isOK()) {\n                                // Reconnected\n                                HostControllerLogger.ROOT_LOGGER.reconnectedToMaster();\n                                return;\n                            }\n                        } catch(IOException e) {\n                            HostControllerLogger.ROOT_LOGGER.debugf(e, \"failed to reconnect to the remote host-controller\");\n                        } catch(InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n        }\n    }","id":77164,"modified_method":"/**\n     * Handle a connection closed event.\n     */\n    private void connectionClosed() {\n        if(! reconnect.get()) {\n            return; // Nothing to do\n        }\n        // Wait until the connection is closed before reconnecting\n        final Connection connection = this.connection;\n        if(connection != null) {\n            if(channel == null) {\n                connection.closeAsync();\n            }\n        } else {\n            if(reconnecting.compareAndSet(false, true)) {\n                HostControllerLogger.ROOT_LOGGER.lostRemoteDomainConnection();\n                executorService.execute(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        try {\n                            reconnect();\n                        } finally {\n                            reconnecting.set(false);\n                        }\n                    }\n\n                    private void reconnect() {\n                        final ReconnectPolicy policy = reconnectPolicy;\n                        for(;;) {\n                            try {\n                                // Wait before reconnecting\n                                policy.wait(reconnectionCount++);\n                                // Check if the connection was closed\n                                if(! reconnect.get()) {\n                                    return;\n                                }\n                                // reconnect\n                                HostControllerLogger.ROOT_LOGGER.debugf(\"trying to reconnect to remote host-controller\");\n                                final RegistrationResult result = connectSync();\n                                if(result.isOK()) {\n                                    // Reconnected\n                                    HostControllerLogger.ROOT_LOGGER.reconnectedToMaster();\n                                    return;\n                                }\n                            } catch(InterruptedException e) {\n                                Thread.currentThread().interrupt();\n                                return;\n                            } catch(Exception e) {\n                                HostControllerLogger.ROOT_LOGGER.debugf(e, \"failed to reconnect to the remote host-controller\");\n                            }\n                        }\n                    }\n                });\n            }\n        }\n    }","commit_id":"5e28783ff034389f47a126060dc591e1795899e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Connect and register at the remote domain controller.\n     *\n     * @throws IOException\n     */\n    private synchronized RegistrationResult connectSync() throws IOException {\n        boolean ok = false;\n        try {\n            final ProtocolChannelClient client = ProtocolChannelClient.create(configuration);\n            CallbackHandler callbackHandler = null;\n            SSLContext sslContext = null;\n            if (realm != null) {\n                sslContext = realm.getSSLContext();\n                CallbackHandlerFactory handlerFactory = realm.getSecretCallbackHandlerFactory();\n                if (handlerFactory != null) {\n                    callbackHandler = handlerFactory.getCallbackHandler(localHostName);\n                }\n            }\n            // Connect\n            connection = client.connectSync(callbackHandler, Collections.<String, String> emptyMap(), sslContext);\n            connection.addCloseHandler(new CloseHandler<Connection>() {\n                @Override\n                public void handleClose(final Connection closed, final IOException exception) {\n                    synchronized (this) {\n                        if(connection == closed) {\n                            connection = null;\n                            connectionClosed();\n                        }\n                    }\n                }\n            });\n            channel = connection.openChannel(CHANNEL_SERVICE_TYPE, OptionMap.EMPTY).get();\n            channel.addCloseHandler(new CloseHandler<Channel>() {\n                @Override\n                public void handleClose(final Channel closed, final IOException exception) {\n                    // Cancel all active operations\n                    channelHandler.handleChannelClosed(closed, exception);\n                    synchronized (this) {\n                        if(channel == closed) {\n                            channel = null;\n                            connectionClosed();\n                        }\n                    }\n                }\n            });\n            channel.receiveMessage(channelHandler.getReceiver());\n            final RegistrationResult result;\n            try {\n                // Register at the remote side\n                result = channelHandler.executeRequest(new RegisterHostControllerRequest(), null).getResult().get();\n            } catch (Exception e) {\n                if(e.getCause() instanceof IOException) {\n                    throw (IOException) e;\n                }\n                throw new IOException(e);\n            }\n            ok = true;\n            reconnectionCount = 0;\n            return result;\n        } finally {\n            if(!ok) {\n                StreamUtils.safeClose(connection);\n                StreamUtils.safeClose(channel);\n            }\n        }\n    }","id":77165,"modified_method":"/**\n     * Connect and register at the remote domain controller.\n     *\n     * @throws IOException\n     */\n    private synchronized RegistrationResult connectSync() throws IOException {\n        boolean ok = false;\n        try {\n            if(connection == null) {\n                final ProtocolChannelClient client = ProtocolChannelClient.create(configuration);\n                CallbackHandler callbackHandler = null;\n                SSLContext sslContext = null;\n                if (realm != null) {\n                    sslContext = realm.getSSLContext();\n                    CallbackHandlerFactory handlerFactory = realm.getSecretCallbackHandlerFactory();\n                    if (handlerFactory != null) {\n                        callbackHandler = handlerFactory.getCallbackHandler(localHostName);\n                    }\n                }\n                // Connect\n                connection = client.connectSync(callbackHandler, Collections.<String, String> emptyMap(), sslContext);\n                connection.addCloseHandler(new CloseHandler<Connection>() {\n                    @Override\n                    public void handleClose(final Connection closed, final IOException exception) {\n                        synchronized (this) {\n                            if(connection == closed) {\n                                connection = null;\n                                connectionClosed();\n                            }\n                        }\n                    }\n                });\n            }\n            channel = connection.openChannel(CHANNEL_SERVICE_TYPE, OptionMap.EMPTY).get();\n            channel.addCloseHandler(new CloseHandler<Channel>() {\n                @Override\n                public void handleClose(final Channel closed, final IOException exception) {\n                    // Cancel all active operations\n                    channelHandler.handleChannelClosed(closed, exception);\n                    synchronized (this) {\n                        if(channel == closed) {\n                            channel = null;\n                            connectionClosed();\n                        }\n                    }\n                }\n            });\n            channel.receiveMessage(channelHandler.getReceiver());\n            final RegistrationResult result;\n            try {\n                // Register at the remote side\n                result = channelHandler.executeRequest(new RegisterHostControllerRequest(), null).getResult().get();\n            } catch (Exception e) {\n                if(e.getCause() instanceof IOException) {\n                    throw (IOException) e;\n                }\n                throw new IOException(e);\n            }\n            ok = true;\n            reconnectionCount = 0;\n            return result;\n        } finally {\n            if(!ok) {\n                StreamUtils.safeClose(connection);\n                StreamUtils.safeClose(channel);\n            }\n        }\n    }","commit_id":"5e28783ff034389f47a126060dc591e1795899e2","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Replaces current notification widget by an overlay.<p>\n     */\n    public void catchNotifications() {\n\n        // remember current notification widget\n        final I_CmsNotificationWidget widget = CmsNotification.get().getWidget();\n        // create our own notification overlay\n        final A_CmsNotificationWidget notificationWidget = createDialogNotificationWidget();\n        add(notificationWidget);\n        CmsNotification.get().setWidget(notificationWidget);\n\n        // when closing the dialog\n        addCloseHandler(new CloseHandler<PopupPanel>() {\n\n            /**\n             * @see CloseHandler#onClose(CloseEvent)\n             */\n            public void onClose(CloseEvent<PopupPanel> event) {\n\n                // restore the previous notification widget\n                CmsNotification.get().setWidget(widget);\n                // remove the overlay notification widget\n                remove(notificationWidget);\n            }\n        });\n    }","id":77166,"modified_method":"/**\n     * Replaces current notification widget by an overlay.<p>\n     */\n    public void catchNotifications() {\n\n        m_catchNotifications = true;\n        if (isShowing()) {\n            // remember current notification widget\n            m_parentNotificationWidget = CmsNotification.get().getWidget();\n            // create our own notification overlay\n            if (m_ownNotificationWidget == null) {\n                m_ownNotificationWidget = createDialogNotificationWidget();\n            }\n            add(m_ownNotificationWidget);\n            CmsNotification.get().setWidget(m_ownNotificationWidget);\n        }\n        if (m_closingHandlerRegistration == null) {\n            // when closing the dialog\n            m_closingHandlerRegistration = addCloseHandler(new CloseHandler<PopupPanel>() {\n\n                /**\n                 * @see CloseHandler#onClose(CloseEvent)\n                 */\n                public void onClose(CloseEvent<PopupPanel> event) {\n\n                    clearNotifications();\n                }\n            });\n        }\n    }","commit_id":"82372604ee9223d1a9eddc878f2e18e4855da635","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a close \"button\" to the top of the popup.<p>\n     * \n     * @param cmd the command that should be executed when the close button is clicked\n     */\n    public void addDialogClose(final Command cmd) {\n\n        if (m_close == null) {\n            m_close = new CloseButton();\n            m_close.setTitle(Messages.get().key(Messages.GUI_CLOSE_0));\n            m_close.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().closePopup());\n            m_close.setImageClass(I_CmsLayoutBundle.INSTANCE.dialogCss().closePopupImage());\n            m_close.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n            m_close.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    boolean cancelled = false;\n                    try {\n                        if (cmd != null) {\n                            cmd.execute();\n                        }\n                    } catch (CmsCancelCloseException e) {\n                        cancelled = true;\n                    } finally {\n                        if (!cancelled) {\n                            hide();\n                        }\n                    }\n                }\n            });\n            DOM.appendChild(m_containerElement, m_close.getElement());\n            adopt(m_close);\n        }\n\n    }","id":77167,"modified_method":"/**\n     * Adds a close \"button\" to the top of the popup.<p>\n     * \n     * @param cmd the command that should be executed when the close button is clicked\n     */\n    public void addDialogClose(final Command cmd) {\n\n        m_closeCommand = cmd;\n        if (m_close == null) {\n            m_close = new CloseButton();\n            m_close.setTitle(Messages.get().key(Messages.GUI_CLOSE_0));\n            m_close.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().closePopup());\n            m_close.setImageClass(I_CmsLayoutBundle.INSTANCE.dialogCss().closePopupImage());\n            m_close.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n            m_close.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    boolean cancelled = false;\n                    try {\n                        if (m_closeCommand != null) {\n                            m_closeCommand.execute();\n                        }\n                    } catch (CmsCancelCloseException e) {\n                        cancelled = true;\n                    } finally {\n                        if (!cancelled) {\n                            hide();\n                        }\n                    }\n                }\n            });\n            DOM.appendChild(m_containerElement, m_close.getElement());\n            adopt(m_close);\n        }\n\n    }","commit_id":"82372604ee9223d1a9eddc878f2e18e4855da635","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see com.google.gwt.user.client.ui.PopupPanel#show()\n     */\n    @Override\n    public void show() {\n\n        boolean fixed = Position.FIXED.getCssName().equals(getElement().getStyle().getPosition());\n        super.show();\n        if (fixed) {\n            // keep position fixed as it may have been set to absolute\n            setPositionFixed();\n        }\n        if (m_useAnimation) {\n            CmsFadeAnimation.fadeIn(getElement(), null, 500);\n        }\n        if (m_resizeHandlerRegistration == null) {\n            m_resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {\n\n                public void onResize(ResizeEvent event) {\n\n                    m_windowWidth = event.getWidth();\n                }\n            });\n        }\n    }","id":77168,"modified_method":"/**\n     * @see com.google.gwt.user.client.ui.PopupPanel#show()\n     */\n    @Override\n    public void show() {\n\n        boolean fixed = Position.FIXED.getCssName().equals(getElement().getStyle().getPosition());\n        super.show();\n        if (fixed) {\n            // keep position fixed as it may have been set to absolute\n            setPositionFixed();\n        }\n        if (m_useAnimation) {\n            CmsFadeAnimation.fadeIn(getElement(), null, 500);\n        }\n        if (m_resizeHandlerRegistration == null) {\n            m_resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {\n\n                public void onResize(ResizeEvent event) {\n\n                    m_windowWidth = event.getWidth();\n                }\n            });\n        }\n        if (m_catchNotifications) {\n            catchNotifications();\n        }\n    }","commit_id":"82372604ee9223d1a9eddc878f2e18e4855da635","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Adds a new button to the button bar at the specified index position.<p>\r\n     * \r\n     * @param button the button to add\r\n     * @param index the index position\r\n     */\r\n    public void addButton(Widget button, int index) {\r\n\r\n        if (m_isFrame) {\r\n            if (m_buttonPanel == null) {\r\n                m_buttonPanel = new FlowPanel();\r\n                m_buttonPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().popupButtonPanel());\r\n                m_main.add(m_buttonPanel);\r\n            }\r\n            m_buttonPanel.insert(button, index);\r\n        } else {\r\n            m_popup.addButton(button, index);\r\n        }\r\n    }","id":77169,"modified_method":"/**\r\n     * Adds a new button to the button bar at the specified index position.<p>\r\n     * \r\n     * @param button the button to add\r\n     * @param index the index position\r\n     */\r\n    public void addButton(Widget button, int index) {\r\n\r\n        if (m_isFrame) {\r\n            initButtonPanel();\r\n            m_buttonPanel.insert(button, index);\r\n        } else {\r\n            m_popup.addButton(button, index);\r\n        }\r\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Shows the dialog.<p>\r\n     */\r\n    public void show() {\r\n\r\n        if (m_isFrame) {\r\n            RootPanel root = RootPanel.get();\r\n            root.getElement().getStyle().setMargin(0, Unit.PX);\r\n            root.getElement().getStyle().setPadding(0, Unit.PX);\r\n            RootPanel.get().add(m_main);\r\n            m_isShowing = true;\r\n        } else {\r\n            m_popup.center();\r\n        }\r\n\r\n    }","id":77170,"modified_method":"/**\r\n     * Shows the dialog.<p>\r\n     */\r\n    public void show() {\r\n\r\n        if (m_isFrame) {\r\n            RootPanel root = RootPanel.get();\r\n            root.getElement().getStyle().setMargin(0, Unit.PX);\r\n            root.getElement().getStyle().setPadding(0, Unit.PX);\r\n            RootPanel.get().add(m_main);\r\n            m_isShowing = true;\r\n            Scheduler.get().scheduleDeferred(new ScheduledCommand() {\r\n\r\n                public void execute() {\r\n\r\n                    adjustContentSize();\r\n                }\r\n            });\r\n        } else {\r\n            m_popup.center();\r\n        }\r\n\r\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Constructor.<p>\r\n     */\r\n    public CmsFrameDialog() {\r\n\r\n        m_isFrame = hasParentFrame();\r\n        if (m_isFrame) {\r\n            m_main = new FlowPanel();\r\n            m_contentPanel = new SimplePanel();\r\n            m_contentPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().popupMainContent());\r\n            m_contentPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().contentPadding());\r\n            m_main.add(m_contentPanel);\r\n\r\n        } else {\r\n            m_popup = new CmsPopup();\r\n            m_popup.setGlassEnabled(true);\r\n        }\r\n    }","id":77171,"modified_method":"/**\r\n     * Constructor.<p>\r\n     */\r\n    public CmsFrameDialog() {\r\n\r\n        m_isFrame = hasParentFrame();\r\n        if (m_isFrame) {\r\n            m_main = new FlowPanel();\r\n            m_main.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().frameDialog());\r\n            m_contentPanel = new SimplePanel();\r\n            m_contentPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().popupMainContent());\r\n            m_contentPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().contentPadding());\r\n            m_main.add(m_contentPanel);\r\n\r\n        } else {\r\n            m_popup = new CmsPopup();\r\n            m_popup.setGlassEnabled(true);\r\n        }\r\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Adds a new button to the button bar.<p>\r\n     * \r\n     * @param button the button to add\r\n     */\r\n    public void addButton(Widget button) {\r\n\r\n        if (m_isFrame) {\r\n            if (m_buttonPanel == null) {\r\n                m_buttonPanel = new FlowPanel();\r\n                m_buttonPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().popupButtonPanel());\r\n                m_main.add(m_buttonPanel);\r\n            }\r\n            m_buttonPanel.add(button);\r\n        } else {\r\n            m_popup.addButton(button);\r\n        }\r\n    }","id":77172,"modified_method":"/**\r\n     * Adds a new button to the button bar.<p>\r\n     * \r\n     * @param button the button to add\r\n     */\r\n    public void addButton(Widget button) {\r\n\r\n        if (m_isFrame) {\r\n            initButtonPanel();\r\n            m_buttonPanel.add(button);\r\n        } else {\r\n            m_popup.addButton(button);\r\n        }\r\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Shows an iFrame dialog popup.<p>\r\n     * \r\n     * @param title the dialog title\r\n     * @param dialogUri the dialog URI\r\n     * @param parameters the dialog post parameters\r\n     * @param closeHandler the dialog close handler\r\n     * \r\n     * @return the opened popup\r\n     */\r\n    public static CmsPopup showFrameDialog(\r\n        String title,\r\n        String dialogUri,\r\n        Map<String, String> parameters,\r\n        CloseHandler<PopupPanel> closeHandler) {\r\n\r\n        CmsPopup popup = new CmsPopup(title);\r\n        popup.addStyleName(I_CmsLayoutBundle.INSTANCE.contentEditorCss().contentEditor());\r\n        popup.removePadding();\r\n        popup.setGlassEnabled(true);\r\n        CmsIFrame editorFrame = new CmsIFrame(IFRAME_NAME, \"\");\r\n        popup.add(editorFrame);\r\n        final FormElement formElement = CmsDomUtil.generateHiddenForm(dialogUri, Method.post, IFRAME_NAME, parameters);\r\n        RootPanel.getBodyElement().appendChild(formElement);\r\n        exportDialogFunctions(popup);\r\n        popup.addCloseHandler(new CloseHandler<PopupPanel>() {\r\n\r\n            public void onClose(CloseEvent<PopupPanel> event) {\r\n\r\n                formElement.removeFromParent();\r\n                removeExportedFunctions();\r\n            }\r\n        });\r\n        popup.addCloseHandler(closeHandler);\r\n        popup.center();\r\n        formElement.submit();\r\n        return popup;\r\n    }","id":77173,"modified_method":"/**\r\n     * Shows an iFrame dialog popup.<p>\r\n     * \r\n     * @param title the dialog title\r\n     * @param dialogUri the dialog URI\r\n     * @param parameters the dialog post parameters\r\n     * @param closeHandler the dialog close handler\r\n     * \r\n     * @return the opened popup\r\n     */\r\n    public static CmsPopup showFrameDialog(\r\n        String title,\r\n        String dialogUri,\r\n        Map<String, String> parameters,\r\n        CloseHandler<PopupPanel> closeHandler) {\r\n\r\n        CmsPopup popup = new CmsPopup(title);\r\n        popup.removePadding();\r\n        popup.addStyleName(I_CmsLayoutBundle.INSTANCE.contentEditorCss().contentEditor());\r\n        popup.setGlassEnabled(true);\r\n        CmsIFrame editorFrame = new CmsIFrame(IFRAME_NAME, \"\");\r\n        popup.add(editorFrame);\r\n        final FormElement formElement = CmsDomUtil.generateHiddenForm(dialogUri, Method.post, IFRAME_NAME, parameters);\r\n        RootPanel.getBodyElement().appendChild(formElement);\r\n        exportDialogFunctions(popup);\r\n        popup.addCloseHandler(new CloseHandler<PopupPanel>() {\r\n\r\n            public void onClose(CloseEvent<PopupPanel> event) {\r\n\r\n                formElement.removeFromParent();\r\n                removeExportedFunctions();\r\n            }\r\n        });\r\n        if (closeHandler != null) {\r\n            popup.addCloseHandler(closeHandler);\r\n        }\r\n        popup.center();\r\n        formElement.submit();\r\n        return popup;\r\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the height for the popup content.<p>\n     * \n     * @param height the height in pixels\n     */\n    public void setHeight(int height) {\n\n        if (height <= 0) {\n            m_containerElement.getStyle().clearWidth();\n        } else {\n            int contentHeight = height;\n            if (hasCaption()) {\n                contentHeight = contentHeight - 36;\n            }\n            if (hasButtons()) {\n                contentHeight = contentHeight - 34;\n            }\n            contentHeight = contentHeight - 6;\n            m_containerElement.getStyle().setProperty(\"height\", height + Unit.PX.toString());\n            m_main.getStyle().setProperty(\"height\", contentHeight + Unit.PX.toString());\n        }\n    }","id":77174,"modified_method":"/**\n     * Sets the height for the popup content.<p>\n     * \n     * @param height the height in pixels\n     */\n    public void setHeight(int height) {\n\n        if (height <= 0) {\n            m_containerElement.getStyle().clearWidth();\n        } else {\n            int contentHeight = height;\n            if (hasCaption()) {\n                contentHeight = contentHeight - 36;\n            }\n            if (hasButtons()) {\n                contentHeight = contentHeight - 34;\n            }\n            contentHeight = contentHeight - m_contentHeightCorrection;\n            m_containerElement.getStyle().setProperty(\"height\", height + Unit.PX.toString());\n            m_main.getStyle().setProperty(\"height\", contentHeight + Unit.PX.toString());\n        }\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes the padding from the popup's content.<p>\n     */\n    public void removePadding() {\n\n        m_main.removeClassName(I_CmsLayoutBundle.INSTANCE.dialogCss().contentPadding());\n    }","id":77175,"modified_method":"/**\n     * Removes the padding from the popup's content.<p>\n     */\n    public void removePadding() {\n\n        m_main.removeClassName(I_CmsLayoutBundle.INSTANCE.dialogCss().contentPadding());\n        m_contentHeightCorrection = -6;\n    }","commit_id":"be4363e060af5028fa91223e27e22e63e860a703","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private static void fillResultsMap(Map<PsiFile, PsiClass[]> result, PsiFile containingFile, PsiClass[] topLevelClasses) {\n    PsiClass[] classes = result.get(containingFile);\n    if (classes != null) {\n      topLevelClasses = ArrayUtil.mergeArrays(classes, topLevelClasses, PsiClass.ARRAY_FACTORY);\n    }\n    result.put(containingFile, topLevelClasses);\n  }","id":77176,"modified_method":"private static void fillResultsMap(Map<PsiFile, PsiClass[]> result, PsiFile containingFile, PsiClass[] topLevelClasses) {\n    PsiClass[] classes = result.get(containingFile);\n    if (classes != null) {\n      topLevelClasses = ArrayUtil.mergeArrays(classes, topLevelClasses, PsiClass.ARRAY_FACTORY);\n    }\n    if (topLevelClasses != null) {\n      result.put(containingFile, topLevelClasses);\n    }\n  }","commit_id":"78ee8593f595c77edb7d2d0342a5e1e4fa19c49b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void copyAsFiles(PsiElement[] elements, PsiDirectory defaultTargetDirectory, Project project) {\n    CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(elements, defaultTargetDirectory, project, false);\n    dialog.show();\n    if (dialog.isOK()) {\n      final String newName = elements.length == 1 ? dialog.getNewName() : null;\n      final PsiDirectory targetDirectory = dialog.getTargetDirectory();\n      try {\n        for (PsiElement element : elements) {\n          PsiFileSystemItem psiElement = (PsiFileSystemItem)element;\n          if (psiElement.isDirectory()) {\n            MoveFilesOrDirectoriesUtil.checkIfMoveIntoSelf(psiElement, targetDirectory);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        CommonRefactoringUtil.showErrorHint(project, null, e.getMessage(), CommonBundle.getErrorTitle(), null);\n        return;\n      }\n      copyImpl(elements, newName, targetDirectory, false);\n    }\n  }","id":77177,"modified_method":"public static void copyAsFiles(PsiElement[] elements, PsiDirectory defaultTargetDirectory, Project project) {\n    PsiDirectory targetDirectory = null;\n    String newName = null;\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      targetDirectory = defaultTargetDirectory;\n    }\n    else {\n      CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(elements, defaultTargetDirectory, project, false);\n      dialog.show();\n      if (dialog.isOK()) {\n        newName = elements.length == 1 ? dialog.getNewName() : null;\n        targetDirectory = dialog.getTargetDirectory();\n      }\n    }\n\n    if (targetDirectory != null) {\n      try {\n        for (PsiElement element : elements) {\n          PsiFileSystemItem psiElement = (PsiFileSystemItem)element;\n          if (psiElement.isDirectory()) {\n            MoveFilesOrDirectoriesUtil.checkIfMoveIntoSelf(psiElement, targetDirectory);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        CommonRefactoringUtil.showErrorHint(project, null, e.getMessage(), CommonBundle.getErrorTitle(), null);\n        return;\n      }\n      copyImpl(elements, newName, targetDirectory, false);\n    }\n  }","commit_id":"78ee8593f595c77edb7d2d0342a5e1e4fa19c49b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void performAction(final String oldName, final String copyName) throws IncorrectOperationException {\n    PsiClass oldClass = JavaPsiFacade.getInstance(myProject).findClass(oldName, ProjectScope.getAllScope(myProject));\n    CopyClassesHandler.doCopyClass(oldClass, copyName, myPsiManager.findDirectory(myRootDir));\n  }","id":77178,"modified_method":"private void performAction(final String oldName, final String copyName) throws IncorrectOperationException {\n    PsiClass oldClass = JavaPsiFacade.getInstance(myProject).findClass(oldName, ProjectScope.getAllScope(myProject));\n    CopyClassesHandler.doCopyClasses(Collections.singletonMap(oldClass.getNavigationElement().getContainingFile(), new PsiClass[]{oldClass}), copyName, myPsiManager.findDirectory(myRootDir),\n                                     myProject);\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void copyClassImpl(final String copyClassName, final Project project, final PsiClass aClass, final PsiDirectory targetDirectory, String commandName, final boolean selectInActivePanel) {\n    if (copyClassName == null || copyClassName.length() == 0) return;\n    final boolean[] result = new boolean[] {false};\n    Runnable command = new Runnable() {\n      public void run() {\n        final Runnable action = new Runnable() {\n          public void run() {\n            try {\n              PsiElement newElement = doCopyClass(aClass, copyClassName, targetDirectory);\n              CopyHandler.updateSelectionInActiveProjectView(newElement, project, selectInActivePanel);\n              EditorHelper.openInEditor(newElement);\n\n              result[0] = true;\n            }\n            catch (final IncorrectOperationException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(action);\n      }\n    };\n    CommandProcessor processor = CommandProcessor.getInstance();\n    processor.executeCommand(project, command, commandName, null);\n\n    if (result[0]) {\n      ToolWindowManager.getInstance(project).invokeLater(new Runnable() {\n        public void run() {\n          ToolWindowManager.getInstance(project).activateEditorComponent();\n        }\n      });\n    }\n  }","id":77179,"modified_method":"private static void copyClassesImpl(final String copyClassName, final Project project, final Map<PsiFile, PsiClass[]> classes, final PsiDirectory targetDirectory, String commandName, final boolean selectInActivePanel) {\n    final boolean[] result = new boolean[] {false};\n    Runnable command = new Runnable() {\n      public void run() {\n        final Runnable action = new Runnable() {\n          public void run() {\n            try {\n              PsiElement newElement = doCopyClasses(classes, copyClassName, targetDirectory, project);\n              if (newElement != null) {\n                CopyHandler.updateSelectionInActiveProjectView(newElement, project, selectInActivePanel);\n                EditorHelper.openInEditor(newElement);\n\n                result[0] = true;\n              }\n            }\n            catch (final IncorrectOperationException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(action);\n      }\n    };\n    CommandProcessor processor = CommandProcessor.getInstance();\n    processor.executeCommand(project, command, commandName, null);\n\n    if (result[0]) {\n      ToolWindowManager.getInstance(project).invokeLater(new Runnable() {\n        public void run() {\n          ToolWindowManager.getInstance(project).activateEditorComponent();\n        }\n      });\n    }\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiClass convertToTopLevelClass(final PsiElement[] elements) {\n    if (elements.length == 1 && !CollectHighlightsUtil.isOutsideSourceRootJavaFile(elements[0].getContainingFile())) {\n      return getTopLevelClass(elements [0]);\n    }\n    return null;\n  }","id":77180,"modified_method":"@Nullable\n  private static Map<PsiFile, PsiClass[]> convertToTopLevelClasses(final PsiElement[] elements) {\n    final Map<PsiFile, PsiClass[]> result = new HashMap<PsiFile, PsiClass[]>();\n    for (PsiElement element : elements) {\n      final PsiFile containingFile = element.getNavigationElement().getContainingFile();\n      if (!CollectHighlightsUtil.isOutsideSourceRootJavaFile(containingFile)) {\n        PsiClass[] topLevelClasses = getTopLevelClasses(element);\n        if (topLevelClasses == null) return null;\n        PsiClass[] classes = result.get(containingFile);\n        if (classes != null) {\n          topLevelClasses = ArrayUtil.mergeArrays(classes, topLevelClasses, PsiClass.class);\n        }\n        result.put(containingFile, topLevelClasses);\n      }\n    }\n    return result.isEmpty() ? null : result;\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiClass getTopLevelClass(PsiElement element) {\n    while (true) {\n      if (element == null || element instanceof PsiFile) break;\n      if (element instanceof PsiClass && element.getParent() instanceof PsiFile) break;\n      element = element.getParent();\n    }\n    if (element instanceof PsiClassOwner) {\n      PsiClass[] classes = ((PsiClassOwner)element).getClasses();\n      if (classes.length > 0) {\n        for (final PsiClass aClass : classes) {\n          if (aClass instanceof SyntheticElement) {\n            return null;\n          }\n        }\n\n        element = classes[0];\n      }\n    }\n    return element instanceof PsiClass ? (PsiClass)element : null;\n  }","id":77181,"modified_method":"@Nullable\n  private static PsiClass[] getTopLevelClasses(PsiElement element) {\n    while (true) {\n      if (element == null || element instanceof PsiFile) break;\n      if (element instanceof PsiClass && element.getParent() instanceof PsiFile) break;\n      element = element.getParent();\n    }\n    if (element instanceof PsiClassOwner) {\n      PsiClass[] classes = ((PsiClassOwner)element).getClasses();\n      if (classes.length > 0) {\n        for (final PsiClass aClass : classes) {\n          if (aClass instanceof SyntheticElement) {\n            return null;\n          }\n        }\n\n        return classes;\n      }\n    }\n    return element instanceof PsiClass ? new PsiClass[]{(PsiClass)element} : null;\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canCopyClass(PsiElement... elements) {\n    return convertToTopLevelClass(elements) != null;\n  }","id":77182,"modified_method":"public static boolean canCopyClass(PsiElement... elements) {\n    return convertToTopLevelClasses(elements) != null;\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement doCopyClass(final PsiClass aClass, final String copyClassName, final PsiDirectory targetDirectory)\n      throws IncorrectOperationException {\n    PsiElement elementToCopy = aClass.getNavigationElement();\n\n    final PsiClass classCopy = (PsiClass)elementToCopy.copy();\n    classCopy.setName(copyClassName);\n\n    final String fileName = copyClassName + \".\" + elementToCopy.getContainingFile().getOriginalFile().getViewProvider().getVirtualFile().getExtension();\n    final PsiFile createdFile = targetDirectory.copyFileFrom(fileName, elementToCopy.getContainingFile());\n    PsiElement newElement = createdFile;\n    if (createdFile instanceof PsiClassOwner) {\n      for (final PsiClass psiClass : ((PsiClassOwner)createdFile).getClasses()) {\n        if (!(psiClass instanceof SyntheticElement)) {\n          psiClass.getParent().deleteChildRange(psiClass, psiClass);\n        }\n      }\n\n      final PsiClass newClass = (PsiClass)createdFile.add(classCopy);\n\n      for (final PsiReference reference : ReferencesSearch.search(aClass, new LocalSearchScope(newClass)).findAll()) {\n        reference.bindToElement(newClass);\n      }\n\n      new OptimizeImportsProcessor(aClass.getProject(), createdFile).run();\n\n      newElement = newClass;\n    }\n    return newElement;\n  }","id":77183,"modified_method":"@Nullable\n  public static PsiElement doCopyClasses(final Map<PsiFile, PsiClass[]> classes,\n                                         final String copyClassName,\n                                         final PsiDirectory targetDirectory,\n                                         final Project project)\n      throws IncorrectOperationException {\n    PsiElement newElement = null;\n    final Map<PsiClass, PsiElement> oldToNewMap = new HashMap<PsiClass, PsiElement>();\n    for (PsiClass[] psiClasses : classes.values()) {\n      for (PsiClass aClass : psiClasses) {\n        oldToNewMap.put(aClass, null);\n      }\n    }\n    final PsiFile[] createdFiles = new PsiFile[classes.size()];\n    int foIdx = 0;\n    for (PsiFile file : classes.keySet()) {\n      final String fileName = copyClassName != null ? (copyClassName +  \".\" + file.getViewProvider().getVirtualFile().getExtension()) : file.getName();\n      final PsiFile createdFile = targetDirectory.copyFileFrom(fileName, file);\n      if (createdFile instanceof PsiClassOwner) {\n        for (final PsiClass psiClass : ((PsiClassOwner)createdFile).getClasses()) {\n          if (!(psiClass instanceof SyntheticElement)) {\n            psiClass.getParent().deleteChildRange(psiClass, psiClass);\n          }\n        }\n      }\n\n      for (PsiClass aClass : classes.get(file)) {\n        final PsiClass classNavigationElement = (PsiClass)aClass.getNavigationElement();\n        final PsiClass classCopy = (PsiClass)classNavigationElement.copy();\n        if (copyClassName != null) {\n          classCopy.setName(copyClassName);\n        }\n        newElement = createdFile.add(classCopy);\n        oldToNewMap.put(aClass, newElement);\n      }\n      createdFiles[foIdx++] = createdFile;\n    }\n\n    final Set<PsiElement> rebindExpressions = new HashSet<PsiElement>();\n    for (PsiElement element : oldToNewMap.values()) {\n      decodeRefs(element, oldToNewMap, rebindExpressions);\n    }\n\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    for (PsiFile psiFile : createdFiles) {\n      if (psiFile instanceof PsiJavaFile) {\n        codeStyleManager.removeRedundantImports((PsiJavaFile)psiFile);\n      }\n    }\n    for (PsiElement expression : rebindExpressions) {\n      codeStyleManager.shortenClassReferences(expression);\n    }\n    new OptimizeImportsProcessor(project, createdFiles, null).run();\n    return newElement;\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doClone(PsiElement element) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    PsiClass aClass = getTopLevelClass(element);\n    Project project = element.getProject();\n\n    CopyClassDialog dialog = new CopyClassDialog(aClass, null, project, true);\n    dialog.setTitle(RefactoringBundle.message(\"copy.handler.clone.class\"));\n    dialog.show();\n    if (dialog.isOK()) {\n      String className = dialog.getClassName();\n      PsiDirectory targetDirectory = element.getContainingFile().getContainingDirectory();\n      copyClassImpl(className, project, aClass, targetDirectory, RefactoringBundle.message(\"copy.handler.clone.class\"), true);\n    }\n  }","id":77184,"modified_method":"public void doClone(PsiElement element) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    PsiClass[] classes = getTopLevelClasses(element);\n    LOG.assertTrue(classes != null && classes.length == 1);\n    Project project = element.getProject();\n\n    CopyClassDialog dialog = new CopyClassDialog(classes[0], null, project, true);\n    dialog.setTitle(RefactoringBundle.message(\"copy.handler.clone.class\"));\n    dialog.show();\n    if (dialog.isOK()) {\n      String className = dialog.getClassName();\n      PsiDirectory targetDirectory = element.getContainingFile().getContainingDirectory();\n      copyClassesImpl(className, project, Collections.singletonMap(classes[0].getContainingFile(), classes), targetDirectory, RefactoringBundle.message(\"copy.handler.clone.class\"), true);\n    }\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doCopy(PsiElement[] elements, PsiDirectory defaultTargetDirectory) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    PsiClass aClass = convertToTopLevelClass(elements);\n    assert aClass != null;\n    if (defaultTargetDirectory == null) {\n      defaultTargetDirectory = aClass.getContainingFile().getContainingDirectory();\n    }\n    Project project = defaultTargetDirectory.getProject();\n    CopyClassDialog dialog = new CopyClassDialog(aClass, defaultTargetDirectory, project, false);\n    dialog.setTitle(RefactoringBundle.message(\"copy.handler.copy.class\"));\n    dialog.show();\n    if (dialog.isOK()) {\n      PsiDirectory targetDirectory = dialog.getTargetDirectory();\n      String className = dialog.getClassName();\n      copyClassImpl(className, project, aClass, targetDirectory, RefactoringBundle.message(\"copy.handler.copy.class\"), false);\n    }\n  }","id":77185,"modified_method":"public void doCopy(PsiElement[] elements, PsiDirectory defaultTargetDirectory) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    Map<PsiFile, PsiClass[]> classes = convertToTopLevelClasses(elements);\n    assert classes != null;\n    if (defaultTargetDirectory == null) {\n      defaultTargetDirectory = classes.keySet().iterator().next().getContainingDirectory();\n    }\n    Project project = defaultTargetDirectory.getProject();\n    PsiDirectory targetDirectory = null;\n    String className = null;\n    if (classes.size() == 1 && classes.values().iterator().next().length == 1) {\n      CopyClassDialog dialog = new CopyClassDialog(classes.values().iterator().next()[0], defaultTargetDirectory, project, false);\n      dialog.setTitle(RefactoringBundle.message(\"copy.handler.copy.class\"));\n      dialog.show();\n      if (dialog.isOK()) {\n        targetDirectory = dialog.getTargetDirectory();\n        className = dialog.getClassName();\n        if (className == null || className.length() == 0) return;\n      }\n    } else {\n      CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(classes.keySet().toArray(new PsiFile[classes.size()]), defaultTargetDirectory, project, false);\n      dialog.show();\n      if (dialog.isOK()) {\n        targetDirectory = dialog.getTargetDirectory();\n      }\n    }\n    if (targetDirectory != null) {\n      copyClassesImpl(className, project, classes, targetDirectory, RefactoringBundle.message(\"copy.handler.copy.class\"), false);\n    }\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testBetweenPackages() throws Throwable {\n    final String testName = getTestName(false);\n    myFixture.copyFileToProject(testName + \".groovy\", \"foo/\" + testName + \".groovy\");\n    myFixture.addClass(\"package foo; public class Bar {}\");\n    myFixture.addClass(\"package bar; public class Bar {}\");\n\n    final PsiClass srcClass = myFixture.getJavaFacade().findClass(\"foo.\" + testName, GlobalSearchScope.allScope(getProject()));\n    assertTrue(CopyClassesHandler.canCopyClass(srcClass));\n    new WriteCommandAction(getProject()) {\n      protected void run(Result result) throws Throwable {\n        CopyClassesHandler.doCopyClass(srcClass, testName + \"_after\", srcClass.getManager().findDirectory(myFixture.getTempDirFixture().getFile(\"bar\")));\n      }\n    }.execute();\n\n    myFixture.checkResultByFile(\"bar/\" + testName + \"_after.groovy\", testName + \"_after.groovy\", true);\n  }","id":77186,"modified_method":"public void testBetweenPackages() throws Throwable {\n    final String testName = getTestName(false);\n    myFixture.copyFileToProject(testName + \".groovy\", \"foo/\" + testName + \".groovy\");\n    myFixture.addClass(\"package foo; public class Bar {}\");\n    myFixture.addClass(\"package bar; public class Bar {}\");\n\n    final PsiClass srcClass = myFixture.getJavaFacade().findClass(\"foo.\" + testName, GlobalSearchScope.allScope(getProject()));\n    assertTrue(CopyClassesHandler.canCopyClass(srcClass));\n    new WriteCommandAction(getProject()) {\n      protected void run(Result result) throws Throwable {\n        CopyClassesHandler.doCopyClasses(Collections.singletonMap(srcClass.getNavigationElement().getContainingFile(), new PsiClass[]{srcClass}), testName + \"_after\", srcClass.getManager().findDirectory(myFixture.getTempDirFixture().getFile(\"bar\")),\n                                         getProject());\n      }\n    }.execute();\n\n    myFixture.checkResultByFile(\"bar/\" + testName + \"_after.groovy\", testName + \"_after.groovy\", true);\n  }","commit_id":"17ce9472918d1d8ac2b6fb642bed18163b2af90b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String[] makeParameters(List files) {\r\n        Map options = config.getJointCompilationOptions();\r\n        LinkedList paras = new LinkedList();\r\n\r\n        // defaults\r\n        paras.add(\"-d\");\r\n        paras.add(config.getTargetDirectory().getAbsolutePath());\r\n        paras.add(\"-sourcepath\");\r\n        paras.add(((File)options.get(\"stubDir\")).getAbsolutePath());\r\n        \r\n        // add flags\r\n        String[] flags = (String[]) options.get(\"flags\");\r\n        if (flags!=null) {\r\n            for (int i = 0; i < flags.length; i++) {\r\n                paras.add('-'+flags[i]);\r\n            }\r\n        }\r\n        \r\n        // add namedValues\r\n        String[] namedValues = (String[]) options.get(\"namedValues\");\r\n        if (namedValues!=null) {\r\n            for (int i = 0; i < namedValues.length; i+=2) {\r\n                paras.add('-'+namedValues[i]);\r\n                paras.add(namedValues[i+1]);\r\n            }\r\n        }\r\n        \r\n        // files to compile\r\n        paras.addAll(files);\r\n        \r\n        return (String[]) paras.toArray(new String[0]);        \r\n    }","id":77187,"modified_method":"private String[] makeParameters(List files) {\r\n        Map options = config.getJointCompilationOptions();\r\n        LinkedList paras = new LinkedList();\r\n\r\n        File target = config.getTargetDirectory();\r\n        if (target==null) target=new File(\".\");\r\n        \r\n        // defaults\r\n        paras.add(\"-d\");\r\n        paras.add(target.getAbsolutePath());\r\n        paras.add(\"-sourcepath\");\r\n        paras.add(((File)options.get(\"stubDir\")).getAbsolutePath());\r\n        \r\n        // add flags\r\n        String[] flags = (String[]) options.get(\"flags\");\r\n        if (flags!=null) {\r\n            for (int i = 0; i < flags.length; i++) {\r\n                paras.add('-'+flags[i]);\r\n            }\r\n        }\r\n        \r\n        // add namedValues\r\n        String[] namedValues = (String[]) options.get(\"namedValues\");\r\n        if (namedValues!=null) {\r\n            for (int i = 0; i < namedValues.length; i+=2) {\r\n                paras.add('-'+namedValues[i]);\r\n                paras.add(namedValues[i+1]);\r\n            }\r\n        }\r\n        \r\n        // files to compile\r\n        paras.addAll(files);\r\n        \r\n        return (String[]) paras.toArray(new String[0]);        \r\n    }","commit_id":"e9915285c0689894df73355cae653599a11f4f89","url":"https://github.com/apache/groovy"},{"original_method":"public DuplicatesFinder(PsiElement[] pattern,\n                          List<? extends PsiVariable> parameters,\n                          List<? extends PsiVariable> outputParameters,\n                          boolean maintainStaticContext) {\n    LOG.assertTrue(pattern.length > 0);\n    myPattern = pattern;\n    myPatternAsList = Arrays.asList(myPattern);\n    myParameters = parameters;\n    myOutputParameters = outputParameters;\n    mySkipStaticContext = maintainStaticContext && !RefactoringUtil.isInStaticContext(myPattern[0]);\n  }","id":77188,"modified_method":"public DuplicatesFinder(PsiElement[] pattern,\n                          List<? extends PsiVariable> parameters,\n                          List<? extends PsiVariable> outputParameters,\n                          boolean maintainStaticContext) {\n    LOG.assertTrue(pattern.length > 0);\n    myPattern = pattern;\n    myPatternAsList = Arrays.asList(myPattern);\n    myParameters = parameters;\n    myOutputParameters = outputParameters;\n    mySkipStaticContext = maintainStaticContext && !RefactoringUtil.isInStaticContext(myPattern[0]);\n\n    final PsiElement codeFragment = ControlFlowUtil.findCodeFragment(pattern[0]);\n    ControlFlowAnalyzer analyzer = new ControlFlowAnalyzer(codeFragment, new LocalsControlFlowPolicy(codeFragment), false);\n    try {\n      final ControlFlow controlFlow = analyzer.buildControlFlow();\n      IntArrayList exitPoints = new IntArrayList();\n      final ArrayList<PsiStatement> exitStatements = new ArrayList<PsiStatement>();\n\n      ControlFlowUtil.findExitPointsAndStatements\n        (controlFlow, controlFlow.getStartOffset(pattern[0]),\n         controlFlow.getEndOffset(pattern[pattern.length - 1]),\n         exitPoints, exitStatements,\n         ControlFlowUtil.DEFAULT_EXIT_STATEMENTS_CLASSES);\n      myMultipleExitPoints = exitPoints.size() > 1;\n    }\n    catch (AnalysisCanceledException e) {\n    }\n  }","commit_id":"22df1b346bb6a7fc323f883cbe169386b965513b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean matchReturnStatement(final PsiReturnStatement patternReturnStatement,\n                                       PsiElement candidate,\n                                       List<PsiElement> candidates,\n                                       Match match) {\n    if (candidate instanceof PsiExpressionStatement) {\n      final PsiExpression expression = ((PsiExpressionStatement)candidate).getExpression();\n      if (expression instanceof PsiAssignmentExpression) {\n        final PsiExpression returnValue = patternReturnStatement.getReturnValue();\n        final PsiExpression rExpression = ((PsiAssignmentExpression)expression).getRExpression();\n        if (!matchPattern(returnValue, rExpression, candidates, match)) return false;\n        final PsiExpression lExpression = ((PsiAssignmentExpression)expression).getLExpression();\n        return match.registerReturnValue(new ExpressionReturnValue(lExpression));\n      }\n      else return false;\n    }\n    else if (candidate instanceof PsiDeclarationStatement) {\n      final PsiElement[] declaredElements = ((PsiDeclarationStatement)candidate).getDeclaredElements();\n      if (declaredElements.length != 1) return false;\n      if (!(declaredElements[0] instanceof PsiVariable)) return false;\n      final PsiVariable variable = ((PsiVariable)declaredElements[0]);\n      if (!matchPattern(patternReturnStatement.getReturnValue(), variable.getInitializer(), candidates, match)) return false;\n      return match.registerReturnValue(new VariableReturnValue(variable));\n    }\n    else if (candidate instanceof PsiReturnStatement) {\n      if (!match.registerReturnValue(ReturnStatementReturnValue.INSTANCE)) return false;\n      return matchPattern(patternReturnStatement.getReturnValue(), ((PsiReturnStatement)candidate).getReturnValue(), candidates, match);\n    }\n    else return false;\n  }","id":77189,"modified_method":"private boolean matchReturnStatement(final PsiReturnStatement patternReturnStatement,\n                                       PsiElement candidate,\n                                       List<PsiElement> candidates,\n                                       Match match) {\n    if (candidate instanceof PsiExpressionStatement) {\n      final PsiExpression expression = ((PsiExpressionStatement)candidate).getExpression();\n      if (expression instanceof PsiAssignmentExpression) {\n        final PsiExpression returnValue = patternReturnStatement.getReturnValue();\n        final PsiExpression rExpression = ((PsiAssignmentExpression)expression).getRExpression();\n        if (!matchPattern(returnValue, rExpression, candidates, match)) return false;\n        final PsiExpression lExpression = ((PsiAssignmentExpression)expression).getLExpression();\n        return match.registerReturnValue(new ExpressionReturnValue(lExpression));\n      }\n      else return false;\n    }\n    else if (candidate instanceof PsiDeclarationStatement) {\n      final PsiElement[] declaredElements = ((PsiDeclarationStatement)candidate).getDeclaredElements();\n      if (declaredElements.length != 1) return false;\n      if (!(declaredElements[0] instanceof PsiVariable)) return false;\n      final PsiVariable variable = ((PsiVariable)declaredElements[0]);\n      if (!matchPattern(patternReturnStatement.getReturnValue(), variable.getInitializer(), candidates, match)) return false;\n      return match.registerReturnValue(new VariableReturnValue(variable));\n    }\n    else if (candidate instanceof PsiReturnStatement) {\n      final PsiExpression returnValue = ((PsiReturnStatement)candidate).getReturnValue();\n      if (myMultipleExitPoints) {\n        if (!match.registerReturnValue(new ConditionalReturnStatementValue(returnValue))) return false;\n      }\n      else {\n        if (!match.registerReturnValue(ReturnStatementReturnValue.INSTANCE)) return false;\n      }\n      return matchPattern(patternReturnStatement.getReturnValue(), returnValue, candidates, match);\n    }\n    else return false;\n  }","commit_id":"22df1b346bb6a7fc323f883cbe169386b965513b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isIOResource(PsiExpression expression) {\n    return TypeUtils.expressionHasTypeOrSubtype(expression, IO_TYPES) != null && !isIgnoredType(expression);\n  }","id":77190,"modified_method":"@Override\n  public boolean isResourceCreation(PsiExpression expression) {\n    if (expression instanceof PsiNewExpression) {\n      return TypeUtils.expressionHasTypeOrSubtype(expression, IO_TYPES) != null && !isIgnoredType(expression);\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      @NonNls final String methodName = methodExpression.getReferenceName();\n      if (!\"getResourceAsStream\".equals(methodName)) {\n        return false;\n      }\n      final PsiExpression qualifier = methodExpression.getQualifierExpression();\n      if (qualifier == null ||\n          TypeUtils.expressionHasTypeOrSubtype(qualifier, CommonClassNames.JAVA_LANG_CLASS, \"java.lang.ClassLoader\") == null) {\n        return false;\n      }\n      return TypeUtils.expressionHasTypeOrSubtype(expression, \"java.io.InputStream\");\n    }\n    return false;\n  }","commit_id":"319fb6b5044a91d66c1fd90cf066ebc716797b08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static boolean isSafelyClosed(@Nullable PsiVariable variable, PsiElement context, boolean insideTryAllowed) {\n    if (variable == null) {\n      return false;\n    }\n    PsiStatement statement = PsiTreeUtil.getParentOfType(context, PsiStatement.class);\n    if (statement == null) {\n      return false;\n    }\n    PsiStatement nextStatement = PsiTreeUtil.getNextSiblingOfType(statement, PsiStatement.class);\n    if (insideTryAllowed) {\n      PsiStatement parentStatement = PsiTreeUtil.getParentOfType(statement, PsiStatement.class);\n      while (parentStatement != null && !(parentStatement instanceof PsiTryStatement)) {\n        parentStatement = PsiTreeUtil.getParentOfType(parentStatement, PsiStatement.class);\n      }\n      if (parentStatement != null) {\n        final PsiTryStatement tryStatement = (PsiTryStatement)parentStatement;\n        if (isResourceClosedInFinally(tryStatement, variable)) {\n          return true;\n        }\n      }\n    }\n    while (nextStatement == null) {\n      statement = PsiTreeUtil.getParentOfType(statement, PsiStatement.class, true);\n      if (statement == null) {\n        return false;\n      }\n      final PsiElement parent = statement.getParent();\n      if (parent instanceof PsiIfStatement) {\n        statement = (PsiStatement)parent;\n      }\n      nextStatement = PsiTreeUtil.getNextSiblingOfType(statement, PsiStatement.class);\n    }\n    if (!(nextStatement instanceof PsiTryStatement)) {\n      // exception in next statement can prevent closing of the resource\n      return isResourceClose(nextStatement, variable);\n    }\n    final PsiTryStatement tryStatement = (PsiTryStatement)nextStatement;\n    if (isResourceClosedInFinally(tryStatement, variable)) {\n      return true;\n    }\n    return isResourceClose(nextStatement, variable);\n  }","id":77191,"modified_method":"private static boolean isSafelyClosed(@Nullable PsiVariable variable, PsiElement context, boolean insideTryAllowed) {\n    if (variable == null) {\n      return false;\n    }\n    PsiStatement statement = PsiTreeUtil.getParentOfType(context, PsiStatement.class);\n    if (statement == null) {\n      return false;\n    }\n    PsiStatement nextStatement = PsiTreeUtil.getNextSiblingOfType(statement, PsiStatement.class);\n    if (insideTryAllowed) {\n      PsiStatement parentStatement = PsiTreeUtil.getParentOfType(statement, PsiStatement.class);\n      while (parentStatement != null && !(parentStatement instanceof PsiTryStatement)) {\n        parentStatement = PsiTreeUtil.getParentOfType(parentStatement, PsiStatement.class);\n      }\n      if (parentStatement != null) {\n        final PsiTryStatement tryStatement = (PsiTryStatement)parentStatement;\n        if (isResourceClosedInFinally(tryStatement, variable)) {\n          return true;\n        }\n      }\n    }\n    while (nextStatement == null) {\n      statement = PsiTreeUtil.getParentOfType(statement, PsiStatement.class, true);\n      if (statement == null) {\n        return false;\n      }\n      final PsiElement parent = statement.getParent();\n      if (parent instanceof PsiIfStatement) {\n        statement = (PsiStatement)parent;\n      }\n      nextStatement = PsiTreeUtil.getNextSiblingOfType(statement, PsiStatement.class);\n    }\n    if (!(nextStatement instanceof PsiTryStatement)) {\n      // exception in next statement can prevent closing of the resource\n      return isResourceClose(nextStatement, variable);\n    }\n    final PsiTryStatement tryStatement = (PsiTryStatement)nextStatement;\n    if (isResourceClosedInFinally(tryStatement, variable)) {\n      return true;\n    }\n    return isResourceClose(nextStatement, variable);\n  }","commit_id":"319fb6b5044a91d66c1fd90cf066ebc716797b08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static PsiElement getExpressionParent(PsiExpression expression) {\n    PsiElement parent = expression.getParent();\n    while (parent instanceof PsiParenthesizedExpression ||\n           parent instanceof PsiTypeCastExpression) {\n      parent = parent.getParent();\n    }\n    return parent;\n  }","id":77192,"modified_method":"@Nullable\n  private static PsiVariable getVariable(@NotNull PsiExpression expression) {\n    final PsiElement parent = ParenthesesUtils.getParentSkipParentheses(expression);\n    if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment = (PsiAssignmentExpression)parent;\n      final PsiExpression lhs = assignment.getLExpression();\n      if (!(lhs instanceof PsiReferenceExpression)) {\n        return null;\n      }\n      final PsiReferenceExpression referenceExpression = (PsiReferenceExpression)lhs;\n      final PsiElement referent = referenceExpression.resolve();\n      if (!(referent instanceof PsiVariable)) {\n        return null;\n      }\n      return (PsiVariable)referent;\n    }\n    else if (parent instanceof PsiVariable) {\n      return (PsiVariable)parent;\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"319fb6b5044a91d66c1fd90cf066ebc716797b08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static boolean isResourceClose(PsiMethodCallExpression call,\n                                           PsiVariable resource) {\n    final PsiReferenceExpression methodExpression =\n      call.getMethodExpression();\n    final String methodName = methodExpression.getReferenceName();\n    if (!HardcodedMethodConstants.CLOSE.equals(methodName)) {\n      return false;\n    }\n    final PsiExpression qualifier =\n      methodExpression.getQualifierExpression();\n    if (!(qualifier instanceof PsiReferenceExpression)) {\n      return false;\n    }\n    final PsiReference reference = (PsiReference)qualifier;\n    final PsiElement referent = reference.resolve();\n    return referent != null && referent.equals(resource);\n  }","id":77193,"modified_method":"private static boolean isResourceClose(PsiMethodCallExpression call, PsiVariable resource) {\n    final PsiReferenceExpression methodExpression = call.getMethodExpression();\n    final String methodName = methodExpression.getReferenceName();\n    if (!HardcodedMethodConstants.CLOSE.equals(methodName)) {\n      return false;\n    }\n    final PsiExpression qualifier = methodExpression.getQualifierExpression();\n    if (!(qualifier instanceof PsiReferenceExpression)) {\n      return false;\n    }\n    final PsiReference reference = (PsiReference)qualifier;\n    final PsiElement referent = reference.resolve();\n    return referent != null && referent.equals(resource);\n  }","commit_id":"319fb6b5044a91d66c1fd90cf066ebc716797b08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitReturnStatement(\n      PsiReturnStatement statement) {\n      PsiExpression value = statement.getReturnValue();\n      value = PsiUtil.deparenthesizeExpression(value);\n      if (value instanceof PsiReferenceExpression) {\n        final PsiReferenceExpression referenceExpression =\n          (PsiReferenceExpression)value;\n        final PsiElement target = referenceExpression.resolve();\n        if (target != null && target.equals(boundVariable)) {\n          escaped = true;\n        }\n      }\n    }","id":77194,"modified_method":"@Override\n    public void visitReturnStatement(PsiReturnStatement statement) {\n      final PsiExpression value = PsiUtil.deparenthesizeExpression(statement.getReturnValue());\n      if (!(value instanceof PsiReferenceExpression)) {\n        return;\n      }\n      final PsiReferenceExpression referenceExpression = (PsiReferenceExpression)value;\n      final PsiElement target = referenceExpression.resolve();\n      if (boundVariable.equals(target)) {\n        escaped = true;\n      }\n    }","commit_id":"319fb6b5044a91d66c1fd90cf066ebc716797b08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static boolean isResourceEscapedFromMethod(\n    PsiVariable boundVariable, PsiElement context) {\n    // poor man dataflow\n    final PsiMethod method =\n      PsiTreeUtil.getParentOfType(context, PsiMethod.class, true,\n                                  PsiMember.class);\n    if (method == null) {\n      return false;\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      return false;\n    }\n    final EscapeVisitor visitor = new EscapeVisitor(boundVariable);\n    body.accept(visitor);\n    return visitor.isEscaped();\n  }","id":77195,"modified_method":"private static boolean isResourceEscapingFromMethod(PsiVariable boundVariable, PsiExpression resourceCreationExpression) {\n    final PsiElement parent = ParenthesesUtils.getParentSkipParentheses(resourceCreationExpression);\n    if (parent instanceof PsiReturnStatement || parent instanceof PsiResourceVariable) {\n      return true;\n    }\n    else if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)parent;\n      if (ParenthesesUtils.stripParentheses(assignmentExpression.getRExpression()) != resourceCreationExpression) {\n        return true; // non-sensical code\n      }\n      final PsiExpression lhs = ParenthesesUtils.stripParentheses(assignmentExpression.getLExpression());\n      if (lhs instanceof PsiReferenceExpression) {\n        final PsiReferenceExpression referenceExpression = (PsiReferenceExpression)lhs;\n        final PsiElement target = referenceExpression.resolve();\n        if (target instanceof PsiField) {\n          return true;\n        }\n      }\n    }\n    else if (parent instanceof PsiExpressionList) {\n      PsiElement grandParent = parent.getParent();\n      if (grandParent instanceof PsiAnonymousClass) {\n        grandParent = grandParent.getParent();\n      }\n      if (grandParent instanceof PsiCallExpression) {\n        return true;\n      }\n    }\n    if (boundVariable == null) {\n      return false;\n    }\n    final PsiCodeBlock codeBlock = PsiTreeUtil.getParentOfType(resourceCreationExpression, PsiCodeBlock.class, true, PsiMember.class);\n    if (codeBlock == null) {\n      return false;\n    }\n    final EscapeVisitor visitor = new EscapeVisitor(boundVariable);\n    codeBlock.accept(visitor);\n    return visitor.isEscaped();\n  }","commit_id":"319fb6b5044a91d66c1fd90cf066ebc716797b08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitIfStatement(\n      @NotNull PsiIfStatement ifStatement) {\n      super.visitIfStatement(ifStatement);\n      final PsiStatement elseBranch = ifStatement.getElseBranch();\n      final PsiStatement thenBranch = ifStatement.getThenBranch();\n      if (thenBranch == null) {\n        return;\n      }\n      final Project project = ifStatement.getProject();\n      final InputVariables inputVariables =\n        new InputVariables(Collections.<PsiVariable>emptyList(),\n                           project, new LocalSearchScope(thenBranch), false);\n      final DuplicatesFinder finder =\n        new DuplicatesFinder(new PsiElement[]{thenBranch},\n                             inputVariables, null,\n                             Collections.<PsiVariable>emptyList());\n      if (elseBranch instanceof PsiIfStatement) {\n        final PsiIfStatement statement =\n          (PsiIfStatement)elseBranch;\n        final PsiStatement branch = statement.getThenBranch();\n        if (branch == null) {\n          return;\n        }\n        final Match match = finder.isDuplicate(branch, true);\n        if (match != null && match.getReturnValue() == null) {\n          registerStatementError(ifStatement, statement);\n          return;\n        }\n      }\n      if (elseBranch == null) {\n        checkIfStatementWithoutElseBranch(ifStatement);\n      }\n      else {\n        final Match match = finder.isDuplicate(elseBranch, true);\n        if (match != null) {\n          registerStatementError(ifStatement);\n        }\n      }\n    }","id":77196,"modified_method":"@Override\n    public void visitIfStatement(@NotNull PsiIfStatement ifStatement) {\n      super.visitIfStatement(ifStatement);\n      final PsiStatement elseBranch = ifStatement.getElseBranch();\n      final PsiStatement thenBranch = ifStatement.getThenBranch();\n      if (thenBranch == null) {\n        return;\n      }\n      final Project project = ifStatement.getProject();\n      final InputVariables inputVariables =\n        new InputVariables(Collections.<PsiVariable>emptyList(),\n                           project, new LocalSearchScope(thenBranch), false);\n      final DuplicatesFinder finder =\n        new DuplicatesFinder(new PsiElement[]{thenBranch},\n                             inputVariables, null,\n                             Collections.<PsiVariable>emptyList());\n      if (elseBranch instanceof PsiIfStatement) {\n        final PsiIfStatement statement = (PsiIfStatement)elseBranch;\n        final PsiStatement branch = statement.getThenBranch();\n        if (branch == null) {\n          return;\n        }\n        final Match match = finder.isDuplicate(branch, true);\n        if (match != null) {\n          final ReturnValue matchReturnValue = match.getReturnValue();\n          if (matchReturnValue instanceof ConditionalReturnStatementValue &&\n              !matchReturnValue.isEquivalent(buildReturnValue(thenBranch))) {\n            return;\n          }\n          registerStatementError(ifStatement, statement);\n          return;\n        }\n      }\n      if (elseBranch == null) {\n        checkIfStatementWithoutElseBranch(ifStatement);\n      }\n      else {\n        final Match match = finder.isDuplicate(elseBranch, true);\n        if (match != null) {\n          final ReturnValue matchReturnValue = match.getReturnValue();\n          if (matchReturnValue instanceof ConditionalReturnStatementValue &&\n              !matchReturnValue.isEquivalent(buildReturnValue(thenBranch))) {\n            return;\n          }\n          registerStatementError(ifStatement);\n        }\n      }\n    }","commit_id":"09fafa85a7c3fe27500cf04ec1e3b4a8c336e1ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Clears the cache to test reloading start times from leveldb (only for\n   * testing).\n   */\n  @VisibleForTesting\n  void clearStartTimeCache() {\n    startTimeCache.clear();\n  }","id":77197,"modified_method":"/**\n   * Clears the cache to test reloading start times from leveldb (only for\n   * testing).\n   */\n  @VisibleForTesting\n  void clearStartTimeCache() {\n    startTimeWriteCache.clear();\n    startTimeReadCache.clear();\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void serviceInit(Configuration conf) throws Exception {\n    Options options = new Options();\n    options.createIfMissing(true);\n    JniDBFactory factory = new JniDBFactory();\n    String path = conf.get(YarnConfiguration.TIMELINE_SERVICE_LEVELDB_PATH);\n    File p = new File(path);\n    if (!p.exists())\n      if (!p.mkdirs())\n        throw new IOException(\"Couldn't create directory for leveldb \" +\n            \"timeline store \" + path);\n    LOG.info(\"Using leveldb path \" + path);\n    db = factory.open(new File(path, FILENAME), options);\n    super.serviceInit(conf);\n  }","id":77198,"modified_method":"@Override\n  @SuppressWarnings(\"unchecked\")\n  protected void serviceInit(Configuration conf) throws Exception {\n    Options options = new Options();\n    options.createIfMissing(true);\n    JniDBFactory factory = new JniDBFactory();\n    String path = conf.get(YarnConfiguration.TIMELINE_SERVICE_LEVELDB_PATH);\n    File p = new File(path);\n    if (!p.exists())\n      if (!p.mkdirs())\n        throw new IOException(\"Couldn't create directory for leveldb \" +\n            \"timeline store \" + path);\n    LOG.info(\"Using leveldb path \" + path);\n    db = factory.open(new File(path, FILENAME), options);\n    startTimeWriteCache =\n        Collections.synchronizedMap(new LRUMap(getStartTimeWriteCacheSize(\n            conf)));\n    startTimeReadCache =\n        Collections.synchronizedMap(new LRUMap(getStartTimeReadCacheSize(\n            conf)));\n    super.serviceInit(conf);\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public TimelineEvents getEntityTimelines(String entityType,\n      SortedSet<String> entityIds, Long limit, Long windowStart,\n      Long windowEnd, Set<String> eventType) throws IOException {\n    TimelineEvents events = new TimelineEvents();\n    if (entityIds == null || entityIds.isEmpty())\n      return events;\n    // create a lexicographically-ordered map from start time to entities\n    Map<byte[], List<EntityIdentifier>> startTimeMap = new TreeMap<byte[],\n        List<EntityIdentifier>>(new Comparator<byte[]>() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                o2.length);\n          }\n        });\n    DBIterator iterator = null;\n    try {\n      // look up start times for the specified entities\n      // skip entities with no start time\n      for (String entity : entityIds) {\n        byte[] startTime = getStartTime(entity, entityType, null, null, null);\n        if (startTime != null) {\n          List<EntityIdentifier> entities = startTimeMap.get(startTime);\n          if (entities == null) {\n            entities = new ArrayList<EntityIdentifier>();\n            startTimeMap.put(startTime, entities);\n          }\n          entities.add(new EntityIdentifier(entity, entityType));\n        }\n      }\n      for (Entry<byte[], List<EntityIdentifier>> entry :\n          startTimeMap.entrySet()) {\n        // look up the events matching the given parameters (limit,\n        // start time, end time, event types) for entities whose start times\n        // were found and add the entities to the return list\n        byte[] revStartTime = entry.getKey();\n        for (EntityIdentifier entityID : entry.getValue()) {\n          EventsOfOneEntity entity = new EventsOfOneEntity();\n          entity.setEntityId(entityID.getId());\n          entity.setEntityType(entityType);\n          events.addEvent(entity);\n          KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n              .add(entityType).add(revStartTime).add(entityID.getId())\n              .add(TIME_COLUMN);\n          byte[] prefix = kb.getBytesForLookup();\n          if (windowEnd == null) {\n            windowEnd = Long.MAX_VALUE;\n          }\n          byte[] revts = writeReverseOrderedLong(windowEnd);\n          kb.add(revts);\n          byte[] first = kb.getBytesForLookup();\n          byte[] last = null;\n          if (windowStart != null) {\n            last = KeyBuilder.newInstance().add(prefix)\n                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n          }\n          if (limit == null) {\n            limit = DEFAULT_LIMIT;\n          }\n          iterator = db.iterator();\n          for (iterator.seek(first); entity.getEvents().size() < limit &&\n              iterator.hasNext(); iterator.next()) {\n            byte[] key = iterator.peekNext().getKey();\n            if (!prefixMatches(prefix, prefix.length, key) || (last != null &&\n                WritableComparator.compareBytes(key, 0, key.length, last, 0,\n                    last.length) > 0))\n              break;\n            TimelineEvent event = getEntityEvent(eventType, key, prefix.length,\n                iterator.peekNext().getValue());\n            if (event != null)\n              entity.addEvent(event);\n          }\n        }\n      }\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n    return events;\n  }","id":77199,"modified_method":"@Override\n  public TimelineEvents getEntityTimelines(String entityType,\n      SortedSet<String> entityIds, Long limit, Long windowStart,\n      Long windowEnd, Set<String> eventType) throws IOException {\n    TimelineEvents events = new TimelineEvents();\n    if (entityIds == null || entityIds.isEmpty())\n      return events;\n    // create a lexicographically-ordered map from start time to entities\n    Map<byte[], List<EntityIdentifier>> startTimeMap = new TreeMap<byte[],\n        List<EntityIdentifier>>(new Comparator<byte[]>() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                o2.length);\n          }\n        });\n    DBIterator iterator = null;\n    try {\n      // look up start times for the specified entities\n      // skip entities with no start time\n      for (String entity : entityIds) {\n        byte[] startTime = getStartTime(entity, entityType);\n        if (startTime != null) {\n          List<EntityIdentifier> entities = startTimeMap.get(startTime);\n          if (entities == null) {\n            entities = new ArrayList<EntityIdentifier>();\n            startTimeMap.put(startTime, entities);\n          }\n          entities.add(new EntityIdentifier(entity, entityType));\n        }\n      }\n      for (Entry<byte[], List<EntityIdentifier>> entry :\n          startTimeMap.entrySet()) {\n        // look up the events matching the given parameters (limit,\n        // start time, end time, event types) for entities whose start times\n        // were found and add the entities to the return list\n        byte[] revStartTime = entry.getKey();\n        for (EntityIdentifier entityID : entry.getValue()) {\n          EventsOfOneEntity entity = new EventsOfOneEntity();\n          entity.setEntityId(entityID.getId());\n          entity.setEntityType(entityType);\n          events.addEvent(entity);\n          KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n              .add(entityType).add(revStartTime).add(entityID.getId())\n              .add(TIME_COLUMN);\n          byte[] prefix = kb.getBytesForLookup();\n          if (windowEnd == null) {\n            windowEnd = Long.MAX_VALUE;\n          }\n          byte[] revts = writeReverseOrderedLong(windowEnd);\n          kb.add(revts);\n          byte[] first = kb.getBytesForLookup();\n          byte[] last = null;\n          if (windowStart != null) {\n            last = KeyBuilder.newInstance().add(prefix)\n                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n          }\n          if (limit == null) {\n            limit = DEFAULT_LIMIT;\n          }\n          iterator = db.iterator();\n          for (iterator.seek(first); entity.getEvents().size() < limit &&\n              iterator.hasNext(); iterator.next()) {\n            byte[] key = iterator.peekNext().getKey();\n            if (!prefixMatches(prefix, prefix.length, key) || (last != null &&\n                WritableComparator.compareBytes(key, 0, key.length, last, 0,\n                    last.length) > 0))\n              break;\n            TimelineEvent event = getEntityEvent(eventType, key, prefix.length,\n                iterator.peekNext().getValue());\n            if (event != null)\n              entity.addEvent(event);\n          }\n        }\n      }\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n    return events;\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public TimelineEntity getEntity(String entityId, String entityType,\n      EnumSet<Field> fields) throws IOException {\n    DBIterator iterator = null;\n    try {\n      byte[] revStartTime = getStartTime(entityId, entityType, null, null, null);\n      if (revStartTime == null)\n        return null;\n      byte[] prefix = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n          .add(entityType).add(revStartTime).add(entityId).getBytesForLookup();\n\n      iterator = db.iterator();\n      iterator.seek(prefix);\n\n      return getEntity(entityId, entityType,\n          readReverseOrderedLong(revStartTime, 0), fields, iterator, prefix,\n          prefix.length);\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","id":77200,"modified_method":"@Override\n  public TimelineEntity getEntity(String entityId, String entityType,\n      EnumSet<Field> fields) throws IOException {\n    DBIterator iterator = null;\n    try {\n      byte[] revStartTime = getStartTime(entityId, entityType);\n      if (revStartTime == null)\n        return null;\n      byte[] prefix = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n          .add(entityType).add(revStartTime).add(entityId).getBytesForLookup();\n\n      iterator = db.iterator();\n      iterator.seek(prefix);\n\n      return getEntity(entityId, entityType,\n          readReverseOrderedLong(revStartTime, 0), fields, iterator, prefix,\n          prefix.length);\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Get the unique start time for a given entity as a byte array that sorts\n   * the timestamps in reverse order (see {@link\n   * GenericObjectMapper#writeReverseOrderedLong(long)}).\n   *\n   * @param entityId The id of the entity\n   * @param entityType The type of the entity\n   * @param startTime The start time of the entity, or null\n   * @param events A list of events for the entity, or null\n   * @param writeBatch A leveldb write batch, if the method is called by a\n   *                   put as opposed to a get\n   * @return A byte array\n   * @throws IOException\n   */\n  private byte[] getStartTime(String entityId, String entityType,\n      Long startTime, List<TimelineEvent> events, WriteBatch writeBatch)\n      throws IOException {\n    EntityIdentifier entity = new EntityIdentifier(entityId, entityType);\n    if (startTime == null) {\n      // start time is not provided, so try to look it up\n      if (startTimeCache.containsKey(entity)) {\n        // found the start time in the cache\n        startTime = startTimeCache.get(entity);\n      } else {\n        // try to look up the start time in the db\n        byte[] b = createStartTimeLookupKey(entity.getId(), entity.getType());\n        byte[] v = db.get(b);\n        if (v == null) {\n          // did not find the start time in the db\n          // if this is a put, try to set it from the provided events\n          if (events == null || writeBatch == null) {\n            // no events, or not a put, so return null\n            return null;\n          }\n          Long min = Long.MAX_VALUE;\n          for (TimelineEvent e : events)\n            if (min > e.getTimestamp())\n              min = e.getTimestamp();\n          startTime = min;\n          // selected start time as minimum timestamp of provided events\n          // write start time to db and cache\n          writeBatch.put(b, writeReverseOrderedLong(startTime));\n          startTimeCache.put(entity, startTime);\n        } else {\n          // found the start time in the db\n          startTime = readReverseOrderedLong(v, 0);\n          if (writeBatch != null) {\n            // if this is a put, re-add the start time to the cache\n            startTimeCache.put(entity, startTime);\n          }\n        }\n      }\n    } else {\n      // start time is provided\n      // TODO: verify start time in db as well as cache?\n      if (startTimeCache.containsKey(entity)) {\n        // if the start time is already in the cache,\n        // and it is different from the provided start time,\n        // use the one from the cache\n        if (!startTime.equals(startTimeCache.get(entity)))\n          startTime = startTimeCache.get(entity);\n      } else if (writeBatch != null) {\n        // if this is a put, write the provided start time to the db and the\n        // cache\n        byte[] b = createStartTimeLookupKey(entity.getId(), entity.getType());\n        writeBatch.put(b, writeReverseOrderedLong(startTime));\n        startTimeCache.put(entity, startTime);\n      }\n    }\n    return writeReverseOrderedLong(startTime);\n  }","id":77201,"modified_method":"/**\n   * Get the unique start time for a given entity as a byte array that sorts\n   * the timestamps in reverse order (see {@link\n   * GenericObjectMapper#writeReverseOrderedLong(long)}). If the start time\n   * doesn't exist, set it based on the information provided.\n   *\n   * @param entityId The id of the entity\n   * @param entityType The type of the entity\n   * @param startTime The start time of the entity, or null\n   * @param events A list of events for the entity, or null\n   * @param writeBatch A leveldb write batch, if the method is called by a\n   *                   put as opposed to a get\n   * @return A byte array\n   * @throws IOException\n   */\n  private byte[] getAndSetStartTime(String entityId, String entityType,\n      Long startTime, List<TimelineEvent> events, WriteBatch writeBatch)\n      throws IOException {\n    EntityIdentifier entity = new EntityIdentifier(entityId, entityType);\n    if (startTime == null) {\n      // start time is not provided, so try to look it up\n      if (startTimeWriteCache.containsKey(entity)) {\n        // found the start time in the cache\n        startTime = startTimeWriteCache.get(entity);\n        return writeReverseOrderedLong(startTime);\n      } else {\n        if (events != null) {\n          // prepare a start time from events in case it is needed\n          Long min = Long.MAX_VALUE;\n          for (TimelineEvent e : events) {\n            if (min > e.getTimestamp()) {\n              min = e.getTimestamp();\n            }\n          }\n          startTime = min;\n        }\n        return checkStartTimeInDb(entity, startTime, writeBatch);\n      }\n    } else {\n      // start time is provided\n      if (startTimeWriteCache.containsKey(entity)) {\n        // check the provided start time matches the cache\n        if (!startTime.equals(startTimeWriteCache.get(entity))) {\n          // the start time is already in the cache,\n          // and it is different from the provided start time,\n          // so use the one from the cache\n          startTime = startTimeWriteCache.get(entity);\n        }\n        return writeReverseOrderedLong(startTime);\n      } else {\n        // check the provided start time matches the db\n        return checkStartTimeInDb(entity, startTime, writeBatch);\n      }\n    }\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Put a single entity.  If there is an error, add a TimelinePutError to the given\n   * response.\n   */\n  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    WriteBatch writeBatch = null;\n    try {\n      writeBatch = db.createWriteBatch();\n      List<TimelineEvent> events = entity.getEvents();\n      // look up the start time for the entity\n      byte[] revStartTime = getStartTime(entity.getEntityId(),\n          entity.getEntityType(), entity.getStartTime(), events,\n          writeBatch);\n      if (revStartTime == null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error = new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      Long revStartTimeLong = readReverseOrderedLong(revStartTime, 0);\n      Map<String, Set<Object>> primaryFilters = entity.getPrimaryFilters();\n\n      // write event entries\n      if (events != null && !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts = writeReverseOrderedLong(event.getTimestamp());\n          byte[] key = createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value = GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map<String, Set<String>> relatedEntities =\n          entity.getRelatedEntities();\n      if (relatedEntities != null && !relatedEntities.isEmpty()) {\n        for (Entry<String, Set<String>> relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType = relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // look up start time of related entity\n            byte[] relatedEntityStartTime = getStartTime(relatedEntityId,\n                relatedEntityType, null, null, writeBatch);\n            if (relatedEntityStartTime == null) {\n              // if start time is not found, set start time of the related\n              // entity to the start time of this entity, and write it to the\n              // db and the cache\n              relatedEntityStartTime = revStartTime;\n              writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n                  relatedEntityType), relatedEntityStartTime);\n              startTimeCache.put(new EntityIdentifier(relatedEntityId,\n                  relatedEntityType), revStartTimeLong);\n            }\n            // write reverse entry (related entity -> entity)\n            byte[] key = createReleatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n            // TODO: write forward entry (entity -> related entity)?\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters != null && !primaryFilters.isEmpty()) {\n        for (Entry<String, Set<Object>> primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key = createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map<String, Object> otherInfo = entity.getOtherInfo();\n      if (otherInfo != null && !otherInfo.isEmpty()) {\n        for (Entry<String, Object> i : otherInfo.entrySet()) {\n          byte[] key = createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value = GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error = new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }","id":77202,"modified_method":"/**\n   * Put a single entity.  If there is an error, add a TimelinePutError to the given\n   * response.\n   */\n  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    LockMap.CountingReentrantLock<EntityIdentifier> lock =\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch = null;\n    try {\n      writeBatch = db.createWriteBatch();\n      List<TimelineEvent> events = entity.getEvents();\n      // look up the start time for the entity\n      byte[] revStartTime = getAndSetStartTime(entity.getEntityId(),\n          entity.getEntityType(), entity.getStartTime(), events,\n          writeBatch);\n      if (revStartTime == null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error = new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      Long revStartTimeLong = readReverseOrderedLong(revStartTime, 0);\n      Map<String, Set<Object>> primaryFilters = entity.getPrimaryFilters();\n\n      // write event entries\n      if (events != null && !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts = writeReverseOrderedLong(event.getTimestamp());\n          byte[] key = createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value = GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map<String, Set<String>> relatedEntities =\n          entity.getRelatedEntities();\n      if (relatedEntities != null && !relatedEntities.isEmpty()) {\n        for (Entry<String, Set<String>> relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType = relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // look up start time of related entity\n            byte[] relatedEntityStartTime = getAndSetStartTime(relatedEntityId,\n                relatedEntityType, null, null, writeBatch);\n            if (relatedEntityStartTime == null) {\n              // if start time is not found, set start time of the related\n              // entity to the start time of this entity, and write it to the\n              // db and the cache\n              relatedEntityStartTime = revStartTime;\n              writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n                  relatedEntityType), relatedEntityStartTime);\n              startTimeWriteCache.put(new EntityIdentifier(relatedEntityId,\n                  relatedEntityType), revStartTimeLong);\n            }\n            // write reverse entry (related entity -> entity)\n            byte[] key = createReleatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n            // TODO: write forward entry (entity -> related entity)?\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters != null && !primaryFilters.isEmpty()) {\n        for (Entry<String, Set<Object>> primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key = createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map<String, Object> otherInfo = entity.getOtherInfo();\n      if (otherInfo != null && !otherInfo.isEmpty()) {\n        for (Entry<String, Object> i : otherInfo.entrySet()) {\n          byte[] key = createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value = GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error = new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testGetSingleEntity() throws IOException {\n    super.testGetSingleEntity();\n    ((LeveldbTimelineStore)store).clearStartTimeCache();\n    super.testGetSingleEntity();\n  }","id":77203,"modified_method":"@Test\n  public void testGetSingleEntity() throws IOException {\n    super.testGetSingleEntity();\n    ((LeveldbTimelineStore)store).clearStartTimeCache();\n    super.testGetSingleEntity();\n    loadTestData();\n  }","commit_id":"40464fba22bac99d0e5b79674152aa5dfba99483","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * This is a smell - this means docs will say defaults are something other than what they are in the server. Better make embedded the special case and\n     * set the defaults to be what the server will have.\n     *\n     * In any case - this overrides embedded defaults.\n     */\n    private static void overrideEmbeddedDefaults( Config config )\n    {\n        Map<String,String> params = config.getParams();\n        if ( !params.containsKey( ShellSettings.remote_shell_enabled.name() ) )\n        {\n            params.put( ShellSettings.remote_shell_enabled.name(), TRUE );\n        }\n\n        if ( !params.containsKey( GraphDatabaseSettings.log_queries_filename.name() ) )\n        {\n            params.put( GraphDatabaseSettings.log_queries_filename.name(), \"data/log/queries.log\" );\n        }\n\n        if( !params.containsKey( BoltKernelExtension.Settings.enabled.name() ))\n        {\n            params.put( BoltKernelExtension.Settings.enabled.name(), \"true\" );\n        }\n\n        if( !params.containsKey( GraphDatabaseSettings.auth_enabled.name() ))\n        {\n            params.put( GraphDatabaseSettings.auth_enabled.name(), \"true\" );\n        }\n\n        config.applyChanges( params );\n    }","id":77204,"modified_method":"private static void overrideEmbeddedDefaults( HashMap<String, String> config )\n    {\n        config.putIfAbsent( ShellSettings.remote_shell_enabled.name(), TRUE );\n        config.putIfAbsent( GraphDatabaseSettings.log_queries_filename.name(), \"data/log/queries.log\" );\n        config.putIfAbsent( BoltKernelExtension.Settings.enabled.name(), \"true\" );\n        config.putIfAbsent( GraphDatabaseSettings.auth_enabled.name(), \"true\" );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Config loadConfig( File configFile, File legacyConfigFile, Log log, Pair<String, String> ... configOverrides )\n    {\n        if ( log == null )\n        {\n            throw new IllegalArgumentException( \"log cannot be null \");\n        }\n\n        Config config = new Config( emptyMap(), asList( ServerSettings.class, GraphDatabaseSettings.class ) );\n        config.setLogger( log );\n\n        // For now, don't print warnings if this file is not specified\n        if( configFile != null && configFile.exists() )\n        {\n            config.augment( loadFromFile( log, configFile ) );\n        }\n\n        config.augment( loadFromFile( log, legacyConfigFile ) );\n\n        overrideEmbeddedDefaults( config );\n        applyUserOverrides( config, configOverrides );\n\n        return config;\n    }","id":77205,"modified_method":"public Config loadConfig( File configFile, File legacyConfigFile, Log log, Pair<String, String>... configOverrides )\n    {\n        if ( log == null )\n        {\n            throw new IllegalArgumentException( \"log cannot be null \" );\n        }\n\n        HashMap<String, String> settings = calculateSettings( configFile, legacyConfigFile, log, configOverrides );\n        Config config = new Config( settings, asList( ServerSettings.class, GraphDatabaseSettings.class ) );\n        config.setLogger( log );\n        return config;\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Augment the existing config with new settings, overriding any conflicting settings, but keeping all old\n     * non-overlapping ones.\n     *\n     * @param changes settings to add and override\n     */\n    public Config augment( Map<String, String> changes )\n    {\n        Map<String, String> params = getParams();\n        params.putAll( changes );\n        applyChanges( params );\n        return this;\n    }","id":77206,"modified_method":"/**\n     * Augment the existing config with new settings, overriding any conflicting settings, but keeping all old\n     * non-overlapping ones.\n     *\n     * @param changes settings to add and override\n     */\n    public Config augment( Map<String, String> changes )\n    {\n        Map<String, String> params = getParams();\n        params.putAll( changes );\n        replaceSettings( params );\n        return this;\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Replace the current set of configuration parameters with another one.\n     */\n    public synchronized Config applyChanges( Map<String, String> newConfiguration )\n    {\n        newConfiguration = migrator.apply( newConfiguration, log );\n\n        // Make sure all changes are valid\n        validator.validate( newConfiguration );\n\n        // Figure out what changed\n        if ( listeners.isEmpty() )\n        {\n            // Make the change\n            params.clear();\n            params.putAll( newConfiguration );\n        }\n        else\n        {\n            List<ConfigurationChange> configurationChanges = new ArrayList<>();\n            for ( Map.Entry<String, String> stringStringEntry : newConfiguration.entrySet() )\n            {\n                String oldValue = params.get( stringStringEntry.getKey() );\n                String newValue = stringStringEntry.getValue();\n                if ( !(oldValue == null && newValue == null) &&\n                        (oldValue == null || newValue == null || !oldValue.equals( newValue )) )\n                {\n                    configurationChanges.add( new ConfigurationChange( stringStringEntry.getKey(), oldValue,\n                            newValue ) );\n                }\n            }\n\n            if ( configurationChanges.isEmpty() )\n            {\n                // Don't bother... nothing changed.\n                return this;\n            }\n\n            // Make the change\n            params.clear();\n            for ( Map.Entry<String, String> entry : newConfiguration.entrySet() )\n            {\n                // Filter out nulls because we are using a ConcurrentHashMap under the covers, which doesn't support\n                // null keys or values.\n                String value = entry.getValue();\n                if ( value != null )\n                {\n                    params.put( entry.getKey(), value );\n                }\n            }\n\n            // Notify listeners\n            for ( ConfigurationChangeListener listener : listeners )\n            {\n                listener.notifyConfigurationChanges( configurationChanges );\n            }\n        }\n\n        return this;\n    }","id":77207,"modified_method":"private synchronized Config replaceSettings( Map<String, String> newValues )\n    {\n        newValues = migrator.apply( newValues, log );\n\n        // Make sure all changes are valid\n        validator.validate( newValues );\n\n        // Figure out what changed\n        if ( listeners.isEmpty() )\n        {\n            // Make the change\n            params.clear();\n            params.putAll( newValues );\n        }\n        else\n        {\n            List<ConfigurationChange> configurationChanges = new ArrayList<>();\n            for ( Map.Entry<String, String> stringStringEntry : newValues.entrySet() )\n            {\n                String oldValue = params.get( stringStringEntry.getKey() );\n                String newValue = stringStringEntry.getValue();\n                if ( !(oldValue == null && newValue == null) &&\n                        (oldValue == null || newValue == null || !oldValue.equals( newValue )) )\n                {\n                    configurationChanges.add( new ConfigurationChange( stringStringEntry.getKey(), oldValue,\n                            newValue ) );\n                }\n            }\n\n            if ( configurationChanges.isEmpty() )\n            {\n                // Don't bother... nothing changed.\n                return this;\n            }\n\n            // Make the change\n            params.clear();\n            for ( Map.Entry<String, String> entry : newValues.entrySet() )\n            {\n                // Filter out nulls because we are using a ConcurrentHashMap under the covers, which doesn't support\n                // null keys or values.\n                String value = entry.getValue();\n                if ( value != null )\n                {\n                    params.put( entry.getKey(), value );\n                }\n            }\n\n            // Notify listeners\n            for ( ConfigurationChangeListener listener : listeners )\n            {\n                listener.notifyConfigurationChanges( configurationChanges );\n            }\n        }\n\n        return this;\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Add more settings classes.\n     */\n    public Config registerSettingsClasses( Iterable<Class<?>> settingsClasses )\n    {\n        this.settingsClasses = Iterables.concat( settingsClasses, this.settingsClasses );\n        this.migrator = new AnnotationBasedConfigurationMigrator( settingsClasses );\n        this.validator = new ConfigurationValidator( settingsClasses );\n\n        // Apply the requirements and changes the new settings classes introduce\n        this.applyChanges( getParams() );\n\n        return this;\n    }","id":77208,"modified_method":"/**\n     * Add more settings classes.\n     */\n    public Config registerSettingsClasses( Iterable<Class<?>> settingsClasses )\n    {\n        this.settingsClasses = Iterables.concat( settingsClasses, this.settingsClasses );\n        this.migrator = new AnnotationBasedConfigurationMigrator( settingsClasses );\n        this.validator = new ConfigurationValidator( settingsClasses );\n\n        // Apply the requirements and changes the new settings classes introduce\n        this.replaceSettings( getParams() );\n\n        return this;\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void addPropertyDirect( String key, Object value )\n    {\n        config.applyChanges( MapUtil.stringMap( config.getParams(), key, value.toString() ) );\n    }","id":77209,"modified_method":"@Override\n    protected void addPropertyDirect( String key, Object value )\n    {\n        config.augment( stringMap( key, value.toString() ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindNoGroupViewWhenGroupNameIsMissing() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"0.user.name\", \"Bob\",\n                \"0.user.age\", \"81\",\n                \"1.user.name\", \"Greta\",\n                \"1.user.age\", \"82\" ) );\n\n        Setting<String> name = setting( \"user.name\", STRING, NO_DEFAULT );\n        Setting<Integer> age = setting( \"user.age\", INTEGER, NO_DEFAULT );\n\n        // When\n        List<Configuration> emptyStrViews = config.view( Config.groups( \"\" ) );\n        List<Configuration> numViews = config.view( Config.groups( \"0\" ) );\n\n        // Then\n        assertThat( emptyStrViews.size(), equalTo( 0 ) );\n        assertThat( numViews.size(), equalTo( 0 ) );\n        assertThat( config.get( setting( \"0.user.name\", STRING, NO_DEFAULT ) ), equalTo( \"Bob\" ) );\n    }","id":77210,"modified_method":"@Test\n    public void shouldFindNoGroupViewWhenGroupNameIsMissing() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"0.user.name\", \"Bob\",\n                \"0.user.age\", \"81\",\n                \"1.user.name\", \"Greta\",\n                \"1.user.age\", \"82\" ) );\n\n        Setting<String> name = setting( \"user.name\", STRING, NO_DEFAULT );\n        Setting<Integer> age = setting( \"user.age\", INTEGER, NO_DEFAULT );\n\n        // When\n        List<Configuration> emptyStrViews = config.view( ConfigGroups.groups( \"\" ) );\n        List<Configuration> numViews = config.view( ConfigGroups.groups( \"0\" ) );\n\n        // Then\n        assertThat( emptyStrViews.size(), equalTo( 0 ) );\n        assertThat( numViews.size(), equalTo( 0 ) );\n        assertThat( config.get( setting( \"0.user.name\", STRING, NO_DEFAULT ) ), equalTo( \"Bob\" ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotifyChangeListenersWhenNewSettingsAreApplied()\n    {\n        // Given\n        Config config = new Config( stringMap(\"setting\", \"old\"), MyMigratingSettings.class );\n        ChangeCaptureListener listener = new ChangeCaptureListener();\n        config.addConfigurationChangeListener( listener );\n\n        // When\n        config.applyChanges( stringMap( \"setting\", \"new\" ) );\n\n        // Then\n        assertThat( listener.lastChangeSet,\n                is( setOf( new ConfigurationChange( \"setting\", \"old\", \"new\" ) ) ) );\n    }","id":77211,"modified_method":"@Test\n    public void shouldNotifyChangeListenersWhenNewSettingsAreApplied()\n    {\n        // Given\n        Config config = new Config( stringMap( \"setting\", \"old\" ), MyMigratingSettings.class );\n        ChangeCaptureListener listener = new ChangeCaptureListener();\n        config.addConfigurationChangeListener( listener );\n\n        // When\n        config.augment( stringMap( \"setting\", \"new\" ) );\n\n        // Then\n        assertThat( listener.lastChangeSet,\n                is( setOf( new ConfigurationChange( \"setting\", \"old\", \"new\" ) ) ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindNoGroupViewWhenGroupNameIsWrong() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"my.users.0.name\", \"Bob\",\n                \"my.users.0.age\", \"81\",\n                \"my.users.1.name\", \"Greta\",\n                \"my.users.1.age\", \"82\" ) );\n\n        // When\n        List<Configuration> views = config.view( Config.groups( \"my\" ) );\n\n        // Then\n        assertThat( views.size(), equalTo( 0 ) );\n    }","id":77212,"modified_method":"@Test\n    public void shouldFindNoGroupViewWhenGroupNameIsWrong() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"my.users.0.name\", \"Bob\",\n                \"my.users.0.age\", \"81\",\n                \"my.users.1.name\", \"Greta\",\n                \"my.users.1.age\", \"82\" ) );\n\n        // When\n        List<Configuration> views = config.view( ConfigGroups.groups( \"my\" ) );\n\n        // Then\n        assertThat( views.size(), equalTo( 0 ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotNotifyChangeListenerWhenNothingChanged()\n    {\n        // Given\n        Config config = new Config( stringMap(\"setting\", \"old\"), MyMigratingSettings.class );\n        ChangeCaptureListener listener = new ChangeCaptureListener();\n        config.addConfigurationChangeListener( listener );\n\n        // When\n        config.applyChanges( stringMap( \"setting\", \"old\" ) ); // nothing really changed here\n\n        // Then\n        assertThat( listener.lastChangeSet, nullValue() );\n    }","id":77213,"modified_method":"@Test\n    public void shouldNotNotifyChangeListenerWhenNothingChanged()\n    {\n        // Given\n        Config config = new Config( stringMap( \"setting\", \"old\" ), MyMigratingSettings.class );\n        ChangeCaptureListener listener = new ChangeCaptureListener();\n        config.addConfigurationChangeListener( listener );\n\n        // When\n        config.augment( stringMap( \"setting\", \"old\" ) ); // nothing really changed here\n\n        // Then\n        assertThat( listener.lastChangeSet, nullValue() );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldOnlyReadInsideGroupWhileAccessingSettingsInAGroup() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"name\", \"lemon\",\n                \"my.users.0.user.name\", \"Bob\",\n                \"my.users.0.user.age\", \"81\",\n                \"my.users.1.user.name\", \"Greta\",\n                \"my.users.1.user.age\", \"82\" ) );\n\n        Setting<String> name = setting( \"name\", STRING, \"No name given to this poor user\" );\n        Setting<Integer> age = setting( \"age\", INTEGER, NO_DEFAULT );\n\n        // When\n        List<Configuration> views = config.view( Config.groups( \"my.users\" ) );\n\n        // Then\n        assertThat( views.size(), equalTo( 2 ) );\n\n        Configuration bob = views.get( 0 );\n        assertThat( bob.get( name ), equalTo( \"No name given to this poor user\" ) );\n        assertNull( bob.get( age ) );\n\n        Configuration greta = views.get( 1 );\n        assertThat( greta.get( name ), equalTo( \"No name given to this poor user\" ) );\n        assertNull( greta.get( age ) );\n\n        assertThat( config.get( name ), equalTo( \"lemon\" ) );\n        assertNull( config.get( age ) );\n    }","id":77214,"modified_method":"@Test\n    public void shouldOnlyReadInsideGroupWhileAccessingSettingsInAGroup() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"name\", \"lemon\",\n                \"my.users.0.user.name\", \"Bob\",\n                \"my.users.0.user.age\", \"81\",\n                \"my.users.1.user.name\", \"Greta\",\n                \"my.users.1.user.age\", \"82\" ) );\n\n        Setting<String> name = setting( \"name\", STRING, \"No name given to this poor user\" );\n        Setting<Integer> age = setting( \"age\", INTEGER, NO_DEFAULT );\n\n        // When\n        List<Configuration> views = config.view( ConfigGroups.groups( \"my.users\" ) );\n\n        // Then\n        assertThat( views.size(), equalTo( 2 ) );\n\n        Configuration bob = views.get( 0 );\n        assertThat( bob.get( name ), equalTo( \"No name given to this poor user\" ) );\n        assertNull( bob.get( age ) );\n\n        Configuration greta = views.get( 1 );\n        assertThat( greta.get( name ), equalTo( \"No name given to this poor user\" ) );\n        assertNull( greta.get( age ) );\n\n        assertThat( config.get( name ), equalTo( \"lemon\" ) );\n        assertNull( config.get( age ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToAgumentConfig() throws Exception\n    {\n        // Given\n        Config config = new Config( stringMap( \"newer\", \"old\", \"non-overlapping\", \"huzzah\" ) );\n\n        // When\n        config.augment( stringMap( \"newer\", \"new\", \"unrelated\", \"hello\" ) );\n\n        // Then\n        assertThat( config.get( setting(\"newer\", STRING, \"\") ), equalTo( \"new\" ) );\n        assertThat( config.get( setting(\"non-overlapping\", STRING, \"\") ), equalTo( \"huzzah\" ) );\n        assertThat( config.get( setting(\"unrelated\", STRING, \"\") ), equalTo( \"hello\" ) );\n    }","id":77215,"modified_method":"@Test\n    public void shouldBeAbleToAugmentConfig() throws Exception\n    {\n        // Given\n        Config config = new Config( stringMap( \"newer\", \"old\", \"non-overlapping\", \"huzzah\" ) );\n\n        // When\n        config.augment( stringMap( \"newer\", \"new\", \"unrelated\", \"hello\" ) );\n\n        // Then\n        assertThat( config.get( setting( \"newer\", STRING, \"\" ) ), equalTo( \"new\" ) );\n        assertThat( config.get( setting( \"non-overlapping\", STRING, \"\" ) ), equalTo( \"huzzah\" ) );\n        assertThat( config.get( setting( \"unrelated\", STRING, \"\" ) ), equalTo( \"hello\" ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldApplyDefaults()\n    {\n        Config config = new Config( new HashMap<String, String>(), MySettingsWithDefaults.class );\n\n        assertThat( config.get( MySettingsWithDefaults.hello ), is( \"Hello, World!\" ) );\n    }","id":77216,"modified_method":"@Test\n    public void shouldApplyDefaults()\n    {\n        Config config = new Config( new HashMap<>(), MySettingsWithDefaults.class );\n\n        assertThat( config.get( MySettingsWithDefaults.hello ), is( \"Hello, World!\" ) );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test( expected = InvalidSettingException.class )\n    public void shouldNotAllowSettingInvalidValues()\n    {\n        Config config = new Config( new HashMap<String, String>(), MySettingsWithDefaults.class );\n\n        Map<String, String> params = config.getParams();\n        params.put( MySettingsWithDefaults.boolSetting.name(), \"asd\" );\n\n        config.applyChanges( params );\n\n        fail( \"Expected validation to fail.\" );\n    }","id":77217,"modified_method":"@Test(expected = InvalidSettingException.class)\n    public void shouldNotAllowSettingInvalidValues()\n    {\n        new Config( stringMap( MySettingsWithDefaults.boolSetting.name(), \"asd\" ), MySettingsWithDefaults.class );\n        fail( \"Expected validation to fail.\" );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideViewOfGroups() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"my.users.0.user.name\", \"Bob\",\n                \"my.users.0.user.age\", \"81\",\n                \"my.users.1.user.name\", \"Greta\",\n                \"my.users.1.user.age\", \"82\" ) );\n\n        Setting<String> name = setting( \"user.name\", STRING, NO_DEFAULT );\n        Setting<Integer> age = setting( \"user.age\", INTEGER, NO_DEFAULT );\n\n        // When\n        List<Configuration> views = config.view( Config.groups( \"my.users\" ) );\n\n        // Then\n        assertThat( views.size(), equalTo( 2 ) );\n\n        Configuration bob = views.get( 0 );\n        assertThat( bob.get( name ), equalTo( \"Bob\" ) );\n        assertThat( bob.get( age ), equalTo( 81 ) );\n\n        Configuration greta = views.get( 1 );\n        assertThat( greta.get( name ), equalTo( \"Greta\" ) );\n        assertThat( greta.get( age ), equalTo( 82 ) );\n\n        // however given the full name, the config could still be accessed outside the group\n        Setting<String> name0 = setting( \"my.users.0.user.name\", STRING, NO_DEFAULT );\n        assertThat( config.get( name0 ), equalTo( \"Bob\" ) );\n\n    }","id":77218,"modified_method":"@Test\n    public void shouldProvideViewOfGroups() throws Throwable\n    {\n        // Given\n        Config config = new Config( stringMap(\n                \"my.users.0.user.name\", \"Bob\",\n                \"my.users.0.user.age\", \"81\",\n                \"my.users.1.user.name\", \"Greta\",\n                \"my.users.1.user.age\", \"82\" ) );\n\n        Setting<String> name = setting( \"user.name\", STRING, NO_DEFAULT );\n        Setting<Integer> age = setting( \"user.age\", INTEGER, NO_DEFAULT );\n\n        // When\n        List<Configuration> views = config.view( ConfigGroups.groups( \"my.users\" ) );\n\n        // Then\n        assertThat( views.size(), equalTo( 2 ) );\n\n        Configuration bob = views.get( 0 );\n        assertThat( bob.get( name ), equalTo( \"Bob\" ) );\n        assertThat( bob.get( age ), equalTo( 81 ) );\n\n        Configuration greta = views.get( 1 );\n        assertThat( greta.get( name ), equalTo( \"Greta\" ) );\n        assertThat( greta.get( age ), equalTo( 82 ) );\n\n        // however given the full name, the config could still be accessed outside the group\n        Setting<String> name0 = setting( \"my.users.0.user.name\", STRING, NO_DEFAULT );\n        assertThat( config.get( name0 ), equalTo( \"Bob\" ) );\n\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowGraphCheckDisabled() throws IOException, ConsistencyCheckIncompleteException\n    {\n        GraphDatabaseService gds = getGraphDatabaseService();\n\n        try ( Transaction tx = gds.beginTx() )\n        {\n            gds.createNode();\n            tx.success();\n        }\n\n        gds.shutdown();\n\n        ConsistencyCheckService service = new ConsistencyCheckService();\n        Config configuration = new Config( settings(), GraphDatabaseSettings.class, ConsistencyCheckSettings.class );\n        configuration.applyChanges( MapUtil.stringMap( ConsistencyCheckSettings.consistency_check_graph.name(),\n                Settings.FALSE ) );\n\n        // when\n        Result result = service.runFullConsistencyCheck( testDirectory.graphDbDir(), configuration,\n                ProgressMonitorFactory.NONE, NullLogProvider.getInstance(), new DefaultFileSystemAbstraction() );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.SUCCESS, result );\n    }","id":77219,"modified_method":"@Test\n    public void shouldAllowGraphCheckDisabled() throws IOException, ConsistencyCheckIncompleteException\n    {\n        GraphDatabaseService gds = getGraphDatabaseService();\n\n        try ( Transaction tx = gds.beginTx() )\n        {\n            gds.createNode();\n            tx.success();\n        }\n\n        gds.shutdown();\n\n        ConsistencyCheckService service = new ConsistencyCheckService();\n        Config configuration = new Config(\n                stringMap( ConsistencyCheckSettings.consistency_check_graph.name(), Settings.FALSE ),\n                GraphDatabaseSettings.class, ConsistencyCheckSettings.class );\n\n        // when\n        Result result = service.runFullConsistencyCheck( testDirectory.graphDbDir(), configuration,\n                ProgressMonitorFactory.NONE, NullLogProvider.getInstance(), new DefaultFileSystemAbstraction() );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.SUCCESS, result );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowGraphCheckDisabled() throws IOException, ConsistencyCheckIncompleteException\n    {\n        GraphDatabaseService gds = getGraphDatabaseService();\n\n        try ( Transaction tx = gds.beginTx() )\n        {\n            gds.createNode();\n            tx.success();\n        }\n\n        gds.shutdown();\n\n        ConsistencyCheckService service = new ConsistencyCheckService();\n        Config configuration = new Config( settings(), GraphDatabaseSettings.class, ConsistencyCheckSettings.class );\n        configuration.applyChanges( MapUtil.stringMap( ConsistencyCheckSettings.consistency_check_graph.name(),\n                Settings.FALSE ) );\n\n        // when\n        Result result = runFullConsistencyCheck( service, configuration );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.SUCCESS, result );\n    }","id":77220,"modified_method":"@Test\n    public void shouldAllowGraphCheckDisabled() throws IOException, ConsistencyCheckIncompleteException\n    {\n        GraphDatabaseService gds = getGraphDatabaseService();\n\n        try ( Transaction tx = gds.beginTx() )\n        {\n            gds.createNode();\n            tx.success();\n        }\n\n        gds.shutdown();\n\n        ConsistencyCheckService service = new ConsistencyCheckService();\n        Config configuration = new Config(\n                stringMap( ConsistencyCheckSettings.consistency_check_graph.name(), Settings.FALSE ),\n                GraphDatabaseSettings.class, ConsistencyCheckSettings.class );\n\n        // when\n        Result result = runFullConsistencyCheck( service, configuration );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.SUCCESS, result );\n    }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void run()\n        {\n            try\n            {\n                int times = 500;\n                while ( times --> 0 )\n                {\n                    config.addConfigurationChangeListener( this );\n\n                    // Edit config a bit\n                    Map<String,String> params = config.getParams();\n                    params.put( \"asd\" + rand.nextInt( 10 ),\"dsa\" + rand.nextInt( 100000 ) );\n\n                    config.applyChanges( params );\n\n                    // Unregister listener\n                    config.removeConfigurationChangeListener( this );\n                }\n            } catch(Throwable e)\n            {\n                this.failure = e;\n            }\n        }","id":77221,"modified_method":"@Override\n        public void run()\n        {\n            try\n            {\n                int times = 500;\n                while ( times --> 0 )\n                {\n                    config.addConfigurationChangeListener( this );\n\n                    // Edit config a bit\n                    config.augment( stringMap( \"asd\" + rand.nextInt( 10 ), \"dsa\" + rand.nextInt( 100000 ) ) );\n\n                    // Unregister listener\n                    config.removeConfigurationChangeListener( this );\n                }\n            } catch(Throwable e)\n            {\n                this.failure = e;\n            }\n        }","commit_id":"01801e990755c4a7a3903c25e75ec3691e6e138d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object getScope() { return _scope; }","id":77222,"modified_method":"/** @return the LogScope (private class) */\n    public Object getScope() { return _scope; }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"void addLog(Log log) {\n        synchronized (_logs) {\n            if (!_logs.containsKey(log.getScope()))\n                _logs.put(log.getScope(), log);\n        }\n        updateLimit(log);\n    }","id":77223,"modified_method":"void addLog(Log log) {\n        _logs.putIfAbsent(log.getScope(), log);\n        updateLimit(log);\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void updateLimits() {\n        Map logs = null;\n        synchronized (_logs) {\n            logs = new HashMap(_logs);\n        }\n        for (Iterator iter = logs.values().iterator(); iter.hasNext();) {\n            Log log = (Log) iter.next();\n            updateLimit(log);\n        }\n    }","id":77224,"modified_method":"private void updateLimits() {\n        for (Log log : _logs.values()) {\n            updateLimit(log);\n        }\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Return a mapping of the explicit overrides - path prefix to (text \n     * formatted) limit.\n     *\n     */\n    public Properties getLimits() {\n        Properties rv = new Properties();\n        synchronized (_limits) {\n            for (int i = 0; i < _limits.size(); i++) {\n                LogLimit lim = (LogLimit)_limits.get(i);\n                rv.setProperty(lim.getRootName(), Log.toLevelString(lim.getLimit()));\n            }\n        }\n        return rv;\n    }","id":77225,"modified_method":"/**\n     * Return a mapping of the explicit overrides - path prefix to (text \n     * formatted) limit.\n     *\n     */\n    public Properties getLimits() {\n        Properties rv = new Properties();\n        for (LogLimit lim : _limits) {\n            rv.setProperty(lim.getRootName(), Log.toLevelString(lim.getLimit()));\n        }\n        return rv;\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"List _removeAll() {\n        List vals = null;\n        synchronized (_records) {\n            if (_records.size() <= 0) \n                return null;\n            vals = new ArrayList(_records);\n            _records.clear();\n        }\n        return vals;\n    }","id":77226,"modified_method":"List<LogRecord> _removeAll() {\n        List<LogRecord> vals = new LinkedList();\n        _records.drainTo(vals);\n        return vals;\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private String createConfig() {\n        StringBuilder buf = new StringBuilder(8*1024);\n        buf.append(PROP_FORMAT).append('=').append(new String(_format)).append('\\n');\n        buf.append(PROP_DATEFORMAT).append('=').append(_dateFormatPattern).append('\\n');\n        buf.append(PROP_DISPLAYONSCREEN).append('=').append((_displayOnScreen ? \"TRUE\" : \"FALSE\")).append('\\n');\n        String filenameOverride = _context.getProperty(FILENAME_OVERRIDE_PROP);\n        if (filenameOverride == null)\n            buf.append(PROP_FILENAME).append('=').append(_baseLogfilename).append('\\n');\n        else // this isn't technically correct - this could mess with some funky scenarios\n            buf.append(PROP_FILENAME).append('=').append(DEFAULT_FILENAME).append('\\n');\n        \n        if (_fileSize >= 1024*1024)\n            buf.append(PROP_FILESIZE).append('=').append( (_fileSize / (1024*1024))).append(\"m\\n\");\n        else if (_fileSize >= 1024)\n            buf.append(PROP_FILESIZE).append('=').append( (_fileSize / (1024))).append(\"k\\n\");\n        else if (_fileSize > 0)\n            buf.append(PROP_FILESIZE).append('=').append(_fileSize).append('\\n');\n        // if <= 0, dont specify\n        \n        buf.append(PROP_ROTATIONLIMIT).append('=').append(_rotationLimit).append('\\n');\n        buf.append(PROP_DEFAULTLEVEL).append('=').append(Log.toLevelString(_defaultLimit)).append('\\n');\n        buf.append(PROP_DISPLAYONSCREENLEVEL).append('=').append(Log.toLevelString(_onScreenLimit)).append('\\n');\n        buf.append(PROP_CONSOLEBUFFERSIZE).append('=').append(_consoleBufferSize).append('\\n');\n\n        buf.append(\"# log limit overrides:\\n\");\n        \n        TreeMap limits = new TreeMap();\n        synchronized (_limits) {\n            for (int i = 0; i < _limits.size(); i++) {\n                LogLimit lim = (LogLimit)_limits.get(i);\n                limits.put(lim.getRootName(), Log.toLevelString(lim.getLimit()));\n            }\n        }\n        for (Iterator iter = limits.entrySet().iterator(); iter.hasNext(); ) {\n            Map.Entry entry = (Map.Entry)iter.next();\n            String path = (String)entry.getKey();\n            String lim = (String)entry.getValue();\n            buf.append(PROP_RECORD_PREFIX).append(path);\n            buf.append('=').append(lim).append('\\n');\n        }\n        \n        return buf.toString();\n    }","id":77227,"modified_method":"private String createConfig() {\n        StringBuilder buf = new StringBuilder(8*1024);\n        buf.append(PROP_FORMAT).append('=').append(new String(_format)).append('\\n');\n        buf.append(PROP_DATEFORMAT).append('=').append(_dateFormatPattern).append('\\n');\n        buf.append(PROP_DISPLAYONSCREEN).append('=').append((_displayOnScreen ? \"TRUE\" : \"FALSE\")).append('\\n');\n        String filenameOverride = _context.getProperty(FILENAME_OVERRIDE_PROP);\n        if (filenameOverride == null)\n            buf.append(PROP_FILENAME).append('=').append(_baseLogfilename).append('\\n');\n        else // this isn't technically correct - this could mess with some funky scenarios\n            buf.append(PROP_FILENAME).append('=').append(DEFAULT_FILENAME).append('\\n');\n        \n        if (_fileSize >= 1024*1024)\n            buf.append(PROP_FILESIZE).append('=').append( (_fileSize / (1024*1024))).append(\"m\\n\");\n        else if (_fileSize >= 1024)\n            buf.append(PROP_FILESIZE).append('=').append( (_fileSize / (1024))).append(\"k\\n\");\n        else if (_fileSize > 0)\n            buf.append(PROP_FILESIZE).append('=').append(_fileSize).append('\\n');\n        // if <= 0, dont specify\n        \n        buf.append(PROP_ROTATIONLIMIT).append('=').append(_rotationLimit).append('\\n');\n        buf.append(PROP_DEFAULTLEVEL).append('=').append(Log.toLevelString(_defaultLimit)).append('\\n');\n        buf.append(PROP_DISPLAYONSCREENLEVEL).append('=').append(Log.toLevelString(_onScreenLimit)).append('\\n');\n        buf.append(PROP_CONSOLEBUFFERSIZE).append('=').append(_consoleBufferSize).append('\\n');\n\n        buf.append(\"# log limit overrides:\\n\");\n        \n        TreeMap limits = new TreeMap();\n        for (LogLimit lim : _limits) {\n            limits.put(lim.getRootName(), Log.toLevelString(lim.getLimit()));\n        }\n        for (Iterator iter = limits.entrySet().iterator(); iter.hasNext(); ) {\n            Map.Entry entry = (Map.Entry)iter.next();\n            String path = (String)entry.getKey();\n            String lim = (String)entry.getValue();\n            buf.append(PROP_RECORD_PREFIX).append(path);\n            buf.append('=').append(lim).append('\\n');\n        }\n        \n        return buf.toString();\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Log getLog(Class cls, String name) {\n        Log rv = null;\n        String scope = Log.getScope(name, cls);\n        boolean isNew = false;\n        synchronized (_logs) {\n            rv = (Log)_logs.get(scope);\n            if (rv == null) {\n                rv = new Log(this, cls, name);\n                _logs.put(scope, rv);\n                isNew = true;\n            }\n        }\n        if (isNew)\n            updateLimit(rv);\n        return rv;\n    }","id":77228,"modified_method":"public Log getLog(Class cls, String name) {\n        String scope = Log.getScope(name, cls);\n        boolean isNew = false;\n        Log rv = _logs.get(scope);\n        if (rv == null) {\n            rv = new Log(this, cls, name);\n            _logs.putIfAbsent(scope, rv);\n            isNew = true;\n        }\n        if (isNew)\n            updateLimit(rv);\n        return rv;\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Used by Log to add records to the queue\n     *\n     */\n    void addRecord(LogRecord record) {\n        int numRecords = 0;\n        synchronized (_records) {\n            _records.add(record);\n            numRecords = _records.size();\n        }\n        \n        if (numRecords > 100) {\n            // the writer waits 10 seconds *or* until we tell them to wake up\n            // before rereading the config and writing out any log messages\n            synchronized (_writer) {\n                _writer.notifyAll();\n            }\n        }\n    }","id":77229,"modified_method":"/**\n     * Used by Log to add records to the queue\n     *\n     */\n    void addRecord(LogRecord record) {\n        _records.offer(record);\n        int numRecords = _records.size();\n        \n        if (numRecords > 100) {\n            // the writer waits 10 seconds *or* until we tell them to wake up\n            // before rereading the config and writing out any log messages\n            synchronized (_writer) {\n                _writer.notifyAll();\n            }\n        }\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public List getLogs() {\n        List rv = null;\n        synchronized (_logs) {\n            rv = new ArrayList(_logs.values());\n        }\n        return rv;\n    }","id":77230,"modified_method":"/** @deprecated unused */\n    public List<Log> getLogs() {\n        return new ArrayList(_logs.values());\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public LogManager(I2PAppContext context) {\n        _displayOnScreen = true;\n        _alreadyNoticedMissingConfig = false;\n        _records = new ArrayList();\n        _limits = new ArrayList(128);\n        _logs = new HashMap(128);\n        _defaultLimit = Log.ERROR;\n        _configLastRead = 0;\n        _context = context;\n        _log = getLog(LogManager.class);\n        String location = context.getProperty(CONFIG_LOCATION_PROP, CONFIG_LOCATION_DEFAULT);\n        setConfig(location);\n        _consoleBuffer = new LogConsoleBuffer(context);\n        _writer = new LogWriter(this);\n        Thread t = new I2PThread(_writer);\n        t.setName(\"LogWriter\");\n        t.setDaemon(true);\n        t.start();\n        try {\n            Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n        } catch (IllegalStateException ise) {\n            // shutdown in progress, fsck it\n        }\n        //System.out.println(\"Created logManager \" + this + \" with context: \" + context);\n    }","id":77231,"modified_method":"public LogManager(I2PAppContext context) {\n        _displayOnScreen = true;\n        _alreadyNoticedMissingConfig = false;\n        _records = new LinkedBlockingQueue();\n        _limits = new ConcurrentHashSet();\n        _logs = new ConcurrentHashMap(128);\n        _defaultLimit = Log.ERROR;\n        _configLastRead = 0;\n        _context = context;\n        _log = getLog(LogManager.class);\n        String location = context.getProperty(CONFIG_LOCATION_PROP, CONFIG_LOCATION_DEFAULT);\n        setConfig(location);\n        _consoleBuffer = new LogConsoleBuffer(context);\n        _writer = new LogWriter(this);\n        Thread t = new I2PThread(_writer);\n        t.setName(\"LogWriter\");\n        t.setDaemon(true);\n        t.start();\n        try {\n            Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n        } catch (IllegalStateException ise) {\n            // shutdown in progress, fsck it\n        }\n        //System.out.println(\"Created logManager \" + this + \" with context: \" + context);\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void updateLimit(Log log) {\n        List limits = getLimits(log);\n        LogLimit max = null;\n        LogLimit notMax = null;\n        if (limits != null) {\n            for (int i = 0; i < limits.size(); i++) {\n                LogLimit cur = (LogLimit) limits.get(i);\n                if (max == null)\n                    max = cur;\n                else {\n                    if (cur.getRootName().length() > max.getRootName().length()) {\n                        notMax = max;\n                        max = cur;\n                    }\n                }\n            }\n        }\n        if (max != null) {\n            log.setMinimumPriority(max.getLimit());\n        } else {\n            //if (_log != null)\n            //    _log.debug(\"The log for \" + log.getClass() + \" has no matching limits\");\n            log.setMinimumPriority(_defaultLimit);\n        }\n    }","id":77232,"modified_method":"private void updateLimit(Log log) {\n        List<LogLimit> limits = getLimits(log);\n        LogLimit max = null;\n        LogLimit notMax = null;\n        if (limits != null) {\n            for (LogLimit cur : limits) {\n                if (max == null)\n                    max = cur;\n                else {\n                    if (cur.getRootName().length() > max.getRootName().length()) {\n                        notMax = max;\n                        max = cur;\n                    }\n                }\n            }\n        }\n        if (max != null) {\n            log.setMinimumPriority(max.getLimit());\n        } else {\n            //if (_log != null)\n            //    _log.debug(\"The log for \" + log.getClass() + \" has no matching limits\");\n            log.setMinimumPriority(_defaultLimit);\n        }\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void parseLimits(Properties config, String recordPrefix) {\n        synchronized (_limits) {\n            _limits.clear();\n        }\n        if (config != null) {\n            for (Iterator iter = config.keySet().iterator(); iter.hasNext();) {\n                String key = (String) iter.next();\n                String val = config.getProperty(key);\n\n                // if we're filtering the records (e.g. logger.record.*) then\n                // filter accordingly (stripping off that prefix for matches)\n                if (recordPrefix != null) {\n                    if (key.startsWith(recordPrefix)) {\n                        key = key.substring(recordPrefix.length());\n                    } else {\n                        continue;\n                    }\n                }\n\n                LogLimit lim = new LogLimit(key, Log.getLevel(val));\n                //_log.debug(\"Limit found for \" + name + \" as \" + val);\n                synchronized (_limits) {\n                    if (!_limits.contains(lim))\n                        _limits.add(lim);\n                }\n            }\n        }\n        updateLimits();\n    }","id":77233,"modified_method":"private void parseLimits(Properties config, String recordPrefix) {\n        _limits.clear();\n        if (config != null) {\n            for (Iterator iter = config.keySet().iterator(); iter.hasNext();) {\n                String key = (String) iter.next();\n                String val = config.getProperty(key);\n\n                // if we're filtering the records (e.g. logger.record.*) then\n                // filter accordingly (stripping off that prefix for matches)\n                if (recordPrefix != null) {\n                    if (key.startsWith(recordPrefix)) {\n                        key = key.substring(recordPrefix.length());\n                    } else {\n                        continue;\n                    }\n                }\n\n                LogLimit lim = new LogLimit(key, Log.getLevel(val));\n                //_log.debug(\"Limit found for \" + name + \" as \" + val);\n                if (!_limits.contains(lim))\n                    _limits.add(lim);\n            }\n        }\n        updateLimits();\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private List getLimits(Log log) {\n        ArrayList limits = null; // new ArrayList(4);\n        synchronized (_limits) {\n            for (int i = 0; i < _limits.size(); i++) {\n                LogLimit limit = (LogLimit)_limits.get(i);\n                if (limit.matches(log)) { \n                    if (limits == null)\n                        limits = new ArrayList(4);\n                    limits.add(limit);\n                }\n            }\n        }\n        return limits;\n    }","id":77234,"modified_method":"/** @return null if no matches */\n    private List<LogLimit> getLimits(Log log) {\n        ArrayList<LogLimit> limits = null; // new ArrayList(4);\n        for (LogLimit limit : _limits) {\n            if (limit.matches(log)) { \n                if (limits == null)\n                    limits = new ArrayList(4);\n                limits.add(limit);\n            }\n        }\n        return limits;\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void flushRecords(boolean shouldWait) {\n        try {\n            List records = _manager._removeAll();\n            if (records == null) return;\n            for (int i = 0; i < records.size(); i++) {\n                LogRecord rec = (LogRecord) records.get(i);\n                writeRecord(rec);\n            }\n            if (records.size() > 0) {\n                try {\n                    _currentOut.flush();\n                } catch (IOException ioe) {\n                    System.err.println(\"Error flushing the records\");\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            if (shouldWait) {\n                try { \n                    synchronized (this) {\n                        this.wait(10*1000); \n                    }\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n        }\n    }","id":77235,"modified_method":"public void flushRecords(boolean shouldWait) {\n        try {\n            List<LogRecord> records = _manager._removeAll();\n            if (records == null) return;\n            for (LogRecord rec : records) {\n                writeRecord(rec);\n            }\n            if (!records.isEmpty()) {\n                try {\n                    _currentOut.flush();\n                } catch (IOException ioe) {\n                    System.err.println(\"Error flushing the records\");\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            if (shouldWait) {\n                try { \n                    synchronized (this) {\n                        this.wait(10*1000); \n                    }\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n        }\n    }","commit_id":"0f502b422928bf2e05400fd52d13304afcd2a946","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void checkCallable(@NotNull PyElement node, @Nullable PyExpression callee, @Nullable PyType type) {\n      final Boolean callable = callee != null ? isCallable(callee, myTypeEvalContext) : PyTypeChecker.isCallable(type);\n      if (callable == null) {\n        return;\n      }\n      if (!callable) {\n        final PyType calleeType = callee != null ? myTypeEvalContext.getType(callee) : type;\n        if (calleeType instanceof PyClassType) {\n          registerProblem(node, String.format(\"'%s' object is not callable\", calleeType.getName()), new PyRemoveCallQuickFix());\n        }\n        else if (callee != null) {\n          registerProblem(node, String.format(\"'%s' is not callable\", callee.getName()), new PyRemoveCallQuickFix());\n        }\n        else {\n          registerProblem(node, \"Expression is not callable\", new PyRemoveCallQuickFix());\n        }\n      }\n    }","id":77236,"modified_method":"private void checkCallable(@NotNull PyElement node, @Nullable PyExpression callee, @Nullable PyType type) {\n      final Boolean callable = callee != null ? isCallable(callee, myTypeEvalContext) : PyTypeChecker.isCallable(type);\n      if (callable == null) {\n        return;\n      }\n      if (!callable) {\n        final PyType calleeType = callee != null ? myTypeEvalContext.getType(callee) : type;\n        String message = \"Expression is not callable\";\n        if (calleeType instanceof PyClassType) {\n          message = String.format(\"'%s' object is not callable\", calleeType.getName());\n        }\n        else if (callee != null) {\n          final String name = callee.getName();\n          if (name != null) {\n            message = String.format(\"'%s' is not callable\", name);\n          }\n        }\n        registerProblem(node, message, new PyRemoveCallQuickFix());\n      }\n    }","commit_id":"a5987d93dd8ebaaf9fee5d4fa2e010e5cc21a5a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Utility method to obtain annotations of a specific type from the supplied PsiModifierListOwner.\n   * For optimization reasons, this method only looks at elements of type java.lang.String.\n   * <p/>\n   * The parameter <code>allowIndirect<\/code> determines if the method should look for indirect annotations, i.e.\n   * annotations which have themselves been annotated by the supplied annotation name. Currently, this only allows\n   * one level of indirection and returns an array of [base-annotation, indirect annotation]\n   * <p/>\n   * The <code>annotationName<\/code> parameter is a pair of the target annotation class' fully qualified name as a\n   * String and as a Set. This is done for performance reasons because the Set is required by the\n   * {@link com.intellij.codeInsight.AnnotationUtil} utility class and allows to avoid unecessary object constructions.\n   */\n  @NotNull\n  public static PsiAnnotation[] getAnnotationFrom(PsiModifierListOwner owner,\n                                                  Pair<String, ? extends Set<String>> annotationName,\n                                                  boolean allowIndirect,\n                                                  boolean inHierarchy) {\n    if (owner instanceof PsiMethod) {\n      final PsiType returnType = ((PsiMethod)owner).getReturnType();\n      if (returnType == null || !PsiUtilEx.isStringOrStringArray(returnType)) {\n        return PsiAnnotation.EMPTY_ARRAY;\n      }\n    }\n    else if (owner instanceof PsiVariable) {\n      final PsiType type = ((PsiVariable)owner).getType();\n      if (!PsiUtilEx.isStringOrStringArray(type)) {\n        return PsiAnnotation.EMPTY_ARRAY;\n      }\n    }\n    else {\n      return PsiAnnotation.EMPTY_ARRAY;\n    }\n\n    if (AnnotationUtil.isAnnotated(owner, annotationName.first, inHierarchy)) {\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotationInHierarchy(owner, annotationName.second);\n      assert annotation != null;\n\n      return new PsiAnnotation[]{annotation};\n    }\n    else if (allowIndirect) {\n      final PsiAnnotation[] annotations = getAnnotations(owner, inHierarchy);\n      for (PsiAnnotation annotation : annotations) {\n        final String fqn = annotation.getQualifiedName();\n        if (fqn == null) {\n          continue;\n        }\n        final PsiClass psiClass = JavaPsiFacade.getInstance(owner.getProject()).findClass(fqn, annotation.getResolveScope());\n        if (psiClass != null) {\n          final PsiAnnotation psiAnnotation = AnnotationUtil.findAnnotationInHierarchy(psiClass, annotationName.second);\n          if (psiAnnotation != null) {\n            return new PsiAnnotation[]{psiAnnotation, annotation};\n          }\n        }\n      }\n    }\n    return PsiAnnotation.EMPTY_ARRAY;\n  }","id":77237,"modified_method":"/**\n   * Utility method to obtain annotations of a specific type from the supplied PsiModifierListOwner.\n   * For optimization reasons, this method only looks at elements of type java.lang.String.\n   * <p/>\n   * The parameter <code>allowIndirect<\/code> determines if the method should look for indirect annotations, i.e.\n   * annotations which have themselves been annotated by the supplied annotation name. Currently, this only allows\n   * one level of indirection and returns an array of [base-annotation, indirect annotation]\n   * <p/>\n   * The <code>annotationName<\/code> parameter is a pair of the target annotation class' fully qualified name as a\n   * String and as a Set. This is done for performance reasons because the Set is required by the\n   * {@link com.intellij.codeInsight.AnnotationUtil} utility class and allows to avoid unecessary object constructions.\n   */\n  @NotNull\n  public static PsiAnnotation[] getAnnotationFrom(PsiModifierListOwner owner,\n                                                  Pair<String, ? extends Set<String>> annotationName,\n                                                  boolean allowIndirect,\n                                                  boolean inHierarchy) {\n    if (owner instanceof PsiMethod) {\n      final PsiType returnType = ((PsiMethod)owner).getReturnType();\n      if (returnType == null || !PsiUtilEx.isStringOrStringArray(returnType)) {\n        return PsiAnnotation.EMPTY_ARRAY;\n      }\n    }\n    else if (owner instanceof PsiVariable) {\n      final PsiType type = ((PsiVariable)owner).getType();\n      if (!PsiUtilEx.isStringOrStringArray(type)) {\n        return PsiAnnotation.EMPTY_ARRAY;\n      }\n    }\n    else {\n      return PsiAnnotation.EMPTY_ARRAY;\n    }\n\n    if (AnnotationUtil.isAnnotated(owner, annotationName.first, inHierarchy)) {\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotationInHierarchy(owner, annotationName.second);\n      assert annotation != null;\n\n      return new PsiAnnotation[]{annotation};\n    }\n    if (allowIndirect) {\n      final PsiAnnotation[] annotations = getAnnotations(owner, inHierarchy);\n      for (PsiAnnotation annotation : annotations) {\n        PsiJavaCodeReferenceElement nameReference = annotation.getNameReferenceElement();\n        if (nameReference == null) continue;\n        PsiElement resolved = nameReference.resolve();\n        if (resolved instanceof PsiClass) {\n          final PsiAnnotation psiAnnotation = AnnotationUtil.findAnnotationInHierarchy((PsiModifierListOwner)resolved, annotationName.second);\n          if (psiAnnotation != null) {\n            return new PsiAnnotation[]{psiAnnotation, annotation};\n          }\n        }\n      }\n    }\n    return PsiAnnotation.EMPTY_ARRAY;\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String calcAnnotationValue(@NotNull PsiAnnotation annotation, @NonNls String attr) {\n    PsiElement value = annotation.findAttributeValue(attr);\n    final Object o;\n    if (value instanceof ClsLiteralExpressionImpl) {\n      final ClsLiteralExpressionImpl expr = ((ClsLiteralExpressionImpl)value);\n      if (expr.getValue() == null) {\n        // This happens when the expression isn't a simple literal but e.g. a concatenated string and the\n        // string contains characters that must be escaped: \"A\" + \"\\\\w\" + \"B\" -> \"A\\wB\" which isn't a legal\n        // string literal any more -> value == null (IDEA-10001)\n        try {\n          final String s = expr.getText();\n          if (s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) {\n            final String e = \"\\\"\" + StringUtil.escapeStringCharacters(s.substring(1, s.length() - 1)) + \"\\\"\";\n            value = JavaPsiFacade.getInstance(annotation.getProject()).getElementFactory().createExpressionFromText(e, annotation);\n          }\n        }\n        catch (IncorrectOperationException e) {\n          Logger.getInstance(AnnotationUtilEx.class.getName()).error(e);\n        }\n      }\n    }\n    if (value instanceof PsiExpression) {\n      o = CONSTANT_EVALUATION_HELPER.computeConstantExpression((PsiExpression)value);\n    }\n    else {\n      return null;\n    }\n    if (o instanceof String) {\n      return (String)o;\n    }\n    return null;\n  }","id":77238,"modified_method":"@Nullable\n  public static String calcAnnotationValue(@NotNull PsiAnnotation annotation, @NonNls String attr) {\n    PsiElement value = annotation.findAttributeValue(attr);\n    if (value instanceof PsiExpression) {\n      Object o = CONSTANT_EVALUATION_HELPER.computeConstantExpression((PsiExpression)value);\n      if (o instanceof String) {\n        return (String)o;\n      }\n    }\n    return null;\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Determines the PsiModifierListOwner for the passed element depending of the specified LookupType. The LookupType\n   * decides whether to prefer the element a reference expressions resolves to, or the element that is implied by the\n   * usage context (\"expected type\").\n   */\n  @Nullable\n  public static PsiModifierListOwner getAnnotatedElementFor(@Nullable PsiExpression element, LookupType type) {\n    if (element == null) return null;\n\n    if (type == LookupType.PREFER_DECLARATION || type == LookupType.DECLRARATION_ONLY) {\n      if (element instanceof PsiReferenceExpression) {\n        final PsiElement e = ((PsiReferenceExpression)element).resolve();\n        if (e instanceof PsiModifierListOwner) {\n          return (PsiModifierListOwner)e;\n        }\n        if (type == LookupType.DECLRARATION_ONLY) {\n          return null;\n        }\n      }\n    }\n\n    final PsiElement parent = element.getParent();\n\n    if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression p = ((PsiAssignmentExpression)parent);\n      if (p.getRExpression() == element) {\n        return getAnnotatedElementFor(p.getLExpression(), type);\n      }\n    }\n    else if (parent instanceof PsiExpression) {\n      return getAnnotatedElementFor((PsiExpression)parent, type);\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      final PsiMethod m = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (m != null) {\n        return m;\n      }\n    }\n    else if (parent instanceof PsiModifierListOwner) {\n      return (PsiModifierListOwner)parent;\n    }\n    else if (parent instanceof PsiArrayInitializerMemberValue) {\n      final PsiArrayInitializerMemberValue value = (PsiArrayInitializerMemberValue)parent;\n      final PsiElement pair = value.getParent();\n      if (pair instanceof PsiNameValuePair) {\n        return getAnnotationMethod(((PsiNameValuePair)pair), element);\n      }\n    }\n    else if (parent instanceof PsiNameValuePair) {\n      return getAnnotationMethod(((PsiNameValuePair)parent), element);\n    }\n    else {\n      return PsiUtilEx.getParameterForArgument(element);\n    }\n\n    // If no annotation has been found through the usage context, check if the element\n    // (i.e. the element the reference refers to) is annotated itself\n    if (type != LookupType.DECLRARATION_ONLY) {\n      if (element instanceof PsiReferenceExpression) {\n        final PsiElement e = ((PsiReferenceExpression)element).resolve();\n        if (e instanceof PsiModifierListOwner) {\n          return (PsiModifierListOwner)e;\n        }\n      }\n    }\n\n    return null;\n  }","id":77239,"modified_method":"/**\n   * Determines the PsiModifierListOwner for the passed element depending of the specified LookupType. The LookupType\n   * decides whether to prefer the element a reference expressions resolves to, or the element that is implied by the\n   * usage context (\"expected type\").\n   */\n  @Nullable\n  public static PsiModifierListOwner getAnnotatedElementFor(@Nullable PsiExpression element, LookupType type) {\n    if (element == null) return null;\n\n    if (type == LookupType.PREFER_DECLARATION || type == LookupType.DECLRARATION_ONLY) {\n      if (element instanceof PsiReferenceExpression) {\n        final PsiElement e = ((PsiReferenceExpression)element).resolve();\n        if (e instanceof PsiModifierListOwner) {\n          return (PsiModifierListOwner)e;\n        }\n        if (type == LookupType.DECLRARATION_ONLY) {\n          return null;\n        }\n      }\n    }\n\n    final PsiElement parent = element.getParent();\n\n    if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression p = (PsiAssignmentExpression)parent;\n      if (p.getRExpression() == element) {\n        return getAnnotatedElementFor(p.getLExpression(), type);\n      }\n    }\n    else if (parent instanceof PsiExpression) {\n      return getAnnotatedElementFor((PsiExpression)parent, type);\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      final PsiMethod m = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (m != null) {\n        return m;\n      }\n    }\n    else if (parent instanceof PsiModifierListOwner) {\n      return (PsiModifierListOwner)parent;\n    }\n    else if (parent instanceof PsiArrayInitializerMemberValue) {\n      final PsiArrayInitializerMemberValue value = (PsiArrayInitializerMemberValue)parent;\n      final PsiElement pair = value.getParent();\n      if (pair instanceof PsiNameValuePair) {\n        return getAnnotationMethod((PsiNameValuePair)pair, element);\n      }\n    }\n    else if (parent instanceof PsiNameValuePair) {\n      return getAnnotationMethod((PsiNameValuePair)parent, element);\n    }\n    else {\n      return PsiUtilEx.getParameterForArgument(element);\n    }\n\n    // If no annotation has been found through the usage context, check if the element\n    // (i.e. the element the reference refers to) is annotated itself\n    if (type != LookupType.DECLRARATION_ONLY) {\n      if (element instanceof PsiReferenceExpression) {\n        final PsiElement e = ((PsiReferenceExpression)element).resolve();\n        if (e instanceof PsiModifierListOwner) {\n          return (PsiModifierListOwner)e;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns all annotations for <code>listOwner<\/code>, possibly walking up the method hierarchy.\n   *\n   * @see com.intellij.codeInsight.AnnotationUtil#isAnnotated(com.intellij.psi.PsiModifierListOwner, java.lang.String, boolean)\n   */\n  public static PsiAnnotation[] getAnnotations(@NotNull PsiModifierListOwner listOwner, boolean inHierarchy) {\n    if (listOwner instanceof PsiParameter) {\n      // this is more efficient than getting the modifier list\n      return ((PsiParameter)listOwner).getAnnotations();\n    }\n    final PsiModifierList modifierList = listOwner.getModifierList();\n    if (modifierList == null) {\n      return PsiAnnotation.EMPTY_ARRAY;\n    }\n    if (inHierarchy && listOwner instanceof PsiMethod) {\n      final Set<PsiAnnotation> all = new HashSet<PsiAnnotation>() {\n        public boolean add(PsiAnnotation o) {\n          // don't overwrite \"higher level\" annotations\n          return !contains(o) && super.add(o);\n        }\n      };\n      all.addAll(Arrays.asList(modifierList.getAnnotations()));\n      addSuperAnnotations(all, (PsiMethod)listOwner);\n      return all.toArray(new PsiAnnotation[all.size()]);\n    }\n    else {\n      return modifierList.getAnnotations();\n    }\n  }","id":77240,"modified_method":"/**\n   * Returns all annotations for <code>listOwner<\/code>, possibly walking up the method hierarchy.\n   *\n   * @see com.intellij.codeInsight.AnnotationUtil#isAnnotated(com.intellij.psi.PsiModifierListOwner, java.lang.String, boolean)\n   */\n  private static PsiAnnotation[] getAnnotations(@NotNull PsiModifierListOwner listOwner, boolean inHierarchy) {\n    final PsiModifierList modifierList = listOwner.getModifierList();\n    if (modifierList == null) {\n      return PsiAnnotation.EMPTY_ARRAY;\n    }\n    if (inHierarchy) {\n      final Set<PsiAnnotation> all = new HashSet<PsiAnnotation>() {\n        public boolean add(PsiAnnotation o) {\n          // don't overwrite \"higher level\" annotations\n          return !contains(o) && super.add(o);\n        }\n      };\n      if (listOwner instanceof PsiMethod) {\n        all.addAll(Arrays.asList(modifierList.getAnnotations()));\n        processSuperMethods((PsiMethod)listOwner, new Processor<PsiMethod>() {\n          public boolean process(final PsiMethod superMethod) {\n            all.addAll(Arrays.asList(superMethod.getModifierList().getAnnotations()));\n            return true;\n          }\n        });\n        return all.toArray(new PsiAnnotation[all.size()]);\n      }\n      if (listOwner instanceof PsiParameter && ((PsiParameter)listOwner).getDeclarationScope() instanceof PsiMethod) {\n        PsiParameter parameter = (PsiParameter)listOwner;\n        PsiMethod method = (PsiMethod)parameter.getDeclarationScope();\n        final int parameterIndex = method.getParameterList().getParameterIndex(parameter);\n        all.addAll(Arrays.asList(modifierList.getAnnotations()));\n        processSuperMethods(method, new Processor<PsiMethod>() {\n          public boolean process(final PsiMethod superMethod) {\n            PsiParameter superParameter = superMethod.getParameterList().getParameters()[parameterIndex];\n            PsiModifierList modifierList = superParameter.getModifierList();\n            all.addAll(Arrays.asList(modifierList.getAnnotations()));\n            return true;\n          }\n        });\n        return all.toArray(new PsiAnnotation[all.size()]);\n      }\n    }\n    return modifierList.getAnnotations();\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiModifierListOwner getAnnotationMethod(PsiNameValuePair pair, PsiExpression element) {\n    final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(pair.getParent(), PsiAnnotation.class);\n    assert annotation != null;\n\n    final String fqn = annotation.getQualifiedName();\n    assert fqn != null;\n\n    final PsiClass psiClass = JavaPsiFacade.getInstance(element.getProject()).findClass(fqn, element.getResolveScope());\n    if (psiClass != null && psiClass.isAnnotationType()) {\n      final String name = pair.getName();\n      final PsiMethod[] methods = psiClass.findMethodsByName(name != null ? name : \"value\", false);\n      return methods.length > 0 ? methods[0] : null;\n    }\n    return null;\n  }","id":77241,"modified_method":"@Nullable\n  private static PsiModifierListOwner getAnnotationMethod(PsiNameValuePair pair, PsiExpression element) {\n    final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(pair.getParent(), PsiAnnotation.class);\n    assert annotation != null;\n\n    final String fqn = annotation.getQualifiedName();\n    if (fqn == null) return null;\n\n    final PsiClass psiClass = JavaPsiFacade.getInstance(element.getProject()).findClass(fqn, element.getResolveScope());\n    if (psiClass != null && psiClass.isAnnotationType()) {\n      final String name = pair.getName();\n      final PsiMethod[] methods = psiClass.findMethodsByName(name != null ? name : \"value\", false);\n      return methods.length > 0 ? methods[0] : null;\n    }\n    return null;\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void checkExpression(PsiExpression expression, final PsiAnnotation[] annotations, ProblemsHolder holder) {\n    if (annotations.length > 0) {\n      final PsiAnnotation psiAnnotation = annotations[0];\n\n      // cache compiled pattern with annotation\n      CachedValue<Pattern> p = psiAnnotation.getUserData(COMPLIED_PATTERN);\n      if (p == null) {\n        final CachedValueProvider<Pattern> provider = new CachedValueProvider<Pattern>() {\n          public Result<Pattern> compute() {\n            final String pattern = AnnotationUtilEx.calcAnnotationValue(psiAnnotation, \"value\");\n            Pattern p = null;\n            if (pattern != null) {\n              try {\n                p = Pattern.compile(pattern);\n              }\n              catch (PatternSyntaxException e) {\n                // pattern stays null\n              }\n            }\n            return Result.create(p, (Object[])annotations);\n          }\n        };\n        p = expression.getManager().getCachedValuesManager().createCachedValue(provider, false);\n        psiAnnotation.putUserData(COMPLIED_PATTERN, p);\n      }\n\n      final Pattern pattern = p.getValue();\n      if (pattern != null) {\n        final SmartList<PsiExpression> nonConstantElements = new SmartList<PsiExpression>();\n        final String o = SubstitutedExpressionEvaluationHelper.computeExpression(expression, nonConstantElements);\n\n        if (o != null) {\n          if (!pattern.matcher(o).matches()) {\n            if (annotations.length > 1) {\n              // the last element contains the element's actual annotation\n              final String fqn = annotations[annotations.length - 1].getQualifiedName();\n              assert fqn != null;\n\n              final String name = StringUtil.getShortName(fqn);\n              holder.registerProblem(expression, MessageFormat.format(\"Expression ''{0}'' doesn''t match ''{1}'' pattern: {2}\", o, name,\n                                                                      pattern.pattern()));\n            }\n            else {\n              holder.registerProblem(expression,\n                                     MessageFormat.format(\"Expression ''{0}'' doesn''t match pattern: {1}\", o, pattern.pattern()));\n            }\n          }\n        }\n        else if (CHECK_NON_CONSTANT_VALUES) {\n          for (PsiExpression expr : nonConstantElements) {\n            final PsiElement e;\n            if (expr instanceof PsiReferenceExpression) {\n              e = ((PsiReferenceExpression)expr).resolve();\n            }\n            else if (expr instanceof PsiMethodCallExpression) {\n              e = ((PsiMethodCallExpression)expr).getMethodExpression().resolve();\n            }\n            else {\n              e = expr;\n            }\n\n            if (e instanceof PsiModifierListOwner) {\n              final String classname = Configuration.getInstance().getSubstAnnotationPair().first;\n              final AnnotateFix fix = new AnnotateFix((PsiModifierListOwner)e, classname);\n              if (fix.canApply()) {\n                holder.registerProblem(expr, \"Unsubstituted expression\", fix);\n              }\n              else {\n                holder.registerProblem(expr, \"Unsubstituted expression\", new IntroduceVariableFix(expr));\n              }\n            }\n            else {\n              holder.registerProblem(expr, \"Unsubstituted expression\", new IntroduceVariableFix(expr));\n            }\n          }\n        }\n      }\n    }\n  }","id":77242,"modified_method":"private void checkExpression(PsiExpression expression, final PsiAnnotation[] annotations, ProblemsHolder holder) {\n    if (annotations.length == 0) return;\n    final PsiAnnotation psiAnnotation = annotations[0];\n\n    // cache compiled pattern with annotation\n    CachedValue<Pattern> p = psiAnnotation.getUserData(COMPLIED_PATTERN);\n    if (p == null) {\n      final CachedValueProvider<Pattern> provider = new CachedValueProvider<Pattern>() {\n        public Result<Pattern> compute() {\n          final String pattern = AnnotationUtilEx.calcAnnotationValue(psiAnnotation, \"value\");\n          Pattern p = null;\n          if (pattern != null) {\n            try {\n              p = Pattern.compile(pattern);\n            }\n            catch (PatternSyntaxException e) {\n              // pattern stays null\n            }\n          }\n          return Result.create(p, (Object[])annotations);\n        }\n      };\n      p = expression.getManager().getCachedValuesManager().createCachedValue(provider, false);\n      psiAnnotation.putUserData(COMPLIED_PATTERN, p);\n    }\n\n    final Pattern pattern = p.getValue();\n    if (pattern == null) return;\n\n    List<PsiExpression> nonConstantElements = new SmartList<PsiExpression>();\n    String o = SubstitutedExpressionEvaluationHelper.computeExpression(expression, nonConstantElements);\n    if (o != null) {\n      if (!pattern.matcher(o).matches()) {\n        if (annotations.length > 1) {\n          // the last element contains the element's actual annotation\n          final String fqn = annotations[annotations.length - 1].getQualifiedName();\n          assert fqn != null;\n\n          final String name = StringUtil.getShortName(fqn);\n          holder.registerProblem(expression, MessageFormat.format(\"Expression ''{0}'' doesn''t match ''{1}'' pattern: {2}\", o, name,\n                                                                  pattern.pattern()));\n        }\n        else {\n          holder.registerProblem(expression,\n                                 MessageFormat.format(\"Expression ''{0}'' doesn''t match pattern: {1}\", o, pattern.pattern()));\n        }\n      }\n    }\n    else if (CHECK_NON_CONSTANT_VALUES) {\n      for (PsiExpression expr : nonConstantElements) {\n        final PsiElement e;\n        if (expr instanceof PsiReferenceExpression) {\n          e = ((PsiReferenceExpression)expr).resolve();\n        }\n        else if (expr instanceof PsiMethodCallExpression) {\n          e = ((PsiMethodCallExpression)expr).getMethodExpression().resolve();\n        }\n        else {\n          e = expr;\n        }\n\n        LocalQuickFix quickFix;\n        if (e instanceof PsiModifierListOwner) {\n          PsiAnnotation[] resolvedAnnos = AnnotationUtilEx.getAnnotationFrom((PsiModifierListOwner)e, myConfiguration.getPatternAnnotationPair(), true);\n          if (resolvedAnnos.length == 2 && annotations.length == 2 && Comparing.strEqual(resolvedAnnos[1].getQualifiedName(), annotations[1].getQualifiedName())) {\n            // both target and source annotated indirectly with the same anno\n            return;\n          }\n\n          final String classname = Configuration.getInstance().getSubstAnnotationPair().first;\n          final AnnotateFix fix = new AnnotateFix((PsiModifierListOwner)e, classname);\n          quickFix = fix.canApply() ? fix : new IntroduceVariableFix(expr);\n        }\n        else {\n          quickFix = new IntroduceVariableFix(expr);\n        }\n        holder.registerProblem(expr, \"Unsubstituted expression\", quickFix);\n      }\n    }\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    return new JavaElementVisitor() {\n\n      public final void visitReferenceExpression(PsiReferenceExpression expression) {\n        visitExpression(expression);\n      }\n\n      @Override\n      public void visitExpression(PsiExpression expression) {\n        final PsiElement element = expression.getParent();\n        if (element instanceof PsiExpressionList) {\n          // this checks method arguments\n          check(expression, holder, false);\n        }\n        else if (element instanceof PsiNameValuePair) {\n          final PsiNameValuePair valuePair = (PsiNameValuePair)element;\n          final String name = valuePair.getName();\n          if (name == null || name.equals(PsiAnnotation.DEFAULT_REFERENCED_METHOD_NAME)) {\n            // check whether @Subst complies with pattern\n            check(expression, holder, true);\n          }\n        }\n      }\n\n      @Override\n      public void visitReturnStatement(PsiReturnStatement statement) {\n        final PsiExpression returnValue = statement.getReturnValue();\n        if (returnValue != null) {\n          check(returnValue, holder, false);\n        }\n      }\n\n      @Override\n      public void visitVariable(PsiVariable var) {\n        final PsiExpression initializer = var.getInitializer();\n        if (initializer != null) {\n          // variable/field initializer\n          check(initializer, holder, false);\n        }\n      }\n\n      @Override\n      public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n        final PsiExpression e = expression.getRExpression();\n        if (e != null) {\n          check(e, holder, false);\n        }\n        visitExpression(expression);\n      }\n\n      private void check(@NotNull PsiExpression expression, ProblemsHolder holder, boolean isAnnotationValue) {\n        if (expression instanceof PsiConditionalExpression) {\n          final PsiConditionalExpression expr = ((PsiConditionalExpression)expression);\n          PsiExpression e = expr.getThenExpression();\n          if (e != null) {\n            check(e, holder, isAnnotationValue);\n          }\n          e = expr.getElseExpression();\n          if (e != null) {\n            check(e, holder, isAnnotationValue);\n          }\n        }\n        else {\n          final PsiType type = expression.getType();\n          // optimiziation: only check expressions of type String\n          if (type != null && PsiUtilEx.isString(type)) {\n            final PsiModifierListOwner element;\n            if (isAnnotationValue) {\n              final PsiAnnotation psiAnnotation = PsiTreeUtil.getParentOfType(expression, PsiAnnotation.class);\n              if (psiAnnotation != null && myConfiguration.getSubstAnnotationClass().equals(psiAnnotation.getQualifiedName())) {\n                element = PsiTreeUtil.getParentOfType(expression, PsiModifierListOwner.class);\n              }\n              else {\n                return;\n              }\n            }\n            else {\n              element = AnnotationUtilEx.getAnnotatedElementFor(expression, AnnotationUtilEx.LookupType.PREFER_CONTEXT);\n            }\n            if (element != null) {\n              final PsiAnnotation[] annotations =\n                  AnnotationUtilEx.getAnnotationFrom(element, myConfiguration.getPatternAnnotationPair(), true);\n              checkExpression(expression, annotations, holder);\n            }\n          }\n        }\n      }\n    };\n  }","id":77243,"modified_method":"@NotNull\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    return new JavaElementVisitor() {\n\n      public final void visitReferenceExpression(PsiReferenceExpression expression) {\n        visitExpression(expression);\n      }\n\n      @Override\n      public void visitExpression(PsiExpression expression) {\n        final PsiElement element = expression.getParent();\n        if (element instanceof PsiExpressionList) {\n          // this checks method arguments\n          check(expression, holder, false);\n        }\n        else if (element instanceof PsiNameValuePair) {\n          final PsiNameValuePair valuePair = (PsiNameValuePair)element;\n          final String name = valuePair.getName();\n          if (name == null || name.equals(PsiAnnotation.DEFAULT_REFERENCED_METHOD_NAME)) {\n            // check whether @Subst complies with pattern\n            check(expression, holder, true);\n          }\n        }\n      }\n\n      @Override\n      public void visitReturnStatement(PsiReturnStatement statement) {\n        final PsiExpression returnValue = statement.getReturnValue();\n        if (returnValue != null) {\n          check(returnValue, holder, false);\n        }\n      }\n\n      @Override\n      public void visitVariable(PsiVariable var) {\n        final PsiExpression initializer = var.getInitializer();\n        if (initializer != null) {\n          // variable/field initializer\n          check(initializer, holder, false);\n        }\n      }\n\n      @Override\n      public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n        final PsiExpression e = expression.getRExpression();\n        if (e != null) {\n          check(e, holder, false);\n        }\n        visitExpression(expression);\n      }\n\n      private void check(@NotNull PsiExpression expression, ProblemsHolder holder, boolean isAnnotationValue) {\n        if (expression instanceof PsiConditionalExpression) {\n          final PsiConditionalExpression expr = (PsiConditionalExpression)expression;\n          PsiExpression e = expr.getThenExpression();\n          if (e != null) {\n            check(e, holder, isAnnotationValue);\n          }\n          e = expr.getElseExpression();\n          if (e != null) {\n            check(e, holder, isAnnotationValue);\n          }\n        }\n        else {\n          final PsiType type = expression.getType();\n          // optimiziation: only check expressions of type String\n          if (type != null && PsiUtilEx.isString(type)) {\n            final PsiModifierListOwner element;\n            if (isAnnotationValue) {\n              final PsiAnnotation psiAnnotation = PsiTreeUtil.getParentOfType(expression, PsiAnnotation.class);\n              if (psiAnnotation != null && myConfiguration.getSubstAnnotationClass().equals(psiAnnotation.getQualifiedName())) {\n                element = PsiTreeUtil.getParentOfType(expression, PsiModifierListOwner.class);\n              }\n              else {\n                return;\n              }\n            }\n            else {\n              element = AnnotationUtilEx.getAnnotatedElementFor(expression, AnnotationUtilEx.LookupType.PREFER_CONTEXT);\n            }\n            if (element != null) {\n              PsiAnnotation[] annotations = AnnotationUtilEx.getAnnotationFrom(element, myConfiguration.getPatternAnnotationPair(), true);\n              checkExpression(expression, annotations, holder);\n            }\n          }\n        }\n      }\n    };\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Object computeSimpleExpression(PsiExpression e) {\n    if (e instanceof PsiLiteralExpression) {\n      return myHelper.computeConstantExpression(e);\n    }\n    else if (e instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression ref = ((PsiReferenceExpression)e);\n      final PsiElement psiElement = ref.resolve();\n      if (psiElement != null) {\n        final Object o = myHelper.computeConstantExpression(e);\n        if (o != null) {\n          return o;\n        }\n        else if (psiElement instanceof PsiModifierListOwner) {\n          // find substitution\n          final Set<String> annotationNames = myConfiguration.getSubstAnnotationPair().second;\n          final PsiAnnotation annotation = AnnotationUtil.findAnnotation((PsiModifierListOwner)psiElement, annotationNames);\n          if (annotation != null) {\n            return AnnotationUtilEx.calcAnnotationValue(annotation, \"value\");\n          }\n        }\n      }\n      else {\n        // unresolvable... no luck\n      }\n    }\n    else if (e instanceof PsiParenthesizedExpression) {\n      return computeSimpleExpression(((PsiParenthesizedExpression)e).getExpression());\n    }\n    else if (e instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression c = ((PsiMethodCallExpression)e);\n      final PsiMethod m = (PsiMethod)c.getMethodExpression().resolve();\n      if (m != null && m.getReturnType() != PsiType.VOID) {\n        // find substitution\n        final PsiAnnotation annotation = AnnotationUtil.findAnnotation(m, myConfiguration.getSubstAnnotationPair().second);\n        if (annotation != null) {\n          return AnnotationUtilEx.calcAnnotationValue(annotation, \"value\");\n        }\n      }\n    }\n    return myHelper.computeConstantExpression(e);\n  }","id":77244,"modified_method":"@Nullable\n  public Object computeSimpleExpression(PsiExpression e) {\n    if (e instanceof PsiLiteralExpression) {\n      return myHelper.computeConstantExpression(e);\n    }\n    else if (e instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression ref = (PsiReferenceExpression)e;\n      final PsiElement psiElement = ref.resolve();\n      if (psiElement != null) {\n        final Object o = myHelper.computeConstantExpression(e);\n        if (o != null) {\n          return o;\n        }\n        else if (psiElement instanceof PsiModifierListOwner) {\n          // find substitution\n          return calcSubstituted((PsiModifierListOwner)psiElement);\n        }\n      }\n      else {\n        // unresolvable... no luck\n      }\n    }\n    else if (e instanceof PsiParenthesizedExpression) {\n      return computeSimpleExpression(((PsiParenthesizedExpression)e).getExpression());\n    }\n    else if (e instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression c = (PsiMethodCallExpression)e;\n      final PsiMethod m = (PsiMethod)c.getMethodExpression().resolve();\n      if (m != null && m.getReturnType() != PsiType.VOID) {\n        // find substitution\n        return calcSubstituted(m);\n      }\n    }\n    return myHelper.computeConstantExpression(e);\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Computes the value for the passed expression.\n   *\n   * @param e           The expression whose value to compute\n   * @param nonConstant list that returns non-constant and non-substituted expressions\n   * @return the computed value, or null if the expression isn't compile time constant and not susbtituted\n   */\n  @Nullable\n  public static String computeExpression(@NotNull final PsiExpression e, @Nullable List<PsiExpression> nonConstant) {\n    final StringBuilder builder = new StringBuilder();\n    final List<PsiExpression> list = nonConstant != null ? nonConstant : new SmartList<PsiExpression>();\n    final PsiElementVisitor processor = new JavaRecursiveElementVisitor() {\n      SubstitutedExpressionEvaluationHelper helper = new SubstitutedExpressionEvaluationHelper(e.getProject());\n\n      @Override\n      public void visitConditionalExpression(PsiConditionalExpression expression) {\n        final PsiExpression c = expression.getCondition();\n        final Object o = helper.myHelper.computeConstantExpression(c);\n        if (Boolean.TRUE.equals(o)) {\n          final PsiExpression then = expression.getThenExpression();\n          if (then != null) {\n            execute(then);\n          }\n        }\n        else if (Boolean.FALSE.equals(o)) {\n          final PsiExpression elseExpr = expression.getElseExpression();\n          if (elseExpr != null) {\n            execute(elseExpr);\n          }\n        }\n        else if (o == null) {\n          list.add(expression);\n        }\n      }\n\n      @Override\n      public void visitLiteralExpression(PsiLiteralExpression expression) {\n        execute(expression);\n      }\n\n      @Override\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        execute(expression);\n      }\n\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n        execute(expression);\n      }\n\n      @Override\n      public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n        final PsiExpression expr = expression.getRExpression();\n        if (expr != null) expr.accept(this);\n      }\n\n      public void execute(PsiExpression e) {\n        final Object s = helper.computeSimpleExpression(e);\n        if (s != null) {\n          builder.append(String.valueOf(s));\n        }\n        else {\n          list.add(e);\n        }\n      }\n    };\n    e.accept(processor);\n\n    return list.size() == 0 ? builder.toString() : null;\n  }","id":77245,"modified_method":"/**\n   * Computes the value for the passed expression.\n   *\n   * @param e           The expression whose value to compute\n   * @param nonConstant list that returns non-constant and non-substituted expressions\n   * @return the computed value, or null if the expression isn't compile time constant and not susbtituted\n   */\n  @Nullable\n  public static String computeExpression(@NotNull final PsiExpression e, @Nullable List<PsiExpression> nonConstant) {\n    final StringBuilder builder = new StringBuilder();\n    final List<PsiExpression> list = nonConstant != null ? nonConstant : new SmartList<PsiExpression>();\n    final PsiElementVisitor processor = new JavaRecursiveElementVisitor() {\n      SubstitutedExpressionEvaluationHelper helper = new SubstitutedExpressionEvaluationHelper(e.getProject());\n      @Override\n      public void visitConditionalExpression(PsiConditionalExpression expression) {\n        PsiExpression c = expression.getCondition();\n        final Object o = helper.myHelper.computeConstantExpression(c);\n        if (Boolean.TRUE.equals(o)) {\n          final PsiExpression then = expression.getThenExpression();\n          if (then != null) {\n            execute(then);\n          }\n        }\n        else if (Boolean.FALSE.equals(o)) {\n          final PsiExpression elseExpr = expression.getElseExpression();\n          if (elseExpr != null) {\n            execute(elseExpr);\n          }\n        }\n        else if (o == null) {\n          list.add(expression);\n        }\n      }\n\n      @Override\n      public void visitLiteralExpression(PsiLiteralExpression expression) {\n        execute(expression);\n      }\n\n      @Override\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        execute(expression);\n      }\n\n      @Override\n      public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n        execute(expression);\n      }\n\n      @Override\n      public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n        final PsiExpression expr = expression.getRExpression();\n        if (expr != null) expr.accept(this);\n      }\n\n      public void execute(PsiExpression e) {\n        final Object s = helper.computeSimpleExpression(e);\n        if (s != null) {\n          builder.append(String.valueOf(s));\n        }\n        else {\n          list.add(e);\n        }\n      }\n    };\n    e.accept(processor);\n\n    return list.isEmpty() ? builder.toString() : null;\n  }","commit_id":"8e76cf0c4d365fa3bd1041d64383bc77ca921d73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PyDocStringOwner docStringOwner = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PyDocStringOwner.class);\n    if (docStringOwner == null) return;\n    PyStringLiteralExpression element = docStringOwner.getDocStringExpression();\n    if (element == null) return;\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PyDocumentationSettings documentationSettings = PyDocumentationSettings.getInstance(element.getProject());\n    if (documentationSettings.isEpydocFormat(element.getContainingFile())) {\n      myPrefix = \"@\";\n    }\n    else {\n      myPrefix = \":\";\n    }\n\n    String replacement = element.getText();\n    if (myMissing != null) {\n      replacement = createMissingReplacement(element);\n    }\n    if (myUnexpected != null) {\n      replacement = createUnexpectedReplacement(replacement);\n    }\n    if (!replacement.equals(element.getText())) {\n      PyExpression str = elementGenerator.createDocstring(replacement).getExpression();\n      element.replace(str);\n    }\n  }","id":77246,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PyDocStringOwner docStringOwner = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PyDocStringOwner.class);\n    if (docStringOwner == null) return;\n    PyStringLiteralExpression element = docStringOwner.getDocStringExpression();\n    if (element == null) {\n      if (docStringOwner instanceof PyFunction) {\n        PsiDocumentManager.getInstance(project).getDocument(docStringOwner.getContainingFile());\n        PythonDocumentationProvider.inserDocStub((PyFunction)docStringOwner, project, getEditor(project, docStringOwner.getContainingFile()));\n      }\n      return;\n    }\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PyDocumentationSettings documentationSettings = PyDocumentationSettings.getInstance(element.getProject());\n    if (documentationSettings.isEpydocFormat(element.getContainingFile())) {\n      myPrefix = \"@\";\n    }\n    else {\n      myPrefix = \":\";\n    }\n\n    String replacement = element.getText();\n    if (myMissing != null) {\n      replacement = createMissingReplacement(element);\n    }\n    if (myUnexpected != null) {\n      replacement = createUnexpectedReplacement(replacement);\n    }\n    if (!replacement.equals(element.getText())) {\n      PyExpression str = elementGenerator.createDocstring(replacement).getExpression();\n      element.replace(str);\n    }\n  }","commit_id":"07efb8bff89414b129a233d3dcc8f3ff05971b9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getName() {\n    if (myMissing != null) {\n      return PyBundle.message(\"QFIX.docstring.add.$0\", myMissingText);\n    }\n    else {\n      return PyBundle.message(\"QFIX.docstring.remove.$0\", myUnexpected);\n    }\n  }","id":77247,"modified_method":"@NotNull\n  public String getName() {\n    if (myMissing != null) {\n      return PyBundle.message(\"QFIX.docstring.add.$0\", myMissingText);\n    }\n    else if (myUnexpected != null){\n      return PyBundle.message(\"QFIX.docstring.remove.$0\", myUnexpected);\n    }\n    else  {\n      return \"insert docstring stub\";\n    }\n  }","commit_id":"07efb8bff89414b129a233d3dcc8f3ff05971b9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    if (!CodeInsightUtilBase.preparePsiElementForWrite(file)) return;\n    PyFunction function = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyFunction.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PythonDocumentationProvider documentationProvider = new PythonDocumentationProvider();\n    PyStatementList list = function.getStatementList();\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(list, PsiWhiteSpace.class);\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1)\n        ws = ws + whitespace.getText().split(\"\\n\")[1];\n    }\n    String docContent = ws + documentationProvider.generateDocumentationContentStub(function, ws, true);\n    PyExpressionStatement string = elementGenerator.createDocstring(\"\\\"\\\"\\\"\" + docContent + \"\\\"\\\"\\\"\");\n    if (list.getStatements().length != 0)\n      list.addBefore(string, list.getStatements()[0]);\n\n    int offset = function.getDocStringExpression().getTextOffset();\n    editor.getCaretModel().moveToOffset(offset);\n    editor.getCaretModel().moveCaretRelatively(0, 1, false, false, false);\n  }","id":77248,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    if (!CodeInsightUtilBase.preparePsiElementForWrite(file)) return;\n    PyFunction function = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyFunction.class);\n    PythonDocumentationProvider.inserDocStub(function, project, editor);\n\n\n  }","commit_id":"07efb8bff89414b129a233d3dcc8f3ff05971b9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkDocString(PyDocStringOwner node) {\n      if (PydevConsoleRunner.isInPydevConsole(node)) {\n        return;\n      }\n      final PyStringLiteralExpression docStringExpression = node.getDocStringExpression();\n      if (docStringExpression == null) {\n        PsiElement marker = null;\n        if (node instanceof PyClass) {\n          final ASTNode n = ((PyClass)node).getNameNode();\n          if (n != null) marker = n.getPsi();\n        }\n        else if (node instanceof PyFunction) {\n          final ASTNode n = ((PyFunction)node).getNameNode();\n          if (n != null) marker = n.getPsi();\n        }\n        else if (node instanceof PyFile) {\n          TextRange tr = new TextRange(0,0);\n          ProblemsHolder holder = getHolder();\n          if (holder != null)\n            holder.registerProblem(node, tr, PyBundle.message(\"INSP.no.docstring\"));\n          return;\n        }\n        if (marker == null) marker = node;\n        registerProblem(marker, PyBundle.message(\"INSP.no.docstring\"));\n      }\n      else {\n        boolean registered = checkParameters(node, docStringExpression);\n        if (!registered && StringUtil.isEmptyOrSpaces(docStringExpression.getStringValue())) {\n          registerProblem(docStringExpression, PyBundle.message(\"INSP.empty.docstring\"));\n        }\n      }\n    }","id":77249,"modified_method":"private void checkDocString(PyDocStringOwner node) {\n      if (PydevConsoleRunner.isInPydevConsole(node)) {\n        return;\n      }\n      final PyStringLiteralExpression docStringExpression = node.getDocStringExpression();\n      if (docStringExpression == null) {\n        PsiElement marker = null;\n        if (node instanceof PyClass) {\n          final ASTNode n = ((PyClass)node).getNameNode();\n          if (n != null) marker = n.getPsi();\n        }\n        else if (node instanceof PyFunction) {\n          final ASTNode n = ((PyFunction)node).getNameNode();\n          if (n != null) marker = n.getPsi();\n        }\n        else if (node instanceof PyFile) {\n          TextRange tr = new TextRange(0,0);\n          ProblemsHolder holder = getHolder();\n          if (holder != null)\n            holder.registerProblem(node, tr, PyBundle.message(\"INSP.no.docstring\"));\n          return;\n        }\n        if (marker == null) marker = node;\n        if (node instanceof PyFunction)\n          registerProblem(marker, PyBundle.message(\"INSP.no.docstring\"), new DocstringQuickFix(null, null));\n        else\n          registerProblem(marker, PyBundle.message(\"INSP.no.docstring\"));\n      }\n      else {\n        boolean registered = checkParameters(node, docStringExpression);\n        if (!registered && StringUtil.isEmptyOrSpaces(docStringExpression.getStringValue())) {\n          registerProblem(docStringExpression, PyBundle.message(\"INSP.empty.docstring\"));\n        }\n      }\n    }","commit_id":"07efb8bff89414b129a233d3dcc8f3ff05971b9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void checkTag(@NotNull final XmlTag tag, @NotNull final ProblemsHolder holder, final boolean isOnTheFly) {\n    final PsiElement[] children = tag.getChildren();\n    String tagName = tag.getName();\n\n    final boolean[] insideEndTag = new boolean[]{false};\n    final XmlToken[] startTagNameToken = new XmlToken[]{null};\n\n    final ElementProcessor processor = new ElementProcessor() {\n      public void process(@NotNull final XmlToken token, @NotNull final String tagName) {\n        String name = tagName;\n        if (token.getTokenType() == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n          return;\n        }\n\n        if (token.getTokenType() == XmlTokenType.XML_END_TAG_START) {\n          insideEndTag[0] = true;\n        }\n\n        if (token.getTokenType() == XmlTokenType.XML_NAME) {\n          if (insideEndTag[0]) {\n            String text = token.getText();\n            if (tag instanceof HtmlTag) {\n              text = text.toLowerCase();\n              name = name.toLowerCase();\n            }\n\n            boolean isExtraHtmlTagEnd = false;\n            if (text.equals(name)) {\n              isExtraHtmlTagEnd = tag instanceof HtmlTag && HtmlUtil.isSingleHtmlTag(name);\n              if (!isExtraHtmlTagEnd) {\n                return;\n              }\n            }\n\n            assert startTagNameToken != null;\n\n            markClosingTag(token, startTagNameToken[0], tag, isExtraHtmlTagEnd, holder);\n          }\n          else {\n            startTagNameToken[0] = token;\n          }\n        }\n      }\n    };\n\n    ProgressManager progressManager = ProgressManager.getInstance();\n    for (PsiElement child : children) {\n      progressManager.checkCanceled();\n\n      if (child instanceof XmlToken) {\n        processor.process((XmlToken) child, tagName);\n      } else if (child instanceof PsiErrorElement) {\n        final PsiElement[] errorChildren = child.getChildren();\n        for (PsiElement errorChild : errorChildren) {\n          progressManager.checkCanceled();\n          if (errorChild instanceof XmlToken) {\n            processor.process((XmlToken) errorChild, tagName);\n          }\n        }\n      }\n\n    }\n  }","id":77250,"modified_method":"protected void checkTag(@NotNull final XmlTag tag, @NotNull final ProblemsHolder holder, final boolean isOnTheFly) {\n    ProgressManager progressManager = ProgressManager.getInstance();\n\n    final String name = tag.getName();\n    final boolean htmlTag = tag instanceof HtmlTag;\n    final String tagName = htmlTag ? name.toLowerCase() : name;\n    boolean matchesNothing = false;\n\n    final PsiElement[] children = tag.getChildren();\n    for (int i = children.length - 1; i >= 0; i--) {\n      progressManager.checkCanceled();\n\n      final PsiElement child = children[i];\n      if (child instanceof XmlToken) {\n        final XmlToken token = (XmlToken)child;\n\n        final IElementType type = token.getTokenType();\n        if (XmlTokenType.XML_NAME == type) {\n          if (isEndTagName(token)) {\n            final String tokenName = htmlTag ? token.getText().toLowerCase() : token.getText();\n\n            if (tagName.equals(tokenName)) {\n              matchesNothing = true;\n\n              if (htmlTag && HtmlUtil.isSingleHtmlTag(name)) {\n                markClosingTag(token, tag, matchesNothing, holder, tag);\n              }\n            } else {\n              markClosingTag(token, tag, matchesNothing, holder, tag);\n            }\n          }\n        }\n      }\n      else if (child instanceof PsiErrorElement) {\n        final PsiElement[] errorChildren = child.getChildren();\n        boolean insideEndTag = false;\n        for (final PsiElement each : errorChildren) {\n          if (each instanceof XmlToken) {\n            final XmlToken token = (XmlToken)each;\n            if (token.getTokenType() == XmlTokenType.XML_END_TAG_START) {\n              insideEndTag = true;\n              continue;\n            }\n\n            if (insideEndTag && token.getTokenType() == XmlTokenType.XML_NAME) {\n              final String tokenName = htmlTag ? token.getText().toLowerCase() : token.getText();\n              if (!tagName.equals(tokenName)) {\n                markClosingTag((XmlToken)each, tag, matchesNothing, holder, child);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void markClosingTag(@NotNull final XmlToken token,\n                                @NotNull final XmlToken startTagNameToken,\n                                @NotNull final XmlTag tag,\n                                boolean extraClosingTag,\n                                @NotNull final ProblemsHolder holder) {\n    if (extraClosingTag) {\n      holder.registerProblem(token, XmlErrorMessages.message(\"extra.closing.tag.for.empty.element\"),\n                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING, new RemoveExtraClosingTagIntentionAction(token));\n    }\n  }","id":77251,"modified_method":"protected void markClosingTag(@NotNull final XmlToken token,\n                                @NotNull final XmlTag tag,\n                                boolean extraClosingTag,\n                                @NotNull final ProblemsHolder holder,\n                                @NotNull final PsiElement parent) {\n    if (extraClosingTag) {\n      final boolean errorElement = parent instanceof PsiErrorElement &&  ((PsiErrorElement)parent).getErrorDescription().equals(XmlErrorMessages.message(\"xml.parsing.closing.tag.mathes.nothing\"));\n      final PsiElement target = errorElement ? parent : token;\n\n      final RemoveExtraClosingTagIntentionAction action = new RemoveExtraClosingTagIntentionAction(token);\n      holder.registerProblem(target, XmlErrorMessages.message(\"extra.closing.tag.for.empty.element\"),\n                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING, action);\n    }\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void parseComment() {\n    final PsiBuilder.Marker comment = mark();\n    advance();\n    while (true) {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_COMMENT_CHARACTERS || tt == XmlTokenType.XML_CHAR_ENTITY_REF) {\n        advance();\n        continue;\n      }\n      else if (tt == XmlTokenType.XML_BAD_CHARACTER) {\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(\"Bad character\");\n        continue;\n      }\n      if (tt == XmlTokenType.XML_COMMENT_END) {\n        advance();\n      }\n      break;\n    }\n    comment.done(XmlElementType.XML_COMMENT);\n  }","id":77252,"modified_method":"protected void parseComment() {\n    final PsiBuilder.Marker comment = mark();\n    advance();\n    while (true) {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_COMMENT_CHARACTERS || tt == XmlTokenType.XML_CHAR_ENTITY_REF) {\n        advance();\n        continue;\n      }\n      else if (tt == XmlTokenType.XML_BAD_CHARACTER) {\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(XmlErrorMessages.message(\"xml.parsing.bad.character\"));\n        continue;\n      }\n      if (tt == XmlTokenType.XML_COMMENT_END) {\n        advance();\n      }\n      break;\n    }\n    comment.done(XmlElementType.XML_COMMENT);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker flushError(PsiBuilder.Marker error) {\n    if (error != null) {\n      error.error(\"Unexpected tokens\");\n      error = null;\n    }\n    return error;\n  }","id":77253,"modified_method":"@Nullable\n  private static PsiBuilder.Marker flushError(PsiBuilder.Marker error) {\n    if (error != null) {\n      error.error(XmlErrorMessages.message(\"xml.parsing.unexpected.tokens\"));\n      error = null;\n    }\n    return error;\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void parseDocument() {\n    final PsiBuilder.Marker document = mark();\n\n    while (token() == XmlTokenType.XML_COMMENT_START) {\n      parseComment();\n    }\n\n    parseProlog();\n\n    PsiBuilder.Marker error = null;\n    while (!eof()) {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_START_TAG_START) {\n        error = flushError(error);\n        parseTag();\n        myTagMarkersStack.clear();\n        myTagNamesStack.clear();\n      }\n      else if (tt == XmlTokenType.XML_COMMENT_START) {\n        error = flushError(error);\n        parseComment();\n      }\n      else if (tt == XmlTokenType.XML_PI_START) {\n        error = flushError(error);\n        parseProcessingInstruction();\n      }\n      else if (tt == XmlTokenType.XML_REAL_WHITE_SPACE || tt == XmlTokenType.XML_CHAR_ENTITY_REF || tt == XmlTokenType.XML_DATA_CHARACTERS) {\n        error = flushError(error);\n        advance();\n      }\n      else {\n        if (error == null) error = mark();\n        advance();\n      }\n    }\n\n    if (error != null) {\n      error.error(\"Top element is not completed\");\n      error = null;\n    }\n\n    document.done(XmlElementType.HTML_DOCUMENT);\n  }","id":77254,"modified_method":"public void parseDocument() {\n    final PsiBuilder.Marker document = mark();\n\n    while (token() == XmlTokenType.XML_COMMENT_START) {\n      parseComment();\n    }\n\n    parseProlog();\n\n    PsiBuilder.Marker error = null;\n    while (!eof()) {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_START_TAG_START) {\n        error = flushError(error);\n        parseTag();\n        myTagMarkersStack.clear();\n        myTagNamesStack.clear();\n      }\n      else if (tt == XmlTokenType.XML_COMMENT_START) {\n        error = flushError(error);\n        parseComment();\n      }\n      else if (tt == XmlTokenType.XML_PI_START) {\n        error = flushError(error);\n        parseProcessingInstruction();\n      }\n      else if (tt == XmlTokenType.XML_REAL_WHITE_SPACE || tt == XmlTokenType.XML_CHAR_ENTITY_REF || tt == XmlTokenType.XML_DATA_CHARACTERS) {\n        error = flushError(error);\n        advance();\n      }\n      else {\n        if (error == null) error = mark();\n        advance();\n      }\n    }\n\n    if (error != null) {\n      error.error(XmlErrorMessages.message(\"top.level.element.is.not.completed\"));\n      error = null;\n    }\n\n    document.done(XmlElementType.HTML_DOCUMENT);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseProcessingInstruction() {\n    assert token() == XmlTokenType.XML_PI_START;\n    final PsiBuilder.Marker pi = mark();\n    advance();\n    if (token() == XmlTokenType.XML_NAME || token() == XmlTokenType.XML_PI_TARGET) {\n      advance();\n    }\n\n    while (token() == XmlTokenType.XML_NAME) {\n      advance();\n      if (token() == XmlTokenType.XML_EQ) {\n        advance();\n      }\n      else {\n        error(\"'=' expected\");\n      }\n      parseAttributeValue();\n    }\n\n    if (token() == XmlTokenType.XML_PI_END) {\n      advance();\n    }\n    else {\n      error(\"Processing instruction not terminated\");\n    }\n\n    pi.done(XmlElementType.XML_PROCESSING_INSTRUCTION);\n  }","id":77255,"modified_method":"private void parseProcessingInstruction() {\n    assert token() == XmlTokenType.XML_PI_START;\n    final PsiBuilder.Marker pi = mark();\n    advance();\n    if (token() == XmlTokenType.XML_NAME || token() == XmlTokenType.XML_PI_TARGET) {\n      advance();\n    }\n\n    while (token() == XmlTokenType.XML_NAME) {\n      advance();\n      if (token() == XmlTokenType.XML_EQ) {\n        advance();\n      }\n      else {\n        error(XmlErrorMessages.message(\"expected.attribute.eq.sign\"));\n      }\n      parseAttributeValue();\n    }\n\n    if (token() == XmlTokenType.XML_PI_END) {\n      advance();\n    }\n    else {\n      error(XmlErrorMessages.message(\"xml.parsing.unterminated.processing.instruction\"));\n    }\n\n    pi.done(XmlElementType.XML_PROCESSING_INSTRUCTION);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseTag() {\n    assert token() == XmlTokenType.XML_START_TAG_START : \"Tag start expected\";\n    final PsiBuilder.Marker tag = mark();\n    myTagMarkersStack.push(tag);\n\n    // Start tag header\n    advance();\n    final String originalTagName;\n    if (token() != XmlTokenType.XML_NAME) {\n      error(\"Tag name expected\");\n      originalTagName = \"\";\n    }\n    else {\n      originalTagName = myBuilder.getTokenText();\n      advance();\n    }\n\n    String tagName = originalTagName.toLowerCase();\n    myTagNamesStack.push(tagName);\n    \n    do {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_NAME) {\n        parseAttribute();\n      }\n      else if (tt == XmlTokenType.XML_CHAR_ENTITY_REF || tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n        parseReference();\n      }\n      else {\n        break;\n      }\n    }\n    while (true);\n\n    if (token() == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n      advance();\n      tag.done(XmlElementType.HTML_TAG);\n      return;\n    }\n\n    if (token() == XmlTokenType.XML_TAG_END) {\n      advance();\n    }\n    else {\n      error(\"Tag start is not closed\");\n      tag.done(XmlElementType.HTML_TAG);\n      return;\n    }\n\n    if (HtmlUtil.isSingleHtmlTagL(tagName)) {\n      final PsiBuilder.Marker footer = mark();\n      if (token() == XmlTokenType.XML_END_TAG_START) {\n        advance();\n        if (token() == XmlTokenType.XML_NAME) {\n          if (tagName.equalsIgnoreCase(myBuilder.getTokenText())) {\n            advance();\n            footer.drop();\n            if (token() == XmlTokenType.XML_TAG_END) {\n              advance();\n            }\n            tag.done(XmlElementType.HTML_TAG);\n            return;\n          }\n        }\n      }\n\n      footer.rollbackTo();\n      tag.done(XmlElementType.HTML_TAG);\n      return;\n    }\n\n    // Done header, start content\n\n    boolean isInlineTagContainer = HtmlUtil.isInlineTagContainerL(tagName);\n    boolean isOptionalTagEnd = HtmlUtil.isOptionalEndForHtmlTagL(tagName);\n\n    PsiBuilder.Marker firstBlockChild = null;\n\n    PsiBuilder.Marker xmlText = null;\n    while (!eof()) {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_START_TAG_START) {\n        xmlText = terminateText(xmlText);\n        parseTag();\n\n        PsiBuilder.Marker childMarker = myTagMarkersStack.pop();\n        String childName = myTagNamesStack.pop();\n\n        if (isOptionalTagEnd) {\n          if (tagName.equals(childName)) {\n            tag.doneBefore(XmlElementType.HTML_TAG, childMarker);\n            return;\n          }\n\n          boolean foundMatch = childTerminatesParentInStack(childName, true);\n          if (foundMatch) {\n            myTagMarkersStack.pop();\n            myTagNamesStack.pop();\n\n            myTagMarkersStack.push(childMarker);\n            myTagNamesStack.push(childName);\n\n            tag.doneBefore(XmlElementType.HTML_TAG, childMarker);\n            return;\n          }\n        }\n\n\n        if (isInlineTagContainer && HtmlUtil.isHtmlBlockTagL(childName)) {\n          tag.doneBefore(XmlElementType.HTML_TAG, childMarker);\n          return;\n        }\n        else if (isOptionalTagEnd && firstBlockChild == null && HtmlUtil.isHtmlBlockTagL(childName) && !HtmlUtil.isHtmlBlockTagL(tagName) && canTerminate(childName, tagName)) {\n          firstBlockChild = childMarker;\n        }\n      }\n      else if (tt == XmlTokenType.XML_PI_START) {\n        xmlText = terminateText(xmlText);\n        parseProcessingInstruction();\n      }\n      else if (tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n        xmlText = terminateText(xmlText);\n        parseReference();\n      }\n      else if (tt == XmlTokenType.XML_CHAR_ENTITY_REF) {\n        xmlText = startText(xmlText);\n        parseReference();\n      }\n      else if (tt == XmlTokenType.XML_CDATA_START) {\n        xmlText = startText(xmlText);\n        parseCData();\n      }\n      else if (tt == XmlTokenType.XML_COMMENT_START) {\n        xmlText = startText(xmlText);\n        parseComment();\n      }\n      else if (tt == XmlTokenType.XML_BAD_CHARACTER) {\n        xmlText = startText(xmlText);\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(\"Unescaped & or nonterminated character/entity reference\");\n      }\n      else if (tt instanceof IChameleonElementType) {\n        xmlText = terminateText(xmlText);\n        advance();\n      }\n      else if (token() == XmlTokenType.XML_END_TAG_START) {\n        xmlText = terminateText(xmlText);\n        final PsiBuilder.Marker footer = mark();\n        advance();\n\n        if (token() == XmlTokenType.XML_NAME) {\n          String endName = myBuilder.getTokenText().toLowerCase();\n          if (!tagName.equals(endName) && !endName.endsWith(COMPLETION_NAME)) {\n            final boolean hasChancesToMatch = HtmlUtil.isOptionalEndForHtmlTagL(endName) ? childTerminatesParentInStack(endName, false) : myTagNamesStack.contains(endName);\n            if (hasChancesToMatch) {\n              footer.rollbackTo();\n              if (isOptionalTagEnd) {\n                if (firstBlockChild != null) {\n                  tag.doneBefore(XmlElementType.HTML_TAG, firstBlockChild);\n                }\n                else {\n                  tag.done(XmlElementType.HTML_TAG);\n                }\n              }\n              else {\n                error(\"Element \" + originalTagName + \" is not closed\");\n                tag.done(XmlElementType.HTML_TAG);\n              }\n              return;\n            }\n            else {\n              advance();\n              if (token() == XmlTokenType.XML_TAG_END) advance();\n              footer.error(\"Closing tag matches nothing\");\n              continue;\n            }\n          }\n\n          advance();\n\n          while (token() != XmlTokenType.XML_TAG_END && token() != XmlTokenType.XML_START_TAG_START && token() != XmlTokenType.XML_END_TAG_START && !eof()) {\n            error(\"Unexpected token\");\n            advance();\n          }\n        }\n        else {\n          error(\"Closing tag name missing\");\n        }\n        footer.drop();\n\n        if (token() == XmlTokenType.XML_TAG_END) {\n          advance();\n        }\n        else {\n          error(\"Closing tag is not done\");\n        }\n        \n        tag.done(XmlElementType.HTML_TAG);\n        return;\n      }\n      else {\n        xmlText = startText(xmlText);\n        advance();\n      }\n    }\n\n    xmlText = terminateText(xmlText);\n\n    if (isOptionalTagEnd) {\n      if (firstBlockChild != null) {\n        tag.doneBefore(XmlElementType.HTML_TAG, firstBlockChild);\n      }\n      else {\n        tag.done(XmlElementType.HTML_TAG);\n      }\n    }\n    else {\n      error(\"Element \" + originalTagName + \" is not closed\");\n      tag.done(XmlElementType.HTML_TAG);\n    }\n  }","id":77256,"modified_method":"private void parseTag() {\n    assert token() == XmlTokenType.XML_START_TAG_START : \"Tag start expected\";\n    final PsiBuilder.Marker tag = mark();\n    myTagMarkersStack.push(tag);\n\n    // Start tag header\n    advance();\n    final String originalTagName;\n    if (token() != XmlTokenType.XML_NAME) {\n      error(XmlErrorMessages.message(\"xml.parsing.tag.name.expected\"));\n      originalTagName = \"\";\n    }\n    else {\n      originalTagName = myBuilder.getTokenText();\n      advance();\n    }\n\n    String tagName = originalTagName.toLowerCase();\n    myTagNamesStack.push(tagName);\n    \n    do {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_NAME) {\n        parseAttribute();\n      }\n      else if (tt == XmlTokenType.XML_CHAR_ENTITY_REF || tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n        parseReference();\n      }\n      else {\n        break;\n      }\n    }\n    while (true);\n\n    if (token() == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n      advance();\n      tag.done(XmlElementType.HTML_TAG);\n      return;\n    }\n\n    if (token() == XmlTokenType.XML_TAG_END) {\n      advance();\n    }\n    else {\n      error(XmlErrorMessages.message(\"tag.start.is.not.closed\"));\n      tag.done(XmlElementType.HTML_TAG);\n      return;\n    }\n\n    if (HtmlUtil.isSingleHtmlTagL(tagName)) {\n      final PsiBuilder.Marker footer = mark();\n      if (token() == XmlTokenType.XML_END_TAG_START) {\n        advance();\n        if (token() == XmlTokenType.XML_NAME) {\n          if (tagName.equalsIgnoreCase(myBuilder.getTokenText())) {\n            advance();\n            footer.drop();\n            if (token() == XmlTokenType.XML_TAG_END) {\n              advance();\n            }\n            tag.done(XmlElementType.HTML_TAG);\n            return;\n          }\n        }\n      }\n\n      footer.rollbackTo();\n      tag.done(XmlElementType.HTML_TAG);\n      return;\n    }\n\n    // Done header, start content\n\n    boolean isInlineTagContainer = HtmlUtil.isInlineTagContainerL(tagName);\n    boolean isOptionalTagEnd = HtmlUtil.isOptionalEndForHtmlTagL(tagName);\n\n    PsiBuilder.Marker firstBlockChild = null;\n\n    PsiBuilder.Marker xmlText = null;\n    while (!eof()) {\n      final IElementType tt = token();\n      if (tt == XmlTokenType.XML_START_TAG_START) {\n        xmlText = terminateText(xmlText);\n        parseTag();\n\n        PsiBuilder.Marker childMarker = myTagMarkersStack.pop();\n        String childName = myTagNamesStack.pop();\n\n        if (isOptionalTagEnd) {\n          if (tagName.equals(childName)) {\n            tag.doneBefore(XmlElementType.HTML_TAG, childMarker);\n            return;\n          }\n\n          boolean foundMatch = childTerminatesParentInStack(childName, true);\n          if (foundMatch) {\n            myTagMarkersStack.pop();\n            myTagNamesStack.pop();\n\n            myTagMarkersStack.push(childMarker);\n            myTagNamesStack.push(childName);\n\n            tag.doneBefore(XmlElementType.HTML_TAG, childMarker);\n            return;\n          }\n        }\n\n\n        if (isInlineTagContainer && HtmlUtil.isHtmlBlockTagL(childName)) {\n          tag.doneBefore(XmlElementType.HTML_TAG, childMarker);\n          return;\n        }\n        else if (isOptionalTagEnd && firstBlockChild == null && HtmlUtil.isHtmlBlockTagL(childName) && !HtmlUtil.isHtmlBlockTagL(tagName) && canTerminate(childName, tagName)) {\n          firstBlockChild = childMarker;\n        }\n      }\n      else if (tt == XmlTokenType.XML_PI_START) {\n        xmlText = terminateText(xmlText);\n        parseProcessingInstruction();\n      }\n      else if (tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n        xmlText = terminateText(xmlText);\n        parseReference();\n      }\n      else if (tt == XmlTokenType.XML_CHAR_ENTITY_REF) {\n        xmlText = startText(xmlText);\n        parseReference();\n      }\n      else if (tt == XmlTokenType.XML_CDATA_START) {\n        xmlText = startText(xmlText);\n        parseCData();\n      }\n      else if (tt == XmlTokenType.XML_COMMENT_START) {\n        xmlText = startText(xmlText);\n        parseComment();\n      }\n      else if (tt == XmlTokenType.XML_BAD_CHARACTER) {\n        xmlText = startText(xmlText);\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(XmlErrorMessages.message(\"unescaped.ampersand.or.nonterminated.character.entity.reference\"));\n      }\n      else if (tt instanceof IChameleonElementType) {\n        xmlText = terminateText(xmlText);\n        advance();\n      }\n      else if (token() == XmlTokenType.XML_END_TAG_START) {\n        xmlText = terminateText(xmlText);\n        final PsiBuilder.Marker footer = mark();\n        advance();\n\n        if (token() == XmlTokenType.XML_NAME) {\n          String endName = myBuilder.getTokenText().toLowerCase();\n          if (!tagName.equals(endName) && !endName.endsWith(COMPLETION_NAME)) {\n            final boolean hasChancesToMatch = HtmlUtil.isOptionalEndForHtmlTagL(endName) ? childTerminatesParentInStack(endName, false) : myTagNamesStack.contains(endName);\n            if (hasChancesToMatch) {\n              footer.rollbackTo();\n              if (isOptionalTagEnd) {\n                if (firstBlockChild != null) {\n                  tag.doneBefore(XmlElementType.HTML_TAG, firstBlockChild);\n                }\n                else {\n                  tag.done(XmlElementType.HTML_TAG);\n                }\n              }\n              else {\n                error(XmlErrorMessages.message(\"named.element.is.not.closed\", originalTagName));\n                tag.done(XmlElementType.HTML_TAG);\n              }\n              return;\n            }\n            else {\n              advance();\n              if (token() == XmlTokenType.XML_TAG_END) advance();\n              footer.error(XmlErrorMessages.message(\"xml.parsing.closing.tag.mathes.nothing\"));\n              continue;\n            }\n          }\n\n          advance();\n\n          while (token() != XmlTokenType.XML_TAG_END && token() != XmlTokenType.XML_START_TAG_START && token() != XmlTokenType.XML_END_TAG_START && !eof()) {\n            error(XmlErrorMessages.message(\"xml.parsing.unexpected.token\"));\n            advance();\n          }\n        }\n        else {\n          error(XmlErrorMessages.message(\"xml.parsing.closing.tag.name.missing\"));\n        }\n        footer.drop();\n\n        if (token() == XmlTokenType.XML_TAG_END) {\n          advance();\n        }\n        else {\n          error(XmlErrorMessages.message(\"xml.parsing.closing.tag.is.not.done\"));\n        }\n        \n        tag.done(XmlElementType.HTML_TAG);\n        return;\n      }\n      else {\n        xmlText = startText(xmlText);\n        advance();\n      }\n    }\n\n    xmlText = terminateText(xmlText);\n\n    if (isOptionalTagEnd) {\n      if (firstBlockChild != null) {\n        tag.doneBefore(XmlElementType.HTML_TAG, firstBlockChild);\n      }\n      else {\n        tag.done(XmlElementType.HTML_TAG);\n      }\n    }\n    else {\n      error(XmlErrorMessages.message(\"named.element.is.not.closed\", originalTagName));\n      tag.done(XmlElementType.HTML_TAG);\n    }\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseDoctype() {\n    assert token() == XmlTokenType.XML_DOCTYPE_START : \"Doctype start expected\";\n    final PsiBuilder.Marker doctype = mark();\n    advance();\n\n    while (token() != XmlTokenType.XML_DOCTYPE_END && !eof()) advance();\n    if (eof()) {\n      error(\"Unexpected ent of file\");\n    }\n    else {\n      advance();\n    }\n\n    doctype.done(XmlElementType.XML_DOCTYPE);\n  }","id":77257,"modified_method":"private void parseDoctype() {\n    assert token() == XmlTokenType.XML_DOCTYPE_START : \"Doctype start expected\";\n    final PsiBuilder.Marker doctype = mark();\n    advance();\n\n    while (token() != XmlTokenType.XML_DOCTYPE_END && !eof()) advance();\n    if (eof()) {\n      error(XmlErrorMessages.message(\"xml.parsing.unexpected.end.of.file\"));\n    }\n    else {\n      advance();\n    }\n\n    doctype.done(XmlElementType.XML_DOCTYPE);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseAttributeValue() {\n    final PsiBuilder.Marker attValue = mark();\n    if (token() == XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n      while (true) {\n        final IElementType tt = token();\n        if (tt == null || tt == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER || tt == XmlTokenType.XML_END_TAG_START || tt == XmlTokenType\n          .XML_EMPTY_ELEMENT_END ||\n            tt == XmlTokenType.XML_START_TAG_START) {\n          break;\n        }\n\n        if (tt == XmlTokenType.XML_BAD_CHARACTER) {\n          final PsiBuilder.Marker error = mark();\n          advance();\n          error.error(\"Unescaped & or nonterminated character/entity reference\");\n        }\n        else if (tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n          parseReference();\n        }\n        else {\n          advance();\n        }\n      }\n\n      if (token() == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n        advance();\n      }\n      else {\n        error(\"Attribute value is not closed\");\n      }\n    }\n    else {\n      if (token() != XmlTokenType.XML_TAG_END && token() != XmlTokenType.XML_EMPTY_ELEMENT_END) {\n        advance(); // Single token att value\n      }\n    }\n\n    attValue.done(XmlElementType.XML_ATTRIBUTE_VALUE);\n  }","id":77258,"modified_method":"private void parseAttributeValue() {\n    final PsiBuilder.Marker attValue = mark();\n    if (token() == XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n      while (true) {\n        final IElementType tt = token();\n        if (tt == null || tt == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER || tt == XmlTokenType.XML_END_TAG_START || tt == XmlTokenType\n          .XML_EMPTY_ELEMENT_END ||\n            tt == XmlTokenType.XML_START_TAG_START) {\n          break;\n        }\n\n        if (tt == XmlTokenType.XML_BAD_CHARACTER) {\n          final PsiBuilder.Marker error = mark();\n          advance();\n          error.error(XmlErrorMessages.message(\"unescaped.ampersand.or.nonterminated.character.entity.reference\"));\n        }\n        else if (tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n          parseReference();\n        }\n        else {\n          advance();\n        }\n      }\n\n      if (token() == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n        advance();\n      }\n      else {\n        error(XmlErrorMessages.message(\"xml.parsing.unclosed.attribute.value\"));\n      }\n    }\n    else {\n      if (token() != XmlTokenType.XML_TAG_END && token() != XmlTokenType.XML_EMPTY_ELEMENT_END) {\n        advance(); // Single token att value\n      }\n    }\n\n    attValue.done(XmlElementType.XML_ATTRIBUTE_VALUE);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void markClosingTag(@NotNull final XmlToken token,\n                                @NotNull final XmlToken startTagNameToken,\n                                @NotNull final XmlTag tag,\n                                final boolean extraClosingTag,\n                                @NotNull final ProblemsHolder holder) {\n    if (!extraClosingTag) {\n\n      final String tokenText = (tag instanceof HtmlTag) ? token.getText().toLowerCase() : token.getText();\n      final String tagName = (tag instanceof HtmlTag) ? tag.getName().toLowerCase() : tag.getName();\n\n      final RenameTagBeginOrEndIntentionAction action1 = new RenameTagBeginOrEndIntentionAction(tag, tagName, false);\n      final RenameTagBeginOrEndIntentionAction action2 = new RenameTagBeginOrEndIntentionAction(tag, tokenText, true);\n\n      holder.registerProblem(token, XmlErrorMessages.message(\"wrong.closing.tag.name\"), ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                             new RemoveExtraClosingTagIntentionAction(token), action1, action2);\n\n      final ASTNode astNode = tag.getNode();\n      assert astNode != null;\n\n      final ASTNode endOfTagStart = XmlChildRole.START_TAG_END_FINDER.findChild(astNode);\n      final ASTNode startOfTagStart = XmlChildRole.START_TAG_START_FINDER.findChild(astNode);\n      if (endOfTagStart != null && startOfTagStart != null) {\n        final TextRange textRange = new TextRange(startOfTagStart.getPsi().getStartOffsetInParent() + startOfTagStart.getTextLength(),\n                                                  endOfTagStart.getPsi().getStartOffsetInParent());\n        holder.registerProblem(holder.getManager().createProblemDescriptor(tag, textRange, XmlErrorMessages.message(\"tag.has.wrong.closing.tag.name\"),\n                                                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING, action1, action2));\n      }\n      else {\n        final ASTNode startTagNameNode = XmlChildRole.START_TAG_NAME_FINDER.findChild(astNode);\n        holder.registerProblem(startTagNameNode.getPsi(), XmlErrorMessages.message(\"tag.has.wrong.closing.tag.name\"),\n                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING, action1, action2);\n      }\n    }\n  }","id":77259,"modified_method":"protected void markClosingTag(@NotNull final XmlToken token,\n                                @NotNull final XmlTag tag,\n                                final boolean extraClosingTag,\n                                @NotNull final ProblemsHolder holder, @NotNull final PsiElement tokenParent) {\n\n    if (!extraClosingTag) {\n      final String tokenText = (tag instanceof HtmlTag) ? token.getText().toLowerCase() : token.getText();\n      final String tagName = (tag instanceof HtmlTag) ? tag.getName().toLowerCase() : tag.getName();\n\n      final RenameTagBeginOrEndIntentionAction action1 = new RenameTagBeginOrEndIntentionAction((CompositeElement) tokenParent, token, tagName, tokenText, false);\n      final RenameTagBeginOrEndIntentionAction action2 = new RenameTagBeginOrEndIntentionAction((CompositeElement) tag, (XmlToken)tag.getChildren()[1], tokenText, tagName, true);\n\n      holder.registerProblem(token, XmlErrorMessages.message(\"wrong.closing.tag.name\"), ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                             new RemoveExtraClosingTagIntentionAction(token), action1, action2);\n\n      final ASTNode astNode = tag.getNode();\n      assert astNode != null;\n\n      final ASTNode endOfTagStart = XmlChildRole.START_TAG_END_FINDER.findChild(astNode);\n      final ASTNode startOfTagStart = XmlChildRole.START_TAG_START_FINDER.findChild(astNode);\n      if (endOfTagStart != null && startOfTagStart != null) {\n        final TextRange textRange = new TextRange(startOfTagStart.getPsi().getStartOffsetInParent() + startOfTagStart.getTextLength(),\n                                                  endOfTagStart.getPsi().getStartOffsetInParent());\n        holder.registerProblem(holder.getManager().createProblemDescriptor(tag, textRange, XmlErrorMessages.message(\"tag.has.wrong.closing.tag.name\"),\n                                                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING, action1, action2));\n      }\n      else {\n        final ASTNode startTagNameNode = XmlChildRole.START_TAG_NAME_FINDER.findChild(astNode);\n        holder.registerProblem(startTagNameNode.getPsi(), XmlErrorMessages.message(\"tag.has.wrong.closing.tag.name\"),\n                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING, action1, action2);\n      }\n    }\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getName() {\n    return myStart ? XmlErrorMessages.message(\"rename.start.tag.name.intention\") : XmlErrorMessages.message(\"rename.end.tag.name.intention\");\n  }","id":77260,"modified_method":"@NotNull\n  public String getName() {\n    return myStart\n           ? XmlErrorMessages.message(\"rename.start.tag.name.intention\", mySourceName, myTargetName)\n           : XmlErrorMessages.message(\"rename.end.tag.name.intention\", mySourceName, myTargetName);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"RenameTagBeginOrEndIntentionAction(XmlTag tagToChange, String name, boolean start) {\n    myStart = start;\n    myTagToChange = tagToChange;\n    myName = name;\n  }","id":77261,"modified_method":"RenameTagBeginOrEndIntentionAction(@NotNull final CompositeElement parent,\n                                     @NotNull final XmlToken target,\n                                     @NotNull final String targetName,\n                                     @NotNull final String sourceName,\n                                     final boolean start) {\n    myParent = parent;\n    myTarget = target;\n    myTargetName = targetName;\n    mySourceName = sourceName;\n    myStart = start;\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull final Project project, final ProblemDescriptor descriptor) {\n    if (!CodeInsightUtil.prepareFileForWrite(myTagToChange.getContainingFile())) {\n      return;\n    }\n\n    new WriteCommandAction(project) {\n      protected void run(final Result result) throws Throwable {\n        myTagToChange.setName(myName);\n      }\n    }.execute();\n  }","id":77262,"modified_method":"public void applyFix(@NotNull final Project project, final ProblemDescriptor descriptor) {\n    if (!CodeInsightUtil.prepareFileForWrite(myTarget.getContainingFile())) {\n      return;\n    }\n\n    new WriteCommandAction(project) {\n      protected void run(final Result result) throws Throwable {\n        final XmlTag newTag = PsiManager.getInstance(project).getElementFactory().createTagFromText(\"<\" + myTargetName + \"/>\");\n        CodeEditUtil.replaceChild(myParent, myTarget.getNode(), newTag.getChildren()[1].getNode());\n      }\n    }.execute();\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String parseTagHeader(final boolean multipleRootTagError, final PsiBuilder.Marker tag) {\n    if (multipleRootTagError) {\n      final PsiBuilder.Marker error = mark();\n      advance();\n      error.error(\"Multiple root tags\");\n    }\n    else {\n      advance();\n    }\n\n    final String tagName;\n    if (token() != XML_NAME) {\n      error(\"Tag name expected\");\n      tagName = \"\";\n    }\n    else {\n      tagName = myBuilder.getTokenText();\n      assert tagName != null;\n      advance();\n    }\n    myTagNamesStack.push(tagName);\n\n    do {\n      final IElementType tt = token();\n      if (tt == XML_NAME) {\n        parseAttribute();\n      }\n      else if (tt == XML_CHAR_ENTITY_REF || tt == XML_ENTITY_REF_TOKEN) {\n        parseReference();\n      }\n      else {\n        break;\n      }\n    }\n    while (true);\n\n    if (token() == XML_EMPTY_ELEMENT_END) {\n      advance();\n      myTagNamesStack.pop();\n      tag.done(XmlElementType.XML_TAG);\n      return null;\n    }\n\n    if (token() == XML_TAG_END) {\n      advance();\n    }\n    else {\n      error(\"Tag start is not closed\");\n      myTagNamesStack.pop();\n      tag.done(XmlElementType.XML_TAG);\n      return null;\n    }\n    return tagName;\n  }","id":77263,"modified_method":"@Nullable\n  private String parseTagHeader(final boolean multipleRootTagError, final PsiBuilder.Marker tag) {\n    if (multipleRootTagError) {\n      final PsiBuilder.Marker error = mark();\n      advance();\n      error.error(XmlErrorMessages.message(\"xml.parsing.multiple.root.tags\"));\n    }\n    else {\n      advance();\n    }\n\n    final String tagName;\n    if (token() != XML_NAME) {\n      error(XmlErrorMessages.message(\"xml.parsing.tag.name.expected\"));\n      tagName = \"\";\n    }\n    else {\n      tagName = myBuilder.getTokenText();\n      assert tagName != null;\n      advance();\n    }\n    myTagNamesStack.push(tagName);\n\n    do {\n      final IElementType tt = token();\n      if (tt == XML_NAME) {\n        parseAttribute();\n      }\n      else if (tt == XML_CHAR_ENTITY_REF || tt == XML_ENTITY_REF_TOKEN) {\n        parseReference();\n      }\n      else {\n        break;\n      }\n    }\n    while (true);\n\n    if (token() == XML_EMPTY_ELEMENT_END) {\n      advance();\n      myTagNamesStack.pop();\n      tag.done(XmlElementType.XML_TAG);\n      return null;\n    }\n\n    if (token() == XML_TAG_END) {\n      advance();\n    }\n    else {\n      error(XmlErrorMessages.message(\"tag.start.is.not.closed\"));\n      myTagNamesStack.pop();\n      tag.done(XmlElementType.XML_TAG);\n      return null;\n    }\n    return tagName;\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseAttributeValue() {\n    final PsiBuilder.Marker attValue = mark();\n    if (token() == XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n      while (true) {\n        final IElementType tt = token();\n        if (tt == null || tt == XML_ATTRIBUTE_VALUE_END_DELIMITER || tt == XML_END_TAG_START || tt == XML_EMPTY_ELEMENT_END ||\n            tt == XML_START_TAG_START) {\n          break;\n        }\n\n        if (tt == XML_BAD_CHARACTER) {\n          final PsiBuilder.Marker error = mark();\n          advance();\n          error.error(\"Unescaped & or nonterminated character/entity reference\");\n        }\n        else if (tt == XML_ENTITY_REF_TOKEN) {\n          parseReference();\n        }\n        else {\n          advance();\n        }\n      }\n\n      if (token() == XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n        advance();\n      }\n      else {\n        error(\"Attribute value is not closed\");\n      }\n    }\n    else {\n      error(\"Attribute value expected\");\n    }\n\n    attValue.done(XML_ATTRIBUTE_VALUE);\n  }","id":77264,"modified_method":"private void parseAttributeValue() {\n    final PsiBuilder.Marker attValue = mark();\n    if (token() == XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n      while (true) {\n        final IElementType tt = token();\n        if (tt == null || tt == XML_ATTRIBUTE_VALUE_END_DELIMITER || tt == XML_END_TAG_START || tt == XML_EMPTY_ELEMENT_END ||\n            tt == XML_START_TAG_START) {\n          break;\n        }\n\n        if (tt == XML_BAD_CHARACTER) {\n          final PsiBuilder.Marker error = mark();\n          advance();\n          error.error(XmlErrorMessages.message(\"unescaped.ampersand.or.nonterminated.character.entity.reference\"));\n        }\n        else if (tt == XML_ENTITY_REF_TOKEN) {\n          parseReference();\n        }\n        else {\n          advance();\n        }\n      }\n\n      if (token() == XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n        advance();\n      }\n      else {\n        error(XmlErrorMessages.message(\"xml.parsing.unclosed.attribute.value\"));\n      }\n    }\n    else {\n      error(XmlErrorMessages.message(\"xml.parsing.attribute.value.expected\"));\n    }\n\n    attValue.done(XML_ATTRIBUTE_VALUE);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseAttribute() {\n    assert token() == XML_NAME;\n    final PsiBuilder.Marker att = mark();\n    advance();\n    if (token() == XML_EQ) {\n      advance();\n      parseAttributeValue();\n      att.done(XML_ATTRIBUTE);\n    }\n    else {\n      error(\"'=' expected\");\n      att.done(XML_ATTRIBUTE);\n    }\n  }","id":77265,"modified_method":"private void parseAttribute() {\n    assert token() == XML_NAME;\n    final PsiBuilder.Marker att = mark();\n    advance();\n    if (token() == XML_EQ) {\n      advance();\n      parseAttributeValue();\n      att.done(XML_ATTRIBUTE);\n    }\n    else {\n      error(XmlErrorMessages.message(\"expected.attribute.eq.sign\"));\n      att.done(XML_ATTRIBUTE);\n    }\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker flushError(PsiBuilder.Marker error) {\n    if (error != null) {\n      error.error(\"Unexpected tokens\");\n      error = null;\n    }\n    return error;\n  }","id":77266,"modified_method":"@Nullable\n  private static PsiBuilder.Marker flushError(PsiBuilder.Marker error) {\n    if (error != null) {\n      error.error(XmlErrorMessages.message(\"xml.parsing.unexpected.tokens\"));\n      error = null;\n    }\n    return error;\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseProcessingInstruction() {\n    assert token() == XML_PI_START;\n    final PsiBuilder.Marker pi = mark();\n    advance();\n    if (token() != XML_NAME) {\n      error(\"Processing instruction name expected\");\n    }\n    else {\n      advance();\n    }\n\n    while (token() == XML_NAME) {\n      advance();\n      if (token() == XML_EQ) {\n        advance();\n      }\n      else {\n        error(\"'=' expected\");\n      }\n      parseAttributeValue();\n    }\n\n    if (token() == XML_PI_END) {\n      advance();\n    }\n    else {\n      error(\"Processing instruction not terminated\");\n    }\n\n    pi.done(XML_PROCESSING_INSTRUCTION);\n  }","id":77267,"modified_method":"private void parseProcessingInstruction() {\n    assert token() == XML_PI_START;\n    final PsiBuilder.Marker pi = mark();\n    advance();\n    if (token() != XML_NAME) {\n      error(XmlErrorMessages.message(\"xml.parsing.processing.instruction.name.expected\"));\n    }\n    else {\n      advance();\n    }\n\n    while (token() == XML_NAME) {\n      advance();\n      if (token() == XML_EQ) {\n        advance();\n      }\n      else {\n        error(XmlErrorMessages.message(\"expected.attribute.eq.sign\"));\n      }\n      parseAttributeValue();\n    }\n\n    if (token() == XML_PI_END) {\n      advance();\n    }\n    else {\n      error(XmlErrorMessages.message(\"xml.parsing.unterminated.processing.instruction\"));\n    }\n\n    pi.done(XML_PROCESSING_INSTRUCTION);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseTag(boolean multipleRootTagError) {\n    assert token() == XML_START_TAG_START : \"Tag start expected\";\n    final PsiBuilder.Marker tag = mark();\n\n    final String tagName = parseTagHeader(multipleRootTagError, tag);\n    if (tagName == null) return;\n\n    final PsiBuilder.Marker content = mark();\n    parseTagContent();\n\n    if (token() == XML_END_TAG_START) {\n      final PsiBuilder.Marker footer = mark();\n      advance();\n\n      if (token() == XML_NAME) {\n        String endName = myBuilder.getTokenText();\n        if (!tagName.equals(endName) && myTagNamesStack.contains(endName)) {\n          footer.rollbackTo();\n          myTagNamesStack.pop();\n          tag.doneBefore(XmlElementType.XML_TAG, content, \"Element \" + tagName + \" is not closed\");\n          content.drop();\n          return;\n        }\n\n        advance();\n      }\n      footer.drop();\n\n      while (token() != XmlTokenType.XML_TAG_END && token() != XmlTokenType.XML_START_TAG_START && token() != XmlTokenType.XML_END_TAG_START && !eof()) {\n        error(\"Unexpected token\");\n        advance();\n      }\n\n      if (token() == XML_TAG_END) advance();\n    }\n    else {\n      error(\"Unexpected end of file\");\n    }\n\n    content.drop();\n    myTagNamesStack.pop();\n    tag.done(XmlElementType.XML_TAG);\n  }","id":77268,"modified_method":"private void parseTag(boolean multipleRootTagError) {\n    assert token() == XML_START_TAG_START : \"Tag start expected\";\n    final PsiBuilder.Marker tag = mark();\n\n    final String tagName = parseTagHeader(multipleRootTagError, tag);\n    if (tagName == null) return;\n\n    final PsiBuilder.Marker content = mark();\n    parseTagContent();\n\n    if (token() == XML_END_TAG_START) {\n      final PsiBuilder.Marker footer = mark();\n      advance();\n\n      if (token() == XML_NAME) {\n        String endName = myBuilder.getTokenText();\n        if (!tagName.equals(endName) && myTagNamesStack.contains(endName)) {\n          footer.rollbackTo();\n          myTagNamesStack.pop();\n          tag.doneBefore(XmlElementType.XML_TAG, content, XmlErrorMessages.message(\"named.element.is.not.closed\", tagName));\n          content.drop();\n          return;\n        }\n\n        advance();\n      }\n      footer.drop();\n\n      while (token() != XmlTokenType.XML_TAG_END && token() != XmlTokenType.XML_START_TAG_START && token() != XmlTokenType.XML_END_TAG_START && !eof()) {\n        error(XmlErrorMessages.message(\"xml.parsing.unexpected.token\"));\n        advance();\n      }\n\n      if (token() == XML_TAG_END) advance();\n    }\n    else {\n      error(XmlErrorMessages.message(\"xml.parsing.unexpected.end.of.file\"));\n    }\n\n    content.drop();\n    myTagNamesStack.pop();\n    tag.done(XmlElementType.XML_TAG);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void parseDocument() {\n    final PsiBuilder.Marker document = mark();\n\n    while (isCommentToken(token())) {\n      parseComment();\n    }\n\n    parseProlog();\n\n    int rootTagCount = 0;\n    PsiBuilder.Marker error = null;\n    while (!eof()) {\n      final IElementType tt = token();\n      if (tt == XML_START_TAG_START) {\n        error = flushError(error);\n        rootTagCount++;\n        parseTag(rootTagCount > 1);\n      }\n      else if (isCommentToken(tt)) {\n        error = flushError(error);\n        parseComment();\n      }\n      else if (tt == XML_PI_START) {\n        error = flushError(error);\n        parseProcessingInstruction();\n      }\n      else if (tt == XML_REAL_WHITE_SPACE) {\n        error = flushError(error);\n        advance();\n      }\n      else {\n        if (error == null) error = mark();\n        advance();\n      }\n    }\n\n    if (error != null) {\n      error.error(\"Top element is not completed\");\n      error = null;\n    }\n\n    if (rootTagCount == 0) {\n      final PsiBuilder.Marker rootTag = mark();\n      error = mark();\n      error.error(\"Valid XML document must have a root tag\");\n      rootTag.done(XmlElementType.XML_TAG);\n    }\n\n    document.done(XmlElementType.XML_DOCUMENT);\n  }","id":77269,"modified_method":"public void parseDocument() {\n    final PsiBuilder.Marker document = mark();\n\n    while (isCommentToken(token())) {\n      parseComment();\n    }\n\n    parseProlog();\n\n    int rootTagCount = 0;\n    PsiBuilder.Marker error = null;\n    while (!eof()) {\n      final IElementType tt = token();\n      if (tt == XML_START_TAG_START) {\n        error = flushError(error);\n        rootTagCount++;\n        parseTag(rootTagCount > 1);\n      }\n      else if (isCommentToken(tt)) {\n        error = flushError(error);\n        parseComment();\n      }\n      else if (tt == XML_PI_START) {\n        error = flushError(error);\n        parseProcessingInstruction();\n      }\n      else if (tt == XML_REAL_WHITE_SPACE) {\n        error = flushError(error);\n        advance();\n      }\n      else {\n        if (error == null) error = mark();\n        advance();\n      }\n    }\n\n    if (error != null) {\n      error.error(XmlErrorMessages.message(\"top.level.element.is.not.completed\"));\n      error = null;\n    }\n\n    if (rootTagCount == 0) {\n      final PsiBuilder.Marker rootTag = mark();\n      error = mark();\n      error.error(XmlErrorMessages.message(\"xml.parsing.absent.root.tag\"));\n      rootTag.done(XmlElementType.XML_TAG);\n    }\n\n    document.done(XmlElementType.XML_DOCUMENT);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseDoctype() {\n    assert token() == XML_DOCTYPE_START : \"Doctype start expected\";\n    final PsiBuilder.Marker doctype = mark();\n    advance();\n\n    while (token() != XML_DOCTYPE_END && !eof()) advance();\n    if (eof()) {\n      error(\"Unexpected ent of file\");\n    }\n    else {\n      advance();\n    }\n\n    doctype.done(XML_DOCTYPE);\n  }","id":77270,"modified_method":"private void parseDoctype() {\n    assert token() == XML_DOCTYPE_START : \"Doctype start expected\";\n    final PsiBuilder.Marker doctype = mark();\n    advance();\n\n    while (token() != XML_DOCTYPE_END && !eof()) advance();\n    if (eof()) {\n      error(XmlErrorMessages.message(\"xml.parsing.unexpected.end.of.file\"));\n    }\n    else {\n      advance();\n    }\n\n    doctype.done(XML_DOCTYPE);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void parseComment() {\n    final PsiBuilder.Marker comment = mark();\n    advance();\n    while (true) {\n      final IElementType tt = token();\n      if (tt == XML_COMMENT_CHARACTERS) {\n        advance();\n        continue;\n      }\n      else if (tt == XML_BAD_CHARACTER) {\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(\"Bad character\");\n        continue;\n      }\n      if (tt == XML_COMMENT_END) {\n        advance();\n      }\n      break;\n    }\n    comment.done(XML_COMMENT);\n  }","id":77271,"modified_method":"protected void parseComment() {\n    final PsiBuilder.Marker comment = mark();\n    advance();\n    while (true) {\n      final IElementType tt = token();\n      if (tt == XML_COMMENT_CHARACTERS) {\n        advance();\n        continue;\n      }\n      else if (tt == XML_BAD_CHARACTER) {\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(XmlErrorMessages.message(\"xml.parsing.bad.character\"));\n        continue;\n      }\n      if (tt == XML_COMMENT_END) {\n        advance();\n      }\n      break;\n    }\n    comment.done(XML_COMMENT);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void parseTagContent() {\n    PsiBuilder.Marker xmlText = null;\n    while (token() != XML_END_TAG_START && !eof()) {\n      final IElementType tt = token();\n      if (tt == XML_START_TAG_START) {\n        xmlText = terminateText(xmlText);\n        parseTag(false);\n      }\n      else if (tt == XML_PI_START) {\n        xmlText = terminateText(xmlText);\n        parseProcessingInstruction();\n      }\n      else if (tt == XML_ENTITY_REF_TOKEN) {\n        xmlText = terminateText(xmlText);\n        parseReference();\n      }\n      else if (tt == XML_CHAR_ENTITY_REF) {\n        xmlText = startText(xmlText);\n        parseReference();\n      }\n      else if (tt == XML_CDATA_START) {\n        xmlText = startText(xmlText);\n        parseCData();\n      }\n      else if (isCommentToken(tt)) {\n        xmlText = terminateText(xmlText);\n        parseComment();\n      }\n      else if (tt == XML_BAD_CHARACTER) {\n        xmlText = startText(xmlText);\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(\"Unescaped & or nonterminated character/entity reference\");\n      }\n      else if (tt instanceof IChameleonElementType) {\n        xmlText = terminateText(xmlText);\n        advance();\n      }\n      else {\n        xmlText = startText(xmlText);\n        advance();\n      }\n    }\n\n    terminateText(xmlText);\n  }","id":77272,"modified_method":"public void parseTagContent() {\n    PsiBuilder.Marker xmlText = null;\n    while (token() != XML_END_TAG_START && !eof()) {\n      final IElementType tt = token();\n      if (tt == XML_START_TAG_START) {\n        xmlText = terminateText(xmlText);\n        parseTag(false);\n      }\n      else if (tt == XML_PI_START) {\n        xmlText = terminateText(xmlText);\n        parseProcessingInstruction();\n      }\n      else if (tt == XML_ENTITY_REF_TOKEN) {\n        xmlText = terminateText(xmlText);\n        parseReference();\n      }\n      else if (tt == XML_CHAR_ENTITY_REF) {\n        xmlText = startText(xmlText);\n        parseReference();\n      }\n      else if (tt == XML_CDATA_START) {\n        xmlText = startText(xmlText);\n        parseCData();\n      }\n      else if (isCommentToken(tt)) {\n        xmlText = terminateText(xmlText);\n        parseComment();\n      }\n      else if (tt == XML_BAD_CHARACTER) {\n        xmlText = startText(xmlText);\n        final PsiBuilder.Marker error = mark();\n        advance();\n        error.error(XmlErrorMessages.message(\"unescaped.ampersand.or.nonterminated.character.entity.reference\"));\n      }\n      else if (tt instanceof IChameleonElementType) {\n        xmlText = terminateText(xmlText);\n        advance();\n      }\n      else {\n        xmlText = startText(xmlText);\n        advance();\n      }\n    }\n\n    terminateText(xmlText);\n  }","commit_id":"54956fc937d71dbeb1ecc2a9bdd5f72d170fe0f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** invoked manually when initializing, and periodically thereafter */\n    protected synchronized void publishAndCheck(boolean initializing) {\n        publishHealth();\n        checkMaster(initializing);\n    }","id":77273,"modified_method":"/** invoked manually when initializing, and periodically thereafter */\n    @VisibleForTesting\n    public synchronized void publishAndCheck(boolean initializing) {\n        publishHealth();\n        checkMaster(initializing);\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void testGetManagementPlaneStatus() throws Exception {\n        // with the name zzzzz the mgr created here should never be promoted by the alphabetical strategy!\n        \n        tickerAdvance(Duration.FIVE_SECONDS);\n        persister.delta(ManagementPlaneSyncRecordDeltaImpl.builder()\n                .node(newManagerMemento(ownNodeId, ManagementNodeState.STANDBY))\n                .node(newManagerMemento(\"zzzzzzz_node1\", ManagementNodeState.STANDBY))\n                .build());\n        ManagementPlaneSyncRecord record = persister.loadSyncRecord();\n        long zzzTime = tickerCurrentMillis();\n        tickerAdvance(Duration.FIVE_SECONDS);\n        \n        manager.start(HighAvailabilityMode.AUTO);\n        ManagementPlaneSyncRecord memento = manager.getManagementPlaneSyncState();\n        \n        // Note can assert timestamp because not \"real\" time; it's using our own Ticker\n        assertEquals(memento.getMasterNodeId(), ownNodeId);\n        assertEquals(memento.getManagementNodes().keySet(), ImmutableSet.of(ownNodeId, \"zzzzzzz_node1\"));\n        assertEquals(memento.getManagementNodes().get(ownNodeId).getNodeId(), ownNodeId);\n        assertEquals(memento.getManagementNodes().get(ownNodeId).getStatus(), ManagementNodeState.MASTER);\n        assertEquals(memento.getManagementNodes().get(ownNodeId).getLocalTimestamp(), tickerCurrentMillis());\n        assertEquals(memento.getManagementNodes().get(\"zzzzzzz_node1\").getNodeId(), \"zzzzzzz_node1\");\n        assertEquals(memento.getManagementNodes().get(\"zzzzzzz_node1\").getStatus(), ManagementNodeState.STANDBY);\n        assertEquals(memento.getManagementNodes().get(\"zzzzzzz_node1\").getLocalTimestamp(), zzzTime);\n    }","id":77274,"modified_method":"public void testGetManagementPlaneStatus() throws Exception {\n        // with the name zzzzz the mgr created here should never be promoted by the alphabetical strategy!\n        \n        tickerAdvance(Duration.FIVE_SECONDS);\n        persister.delta(ManagementPlaneSyncRecordDeltaImpl.builder()\n                .node(newManagerMemento(ownNodeId, ManagementNodeState.STANDBY))\n                .node(newManagerMemento(\"zzzzzzz_node1\", ManagementNodeState.STANDBY))\n                .build());\n        persister.loadSyncRecord();\n        long zzzTime = tickerCurrentMillis();\n        tickerAdvance(Duration.FIVE_SECONDS);\n        \n        manager.start(HighAvailabilityMode.AUTO);\n        ManagementPlaneSyncRecord memento = manager.getManagementPlaneSyncState();\n        \n        // Note can assert timestamp because not \"real\" time; it's using our own Ticker\n        assertEquals(memento.getMasterNodeId(), ownNodeId);\n        assertEquals(memento.getManagementNodes().keySet(), ImmutableSet.of(ownNodeId, \"zzzzzzz_node1\"));\n        assertEquals(memento.getManagementNodes().get(ownNodeId).getNodeId(), ownNodeId);\n        assertEquals(memento.getManagementNodes().get(ownNodeId).getStatus(), ManagementNodeState.MASTER);\n        assertEquals(memento.getManagementNodes().get(ownNodeId).getLocalTimestamp(), tickerCurrentMillis());\n        assertEquals(memento.getManagementNodes().get(\"zzzzzzz_node1\").getNodeId(), \"zzzzzzz_node1\");\n        assertEquals(memento.getManagementNodes().get(\"zzzzzzz_node1\").getStatus(), ManagementNodeState.STANDBY);\n        assertEquals(memento.getManagementNodes().get(\"zzzzzzz_node1\").getLocalTimestamp(), zzzTime);\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public InMemoryObjectStore() {\n        log.info(\"Using memory-based objectStore\");\n    }","id":77275,"modified_method":"public InMemoryObjectStore() {\n        this(MutableMap.<String,String>of(), MutableMap.<String,Date>of());\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void deleteCompletely() {\n        listener.recordDataOut(\"deleting completely\", 1);\n        delegate.deleteCompletely();\n    }","id":77276,"modified_method":"@Override\n    public void deleteCompletely() {\n        for (ObjectStoreTransactionListener listener: listeners)\n            listener.recordDataOut(\"deleting completely\", 1);\n        delegate.deleteCompletely();\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n        public void delete() {\n            listener.recordQueryOut(\"deleting \"+path, path.length());\n            delegate.delete();\n        }","id":77277,"modified_method":"@Override\n        public void delete() {\n            if (writesFailSilently)\n                return;\n\n            for (ObjectStoreTransactionListener listener: listeners)\n                listener.recordQueryOut(\"deleting \"+path, path.length());\n            delegate.delete();\n        }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n        public void append(String s) {\n            listener.recordDataOut(\"appending \"+path, s.length());\n            delegate.append(s);\n        }","id":77278,"modified_method":"@Override\n        public void append(String s) {\n            if (writesFailSilently)\n                return;\n\n            for (ObjectStoreTransactionListener listener: listeners)\n                listener.recordDataOut(\"appending \"+path, s.length());\n            delegate.append(s);\n        }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public List<String> listContentsWithSubPath(String subPath) {\n        listener.recordQueryOut(\"requesting list \"+subPath, 1+subPath.length());\n        List<String> result = delegate.listContentsWithSubPath(subPath);\n        listener.recordDataIn(\"receiving list \"+subPath, result.toString().length());\n        return result;\n    }","id":77279,"modified_method":"@Override\n    public List<String> listContentsWithSubPath(String subPath) {\n        for (ObjectStoreTransactionListener listener: listeners)\n            listener.recordQueryOut(\"requesting list \"+subPath, 1+subPath.length());\n        \n        List<String> result = delegate.listContentsWithSubPath(subPath);\n        \n        for (ObjectStoreTransactionListener listener: listeners)\n            listener.recordDataIn(\"receiving list \"+subPath, result.toString().length());\n        return result;\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public ListeningObjectStore(PersistenceObjectStore delegate, ObjectStoreTransactionListener listener) {\n        this.delegate = Preconditions.checkNotNull(delegate);\n        this.listener = Preconditions.checkNotNull(listener);\n    }","id":77280,"modified_method":"public ListeningObjectStore(PersistenceObjectStore delegate, ObjectStoreTransactionListener ...listeners) {\n        this.delegate = Preconditions.checkNotNull(delegate);\n        for (ObjectStoreTransactionListener listener: listeners)\n            this.listeners.add(listener);\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n        public void put(String val) {\n            listener.recordDataOut(\"writing \"+path, val.length());\n            delegate.put(val);\n        }","id":77281,"modified_method":"@Override\n        public void put(String val) {\n            if (writesFailSilently)\n                return;\n\n            for (ObjectStoreTransactionListener listener: listeners)\n                listener.recordDataOut(\"writing \"+path, val.length());\n            delegate.put(val);\n        }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n        public String get() {\n            listener.recordQueryOut(\"requesting \"+path, path.length());\n            String result = delegate.get();\n            listener.recordDataIn(\"reading \"+path, result.length());\n            return result;\n        }","id":77282,"modified_method":"@Override\n        public String get() {\n            for (ObjectStoreTransactionListener listener: listeners)\n                listener.recordQueryOut(\"requesting \"+path, path.length());\n            String result = delegate.get();\n            \n            for (ObjectStoreTransactionListener listener: listeners)\n                listener.recordDataIn(\"reading \"+path, (result==null ? 0 : result.length()));\n            return result;\n        }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void createSubPath(String subPath) {\n        listener.recordQueryOut(\"creating path \"+subPath, 1+subPath.length());\n        delegate.createSubPath(subPath);\n    }","id":77283,"modified_method":"@Override\n    public void createSubPath(String subPath) {\n        if (writesFailSilently)\n            return;\n        \n        for (ObjectStoreTransactionListener listener: listeners)\n            listener.recordQueryOut(\"creating path \"+subPath, 1+subPath.length());\n        delegate.createSubPath(subPath);\n    }","commit_id":"2ed4c77e864f43d0d95ef35ddb03cb39867032f1","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"CacheManager( ManagementData management, NodeManager nodeManager, Cache cache )\n                throws NotCompliantMBeanException\n        {\n            super( management, cache.getName() );\n            this.nodeManager = nodeManager;\n            this.cache = cache;\n        }","id":77284,"modified_method":"CacheManager( ManagementData management, NodeManager nodeManager, Cache<?> cache )\n                throws NotCompliantMBeanException\n        {\n            super( management, cache.getName() );\n            this.nodeManager = nodeManager;\n            this.cache = cache;\n        }","commit_id":"ce1df8226f2bc22c8fd37dafea69ad14701b3d6f","url":"https://github.com/neo4j/neo4j"},{"original_method":"MemoryMappingImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            this.datasource = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n        }","id":77285,"modified_method":"MemoryMappingImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            this.datasource = KernelBean.getNeoDataSource( management.getKernelData() );\n        }","commit_id":"ce1df8226f2bc22c8fd37dafea69ad14701b3d6f","url":"https://github.com/neo4j/neo4j"},{"original_method":"MemoryMappingImpl( ManagementData management, boolean isMxBean )\n        {\n            super( management, isMxBean );\n            this.datasource = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n        }","id":77286,"modified_method":"MemoryMappingImpl( ManagementData management, boolean isMxBean )\n        {\n            super( management, isMxBean );\n            this.datasource = KernelBean.getNeoDataSource( management.getKernelData() );\n        }","commit_id":"ce1df8226f2bc22c8fd37dafea69ad14701b3d6f","url":"https://github.com/neo4j/neo4j"},{"original_method":"StoreFileImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            NeoStoreXaDataSource nioneodb = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n            File path;\n            try\n            {\n                path = new File( nioneodb.getStoreDir() ).getCanonicalFile().getAbsoluteFile();\n            }\n            catch ( IOException e )\n            {\n                path = new File( nioneodb.getStoreDir() ).getAbsoluteFile();\n            }\n            this.storePath = path;\n        }","id":77287,"modified_method":"StoreFileImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            NeoStoreXaDataSource nioneodb = KernelBean.getNeoDataSource( management.getKernelData() );\n            File path;\n            try\n            {\n                path = new File( nioneodb.getStoreDir() ).getCanonicalFile().getAbsoluteFile();\n            }\n            catch ( IOException e )\n            {\n                path = new File( nioneodb.getStoreDir() ).getAbsoluteFile();\n            }\n            this.storePath = path;\n        }","commit_id":"ce1df8226f2bc22c8fd37dafea69ad14701b3d6f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myFileSystem = LocalFileSystem.getInstance();\n    myTempDir = createTestDir(\"temp\");\n  }","id":77288,"modified_method":"@Before\n  public void setUp() {\n    assumeTrue(SystemInfo.areSymLinksSupported);\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDotLink() throws Exception {\n    File dotLinkFile = createSymLink(\".\", myTempDir + \"/dot_link\");\n    VirtualFile dotLinkVFile = refreshAndFind(dotLinkFile);\n    assertNotNull(dotLinkVFile);\n    assertTrue(dotLinkVFile.is(VFileProperty.SYMLINK));\n    assertTrue(dotLinkVFile.isDirectory());\n    assertPathsEqual(myTempDir.getPath(), dotLinkVFile.getCanonicalPath());\n    assertVisitedPaths(dotLinkVFile.getPath());\n  }","id":77289,"modified_method":"@Test\n  public void testDotLink() throws Exception {\n    File dotLinkFile = createSymLink(\".\", myTempDir.getRoot() + \"/dot_link\");\n    VirtualFile dotLinkVFile = refreshAndFind(dotLinkFile);\n    assertNotNull(dotLinkVFile);\n    assertTrue(dotLinkVFile.is(VFileProperty.SYMLINK));\n    assertTrue(dotLinkVFile.isDirectory());\n    assertPathsEqual(myTempDir.getRoot().getPath(), dotLinkVFile.getCanonicalPath());\n    assertVisitedPaths(dotLinkVFile.getPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testTraversePathBehindLink() throws Exception {\n    File topDir = createTestDir(myTempDir, \"top\");\n    File subDir1 = createTestDir(topDir, \"sub1\");\n    File link = createSymLink(subDir1.getPath(), myTempDir + \"/link\");\n    VirtualFile vLink = refreshAndFind(link);\n    assertNotNull(link.getPath(), vLink);\n\n    File subDir2 = createTestDir(topDir, \"sub2\");\n    File subChild = createTestFile(subDir2, \"subChild.txt\");\n    VirtualFile vSubChild = refreshAndFind(subChild);\n    assertNotNull(subChild.getPath(), vSubChild);\n\n    String relPath = \"../\" + subDir2.getName() + \"/\" + subChild.getName();\n    VirtualFile vSubChildRel;\n    vSubChildRel = vLink.findFileByRelativePath(relPath);\n    assertEquals(vSubChild, vSubChildRel);\n    vSubChildRel = LocalFileSystem.getInstance().findFileByPath(vLink.getPath() + \"/\" + relPath);\n    assertEquals(vSubChild, vSubChildRel);\n  }","id":77290,"modified_method":"@Test\n  public void testTraversePathBehindLink() throws Exception {\n    File topDir = myTempDir.newFolder(\"top\");\n    File subDir1 = createTestDir(topDir, \"sub1\");\n    File link = createSymLink(subDir1.getPath(), myTempDir.getRoot() + \"/link\");\n    VirtualFile vLink = refreshAndFind(link);\n    assertNotNull(link.getPath(), vLink);\n\n    File subDir2 = createTestDir(topDir, \"sub2\");\n    File subChild = createTestFile(subDir2, \"subChild.txt\");\n    VirtualFile vSubChild = refreshAndFind(subChild);\n    assertNotNull(subChild.getPath(), vSubChild);\n\n    String relPath = \"../\" + subDir2.getName() + \"/\" + subChild.getName();\n    VirtualFile vSubChildRel;\n    vSubChildRel = vLink.findFileByRelativePath(relPath);\n    assertEquals(vSubChild, vSubChildRel);\n    vSubChildRel = LocalFileSystem.getInstance().findFileByPath(vLink.getPath() + \"/\" + relPath);\n    assertEquals(vSubChild, vSubChildRel);\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSelfLink() throws Exception {\n    String target = new File(myTempDir.getPath(), \"self_link\").getPath();\n    File selfLinkFile = createSymLink(target, target, false);\n    VirtualFile selfLinkVFile = refreshAndFind(selfLinkFile);\n    assertNotNull(selfLinkVFile);\n    assertBrokenLink(selfLinkVFile);\n    assertVisitedPaths(selfLinkVFile.getPath());\n  }","id":77291,"modified_method":"@Test\n  public void testSelfLink() throws Exception {\n    String target = new File(myTempDir.getRoot(), \"self_link\").getPath();\n    File selfLinkFile = createSymLink(target, target, false);\n    VirtualFile selfLinkVFile = refreshAndFind(selfLinkFile);\n    assertNotNull(selfLinkVFile);\n    assertBrokenLink(selfLinkVFile);\n    assertVisitedPaths(selfLinkVFile.getPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFileLinkSwitch() throws Exception {\n    File target1 = createTestFile(myTempDir, \"target1.txt\");\n    FileUtil.writeToFile(target1, \"some text\");\n    File target2 = createTestFile(myTempDir, \"target2.txt\");\n    FileUtil.writeToFile(target2, \"some quite another text\");\n\n    File link = createSymLink(target1.getPath(), myTempDir + \"/link\");\n    VirtualFile vLink1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink1,\n               vLink1 != null && !vLink1.isDirectory() && vLink1.is(VFileProperty.SYMLINK));\n    assertEquals(FileUtil.loadFile(target1), VfsUtilCore.loadText(vLink1));\n    assertPathsEqual(target1.getPath(), vLink1.getCanonicalPath());\n\n    assertTrue(link.toString(), link.delete());\n    createSymLink(target2.getPath(), myTempDir + \"/\" + link.getName());\n\n    refresh();\n    assertTrue(vLink1.isValid());\n    VirtualFile vLink2 = myFileSystem.findFileByIoFile(link);\n    assertEquals(vLink1, vLink2);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink2,\n               vLink2 != null && !vLink2.isDirectory() && vLink2.is(VFileProperty.SYMLINK));\n    assertEquals(FileUtil.loadFile(target2), VfsUtilCore.loadText(vLink2));\n    assertPathsEqual(target2.getPath(), vLink1.getCanonicalPath());\n  }","id":77292,"modified_method":"@Test\n  public void testFileLinkSwitch() throws Exception {\n    File target1 = myTempDir.newFile(\"target1.txt\");\n    FileUtil.writeToFile(target1, \"some text\");\n    File target2 = myTempDir.newFile(\"target2.txt\");\n    FileUtil.writeToFile(target2, \"some quite another text\");\n\n    File link = createSymLink(target1.getPath(), myTempDir.getRoot() + \"/link\");\n    VirtualFile vLink1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink1,\n               vLink1 != null && !vLink1.isDirectory() && vLink1.is(VFileProperty.SYMLINK));\n    assertEquals(FileUtil.loadFile(target1), VfsUtilCore.loadText(vLink1));\n    assertPathsEqual(target1.getPath(), vLink1.getCanonicalPath());\n\n    assertTrue(link.toString(), link.delete());\n    createSymLink(target2.getPath(), myTempDir.getRoot() + \"/\" + link.getName());\n\n    refresh();\n    assertTrue(vLink1.isValid());\n    VirtualFile vLink2 = LocalFileSystem.getInstance().findFileByIoFile(link);\n    assertEquals(vLink1, vLink2);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink2,\n               vLink2 != null && !vLink2.isDirectory() && vLink2.is(VFileProperty.SYMLINK));\n    assertEquals(FileUtil.loadFile(target2), VfsUtilCore.loadText(vLink2));\n    assertPathsEqual(target2.getPath(), vLink1.getCanonicalPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testVisitAllNonRecursiveLinks() throws Exception {\n    File target = createTestDir(myTempDir, \"target\");\n    File child = createTestDir(target, \"child\");\n    File link1 = createSymLink(target.getPath(), myTempDir.getPath() + \"/link1\");\n    File link2 = createSymLink(target.getPath(), myTempDir.getPath() + \"/link2\");\n    assertVisitedPaths(target.getPath(), child.getPath(),\n                       link1.getPath(), link1.getPath() + \"/child\",\n                       link2.getPath(), link2.getPath() + \"/child\");\n  }","id":77293,"modified_method":"@Test\n  public void testVisitAllNonRecursiveLinks() throws Exception {\n    File target = myTempDir.newFolder(\"target\");\n    File child = createTestDir(target, \"child\");\n    File link1 = createSymLink(target.getPath(), myTempDir.getRoot() + \"/link1\");\n    File link2 = createSymLink(target.getPath(), myTempDir.getRoot() + \"/link2\");\n    assertVisitedPaths(target.getPath(), child.getPath(),\n                       link1.getPath(), link1.getPath() + \"/child\",\n                       link2.getPath(), link2.getPath() + \"/child\");\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void assertVisitedPaths(File from, String... expected) {\n    VirtualFile vDir = refreshAndFind(from);\n    assertNotNull(vDir);\n\n    Set<String> expectedSet = ContainerUtil.map2Set(expected, new Function<String, String>() {\n      @Override\n      public String fun(String path) {\n        return FileUtil.toSystemIndependentName(path);\n      }\n    });\n    expectedSet.add(vDir.getPath());\n\n    final Set<String> actualSet = new HashSet<String>();\n    VfsUtilCore.visitChildrenRecursively(vDir, new VirtualFileVisitor() {\n      @Override\n      public boolean visitFile(@NotNull VirtualFile file) {\n        actualSet.add(file.getPath());\n        return true;\n      }\n    });\n\n    assertEquals(expectedSet, actualSet);\n  }","id":77294,"modified_method":"private void assertVisitedPaths(File from, String... expected) {\n    VirtualFile vDir = refreshAndFind(from);\n    assertNotNull(vDir);\n\n    Set<String> expectedSet =\n      Stream.concat(Stream.of(expected).map(FileUtil::toSystemIndependentName), Stream.of(vDir.getPath())).collect(Collectors.toSet());\n\n    Set<String> actualSet = new java.util.HashSet<>();\n    VfsUtilCore.visitChildrenRecursively(vDir, new VirtualFileVisitor() {\n      @Override\n      public boolean visitFile(@NotNull VirtualFile file) {\n        actualSet.add(file.getPath());\n        return true;\n      }\n    });\n\n    assertEquals(expectedSet, actualSet);\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testTransGenderRefresh() throws Exception {\n    File targetFile = createTestFile(myTempDir, \"target\");\n    File targetDir = createTestDir(myTempDir, \"targetDir\");\n\n    // file link\n    File link = createSymLink(targetFile.getPath(), myTempDir + \"/link\");\n    VirtualFile vFile1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               vFile1 != null && !vFile1.isDirectory() && vFile1.is(VFileProperty.SYMLINK));\n\n    // file link => dir\n    assertTrue(link.getPath(), link.delete() && link.mkdir() && link.isDirectory());\n    VirtualFile vFile2 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile2,\n               !vFile1.isValid() && vFile2 != null && vFile2.isDirectory() && !vFile2.is(VFileProperty.SYMLINK));\n\n    // dir => dir link\n    assertTrue(link.getPath(), link.delete());\n    link = createSymLink(targetDir.getPath(), myTempDir + \"/link\");\n    vFile1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               !vFile2.isValid() && vFile1 != null && vFile1.isDirectory() && vFile1.is(VFileProperty.SYMLINK));\n\n    // dir link => file\n    assertTrue(link.getPath(), link.delete() && link.createNewFile() && link.isFile());\n    vFile2 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               !vFile1.isValid() && vFile2 != null && !vFile2.isDirectory() && !vFile2.is(VFileProperty.SYMLINK));\n\n    // file => file link\n    assertTrue(link.getPath(), link.delete());\n    link = createSymLink(targetFile.getPath(), myTempDir + \"/link\");\n    vFile1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               !vFile2.isValid() && vFile1 != null && !vFile1.isDirectory() && vFile1.is(VFileProperty.SYMLINK));\n  }","id":77295,"modified_method":"@Test\n  public void testTransGenderRefresh() throws Exception {\n    File targetFile = myTempDir.newFile(\"target\");\n    File targetDir = myTempDir.newFolder(\"targetDir\");\n\n    // file link\n    File link = createSymLink(targetFile.getPath(), myTempDir.getRoot() + \"/link\");\n    VirtualFile vFile1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               vFile1 != null && !vFile1.isDirectory() && vFile1.is(VFileProperty.SYMLINK));\n\n    // file link => dir\n    assertTrue(link.getPath(), link.delete() && link.mkdir() && link.isDirectory());\n    VirtualFile vFile2 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile2,\n               !vFile1.isValid() && vFile2 != null && vFile2.isDirectory() && !vFile2.is(VFileProperty.SYMLINK));\n\n    // dir => dir link\n    assertTrue(link.getPath(), link.delete());\n    link = createSymLink(targetDir.getPath(), myTempDir.getRoot() + \"/link\");\n    vFile1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               !vFile2.isValid() && vFile1 != null && vFile1.isDirectory() && vFile1.is(VFileProperty.SYMLINK));\n\n    // dir link => file\n    assertTrue(link.getPath(), link.delete() && link.createNewFile() && link.isFile());\n    vFile2 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               !vFile1.isValid() && vFile2 != null && !vFile2.isDirectory() && !vFile2.is(VFileProperty.SYMLINK));\n\n    // file => file link\n    assertTrue(link.getPath(), link.delete());\n    link = createSymLink(targetFile.getPath(), myTempDir.getRoot() + \"/link\");\n    vFile1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vFile1,\n               !vFile2.isValid() && vFile1 != null && !vFile1.isDirectory() && vFile1.is(VFileProperty.SYMLINK));\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void refresh() {\n    assertTrue(myTempDir.getPath(), myTempDir.isDirectory() || myTempDir.mkdirs());\n\n    VirtualFile tempDir = myFileSystem.refreshAndFindFileByIoFile(myTempDir);\n    assertNotNull(myTempDir.getPath(), tempDir);\n\n    tempDir.getChildren();\n    tempDir.refresh(false, true);\n    VfsUtilCore.visitChildrenRecursively(tempDir, new VirtualFileVisitor() { });\n  }","id":77296,"modified_method":"protected void refresh() {\n    VirtualFile tempDir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myTempDir.getRoot());\n    assertNotNull(myTempDir.getRoot().getPath(), tempDir);\n\n    tempDir.getChildren();\n    tempDir.refresh(false, true);\n    VfsUtilCore.visitChildrenRecursively(tempDir, new VirtualFileVisitor() { });\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void assertVisitedPaths(String... expected) {\n    assertVisitedPaths(myTempDir, expected);\n  }","id":77297,"modified_method":"private void assertVisitedPaths(String... expected) {\n    assertVisitedPaths(myTempDir.getRoot(), expected);\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDirLinkSwitch() throws Exception {\n    File targetDir1 = createTestDir(myTempDir, \"target1\");\n    File targetDir2 = createTestDir(myTempDir, \"target2\");\n    assertTrue(new File(targetDir1, \"child1.txt\").createNewFile());\n    assertTrue(new File(targetDir2, \"child11.txt\").createNewFile());\n    assertTrue(new File(targetDir2, \"child12.txt\").createNewFile());\n\n    File link = createSymLink(targetDir1.getPath(), myTempDir + \"/link\");\n    VirtualFile vLink1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink1,\n               vLink1 != null && vLink1.isDirectory() && vLink1.is(VFileProperty.SYMLINK));\n    assertEquals(1, vLink1.getChildren().length);\n    assertPathsEqual(targetDir1.getPath(), vLink1.getCanonicalPath());\n\n    assertTrue(link.toString(), link.delete());\n    createSymLink(targetDir2.getPath(), myTempDir + \"/\" + link.getName());\n\n    refresh();\n    assertTrue(vLink1.isValid());\n    VirtualFile vLink2 = myFileSystem.findFileByIoFile(link);\n    assertEquals(vLink1, vLink2);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink2,\n               vLink2 != null && vLink2.isDirectory() && vLink2.is(VFileProperty.SYMLINK));\n    assertEquals(2, vLink2.getChildren().length);\n    assertPathsEqual(targetDir2.getPath(), vLink1.getCanonicalPath());\n  }","id":77298,"modified_method":"@Test\n  public void testDirLinkSwitch() throws Exception {\n    File targetDir1 = myTempDir.newFolder(\"target1\");\n    File targetDir2 = myTempDir.newFolder(\"target2\");\n    assertTrue(new File(targetDir1, \"child1.txt\").createNewFile());\n    assertTrue(new File(targetDir2, \"child11.txt\").createNewFile());\n    assertTrue(new File(targetDir2, \"child12.txt\").createNewFile());\n\n    File link = createSymLink(targetDir1.getPath(), myTempDir.getRoot() + \"/link\");\n    VirtualFile vLink1 = refreshAndFind(link);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink1,\n               vLink1 != null && vLink1.isDirectory() && vLink1.is(VFileProperty.SYMLINK));\n    assertEquals(1, vLink1.getChildren().length);\n    assertPathsEqual(targetDir1.getPath(), vLink1.getCanonicalPath());\n\n    assertTrue(link.toString(), link.delete());\n    createSymLink(targetDir2.getPath(), myTempDir.getRoot() + \"/\" + link.getName());\n\n    refresh();\n    assertTrue(vLink1.isValid());\n    VirtualFile vLink2 = LocalFileSystem.getInstance().findFileByIoFile(link);\n    assertEquals(vLink1, vLink2);\n    assertTrue(\"link=\" + link + \", vLink=\" + vLink2,\n               vLink2 != null && vLink2.isDirectory() && vLink2.is(VFileProperty.SYMLINK));\n    assertEquals(2, vLink2.getChildren().length);\n    assertPathsEqual(targetDir2.getPath(), vLink1.getCanonicalPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMissingLink() throws Exception {\n    File missingFile = new File(myTempDir, \"missing_file\");\n    assertTrue(missingFile.getPath(), !missingFile.exists() || missingFile.delete());\n    File missingLinkFile = createSymLink(missingFile.getPath(), myTempDir.getPath() + \"/missing_link\", false);\n    VirtualFile missingLinkVFile = refreshAndFind(missingLinkFile);\n    assertNotNull(missingLinkVFile);\n    assertBrokenLink(missingLinkVFile);\n    assertVisitedPaths(missingLinkVFile.getPath());\n  }","id":77299,"modified_method":"@Test\n  public void testMissingLink() throws Exception {\n    File missingFile = new File(myTempDir.getRoot(), \"missing_file\");\n    assertTrue(missingFile.getPath(), !missingFile.exists() || missingFile.delete());\n    File missingLinkFile = createSymLink(missingFile.getPath(), myTempDir.getRoot() + \"/missing_link\", false);\n    VirtualFile missingLinkVFile = refreshAndFind(missingLinkFile);\n    assertNotNull(missingLinkVFile);\n    assertBrokenLink(missingLinkVFile);\n    assertVisitedPaths(missingLinkVFile.getPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCircularLink() throws Exception {\n    File upDir = createTestDir(myTempDir, \"sub\");\n    File upLinkFile = createSymLink(upDir.getPath(), upDir.getPath() + \"/up_link\");\n    VirtualFile upLinkVFile = refreshAndFind(upLinkFile);\n    assertNotNull(upLinkVFile);\n    assertTrue(upLinkVFile.is(VFileProperty.SYMLINK));\n    assertTrue(upLinkVFile.isDirectory());\n    assertPathsEqual(upDir.getPath(), upLinkVFile.getCanonicalPath());\n    assertVisitedPaths(upDir.getPath(), upLinkVFile.getPath());\n\n    File repeatedLinksFile = new File(upDir.getPath() + StringUtil.repeat(File.separator + upLinkFile.getName(), 4));\n    assertTrue(repeatedLinksFile.getPath(), repeatedLinksFile.isDirectory());\n    VirtualFile repeatedLinksVFile = refreshAndFind(repeatedLinksFile);\n    assertNotNull(repeatedLinksFile.getPath(), repeatedLinksVFile);\n    assertTrue(repeatedLinksVFile.is(VFileProperty.SYMLINK));\n    assertTrue(repeatedLinksVFile.isDirectory());\n    assertPathsEqual(upDir.getPath(), repeatedLinksVFile.getCanonicalPath());\n    assertEquals(upLinkVFile.getCanonicalFile(), repeatedLinksVFile.getCanonicalFile());\n  }","id":77300,"modified_method":"@Test\n  public void testCircularLink() throws Exception {\n    File upDir = myTempDir.newFolder(\"sub\");\n    File upLinkFile = createSymLink(upDir.getPath(), upDir.getPath() + \"/up_link\");\n    VirtualFile upLinkVFile = refreshAndFind(upLinkFile);\n    assertNotNull(upLinkVFile);\n    assertTrue(upLinkVFile.is(VFileProperty.SYMLINK));\n    assertTrue(upLinkVFile.isDirectory());\n    assertPathsEqual(upDir.getPath(), upLinkVFile.getCanonicalPath());\n    assertVisitedPaths(upDir.getPath(), upLinkVFile.getPath());\n\n    File repeatedLinksFile = new File(upDir.getPath() + StringUtil.repeat(File.separator + upLinkFile.getName(), 4));\n    assertTrue(repeatedLinksFile.getPath(), repeatedLinksFile.isDirectory());\n    VirtualFile repeatedLinksVFile = refreshAndFind(repeatedLinksFile);\n    assertNotNull(repeatedLinksFile.getPath(), repeatedLinksVFile);\n    assertTrue(repeatedLinksVFile.is(VFileProperty.SYMLINK));\n    assertTrue(repeatedLinksVFile.isDirectory());\n    assertPathsEqual(upDir.getPath(), repeatedLinksVFile.getCanonicalPath());\n    assertEquals(upLinkVFile.getCanonicalFile(), repeatedLinksVFile.getCanonicalFile());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile refreshAndFind(File ioFile) {\n    refresh();\n    return myFileSystem.findFileByPath(ioFile.getPath());\n  }","id":77301,"modified_method":"@Nullable\n  private VirtualFile refreshAndFind(File ioFile) {\n    refresh();\n    return LocalFileSystem.getInstance().findFileByPath(ioFile.getPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testTargetIsWritable() throws Exception {\n    File targetFile = createTestFile(myTempDir, \"target.txt\");\n    File linkFile = createSymLink(targetFile.getPath(), myTempDir + \"/link\");\n    VirtualFile linkVFile = refreshAndFind(linkFile);\n    assertTrue(\"link=\" + linkFile + \", vLink=\" + linkVFile, linkVFile != null && !linkVFile.isDirectory() &&\n                                                            linkVFile.is(VFileProperty.SYMLINK));\n\n    setWritableAndCheck(targetFile, true);\n    refresh();\n    assertTrue(linkVFile.getPath(), linkVFile.isWritable());\n    setWritableAndCheck(targetFile, false);\n    refresh();\n    assertFalse(linkVFile.getPath(), linkVFile.isWritable());\n\n    File targetDir = createTestDir(myTempDir, \"target\");\n    File linkDir = createSymLink(targetDir.getPath(), myTempDir + \"/linkDir\");\n    VirtualFile linkVDir = refreshAndFind(linkDir);\n    assertTrue(\"link=\" + linkDir + \", vLink=\" + linkVDir, linkVDir != null && linkVDir.isDirectory() && linkVDir.is(VFileProperty.SYMLINK));\n\n    if (!SystemInfo.isWindows) {\n      setWritableAndCheck(targetDir, true);\n      refresh();\n      assertTrue(linkVDir.getPath(), linkVDir.isWritable());\n      setWritableAndCheck(targetDir, false);\n      refresh();\n      assertFalse(linkVDir.getPath(), linkVDir.isWritable());\n    }\n    else {\n      assertEquals(linkVDir.getPath(), targetDir.canWrite(), linkVDir.isWritable());\n    }\n  }","id":77302,"modified_method":"@Test\n  public void testTargetIsWritable() throws Exception {\n    File targetFile = myTempDir.newFile(\"target.txt\");\n    File linkFile = createSymLink(targetFile.getPath(), myTempDir.getRoot() + \"/link\");\n    VirtualFile linkVFile = refreshAndFind(linkFile);\n    assertTrue(\"link=\" + linkFile + \", vLink=\" + linkVFile, linkVFile != null && !linkVFile.isDirectory() &&\n                                                            linkVFile.is(VFileProperty.SYMLINK));\n\n    setWritableAndCheck(targetFile, true);\n    refresh();\n    assertTrue(linkVFile.getPath(), linkVFile.isWritable());\n    setWritableAndCheck(targetFile, false);\n    refresh();\n    assertFalse(linkVFile.getPath(), linkVFile.isWritable());\n\n    File targetDir = myTempDir.newFolder(\"target\");\n    File linkDir = createSymLink(targetDir.getPath(), myTempDir.getRoot() + \"/linkDir\");\n    VirtualFile linkVDir = refreshAndFind(linkDir);\n    assertTrue(\"link=\" + linkDir + \", vLink=\" + linkVDir, linkVDir != null && linkVDir.isDirectory() && linkVDir.is(VFileProperty.SYMLINK));\n\n    if (!SystemInfo.isWindows) {\n      setWritableAndCheck(targetDir, true);\n      refresh();\n      assertTrue(linkVDir.getPath(), linkVDir.isWritable());\n      setWritableAndCheck(targetDir, false);\n      refresh();\n      assertFalse(linkVDir.getPath(), linkVDir.isWritable());\n    }\n    else {\n      assertEquals(linkVDir.getPath(), targetDir.canWrite(), linkVDir.isWritable());\n    }\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSidewaysRecursiveLink() throws Exception {\n    File target = createTestDir(myTempDir, \"dir_a\");\n    File link1Home = createTestDir(target, \"dir_b\");\n    File link1 = createSymLink(SystemInfo.isWindows ? target.getPath() : \"../../\" + target.getName(), link1Home.getPath() + \"/link1\");\n    File mainDir = createTestDir(myTempDir, \"project\");\n    File subDir = createTestDir(mainDir, \"dir_c\");\n    File link2Home = createTestDir(subDir, \"dir_d\");\n    File link2 = createSymLink(SystemInfo.isWindows ? target.getPath() : \"../../../\" + target.getName(), link2Home.getPath() + \"/link2\");\n    assertVisitedPaths(mainDir,\n                       subDir.getPath(), link2Home.getPath(), link2.getPath(), link2.getPath() + \"/\" + link1Home.getName(),\n                       link2.getPath() + \"/\" + link1Home.getName() + \"/\" + link1.getName());\n  }","id":77303,"modified_method":"@Test\n  public void testSidewaysRecursiveLink() throws Exception {\n    File target = myTempDir.newFolder(\"dir_a\");\n    File link1Home = createTestDir(target, \"dir_b\");\n    File link1 = createSymLink(SystemInfo.isWindows ? target.getPath() : \"../../\" + target.getName(), link1Home.getPath() + \"/link1\");\n    File mainDir = myTempDir.newFolder(\"project\");\n    File subDir = createTestDir(mainDir, \"dir_c\");\n    File link2Home = createTestDir(subDir, \"dir_d\");\n    File link2 = createSymLink(SystemInfo.isWindows ? target.getPath() : \"../../../\" + target.getName(), link2Home.getPath() + \"/link2\");\n    assertVisitedPaths(mainDir,\n                       subDir.getPath(), link2Home.getPath(), link2.getPath(), link2.getPath() + \"/\" + link1Home.getName(),\n                       link2.getPath() + \"/\" + link1Home.getName() + \"/\" + link1.getName());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMutualRecursiveLinks() throws Exception {\n    File circularDir1 = createTestDir(myTempDir, \"dir1\");\n    File circularDir2 = createTestDir(myTempDir, \"dir2\");\n    File circularLink1 = createSymLink(circularDir2.getPath(), circularDir1 + \"/link1\");\n    File circularLink2 = createSymLink(circularDir1.getPath(), circularDir2 + \"/link2\");\n    VirtualFile circularLink1VFile = refreshAndFind(circularLink1);\n    VirtualFile circularLink2VFile = refreshAndFind(circularLink2);\n    assertNotNull(circularLink1VFile);\n    assertNotNull(circularLink2VFile);\n    assertVisitedPaths(circularDir1.getPath(), circularLink1.getPath(), circularLink1.getPath() + \"/\" + circularLink2.getName(),\n                       circularDir2.getPath(), circularLink2.getPath(), circularLink2.getPath() + \"/\" + circularLink1.getName());\n  }","id":77304,"modified_method":"@Test\n  public void testMutualRecursiveLinks() throws Exception {\n    File circularDir1 = myTempDir.newFolder(\"dir1\");\n    File circularDir2 = myTempDir.newFolder(\"dir2\");\n    File circularLink1 = createSymLink(circularDir2.getPath(), circularDir1 + \"/link1\");\n    File circularLink2 = createSymLink(circularDir1.getPath(), circularDir2 + \"/link2\");\n    VirtualFile circularLink1VFile = refreshAndFind(circularLink1);\n    VirtualFile circularLink2VFile = refreshAndFind(circularLink2);\n    assertNotNull(circularLink1VFile);\n    assertNotNull(circularLink2VFile);\n    assertVisitedPaths(circularDir1.getPath(), circularLink1.getPath(), circularLink1.getPath() + \"/\" + circularLink2.getName(),\n                       circularDir2.getPath(), circularLink2.getPath(), circularLink2.getPath() + \"/\" + circularLink1.getName());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testLinkDeleteIsSafe() throws Exception {\n    File targetFile = createTestFile(myTempDir, \"target\");\n    File linkFile = createSymLink(targetFile.getPath(), myTempDir + \"/link\");\n    VirtualFile linkVFile = refreshAndFind(linkFile);\n    assertTrue(\"link=\" + linkFile + \", vLink=\" + linkVFile, linkVFile != null && !linkVFile.isDirectory() &&\n                                                            linkVFile.is(VFileProperty.SYMLINK));\n\n    AccessToken token = ApplicationManager.getApplication().acquireWriteActionLock(getClass());\n    try {\n      linkVFile.delete(this);\n    }\n    finally {\n      token.finish();\n    }\n    assertFalse(linkVFile.toString(), linkVFile.isValid());\n    assertFalse(linkFile.exists());\n    assertTrue(targetFile.exists());\n\n    File targetDir = createTestDir(myTempDir, \"targetDir\");\n    File childFile = new File(targetDir, \"child.txt\");\n    assertTrue(childFile.getPath(), childFile.exists() || childFile.createNewFile());\n    File linkDir = createSymLink(targetDir.getPath(), myTempDir + \"/linkDir\");\n    VirtualFile linkVDir = refreshAndFind(linkDir);\n    assertTrue(\"link=\" + linkDir + \", vLink=\" + linkVDir,\n               linkVDir != null && linkVDir.isDirectory() && linkVDir.is(VFileProperty.SYMLINK) && linkVDir.getChildren().length == 1);\n\n    token = ApplicationManager.getApplication().acquireWriteActionLock(getClass());\n    try {\n      linkVDir.delete(this);\n    }\n    finally {\n      token.finish();\n    }\n    assertFalse(linkVDir.toString(), linkVDir.isValid());\n    assertFalse(linkDir.exists());\n    assertTrue(targetDir.exists());\n    assertTrue(childFile.exists());\n  }","id":77305,"modified_method":"@Test\n  public void testLinkDeleteIsSafe() throws Exception {\n    File targetFile = myTempDir.newFile(\"target\");\n    File linkFile = createSymLink(targetFile.getPath(), myTempDir.getRoot() + \"/link\");\n    VirtualFile linkVFile = refreshAndFind(linkFile);\n    assertTrue(\"link=\" + linkFile + \", vLink=\" + linkVFile,\n               linkVFile != null && !linkVFile.isDirectory() && linkVFile.is(VFileProperty.SYMLINK));\n\n    new WriteAction() {\n      @Override\n      protected void run(@NotNull Result result) throws Throwable {\n        linkVFile.delete(SymlinkHandlingTest.this);\n      }\n    }.execute();\n    assertFalse(linkVFile.toString(), linkVFile.isValid());\n    assertFalse(linkFile.exists());\n    assertTrue(targetFile.exists());\n\n    File targetDir = myTempDir.newFolder(\"targetDir\");\n    File childFile = new File(targetDir, \"child.txt\");\n    assertTrue(childFile.getPath(), childFile.exists() || childFile.createNewFile());\n    File linkDir = createSymLink(targetDir.getPath(), myTempDir.getRoot() + \"/linkDir\");\n    VirtualFile linkVDir = refreshAndFind(linkDir);\n    assertTrue(\"link=\" + linkDir + \", vLink=\" + linkVDir,\n               linkVDir != null && linkVDir.isDirectory() && linkVDir.is(VFileProperty.SYMLINK) && linkVDir.getChildren().length == 1);\n\n    new WriteAction() {\n      @Override\n      protected void run(@NotNull Result result) throws Throwable {\n        linkVDir.delete(SymlinkHandlingTest.this);\n      }\n    }.execute();\n    assertFalse(linkVDir.toString(), linkVDir.isValid());\n    assertFalse(linkDir.exists());\n    assertTrue(targetDir.exists());\n    assertTrue(childFile.exists());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDuplicateLinks() throws Exception {\n    File targetDir = createTestDir(myTempDir, \"target\");\n    File link1 = createSymLink(targetDir.getPath(), myTempDir + \"/link1\");\n    File link2 = createSymLink(targetDir.getPath(), myTempDir + \"/link2\");\n    assertVisitedPaths(targetDir.getPath(), link1.getPath(), link2.getPath());\n  }","id":77306,"modified_method":"@Test\n  public void testDuplicateLinks() throws Exception {\n    File targetDir = myTempDir.newFolder(\"target\");\n    File link1 = createSymLink(targetDir.getPath(), myTempDir.getRoot() + \"/link1\");\n    File link2 = createSymLink(targetDir.getPath(), myTempDir.getRoot() + \"/link2\");\n    assertVisitedPaths(targetDir.getPath(), link1.getPath(), link2.getPath());\n  }","commit_id":"50101ef02d4bdc91ffa8a49c4353ff7ae7e00440","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"boolean doDiagnostics(Frame ftrain, Frame ftest, long timeStart, Key dest_key) {\n    epoch_counter = (float)model_info().get_processed_total()/data_info._adaptedFrame.numRows();\n    boolean keep_running = (epoch_counter < model_info().parameters.epochs);\n    final long now = System.currentTimeMillis();\n    final long sinceLastScore = now-_timeLastScoreStart;\n    final long sinceLastPrint = now-_timeLastPrint;\n    if( (sinceLastPrint > 5000) ) {\n      final long samples = model_info().get_processed_total();\n      Log.info(\"Training time: \" + PrettyPrint.msecs(now - timeStart, true)\n              + \" processed \" + samples + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n              + \" Speed: \" + String.format(\"%.3f\", (double)samples/((now - timeStart)/1000.)) + \" samples/sec.\");\n      _timeLastPrint = now;\n    }\n    // this is potentially slow - only do every so often\n    if( !keep_running || (now-timeStart < 30000) // Score every time for first 30 seconds\n            || (sinceLastScore > model_info().parameters.score_interval*1000) ) {\n      if (model_info.parameters.diagnostics) computeDiagnostics();\n      _timeLastScoreStart = now;\n      long timeStart2 = System.currentTimeMillis();\n      classificationError(ftrain, \"Classification error on training data:\", true);\n      if (ftest != null)\n        classificationError(ftest, \"Classification error on validation data:\", true);\n      Log.info(\"scoring time: \" + PrettyPrint.msecs(System.currentTimeMillis() - timeStart2, true));\n    }\n    if (model_info().unstable()) {\n      Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n      Log.err(\"Try using L1/L2/max_w2 regularization, a different activation function, or more synchronization in multi-node operation.\");\n      keep_running = false;\n    }\n    update(dest_key); //update model in UKV\n//    System.out.println(this);\n    return keep_running;\n  }","id":77307,"modified_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param timeStart start time in milliseconds, used to report training speed\n   * @param dest_key where to store the model with the diagnostics in it\n   * @return true if model building is ongoing\n   */\n  boolean doDiagnostics(Frame ftrain, Frame ftest, long timeStart, Key dest_key) {\n    epoch_counter = (float)model_info().get_processed_total()/data_info._adaptedFrame.numRows();\n    run_time = (System.currentTimeMillis()-start_time);\n    boolean keep_running = (epoch_counter < model_info().parameters.epochs);\n    final long now = System.currentTimeMillis();\n    final long sinceLastScore = now-_timeLastScoreStart;\n    final long sinceLastPrint = now-_timeLastPrint;\n    if( (sinceLastPrint > 5000) ) {\n      final long samples = model_info().get_processed_total();\n      Log.info(\"Training time: \" + PrettyPrint.msecs(now - timeStart, true)\n              + \" processed \" + samples + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n              + \" Speed: \" + String.format(\"%.3f\", (double)samples/((now - timeStart)/1000.)) + \" samples/sec.\");\n      _timeLastPrint = now;\n    }\n    // this is potentially slow - only do every so often\n    if( !keep_running || (now-timeStart < 30000) // Score every time for first 30 seconds\n            || (sinceLastScore > model_info().parameters.score_interval*1000) ) {\n      _timeLastScoreStart = now;\n      if (model_info().parameters.diagnostics)\n        model_info.computeStats();\n      Errors err = new Errors();\n      err.training_time_ms = now - timeStart;\n      err.validation = ftest != null;\n      err.training_samples = model_info().get_processed_total();\n      err.train_confusion_matrix = new ConfusionMatrix();\n      err.train_err = classificationError(ftrain, \"Classification error on training data:\", true, err.train_confusion_matrix);\n      if (ftest != null) {\n        err.valid_confusion_matrix = new ConfusionMatrix();\n        err.valid_err = classificationError(ftest, \"Classification error on validation data:\", true, err.valid_confusion_matrix);\n      }\n\n      // enlarge the error array by one, push latest score back\n      if (errors == null) {\n         errors = new Errors[]{err};\n      } else {\n        Errors[] err2 = new Errors[errors.length+1];\n        System.arraycopy(errors, 0, err2, 0, errors.length);\n        err2[err2.length-1] = err;\n        errors = err2;\n      }\n      Log.info(\"scoring time: \" + PrettyPrint.msecs(System.currentTimeMillis() - now, true));\n    }\n    if (model_info().unstable()) {\n      Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n      Log.err(\"Try using L1/L2/max_w2 regularization, a different activation function, or more synchronization in multi-node operation.\");\n      keep_running = false;\n    }\n    update(dest_key); //update model in UKV\n//    System.out.println(this);\n    return keep_running;\n  }","commit_id":"85635a6f938a8b4b2339799881da6f78079a6d11","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public double classificationError(Frame ftest, String label, boolean printCM) {\n    Frame fpreds;\n    fpreds = score(ftest);\n    water.api.ConfusionMatrix CM = new water.api.ConfusionMatrix();\n    CM.actual = ftest;\n    CM.vactual = ftest.lastVec();\n    CM.predict = fpreds;\n    CM.vpredict = fpreds.vecs()[0];\n    CM.serve();\n    StringBuilder sb = new StringBuilder();\n    final double error = CM.toASCII(sb);\n    if (printCM) {\n      Log.info(label);\n      for (String s : sb.toString().split(\"\\n\")) Log.info(s);\n    }\n    fpreds.delete();\n    return error;\n  }","id":77308,"modified_method":"public double classificationError(Frame ftest, String label, boolean printCM, ConfusionMatrix CM) {\n    Frame fpreds;\n    fpreds = score(ftest);\n    CM.actual = ftest;\n    CM.vactual = ftest.lastVec();\n    CM.predict = fpreds;\n    CM.vpredict = fpreds.vecs()[0];\n    CM.serve();\n    StringBuilder sb = new StringBuilder();\n    final double error = CM.toASCII(sb);\n    if (printCM) {\n      Log.info(label);\n      for (String s : sb.toString().split(\"\\n\")) Log.info(s);\n    }\n    fpreds.delete();\n    return error;\n  }","commit_id":"85635a6f938a8b4b2339799881da6f78079a6d11","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public boolean generateHTML(String title, StringBuilder sb) {\n    if (_key == null) {\n      DocGen.HTML.title(sb, \"No model yet\");\n      return true;\n    }\n\n    final String mse_format = \"%2.6f\";\n    final String cross_entropy_format = \"%2.6f\";\n\n    DocGen.HTML.title(sb,title);\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n    model_info.job().toHTML(sb);\n    sb.append(\"<div class='alert'>Actions: \" + water.api.Predict.link(_key, \"Score on dataset\") + \", \" +\n            NN.link(_dataKey, \"Compute new model\") + \"<\/div>\");\n    DocGen.HTML.title(sb, \"Epochs: \" + epoch_counter);\n\n    // stats for training and validation\n    final Errors error = errors[errors.length - 1];\n\n    if (isClassifier()) {\n      // Plot training error\n      float[] err = new float[errors.length];\n      float[] samples = new float[errors.length];\n      for (int i=0; i<err.length; ++i) {\n        err[i] = (float)errors[i].train_err;\n        samples[i] = errors[i].training_samples;\n      }\n      new D3Plot(samples, err, \"training samples\", \"classification error\",\n              \"Classification Error on Training Set\").generate(sb);\n\n      // Plot validation error\n      if (model_info.parameters.validation != null) {\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i].valid_err;\n        }\n        new D3Plot(samples, err, \"training samples\", \"classification error\",\n                \"Classification Error on Validation Set\").generate(sb);\n      }\n    }\n\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Training classification error: \" + formatPct(error.train_err));\n    }\n    DocGen.HTML.section(sb, \"Training mean square error: \" + String.format(mse_format, error.train_mse));\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Training cross entropy: \" + String.format(cross_entropy_format, error.train_mce));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"Validation classification error: \" + formatPct(error.valid_err));\n      }\n    }\n    if(error.validation) {\n      DocGen.HTML.section(sb, \"Validation mean square error: \" + String.format(mse_format, error.valid_mse));\n      if (isClassifier()) {\n        DocGen.HTML.section(sb, \"Validation mean cross entropy: \" + String.format(cross_entropy_format, error.valid_mce));\n      }\n      if (error.training_time_ms > 0)\n        DocGen.HTML.section(sb, \"Training speed: \" + error.training_samples * 1000 / error.training_time_ms + \" samples/s\");\n    }\n    else {\n      if (error.training_time_ms > 0)\n        DocGen.HTML.section(sb, \"Training speed: \" + error.training_samples * 1000 / error.training_time_ms + \" samples/s\");\n    }\n    if (model_info.parameters != null && model_info.parameters.diagnostics) {\n      DocGen.HTML.section(sb, \"Status of Hidden and Output Layers\");\n      sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(\"#\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Units\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Activation\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Rate\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L1\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L2\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Momentum\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Weight (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Bias (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<\/tr>\");\n      Neurons[] neurons = NNTask.makeNeurons(model_info.parameters._dinfo, model_info()); //link the weights to the neurons, for easy access\n      for (int i=1; i<neurons.length; ++i) {\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\").append(\"<b>\").append(i).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(\"<b>\").append(neurons[i].units).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].getClass().getSimpleName().replace(\"Vec\",\"\").replace(\"Chunk\", \"\")).append(\"<\/td>\");\n        sb.append(\"<td>\").append(String.format(\"%.5g\", neurons[i].rate(error.training_samples))).append(\"<\/td>\");\n       sb.append(\"<td>\").append(neurons[i].l1).append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].l2).append(\"<\/td>\");\n        final String format = \"%g\";\n        sb.append(\"<td>\").append(neurons[i].momentum(error.training_samples)).append(\"<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_weight[i])).\n                append(\", \").append(String.format(format, model_info.rms_weight[i])).append(\")<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_bias[i])).\n                append(\", \").append(String.format(format, model_info.rms_bias[i])).append(\")<\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }\n    if (model_info.unstable()) {\n      final String msg = \"Job was aborted due to observed numerical instability (exponential growth).\"\n              + \" Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\";\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n      DocGen.HTML.section(sb, msg);\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n    }\n    final String cmTitle = \"Confusion Matrix on \" + (error.validation ? \" Validation Data\" : \" Training Data\");\n    DocGen.HTML.section(sb, cmTitle);\n    if (error.confusion_matrix != null)\n      error.confusion_matrix.toHTML(sb);\n\n    sb.append(\"<h3>\" + \"Progress\" + \"<\/h3>\");\n//    String training = \"Number of training set samples for scoring: \" + error.score_training;\n    if (error.validation) {\n//      String validation = \"Number of validation set samples for scoring: \" + error.score_validation;\n    }\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Training Time<\/th>\");\n    sb.append(\"<th>Training Samples<\/th>\");\n    sb.append(\"<th>Training MSE<\/th>\");\n    if (isClassifier()) {\n      sb.append(\"<th>Training MCE<\/th>\");\n      sb.append(\"<th>Training Classification Error<\/th>\");\n    }\n    sb.append(\"<th>Validation MSE<\/th>\");\n    if (isClassifier()) {\n      sb.append(\"<th>Validation MCE<\/th>\");\n      sb.append(\"<th>Validation Classification Error<\/th>\");\n    }\n    sb.append(\"<\/tr>\");\n    for( int i = errors.length - 1; i >= 0; i-- ) {\n      final Errors e = errors[i];\n      sb.append(\"<tr>\");\n      sb.append(\"<td>\" + PrettyPrint.msecs(e.training_time_ms, true) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%,d\", e.training_samples) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(mse_format, e.train_mse) + \"<\/td>\");\n      if (isClassifier()) {\n        sb.append(\"<td>\" + String.format(cross_entropy_format, e.train_mce) + \"<\/td>\");\n        sb.append(\"<td>\" + formatPct(e.train_err) + \"<\/td>\");\n      }\n      if(e.validation) {\n        sb.append(\"<td>\" + String.format(mse_format, e.valid_mse) + \"<\/td>\");\n        if (isClassifier()) {\n          sb.append(\"<td>\" + String.format(cross_entropy_format, e.valid_mce) + \"<\/td>\");\n          sb.append(\"<td>\" + formatPct(e.valid_err) + \"<\/td>\");\n        }\n      } else\n        sb.append(\"<td><\/td><td><\/td><td><\/td>\");\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table>\");\n    return true;\n  }","id":77309,"modified_method":"public boolean generateHTML(String title, StringBuilder sb) {\n    if (_key == null) {\n      DocGen.HTML.title(sb, \"No model yet\");\n      return true;\n    }\n\n    final String mse_format = \"%2.6f\";\n    final String cross_entropy_format = \"%2.6f\";\n\n    DocGen.HTML.title(sb, title);\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n    model_info.job().toHTML(sb);\n    sb.append(\"<div class='alert'>Actions: \" + water.api.Predict.link(_key, \"Score on dataset\") + \", \" +\n            NN.link(_dataKey, \"Compute new model\") + \"<\/div>\");\n\n    // stats for training and validation\n    final Errors error = errors[errors.length - 1];\n\n    if (isClassifier()) {\n      // Plot training error\n      float[] err = new float[errors.length];\n      float[] samples = new float[errors.length];\n      for (int i=0; i<err.length; ++i) {\n        err[i] = (float)errors[i].train_err;\n        samples[i] = errors[i].training_samples;\n      }\n      new D3Plot(samples, err, \"training samples\", \"classification error\",\n              \"Classification Error on Training Set\").generate(sb);\n\n      // Plot validation error\n      if (model_info.parameters.validation != null) {\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i].valid_err;\n        }\n        new D3Plot(samples, err, \"training samples\", \"classification error\",\n                \"Classification Error on Validation Set\").generate(sb);\n      }\n    }\n\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Training classification error: \" + formatPct(error.train_err));\n    }\n    DocGen.HTML.section(sb, \"Training mean square error: \" + String.format(mse_format, error.train_mse));\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Training cross entropy: \" + String.format(cross_entropy_format, error.train_mce));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"Validation classification error: \" + formatPct(error.valid_err));\n      }\n    }\n    if(error.validation) {\n      DocGen.HTML.section(sb, \"Validation mean square error: \" + String.format(mse_format, error.valid_mse));\n      if (isClassifier()) {\n        DocGen.HTML.section(sb, \"Validation mean cross entropy: \" + String.format(cross_entropy_format, error.valid_mce));\n      }\n    }\n    if (error.training_time_ms > 0)\n      DocGen.HTML.section(sb, \"Training speed: \" + error.training_samples * 1000 / error.training_time_ms + \" samples/s\");\n    if (model_info.parameters != null && model_info.parameters.diagnostics) {\n      DocGen.HTML.section(sb, \"Status of Hidden and Output Layers\");\n      sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(\"#\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Units\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Activation\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Rate\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L1\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L2\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Momentum\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Weight (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Bias (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<\/tr>\");\n      Neurons[] neurons = NNTask.makeNeurons(model_info.parameters._dinfo, model_info()); //link the weights to the neurons, for easy access\n      for (int i=1; i<neurons.length; ++i) {\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\").append(\"<b>\").append(i).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(\"<b>\").append(neurons[i].units).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].getClass().getSimpleName().replace(\"Vec\",\"\").replace(\"Chunk\", \"\")).append(\"<\/td>\");\n        sb.append(\"<td>\").append(String.format(\"%.5g\", neurons[i].rate(error.training_samples))).append(\"<\/td>\");\n       sb.append(\"<td>\").append(neurons[i].l1).append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].l2).append(\"<\/td>\");\n        final String format = \"%g\";\n        sb.append(\"<td>\").append(neurons[i].momentum(error.training_samples)).append(\"<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_weight[i])).\n                append(\", \").append(String.format(format, model_info.rms_weight[i])).append(\")<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_bias[i])).\n                append(\", \").append(String.format(format, model_info.rms_bias[i])).append(\")<\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }\n    if (model_info.unstable()) {\n      final String msg = \"Job was aborted due to observed numerical instability (exponential growth).\"\n              + \" Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\";\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n      DocGen.HTML.section(sb, msg);\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n    }\n    final String cmTitle = \"Confusion Matrix on \" + (error.validation ? \" Validation Data\" : \" Training Data\");\n    DocGen.HTML.section(sb, cmTitle);\n    if (error.validation && error.valid_confusion_matrix != null) error.valid_confusion_matrix.toHTML(sb);\n    else if (error.train_confusion_matrix != null) error.train_confusion_matrix.toHTML(sb);\n    else sb.append(\"<h5>Not yet computed.<\/h5>\");\n\n    sb.append(\"<h3>\" + \"Progress\" + \"<\/h3>\");\n    sb.append(\"<h4>\" + \"Epochs: \" + String.format(\"%.3f\", epoch_counter) + \"<\/h4>\");\n//    String training = \"Number of training set samples for scoring: \" + error.score_training;\n    if (error.validation) {\n//      String validation = \"Number of validation set samples for scoring: \" + error.score_validation;\n    }\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Training Time<\/th>\");\n    sb.append(\"<th>Training Samples<\/th>\");\n//    sb.append(\"<th>Training MSE<\/th>\");\n//    if (isClassifier()) {\n//      sb.append(\"<th>Training MCE<\/th>\");\n      sb.append(\"<th>Training Error<\/th>\");\n//    }\n//    sb.append(\"<th>Validation MSE<\/th>\");\n//    if (isClassifier()) {\n//      sb.append(\"<th>Validation MCE<\/th>\");\n      sb.append(\"<th>Validation Error<\/th>\");\n//    }\n    sb.append(\"<\/tr>\");\n    for( int i = errors.length - 1; i >= 0; i-- ) {\n      final Errors e = errors[i];\n      sb.append(\"<tr>\");\n      sb.append(\"<td>\" + PrettyPrint.msecs(e.training_time_ms, true) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%,d\", e.training_samples) + \"<\/td>\");\n//      sb.append(\"<td>\" + String.format(mse_format, e.train_mse) + \"<\/td>\");\n      if (isClassifier()) {\n//        sb.append(\"<td>\" + String.format(cross_entropy_format, e.train_mce) + \"<\/td>\");\n        sb.append(\"<td>\" + formatPct(e.train_err) + \"<\/td>\");\n      }\n      if(e.validation) {\n//        sb.append(\"<td>\" + String.format(mse_format, e.valid_mse) + \"<\/td>\");\n        if (isClassifier()) {\n//          sb.append(\"<td>\" + String.format(cross_entropy_format, e.valid_mce) + \"<\/td>\");\n          sb.append(\"<td>\" + formatPct(e.valid_err) + \"<\/td>\");\n        }\n      } else\n        sb.append(\"<td><\/td><td><\/td><td><\/td>\");\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table>\");\n    return true;\n  }","commit_id":"85635a6f938a8b4b2339799881da6f78079a6d11","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public NNModel(Key selfKey, Key jobKey, Key dataKey, DataInfo dinfo, NN params) {\n    super(selfKey, dataKey, dinfo._adaptedFrame);\n    job_key = jobKey;\n    data_info = dinfo;\n    run_time = 0;\n    start_time = System.currentTimeMillis();\n    errors = new Errors[(int)params.epochs];\n    for (int i=0; i<errors.length; ++i) {\n      errors[i] = new Errors();\n    }\n\n    model_info = new NNModelInfo(params, data_info.fullN(), data_info._adaptedFrame.lastVec().domain().length);\n    model_info.initializeMembers();\n  }","id":77310,"modified_method":"public NNModel(Key selfKey, Key jobKey, Key dataKey, DataInfo dinfo, NN params) {\n    super(selfKey, dataKey, dinfo._adaptedFrame);\n    job_key = jobKey;\n    data_info = dinfo;\n    run_time = 0;\n    start_time = System.currentTimeMillis();\n    model_info = new NNModelInfo(params, data_info.fullN(), data_info._adaptedFrame.lastVec().domain().length);\n    model_info.initializeMembers();\n    errors = new Errors[1];\n    errors[0] = new Errors();\n    errors[0].validation = (params.validation != null);\n  }","commit_id":"85635a6f938a8b4b2339799881da6f78079a6d11","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public boolean toHTML(StringBuilder sb){\n    neuralnet_model.generateHTML(\"NeuralNet Model\", sb);\n    return true;\n  }","id":77311,"modified_method":"@Override public boolean toHTML(StringBuilder sb){\n    if (neuralnet_model != null)\n      neuralnet_model.generateHTML(\"NeuralNet Model\", sb);\n    return true;\n  }","commit_id":"85635a6f938a8b4b2339799881da6f78079a6d11","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public boolean toHTML( StringBuilder sb ) {\n    Job jjob = Job.findJob(job_key);\n    DRFModel m = DKV.get(jjob.dest()).get();\n    m.generateHTML(\"DRF Model\", sb);\n    return true;\n  }","id":77312,"modified_method":"@Override public boolean toHTML( StringBuilder sb ) {\n    Job jjob = Job.findJob(job_key);\n    DRFModel m = UKV.get(jjob.dest());\n    if (m!=null) m.generateHTML(\"DRF Model\", sb);\n    else DocGen.HTML.paragraph(sb, \"Pending...\");\n\n    return true;\n  }","commit_id":"e352ef409b9ec3989858110ddd3d99ff24302d9b","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected Response serve() {\n    link = family.defaultLink;\n    _startTime = System.currentTimeMillis();\n    GLMModel m = new GLMModel(dest(),source,new GLMParams(family,tweedie_variance_power,link,1-tweedie_variance_power),beta_epsilon,alpha,lambda,System.currentTimeMillis()-_startTime);\n    DKV.put(dest(), m);\n    fork();\n    return GLMProgressPage2.redirect(this, self(),dest());\n  }","id":77313,"modified_method":"@Override protected Response serve() {\n    link = family.defaultLink;\n    _startTime = System.currentTimeMillis();\n    fork();\n    return GLMProgressPage2.redirect(this, self(),dest());\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void xvalidate(final GLMModel model, final H2OCountedCompleter cmp){\n    final Key [] keys = new Key[n_folds];\n    H2OCallback callback = new H2OCallback() {\n      @Override public void callback(H2OCountedCompleter t) {\n        GLMXValidation xval = new GLMXValidation(model, keys);\n        Key xvalKey = Key.make();\n        DKV.put(xvalKey, xval);\n        model.setValidation(xvalKey);\n        DKV.put(model._selfKey, model);\n        GLM2.this.remove();\n      }\n    };\n    callback.addToPendingCount(n_folds-1);\n    callback.setCompleter(cmp);\n    for(int i = 0; i < n_folds; ++i)\n      new GLM2(this.description + \"xval \" + i, keys[i] = Key.make(), source, standardize, family, link,alpha,lambda, n_folds, i,false,model.norm_beta).fork(callback);\n  }","id":77314,"modified_method":"private void xvalidate(final GLMModel model, final H2OCountedCompleter cmp){\n    final Key [] keys = new Key[n_folds];\n    H2OCallback callback = new H2OCallback() {\n      @Override public void callback(H2OCountedCompleter t) {\n        model.setValidation(new GLMXValidation(model, keys));\n        DKV.put(model._selfKey, model);\n        GLM2.this.remove();\n      }\n    };\n    callback.addToPendingCount(n_folds-1);\n    callback.setCompleter(cmp);\n    for(int i = 0; i < n_folds; ++i)\n      new GLM2(this.description + \"xval \" + i, keys[i] = Key.make(), source, standardize, family, link,alpha,lambda, n_folds, i,false,model.norm_beta).fork(callback);\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Future fork(H2OCountedCompleter completer){\n    final H2OCountedCompleter fjt = new H2OEmptyCompleter();\n    if(completer != null)fjt.setCompleter(completer);\n    start(fjt);\n    tweedie_link_power = 1 - tweedie_variance_power; // TODO\n    source.remove(ignored_cols);\n    final Vec [] vecs =  source.vecs();\n    ArrayList<Integer> constantOrNAs = new ArrayList<Integer>();\n    for(int i = 0; i < vecs.length-1; ++i)// put response to the end\n      if(vecs[i] == vresponse){\n        source.add(source._names[i], source.remove(i));\n        break;\n      }\n    for(int i = 0; i < vecs.length-1; ++i) // put response to the end\n      if(vecs[i].min() == vecs[i].max() || vecs[i].naCnt() > vecs[i].length()*0.2)constantOrNAs.add(i);\n    if(!constantOrNAs.isEmpty()){\n      int [] cols = new int[constantOrNAs.size()];\n      for(int i = 0; i < cols.length; ++i)cols[i] = constantOrNAs.get(i);\n      source.remove(cols);\n    }\n    final Frame fr = GLMTask.adaptFrame(source);\n    YMUTask ymut = new YMUTask(new GLMParams(family, tweedie_variance_power, link,tweedie_link_power), standardize, case_mode, case_val, fr.anyVec().length());\n    ymut.doAll(fr);\n    GLMIterationTask firstIter = new GLMIterationTask(new GLMParams(family, tweedie_variance_power, link,tweedie_link_power),_beta,standardize, 1.0/ymut.nobs(), case_mode, case_val,_step,_offset,_complement);\n    firstIter._ymu = ymut.ymu();\n    final LSMSolver solver = new ADMMSolver(lambda, alpha);\n    firstIter.setCompleter(new Iteration(solver,fr,fjt));\n    firstIter.dfork(fr);\n    return fjt;\n  }","id":77315,"modified_method":"public Future fork(H2OCountedCompleter completer){\n    final H2OCountedCompleter fjt = new H2OEmptyCompleter();\n    if(completer != null)fjt.setCompleter(completer);\n    start(fjt);\n    _oldModel = new GLMModel(dest(),source,new GLMParams(family,tweedie_variance_power,link,1-tweedie_variance_power),beta_epsilon,alpha,lambda,System.currentTimeMillis()-_startTime,GLM2.this.case_mode,GLM2.this.case_val);\n    tweedie_link_power = 1 - tweedie_variance_power; // TODO\n    source.remove(ignored_cols);\n    final Vec [] vecs =  source.vecs();\n    ArrayList<Integer> constantOrNAs = new ArrayList<Integer>();\n    for(int i = 0; i < vecs.length-1; ++i)// put response to the end\n      if(vecs[i] == vresponse){\n        source.add(source._names[i], source.remove(i));\n        break;\n      }\n    for(int i = 0; i < vecs.length-1; ++i) // remove constant cols and cols with too many NAs\n      if(vecs[i].min() == vecs[i].max() || vecs[i].naCnt() > vecs[i].length()*0.2)constantOrNAs.add(i);\n    if(!constantOrNAs.isEmpty()){\n      int [] cols = new int[constantOrNAs.size()];\n      for(int i = 0; i < cols.length; ++i)cols[i] = constantOrNAs.get(i);\n      source.remove(cols);\n    }\n    final Frame fr = GLMTask.adaptFrame(source);\n    YMUTask ymut = new YMUTask(new GLMParams(family, tweedie_variance_power, link,tweedie_link_power), standardize, case_mode, case_val, fr.anyVec().length());\n    ymut.doAll(fr);\n    GLMIterationTask firstIter = new GLMIterationTask(new GLMParams(family, tweedie_variance_power, link,tweedie_link_power),_beta,standardize, 1.0/ymut.nobs(), case_mode, case_val,_step,_offset,_complement);\n    firstIter._ymu = ymut.ymu();\n    final LSMSolver solver = new ADMMSolver(lambda, alpha);\n    firstIter.setCompleter(new Iteration(solver,fr,fjt));\n    firstIter.dfork(fr);\n    return fjt;\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void callback(GLMIterationTask glmt) {\n      double [] newBeta = MemoryManager.malloc8d(glmt._xy.length);\n//      System.out.println(glmt._gram.pprint(glmt._gram.getXX()));\n      solver.solve(glmt._gram, glmt._xy, glmt._yy, newBeta);\n      boolean done = false;\n      if(Utils.hasNaNsOrInfs(newBeta)){\n        System.out.println(\"got NaNs in beta after \" + glmt._iter + \" iterations\");\n        System.out.println(glmt._gram.pprint(glmt._gram.getXX()));\n        done = true;\n        newBeta = glmt._beta == null?newBeta:glmt._beta;\n      }\n      done = done || family == Family.gaussian || (glmt._iter+1) == max_iter || beta_diff(glmt._beta, newBeta) < beta_epsilon;\n      GLMModel res = new GLMModel(dest(),null,glmt._iter+1,fr,glmt,beta_epsilon,alpha,lambda,newBeta,0.5,null,System.currentTimeMillis() - start_time);\n      if(done){\n        // final validation\n        if(GLM2.this.n_folds < 2){\n          GLMValidationTask t = new GLMValidationTask(res,_step,_offset,true);\n          t.doAll(fr);\n          Key valKey = GLMValidation.makeKey();\n          DKV.put(valKey,t._res);\n          t._res.finalize_AIC_AUC();\n          res.setValidation(valKey);\n          DKV.put(dest(),res);\n          remove();\n          fjt.tryComplete(); // signal we're done to anyone waiting for the job\n        } else\n          xvalidate(res, fjt);\n      } else {\n        DKV.put(dest(),res);\n        GLMIterationTask nextIter = new GLMIterationTask(glmt, newBeta);\n        nextIter.setCompleter(clone()); // we need to clone here as FJT will set status to done after this method\n        nextIter.dfork(fr);\n      }\n    }","id":77316,"modified_method":"@Override public void callback(GLMIterationTask glmt) {\n      double [] newBeta = MemoryManager.malloc8d(glmt._xy.length);\n//      System.out.println(glmt._gram.pprint(glmt._gram.getXX()));\n      solver.solve(glmt._gram, glmt._xy, glmt._yy, newBeta);\n      boolean done = false;\n      if(Utils.hasNaNsOrInfs(newBeta)){\n        System.out.println(\"got NaNs in beta after \" + glmt._iter + \" iterations\");\n        System.out.println(glmt._gram.pprint(glmt._gram.getXX()));\n        done = true;\n        newBeta = glmt._beta == null?newBeta:glmt._beta;\n      }\n      done = done || family == Family.gaussian || (glmt._iter+1) == max_iter || beta_diff(glmt._beta, newBeta) < beta_epsilon;\n      GLMModel res = new GLMModel(dest(),null,glmt._iter+1,fr,glmt,beta_epsilon,alpha,lambda,newBeta,0.5,null,System.currentTimeMillis() - start_time,GLM2.this.case_mode,GLM2.this.case_val);\n      if(done){\n        // final validation\n        GLMValidationTask t = new GLMValidationTask(res,_step,_offset,true);\n        t.doAll(fr);\n        t._res.finalize_AIC_AUC();\n        res.setValidation(t._res);\n        DKV.put(dest(),res);\n        if(GLM2.this.n_folds < 2){\n          remove();\n          fjt.tryComplete(); // signal we're done to anyone waiting for the job\n        } else\n          xvalidate(res, fjt);\n      } else {\n        glmt._val.finalize_AIC_AUC();\n        _oldModel.setValidation(glmt._val);\n        DKV.put(dest(),_oldModel);// validation is one iteration behind\n        _oldModel = res;\n        GLMIterationTask nextIter = new GLMIterationTask(glmt, newBeta);\n        nextIter.setCompleter(clone()); // we need to clone here as FJT will set status to done after this method\n        nextIter.dfork(fr);\n      }\n    }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void map(Chunk [] chunks){\n      _res = new GLMValidation(null,_model.ymu,_model.glm,_model.rank());\n      final int nrows = chunks[0]._len;\n      double [] row   = MemoryManager.malloc8d(_model._names.length);\n      float  [] preds = MemoryManager.malloc4f(_model.glm.family == Family.binomial?2:1);\n      final int step  = _complement?_step:1;\n      final int start = _complement?_offset:0;\n      OUTER:\n      for(int i = start; i < nrows; i += step){\n        if(_step > step && (i % _step) == _offset)continue;\n        if(chunks[chunks.length-1].isNA0(i))continue;\n        for(int j = 0; j < chunks.length-1; ++j){\n          if(chunks[j].isNA0(i))continue OUTER;\n          row[j] = chunks[j].at0(i);\n        }\n        _model.score0(row, preds);\n        _res.add(chunks[chunks.length-1].at80(i), _model.glm.family == Family.binomial?preds[1]:preds[0]);\n      }\n      if(_res.nobs > 0)_res.avg_err /= _res.nobs;\n    }","id":77317,"modified_method":"@Override public void map(Chunk [] chunks){\n      _res = new GLMValidation(null,_model.ymu,_model.glm,_model.rank());\n      final int nrows = chunks[0]._len;\n      double [] row   = MemoryManager.malloc8d(_model._names.length);\n      float  [] preds = MemoryManager.malloc4f(_model.glm.family == Family.binomial?2:1);\n      final int step  = _complement?_step:1;\n      final int start = _complement?_offset:0;\n      OUTER:\n      for(int i = start; i < nrows; i += step){\n        if(_step > step && (i % _step) == _offset)continue;\n        if(chunks[chunks.length-1].isNA0(i))continue;\n        for(int j = 0; j < chunks.length-1; ++j){\n          if(chunks[j].isNA0(i))continue OUTER;\n          row[j] = chunks[j].at0(i);\n        }\n        _model.score0(row, preds);\n        double response = chunks[chunks.length-1].at80(i);\n        if(_model._caseMode != CaseMode.none)\n          response = _model._caseMode.isCase(response, _model._caseVal)?1:0;\n        _res.add(response, _model.glm.family == Family.binomial?preds[1]:preds[0]);\n      }\n      if(_res.nobs > 0)_res.avg_err /= _res.nobs;\n    }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void delete(){\n    if(validations != null) for(Key k:validations)\n      DKV.remove(k);\n    super.delete();\n  }","id":77318,"modified_method":"@Override public void delete(){super.delete();}","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public GLMValidation validation(){\n    GLMValidation res = DKV.get(validations[0]).get();\n    return res;\n  }","id":77319,"modified_method":"public GLMValidation validation(){\n    return validation;\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public GLMModel(Key selfKey, Key dataKey, int iteration, Frame fr, GLMTask glmt, double beta_eps, double alpha, double lambda, double [] beta, double threshold, String [] warnings, long run_time) {\n    super(selfKey, dataKey, fr);\n    glm = glmt._glm;\n    this.threshold = threshold;\n    catOffsets = glmt._catOffsets;\n    if(glmt._standardize){\n      this.norm_beta = beta;\n      // denormalize beta\n      this.beta = beta.clone();\n      double norm = 0.0;        // Reverse any normalization on the intercept\n      // denormalize only the number coefs (categoricals are not normalized)\n      final int numoff = beta.length - glmt._nums - 1;\n      for( int i=numoff; i< this.beta.length-1; i++ ) {\n        double b = this.beta[i]*glmt._normMul[i-numoff];\n        norm += b*glmt._normSub[i-numoff]; // Also accumulate the intercept adjustment\n        this.beta[i] = b;\n      }\n      this.beta[beta.length-1] -= norm;\n    } else {\n      this.beta = beta;\n      norm_beta = null;\n    }\n    final Vec [] vecs = fr.vecs();\n    ymu = vecs[vecs.length-1].mean();\n    this.iteration = iteration;\n    this.warnings = warnings;\n    this.alpha = alpha;\n    this.lambda = lambda;\n    this.beta_eps = beta_eps;\n    this.run_time = run_time;\n  }","id":77320,"modified_method":"public GLMModel(Key selfKey, Key dataKey, int iteration, Frame fr, GLMTask glmt, double beta_eps, double alpha, double lambda, double [] beta, double threshold, String [] warnings, long run_time, CaseMode caseMode, double caseVal) {\n    super(selfKey, dataKey, fr);\n    glm = glmt._glm;\n    this.threshold = threshold;\n    catOffsets = glmt._catOffsets;\n    if(glmt._standardize){\n      this.norm_beta = beta;\n      // denormalize beta\n      this.beta = beta.clone();\n      double norm = 0.0;        // Reverse any normalization on the intercept\n      // denormalize only the number coefs (categoricals are not normalized)\n      final int numoff = beta.length - glmt._nums - 1;\n      for( int i=numoff; i< this.beta.length-1; i++ ) {\n        double b = this.beta[i]*glmt._normMul[i-numoff];\n        norm += b*glmt._normSub[i-numoff]; // Also accumulate the intercept adjustment\n        this.beta[i] = b;\n      }\n      this.beta[beta.length-1] -= norm;\n    } else {\n      this.beta = beta;\n      norm_beta = null;\n    }\n    final Vec [] vecs = fr.vecs();\n    ymu = vecs[vecs.length-1].mean();\n    this.iteration = iteration;\n    this.warnings = warnings;\n    this.alpha = alpha;\n    this.lambda = lambda;\n    this.beta_eps = beta_eps;\n    this.run_time = run_time;\n    _caseMode = caseMode;\n    _caseVal = caseVal;\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void generateHTML(String title, StringBuilder sb) {\n    if(title != null && !title.isEmpty())DocGen.HTML.title(sb,title);\n    DocGen.HTML.paragraph(sb,\"Model Key: \"+_selfKey);\n    if(beta != null)\n      DocGen.HTML.paragraph(sb,water.api.Predict.link(_selfKey,\"Predict!\"));\n    String succ = (warnings == null || warnings.length == 0)?\"alert-success\":\"alert-warning\";\n    sb.append(\"<div class='alert \" + succ + \"'>\");\n    sb.append(iteration + \" iterations computed in \");\n    pprintTime(sb, run_time);\n    if(warnings != null && warnings.length > 0){\n      sb.append(\"<b>Warnings:<\/b><ul>\");\n      for(String w:warnings)sb.append(\"<li>\" + w + \"<\/li>\");\n      sb.append(\"<\/ul>\");\n    }\n    sb.append(\"<\/div>\");\n    sb.append(\"<h4>Parameters<\/h4>\");\n    parm(sb,\"family\",glm.family);\n    parm(sb,\"link\",glm.link);\n    parm(sb,\"&epsilon;<sub>&beta;<\/sub>\",beta_eps);\n    parm(sb,\"&alpha;\",alpha);\n    parm(sb,\"&lambda;\",lambda);\n    if(beta != null)\n      coefs2html(sb);\n    if(validations != null && validations.length > 0){\n      for(Key k:validations){\n        GLMValidation v = DKV.get(k).get();\n        v.generateHTML(\"\", sb);\n      }\n    }\n  }","id":77321,"modified_method":"public void generateHTML(String title, StringBuilder sb) {\n    if(title != null && !title.isEmpty())DocGen.HTML.title(sb,title);\n    DocGen.HTML.paragraph(sb,\"Model Key: \"+_selfKey);\n    if(beta != null)\n      DocGen.HTML.paragraph(sb,water.api.Predict.link(_selfKey,\"Predict!\"));\n    String succ = (warnings == null || warnings.length == 0)?\"alert-success\":\"alert-warning\";\n    sb.append(\"<div class='alert \" + succ + \"'>\");\n    sb.append(iteration + \" iterations computed in \");\n    pprintTime(sb, run_time);\n    if(warnings != null && warnings.length > 0){\n      sb.append(\"<b>Warnings:<\/b><ul>\");\n      for(String w:warnings)sb.append(\"<li>\" + w + \"<\/li>\");\n      sb.append(\"<\/ul>\");\n    }\n    sb.append(\"<\/div>\");\n    sb.append(\"<h4>Parameters<\/h4>\");\n    parm(sb,\"family\",glm.family);\n    parm(sb,\"link\",glm.link);\n    parm(sb,\"&epsilon;<sub>&beta;<\/sub>\",beta_eps);\n    parm(sb,\"&alpha;\",alpha);\n    parm(sb,\"&lambda;\",lambda);\n    if(beta != null)\n      coefs2html(sb);\n    GLMValidation val = validation();\n    if(val != null)val.generateHTML(\"Training Set Validation\", sb);\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void setValidation(Key k){this.validations = new Key[]{k};}","id":77322,"modified_method":"public void setValidation(GLMValidation val ){validation = val;}","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public GLMModel(Key selfKey, Frame fr, GLMParams glm, double beta_eps, double alpha, double lambda,long run_time) {\n    super(selfKey,null,fr);\n    ymu = 0;\n    beta = null;\n    norm_beta = null;\n    this.glm = glm;\n    threshold = 0.5;\n    iteration = 0;\n    this.catOffsets = null;\n    this.warnings = null;\n    this.alpha = alpha;\n    this.lambda = lambda;\n    this.beta_eps = beta_eps;\n    this.run_time = run_time;\n  }","id":77323,"modified_method":"public GLMModel(Key selfKey, Frame fr, GLMParams glm, double beta_eps, double alpha, double lambda,long run_time, CaseMode caseMode, double caseVal ) {\n    super(selfKey,null,fr);\n    ymu = 0;\n    beta = null;\n    norm_beta = null;\n    this.glm = glm;\n    threshold = 0.5;\n    iteration = 0;\n    this.catOffsets = null;\n    this.warnings = null;\n    this.alpha = alpha;\n    this.lambda = lambda;\n    this.beta_eps = beta_eps;\n    this.run_time = run_time;\n    _caseVal = caseVal;\n    _caseMode = caseMode;\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public boolean toHTML( StringBuilder sb ) {\n    Job jjob = Job.findJob(Key.make(job.value()));\n    GLMModel m = DKV.get(jjob.dest()).get();\n    m.generateHTML(\"GLM Model\", sb);\n    return true;\n  }","id":77324,"modified_method":"@Override public boolean toHTML( StringBuilder sb ) {\n    Job jjob = Job.findJob(Key.make(job.value()));\n    Value v = DKV.get(jjob.dest());\n    if(v != null){\n      GLMModel m = v.get();\n      m.generateHTML(\"GLM Model\", sb);\n    } else\n      sb.append(\"<b>No model yet.<\/b>\");\n    return true;\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public final void processRow(double [] nums, int ncats, int [] cats, double y){\n      assert ((_glm.family != Family.gamma) || y > 0) : \"illegal response column, y must be > 0  for family=Gamma.\";\n      if( _caseMode != CaseMode.none ) y = (_caseMode.isCase(y, _caseVal)) ? 1 : 0;\n      double w = 1;\n      double eta = 0, mu = 0, var = 1;\n      if( _glm.family != Family.gaussian) {\n        if( _beta == null ) {\n          mu = _glm.mustart(y);\n          eta = _glm.link(mu);\n        } else {\n          eta = computeEta(ncats, cats,nums);\n          mu = _glm.linkInv(eta);\n        }\n        if(Double.isNaN(mu)){\n          System.out.println(\"got NaN mu from: beta=\" + Arrays.toString(_beta) + \", row = \" + Arrays.toString(nums) + \", cats = \" + Arrays.toString(cats) + \", ncats = \" + ncats);\n        }\n        _val.add(y, mu);\n\n        var = Math.max(1e-5, _glm.variance(mu)); // avoid numerical problems with 0 variance\n        if( _glm.family == Family.binomial || _glm.family == Family.poisson ) {\n          w = var;\n          y = eta + (y - mu) / var;\n        } else {\n          double dp = _glm.linkInvDeriv(eta);\n          w = dp * dp / var;\n          y = eta + (y - mu) / dp;\n        }\n      }\n      assert w >= 0 : \"invalid weight \" + w;\n      _yy += 0.5 * w * y * y;\n      double wy = w * y;\n      for(int i = 0; i < ncats; ++i)_xy[cats[i]] += wy;\n      final int numStart = _catOffsets[_cats];\n      for(int i = 0; i < nums.length; ++i)_xy[numStart+i] += wy*nums[i];\n      _xy[numStart + _nums] += wy;\n      _gram.addRow(nums, ncats, cats, w);\n    }","id":77325,"modified_method":"@Override public final void processRow(double [] nums, int ncats, int [] cats, double y){\n      assert ((_glm.family != Family.gamma) || y > 0) : \"illegal response column, y must be > 0  for family=Gamma.\";\n      assert ((_glm.family != Family.binomial) || (0 <= y && y <= 1)) : \"illegal response column, y must be <0,1>  for family=Binomial. got \" + y;\n      double w = 1;\n      double eta = 0, mu = 0, var = 1;\n      if( _glm.family != Family.gaussian) {\n        if( _beta == null ) {\n          mu = _glm.mustart(y);\n          eta = _glm.link(mu);\n        } else {\n          eta = computeEta(ncats, cats,nums);\n          mu = _glm.linkInv(eta);\n        }\n        _val.add(y, mu);\n        var = Math.max(1e-5, _glm.variance(mu)); // avoid numerical problems with 0 variance\n        if( _glm.family == Family.binomial || _glm.family == Family.poisson ) {\n          w = var;\n          y = eta + (y - mu) / var;\n        } else {\n          double dp = _glm.linkInvDeriv(eta);\n          w = dp * dp / var;\n          y = eta + (y - mu) / dp;\n        }\n      }\n      assert w >= 0 : \"invalid weight \" + w;\n      _yy += 0.5 * w * y * y;\n      double wy = w * y;\n      for(int i = 0; i < ncats; ++i)_xy[cats[i]] += wy;\n      final int numStart = _catOffsets[_cats];\n      for(int i = 0; i < nums.length; ++i)_xy[numStart+i] += wy*nums[i];\n      _xy[numStart + _nums] += wy;\n      _gram.addRow(nums, ncats, cats, w);\n    }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public void map(Chunk [] chunks){\n    final int nrows = chunks[0]._len;\n    double [] nums = MemoryManager.malloc8d(_nums);\n    int    [] cats = MemoryManager.malloc4(_cats);\n    final int step = _complement?_step:1;\n    final int start = _complement?_offset:0;\n\n    OUTER:\n    for(int r = start; r < nrows; r += step){\n      if(_step > step && (r % _step) == _offset)continue;\n      for(Chunk c:chunks)if(c.isNA0(r))continue OUTER; // skip rows with NAs!\n      int i = 0, ncats = 0;\n      for(; i < _cats; ++i){\n        int c = (int)chunks[i].at80(r);\n        if(c != 0)cats[ncats++] = c + _catOffsets[i] - 1;\n      }\n      for(;i < chunks.length-1;++i)\n        nums[i-_cats] = (chunks[i].at0(r) - _normSub[i-_cats])*_normMul[i-_cats];\n      processRow(nums, ncats, cats, chunks[chunks.length-1].at0(r));\n    }\n  }","id":77326,"modified_method":"/**\n   * Extracts the values, applies regularization to numerics, adds appropriate offsets to categoricals,\n   * and adapts response according to the CaseMode/CaseValue if set.\n   */\n  @Override public void map(Chunk [] chunks){\n    final int nrows = chunks[0]._len;\n    double [] nums = MemoryManager.malloc8d(_nums);\n    int    [] cats = MemoryManager.malloc4(_cats);\n    final int step = _complement?_step:1;\n    final int start = _complement?_offset:0;\n\n    OUTER:\n    for(int r = start; r < nrows; r += step){\n      if(_step > step && (r % _step) == _offset)continue;\n      for(Chunk c:chunks)if(c.isNA0(r))continue OUTER; // skip rows with NAs!\n      int i = 0, ncats = 0;\n      for(; i < _cats; ++i){\n        int c = (int)chunks[i].at80(r);\n        if(c != 0)cats[ncats++] = c + _catOffsets[i] - 1;\n      }\n      for(;i < chunks.length-1;++i)\n        nums[i-_cats] = (chunks[i].at0(r) - _normSub[i-_cats])*_normMul[i-_cats];\n      double y = chunks[chunks.length-1].at0(r);\n      if( _caseMode != CaseMode.none ) y = (_caseMode.isCase(y, _caseVal)) ? 1 : 0;\n      processRow(nums, ncats, cats,y);\n    }\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void generateHTML(String title, StringBuilder sb) {\n      super.generateHTML(title, sb);\n      // add links to the xval models\n      sb.append(\"<h4>Cross Validation Models<\/h4>\");\n      sb.append(\"<table class='table table-bordered table-condensed'>\");\n      int i = 0;\n      for(Key k:_xvalModels){\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\" + \"<a href='Inspect.html?key=\"+k+\"'>\" + \"Model \" + ++i + \"<\/a><\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }","id":77327,"modified_method":"@Override public void generateHTML(String title, StringBuilder sb) {\n      super.generateHTML(_xvalModels.length + \"-fold Cross Validation\", sb);\n      // add links to the xval models\n      sb.append(\"<h4>Cross Validation Models<\/h4>\");\n      sb.append(\"<table class='table table-bordered table-condensed'>\");\n      int i = 0;\n      for(Key k:_xvalModels){\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\" + \"<a href='Inspect.html?key=\"+k+\"'>\" + \"Model \" + ++i + \"<\/a><\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void generateHTML(String title, StringBuilder sb) {\n    sb.append(\"<h4>Validation on: \" + dataKey + \"<\/h4>\");\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    final long null_dof = nobs-1, res_dof = Math.max(0,nobs-_rank-1);\n    sb.append(\"<tr><th>Degrees of freedom:<\/th><td>\" + null_dof + \" total (i.e. Null); \" + res_dof + \" Residual<\/td><\/tr>\");\n    sb.append(\"<tr><th>Null Deviance<\/th><td>\" + null_deviance + \"<\/td><\/tr>\");\n    sb.append(\"<tr><th>Residual Deviance<\/th><td>\" + residual_deviance + \"<\/td><\/tr>\");\n    sb.append(\"<tr><th>AIC<\/th><td>\" + aic() + \"<\/td><\/tr>\");\n    sb.append(\"<tr><th>Training Error Rate Avg<\/th><td>\" + avg_err + \"<\/td><\/tr>\");\n    if(_glm.family == Family.binomial)sb.append(\"<tr><th>AUC<\/th><td>\" + auc() + \"<\/td><\/tr>\");\n    sb.append(\"<\/table>\");\n\n    if(_glm.family == Family.binomial){\n      int best = 0;\n      for(int i = 1; i < _cms.length; ++i){\n        if(Math.max(_cms[i].classErr(0),_cms[i].classErr(1)) < Math.max(_cms[best].classErr(0),_cms[best].classErr(1)))\n          best = i;\n      }\n      sb.append(\"<span><b>Confusion Matrix at decision threshold:<\/b><\/span><span>\" + DEFAULT_THRESHOLDS[best] + \"<\/span>\");\n      confusionHTML(_cms[best], sb);\n    }\n  }","id":77328,"modified_method":"public void generateHTML(String title, StringBuilder sb) {\n    sb.append(\"<h4>\" + title + \"<\/h4>\");\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    final long null_dof = nobs-1, res_dof = Math.max(0,nobs-_rank-1);\n    sb.append(\"<tr><th>Degrees of freedom:<\/th><td>\" + null_dof + \" total (i.e. Null); \" + res_dof + \" Residual<\/td><\/tr>\");\n    sb.append(\"<tr><th>Null Deviance<\/th><td>\" + null_deviance + \"<\/td><\/tr>\");\n    sb.append(\"<tr><th>Residual Deviance<\/th><td>\" + residual_deviance + \"<\/td><\/tr>\");\n    sb.append(\"<tr><th>AIC<\/th><td>\" + aic() + \"<\/td><\/tr>\");\n    sb.append(\"<tr><th>Training Error Rate Avg<\/th><td>\" + avg_err + \"<\/td><\/tr>\");\n    if(_glm.family == Family.binomial)sb.append(\"<tr><th>AUC<\/th><td>\" + auc() + \"<\/td><\/tr>\");\n    sb.append(\"<\/table>\");\n\n    if(_glm.family == Family.binomial){\n      int best = 0;\n      for(int i = 1; i < _cms.length; ++i){\n        if(Math.max(_cms[i].classErr(0),_cms[i].classErr(1)) < Math.max(_cms[best].classErr(0),_cms[best].classErr(1)))\n          best = i;\n      }\n      sb.append(\"<span><b>Confusion Matrix at decision threshold:<\/b><\/span><span>\" + DEFAULT_THRESHOLDS[best] + \"<\/span>\");\n      confusionHTML(_cms[best], sb);\n    }\n  }","commit_id":"7aec20e7c30c59f6ad6bc7fcffc72cf8fad00edc","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected File runWithProject( List goals,\n                                   Properties properties )\n        throws Exception\n    {\n        /*\n        if ( request.getBaseDirectory() == null || !new File( request.getBaseDirectory() ).exists() )\n        {\n            throw new IllegalStateException( \"You must specify a valid base directory in your execution request for this test.\" );\n        }\n        */\n\n        File testDirectory = new File( getBasedir(), \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( getBasedir(), \"target/\" + getId() );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setShowErrors( true )\n            .setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_DEBUG )\n            .setBaseDirectory( targetDirectory )\n            .setGoals( goals );\n\n        System.out.println( \"properties = \" + properties );\n\n        if ( properties != null )\n        {\n            request.setProperties( properties );\n        }\n\n        MavenExecutionResult result = maven.execute( request );\n\n        assertNoExceptions( result );\n\n        return targetDirectory;\n    }","id":77329,"modified_method":"protected File runWithProject( List goals,\n                                   Properties properties )\n        throws Exception\n    {\n        /*\n        if ( request.getBaseDirectory() == null || !new File( request.getBaseDirectory() ).exists() )\n        {\n            throw new IllegalStateException( \"You must specify a valid base directory in your execution request for this test.\" );\n        }\n        */\n\n        File testDirectory = new File( getBasedir(), \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( getBasedir(), \"target/\" + getId() );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setShowErrors( true )\n            //.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_DEBUG )\n            .setBaseDirectory( targetDirectory )\n            .setGoals( goals );\n\n        System.out.println( \"properties = \" + properties );\n\n        if ( properties != null )\n        {\n            request.setProperties( properties );\n        }\n\n        MavenExecutionResult result = maven.execute( request );\n\n        assertNoExceptions( result );\n\n        return targetDirectory;\n    }","commit_id":"18e797c7d061db47d24199c1a8545f051223a6ae","url":"https://github.com/apache/maven"},{"original_method":"public void test()\n        throws Exception\n    {\n        Configuration configuration = new DefaultConfiguration();\n        configuration.setMavenEmbedderLogger( new MavenEmbedderConsoleLogger() );\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        File pom = new File( \"src/test/projects/bad-module-non-recursive/pom.xml\" ).getCanonicalFile();\n\n        System.out.println( pom.getCanonicalFile() );\n\n        DefaultMavenExecutionRequest request = new DefaultMavenExecutionRequest();\n        request.setOffline( false );\n        request.setUseReactor( false );\n        request.setRecursive( false );\n        request.setLoggingLevel( Logger.LEVEL_DEBUG );\n        request.setPom( pom );\n        request.setBaseDirectory( pom.getParentFile() );\n        MavenExecutionResult result = embedder.readProjectWithDependencies( request );\n        MavenProject project = result.getProject();\n\n        if ( result.hasExceptions() )\n        {\n            for ( Iterator it = result.getExceptions().iterator(); it.hasNext(); )\n            {\n                Exception ex = (Exception) it.next();\n                ex.printStackTrace();\n            }\n        }\n\n        assertNotNull( project );\n    }","id":77330,"modified_method":"public void test()\n        throws Exception\n    {\n        Configuration configuration = new DefaultConfiguration();\n        configuration.setMavenEmbedderLogger( new MavenEmbedderConsoleLogger() );\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        File pom = new File( \"src/test/projects/bad-module-non-recursive/pom.xml\" ).getCanonicalFile();\n\n        System.out.println( pom.getCanonicalFile() );\n\n        DefaultMavenExecutionRequest request = new DefaultMavenExecutionRequest();\n        request.setOffline( false );\n        request.setUseReactor( false );\n        request.setRecursive( false );\n        //request.setLoggingLevel( Logger.LEVEL_DEBUG );\n        request.setPom( pom );\n        request.setBaseDirectory( pom.getParentFile() );\n        MavenExecutionResult result = embedder.readProjectWithDependencies( request );\n        MavenProject project = result.getProject();\n\n        if ( result.hasExceptions() )\n        {\n            for ( Iterator it = result.getExceptions().iterator(); it.hasNext(); )\n            {\n                Exception ex = (Exception) it.next();\n                ex.printStackTrace();\n            }\n        }\n\n        assertNotNull( project );\n    }","commit_id":"18e797c7d061db47d24199c1a8545f051223a6ae","url":"https://github.com/apache/maven"},{"original_method":"public void testReportProjectDependenciesUnresolvable()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n\n        reporter.reportProjectDependenciesUnresolvable( null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"compile\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","id":77331,"modified_method":"public void testReportProjectDependenciesUnresolvable()\n        throws URISyntaxException, IOException\n    {\n//        File projectDir = prepareProjectDir();\n//\n//        reporter.reportProjectDependenciesUnresolvable( null, null, null );\n//        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n//        reporterCtl.setVoidCallable();\n//\n//        reporterCtl.replay();\n//\n//        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n//                                                                          .setShowErrors( true )\n//                                                                          .setErrorReporter( reporter )\n//                                                                          .setGoals( Arrays.asList( new String[] {\n//                                                                              \"compile\"\n//                                                                          } ) );\n//\n//        maven.execute( request );\n//\n//        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"public void testReportErrorParsingProjectModel_XmlPullParserException()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n\n        reporter.reportErrorParsingProjectModel( null, null, (XmlPullParserException) null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setLoggingLevel( Logger.LEVEL_DEBUG )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"initialize\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","id":77332,"modified_method":"public void testReportErrorParsingProjectModel_XmlPullParserException()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n\n        reporter.reportErrorParsingProjectModel( null, null, (XmlPullParserException) null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"initialize\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"public void testReportErrorInterpolatingModel_UsingModelInstance()\n    {\n        // TODO Auto-generated method stub\n\n    }","id":77333,"modified_method":"public void testReportErrorInterpolatingModel_UsingModelInstance()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n\n        reporter.reportErrorInterpolatingModel( null, null, null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"compile\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"public void testReportLifecycleLoaderErrorWhileValidatingTask()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n        File localRepo = new File( projectDir, \"local-repo\" );\n\n        Settings settings = new Settings();\n        settings.setLocalRepository( localRepo.getAbsolutePath() );\n        settings.setOffline( true );\n\n        reporter.reportLifecycleLoaderErrorWhileValidatingTask( null, null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setLoggingLevel( Logger.LEVEL_DEBUG )\n                                                                          .setSettings( settings )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"invalid:test\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","id":77334,"modified_method":"public void testReportLifecycleLoaderErrorWhileValidatingTask()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n        File localRepo = new File( projectDir, \"local-repo\" );\n\n        Settings settings = new Settings();\n        settings.setLocalRepository( localRepo.getAbsolutePath() );\n        settings.setOffline( true );\n\n        reporter.reportLifecycleLoaderErrorWhileValidatingTask( null, null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setSettings( settings )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"invalid:test\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"public void testReportErrorLoadingExternalProfilesFromFile_XmlPullParserException()\n    {\n        // TODO Auto-generated method stub\n\n    }","id":77335,"modified_method":"public void testReportErrorLoadingExternalProfilesFromFile_XmlPullParserException()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n\n        reporter.reportErrorLoadingExternalProfilesFromFile( null, null, null, (XmlPullParserException) null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"initialize\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"public void testReportErrorInterpolatingModel_UsingProjectInstance()\n    {\n        // TODO Auto-generated method stub\n\n    }","id":77336,"modified_method":"public void testReportErrorInterpolatingModel_UsingProjectInstance()\n        throws URISyntaxException, IOException\n    {\n        if ( !checkOnline() )\n        {\n            return;\n        }\n\n        File projectDir = prepareProjectDir();\n        File localRepo = new File( projectDir, \"local-repo\" );\n        File project = new File( projectDir, \"project\" );\n\n        reporter.reportErrorInterpolatingModel( null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( project )\n                                                                          .setLocalRepositoryPath( localRepo )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"compile\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"public void testReportErrorLoadingExternalProfilesFromFile_IOException()\n    {\n        // TODO Auto-generated method stub\n\n    }","id":77337,"modified_method":"public void testReportErrorLoadingExternalProfilesFromFile_IOException()\n        throws URISyntaxException, IOException\n    {\n        File projectDir = prepareProjectDir();\n\n        reporter.reportErrorLoadingExternalProfilesFromFile( null, null, null, (IOException) null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( projectDir )\n                                                                          .setShowErrors( true )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"initialize\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"1071c589dc98fe0a5dea95e18e769c2b76acff5d","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Logs result of the executed build.\n     * @param request - build parameters\n     * @param result - result of build\n     * @param logger - the logger to use\n     */\n    public static void logResult( MavenExecutionRequest request,\n                           MavenExecutionResult result,\n                           MavenEmbedderLogger logger )\n    {\n        ReactorManager reactorManager = result.getReactorManager();\n\n        logReactorSummary( reactorManager, logger );\n\n        boolean printSuccess = true;\n        if ( ( reactorManager != null ) && reactorManager.hasBuildFailures() )\n        {\n            for ( Iterator i = result.getExceptions().iterator(); i.hasNext(); )\n            {\n                Exception e = (Exception) i.next();\n\n                showError( e, request.isShowErrors(), request.getErrorReporter(), logger );\n            }\n\n            line( logger );\n            if ( !request.isShowErrors() )\n            {\n                logger.info( \"For more information, run with the -e flag\" );\n                line( logger );\n            }\n\n            if ( !ReactorManager.FAIL_NEVER.equals( reactorManager.getFailureBehavior() ) )\n            {\n                logger.info( \"BUILD FAILED\" );\n\n                line( logger );\n\n                stats( request.getStartTime(), logger );\n\n                line( logger );\n                printSuccess = false;\n            }\n            else\n            {\n                logger.info( \" + Ignoring build failures\" );\n            }\n        }\n\n        if ( printSuccess )\n        {\n            line( logger );\n\n            logger.info( \"BUILD SUCCESSFUL\" );\n\n            line( logger );\n\n            stats( request.getStartTime(), logger );\n\n            line( logger );\n        }\n\n        logger.close();\n    }","id":77338,"modified_method":"/**\n     * Logs result of the executed build.\n     * @param request - build parameters\n     * @param result - result of build\n     * @param logger - the logger to use\n     */\n    public static void logResult( MavenExecutionRequest request,\n                           MavenExecutionResult result,\n                           MavenEmbedderLogger logger )\n    {\n        ReactorManager reactorManager = result.getReactorManager();\n\n        logReactorSummary( reactorManager, logger );\n\n        boolean printSuccess = true;\n        if ( ( reactorManager == null ) || reactorManager.hasBuildFailures() )\n        {\n            for ( Iterator i = result.getExceptions().iterator(); i.hasNext(); )\n            {\n                Exception e = (Exception) i.next();\n\n                showError( e, request.isShowErrors(), request.getErrorReporter(), logger );\n            }\n\n            line( logger );\n            if ( !request.isShowErrors() )\n            {\n                logger.info( \"For more information, run with the -e flag\" );\n                line( logger );\n            }\n\n            if ( ( reactorManager != null ) && !ReactorManager.FAIL_NEVER.equals( reactorManager.getFailureBehavior() ) )\n            {\n                logger.info( \"BUILD FAILED\" );\n\n                line( logger );\n\n                stats( request.getStartTime(), logger );\n\n                line( logger );\n                printSuccess = false;\n            }\n            else\n            {\n                logger.info( \" + Ignoring build failures\" );\n            }\n        }\n\n        if ( printSuccess )\n        {\n            line( logger );\n\n            logger.info( \"BUILD SUCCESSFUL\" );\n\n            line( logger );\n\n            stats( request.getStartTime(), logger );\n\n            line( logger );\n        }\n\n        logger.close();\n    }","commit_id":"a0297f1d5b6f6bb75d29992bc6e28767ebfa4a40","url":"https://github.com/apache/maven"},{"original_method":"public void testReportExtensionPluginVersionNotFound()\n        throws IOException\n    {\n        File projectDir = prepareProjectDir();\n        File localRepo = new File( projectDir, \"local-repo\" );\n        File project = new File( projectDir, \"project\" );\n\n        Settings settings = new Settings();\n        settings.setOffline( true );\n        settings.setLocalRepository( localRepo.getAbsolutePath() );\n\n        reporter.reportExtensionPluginVersionNotFound( null, null, null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( project )\n                                                                          .setShowErrors( true )\n                                                                          .setLoggingLevel( Logger.LEVEL_DEBUG )\n                                                                          .setSettings( settings )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"initialize\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","id":77339,"modified_method":"public void testReportExtensionPluginVersionNotFound()\n        throws IOException\n    {\n        File projectDir = prepareProjectDir();\n        File localRepo = new File( projectDir, \"local-repo\" );\n        File project = new File( projectDir, \"project\" );\n\n        Settings settings = new Settings();\n        settings.setOffline( true );\n        settings.setLocalRepository( localRepo.getAbsolutePath() );\n\n        reporter.reportExtensionPluginVersionNotFound( null, null, null, null, null );\n        reporterCtl.setMatcher( MockControl.ALWAYS_MATCHER );\n        reporterCtl.setVoidCallable();\n\n        reporterCtl.replay();\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setBaseDirectory( project )\n                                                                          .setShowErrors( true )\n                                                                          .setSettings( settings )\n                                                                          .setErrorReporter( reporter )\n                                                                          .setGoals( Arrays.asList( new String[] {\n                                                                              \"initialize\"\n                                                                          } ) );\n\n        maven.execute( request );\n\n        reporterCtl.verify();\n    }","commit_id":"a0297f1d5b6f6bb75d29992bc6e28767ebfa4a40","url":"https://github.com/apache/maven"},{"original_method":"private MuleEvent processResponses(MuleEvent event, List<ProcessingMuleEventWork> works)\n        throws MuleException\n    {\n        List<MuleEvent> responses = new ArrayList<MuleEvent>(works.size());\n\n        long remainingTimeout = timeout;\n        for (int routeIndex = 0; routeIndex < works.size(); routeIndex++)\n        {\n            MuleEvent response = null;\n            Exception exception = null;\n\n            ProcessingMuleEventWork work = works.get(routeIndex);\n            MessageProcessor route = routes.get(routeIndex);\n\n            long startedAt = System.currentTimeMillis();\n            try\n            {\n                response = work.getResult(remainingTimeout, TimeUnit.MILLISECONDS);\n            }\n            catch (ResponseTimeoutException e)\n            {\n                exception = e;\n            }\n            catch (InterruptedException e)\n            {\n                throw new DefaultMuleException(MessageFactory.createStaticMessage(String.format(\n                    \"Was interrupted while waiting for route %d\", routeIndex)), e);\n            }\n            catch (Exception e)\n            {\n                exception = new DispatchException(MessageFactory.createStaticMessage(String.format(\n                    \"route number %d failed to be executed\", routeIndex)), event, route, e);\n            }\n\n            remainingTimeout -= System.currentTimeMillis() - startedAt;\n\n            if (exception != null)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\n                        String.format(\"route %d generated exception for MuleEvent %s\", routeIndex,\n                            event.getId()), exception);\n                }\n                response = DefaultMuleEvent.copy(event);\n                response.getMessage().setExceptionPayload(new DefaultExceptionPayload(exception));\n            }\n            else\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(String.format(\"route %d executed successfully for event %s\", routeIndex,\n                        event.getId()));\n                }\n            }\n\n            responses.add(response);\n        }\n\n        return aggregationStrategy.aggregate(new AggregationContext(event, responses));\n    }","id":77340,"modified_method":"private MuleEvent processResponses(MuleEvent event, List<ProcessingMuleEventWork> works)\n        throws MuleException\n    {\n        List<MuleEvent> responses = new ArrayList<MuleEvent>(works.size());\n\n        long remainingTimeout = timeout;\n        for (int routeIndex = 0; routeIndex < works.size(); routeIndex++)\n        {\n            MuleEvent response = null;\n            Exception exception = null;\n\n            ProcessingMuleEventWork work = works.get(routeIndex);\n            MessageProcessor route = routes.get(routeIndex);\n\n            long startedAt = System.currentTimeMillis();\n            try\n            {\n                response = work.getResult(remainingTimeout, TimeUnit.MILLISECONDS);\n            }\n            catch (ResponseTimeoutException e)\n            {\n                exception = e;\n            }\n            catch (InterruptedException e)\n            {\n                throw new DefaultMuleException(MessageFactory.createStaticMessage(String.format(\n                    \"Was interrupted while waiting for route %d\", routeIndex)), e);\n            }\n            catch (MessagingException e)\n            {\n                exception = wrapInDispatchException(e.getEvent(), routeIndex, route, e);\n            }\n            catch (Exception e)\n            {\n                exception = wrapInDispatchException(event, routeIndex, route, e);\n            }\n\n            remainingTimeout -= System.currentTimeMillis() - startedAt;\n\n            if (exception != null)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\n                        String.format(\"route %d generated exception for MuleEvent %s\", routeIndex,\n                            event.getId()), exception);\n                }\n\n                if (exception instanceof MessagingException)\n                {\n                    response = DefaultMuleEvent.copy(((MessagingException) exception).getEvent());\n                }\n                else\n                {\n                    response = DefaultMuleEvent.copy(event);\n                }\n\n                if (response.getMessage().getExceptionPayload() == null)\n                {\n                    response.getMessage().setExceptionPayload(new DefaultExceptionPayload(exception));\n                }\n            }\n            else\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(String.format(\"route %d executed successfully for event %s\", routeIndex,\n                        event.getId()));\n                }\n            }\n\n            responses.add(response);\n        }\n\n        return aggregationStrategy.aggregate(new AggregationContext(event, responses));\n    }","commit_id":"c5eba1e8943461e92a86d1b7625a7effa3725e4b","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void defaultHandler(Throwable t) {\n        logException(t);\n        RequestContext.setExceptionPayload(new ExceptionPayload(t));\n    }","id":77341,"modified_method":"protected void defaultHandler(Throwable t) {\n        logException(t);\n        if(RequestContext.getEvent()!=null) {\n            RequestContext.setExceptionPayload(new ExceptionPayload(t));\n        }\n    }","commit_id":"03204e695c48a501a0f43efd587568361cc0b389","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Returns a formatted string that is a summary of the configuration of\n     * the server.  This is the brock of information that gets displayed when\n     * the server starts\n     * @return a string summary of the server information\n     */\n    protected String getStartSplash()\n    {\n        String notset = new Message(Messages.NOT_SET).getMessage();\n\n        List message = new ArrayList();\n        Manifest mf = config.getManifest();\n        Map att = mf.getMainAttributes();\n        if (att.values().size() > 0)\n        {\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Title\"), notset)\n                    + \" \" + new Message(Messages.VERSION).getMessage() + PropertiesHelper.getStringProperty(att,\n                      \" \" + new Attributes.Name(\"Implementation-Version\"), notset));\n\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Vendor\"), notset));\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Implementation-Vendor\"), notset));\n        } else\n        {\n            message.add(new Message(Messages.VERSION_INFO_NOT_SET).getMessage());\n        }\n        message.add(\" \");\n        message.add(new Message(Messages.SERVER_STARTED_AT_X, new Date(getStartDate()).toString()).getMessage());\n        message.add(\"JDK: \" + System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vm.info\") + \")\");\n        message.add(\" \");\n        if(agents.size()==0) {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage() + \" \" + new Message(Messages.NONE).getMessage());\n        } else {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage());\n            UMOAgent umoAgent;\n            for (Iterator iterator = agents.values().iterator(); iterator.hasNext();)\n            {\n                umoAgent = (UMOAgent) iterator.next();\n                message.add(\"  \" + umoAgent.getDescription());\n            }\n        }\n        return StringMessageHelper.getBoilerPlate(message, '*', 70);\n    }","id":77342,"modified_method":"/**\n     * Returns a formatted string that is a summary of the configuration of\n     * the server.  This is the brock of information that gets displayed when\n     * the server starts\n     * @return a string summary of the server information\n     */\n    protected String getStartSplash()\n    {\n        String notset = new Message(Messages.NOT_SET).getMessage();\n\n        List message = new ArrayList();\n        Manifest mf = config.getManifest();\n        Map att = mf.getMainAttributes();\n        if (att.values().size() > 0)\n        {\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Title\"), notset)\n                    + \" \" + new Message(Messages.VERSION).getMessage() + PropertiesHelper.getStringProperty(att,\n                      new Attributes.Name(\"Implementation-Version\"), notset));\n\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Vendor\"), notset));\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Implementation-Vendor\"), notset));\n        } else\n        {\n            message.add(new Message(Messages.VERSION_INFO_NOT_SET).getMessage());\n        }\n        message.add(\" \");\n        message.add(new Message(Messages.SERVER_STARTED_AT_X, new Date(getStartDate()).toString()).getMessage());\n        message.add(\"JDK: \" + System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vm.info\") + \")\");\n        message.add(\" \");\n        if(agents.size()==0) {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage() + \" \" + new Message(Messages.NONE).getMessage());\n        } else {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage());\n            UMOAgent umoAgent;\n            for (Iterator iterator = agents.values().iterator(); iterator.hasNext();)\n            {\n                umoAgent = (UMOAgent) iterator.next();\n                message.add(\"  \" + umoAgent.getDescription());\n            }\n        }\n        return StringMessageHelper.getBoilerPlate(message, '*', 70);\n    }","commit_id":"03204e695c48a501a0f43efd587568361cc0b389","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void defaultHandler(Throwable t) {\n        logException(t);\n        RequestContext.setExceptionPayload(new ExceptionPayload(t));\n    }","id":77343,"modified_method":"protected void defaultHandler(Throwable t) {\n        logException(t);\n        if(RequestContext.getEvent()!=null) {\n            RequestContext.setExceptionPayload(new ExceptionPayload(t));\n        }\n    }","commit_id":"4da188fc3267d283f043e3cce93f1c27af81319e","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Returns a formatted string that is a summary of the configuration of\n     * the server.  This is the brock of information that gets displayed when\n     * the server starts\n     * @return a string summary of the server information\n     */\n    protected String getStartSplash()\n    {\n        String notset = new Message(Messages.NOT_SET).getMessage();\n\n        List message = new ArrayList();\n        Manifest mf = config.getManifest();\n        Map att = mf.getMainAttributes();\n        if (att.values().size() > 0)\n        {\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Title\"), notset)\n                    + \" \" + new Message(Messages.VERSION).getMessage() + PropertiesHelper.getStringProperty(att,\n                      \" \" + new Attributes.Name(\"Implementation-Version\"), notset));\n\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Vendor\"), notset));\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Implementation-Vendor\"), notset));\n        } else\n        {\n            message.add(new Message(Messages.VERSION_INFO_NOT_SET).getMessage());\n        }\n        message.add(\" \");\n        message.add(new Message(Messages.SERVER_STARTED_AT_X, new Date(getStartDate()).toString()).getMessage());\n        message.add(\"JDK: \" + System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vm.info\") + \")\");\n        message.add(\" \");\n        if(agents.size()==0) {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage() + \" \" + new Message(Messages.NONE).getMessage());\n        } else {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage());\n            UMOAgent umoAgent;\n            for (Iterator iterator = agents.values().iterator(); iterator.hasNext();)\n            {\n                umoAgent = (UMOAgent) iterator.next();\n                message.add(\"  \" + umoAgent.getDescription());\n            }\n        }\n        return StringMessageHelper.getBoilerPlate(message, '*', 70);\n    }","id":77344,"modified_method":"/**\n     * Returns a formatted string that is a summary of the configuration of\n     * the server.  This is the brock of information that gets displayed when\n     * the server starts\n     * @return a string summary of the server information\n     */\n    protected String getStartSplash()\n    {\n        String notset = new Message(Messages.NOT_SET).getMessage();\n\n        List message = new ArrayList();\n        Manifest mf = config.getManifest();\n        Map att = mf.getMainAttributes();\n        if (att.values().size() > 0)\n        {\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Title\"), notset)\n                    + \" \" + new Message(Messages.VERSION).getMessage() + PropertiesHelper.getStringProperty(att,\n                      new Attributes.Name(\"Implementation-Version\"), notset));\n\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Specification-Vendor\"), notset));\n            message.add(PropertiesHelper.getStringProperty(att, new Attributes.Name(\"Implementation-Vendor\"), notset));\n        } else\n        {\n            message.add(new Message(Messages.VERSION_INFO_NOT_SET).getMessage());\n        }\n        message.add(\" \");\n        message.add(new Message(Messages.SERVER_STARTED_AT_X, new Date(getStartDate()).toString()).getMessage());\n        message.add(\"JDK: \" + System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vm.info\") + \")\");\n        message.add(\" \");\n        if(agents.size()==0) {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage() + \" \" + new Message(Messages.NONE).getMessage());\n        } else {\n            message.add(new Message(Messages.AGENTS_RUNNING).getMessage());\n            UMOAgent umoAgent;\n            for (Iterator iterator = agents.values().iterator(); iterator.hasNext();)\n            {\n                umoAgent = (UMOAgent) iterator.next();\n                message.add(\"  \" + umoAgent.getDescription());\n            }\n        }\n        return StringMessageHelper.getBoilerPlate(message, '*', 70);\n    }","commit_id":"4da188fc3267d283f043e3cce93f1c27af81319e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Iterable<? extends ChildNodeEntry> getChildNodeEntries() {\n        init();\n        Iterable<ChildNodeEntry> iterable = iterable(childNames);\n        if (childNodeCount > childNames.size()) {\n            List<Iterable<ChildNodeEntry>> iterables = Lists.newArrayList();\n            iterables.add(iterable);\n            long offset = childNames.size();\n            while (offset < childNodeCount) {\n                iterables.add(getChildNodeEntries(offset, MAX_CHILD_NODE_NAMES));\n                offset += MAX_CHILD_NODE_NAMES;\n            }\n            iterable = Iterables.concat(iterables);\n        }\n        return iterable;\n    }","id":77345,"modified_method":"@Override\n    public Iterable<? extends ChildNodeEntry> getChildNodeEntries() {\n        init();\n        if (childNodeCount <= childNames.size()) {\n            return iterable(childNames);\n        }\n        List<Iterable<ChildNodeEntry>> iterables = Lists.newArrayList();\n        iterables.add(iterable(childNames));\n        iterables.add(getChildNodeEntries(childNames.size()));\n        return Iterables.concat(iterables);\n    }","commit_id":"e5c15e87e81a3141985a77682197b007e0648942","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Iterable<ChildNodeEntry> getChildNodeEntries(\n            final long offset, final int count) {\n        return new Iterable<ChildNodeEntry>() {\n            @Override\n            public Iterator<ChildNodeEntry> iterator() {\n                List<ChildNodeEntry> entries =\n                        Lists.newArrayListWithCapacity(count);\n                String json = kernel.getNodes(\n                        path, revision, 0, offset, count, null);\n                JsopReader reader = new JsopTokenizer(json);\n                reader.read('{');\n                do {\n                    String name = StringCache.get(reader.readString());\n                    reader.read(':');\n                    if (reader.matches('{')) {\n                        reader.read('}');\n                        entries.add(new KernelChildNodeEntry(name));\n                    } else if (reader.matches('[')) {\n                        while (reader.read() != ']') {\n                            // skip\n                        }\n                    } else {\n                        reader.read();\n                    }\n                } while (reader.matches(','));\n                reader.read('}');\n                reader.read(JsopReader.END);\n                return entries.iterator();\n            }\n        };\n    }","id":77346,"modified_method":"private Iterable<ChildNodeEntry> getChildNodeEntries(final long offset) {\n        return new Iterable<ChildNodeEntry>() {\n            @Override\n            public Iterator<ChildNodeEntry> iterator() {\n                return new Iterator<ChildNodeEntry>() {\n                    private long currentOffset = offset;\n                    private Iterator<ChildNodeEntry> current;\n\n                    {\n                        fetchEntries();\n                    }\n\n                    private void fetchEntries() {\n                        List<ChildNodeEntry> entries = Lists\n                                .newArrayListWithCapacity(MAX_CHILD_NODE_NAMES);\n                        String json = kernel.getNodes(path, revision, 0,\n                                currentOffset, MAX_CHILD_NODE_NAMES, null);\n                        JsopReader reader = new JsopTokenizer(json);\n                        reader.read('{');\n                        do {\n                            String name = StringCache.get(reader.readString());\n                            reader.read(':');\n                            if (reader.matches('{')) {\n                                reader.read('}');\n                                entries.add(new KernelChildNodeEntry(name));\n                            } else if (reader.matches('[')) {\n                                while (reader.read() != ']') {\n                                    // skip\n                                }\n                            } else {\n                                reader.read();\n                            }\n                        } while (reader.matches(','));\n                        reader.read('}');\n                        reader.read(JsopReader.END);\n                        if (entries.isEmpty()) {\n                            current = null;\n                        } else {\n                            currentOffset += entries.size();\n                            current = entries.iterator();\n                        }\n                    }\n\n                    @Override\n                    public boolean hasNext() {\n                        while (true) {\n                            if (current == null) {\n                                return false;\n                            } else if (current.hasNext()) {\n                                return true;\n                            }\n                            fetchEntries();\n                        }\n                    }\n\n                    @Override\n                    public ChildNodeEntry next() {\n                        if (!hasNext()) {\n                            throw new IllegalStateException(\n                                    \"Reading past the end\");\n                        }\n                        return current.next();\n                    }\n\n                    @Override\n                    public void remove() {\n                        throw new UnsupportedOperationException();\n                    }\n                    \n                };\n            }\n        };\n    }","commit_id":"e5c15e87e81a3141985a77682197b007e0648942","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public String getPathInfo()\n        {\n            String pathInfo = super.getPathInfo();\n            if (isForwardingDispatcher() || !isWrapperFor(ServletRequestWrapper.class))\n            {\n                pathInfo = this.requestInfo.pathInfo;\n            }\n            return pathInfo;\n        }","id":77347,"modified_method":"@Override\n        public String getPathInfo()\n        {\n            if ( this.isInclusionDispatcher() )\n            {\n                return super.getPathInfo();\n            }\n            return this.requestInfo.pathInfo;\n        }","commit_id":"0474147436561858bdb6844e0ccb8f3d0c9f7550","url":"https://github.com/apache/felix"},{"original_method":"@Override\n        public String getServletPath()\n        {\n            String servletPath = super.getServletPath();\n            if (isForwardingDispatcher() || !isWrapperFor(ServletRequestWrapper.class))\n            {\n                servletPath = this.requestInfo.servletPath;\n            }\n            if (\"/\".equals(servletPath))\n            {\n                return \"\"; // XXX still necessary?\n            }\n            return servletPath;\n        }","id":77348,"modified_method":"@Override\n        public String getServletPath()\n        {\n            if ( isInclusionDispatcher() )\n            {\n                return super.getServletPath();\n            }\n            return this.requestInfo.servletPath;\n        }","commit_id":"0474147436561858bdb6844e0ccb8f3d0c9f7550","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Responsible for dispatching a given request to the actual applicable servlet and/or filters in the local registry.\n     *\n     * @param req the {@link ServletRequest} to dispatch;\n     * @param res the {@link ServletResponse} to dispatch.\n     * @throws ServletException in case of exceptions during the actual dispatching;\n     * @throws IOException in case of I/O problems.\n     */\n    public void dispatch(final HttpServletRequest req, final HttpServletResponse res) throws ServletException, IOException\n    {\n        // invalid sessions first\n        final HttpSession session = req.getSession(false);\n        if ( session != null )\n        {\n            final Set<Long> ids = HttpSessionWrapper.getExpiredSessionContextIds(session);\n            this.whiteboardManager.sessionDestroyed(session, ids);\n        }\n        String requestURI = getRequestURI(req);\n        if ( requestURI == null )\n        {\n            requestURI = \"\";\n        }\n\n        // Determine which servlets we should forward the request to...\n        final ServletHandler servletHandler = this.handlerRegistry.getServletHander(requestURI);\n\n        final HttpServletResponse wrappedResponse = new ServletResponseWrapper(req, res, servletHandler);\n        if ( servletHandler == null )\n        {\n            wrappedResponse.sendError(404);\n            return;\n        }\n\n        // strip of context path\n        requestURI = requestURI.substring(servletHandler.getContext().getContextPath().length());\n\n        final String servletPath = servletHandler.determineServletPath(requestURI);\n        String pathInfo = UriUtils.compactPath(UriUtils.relativePath(servletPath, requestURI));\n        String queryString = null; // XXX\n\n        ExtServletContext servletContext = (servletHandler != null) ? servletHandler.getContext() : null;\n        RequestInfo requestInfo = new RequestInfo(servletPath, pathInfo, queryString);\n\n        final HttpServletRequest wrappedRequest = new ServletRequestWrapper(req, servletContext, requestInfo, servletHandler.getContextServiceId());\n        final FilterHandler[] filterHandlers = this.handlerRegistry.getFilterHandlers(servletHandler, req.getDispatcherType(), requestURI);\n\n        try\n        {\n            if ( servletContext.getServletRequestListener() != null )\n            {\n                servletContext.getServletRequestListener().requestInitialized(new ServletRequestEvent(servletContext, wrappedRequest));\n            }\n            invokeChain(filterHandlers, servletHandler, wrappedRequest, wrappedResponse);\n        }\n        catch ( final Exception e)\n        {\n            req.setAttribute(RequestDispatcher.ERROR_EXCEPTION, e);\n            req.setAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE, e.getClass().getName());\n\n            wrappedResponse.sendError(500);\n        }\n        finally\n        {\n            if ( servletContext.getServletRequestListener() != null )\n            {\n                servletContext.getServletRequestListener().requestDestroyed(new ServletRequestEvent(servletContext, wrappedRequest));\n            }\n        }\n    }","id":77349,"modified_method":"/**\n     * Responsible for dispatching a given request to the actual applicable servlet and/or filters in the local registry.\n     *\n     * @param req the {@link ServletRequest} to dispatch;\n     * @param res the {@link ServletResponse} to dispatch.\n     * @throws ServletException in case of exceptions during the actual dispatching;\n     * @throws IOException in case of I/O problems.\n     */\n    public void dispatch(final HttpServletRequest req, final HttpServletResponse res) throws ServletException, IOException\n    {\n        // invalid sessions first\n        final HttpSession session = req.getSession(false);\n        if ( session != null )\n        {\n            final Set<Long> ids = HttpSessionWrapper.getExpiredSessionContextIds(session);\n            this.whiteboardManager.sessionDestroyed(session, ids);\n        }\n        String requestURI = getRequestURI(req);\n        if ( requestURI == null )\n        {\n            requestURI = \"\";\n        }\n\n        // Determine which servlets we should forward the request to...\n        final ServletHandler servletHandler = this.handlerRegistry.getServletHander(requestURI);\n\n        final HttpServletResponse wrappedResponse = new ServletResponseWrapper(req, res, servletHandler);\n        if ( servletHandler == null )\n        {\n            wrappedResponse.sendError(404);\n            return;\n        }\n\n        // strip of context path\n        requestURI = requestURI.substring(servletHandler.getContext().getContextPath().length() - req.getContextPath().length());\n\n        final String servletPath = servletHandler.determineServletPath(requestURI);\n        String pathInfo = UriUtils.compactPath(UriUtils.relativePath(servletPath, requestURI));\n        String queryString = null; // XXX\n\n        ExtServletContext servletContext = (servletHandler != null) ? servletHandler.getContext() : null;\n        final RequestInfo requestInfo = new RequestInfo(servletPath, pathInfo, queryString);\n\n        final HttpServletRequest wrappedRequest = new ServletRequestWrapper(req, servletContext, requestInfo, servletHandler.getContextServiceId());\n        final FilterHandler[] filterHandlers = this.handlerRegistry.getFilterHandlers(servletHandler, req.getDispatcherType(), requestURI);\n\n        try\n        {\n            if ( servletContext.getServletRequestListener() != null )\n            {\n                servletContext.getServletRequestListener().requestInitialized(new ServletRequestEvent(servletContext, wrappedRequest));\n            }\n            invokeChain(filterHandlers, servletHandler, wrappedRequest, wrappedResponse);\n        }\n        catch ( final Exception e)\n        {\n            req.setAttribute(RequestDispatcher.ERROR_EXCEPTION, e);\n            req.setAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE, e.getClass().getName());\n\n            wrappedResponse.sendError(500);\n        }\n        finally\n        {\n            if ( servletContext.getServletRequestListener() != null )\n            {\n                servletContext.getServletRequestListener().requestDestroyed(new ServletRequestEvent(servletContext, wrappedRequest));\n            }\n        }\n    }","commit_id":"0474147436561858bdb6844e0ccb8f3d0c9f7550","url":"https://github.com/apache/felix"},{"original_method":"@Override\n        public String getRequestURI()\n        {\n            String requestURI = super.getRequestURI();\n            if (isForwardingDispatcher() || !isWrapperFor(ServletRequestWrapper.class))\n            {\n                requestURI = concat(getContextPath(), this.requestInfo.requestURI);\n            }\n            return requestURI;\n        }","id":77350,"modified_method":"@Override\n        public String getRequestURI()\n        {\n            if ( isInclusionDispatcher() )\n            {\n                return super.getRequestURI();\n            }\n            return concat(getContextPath(), this.requestInfo.requestURI);\n        }","commit_id":"0474147436561858bdb6844e0ccb8f3d0c9f7550","url":"https://github.com/apache/felix"},{"original_method":"public String getShortName(final QualifiedName qualifiedName) {\n    String _xblockexpression = null;\n    {\n      final String lastSegment = qualifiedName.getLastSegment();\n      final int index = lastSegment.indexOf(\"$\");\n      String _xifexpression = null;\n      if ((index == (-1))) {\n        _xifexpression = lastSegment;\n      } else {\n        _xifexpression = lastSegment.substring(index);\n      }\n      _xblockexpression = _xifexpression;\n    }\n    return _xblockexpression;\n  }","id":77351,"modified_method":"/**\n   * Computes a short name from a qualified name. If the qualified name is a name with a name of a nested type,\n   * only the innermost name is returned as the short name, e.g {@code 'java.util.Map$Entry'.shortName} yields {@code 'Entry'}\n   */\n  public String getShortName(final QualifiedName qualifiedName) {\n    String _xblockexpression = null;\n    {\n      final String lastSegment = qualifiedName.getLastSegment();\n      final int index = lastSegment.lastIndexOf(\"$\");\n      String _xifexpression = null;\n      if ((index == (-1))) {\n        _xifexpression = lastSegment;\n      } else {\n        _xifexpression = lastSegment.substring(index);\n      }\n      _xblockexpression = _xifexpression;\n    }\n    return _xblockexpression;\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Iterable<PsiClass> _findPsiClasses(final PsiElement element) {\n    Iterable<PsiClass> _switchResult = null;\n    PsiElement _nearestLogicalContainer = this._iPsiLogicalContainerProvider.getNearestLogicalContainer(element);\n    final PsiElement container = _nearestLogicalContainer;\n    boolean _matched = false;\n    if (!_matched) {\n      if (container instanceof PsiClass) {\n        _matched=true;\n        _switchResult = Iterables.<PsiClass>filter(Collections.<PsiClass>unmodifiableList(CollectionLiterals.<PsiClass>newArrayList(((PsiClass)container))), PsiClass.class);\n      }\n    }\n    if (!_matched) {\n      if (container instanceof PsiMember) {\n        _matched=true;\n        PsiClass _containingClass = ((PsiMember)container).getContainingClass();\n        _switchResult = Iterables.<PsiClass>filter(Collections.<PsiClass>unmodifiableList(CollectionLiterals.<PsiClass>newArrayList(_containingClass)), PsiClass.class);\n      }\n    }\n    if (!_matched) {\n      Iterable<PsiClass> _xblockexpression = null;\n      {\n        final Iterable<PsiClass> psiClasses = this.getPsiClasses(element);\n        Iterable<PsiClass> _xifexpression = null;\n        boolean _isEmpty = IterableExtensions.isEmpty(psiClasses);\n        if (_isEmpty) {\n          PsiElement _parent = element.getParent();\n          _xifexpression = this.findPsiClasses(_parent);\n        } else {\n          _xifexpression = psiClasses;\n        }\n        _xblockexpression = _xifexpression;\n      }\n      _switchResult = _xblockexpression;\n    }\n    return _switchResult;\n  }","id":77352,"modified_method":"protected Iterable<PsiClass> _findPsiClasses(final PsiElement element) {\n    Iterable<PsiClass> _switchResult = null;\n    PsiElement _nearestLogicalContainer = this._iPsiLogicalContainerProvider.getNearestLogicalContainer(element);\n    final PsiElement container = _nearestLogicalContainer;\n    boolean _matched = false;\n    if (!_matched) {\n      if (container instanceof PsiClass) {\n        _matched=true;\n        _switchResult = Collections.<PsiClass>unmodifiableList(CollectionLiterals.<PsiClass>newArrayList(((PsiClass)container)));\n      }\n    }\n    if (!_matched) {\n      if (container instanceof PsiMember) {\n        _matched=true;\n        PsiClass _containingClass = ((PsiMember)container).getContainingClass();\n        _switchResult = Collections.<PsiClass>unmodifiableList(CollectionLiterals.<PsiClass>newArrayList(_containingClass));\n      }\n    }\n    if (!_matched) {\n      Iterable<PsiClass> _xblockexpression = null;\n      {\n        final Iterable<PsiClass> psiClasses = this.getPsiClasses(element);\n        Iterable<PsiClass> _xifexpression = null;\n        boolean _isEmpty = IterableExtensions.isEmpty(psiClasses);\n        if (_isEmpty) {\n          PsiElement _parent = element.getParent();\n          _xifexpression = this.findPsiClasses(_parent);\n        } else {\n          _xifexpression = psiClasses;\n        }\n        _xblockexpression = _xifexpression;\n      }\n      _switchResult = _xblockexpression;\n    }\n    return _switchResult;\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiClass findClass(final String qualifiedName, final GlobalSearchScope scope) {\n    PsiClass[] _findClasses = this.findClasses(qualifiedName, scope);\n    return IterableExtensions.<PsiClass>head(((Iterable<PsiClass>)Conversions.doWrapArray(_findClasses)));\n  }","id":77353,"modified_method":"@Override\n  public PsiClass findClass(final String qualifiedName, final GlobalSearchScope scope) {\n    Iterable<PsiClass> _doFindClasses = this.doFindClasses(qualifiedName, scope);\n    return IterableExtensions.<PsiClass>head(_doFindClasses);\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Iterable<String> getVariants(final String qualifiedName) {\n    AbstractJvmTypeProvider.ClassNameVariants _classNameVariants = new AbstractJvmTypeProvider.ClassNameVariants(qualifiedName);\n    Iterable<String> _iterable = IteratorExtensions.<String>toIterable(_classNameVariants);\n    return Iterables.<String>concat(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(qualifiedName)), _iterable);\n  }","id":77354,"modified_method":"protected Iterable<String> getVariants(final String qualifiedName) {\n    final Iterable<String> _function = new Iterable<String>() {\n      @Override\n      public Iterator<String> iterator() {\n        return new AbstractJvmTypeProvider.ClassNameVariants(qualifiedName);\n      }\n    };\n    return Iterables.<String>concat(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(qualifiedName)), _function);\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiClass[] findClasses(final String qualifiedName, final GlobalSearchScope scope) {\n    Iterable<String> _variants = this.getVariants(qualifiedName);\n    final Function1<String, Iterable<PsiClass>> _function = new Function1<String, Iterable<PsiClass>>() {\n      @Override\n      public Iterable<PsiClass> apply(final String it) {\n        return JvmTypesElementFinder.this.doFindClasses(it, scope);\n      }\n    };\n    Iterable<Iterable<PsiClass>> _map = IterableExtensions.<String, Iterable<PsiClass>>map(_variants, _function);\n    return ((PsiClass[])Conversions.unwrapArray(Iterables.<PsiClass>concat(_map), PsiClass.class));\n  }","id":77355,"modified_method":"@Override\n  public PsiClass[] findClasses(final String qualifiedName, final GlobalSearchScope scope) {\n    return ((PsiClass[])Conversions.unwrapArray(this.doFindClasses(qualifiedName, scope), PsiClass.class));\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Iterable<BaseXtextFile> findFiles(final String qualifiedName, final GlobalSearchScope scope) {\n    String _string = qualifiedName.toString();\n    Collection<BaseXtextFile> _get = this.exportedObjectQualifiedNameIndex.get(_string, this.project, scope);\n    final Function1<BaseXtextFile, Boolean> _function = new Function1<BaseXtextFile, Boolean>() {\n      @Override\n      public Boolean apply(final BaseXtextFile xtextFile) {\n        Language _language = xtextFile.getLanguage();\n        return Boolean.valueOf(Objects.equal(_language, JvmTypesElementFinder.this.language));\n      }\n    };\n    return IterableExtensions.<BaseXtextFile>filter(_get, _function);\n  }","id":77356,"modified_method":"protected Iterable<BaseXtextFile> findFiles(final String qualifiedName, final GlobalSearchScope scope) {\n    Collection<BaseXtextFile> _get = this.exportedObjectQualifiedNameIndex.get(qualifiedName, this.project, scope);\n    final Function1<BaseXtextFile, Boolean> _function = new Function1<BaseXtextFile, Boolean>() {\n      @Override\n      public Boolean apply(final BaseXtextFile xtextFile) {\n        Language _language = xtextFile.getLanguage();\n        return Boolean.valueOf(Objects.equal(_language, JvmTypesElementFinder.this.language));\n      }\n    };\n    return IterableExtensions.<BaseXtextFile>filter(_get, _function);\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Iterable<PsiClass> doFindClasses(final String variant, final GlobalSearchScope scope) {\n    Iterable<PsiClass> _xblockexpression = null;\n    {\n      final QualifiedName qualifiedName = this.toQualifiedName(variant);\n      Iterable<BaseXtextFile> _findFiles = this.findFiles(variant, scope);\n      final Function1<BaseXtextFile, Iterable<PsiClass>> _function = new Function1<BaseXtextFile, Iterable<PsiClass>>() {\n        @Override\n        public Iterable<PsiClass> apply(final BaseXtextFile it) {\n          return JvmTypesElementFinder.this._jvmPsiClasses.getPsiClassesByQualifiedName(it, qualifiedName);\n        }\n      };\n      Iterable<Iterable<PsiClass>> _map = IterableExtensions.<BaseXtextFile, Iterable<PsiClass>>map(_findFiles, _function);\n      _xblockexpression = Iterables.<PsiClass>concat(_map);\n    }\n    return _xblockexpression;\n  }","id":77357,"modified_method":"protected Iterable<PsiClass> doFindClasses(final String qualifiedName, final GlobalSearchScope scope) {\n    Iterable<String> _variants = this.getVariants(qualifiedName);\n    final Function1<String, Iterable<PsiClass>> _function = new Function1<String, Iterable<PsiClass>>() {\n      @Override\n      public Iterable<PsiClass> apply(final String it) {\n        return JvmTypesElementFinder.this.doFindClassesByVariant(it, scope);\n      }\n    };\n    Iterable<Iterable<PsiClass>> _map = IterableExtensions.<String, Iterable<PsiClass>>map(_variants, _function);\n    return Iterables.<PsiClass>concat(_map);\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiField[] getFieldsByName(final String name, final GlobalSearchScope scope) {\n    return JvmTypesShortNamesCache.NO_FIELDS;\n  }","id":77358,"modified_method":"@Override\n  public PsiField[] getFieldsByName(final String name, final GlobalSearchScope scope) {\n    return PsiField.EMPTY_ARRAY;\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiClass[] getClassesByName(final String name, final GlobalSearchScope scope) {\n    ArrayList<PsiClass> _xblockexpression = null;\n    {\n      final ArrayList<PsiClass> result = CollectionLiterals.<PsiClass>newArrayList();\n      final Collection<BaseXtextFile> xtextFiles = this.jvmDeclaredTypeShortNameIndex.get(name, this.project, scope);\n      for (final BaseXtextFile xtextFile : xtextFiles) {\n        Language _language = xtextFile.getLanguage();\n        boolean _equals = Objects.equal(_language, this.language);\n        if (_equals) {\n          Iterable<PsiClass> _psiClassesByName = this._jvmPsiClasses.getPsiClassesByName(xtextFile, name);\n          Iterables.<PsiClass>addAll(result, _psiClassesByName);\n        }\n      }\n      _xblockexpression = result;\n    }\n    return ((PsiClass[])Conversions.unwrapArray(_xblockexpression, PsiClass.class));\n  }","id":77359,"modified_method":"@Override\n  public PsiClass[] getClassesByName(final String name, final GlobalSearchScope scope) {\n    ArrayList<PsiClass> _xblockexpression = null;\n    {\n      final Collection<BaseXtextFile> xtextFiles = this.jvmDeclaredTypeShortNameIndex.get(name, this.project, scope);\n      boolean _isEmpty = xtextFiles.isEmpty();\n      if (_isEmpty) {\n        return PsiClass.EMPTY_ARRAY;\n      }\n      final ArrayList<PsiClass> result = CollectionLiterals.<PsiClass>newArrayList();\n      for (final BaseXtextFile xtextFile : xtextFiles) {\n        Language _language = xtextFile.getLanguage();\n        boolean _equals = Objects.equal(_language, this.language);\n        if (_equals) {\n          Iterable<PsiClass> _psiClassesByName = this._jvmPsiClasses.getPsiClassesByName(xtextFile, name);\n          Iterables.<PsiClass>addAll(result, _psiClassesByName);\n        }\n      }\n      _xblockexpression = result;\n    }\n    return ((PsiClass[])Conversions.unwrapArray(_xblockexpression, PsiClass.class));\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiMethod[] getMethodsByNameIfNotMoreThan(final String name, final GlobalSearchScope scope, final int maxCount) {\n    return JvmTypesShortNamesCache.NO_METHODS;\n  }","id":77360,"modified_method":"@Override\n  public PsiMethod[] getMethodsByNameIfNotMoreThan(final String name, final GlobalSearchScope scope, final int maxCount) {\n    return PsiMethod.EMPTY_ARRAY;\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiField[] getFieldsByNameIfNotMoreThan(final String name, final GlobalSearchScope scope, final int maxCount) {\n    return JvmTypesShortNamesCache.NO_FIELDS;\n  }","id":77361,"modified_method":"@Override\n  public PsiField[] getFieldsByNameIfNotMoreThan(final String name, final GlobalSearchScope scope, final int maxCount) {\n    return PsiField.EMPTY_ARRAY;\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PsiMethod[] getMethodsByName(final String name, final GlobalSearchScope scope) {\n    return JvmTypesShortNamesCache.NO_METHODS;\n  }","id":77362,"modified_method":"@Override\n  public PsiMethod[] getMethodsByName(final String name, final GlobalSearchScope scope) {\n    return PsiMethod.EMPTY_ARRAY;\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void getAllClassNames(final HashSet<String> dest) {\n    String[] _allClassNames = this.getAllClassNames();\n    Iterables.<String>addAll(dest, ((Iterable<? extends String>)Conversions.doWrapArray(_allClassNames)));\n  }","id":77363,"modified_method":"@Override\n  public void getAllClassNames(final HashSet<String> dest) {\n    CommonProcessors.CollectProcessor<String> _collectProcessor = new CommonProcessors.CollectProcessor<String>(dest);\n    this.processAllClassNames(_collectProcessor);\n  }","commit_id":"426c35c0d1aa8884926ca2c3c863e82747e45cad","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Iterable<PsiJavaFile> collectJavaFiles(final PsiElement[] elements) {\n    final Function1<PsiElement, Iterable<PsiJavaFile>> _function = new Function1<PsiElement, Iterable<PsiJavaFile>>() {\n      @Override\n      public Iterable<PsiJavaFile> apply(final PsiElement it) {\n        Iterable<PsiJavaFile> _xifexpression = null;\n        if ((it instanceof PsiJavaFile)) {\n          _xifexpression = ImmutableList.<PsiJavaFile>of(((PsiJavaFile)it));\n        } else {\n          Iterable<PsiJavaFile> _xifexpression_1 = null;\n          PsiFile _containingFile = it.getContainingFile();\n          if ((_containingFile instanceof PsiJavaFile)) {\n            PsiFile _containingFile_1 = it.getContainingFile();\n            _xifexpression_1 = ImmutableList.<PsiJavaFile>of(((PsiJavaFile) _containingFile_1));\n          } else {\n            Iterable<PsiJavaFile> _xifexpression_2 = null;\n            if ((it instanceof PsiDirectory)) {\n              PsiElement[] _children = ((PsiDirectory)it).getChildren();\n              _xifexpression_2 = ConvertJavaCodeHandler.collectJavaFiles(_children);\n            }\n            _xifexpression_1 = _xifexpression_2;\n          }\n          _xifexpression = _xifexpression_1;\n        }\n        return _xifexpression;\n      }\n    };\n    List<Iterable<PsiJavaFile>> _map = ListExtensions.<PsiElement, Iterable<PsiJavaFile>>map(((List<PsiElement>)Conversions.doWrapArray(elements)), _function);\n    Iterable<Iterable<PsiJavaFile>> _filterNull = IterableExtensions.<Iterable<PsiJavaFile>>filterNull(_map);\n    final Iterable<PsiJavaFile> iterators = Iterables.<PsiJavaFile>concat(_filterNull);\n    return iterators;\n  }","id":77364,"modified_method":"public static Iterable<PsiJavaFile> collectJavaFiles(final PsiElement[] elements) {\n    final Function1<PsiElement, Iterable<PsiJavaFile>> _function = new Function1<PsiElement, Iterable<PsiJavaFile>>() {\n      @Override\n      public Iterable<PsiJavaFile> apply(final PsiElement it) {\n        Iterable<PsiJavaFile> _xifexpression = null;\n        if ((it instanceof PsiJavaFile)) {\n          _xifexpression = ImmutableList.<PsiJavaFile>of(((PsiJavaFile)it));\n        } else {\n          Iterable<PsiJavaFile> _xifexpression_1 = null;\n          PsiFile _containingFile = it.getContainingFile();\n          if ((_containingFile instanceof PsiJavaFile)) {\n            PsiFile _containingFile_1 = it.getContainingFile();\n            _xifexpression_1 = ImmutableList.<PsiJavaFile>of(((PsiJavaFile) _containingFile_1));\n          } else {\n            Iterable<PsiJavaFile> _xifexpression_2 = null;\n            if ((it instanceof PsiDirectory)) {\n              PsiElement[] _children = ((PsiDirectory)it).getChildren();\n              _xifexpression_2 = ConvertJavaCodeHandler.collectJavaFiles(_children);\n            }\n            _xifexpression_1 = _xifexpression_2;\n          }\n          _xifexpression = _xifexpression_1;\n        }\n        return _xifexpression;\n      }\n    };\n    final List<Iterable<PsiJavaFile>> iterables = ListExtensions.<PsiElement, Iterable<PsiJavaFile>>map(((List<PsiElement>)Conversions.doWrapArray(elements)), _function);\n    Iterable<Iterable<PsiJavaFile>> _filterNull = IterableExtensions.<Iterable<PsiJavaFile>>filterNull(iterables);\n    return Iterables.<PsiJavaFile>concat(_filterNull);\n  }","commit_id":"7e382822e273dea89cab392d0d77f529a94df10a","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * Configure a {@link Context} using the stored web.xml representation.\n     *  \n     * @param context   The context to be configured\n     */\n    public void configureContext(Context context) {\n        // As far as possible, process in alphabetical order so it is easy to\n        // check everything is present\n        // Some validation depends on correct public ID\n        context.setPublicId(publicId);\n\n        // Everything else in order\n        for (String contextParam : contextParams.keySet()) {\n            context.addParameter(contextParam, contextParams.get(contextParam));\n        }\n        context.setDisplayName(displayName);\n        context.setDistributable(distributable);\n        for (ContextLocalEjb ejbLocalRef : ejbLocalRefs) {\n            context.getNamingResources().addLocalEjb(ejbLocalRef);\n        }\n        for (ContextEjb ejbRef : ejbRefs) {\n            context.getNamingResources().addEjb(ejbRef);\n        }\n        for (ContextEnvironment environment : envEntries.values()) {\n            context.getNamingResources().addEnvironment(environment);\n        }\n        for (ErrorPage errorPage : errorPages) {\n            context.addErrorPage(errorPage);\n        }\n        for (FilterDef filter : filters.values()) {\n            context.addFilterDef(filter);\n        }\n        for (FilterMap filterMap : filterMaps) {\n            context.addFilterMap(filterMap);\n        }\n        // jsp-property-group needs to be after servlet configuration\n        for (String listener : listeners) {\n            context.addApplicationListener(listener);\n        }\n        for (String locale : localeEncodingMappings.keySet()) {\n            context.addLocaleEncodingMappingParameter(locale,\n                    localeEncodingMappings.get(locale));\n        }\n        // Prevents IAE\n        if (loginConfig != null) {\n            context.setLoginConfig(loginConfig);\n        }\n        for (MessageDestinationRef mdr : messageDestinationRefs.values()) {\n            context.getNamingResources().addMessageDestinationRef(mdr);\n        }\n\n        // messageDestinations were ignored in Tomcat 6, so ignore here\n        \n        // TODO SERVLET3 - This needs to be more fine-grained. Whether or not to\n        //                 process annotations on destroy() will depend on where\n        //                 the filter/servlet was loaded from. Joy.\n        context.setIgnoreAnnotations(metadataComplete);\n        for (String extension : mimeMappings.keySet()) {\n            context.addMimeMapping(extension, mimeMappings.get(extension));\n        }\n        // Name is just used for ordering\n        for (ContextResourceEnvRef resource : resourceEnvRefs.values()) {\n            context.getNamingResources().addResourceEnvRef(resource);\n        }\n        for (ContextResource resource : resourceRefs.values()) {\n            context.getNamingResources().addResource(resource);\n        }\n        for (SecurityConstraint constraint : securityConstraints) {\n            context.addConstraint(constraint);\n        }\n        for (String role : securityRoles) {\n            context.addSecurityRole(role);\n        }\n        for (ContextService service : serviceRefs) {\n            context.getNamingResources().addService(service);\n        }\n        for (ServletDef servlet : servlets.values()) {\n            Wrapper wrapper = context.createWrapper();\n            // Description is ignored\n            // Display name is ignored\n            // Icons are ignored\n            wrapper.setJspFile(servlet.getJspFile());\n            if (servlet.getLoadOnStartup() != null) {\n                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());\n            }\n            wrapper.setName(servlet.getServletName());\n            Map<String,String> params = servlet.getParameterMap(); \n            for (String param : params.keySet()) {\n                wrapper.addInitParameter(param, params.get(param));\n            }\n            wrapper.setRunAs(servlet.getRunAs());\n            Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs();\n            for (SecurityRoleRef roleRef : roleRefs) {\n                wrapper.addSecurityReference(\n                        roleRef.getName(), roleRef.getLink());\n            }\n            wrapper.setServletClass(servlet.getServletClass());\n            context.addChild(wrapper);\n        }\n        for (String pattern : servletMappings.keySet()) {\n            context.addServletMapping(pattern, servletMappings.get(pattern));\n        }\n        if (sessionTimeout != null) {\n            context.setSessionTimeout(sessionTimeout.intValue());\n        }\n        for (String uri : taglibs.keySet()) {\n            context.addTaglib(uri, taglibs.get(uri));\n        }\n        \n        // Context doesn't use version directly\n        \n        for (String welcomeFile : welcomeFiles) {\n            context.addWelcomeFile(welcomeFile);\n        }\n\n        // Do this last as it depends on servlets\n        for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) {\n            context.addJspMapping(jspPropertyGroup.getUrlPattern());\n        }\n    }","id":77365,"modified_method":"/**\n     * Configure a {@link Context} using the stored web.xml representation.\n     *  \n     * @param context   The context to be configured\n     */\n    public void configureContext(Context context) {\n        // As far as possible, process in alphabetical order so it is easy to\n        // check everything is present\n        // Some validation depends on correct public ID\n        context.setPublicId(publicId);\n\n        // Everything else in order\n        for (String contextParam : contextParams.keySet()) {\n            context.addParameter(contextParam, contextParams.get(contextParam));\n        }\n        context.setDisplayName(displayName);\n        context.setDistributable(distributable);\n        for (ContextLocalEjb ejbLocalRef : ejbLocalRefs) {\n            context.getNamingResources().addLocalEjb(ejbLocalRef);\n        }\n        for (ContextEjb ejbRef : ejbRefs) {\n            context.getNamingResources().addEjb(ejbRef);\n        }\n        for (ContextEnvironment environment : envEntries.values()) {\n            context.getNamingResources().addEnvironment(environment);\n        }\n        for (ErrorPage errorPage : errorPages) {\n            context.addErrorPage(errorPage);\n        }\n        for (FilterDef filter : filters.values()) {\n            context.addFilterDef(filter);\n        }\n        for (FilterMap filterMap : filterMaps) {\n            context.addFilterMap(filterMap);\n        }\n        // jsp-property-group needs to be after servlet configuration\n        for (String listener : listeners) {\n            context.addApplicationListener(listener);\n        }\n        for (String locale : localeEncodingMappings.keySet()) {\n            context.addLocaleEncodingMappingParameter(locale,\n                    localeEncodingMappings.get(locale));\n        }\n        // Prevents IAE\n        if (loginConfig != null) {\n            context.setLoginConfig(loginConfig);\n        }\n        for (MessageDestinationRef mdr : messageDestinationRefs.values()) {\n            context.getNamingResources().addMessageDestinationRef(mdr);\n        }\n\n        // messageDestinations were ignored in Tomcat 6, so ignore here\n        \n        // TODO SERVLET3 - This needs to be more fine-grained. Whether or not to\n        //                 process annotations on destroy() will depend on where\n        //                 the filter/servlet was loaded from. Joy.\n        context.setIgnoreAnnotations(metadataComplete);\n        for (String extension : mimeMappings.keySet()) {\n            context.addMimeMapping(extension, mimeMappings.get(extension));\n        }\n        // Name is just used for ordering\n        for (ContextResourceEnvRef resource : resourceEnvRefs.values()) {\n            context.getNamingResources().addResourceEnvRef(resource);\n        }\n        for (ContextResource resource : resourceRefs.values()) {\n            context.getNamingResources().addResource(resource);\n        }\n        for (SecurityConstraint constraint : securityConstraints) {\n            context.addConstraint(constraint);\n        }\n        for (String role : securityRoles) {\n            context.addSecurityRole(role);\n        }\n        for (ContextService service : serviceRefs) {\n            context.getNamingResources().addService(service);\n        }\n        for (ServletDef servlet : servlets.values()) {\n            Wrapper wrapper = context.createWrapper();\n            // Description is ignored\n            // Display name is ignored\n            // Icons are ignored\n            // Only set this if it is non-null else every servlet will get\n            // marked as the JSP servlet\n            String jspFile = servlet.getJspFile();\n            if (jspFile != null) {\n                wrapper.setJspFile(jspFile);\n            }\n            if (servlet.getLoadOnStartup() != null) {\n                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());\n            }\n            wrapper.setName(servlet.getServletName());\n            Map<String,String> params = servlet.getParameterMap(); \n            for (String param : params.keySet()) {\n                wrapper.addInitParameter(param, params.get(param));\n            }\n            wrapper.setRunAs(servlet.getRunAs());\n            Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs();\n            for (SecurityRoleRef roleRef : roleRefs) {\n                wrapper.addSecurityReference(\n                        roleRef.getName(), roleRef.getLink());\n            }\n            wrapper.setServletClass(servlet.getServletClass());\n            context.addChild(wrapper);\n        }\n        for (String pattern : servletMappings.keySet()) {\n            context.addServletMapping(pattern, servletMappings.get(pattern));\n        }\n        if (sessionTimeout != null) {\n            context.setSessionTimeout(sessionTimeout.intValue());\n        }\n        for (String uri : taglibs.keySet()) {\n            context.addTaglib(uri, taglibs.get(uri));\n        }\n        \n        // Context doesn't use version directly\n        \n        for (String welcomeFile : welcomeFiles) {\n            context.addWelcomeFile(welcomeFile);\n        }\n\n        // Do this last as it depends on servlets\n        for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) {\n            context.addJspMapping(jspPropertyGroup.getUrlPattern());\n        }\n    }","commit_id":"cc2f544cf867a886790d8de22f7a9b3c1af5d5be","url":"https://github.com/apache/tomcat"},{"original_method":"public static XmlDocument getRealXmlDocument(XmlDocument doc) {\n    final PsiFile containingFile = doc.getContainingFile();\n\n    if (PsiUtil.isInJspFile(containingFile)) {\n      final PsiFile baseLanguageRoot = (PsiUtil.getJspFile(containingFile)).getBaseLanguageRoot();\n      final PsiElement[] children = baseLanguageRoot.getChildren();\n\n      for (int i = 0; i < children.length; i++) {\n        PsiElement child = children[i];\n\n        if (child instanceof XmlDocument) {\n          doc = (XmlDocument)child;\n          break;\n        }\n      }\n    }\n    return doc;\n  }","id":77366,"modified_method":"public static XmlDocument getRealXmlDocument(XmlDocument doc) {\n    final PsiFile containingFile = doc.getContainingFile();\n\n    if (PsiUtil.isInJspFile(containingFile)) {\n      final JspFile jspFile = PsiUtil.getJspFile(containingFile);\n      \n      if (jspFile != null) { // it may be for some reason\n        final PsiFile baseLanguageRoot = jspFile.getBaseLanguageRoot();\n        final PsiElement[] children = baseLanguageRoot.getChildren();\n\n        for (PsiElement child : children) {\n          if (child instanceof XmlDocument) {\n            doc = (XmlDocument)child;\n            break;\n          }\n        }\n      }\n    }\n    return doc;\n  }","commit_id":"d6501955f76fc009fd900be51960e3d4f36900b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, Editor editor, PsiFile file, DataContext dataContext) {\n    editor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    PsiElement element = DataKeys.PSI_ELEMENT.getData(dataContext);\n    if (element != null) {\n      final com.intellij.lang.refactoring.InlineHandler languageSpecific =\n        element.getLanguage().getRefactoringSupportProvider().getInlineHandler();\n      if (languageSpecific != null) {\n        GenericInlineHandler.invoke(element, editor, languageSpecific);\n        return;\n      }\n    }\n\n    if (element instanceof PsiLocalVariable) {\n      final PsiReference psiReference = TargetElementUtil.findReference(editor);\n      final PsiReferenceExpression refExpr = psiReference instanceof PsiReferenceExpression ? ((PsiReferenceExpression)psiReference) : null;\n      InlineLocalHandler.invoke(project, editor, (PsiLocalVariable) element, refExpr);\n    } else if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      if (method.isConstructor() && !InlineMethodHandler.isChainingConstructor(method)) {\n        InlineToAnonymousClassHandler.invoke(project, editor, method.getContainingClass());\n      }\n      else {\n        InlineMethodHandler.invoke(project, editor, method);\n      }\n    } else if (element instanceof PsiField) {\n      InlineConstantFieldHandler.invoke(project, editor, (PsiField) element);\n    }\n    else if (element instanceof PsiClass) {\n      InlineToAnonymousClassHandler.invoke(project, editor, (PsiClass) element);\n    }\n    else if (PsiUtil.isInJspFile(file)) {\n      InlineIncludeFileHandler.invoke(project, editor, PsiUtil.getJspFile(file));\n    }\n    else {\n      String message =\n        RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"error.wrong.caret.position.method.or.local.name\"));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, null, project);\n    }\n  }","id":77367,"modified_method":"public void invoke(@NotNull final Project project, Editor editor, PsiFile file, DataContext dataContext) {\n    editor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    PsiElement element = DataKeys.PSI_ELEMENT.getData(dataContext);\n    if (element != null) {\n      final com.intellij.lang.refactoring.InlineHandler languageSpecific =\n        element.getLanguage().getRefactoringSupportProvider().getInlineHandler();\n      if (languageSpecific != null) {\n        GenericInlineHandler.invoke(element, editor, languageSpecific);\n        return;\n      }\n    }\n\n    JspFile jspFile;\n\n    if (element instanceof PsiLocalVariable) {\n      final PsiReference psiReference = TargetElementUtil.findReference(editor);\n      final PsiReferenceExpression refExpr = psiReference instanceof PsiReferenceExpression ? ((PsiReferenceExpression)psiReference) : null;\n      InlineLocalHandler.invoke(project, editor, (PsiLocalVariable) element, refExpr);\n    } else if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      if (method.isConstructor() && !InlineMethodHandler.isChainingConstructor(method)) {\n        InlineToAnonymousClassHandler.invoke(project, editor, method.getContainingClass());\n      }\n      else {\n        InlineMethodHandler.invoke(project, editor, method);\n      }\n    } else if (element instanceof PsiField) {\n      InlineConstantFieldHandler.invoke(project, editor, (PsiField) element);\n    }\n    else if (element instanceof PsiClass) {\n      InlineToAnonymousClassHandler.invoke(project, editor, (PsiClass) element);\n    }\n    else if (PsiUtil.isInJspFile(file) && (jspFile = PsiUtil.getJspFile(file)) != null) {\n      InlineIncludeFileHandler.invoke(project, editor, jspFile);\n    }\n    else {\n      String message =\n        RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"error.wrong.caret.position.method.or.local.name\"));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, null, project);\n    }\n  }","commit_id":"373e2cfabd523ba1aa8f31adb6be73d6b1687fd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doCollectInformation(ProgressIndicator progress) {\n    DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(myProject);\n    myRefCountHolder = ((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap().getRefCountHolder(myFile);\n    Runnable doCollectInfo = new Runnable() {\n      public void run() {\n        List<HighlightInfo> highlights = new ArrayList<HighlightInfo>();\n        final FileViewProvider viewProvider = myFile.getViewProvider();\n        final Set<Language> relevantLanguages = viewProvider.getPrimaryLanguages();\n        Set<PsiElement> elementSet = new THashSet<PsiElement>();\n        for (Language language : relevantLanguages) {\n          PsiElement psiRoot = viewProvider.getPsi(language);\n          if (!HighlightUtil.shouldHighlight(psiRoot)) continue;\n          List<PsiElement> elements = CodeInsightUtil.getElementsInRange(psiRoot, myStartOffset, myEndOffset);\n          elementSet.addAll(elements);\n        }\n        collectHighlights(elementSet, highlights);\n\n        boolean doubleCheckUsages = false;\n        if (PsiUtil.isInJspFile(myFile)) {\n          doubleCheckUsages = JspSpiUtil.isIncludedOrIncludesSomething(PsiUtil.getJspFile(myFile));\n        }\n\n        List<PsiNamedElement> unusedDcls = myRefCountHolder.getUnusedDcls();\n        for (PsiNamedElement unusedDcl : unusedDcls) {\n          if (doubleCheckUsages) {\n            if (ReferencesSearch.search(unusedDcl).findFirst() != null) continue;\n          }\n\n          String dclType = StringUtil.capitalize(UsageViewUtil.getType(unusedDcl));\n          if (dclType.length() == 0) dclType = LangBundle.message(\"java.terms.symbol\");\n          String message = MessageFormat.format(JavaErrorMessages.message(\"symbol.is.never.used\"), dclType, unusedDcl.getName());\n\n          HighlightInfo highlightInfo = createUnusedSymbolInfo(unusedDcl.getNavigationElement(), message);\n          highlights.add(highlightInfo);\n        }\n\n        myHighlights = highlights;\n      }\n    };\n    myRefCountHolder.retrieveUnusedReferencesInfo(doCollectInfo, progress);\n  }","id":77368,"modified_method":"public void doCollectInformation(ProgressIndicator progress) {\n    DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(myProject);\n    myRefCountHolder = ((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap().getRefCountHolder(myFile);\n    Runnable doCollectInfo = new Runnable() {\n      public void run() {\n        List<HighlightInfo> highlights = new ArrayList<HighlightInfo>();\n        final FileViewProvider viewProvider = myFile.getViewProvider();\n        final Set<Language> relevantLanguages = viewProvider.getPrimaryLanguages();\n        Set<PsiElement> elementSet = new THashSet<PsiElement>();\n        for (Language language : relevantLanguages) {\n          PsiElement psiRoot = viewProvider.getPsi(language);\n          if (!HighlightUtil.shouldHighlight(psiRoot)) continue;\n          List<PsiElement> elements = CodeInsightUtil.getElementsInRange(psiRoot, myStartOffset, myEndOffset);\n          elementSet.addAll(elements);\n        }\n        collectHighlights(elementSet, highlights);\n\n        boolean doubleCheckUsages = false;\n        if (PsiUtil.isInJspFile(myFile)) {\n          final JspFile jspFile = PsiUtil.getJspFile(myFile);\n          if (jspFile != null) {\n            doubleCheckUsages = JspSpiUtil.isIncludedOrIncludesSomething(jspFile);\n          }\n        }\n\n        List<PsiNamedElement> unusedDcls = myRefCountHolder.getUnusedDcls();\n        for (PsiNamedElement unusedDcl : unusedDcls) {\n          if (doubleCheckUsages) {\n            if (ReferencesSearch.search(unusedDcl).findFirst() != null) continue;\n          }\n\n          String dclType = StringUtil.capitalize(UsageViewUtil.getType(unusedDcl));\n          if (dclType.length() == 0) dclType = LangBundle.message(\"java.terms.symbol\");\n          String message = MessageFormat.format(JavaErrorMessages.message(\"symbol.is.never.used\"), dclType, unusedDcl.getName());\n\n          HighlightInfo highlightInfo = createUnusedSymbolInfo(unusedDcl.getNavigationElement(), message);\n          highlights.add(highlightInfo);\n        }\n\n        myHighlights = highlights;\n      }\n    };\n    myRefCountHolder.retrieveUnusedReferencesInfo(doCollectInfo, progress);\n  }","commit_id":"38f78aaad0c10250fba579823e4a6da32274c984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void collectHighlights(Collection<PsiElement> elements, List<HighlightInfo> array) throws ProcessCanceledException {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    InspectionProfile profile = InspectionProjectProfileManager.getInstance(myProject).getInspectionProfile(myFile);\n    boolean unusedSymbolEnabled = profile.isToolEnabled(HighlightDisplayKey.find(UnusedSymbolLocalInspection.SHORT_NAME));\n    boolean unusedImportEnabled = profile.isToolEnabled(HighlightDisplayKey.find(UnusedImportLocalInspection.SHORT_NAME));\n    LocalInspectionToolWrapper unusedSymbolTool = (LocalInspectionToolWrapper)profile.getInspectionTool(UnusedSymbolLocalInspection.SHORT_NAME);\n    final UnusedSymbolLocalInspection unusedSymbolInspection = unusedSymbolTool == null ? null : (UnusedSymbolLocalInspection)unusedSymbolTool.getTool();\n\n    if (unusedImportEnabled && PsiUtil.isInJspFile(myFile)) {\n      unusedImportEnabled = !JspSpiUtil.isIncludedOrIncludesSomething(PsiUtil.getJspFile(myFile));\n    }\n\n    for (PsiElement element : elements) {\n      ProgressManager.getInstance().checkCanceled();\n\n      if (element instanceof PsiIdentifier && unusedSymbolEnabled) {\n        final HighlightInfo highlightInfo = processIdentifier((PsiIdentifier)element,unusedSymbolInspection);\n        if (highlightInfo != null) array.add(highlightInfo);\n      }\n      else if (element instanceof PsiImportList && unusedImportEnabled) {\n        final PsiImportStatementBase[] imports = ((PsiImportList)element).getAllImportStatements();\n        for (PsiImportStatementBase statement : imports) {\n          final HighlightInfo highlightInfo = processImport(statement);\n          if (highlightInfo != null) array.add(highlightInfo);\n        }\n      }\n      else if (element instanceof XmlAttributeValue) {\n        final HighlightInfo highlightInfo = XmlHighlightVisitor.checkIdRefAttrValue((XmlAttributeValue)element, myRefCountHolder);\n        if (highlightInfo != null) array.add(highlightInfo);\n      }\n    }\n  }","id":77369,"modified_method":"private void collectHighlights(Collection<PsiElement> elements, List<HighlightInfo> array) throws ProcessCanceledException {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    InspectionProfile profile = InspectionProjectProfileManager.getInstance(myProject).getInspectionProfile(myFile);\n    boolean unusedSymbolEnabled = profile.isToolEnabled(HighlightDisplayKey.find(UnusedSymbolLocalInspection.SHORT_NAME));\n    boolean unusedImportEnabled = profile.isToolEnabled(HighlightDisplayKey.find(UnusedImportLocalInspection.SHORT_NAME));\n    LocalInspectionToolWrapper unusedSymbolTool = (LocalInspectionToolWrapper)profile.getInspectionTool(UnusedSymbolLocalInspection.SHORT_NAME);\n    final UnusedSymbolLocalInspection unusedSymbolInspection = unusedSymbolTool == null ? null : (UnusedSymbolLocalInspection)unusedSymbolTool.getTool();\n\n    if (unusedImportEnabled && PsiUtil.isInJspFile(myFile)) {\n      final JspFile jspFile = PsiUtil.getJspFile(myFile);\n      if (jspFile != null) {\n        unusedImportEnabled = !JspSpiUtil.isIncludedOrIncludesSomething(jspFile);\n      }\n    }\n\n    for (PsiElement element : elements) {\n      ProgressManager.getInstance().checkCanceled();\n\n      if (element instanceof PsiIdentifier && unusedSymbolEnabled) {\n        final HighlightInfo highlightInfo = processIdentifier((PsiIdentifier)element,unusedSymbolInspection);\n        if (highlightInfo != null) array.add(highlightInfo);\n      }\n      else if (element instanceof PsiImportList && unusedImportEnabled) {\n        final PsiImportStatementBase[] imports = ((PsiImportList)element).getAllImportStatements();\n        for (PsiImportStatementBase statement : imports) {\n          final HighlightInfo highlightInfo = processImport(statement);\n          if (highlightInfo != null) array.add(highlightInfo);\n        }\n      }\n      else if (element instanceof XmlAttributeValue) {\n        final HighlightInfo highlightInfo = XmlHighlightVisitor.checkIdRefAttrValue((XmlAttributeValue)element, myRefCountHolder);\n        if (highlightInfo != null) array.add(highlightInfo);\n      }\n    }\n  }","commit_id":"38f78aaad0c10250fba579823e4a6da32274c984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String[] collectNamesToImport(PsiJavaFile file, Set<String> namesToImportStaticly){\n    Set<String> names = new THashSet<String>();\n    collectNamesToImport(names, file, namesToImportStaticly);\n\n    if (PsiUtil.isInJspFile(file)) {\n      final PsiFile[] includingFiles = JspSpiUtil.getReferencingFiles(PsiUtil.getJspFile(file));\n      for (PsiFile includingFile : includingFiles) {\n        final PsiFile javaRoot = includingFile.getViewProvider().getPsi(StdLanguages.JAVA);\n        if (javaRoot instanceof PsiJavaFile && file != javaRoot) {\n          collectNamesToImport(names, (PsiJavaFile)javaRoot, namesToImportStaticly);\n        }\n      }\n    }\n\n    addUnresolvedImportNames(names, file, namesToImportStaticly);\n\n    return names.toArray(new String[names.size()]);\n  }","id":77370,"modified_method":"private static String[] collectNamesToImport(PsiJavaFile file, Set<String> namesToImportStaticly){\n    Set<String> names = new THashSet<String>();\n    collectNamesToImport(names, file, namesToImportStaticly);\n\n    final JspFile jspFile = PsiUtil.getJspFile(file);\n    if (jspFile != null) {\n      for (PsiFile includingFile : JspSpiUtil.getReferencingFiles(jspFile)) {\n        final PsiFile javaRoot = includingFile.getViewProvider().getPsi(StdLanguages.JAVA);\n        if (javaRoot instanceof PsiJavaFile && file != javaRoot) {\n          collectNamesToImport(names, (PsiJavaFile)javaRoot, namesToImportStaticly);\n        }\n      }\n      for (PsiFile includingFile : JspSpiUtil.getIncludedFiles(jspFile)) {\n        final PsiFile javaRoot = includingFile.getViewProvider().getPsi(StdLanguages.JAVA);\n        if (javaRoot instanceof PsiJavaFile && file != javaRoot) {\n          collectNamesToImport(names, (PsiJavaFile)javaRoot, namesToImportStaticly);\n        }\n      }\n    }\n\n    addUnresolvedImportNames(names, file, namesToImportStaticly);\n\n    return names.toArray(new String[names.size()]);\n  }","commit_id":"2edf8feea625b63df495b81342637d9a139d6363","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent event) {\n    DataContext dataContext = event.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n    final Editor editor = BaseCodeInsightAction.getInjectedEditor(project, PlatformDataKeys.EDITOR.getData(dataContext));\n\n    final VirtualFile[] files = (VirtualFile[])dataContext.getData(DataConstants.VIRTUAL_FILE_ARRAY);\n\n    PsiFile file = null;\n    PsiDirectory dir;\n\n    if (editor != null){\n      file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n      if (file == null) return;\n      dir = file.getContainingDirectory();\n    }\n    else if (ReformatCodeAction.areFiles(files)) {\n      final ReadonlyStatusHandler.OperationStatus operationStatus = ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(files);\n      if (!operationStatus.hasReadonlyFiles()) {\n        new OptimizeImportsProcessor(project, ReformatCodeAction.convertToPsiFiles(files, project), null).run();\n      }\n      return;\n    }\n    else{\n      Project projectContext = PlatformDataKeys.PROJECT_CONTEXT.getData(dataContext);\n      Module moduleContext = (Module)dataContext.getData(DataConstants.MODULE_CONTEXT);\n\n      if (projectContext != null || moduleContext != null) {\n        final String text;\n        if (moduleContext != null) {\n          text = CodeInsightBundle.message(\"process.scope.module\", moduleContext.getName());\n        }\n        else {\n          text = CodeInsightBundle.message(\"process.scope.project\", projectContext.getPresentableUrl());\n        }\n        LayoutProjectCodeDialog dialog = new LayoutProjectCodeDialog(project, CodeInsightBundle.message(\"process.optimize.imports\"), text, false);\n        dialog.show();\n        if (!dialog.isOK()) return;\n        if (moduleContext != null) {\n          new OptimizeImportsProcessor(project, moduleContext).run();\n        }\n        else {\n          new OptimizeImportsProcessor(projectContext).run();\n        }\n        return;\n      }\n\n      PsiElement element = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n      if (element == null) return;\n      if (element instanceof PsiDirectoryContainer) {\n        dir = ((PsiDirectoryContainer)element).getDirectories()[0];\n      }\n      else if (element instanceof PsiDirectory) {\n        dir = (PsiDirectory)element;\n      }\n      else{\n        file = element.getContainingFile();\n        if (file == null) return;\n        dir = file.getContainingDirectory();\n      }\n    }\n\n    boolean processDirectory;\n    boolean includeSubdirectories;\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      includeSubdirectories = processDirectory = false;\n    } else {\n      final LayoutCodeDialog dialog = new LayoutCodeDialog(project, CodeInsightBundle.message(\"process.optimize.imports\"), file, dir, null, HELP_ID);\n      dialog.show();\n      if (!dialog.isOK()) return;\n      processDirectory = dialog.isProcessDirectory();\n      includeSubdirectories = dialog.isIncludeSubdirectories();\n    }\n\n    if (processDirectory){\n      new OptimizeImportsProcessor(project, dir, includeSubdirectories).run();\n    }\n    else{\n      new OptimizeImportsProcessor(project, file).run();\n    }\n  }","id":77371,"modified_method":"public void actionPerformed(AnActionEvent event) {\n    actionPerformedImpl(event.getDataContext());\n  }","commit_id":"2edf8feea625b63df495b81342637d9a139d6363","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fromHdfsToTachyon(TachyonURI path) throws IOException {\n    if (!mTFS.exist(path)) {\n      Path hdfsPath = Utils.getHDFSPath(path);\n      FileSystem fs = hdfsPath.getFileSystem(getConf());\n      if (fs.exists(hdfsPath)) {\n        TachyonURI ufsAddrPath = path.makeQualified(new TachyonURI(mUnderFSAddress));\n        // Set the path as the TFS root path.\n        UfsUtils.loadUnderFs(mTFS, path, ufsAddrPath, new PrefixList(null));\n      }\n    }\n  }","id":77372,"modified_method":"private void fromHdfsToTachyon(TachyonURI path) throws IOException {\n    if (!mTFS.exist(path)) {\n      Path hdfsPath = Utils.getHDFSPath(path);\n      FileSystem fs = hdfsPath.getFileSystem(getConf());\n      if (fs.exists(hdfsPath)) {\n        TachyonURI ufsUri = new TachyonURI(mUnderFSAddress);\n        TachyonURI ufsAddrPath = new TachyonURI(ufsUri.getScheme(), ufsUri.getAuthority(), path.getPath());\n        // Set the path as the TFS root path.\n        UfsUtils.loadUnderFs(mTFS, path, ufsAddrPath, new PrefixList(null));\n      }\n    }\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FSDataOutputStream append(Path cPath, int bufferSize, Progressable progress)\n      throws IOException {\n    LOG.info(\"append(\" + cPath + \", \" + bufferSize + \", \" + progress + \")\");\n\n    String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n    TachyonURI path = new TachyonURI(pathWithoutScheme);\n    fromHdfsToTachyon(path);\n    int fileId = mTFS.getFileId(path);\n    TachyonFile file = mTFS.getFile(fileId);\n\n    if (file.length() > 0) {\n      LOG.warn(\"This maybe an error.\");\n    }\n\n    return new FSDataOutputStream(file.getOutStream(WriteType.CACHE_THROUGH), null);\n  }","id":77373,"modified_method":"@Override\n  public FSDataOutputStream append(Path cPath, int bufferSize, Progressable progress)\n      throws IOException {\n    LOG.info(\"append(\" + cPath + \", \" + bufferSize + \", \" + progress + \")\");\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    fromHdfsToTachyon(path);\n    int fileId = mTFS.getFileId(path);\n    TachyonFile file = mTFS.getFile(fileId);\n\n    if (file.length() > 0) {\n      LOG.warn(\"This maybe an error.\");\n    }\n\n    return new FSDataOutputStream(file.getOutStream(WriteType.CACHE_THROUGH), null);\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Return the status of a single file. If the file does not exist in Tachyon, query it from HDFS.\n   */\n  @Override\n  public FileStatus getFileStatus(Path path) throws IOException {\n    String pathWithoutScheme = Utils.getPathWithoutScheme(path);\n    TachyonURI tPath = new TachyonURI(pathWithoutScheme);\n    Path hdfsPath = Utils.getHDFSPath(tPath);\n\n    LOG.info(\"getFileStatus(\" + path + \"): HDFS Path: \" + hdfsPath + \" TPath: \" + mTachyonHeader\n        + tPath);\n    if (useHdfs()) {\n      fromHdfsToTachyon(tPath);\n    }\n    TachyonFile file = mTFS.getFile(tPath);\n    if (file == null) {\n      LOG.info(\"File does not exist: \" + path);\n      throw new FileNotFoundException(\"File does not exist: \" + path);\n    }\n\n    FileStatus ret =\n        new FileStatus(file.length(), file.isDirectory(), file.getDiskReplication(),\n            file.getBlockSizeByte(), file.getCreationTimeMs(), file.getCreationTimeMs(), null,\n            null, null, new Path(mTachyonHeader + tPath));\n    return ret;\n  }","id":77374,"modified_method":"/**\n   * Return the status of a single file. If the file does not exist in Tachyon, query it from HDFS.\n   */\n  @Override\n  public FileStatus getFileStatus(Path path) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath);\n\n    LOG.info(\"getFileStatus(\" + path + \"): HDFS Path: \" + hdfsPath + \" TPath: \" + mTachyonHeader\n        + tPath);\n    if (useHdfs()) {\n      fromHdfsToTachyon(tPath);\n    }\n    TachyonFile file = mTFS.getFile(tPath);\n    if (file == null) {\n      LOG.info(\"File does not exist: \" + path);\n      throw new FileNotFoundException(\"File does not exist: \" + path);\n    }\n\n    FileStatus ret =\n        new FileStatus(file.length(), file.isDirectory(), file.getDiskReplication(),\n            file.getBlockSizeByte(), file.getCreationTimeMs(), file.getCreationTimeMs(), null,\n            null, null, new Path(mTachyonHeader + tPath));\n    return ret;\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FSDataOutputStream create(Path cPath, FsPermission permission, boolean overwrite,\n      int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    LOG.info(\"create(\" + cPath + \", \" + permission + \", \" + overwrite + \", \" + bufferSize + \", \"\n        + replication + \", \" + blockSize + \", \" + progress + \")\");\n\n    if (!CommonConf.get().ASYNC_ENABLED) {\n      String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n      TachyonURI path = new TachyonURI(pathWithoutScheme);\n      if (mTFS.exist(path)) {\n        if (!mTFS.delete(path, false)) {\n          throw new IOException(\"Failed to delete existing data \" + cPath);\n        }\n      }\n      int fileId = mTFS.createFile(path, blockSize);\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      return new FSDataOutputStream(file.getOutStream(WriteType.CACHE_THROUGH), null);\n    }\n\n    if (cPath.toString().contains(FIRST_COM_PATH) && !cPath.toString().contains(\"SUCCESS\")) {\n      String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n      TachyonURI path = new TachyonURI(pathWithoutScheme);\n      mTFS.createFile(path, blockSize);\n      String depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(FIRST_COM_PATH) + FIRST_COM_PATH.length());\n      depPath = depPath.substring(0, depPath.indexOf(TachyonURI.SEPARATOR));\n      int depId = Integer.parseInt(depPath);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + depId);\n      depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(\"part-\") + 5);\n      int index = Integer.parseInt(depPath);\n      ClientDependencyInfo info = mTFS.getClientDependencyInfo(depId);\n      int fileId = info.getChildren().get(index);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + index + \" \" + info + \" \" + fileId);\n\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      // if (file.getBlockSizeByte() != blockSize) {\n      // throw new IOException(\"File already exist with a different blocksize \"\n      // file.getBlockSizeByte() + \" != \" + blockSize);\n      // }\n      return new FSDataOutputStream(file.getOutStream(WriteType.ASYNC_THROUGH), null);\n    }\n\n    if (cPath.toString().contains(RECOMPUTE_PATH) && !cPath.toString().contains(\"SUCCESS\")) {\n      String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n      TachyonURI path = new TachyonURI(pathWithoutScheme);\n      mTFS.createFile(path, blockSize);\n      String depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(RECOMPUTE_PATH) + RECOMPUTE_PATH.length());\n      depPath = depPath.substring(0, depPath.indexOf(TachyonURI.SEPARATOR));\n      int depId = Integer.parseInt(depPath);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + depId);\n      depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(\"part-\") + 5);\n      int index = Integer.parseInt(depPath);\n      ClientDependencyInfo info = mTFS.getClientDependencyInfo(depId);\n      int fileId = info.getChildren().get(index);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + index + \" \" + info + \" \" + fileId);\n\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      // if (file.getBlockSizeByte() != blockSize) {\n      // throw new IOException(\"File already exist with a different blocksize \"\n      // file.getBlockSizeByte() + \" != \" + blockSize);\n      // }\n      return new FSDataOutputStream(file.getOutStream(WriteType.ASYNC_THROUGH), null);\n    } else {\n      String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n      TachyonURI path = new TachyonURI(pathWithoutScheme);\n      int fileId;\n      WriteType type = WriteType.CACHE_THROUGH;\n      if (mTFS.exist(path)) {\n        fileId = mTFS.getFileId(path);\n        type = WriteType.MUST_CACHE;\n      } else {\n        fileId = mTFS.createFile(path, blockSize);\n      }\n\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      // if (file.getBlockSizeByte() != blockSize) {\n      // throw new IOException(\"File already exist with a different blocksize \"\n      // file.getBlockSizeByte() + \" != \" + blockSize);\n      // }\n      return new FSDataOutputStream(file.getOutStream(type), null);\n    }\n  }","id":77375,"modified_method":"@Override\n  public FSDataOutputStream create(Path cPath, FsPermission permission, boolean overwrite,\n      int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    LOG.info(\"create(\" + cPath + \", \" + permission + \", \" + overwrite + \", \" + bufferSize + \", \"\n        + replication + \", \" + blockSize + \", \" + progress + \")\");\n\n    if (!CommonConf.get().ASYNC_ENABLED) {\n      TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n      if (mTFS.exist(path)) {\n        if (!mTFS.delete(path, false)) {\n          throw new IOException(\"Failed to delete existing data \" + cPath);\n        }\n      }\n      int fileId = mTFS.createFile(path, blockSize);\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      return new FSDataOutputStream(file.getOutStream(WriteType.CACHE_THROUGH), null);\n    }\n\n    if (cPath.toString().contains(FIRST_COM_PATH) && !cPath.toString().contains(\"SUCCESS\")) {\n      TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n      mTFS.createFile(path, blockSize);\n      String depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(FIRST_COM_PATH) + FIRST_COM_PATH.length());\n      depPath = depPath.substring(0, depPath.indexOf(TachyonURI.SEPARATOR));\n      int depId = Integer.parseInt(depPath);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + depId);\n      depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(\"part-\") + 5);\n      int index = Integer.parseInt(depPath);\n      ClientDependencyInfo info = mTFS.getClientDependencyInfo(depId);\n      int fileId = info.getChildren().get(index);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + index + \" \" + info + \" \" + fileId);\n\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      // if (file.getBlockSizeByte() != blockSize) {\n      // throw new IOException(\"File already exist with a different blocksize \"\n      // file.getBlockSizeByte() + \" != \" + blockSize);\n      // }\n      return new FSDataOutputStream(file.getOutStream(WriteType.ASYNC_THROUGH), null);\n    }\n\n    if (cPath.toString().contains(RECOMPUTE_PATH) && !cPath.toString().contains(\"SUCCESS\")) {\n      TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n      mTFS.createFile(path, blockSize);\n      String depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(RECOMPUTE_PATH) + RECOMPUTE_PATH.length());\n      depPath = depPath.substring(0, depPath.indexOf(TachyonURI.SEPARATOR));\n      int depId = Integer.parseInt(depPath);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + depId);\n      depPath = path.getPath();\n      depPath = depPath.substring(depPath.indexOf(\"part-\") + 5);\n      int index = Integer.parseInt(depPath);\n      ClientDependencyInfo info = mTFS.getClientDependencyInfo(depId);\n      int fileId = info.getChildren().get(index);\n      LOG.info(\"create(\" + cPath + \") : \" + depPath + \" \" + index + \" \" + info + \" \" + fileId);\n\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      // if (file.getBlockSizeByte() != blockSize) {\n      // throw new IOException(\"File already exist with a different blocksize \"\n      // file.getBlockSizeByte() + \" != \" + blockSize);\n      // }\n      return new FSDataOutputStream(file.getOutStream(WriteType.ASYNC_THROUGH), null);\n    } else {\n      TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n      int fileId;\n      WriteType type = WriteType.CACHE_THROUGH;\n      if (mTFS.exist(path)) {\n        fileId = mTFS.getFileId(path);\n        type = WriteType.MUST_CACHE;\n      } else {\n        fileId = mTFS.createFile(path, blockSize);\n      }\n\n      TachyonFile file = mTFS.getFile(fileId);\n      file.setUFSConf(getConf());\n      // if (file.getBlockSizeByte() != blockSize) {\n      // throw new IOException(\"File already exist with a different blocksize \"\n      // file.getBlockSizeByte() + \" != \" + blockSize);\n      // }\n      return new FSDataOutputStream(file.getOutStream(type), null);\n    }\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean delete(Path cPath, boolean recursive) throws IOException {\n    LOG.info(\"delete(\" + cPath + \", \" + recursive + \")\");\n    String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n    TachyonURI path = new TachyonURI(pathWithoutScheme);\n    fromHdfsToTachyon(path);\n    return mTFS.delete(path, recursive);\n  }","id":77376,"modified_method":"@Override\n  public boolean delete(Path cPath, boolean recursive) throws IOException {\n    LOG.info(\"delete(\" + cPath + \", \" + recursive + \")\");\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    fromHdfsToTachyon(path);\n    return mTFS.delete(path, recursive);\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FSDataInputStream open(Path cPath, int bufferSize) throws IOException {\n    LOG.info(\"open(\" + cPath + \", \" + bufferSize + \")\");\n\n    String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n    TachyonURI path = new TachyonURI(pathWithoutScheme);\n    fromHdfsToTachyon(path);\n    int fileId = mTFS.getFileId(path);\n\n    return new FSDataInputStream(new HdfsFileInputStream(mTFS, fileId, Utils.getHDFSPath(path),\n        getConf(), bufferSize));\n  }","id":77377,"modified_method":"@Override\n  public FSDataInputStream open(Path cPath, int bufferSize) throws IOException {\n    LOG.info(\"open(\" + cPath + \", \" + bufferSize + \")\");\n\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    fromHdfsToTachyon(path);\n    int fileId = mTFS.getFileId(path);\n\n    return new FSDataInputStream(new HdfsFileInputStream(mTFS, fileId, Utils.getHDFSPath(path),\n        getConf(), bufferSize));\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean mkdirs(Path cPath, FsPermission permission) throws IOException {\n    LOG.info(\"mkdirs(\" + cPath + \", \" + permission + \")\");\n    String pathWithoutScheme = Utils.getPathWithoutScheme(cPath);\n    TachyonURI path = new TachyonURI(pathWithoutScheme);\n    return mTFS.mkdir(path);\n  }","id":77378,"modified_method":"@Override\n  public boolean mkdirs(Path cPath, FsPermission permission) throws IOException {\n    LOG.info(\"mkdirs(\" + cPath + \", \" + permission + \")\");\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    return mTFS.mkdir(path);\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * TODO: We need to refactor this method after having a new internal API support (TACHYON-46).\n   * <p>\n   * Opens an FSDataOutputStream at the indicated Path with write-progress reporting. Same as\n   * create(), except fails if parent directory doesn't already exist.\n   * \n   * @param cPath the file name to open\n   * @param overwrite if a file with this name already exists, then if true, the file will be\n   *        overwritten, and if false an error will be thrown.\n   * @param bufferSize the size of the buffer to be used.\n   * @param replication required block replication for the file.\n   * @param blockSize\n   * @param progress\n   * @throws IOException\n   * @see #setPermission(Path, FsPermission)\n   * @deprecated API only for 0.20-append\n   */\n  @Override\n  @Deprecated\n  public FSDataOutputStream createNonRecursive(Path cPath, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)\n      throws IOException {\n    String pathWithoutScheme = Utils.getPathWithoutScheme(cPath.getParent());\n    TachyonURI path = new TachyonURI(pathWithoutScheme);\n    fromHdfsToTachyon(path);\n    if (!mTFS.exist(path)) {\n      throw new FileNotFoundException(\"Parent directory does not exist!\");\n    }\n    return this.create(cPath, permission, overwrite, bufferSize, replication, blockSize, progress);\n  }","id":77379,"modified_method":"/**\n   * TODO: We need to refactor this method after having a new internal API support (TACHYON-46).\n   * <p>\n   * Opens an FSDataOutputStream at the indicated Path with write-progress reporting. Same as\n   * create(), except fails if parent directory doesn't already exist.\n   * \n   * @param cPath the file name to open\n   * @param overwrite if a file with this name already exists, then if true, the file will be\n   *        overwritten, and if false an error will be thrown.\n   * @param bufferSize the size of the buffer to be used.\n   * @param replication required block replication for the file.\n   * @param blockSize\n   * @param progress\n   * @throws IOException\n   * @see #setPermission(Path, FsPermission)\n   * @deprecated API only for 0.20-append\n   */\n  @Override\n  @Deprecated\n  public FSDataOutputStream createNonRecursive(Path cPath, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)\n      throws IOException {\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath.getParent()));\n    fromHdfsToTachyon(path);\n    if (!mTFS.exist(path)) {\n      throw new FileNotFoundException(\"Parent directory does not exist!\");\n    }\n    return this.create(cPath, permission, overwrite, bufferSize, replication, blockSize, progress);\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"rename(\" + src + \", \" + dst + \")\");\n    String srcPathWithoutScheme = Utils.getPathWithoutScheme(src);\n    String dstPathWithoutScheme = Utils.getPathWithoutScheme(dst);\n    TachyonURI srcPath = new TachyonURI(srcPathWithoutScheme);\n    TachyonURI dstPath = new TachyonURI(dstPathWithoutScheme);\n    fromHdfsToTachyon(srcPath);\n    return mTFS.rename(srcPath, dstPath);\n  }","id":77380,"modified_method":"@Override\n  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"rename(\" + src + \", \" + dst + \")\");\n    TachyonURI srcPath = new TachyonURI(Utils.getPathWithoutScheme(src));\n    TachyonURI dstPath = new TachyonURI(Utils.getPathWithoutScheme(dst));\n    fromHdfsToTachyon(srcPath);\n    return mTFS.rename(srcPath, dstPath);\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len)\n      throws IOException {\n    if (file == null) {\n      return null;\n    }\n\n    String pathWithoutScheme = Utils.getPathWithoutScheme(file.getPath());\n    TachyonURI path = new TachyonURI(pathWithoutScheme);\n    fromHdfsToTachyon(path);\n    int fileId = mTFS.getFileId(path);\n\n    if (fileId == -1) {\n      throw new FileNotFoundException(\"File does not exist: \" + file.getPath());\n    }\n\n    List<BlockLocation> blockLocations = new ArrayList<BlockLocation>();\n    List<ClientBlockInfo> blocks = mTFS.getFileBlocks(fileId);\n    for (int k = 0; k < blocks.size(); k ++) {\n      ClientBlockInfo info = blocks.get(k);\n      long offset = info.getOffset();\n      long end = offset + info.getLength();\n      if ((offset >= start && offset <= start + len) || (end >= start && end <= start + len)) {\n        ArrayList<String> names = new ArrayList<String>();\n        ArrayList<String> hosts = new ArrayList<String>();\n        for (NetAddress addr : info.getLocations()) {\n          names.add(addr.mHost);\n          hosts.add(addr.mHost);\n        }\n        blockLocations.add(new BlockLocation(CommonUtils.toStringArray(names), CommonUtils\n            .toStringArray(hosts), offset, info.getLength()));\n      }\n    }\n\n    BlockLocation[] ret = new BlockLocation[blockLocations.size()];\n    for (int k = 0; k < blockLocations.size(); k ++) {\n      ret[k] = blockLocations.get(k);\n    }\n    return ret;\n  }","id":77381,"modified_method":"@Override\n  public BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len)\n      throws IOException {\n    if (file == null) {\n      return null;\n    }\n\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(file.getPath()));\n    fromHdfsToTachyon(path);\n    int fileId = mTFS.getFileId(path);\n\n    if (fileId == -1) {\n      throw new FileNotFoundException(\"File does not exist: \" + file.getPath());\n    }\n\n    List<BlockLocation> blockLocations = new ArrayList<BlockLocation>();\n    List<ClientBlockInfo> blocks = mTFS.getFileBlocks(fileId);\n    for (int k = 0; k < blocks.size(); k ++) {\n      ClientBlockInfo info = blocks.get(k);\n      long offset = info.getOffset();\n      long end = offset + info.getLength();\n      if ((offset >= start && offset <= start + len) || (end >= start && end <= start + len)) {\n        ArrayList<String> names = new ArrayList<String>();\n        ArrayList<String> hosts = new ArrayList<String>();\n        for (NetAddress addr : info.getLocations()) {\n          names.add(addr.mHost);\n          hosts.add(addr.mHost);\n        }\n        blockLocations.add(new BlockLocation(CommonUtils.toStringArray(names), CommonUtils\n            .toStringArray(hosts), offset, info.getLength()));\n      }\n    }\n\n    BlockLocation[] ret = new BlockLocation[blockLocations.size()];\n    for (int k = 0; k < blockLocations.size(); k ++) {\n      ret[k] = blockLocations.get(k);\n    }\n    return ret;\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FileStatus[] listStatus(Path path) throws IOException {\n    String pathWithoutScheme = Utils.getPathWithoutScheme(path);\n    TachyonURI tPath = new TachyonURI(pathWithoutScheme);\n    Path hdfsPath = Utils.getHDFSPath(tPath);\n    LOG.info(\"listStatus(\" + path + \"): HDFS Path: \" + hdfsPath);\n\n    fromHdfsToTachyon(tPath);\n    if (!mTFS.exist(tPath)) {\n      throw new FileNotFoundException(\"File does not exist: \" + path);\n    }\n\n    List<ClientFileInfo> files = mTFS.listStatus(tPath);\n    FileStatus[] ret = new FileStatus[files.size()];\n    for (int k = 0; k < files.size(); k ++) {\n      ClientFileInfo info = files.get(k);\n      // TODO replicate 3 with the number of disk replications.\n      ret[k] =\n          new FileStatus(info.getLength(), info.isFolder, 3, info.getBlockSizeByte(),\n              info.getCreationTimeMs(), info.getCreationTimeMs(), null, null, null, new Path(\n                  mTachyonHeader + info.getPath()));\n    }\n    return ret;\n  }","id":77382,"modified_method":"@Override\n  public FileStatus[] listStatus(Path path) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath);\n    LOG.info(\"listStatus(\" + path + \"): HDFS Path: \" + hdfsPath);\n\n    fromHdfsToTachyon(tPath);\n    if (!mTFS.exist(tPath)) {\n      throw new FileNotFoundException(\"File does not exist: \" + path);\n    }\n\n    List<ClientFileInfo> files = mTFS.listStatus(tPath);\n    FileStatus[] ret = new FileStatus[files.size()];\n    for (int k = 0; k < files.size(); k ++) {\n      ClientFileInfo info = files.get(k);\n      // TODO replicate 3 with the number of disk replications.\n      ret[k] =\n          new FileStatus(info.getLength(), info.isFolder, 3, info.getBlockSizeByte(),\n              info.getCreationTimeMs(), info.getCreationTimeMs(), null, null, null, new Path(\n                  mTachyonHeader + info.getPath()));\n    }\n    return ret;\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Transform an input string like hdfs://host:port/dir, hdfs://host:port, file:///dir, /dir into a\n   * pair of address and path. The returned pairs are (\"hdfs://host:port\", \"/dir\"),\n   * (\"hdfs://host:port\", \"/\"), and (\"/\", \"/dir\"), respectively.\n   * \n   * @param path the input path string\n   * @return null if path does not start with tachyon://, tachyon-ft://, hdfs://, s3://, s3n://,\n   *         file://, /. Or a pair of strings denoting the under FS address and the relative path\n   *         relative to that address. For local FS (with prefixes file:// or /), the under FS\n   *         address is \"/\" and the path starts with \"/\".\n   */\n  public static Pair<String, String> parse(TachyonURI path) {\n    if (path == null) {\n      return null;\n    }\n\n    if (path.hasScheme()) {\n      String header = path.getScheme() + \"://\";\n      if (header.equals(Constants.HEADER) || header.equals(Constants.HEADER_FT)\n          || isHadoopUnderFS(header)) {\n        if (path.getPath().isEmpty()) {\n          return new Pair<String, String>(header + path.getAuthority(), TachyonURI.SEPARATOR);\n        } else {\n          return new Pair<String, String>(header + path.getAuthority(), path.getPath());\n        }\n      } else if (header.equals(\"file://\")) {\n        return new Pair<String, String>(TachyonURI.SEPARATOR, path.getPath());\n      }\n    } else if (path.isPathAbsolute()) {\n      return new Pair<String, String>(TachyonURI.SEPARATOR, path.getPath());\n    }\n\n    return null;\n  }","id":77383,"modified_method":"/**\n   * Transform an input string like hdfs://host:port/dir, hdfs://host:port, file:///dir, /dir into a\n   * pair of address and path. The returned pairs are (\"hdfs://host:port\", \"/dir\"),\n   * (\"hdfs://host:port\", \"/\"), and (\"/\", \"/dir\"), respectively.\n   * \n   * @param path the input path string\n   * @return null if path does not start with tachyon://, tachyon-ft://, hdfs://, s3://, s3n://,\n   *         file://, /. Or a pair of strings denoting the under FS address and the relative path\n   *         relative to that address. For local FS (with prefixes file:// or /), the under FS\n   *         address is \"/\" and the path starts with \"/\".\n   */\n  public static Pair<String, String> parse(TachyonURI path) {\n    if (path == null) {\n      return null;\n    }\n\n    if (path.hasScheme()) {\n      String header = path.getScheme() + \"://\";\n      String authority = (path.hasAuthority()) ? path.getAuthority() : \"\";\n      if (header.equals(Constants.HEADER) || header.equals(Constants.HEADER_FT)\n          || isHadoopUnderFS(header)) {\n        if (path.getPath().isEmpty()) {\n          return new Pair<String, String>(header + authority, TachyonURI.SEPARATOR);\n        } else {\n          return new Pair<String, String>(header + authority, path.getPath());\n        }\n      } else if (header.equals(\"file://\")) {\n        return new Pair<String, String>(TachyonURI.SEPARATOR, path.getPath());\n      }\n    } else if (path.isPathAbsolute()) {\n      return new Pair<String, String>(TachyonURI.SEPARATOR, path.getPath());\n    }\n\n    return null;\n  }","commit_id":"4b6918a3f06e5e5fb3987cde68734fc2225f54d8","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n\tpublic void apply(Project project) {\n\t\tfinal WorkspaceExtension workspaceExtension = addWorkspaceExtension(\n\t\t\tproject);\n\n\t\tapplyConfigScripts(project);\n\n\t\tConfiguration bundleConfiguration = addConfigurationBundle(\n\t\t\tproject, workspaceExtension);\n\n\t\tZip distBundle = addTaskDistBundle(project, bundleConfiguration);\n\n\t\tCopy initBundle = addTaskInitBundle(\n\t\t\tproject, workspaceExtension, bundleConfiguration);\n\n\t\tconfigureModules(project, workspaceExtension);\n\n\t\tconfigureThemes(project, workspaceExtension, distBundle);\n\n\t\tconfigurePluginsSDK(\n\t\t\tproject, workspaceExtension, initBundle, distBundle);\n\t}","id":77384,"modified_method":"@Override\n\tpublic void apply(Project project) {\n\t\tfinal WorkspaceExtension workspaceExtension = addWorkspaceExtension(\n\t\t\tproject);\n\n\t\tapplyConfigScripts(project);\n\n\t\tConfiguration bundleConfiguration = addConfigurationBundle(\n\t\t\tproject, workspaceExtension);\n\n\t\tAbstractArchiveTask distBundle =\n\t\t\taddTaskDistBundle(project, bundleConfiguration);\n\n\t\tCopy initBundle = addTaskInitBundle(\n\t\t\tproject, workspaceExtension, bundleConfiguration);\n\n\t\tconfigureModules(project, workspaceExtension);\n\n\t\tconfigureThemes(project, workspaceExtension, distBundle);\n\n\t\tconfigurePluginsSDK(\n\t\t\tproject, workspaceExtension, initBundle, distBundle);\n\t}","commit_id":"904652a291d98b62d7516c40081c1abcc9a9bc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configurePluginsSDK(\n\t\tProject project, final WorkspaceExtension workspaceExtension,\n\t\tCopy initBundle, Zip distBundle) {\n\n\t\tFile pluginsSDKDir = workspaceExtension.getPluginsSDKDir();\n\n\t\tif (!pluginsSDKDir.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Project pluginsSDKProject = GradleUtil.getProject(\n\t\t\tproject, workspaceExtension.getPluginsSDKDir());\n\n\t\tAntBuilder antBuilder = pluginsSDKProject.getAnt();\n\n\t\tantBuilder.importBuild(\"build.xml\");\n\n\t\tTask build = GradleUtil.addTask(pluginsSDKProject, \"build\", Task.class);\n\n\t\tfinal Task war = GradleUtil.getTask(pluginsSDKProject, \"war\");\n\n\t\tbuild.dependsOn(war);\n\n\t\tFile homeDir = workspaceExtension.getHomeDir();\n\n\t\tif (!homeDir.exists()) {\n\t\t\twar.dependsOn(initBundle);\n\t\t}\n\n\t\tdistBundle.into(\n\t\t\t\"deploy\",\n\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\tConfigurableFileTree fileTree = pluginsSDKProject.fileTree(\n\t\t\t\t\t\t\"dist\");\n\n\t\t\t\t\tfileTree.builtBy(war);\n\n\t\t\t\t\tfileTree.include(\"*.war\");\n\n\t\t\t\t\tcopySpec.from(fileTree);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tTask updateSDKProperties = GradleUtil.addTask(\n\t\t\tpluginsSDKProject, \"updateSDKProperties\", Task.class);\n\n\t\tupdateSDKProperties.doLast(new Action<Task>() {\n\t\t\t@Override\n\t\t\tpublic void execute(Task task) {\n\t\t\t\ttry {\n\t\t\t\t\tString username = System.getProperty(\"user.name\");\n\n\t\t\t\t\tFile buildPropertiesFile = new File(\n\t\t\t\t\t\tworkspaceExtension.getPluginsSDKDir(),\n\t\t\t\t\t\t\"build.\" + username + \".properties\");\n\n\t\t\t\t\tProperties buildProperties = FileUtil.readProperties(\n\t\t\t\t\t\tbuildPropertiesFile);\n\n\t\t\t\t\tbuildProperties.setProperty(\n\t\t\t\t\t\t\"app.server.parent.dir\",\n\t\t\t\t\t\tFileUtil.getAbsolutePath(\n\t\t\t\t\t\t\tworkspaceExtension.getHomeDir()));\n\n\t\t\t\t\tbuildProperties.store(\n\t\t\t\t\t\tnew FileOutputStream(buildPropertiesFile), \"\");\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\tbuild.dependsOn(updateSDKProperties);\n\t}","id":77385,"modified_method":"protected void configurePluginsSDK(\n\t\tProject project, final WorkspaceExtension workspaceExtension,\n\t\tCopy initBundle, AbstractArchiveTask distBundle) {\n\n\t\tFile pluginsSDKDir = workspaceExtension.getPluginsSDKDir();\n\n\t\tif (!pluginsSDKDir.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Project pluginsSDKProject = GradleUtil.getProject(\n\t\t\tproject, workspaceExtension.getPluginsSDKDir());\n\n\t\tAntBuilder antBuilder = pluginsSDKProject.getAnt();\n\n\t\tantBuilder.importBuild(\"build.xml\");\n\n\t\tTask build = GradleUtil.addTask(pluginsSDKProject, \"build\", Task.class);\n\n\t\tfinal Task war = GradleUtil.getTask(pluginsSDKProject, \"war\");\n\n\t\tbuild.dependsOn(war);\n\n\t\tFile homeDir = workspaceExtension.getHomeDir();\n\n\t\tif (!homeDir.exists()) {\n\t\t\twar.dependsOn(initBundle);\n\t\t}\n\n\t\tdistBundle.into(\n\t\t\t\"deploy\",\n\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\tConfigurableFileTree fileTree = pluginsSDKProject.fileTree(\n\t\t\t\t\t\t\"dist\");\n\n\t\t\t\t\tfileTree.builtBy(war);\n\n\t\t\t\t\tfileTree.include(\"*.war\");\n\n\t\t\t\t\tcopySpec.from(fileTree);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tTask updateSDKProperties = GradleUtil.addTask(\n\t\t\tpluginsSDKProject, \"updateSDKProperties\", Task.class);\n\n\t\tupdateSDKProperties.doLast(new Action<Task>() {\n\t\t\t@Override\n\t\t\tpublic void execute(Task task) {\n\t\t\t\ttry {\n\t\t\t\t\tString username = System.getProperty(\"user.name\");\n\n\t\t\t\t\tFile buildPropertiesFile = new File(\n\t\t\t\t\t\tworkspaceExtension.getPluginsSDKDir(),\n\t\t\t\t\t\t\"build.\" + username + \".properties\");\n\n\t\t\t\t\tProperties buildProperties = FileUtil.readProperties(\n\t\t\t\t\t\tbuildPropertiesFile);\n\n\t\t\t\t\tbuildProperties.setProperty(\n\t\t\t\t\t\t\"app.server.parent.dir\",\n\t\t\t\t\t\tFileUtil.getAbsolutePath(\n\t\t\t\t\t\t\tworkspaceExtension.getHomeDir()));\n\n\t\t\t\t\tbuildProperties.store(\n\t\t\t\t\t\tnew FileOutputStream(buildPropertiesFile), \"\");\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\tbuild.dependsOn(updateSDKProperties);\n\t}","commit_id":"904652a291d98b62d7516c40081c1abcc9a9bc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Zip addTaskDistBundle(\n\t\tfinal Project project, final Configuration bundleConfiguration) {\n\n\t\tZip zip = GradleUtil.addTask(project, DIST_BUNDLE_TASK_NAME, Zip.class);\n\n\t\tfinal File bundle = bundleConfiguration.getSingleFile();\n\n\t\tzip.from(\n\t\t\tnew Callable<FileTree>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileTree call() throws Exception {\n\t\t\t\t\tString bundleName = bundle.getName();\n\n\t\t\t\t\tif (bundleName.endsWith(\".tar.gz\")) {\n\t\t\t\t\t\treturn project.tarTree(\n\t\t\t\t\t\t\tbundleConfiguration.getSingleFile());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn project.zipTree(\n\t\t\t\t\t\t\tbundleConfiguration.getSingleFile());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t},\n\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\tcopySpec.eachFile(new StripPathSegmentsAction(1));\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tzip.setArchiveName(\"bundle.zip\");\n\t\tzip.setDescription(\"Assembles the bundle and zips it up.\");\n\t\tzip.setDestinationDir(project.getBuildDir());\n\t\tzip.setIncludeEmptyDirs(false);\n\n\t\treturn zip;\n\t}","id":77386,"modified_method":"protected AbstractArchiveTask addTaskDistBundle(\n\t\tfinal Project project, final Configuration bundleConfiguration) {\n\n\t\tfinal File bundle = bundleConfiguration.getSingleFile();\n\n\t\tfinal String bundleName = bundle.getName();\n\n\t\tAbstractArchiveTask archiveTask;\n\n\t\tif (bundleName.endsWith(\".tar.gz\")) {\n\t\t\tarchiveTask = GradleUtil.addTask(\n\t\t\t\tproject, DIST_BUNDLE_TASK_NAME, Tar.class);\n\t\t}\n\t\telse {\n\t\t\tarchiveTask = GradleUtil.addTask(\n\t\t\t\tproject, DIST_BUNDLE_TASK_NAME, Zip.class);\n\t\t}\n\n\t\tarchiveTask.from(\n\t\t\tnew Callable<FileTree>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileTree call() throws Exception {\n\n\t\t\t\t\tif (bundleName.endsWith(\".tar.gz\")) {\n\t\t\t\t\t\treturn project.tarTree(\n\t\t\t\t\t\t\tbundleConfiguration.getSingleFile());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn project.zipTree(\n\t\t\t\t\t\t\tbundleConfiguration.getSingleFile());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t},\n\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\tcopySpec.eachFile(new StripPathSegmentsAction(1));\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tarchiveTask.setArchiveName(project.getName() + \"-\" + bundleName);\n\t\tarchiveTask.setDescription(\"Assembles the bundle and zips it up.\");\n\t\tarchiveTask.setDestinationDir(project.getBuildDir());\n\t\tarchiveTask.setIncludeEmptyDirs(false);\n\n\t\treturn archiveTask;\n\t}","commit_id":"904652a291d98b62d7516c40081c1abcc9a9bc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureThemes(\n\t\tProject project, final WorkspaceExtension workspaceExtension,\n\t\tfinal Zip distBundle) {\n\n\t\tfinal Project themesProject = GradleUtil.getProject(\n\t\t\tproject, workspaceExtension.getThemesDir());\n\n\t\tthemesProject.subprojects(new Action<Project>() {\n\t\t\t@Override\n\t\t\tpublic void execute(final Project subproject) {\n\t\t\t\tSet<Project> subprojects = subproject.getSubprojects();\n\n\t\t\t\tif ((subprojects != null) && (subprojects.size() > 0)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tGradleUtil.applyPlugin(subproject, BasePlugin.class);\n\t\t\t\tGradleUtil.applyPlugin(subproject, GulpPlugin.class);\n\n\t\t\t\tTask createLiferayThemeJson = GradleUtil.addTask(\n\t\t\t\t\tsubproject, \"createLiferayThemeJson\", Task.class);\n\n\t\t\t\tTask deploy = GradleUtil.addTask(\n\t\t\t\t\tsubproject, \"deploy\", Task.class);\n\n\t\t\t\tfinal Task gulpDeploy = GradleUtil.getTask(\n\t\t\t\t\tsubproject, \"gulpDeploy\");\n\n\t\t\t\tdeploy.dependsOn(gulpDeploy);\n\n\t\t\t\tsubproject.setBuildDir(\n\t\t\t\t\tnew File(subproject.getProjectDir(), \"build_gradle\"));\n\n\t\t\t\tTask assemble = GradleUtil.getTask(subproject, \"assemble\");\n\n\t\t\t\tassemble.dependsOn(\"gulpBuild\");\n\n\t\t\t\tTask clean = GradleUtil.getTask(subproject, \"clean\");\n\n\t\t\t\tclean.dependsOn(\"cleanNpmInstall\");\n\n\t\t\t\tclean.configure(\n\t\t\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t\t\tpublic void doCall() {\n\t\t\t\t\t\t\tsubproject.delete(\"build\", \"dist\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tfinal File liferayThemeJsonFile = new File(\n\t\t\t\t\tsubproject.getProjectDir(), \"liferay-theme.json\");\n\n\t\t\t\tif (!liferayThemeJsonFile.exists()) {\n\t\t\t\t\tcreateLiferayThemeJson.doLast(new Action<Task>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void execute(Task task) {\n\t\t\t\t\t\t\tFile appServerDir = new File(\n\t\t\t\t\t\t\t\tworkspaceExtension.getHomeDir(),\n\t\t\t\t\t\t\t\t\"tomcat-7.0.62\");\n\t\t\t\t\t\t\tFile appServerThemeDir = new File(\n\t\t\t\t\t\t\t\tappServerDir,\n\t\t\t\t\t\t\t\t\"webapps/\" + subproject.getName());\n\t\t\t\t\t\t\tFile deployDir = new File(\n\t\t\t\t\t\t\t\tworkspaceExtension.getHomeDir(), \"deploy\");\n\n\t\t\t\t\t\t\tJSONObject jsonObject = new JSONObject();\n\n\t\t\t\t\t\t\tMap<String, Object> jsonValues = new HashMap<>();\n\n\t\t\t\t\t\t\tjsonValues.put(\n\t\t\t\t\t\t\t\t\"appServerPath\",\n\t\t\t\t\t\t\t\tappServerDir.getAbsolutePath());\n\t\t\t\t\t\t\tjsonValues.put(\n\t\t\t\t\t\t\t\t\"appServerPathTheme\",\n\t\t\t\t\t\t\t\tappServerThemeDir.getAbsolutePath());\n\t\t\t\t\t\t\tjsonValues.put(\"deployed\", false);\n\t\t\t\t\t\t\tjsonValues.put(\n\t\t\t\t\t\t\t\t\"deployPath\", deployDir.getAbsolutePath());\n\t\t\t\t\t\t\tjsonValues.put(\"themeName\", subproject.getName());\n\n\t\t\t\t\t\t\tjsonObject.put(\"LiferayTheme\", jsonValues);\n\n\t\t\t\t\t\t\ttry (PrintStream out = new PrintStream(\n\t\t\t\t\t\t\t\tnew FileOutputStream(liferayThemeJsonFile))) {\n\n\t\t\t\t\t\t\t\tout.println(jsonObject.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tdistBundle.into(\n\t\t\t\t\t\"deploy\",\n\t\t\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\t\t\tConfigurableFileTree fileTree =\n\t\t\t\t\t\t\t\tthemesProject.fileTree(\"dist\");\n\n\t\t\t\t\t\t\tfileTree.builtBy(gulpDeploy);\n\n\t\t\t\t\t\t\tfileTree.include(\"*.war\");\n\n\t\t\t\t\t\t\tcopySpec.from(fileTree);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\tTaskContainer taskContainer = subproject.getTasks();\n\n\t\t\t\ttaskContainer.withType(\n\t\t\t\t\tExecuteGulpTask.class,\n\t\t\t\t\tnew Action<ExecuteGulpTask>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void execute(ExecuteGulpTask executeGulpTask) {\n\t\t\t\t\t\t\texecuteGulpTask.dependsOn(\"createLiferayThemeJson\");\n\t\t\t\t\t\t\texecuteGulpTask.dependsOn(\"npmInstall\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\t}","id":77387,"modified_method":"protected void configureThemes(\n\t\tProject project, final WorkspaceExtension workspaceExtension,\n\t\tfinal AbstractArchiveTask distBundle) {\n\n\t\tfinal Project themesProject = GradleUtil.getProject(\n\t\t\tproject, workspaceExtension.getThemesDir());\n\n\t\tthemesProject.subprojects(new Action<Project>() {\n\t\t\t@Override\n\t\t\tpublic void execute(final Project subproject) {\n\t\t\t\tSet<Project> subprojects = subproject.getSubprojects();\n\n\t\t\t\tif ((subprojects != null) && (subprojects.size() > 0)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tGradleUtil.applyPlugin(subproject, BasePlugin.class);\n\t\t\t\tGradleUtil.applyPlugin(subproject, GulpPlugin.class);\n\n\t\t\t\tTask createLiferayThemeJson = GradleUtil.addTask(\n\t\t\t\t\tsubproject, \"createLiferayThemeJson\", Task.class);\n\n\t\t\t\tTask deploy = GradleUtil.addTask(\n\t\t\t\t\tsubproject, \"deploy\", Task.class);\n\n\t\t\t\tfinal Task gulpDeploy = GradleUtil.getTask(\n\t\t\t\t\tsubproject, \"gulpDeploy\");\n\n\t\t\t\tdeploy.dependsOn(gulpDeploy);\n\n\t\t\t\tsubproject.setBuildDir(\n\t\t\t\t\tnew File(subproject.getProjectDir(), \"build_gradle\"));\n\n\t\t\t\tTask assemble = GradleUtil.getTask(subproject, \"assemble\");\n\n\t\t\t\tassemble.dependsOn(\"gulpBuild\");\n\n\t\t\t\tTask clean = GradleUtil.getTask(subproject, \"clean\");\n\n\t\t\t\tclean.dependsOn(\"cleanNpmInstall\");\n\n\t\t\t\tclean.configure(\n\t\t\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t\t\tpublic void doCall() {\n\t\t\t\t\t\t\tsubproject.delete(\"build\", \"dist\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tfinal File liferayThemeJsonFile = new File(\n\t\t\t\t\tsubproject.getProjectDir(), \"liferay-theme.json\");\n\n\t\t\t\tif (!liferayThemeJsonFile.exists()) {\n\t\t\t\t\tcreateLiferayThemeJson.doLast(new Action<Task>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void execute(Task task) {\n\t\t\t\t\t\t\tFile appServerDir = new File(\n\t\t\t\t\t\t\t\tworkspaceExtension.getHomeDir(),\n\t\t\t\t\t\t\t\t\"tomcat-7.0.62\");\n\t\t\t\t\t\t\tFile appServerThemeDir = new File(\n\t\t\t\t\t\t\t\tappServerDir,\n\t\t\t\t\t\t\t\t\"webapps/\" + subproject.getName());\n\t\t\t\t\t\t\tFile deployDir = new File(\n\t\t\t\t\t\t\t\tworkspaceExtension.getHomeDir(), \"deploy\");\n\n\t\t\t\t\t\t\tJSONObject jsonObject = new JSONObject();\n\n\t\t\t\t\t\t\tMap<String, Object> jsonValues = new HashMap<>();\n\n\t\t\t\t\t\t\tjsonValues.put(\n\t\t\t\t\t\t\t\t\"appServerPath\",\n\t\t\t\t\t\t\t\tappServerDir.getAbsolutePath());\n\t\t\t\t\t\t\tjsonValues.put(\n\t\t\t\t\t\t\t\t\"appServerPathTheme\",\n\t\t\t\t\t\t\t\tappServerThemeDir.getAbsolutePath());\n\t\t\t\t\t\t\tjsonValues.put(\"deployed\", false);\n\t\t\t\t\t\t\tjsonValues.put(\n\t\t\t\t\t\t\t\t\"deployPath\", deployDir.getAbsolutePath());\n\t\t\t\t\t\t\tjsonValues.put(\"themeName\", subproject.getName());\n\n\t\t\t\t\t\t\tjsonObject.put(\"LiferayTheme\", jsonValues);\n\n\t\t\t\t\t\t\ttry (PrintStream out = new PrintStream(\n\t\t\t\t\t\t\t\tnew FileOutputStream(liferayThemeJsonFile))) {\n\n\t\t\t\t\t\t\t\tout.println(jsonObject.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tdistBundle.into(\n\t\t\t\t\t\"deploy\",\n\t\t\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\t\t\tConfigurableFileTree fileTree =\n\t\t\t\t\t\t\t\tthemesProject.fileTree(\"dist\");\n\n\t\t\t\t\t\t\tfileTree.builtBy(gulpDeploy);\n\n\t\t\t\t\t\t\tfileTree.include(\"*.war\");\n\n\t\t\t\t\t\t\tcopySpec.from(fileTree);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\tTaskContainer taskContainer = subproject.getTasks();\n\n\t\t\t\ttaskContainer.withType(\n\t\t\t\t\tExecuteGulpTask.class,\n\t\t\t\t\tnew Action<ExecuteGulpTask>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void execute(ExecuteGulpTask executeGulpTask) {\n\t\t\t\t\t\t\texecuteGulpTask.dependsOn(\"createLiferayThemeJson\");\n\t\t\t\t\t\t\texecuteGulpTask.dependsOn(\"npmInstall\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\t}","commit_id":"904652a291d98b62d7516c40081c1abcc9a9bc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private <D extends CallableDescriptor> OverloadResolutionResults<D> chooseAndReportMaximallySpecific(BindingTrace trace, TracingStrategy tracing, Set<ResolvedCallImpl<D>> candidates) {\n        if (candidates.size() != 1) {\n            Set<ResolvedCallImpl<D>> cleanCandidates = Sets.newLinkedHashSet(candidates);\n            boolean allClean = true;\n            for (Iterator<ResolvedCallImpl<D>> iterator = cleanCandidates.iterator(); iterator.hasNext(); ) {\n                ResolvedCallImpl<D> candidate = iterator.next();\n                if (candidate.isDirty()) {\n                    iterator.remove();\n                    allClean = false;\n                }\n            }\n\n            if (cleanCandidates.isEmpty()) {\n                cleanCandidates = candidates;\n            }\n            ResolvedCallImpl<D> maximallySpecific = overloadingConflictResolver.findMaximallySpecific(cleanCandidates, false);\n            if (maximallySpecific != null) {\n                return OverloadResolutionResults.success(maximallySpecific);\n            }\n\n            ResolvedCallImpl<D> maximallySpecificGenericsDiscriminated = overloadingConflictResolver.findMaximallySpecific(cleanCandidates, true);\n            if (maximallySpecificGenericsDiscriminated != null) {\n                return OverloadResolutionResults.success(maximallySpecificGenericsDiscriminated);\n            }\n\n            Set<ResolvedCallImpl<D>> noOverrides = OverridingUtil.filterOverrides(candidates, MAP_TO_RESULT);\n            if (allClean) {\n//                    tracing.reportOverallResolutionError(trace, \"Overload resolution ambiguity: \"\n//                                                                + makeErrorMessageForMultipleDescriptors(noOverrides));\n                tracing.ambiguity(trace, noOverrides);\n            }\n\n            tracing.recordAmbiguity(trace, noOverrides);\n\n            return OverloadResolutionResults.ambiguity(noOverrides);\n        }\n        else {\n            ResolvedCallImpl<D> result = candidates.iterator().next();\n\n            TemporaryBindingTrace temporaryTrace = result.getTrace();\n            temporaryTrace.commit();\n            return OverloadResolutionResults.success(result);\n        }\n    }","id":77388,"modified_method":"private <D extends CallableDescriptor> OverloadResolutionResults<D> chooseAndReportMaximallySpecific(Set<ResolvedCallImpl<D>> candidates) {\n        if (candidates.size() != 1) {\n            Set<ResolvedCallImpl<D>> cleanCandidates = Sets.newLinkedHashSet(candidates);\n            for (Iterator<ResolvedCallImpl<D>> iterator = cleanCandidates.iterator(); iterator.hasNext(); ) {\n                ResolvedCallImpl<D> candidate = iterator.next();\n                if (candidate.isDirty()) {\n                    iterator.remove();\n                }\n            }\n\n            if (cleanCandidates.isEmpty()) {\n                cleanCandidates = candidates;\n            }\n            ResolvedCallImpl<D> maximallySpecific = overloadingConflictResolver.findMaximallySpecific(cleanCandidates, false);\n            if (maximallySpecific != null) {\n                return OverloadResolutionResults.success(maximallySpecific);\n            }\n\n            ResolvedCallImpl<D> maximallySpecificGenericsDiscriminated = overloadingConflictResolver.findMaximallySpecific(cleanCandidates, true);\n            if (maximallySpecificGenericsDiscriminated != null) {\n                return OverloadResolutionResults.success(maximallySpecificGenericsDiscriminated);\n            }\n\n            Set<ResolvedCallImpl<D>> noOverrides = OverridingUtil.filterOverrides(candidates, MAP_TO_RESULT);\n\n            return OverloadResolutionResults.ambiguity(noOverrides);\n        }\n        else {\n            ResolvedCallImpl<D> result = candidates.iterator().next();\n\n            TemporaryBindingTrace temporaryTrace = result.getTrace();\n            temporaryTrace.commit();\n            return OverloadResolutionResults.success(result);\n        }\n    }","commit_id":"a67b76d105392b0e59a72ac631519bc03c696349","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private <D extends CallableDescriptor> OverloadResolutionResults<D> computeResultAndReportErrors(\n            BindingTrace trace,\n            TracingStrategy tracing,\n            Set<ResolvedCallImpl<D>> successfulCandidates,\n            Set<ResolvedCallImpl<D>> failedCandidates) {\n        // TODO : maybe it's better to filter overrides out first, and only then look for the maximally specific\n        if (successfulCandidates.size() > 0) {\n            return chooseAndReportMaximallySpecific(trace, tracing, successfulCandidates);\n        }\n        else if (!failedCandidates.isEmpty()) {\n            if (failedCandidates.size() != 1) {\n                Set<ResolvedCallImpl<D>> weakErrors = Sets.newLinkedHashSet();\n                for (ResolvedCallImpl<D> candidate : failedCandidates) {\n                    if (candidate.getStatus().isWeakError()) {\n                        weakErrors.add(candidate);\n                    }\n                }\n                if (!weakErrors.isEmpty()) {\n                    OverloadResolutionResults<D> results = chooseAndReportMaximallySpecific(trace, tracing, weakErrors);\n                    if (results.isSuccess()) {\n                        return OverloadResolutionResults.singleFailedCandidate(results.getResult());\n                    }\n\n                    return OverloadResolutionResults.manyFailedCandidates(results.getResults());\n                }\n\n                Set<ResolvedCallImpl<D>> noOverrides = OverridingUtil.filterOverrides(failedCandidates, MAP_TO_CANDIDATE);\n                if (noOverrides.size() != 1) {\n//                    tracing.reportOverallResolutionError(trace, \"None of the following functions can be called with the arguments supplied: \"\n//                                                                + makeErrorMessageForMultipleDescriptors(noOverrides));\n                    tracing.noneApplicable(trace, noOverrides);\n                    tracing.recordAmbiguity(trace, noOverrides);\n                    return OverloadResolutionResults.manyFailedCandidates(noOverrides);\n                }\n                failedCandidates = noOverrides;\n            }\n            ResolvedCallImpl<D> failed = failedCandidates.iterator().next();\n            failed.getTrace().commit();\n            return OverloadResolutionResults.singleFailedCandidate(failed);\n        }\n        else {\n            tracing.unresolvedReference(trace);\n            return OverloadResolutionResults.nameNotFound();\n        }\n    }","id":77389,"modified_method":"@NotNull\n    private <D extends CallableDescriptor> OverloadResolutionResults<D> computeResultAndReportErrors(\n            BindingTrace trace,\n            TracingStrategy tracing,\n            Set<ResolvedCallImpl<D>> successfulCandidates,\n            Set<ResolvedCallImpl<D>> failedCandidates) {\n        // TODO : maybe it's better to filter overrides out first, and only then look for the maximally specific\n\n        if (successfulCandidates.size() > 0) {\n            OverloadResolutionResults<D> results = chooseAndReportMaximallySpecific(successfulCandidates);\n            if (results.isAmbiguity()) {\n                // This check is needed for the following case:\n                //    x.foo(unresolved) -- if there are multiple foo's, we'd report an ambiguity, and it does not make sense here\n                if (allClean(results.getResults())) {\n                    tracing.ambiguity(trace, results.getResults());\n                }\n                tracing.recordAmbiguity(trace, results.getResults());\n            }\n            return results;\n        }\n        else if (!failedCandidates.isEmpty()) {\n            if (failedCandidates.size() != 1) {\n                // This is needed when there are several overloads some of which are OK but for nullability of the receiver,\n                // and some are not OK at all. In this case we'd like to say \"unsafe call\" rather than \"none applicable\"\n                // Used to be: weak errors. Generalized for future extensions\n                for (EnumSet<ResolutionStatus> severityLevel : SEVERITY_LEVELS) {\n                    Set<ResolvedCallImpl<D>> thisLevel = Sets.newLinkedHashSet();\n                    for (ResolvedCallImpl<D> candidate : failedCandidates) {\n                        if (severityLevel.contains(candidate.getStatus())) {\n                            thisLevel.add(candidate);\n                        }\n                    }\n                    if (!thisLevel.isEmpty()) {\n                        OverloadResolutionResults<D> results = chooseAndReportMaximallySpecific(thisLevel);\n                        if (results.isSuccess()) {\n                            results.getResult().getTrace().commit();\n                            return OverloadResolutionResults.singleFailedCandidate(results.getResult());\n                        }\n\n                        tracing.noneApplicable(trace, results.getResults());\n                        tracing.recordAmbiguity(trace, results.getResults());\n                        return OverloadResolutionResults.manyFailedCandidates(results.getResults());\n                    }\n                }\n                assert false : \"Should not be reachable, cause every status must belong to some level\";\n\n                Set<ResolvedCallImpl<D>> noOverrides = OverridingUtil.filterOverrides(failedCandidates, MAP_TO_CANDIDATE);\n                if (noOverrides.size() != 1) {\n                    tracing.noneApplicable(trace, noOverrides);\n                    tracing.recordAmbiguity(trace, noOverrides);\n                    return OverloadResolutionResults.manyFailedCandidates(noOverrides);\n                }\n                failedCandidates = noOverrides;\n            }\n            ResolvedCallImpl<D> failed = failedCandidates.iterator().next();\n            failed.getTrace().commit();\n            return OverloadResolutionResults.singleFailedCandidate(failed);\n        }\n        else {\n            tracing.unresolvedReference(trace);\n            return OverloadResolutionResults.nameNotFound();\n        }\n    }","commit_id":"a67b76d105392b0e59a72ac631519bc03c696349","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private <D extends CallableDescriptor> ResolvedCallImpl<D> doResolveCall(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull final Call call,\n            @NotNull JetType expectedType,\n            @NotNull final List<ResolutionTask<D>> prioritizedTasks, // high to low priority\n            @NotNull final JetReferenceExpression reference) {\n        TemporaryBindingTrace traceForFirstNonemptyCandidateSet = null;\n        OverloadResolutionResults<D> resultsForFirstNonemptyCandidateSet = null;\n        TracingStrategy tracing = new TracingStrategy() {\n            @Override\n            public <D extends CallableDescriptor> void bindReference(@NotNull BindingTrace trace, @NotNull ResolvedCallImpl<D> resolvedCall) {\n                D descriptor = resolvedCall.getCandidateDescriptor();\n//                if (descriptor instanceof VariableAsFunctionDescriptor) {\n//                    VariableAsFunctionDescriptor variableAsFunctionDescriptor = (VariableAsFunctionDescriptor) descriptor;\n//                    trace.record(REFERENCE_TARGET, reference, variableAsFunctionDescriptor.getVariableDescriptor());\n//                }\n//                else {\n                    trace.record(REFERENCE_TARGET, reference, descriptor);\n//                }\n                trace.record(RESOLVED_CALL, reference, resolvedCall);\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void recordAmbiguity(BindingTrace trace, Collection<ResolvedCallImpl<D>> candidates) {\n                trace.record(AMBIGUOUS_REFERENCE_TARGET, reference, candidates);\n            }\n\n            @Override\n            public void unresolvedReference(@NotNull BindingTrace trace) {\n                trace.report(UNRESOLVED_REFERENCE.on(reference));\n            }\n\n            @Override\n            public void noValueForParameter(@NotNull BindingTrace trace, @NotNull ValueParameterDescriptor valueParameter) {\n                trace.report(NO_VALUE_FOR_PARAMETER.on(reference, valueParameter));\n            }\n\n            @Override\n            public void missingReceiver(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor expectedReceiver) {\n                trace.report(MISSING_RECEIVER.on(reference, expectedReceiver.getType()));\n            }\n\n            @Override\n            public void wrongReceiverType(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor receiverParameter, @NotNull ReceiverDescriptor receiverArgument) {\n                if (receiverArgument instanceof ExpressionReceiver) {\n                    ExpressionReceiver expressionReceiver = (ExpressionReceiver) receiverArgument;\n                    trace.report(TYPE_MISMATCH.on(expressionReceiver.getExpression(), receiverParameter.getType(), receiverArgument.getType()));\n                }\n                else {\n                    trace.report(TYPE_MISMATCH.on(reference, receiverParameter.getType(), receiverArgument.getType()));\n                }\n            }\n\n            @Override\n            public void noReceiverAllowed(@NotNull BindingTrace trace) {\n                trace.report(NO_RECEIVER_ADMITTED.on(reference));\n            }\n\n            @Override\n            public void wrongNumberOfTypeArguments(@NotNull BindingTrace trace, int expectedTypeArgumentCount) {\n                JetTypeArgumentList typeArgumentList = call.getTypeArgumentList();\n                if (typeArgumentList != null) {\n//                    trace.getErrorHandler().genericError(typeArgumentList.getNode(), message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(typeArgumentList, expectedTypeArgumentCount));\n                }\n                else {\n//                    reportOverallResolutionError(trace, message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reference, expectedTypeArgumentCount));\n                }\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void ambiguity(@NotNull BindingTrace trace, @NotNull Set<ResolvedCallImpl<D>> descriptors) {\n                trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(call.getCallNode(), descriptors));\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void noneApplicable(@NotNull BindingTrace trace, @NotNull Set<ResolvedCallImpl<D>> descriptors) {\n                trace.report(NONE_APPLICABLE.on(reference, descriptors));\n            }\n\n            @Override\n            public void instantiationOfAbstractClass(@NotNull BindingTrace trace) {\n                trace.report(CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS.on(call.getCallNode()));\n            }\n\n            @Override\n            public void typeInferenceFailed(@NotNull BindingTrace trace) {\n                trace.report(TYPE_INFERENCE_FAILED.on(call.getCallNode()));\n            }\n\n            @Override\n            public void unsafeCall(@NotNull BindingTrace trace, @NotNull JetType type) {\n                ASTNode callOperationNode = call.getCallOperationNode();\n                if (callOperationNode != null) {\n                    trace.report(UNSAFE_CALL.on(callOperationNode, type));\n                }\n                else {\n                    PsiElement callElement = call.getCallElement();\n                    if (callElement instanceof JetBinaryExpression) {\n                        JetBinaryExpression binaryExpression = (JetBinaryExpression) callElement;\n                        JetSimpleNameExpression operationReference = binaryExpression.getOperationReference();\n                        String operationString = operationReference.getReferencedNameElementType() == JetTokens.IDENTIFIER ? operationReference.getText() : OperatorConventions.getNameForOperationSymbol(operationReference.getReferencedNameElementType());\n                        JetExpression right = binaryExpression.getRight();\n                        if (right != null) {\n                            trace.report(UNSAFE_INFIX_CALL.on(reference, binaryExpression.getLeft().getText(), operationString, right.getText()));\n                        }\n                    }\n                    else {\n                        trace.report(UNSAFE_CALL.on(reference, type));\n                    }\n                }\n            }\n\n            @Override\n            public void unnecessarySafeCall(@NotNull BindingTrace trace, @NotNull JetType type) {\n                ASTNode callOperationNode = call.getCallOperationNode();\n                assert callOperationNode != null;\n                PsiElement callElement = call.getCallElement();\n                assert callElement != null;\n                trace.report(UNNECESSARY_SAFE_CALL.on((JetElement) callOperationNode.getTreeParent().getPsi(), callOperationNode, type));\n            }\n        };\n        for (ResolutionTask<D> task : prioritizedTasks) {\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            OverloadResolutionResults<D> results = performResolution(temporaryTrace, scope, expectedType, task, tracing);\n            if (results.isSuccess()) {\n                temporaryTrace.commit();\n                return results.getResult();\n            }\n            if (traceForFirstNonemptyCandidateSet == null && !task.getCandidates().isEmpty()) {\n                traceForFirstNonemptyCandidateSet = temporaryTrace;\n                resultsForFirstNonemptyCandidateSet = results;\n            }\n        }\n        if (traceForFirstNonemptyCandidateSet != null) {\n            traceForFirstNonemptyCandidateSet.commit();\n            if (resultsForFirstNonemptyCandidateSet.singleDescriptor()) {\n                return resultsForFirstNonemptyCandidateSet.getResult();\n            }\n        }\n        else {\n            trace.report(UNRESOLVED_REFERENCE.on(reference));\n            checkTypesWithNoCallee(trace, scope, call);\n        }\n        return null;\n    }","id":77390,"modified_method":"@Nullable\n    private <D extends CallableDescriptor> ResolvedCallImpl<D> doResolveCall(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull final Call call,\n            @NotNull JetType expectedType,\n            @NotNull final List<ResolutionTask<D>> prioritizedTasks, // high to low priority\n            @NotNull final JetReferenceExpression reference) {\n        TracingStrategy tracing = new TracingStrategy() {\n            @Override\n            public <D extends CallableDescriptor> void bindReference(@NotNull BindingTrace trace, @NotNull ResolvedCallImpl<D> resolvedCall) {\n                D descriptor = resolvedCall.getCandidateDescriptor();\n//                if (descriptor instanceof VariableAsFunctionDescriptor) {\n//                    VariableAsFunctionDescriptor variableAsFunctionDescriptor = (VariableAsFunctionDescriptor) descriptor;\n//                    trace.record(REFERENCE_TARGET, reference, variableAsFunctionDescriptor.getVariableDescriptor());\n//                }\n//                else {\n                    trace.record(REFERENCE_TARGET, reference, descriptor);\n//                }\n                trace.record(RESOLVED_CALL, reference, resolvedCall);\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void recordAmbiguity(BindingTrace trace, Collection<ResolvedCallImpl<D>> candidates) {\n                trace.record(AMBIGUOUS_REFERENCE_TARGET, reference, candidates);\n            }\n\n            @Override\n            public void unresolvedReference(@NotNull BindingTrace trace) {\n                trace.report(UNRESOLVED_REFERENCE.on(reference));\n            }\n\n            @Override\n            public void noValueForParameter(@NotNull BindingTrace trace, @NotNull ValueParameterDescriptor valueParameter) {\n                trace.report(NO_VALUE_FOR_PARAMETER.on(reference, valueParameter));\n            }\n\n            @Override\n            public void missingReceiver(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor expectedReceiver) {\n                trace.report(MISSING_RECEIVER.on(reference, expectedReceiver.getType()));\n            }\n\n            @Override\n            public void wrongReceiverType(@NotNull BindingTrace trace, @NotNull ReceiverDescriptor receiverParameter, @NotNull ReceiverDescriptor receiverArgument) {\n                if (receiverArgument instanceof ExpressionReceiver) {\n                    ExpressionReceiver expressionReceiver = (ExpressionReceiver) receiverArgument;\n                    trace.report(TYPE_MISMATCH.on(expressionReceiver.getExpression(), receiverParameter.getType(), receiverArgument.getType()));\n                }\n                else {\n                    trace.report(TYPE_MISMATCH.on(reference, receiverParameter.getType(), receiverArgument.getType()));\n                }\n            }\n\n            @Override\n            public void noReceiverAllowed(@NotNull BindingTrace trace) {\n                trace.report(NO_RECEIVER_ADMITTED.on(reference));\n            }\n\n            @Override\n            public void wrongNumberOfTypeArguments(@NotNull BindingTrace trace, int expectedTypeArgumentCount) {\n                JetTypeArgumentList typeArgumentList = call.getTypeArgumentList();\n                if (typeArgumentList != null) {\n//                    trace.getErrorHandler().genericError(typeArgumentList.getNode(), message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(typeArgumentList, expectedTypeArgumentCount));\n                }\n                else {\n//                    reportOverallResolutionError(trace, message);\n                    trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reference, expectedTypeArgumentCount));\n                }\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void ambiguity(@NotNull BindingTrace trace, @NotNull Collection<ResolvedCallImpl<D>> descriptors) {\n                trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(call.getCallNode(), descriptors));\n            }\n\n            @Override\n            public <D extends CallableDescriptor> void noneApplicable(@NotNull BindingTrace trace, @NotNull Collection<ResolvedCallImpl<D>> descriptors) {\n                trace.report(NONE_APPLICABLE.on(reference, descriptors));\n            }\n\n            @Override\n            public void instantiationOfAbstractClass(@NotNull BindingTrace trace) {\n                trace.report(CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS.on(call.getCallNode()));\n            }\n\n            @Override\n            public void typeInferenceFailed(@NotNull BindingTrace trace) {\n                trace.report(TYPE_INFERENCE_FAILED.on(call.getCallNode()));\n            }\n\n            @Override\n            public void unsafeCall(@NotNull BindingTrace trace, @NotNull JetType type) {\n                ASTNode callOperationNode = call.getCallOperationNode();\n                if (callOperationNode != null) {\n                    trace.report(UNSAFE_CALL.on(callOperationNode, type));\n                }\n                else {\n                    PsiElement callElement = call.getCallElement();\n                    if (callElement instanceof JetBinaryExpression) {\n                        JetBinaryExpression binaryExpression = (JetBinaryExpression) callElement;\n                        JetSimpleNameExpression operationReference = binaryExpression.getOperationReference();\n                        String operationString = operationReference.getReferencedNameElementType() == JetTokens.IDENTIFIER ? operationReference.getText() : OperatorConventions.getNameForOperationSymbol(operationReference.getReferencedNameElementType());\n                        JetExpression right = binaryExpression.getRight();\n                        if (right != null) {\n                            trace.report(UNSAFE_INFIX_CALL.on(reference, binaryExpression.getLeft().getText(), operationString, right.getText()));\n                        }\n                    }\n                    else {\n                        trace.report(UNSAFE_CALL.on(reference, type));\n                    }\n                }\n            }\n\n            @Override\n            public void unnecessarySafeCall(@NotNull BindingTrace trace, @NotNull JetType type) {\n                ASTNode callOperationNode = call.getCallOperationNode();\n                assert callOperationNode != null;\n                PsiElement callElement = call.getCallElement();\n                assert callElement != null;\n                trace.report(UNNECESSARY_SAFE_CALL.on((JetElement) callOperationNode.getTreeParent().getPsi(), callOperationNode, type));\n            }\n        };\n\n        TemporaryBindingTrace traceForFirstNonemptyCandidateSet = null;\n        OverloadResolutionResults<D> resultsForFirstNonemptyCandidateSet = null;\n        for (ResolutionTask<D> task : prioritizedTasks) {\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            OverloadResolutionResults<D> results = performResolution(temporaryTrace, scope, expectedType, task, tracing);\n            if (results.isSuccess()) {\n                temporaryTrace.commit();\n                return results.getResult();\n            }\n            if (traceForFirstNonemptyCandidateSet == null && !task.getCandidates().isEmpty()) {\n                traceForFirstNonemptyCandidateSet = temporaryTrace;\n                resultsForFirstNonemptyCandidateSet = results;\n            }\n        }\n        if (traceForFirstNonemptyCandidateSet != null) {\n            traceForFirstNonemptyCandidateSet.commit();\n            if (resultsForFirstNonemptyCandidateSet.singleDescriptor()) {\n                return resultsForFirstNonemptyCandidateSet.getResult();\n            }\n        }\n        else {\n            trace.report(UNRESOLVED_REFERENCE.on(reference));\n            checkTypesWithNoCallee(trace, scope, call);\n        }\n        return null;\n    }","commit_id":"a67b76d105392b0e59a72ac631519bc03c696349","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private <D extends CallableDescriptor> OverloadResolutionResults<D> performResolution(@NotNull BindingTrace trace, @NotNull JetScope scope, @NotNull JetType expectedType, @NotNull ResolutionTask<D> task, @NotNull TracingStrategy tracing) {\n        for (ResolvedCallImpl<D> candidateCall : task.getCandidates()) {\n            D candidate = candidateCall.getCandidateDescriptor();\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            candidateCall.setTrace(temporaryTrace);\n\n            tracing.bindReference(temporaryTrace, candidateCall);\n            \n            if (ErrorUtils.isError(candidate)) {\n                candidateCall.setStatus(SUCCESS);\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getCall());\n                continue;\n            }\n\n            boolean errorInArgumentMapping = ValueArgumentsToParametersMapper.mapValueArgumentsToParameters(task, tracing, candidateCall);\n            if (errorInArgumentMapping) {\n                candidateCall.setStatus(OTHER_ERROR);\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getCall());\n                continue;\n            }\n\n            List<JetTypeProjection> jetTypeArguments = task.getCall().getTypeArguments();\n            if (jetTypeArguments.isEmpty()) {\n                if (!candidate.getTypeParameters().isEmpty()) {\n                    // Type argument inference\n\n                    ConstraintSystem constraintSystem = new ConstraintSystem();\n                    for (TypeParameterDescriptor typeParameterDescriptor : candidate.getTypeParameters()) {\n                        constraintSystem.registerTypeVariable(typeParameterDescriptor, Variance.INVARIANT); // TODO\n                    }\n\n                    for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : candidateCall.getValueArguments().entrySet()) {\n                        ResolvedValueArgument valueArgument = entry.getValue();\n                        ValueParameterDescriptor valueParameterDescriptor = entry.getKey();\n\n                        for (JetExpression expression : valueArgument.getArgumentExpressions()) {\n//                            JetExpression expression = valueArgument.getArgumentExpression();\n                            // TODO : more attempts, with different expected types\n                            ExpressionTypingServices temporaryServices = new ExpressionTypingServices(semanticServices, temporaryTrace);\n                            JetType type = temporaryServices.getType(scope, expression, NO_EXPECTED_TYPE);\n                            if (type != null) {\n                                constraintSystem.addSubtypingConstraint(type, valueParameterDescriptor.getOutType());\n                            }\n                            else {\n                                candidateCall.argumentHasNoType();\n                            }\n                        }\n                    }\n\n//                    checkReceiverAbsence(candidateCall, tracing, candidate);\n\n                    // Error is already reported if something is missing\n                    ReceiverDescriptor receiverParameter = candidateCall.getReceiverArgument();\n                    ReceiverDescriptor candidateReceiver = candidate.getReceiverParameter();\n                    if (receiverParameter.exists() && candidateReceiver.exists()) {\n                        constraintSystem.addSubtypingConstraint(receiverParameter.getType(), candidateReceiver.getType());\n                    }\n\n                    if (expectedType != NO_EXPECTED_TYPE) {\n                        constraintSystem.addSubtypingConstraint(candidate.getReturnType(), expectedType);\n                    }\n\n                    ConstraintSystem.Solution solution = constraintSystem.solve();\n//                    solutions.put(candidate, solution);\n                    if (solution.isSuccessful()) {\n                        D substitute = (D) candidate.substitute(solution.getSubstitutor());\n                        assert substitute != null;\n                        replaceValueParametersWithSubstitutedOnes(candidateCall, substitute);\n                        candidateCall.setResultingDescriptor(substitute);\n                        for (TypeParameterDescriptor typeParameterDescriptor : candidateCall.getCandidateDescriptor().getTypeParameters()) {\n                            candidateCall.recordTypeArgument(typeParameterDescriptor, solution.getValue(typeParameterDescriptor));\n                        }\n                        candidateCall.setStatus(SUCCESS);\n                    }\n                    else {\n                        tracing.typeInferenceFailed(temporaryTrace);\n                        candidateCall.setStatus(OTHER_ERROR);\n                    }\n                }\n                else {\n                    candidateCall.setStatus(checkAllValueArguments(scope, tracing, task, candidateCall));\n                }\n            }\n            else {\n                // Explicit type arguments passed\n\n                for (JetTypeProjection typeArgument : jetTypeArguments) {\n                    if (typeArgument.getProjectionKind() != JetProjectionKind.NONE) {\n//                        temporaryTrace.getErrorHandler().genericError(typeArgument.getNode(), \"Projections are not allowed on type parameters for methods\"); // TODO : better positioning\n                        temporaryTrace.report(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT.on(typeArgument));\n                    }\n                }\n\n                int expectedTypeArgumentCount = candidate.getTypeParameters().size();\n                if (expectedTypeArgumentCount == jetTypeArguments.size()) {\n                    List<JetType> typeArguments = new ArrayList<JetType>();\n                    for (JetTypeProjection projection : jetTypeArguments) {\n                        // TODO : check that there's no projection\n                        JetTypeReference typeReference = projection.getTypeReference();\n                        if (typeReference != null) {\n                            typeArguments.add(new TypeResolver(semanticServices, temporaryTrace, true).resolveType(scope, typeReference));\n                        }\n                    }\n\n                    checkGenericBoundsInAFunctionCall(jetTypeArguments, typeArguments, candidate, temporaryTrace);\n                    \n                    Map<TypeConstructor, TypeProjection> substitutionContext = FunctionDescriptorUtil.createSubstitutionContext((FunctionDescriptor) candidate, typeArguments);\n                    D substitutedDescriptor = (D) candidate.substitute(TypeSubstitutor.create(substitutionContext));\n\n                    candidateCall.setResultingDescriptor(substitutedDescriptor);\n                    replaceValueParametersWithSubstitutedOnes(candidateCall, substitutedDescriptor);\n\n                    List<TypeParameterDescriptor> typeParameters = candidateCall.getCandidateDescriptor().getTypeParameters();\n                    for (int i = 0; i < typeParameters.size(); i++) {\n                        TypeParameterDescriptor typeParameterDescriptor = typeParameters.get(i);\n                        candidateCall.recordTypeArgument(typeParameterDescriptor, typeArguments.get(i));\n                    }\n                    candidateCall.setStatus(checkAllValueArguments(scope, tracing, task, candidateCall));\n                }\n                else {\n                    candidateCall.setStatus(OTHER_ERROR);\n//                    tracing.reportWrongTypeArguments(temporaryTrace, \"Number of type arguments does not match \" + DescriptorRenderer.TEXT.render(candidate));\n                    tracing.wrongNumberOfTypeArguments(temporaryTrace, expectedTypeArgumentCount);\n                }\n            }\n            \n            task.performAdvancedChecks(candidate, temporaryTrace, tracing);\n\n            recordAutoCastIfNecessary(candidateCall.getReceiverArgument(), candidateCall.getTrace());\n            recordAutoCastIfNecessary(candidateCall.getThisObject(), candidateCall.getTrace());\n        }\n\n        Set<ResolvedCallImpl<D>> successfulCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCallImpl<D>> failedCandidates = Sets.newLinkedHashSet();\n        for (ResolvedCallImpl<D> candidateCall : task.getCandidates()) {\n            ResolutionStatus status = candidateCall.getStatus();\n            if (status.isSuccess()) {\n                successfulCandidates.add(candidateCall);\n            }\n            else {\n                assert status != UNKNOWN_STATUS : \"No resolution for \" + candidateCall.getCandidateDescriptor();\n                failedCandidates.add(candidateCall);\n            }\n        }\n        \n        OverloadResolutionResults<D> results = computeResultAndReportErrors(trace, tracing, successfulCandidates, failedCandidates);\n        if (!results.singleDescriptor()) {\n            checkTypesWithNoCallee(trace, scope, task.getCall());\n        }\n        return results;\n    }","id":77391,"modified_method":"@NotNull\n    private <D extends CallableDescriptor> OverloadResolutionResults<D> performResolution(@NotNull BindingTrace trace, @NotNull JetScope scope, @NotNull JetType expectedType, @NotNull ResolutionTask<D> task, @NotNull TracingStrategy tracing) {\n        for (ResolvedCallImpl<D> candidateCall : task.getCandidates()) {\n            D candidate = candidateCall.getCandidateDescriptor();\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(trace);\n            candidateCall.setTrace(temporaryTrace);\n\n            tracing.bindReference(temporaryTrace, candidateCall);\n            \n            if (ErrorUtils.isError(candidate)) {\n                candidateCall.setStatus(SUCCESS);\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getCall());\n                continue;\n            }\n\n            boolean errorInArgumentMapping = ValueArgumentsToParametersMapper.mapValueArgumentsToParameters(task, tracing, candidateCall);\n            if (errorInArgumentMapping) {\n                candidateCall.setStatus(OTHER_ERROR);\n                checkTypesWithNoCallee(temporaryTrace, scope, task.getCall());\n                continue;\n            }\n\n            List<JetTypeProjection> jetTypeArguments = task.getCall().getTypeArguments();\n            if (jetTypeArguments.isEmpty()) {\n                if (!candidate.getTypeParameters().isEmpty()) {\n                    // Type argument inference\n\n                    ConstraintSystem constraintSystem = new ConstraintSystem();\n                    for (TypeParameterDescriptor typeParameterDescriptor : candidate.getTypeParameters()) {\n                        constraintSystem.registerTypeVariable(typeParameterDescriptor, Variance.INVARIANT); // TODO\n                    }\n\n                    for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : candidateCall.getValueArguments().entrySet()) {\n                        ResolvedValueArgument valueArgument = entry.getValue();\n                        ValueParameterDescriptor valueParameterDescriptor = entry.getKey();\n\n                        for (JetExpression expression : valueArgument.getArgumentExpressions()) {\n//                            JetExpression expression = valueArgument.getArgumentExpression();\n                            // TODO : more attempts, with different expected types\n                            ExpressionTypingServices temporaryServices = new ExpressionTypingServices(semanticServices, temporaryTrace);\n                            JetType type = temporaryServices.getType(scope, expression, NO_EXPECTED_TYPE);\n                            if (type != null) {\n                                constraintSystem.addSubtypingConstraint(type, valueParameterDescriptor.getOutType());\n                            }\n                            else {\n                                candidateCall.argumentHasNoType();\n                            }\n                        }\n                    }\n\n//                    checkReceiverAbsence(candidateCall, tracing, candidate);\n\n                    // Error is already reported if something is missing\n                    ReceiverDescriptor receiverParameter = candidateCall.getReceiverArgument();\n                    ReceiverDescriptor candidateReceiver = candidate.getReceiverParameter();\n                    if (receiverParameter.exists() && candidateReceiver.exists()) {\n                        constraintSystem.addSubtypingConstraint(receiverParameter.getType(), candidateReceiver.getType());\n                    }\n\n                    if (expectedType != NO_EXPECTED_TYPE) {\n                        constraintSystem.addSubtypingConstraint(candidate.getReturnType(), expectedType);\n                    }\n\n                    ConstraintSystem.Solution solution = constraintSystem.solve();\n//                    solutions.put(candidate, solution);\n                    if (solution.isSuccessful()) {\n                        D substitute = (D) candidate.substitute(solution.getSubstitutor());\n                        assert substitute != null;\n                        replaceValueParametersWithSubstitutedOnes(candidateCall, substitute);\n                        candidateCall.setResultingDescriptor(substitute);\n                        for (TypeParameterDescriptor typeParameterDescriptor : candidateCall.getCandidateDescriptor().getTypeParameters()) {\n                            candidateCall.recordTypeArgument(typeParameterDescriptor, solution.getValue(typeParameterDescriptor));\n                        }\n                        candidateCall.setStatus(SUCCESS);\n                    }\n                    else {\n                        tracing.typeInferenceFailed(temporaryTrace);\n                        candidateCall.setStatus(OTHER_ERROR);\n                    }\n                }\n                else {\n                    candidateCall.setStatus(checkAllValueArguments(scope, tracing, task, candidateCall));\n                }\n            }\n            else {\n                // Explicit type arguments passed\n\n                for (JetTypeProjection typeArgument : jetTypeArguments) {\n                    if (typeArgument.getProjectionKind() != JetProjectionKind.NONE) {\n//                        temporaryTrace.getErrorHandler().genericError(typeArgument.getNode(), \"Projections are not allowed on type parameters for methods\"); // TODO : better positioning\n                        temporaryTrace.report(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT.on(typeArgument));\n                    }\n                }\n\n                int expectedTypeArgumentCount = candidate.getTypeParameters().size();\n                if (expectedTypeArgumentCount == jetTypeArguments.size()) {\n                    List<JetType> typeArguments = new ArrayList<JetType>();\n                    for (JetTypeProjection projection : jetTypeArguments) {\n                        // TODO : check that there's no projection\n                        JetTypeReference typeReference = projection.getTypeReference();\n                        if (typeReference != null) {\n                            typeArguments.add(new TypeResolver(semanticServices, temporaryTrace, true).resolveType(scope, typeReference));\n                        }\n                    }\n\n                    checkGenericBoundsInAFunctionCall(jetTypeArguments, typeArguments, candidate, temporaryTrace);\n                    \n                    Map<TypeConstructor, TypeProjection> substitutionContext = FunctionDescriptorUtil.createSubstitutionContext((FunctionDescriptor) candidate, typeArguments);\n                    D substitutedDescriptor = (D) candidate.substitute(TypeSubstitutor.create(substitutionContext));\n\n                    candidateCall.setResultingDescriptor(substitutedDescriptor);\n                    replaceValueParametersWithSubstitutedOnes(candidateCall, substitutedDescriptor);\n\n                    List<TypeParameterDescriptor> typeParameters = candidateCall.getCandidateDescriptor().getTypeParameters();\n                    for (int i = 0; i < typeParameters.size(); i++) {\n                        TypeParameterDescriptor typeParameterDescriptor = typeParameters.get(i);\n                        candidateCall.recordTypeArgument(typeParameterDescriptor, typeArguments.get(i));\n                    }\n                    candidateCall.setStatus(checkAllValueArguments(scope, tracing, task, candidateCall));\n                }\n                else {\n                    candidateCall.setStatus(OTHER_ERROR);\n//                    tracing.reportWrongTypeArguments(temporaryTrace, \"Number of type arguments does not match \" + DescriptorRenderer.TEXT.render(candidate));\n                    tracing.wrongNumberOfTypeArguments(temporaryTrace, expectedTypeArgumentCount);\n                }\n            }\n            \n            task.performAdvancedChecks(candidate, temporaryTrace, tracing);\n\n            // 'super' cannot be passed as an argument, for receiver arguments expression typer does not track this\n            // See TaskPrioritizer for more\n            JetSuperExpression superExpression = TaskPrioritizer.getReceiverSuper(candidateCall.getReceiverArgument());\n            if (superExpression != null) {\n                temporaryTrace.report(SUPER_IS_NOT_AN_EXPRESSION.on(superExpression, superExpression.getText()));\n                candidateCall.setStatus(OTHER_ERROR);\n            }\n\n            recordAutoCastIfNecessary(candidateCall.getReceiverArgument(), candidateCall.getTrace());\n            recordAutoCastIfNecessary(candidateCall.getThisObject(), candidateCall.getTrace());\n        }\n\n        Set<ResolvedCallImpl<D>> successfulCandidates = Sets.newLinkedHashSet();\n        Set<ResolvedCallImpl<D>> failedCandidates = Sets.newLinkedHashSet();\n        for (ResolvedCallImpl<D> candidateCall : task.getCandidates()) {\n            ResolutionStatus status = candidateCall.getStatus();\n            if (status.isSuccess()) {\n                successfulCandidates.add(candidateCall);\n            }\n            else {\n                assert status != UNKNOWN_STATUS : \"No resolution for \" + candidateCall.getCandidateDescriptor();\n                failedCandidates.add(candidateCall);\n            }\n        }\n        \n        OverloadResolutionResults<D> results = computeResultAndReportErrors(trace, tracing, successfulCandidates, failedCandidates);\n        if (!results.singleDescriptor()) {\n            checkTypesWithNoCallee(trace, scope, task.getCall());\n        }\n        return results;\n    }","commit_id":"a67b76d105392b0e59a72ac631519bc03c696349","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doComputeTasks(JetScope scope, ReceiverDescriptor receiver, Call call, String name, List<ResolutionTask<D>> result, @NotNull AutoCastService autoCastService) {\n        DataFlowInfo dataFlowInfo = autoCastService.getDataFlowInfo();\n        List<ReceiverDescriptor> implicitReceivers = Lists.newArrayList();\n        scope.getImplicitReceiversHierarchy(implicitReceivers);\n        if (receiver.exists()) {\n            List<ReceiverDescriptor> variantsForExplicitReceiver = autoCastService.getVariantsForReceiver(receiver);\n\n            Collection<ResolvedCallImpl<D>> extensionFunctions = convertWithImpliedThis(scope, variantsForExplicitReceiver, getExtensionsByName(scope, name));\n            List<ResolvedCallImpl<D>> nonlocals = Lists.newArrayList();\n            List<ResolvedCallImpl<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(extensionFunctions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            Collection<ResolvedCallImpl<D>> members = Lists.newArrayList();\n            for (ReceiverDescriptor variant : variantsForExplicitReceiver) {\n                Collection<D> membersForThisVariant = getMembersByName(variant.getType(), name);\n                convertWithReceivers(membersForThisVariant, Collections.singletonList(variant), Collections.singletonList(NO_RECEIVER), members);\n            }\n\n            addTask(result, call, locals, dataFlowInfo);\n            addTask(result, call, members, dataFlowInfo);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                Collection<D> memberExtensions = getExtensionsByName(implicitReceiver.getType().getMemberScope(), name);\n                List<ReceiverDescriptor> variantsForImplicitReceiver = autoCastService.getVariantsForReceiver(implicitReceiver);\n                addTask(result, call, convertWithReceivers(memberExtensions, variantsForImplicitReceiver, variantsForExplicitReceiver), dataFlowInfo);\n            }\n\n            addTask(result, call, nonlocals, dataFlowInfo);\n        }\n        else {\n            Collection<ResolvedCallImpl<D>> functions = convertWithImpliedThis(scope, Collections.singletonList(receiver), getNonExtensionsByName(scope, name));\n\n            List<ResolvedCallImpl<D>> nonlocals = Lists.newArrayList();\n            List<ResolvedCallImpl<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(functions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            addTask(result, call, locals, dataFlowInfo);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                doComputeTasks(scope, implicitReceiver, call, name, result, autoCastService);\n            }\n\n            addTask(result, call, nonlocals, dataFlowInfo);\n        }\n    }","id":77392,"modified_method":"private void doComputeTasks(JetScope scope, ReceiverDescriptor receiver, Call call, String name, List<ResolutionTask<D>> result, @NotNull AutoCastService autoCastService) {\n        DataFlowInfo dataFlowInfo = autoCastService.getDataFlowInfo();\n        List<ReceiverDescriptor> implicitReceivers = Lists.newArrayList();\n        scope.getImplicitReceiversHierarchy(implicitReceivers);\n        if (receiver.exists()) {\n            List<ReceiverDescriptor> variantsForExplicitReceiver = autoCastService.getVariantsForReceiver(receiver);\n\n            Collection<ResolvedCallImpl<D>> extensionFunctions = convertWithImpliedThis(scope, variantsForExplicitReceiver, getExtensionsByName(scope, name));\n            List<ResolvedCallImpl<D>> nonlocals = Lists.newArrayList();\n            List<ResolvedCallImpl<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(extensionFunctions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            Collection<ResolvedCallImpl<D>> members = Lists.newArrayList();\n            for (ReceiverDescriptor variant : variantsForExplicitReceiver) {\n                Collection<D> membersForThisVariant = getMembersByName(variant.getType(), name);\n                convertWithReceivers(membersForThisVariant, Collections.singletonList(variant), Collections.singletonList(NO_RECEIVER), members);\n            }\n\n            if (getReceiverSuper(receiver) != null) {\n                // If the call is of the form super.foo(), it can actually be only a member\n                // But  if there's no appropriate member, we would like to report that super cannot be a receiver for an extension\n                // Thus, put members first\n                addTask(result, call, members, dataFlowInfo);\n                addTask(result, call, locals, dataFlowInfo);\n            }\n            else {\n                addTask(result, call, locals, dataFlowInfo);\n                addTask(result, call, members, dataFlowInfo);\n            }\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                Collection<D> memberExtensions = getExtensionsByName(implicitReceiver.getType().getMemberScope(), name);\n                List<ReceiverDescriptor> variantsForImplicitReceiver = autoCastService.getVariantsForReceiver(implicitReceiver);\n                addTask(result, call, convertWithReceivers(memberExtensions, variantsForImplicitReceiver, variantsForExplicitReceiver), dataFlowInfo);\n            }\n\n            addTask(result, call, nonlocals, dataFlowInfo);\n        }\n        else {\n            Collection<ResolvedCallImpl<D>> functions = convertWithImpliedThis(scope, Collections.singletonList(receiver), getNonExtensionsByName(scope, name));\n\n            List<ResolvedCallImpl<D>> nonlocals = Lists.newArrayList();\n            List<ResolvedCallImpl<D>> locals = Lists.newArrayList();\n            //noinspection unchecked,RedundantTypeArguments\n            TaskPrioritizer.<D>splitLexicallyLocalDescriptors(functions, scope.getContainingDeclaration(), locals, nonlocals);\n\n            addTask(result, call, locals, dataFlowInfo);\n\n            for (ReceiverDescriptor implicitReceiver : implicitReceivers) {\n                doComputeTasks(scope, implicitReceiver, call, name, result, autoCastService);\n            }\n\n            addTask(result, call, nonlocals, dataFlowInfo);\n        }\n    }","commit_id":"a67b76d105392b0e59a72ac631519bc03c696349","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void commit() {\n        addAllMyDataTo(trace);\n    }","id":77393,"modified_method":"public void commit() {\n        addAllMyDataTo(trace);\n        clear();\n    }","commit_id":"a67b76d105392b0e59a72ac631519bc03c696349","url":"https://github.com/JetBrains/kotlin"},{"original_method":"UserGroupInformation ugi() throws IOException {\n    if (UserGroupInformation.isSecurityEnabled()) {\n      return tokenUGI();\n    }\n\n    final String usernameFromQuery = params.userName();\n    final String doAsUserFromQuery = params.doAsUser();\n    final String remoteUser = usernameFromQuery == null\n        ? JspHelper.getDefaultWebUserName(params.conf()) // not specified in\n        // request\n        : usernameFromQuery;\n\n    UserGroupInformation ugi = UserGroupInformation.createRemoteUser(remoteUser);\n    JspHelper.checkUsername(ugi.getShortUserName(), usernameFromQuery);\n    if (doAsUserFromQuery != null) {\n      // create and attempt to authorize a proxy user\n      ugi = UserGroupInformation.createProxyUser(doAsUserFromQuery, ugi);\n    }\n    return ugi;\n  }","id":77394,"modified_method":"UserGroupInformation ugi() throws IOException {\n    UserGroupInformation ugi;\n\n    try {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        final Token<DelegationTokenIdentifier> token = params.delegationToken();\n\n        ugi = ugiCache.get(buildTokenCacheKey(token),\n            new Callable<UserGroupInformation>() {\n              @Override\n              public UserGroupInformation call() throws Exception {\n                return tokenUGI(token);\n              }\n            });\n      } else {\n        final String usernameFromQuery = params.userName();\n        final String doAsUserFromQuery = params.doAsUser();\n        final String remoteUser = usernameFromQuery == null ? JspHelper\n            .getDefaultWebUserName(params.conf()) // not specified in request\n            : usernameFromQuery;\n\n        ugi = ugiCache.get(\n            buildNonTokenCacheKey(doAsUserFromQuery, remoteUser),\n            new Callable<UserGroupInformation>() {\n              @Override\n              public UserGroupInformation call() throws Exception {\n                return nonTokenUGI(usernameFromQuery, doAsUserFromQuery,\n                    remoteUser);\n              }\n            });\n      }\n    } catch (ExecutionException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof IOException) {\n        throw (IOException) cause;\n      } else {\n        throw new IOException(cause);\n      }\n    }\n\n    return ugi;\n  }","commit_id":"84cbd72afda6344e220526fac5c560f00f84e374","url":"https://github.com/apache/hadoop"},{"original_method":"DataNodeUGIProvider(ParameterParser params) {\n    this.params = params;\n  }","id":77395,"modified_method":"DataNodeUGIProvider(ParameterParser params, Configuration conf) {\n    this.params = params;\n    if (ugiCache == null) {\n      synchronized (DataNodeUGIProvider.class) {\n        if (ugiCache == null) {\n          ugiCache = CacheBuilder\n              .newBuilder()\n              .expireAfterAccess(\n                  conf.getInt(\n                      DFSConfigKeys.DFS_WEBHDFS_UGI_EXPIRE_AFTER_ACCESS_KEY,\n                      DFSConfigKeys.DFS_WEBHDFS_UGI_EXPIRE_AFTER_ACCESS_DEFAULT),\n                  TimeUnit.MILLISECONDS).build();\n        }\n      }\n    }\n  }","commit_id":"84cbd72afda6344e220526fac5c560f00f84e374","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void channelRead0(final ChannelHandlerContext ctx,\n                           final HttpRequest req) throws Exception {\n    Preconditions.checkArgument(req.uri().startsWith(WEBHDFS_PREFIX));\n    QueryStringDecoder queryString = new QueryStringDecoder(req.uri());\n    params = new ParameterParser(queryString, conf);\n    DataNodeUGIProvider ugiProvider = new DataNodeUGIProvider(params);\n    ugi = ugiProvider.ugi();\n    path = params.path();\n\n    injectToken();\n    ugi.doAs(new PrivilegedExceptionAction<Void>() {\n      @Override\n      public Void run() throws Exception {\n        handle(ctx, req);\n        return null;\n      }\n    });\n  }","id":77396,"modified_method":"@Override\n  public void channelRead0(final ChannelHandlerContext ctx,\n                           final HttpRequest req) throws Exception {\n    Preconditions.checkArgument(req.uri().startsWith(WEBHDFS_PREFIX));\n    QueryStringDecoder queryString = new QueryStringDecoder(req.uri());\n    params = new ParameterParser(queryString, conf);\n    DataNodeUGIProvider ugiProvider = new DataNodeUGIProvider(params, conf);\n    ugi = ugiProvider.ugi();\n    path = params.path();\n\n    injectToken();\n    ugi.doAs(new PrivilegedExceptionAction<Void>() {\n      @Override\n      public Void run() throws Exception {\n        handle(ctx, req);\n        return null;\n      }\n    });\n  }","commit_id":"84cbd72afda6344e220526fac5c560f00f84e374","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public ProgramController run(final Program program, ProgramOptions options) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.MAPREDUCE, \"Only MAPREDUCE process type is supported.\");\n\n    MapReduceSpecification spec = appSpec.getMapReduce().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing MapReduceSpecification for %s\", program.getName());\n\n    // Optionally get runId. If the map-reduce started by other program (e.g. Workflow), it inherit the runId.\n    Arguments arguments = options.getArguments();\n\n    final RunId runId = RunIds.fromString(arguments.getOption(ProgramOptionConstants.RUN_ID));\n\n    long logicalStartTime = arguments.hasOption(ProgramOptionConstants.LOGICAL_START_TIME)\n                                ? Long.parseLong(arguments\n                                                   .getOption(ProgramOptionConstants.LOGICAL_START_TIME))\n                                : System.currentTimeMillis();\n\n    String programNameInWorkflow = arguments.getOption(ProgramOptionConstants.PROGRAM_NAME_IN_WORKFLOW);\n\n    WorkflowToken workflowToken = null;\n    if (arguments.hasOption(ProgramOptionConstants.WORKFLOW_TOKEN)) {\n      workflowToken = GSON.fromJson(arguments.getOption(ProgramOptionConstants.WORKFLOW_TOKEN),\n                                    BasicWorkflowToken.class);\n    }\n\n    // Setup dataset framework context, if required\n    if (datasetFramework instanceof ProgramContextAware) {\n      Id.Program programId = program.getId();\n      ((ProgramContextAware) datasetFramework).initContext(new Id.Run(programId, runId.getId()));\n    }\n\n    MapReduce mapReduce;\n    try {\n      mapReduce = new InstantiatorFactory(false).get(TypeToken.of(program.<MapReduce>getMainClass())).create();\n    } catch (Exception e) {\n      LOG.error(\"Failed to instantiate MapReduce class for {}\", spec.getClassName(), e);\n      throw Throwables.propagate(e);\n    }\n\n    // List of all Closeable resources that needs to be cleanup\n    List<Closeable> closeables = new ArrayList<>();\n    try {\n      PluginInstantiator pluginInstantiator = createPluginInstantiator(options, program.getClassLoader());\n      if (pluginInstantiator != null) {\n        closeables.add(pluginInstantiator);\n      }\n\n      final BasicMapReduceContext context =\n        new BasicMapReduceContext(program, runId, options.getUserArguments(), spec,\n                                  logicalStartTime, programNameInWorkflow, workflowToken, discoveryServiceClient,\n                                  metricsCollectionService, txSystemClient, datasetFramework, streamAdmin,\n                                  getPluginArchive(options), pluginInstantiator);\n\n      Reflections.visit(mapReduce, mapReduce.getClass(),\n                        new PropertyFieldSetter(context.getSpecification().getProperties()),\n                        new MetricsFieldSetter(context.getMetrics()),\n                        new DataSetFieldSetter(context));\n\n      // note: this sets logging context on the thread level\n      LoggingContextAccessor.setLoggingContext(context.getLoggingContext());\n\n      final Service mapReduceRuntimeService = new MapReduceRuntimeService(injector, cConf, hConf, mapReduce, spec,\n                                                                          context, program.getJarLocation(),\n                                                                          locationFactory, streamAdmin,\n                                                                          txSystemClient, usageRegistry);\n      mapReduceRuntimeService.addListener(\n        createRuntimeServiceListener(program, runId, closeables, arguments, options.getUserArguments()),\n        Threads.SAME_THREAD_EXECUTOR);\n\n      final ProgramController controller = new MapReduceProgramController(mapReduceRuntimeService, context);\n\n      LOG.info(\"Starting MapReduce Job: {}\", context.toString());\n      // if security is not enabled, start the job as the user we're using to access hdfs with.\n      // if this is not done, the mapred job will be launched as the user that runs the program\n      // runner, which is probably the yarn user. This may cause permissions issues if the program\n      // tries to access cdap data. For example, writing to a FileSet will fail, as the yarn user will\n      // be running the job, but the data directory will be owned by cdap.\n      if (!MapReduceTaskContextProvider.isLocal(hConf) && !UserGroupInformation.isSecurityEnabled()) {\n        String runAs = cConf.get(Constants.CFG_HDFS_USER);\n        try {\n          UserGroupInformation.createRemoteUser(runAs)\n            .doAs(new PrivilegedExceptionAction<ListenableFuture<Service.State>>() {\n              @Override\n              public ListenableFuture<Service.State> run() throws Exception {\n                return mapReduceRuntimeService.start();\n              }\n            });\n        } catch (Exception e) {\n          LOG.error(\"Exception running mapreduce job as user {}.\", runAs, e);\n          throw Throwables.propagate(e);\n        }\n      } else {\n        mapReduceRuntimeService.start();\n      }\n      return controller;\n    } catch (Exception e) {\n      closeAllQuietly(closeables);\n      throw Throwables.propagate(e);\n    }\n  }","id":77397,"modified_method":"@Override\n  public ProgramController run(final Program program, ProgramOptions options) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.MAPREDUCE, \"Only MAPREDUCE process type is supported.\");\n\n    MapReduceSpecification spec = appSpec.getMapReduce().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing MapReduceSpecification for %s\", program.getName());\n\n    // Optionally get runId. If the map-reduce started by other program (e.g. Workflow), it inherit the runId.\n    Arguments arguments = options.getArguments();\n\n    final RunId runId = RunIds.fromString(arguments.getOption(ProgramOptionConstants.RUN_ID));\n\n    long logicalStartTime = arguments.hasOption(ProgramOptionConstants.LOGICAL_START_TIME)\n                                ? Long.parseLong(arguments\n                                                   .getOption(ProgramOptionConstants.LOGICAL_START_TIME))\n                                : System.currentTimeMillis();\n\n    String programNameInWorkflow = arguments.getOption(ProgramOptionConstants.PROGRAM_NAME_IN_WORKFLOW);\n\n    WorkflowToken workflowToken = null;\n    if (arguments.hasOption(ProgramOptionConstants.WORKFLOW_TOKEN)) {\n      workflowToken = GSON.fromJson(arguments.getOption(ProgramOptionConstants.WORKFLOW_TOKEN),\n                                    BasicWorkflowToken.class);\n    }\n\n    // Setup dataset framework context, if required\n    if (datasetFramework instanceof ProgramContextAware) {\n      Id.Program programId = program.getId();\n      ((ProgramContextAware) datasetFramework).initContext(new Id.Run(programId, runId.getId()));\n    }\n\n    MapReduce mapReduce;\n    try {\n      mapReduce = new InstantiatorFactory(false).get(TypeToken.of(program.<MapReduce>getMainClass())).create();\n    } catch (Exception e) {\n      LOG.error(\"Failed to instantiate MapReduce class for {}\", spec.getClassName(), e);\n      throw Throwables.propagate(e);\n    }\n\n    // List of all Closeable resources that needs to be cleanup\n    List<Closeable> closeables = new ArrayList<>();\n    try {\n      PluginInstantiator pluginInstantiator = createPluginInstantiator(options, program.getClassLoader());\n      if (pluginInstantiator != null) {\n        closeables.add(pluginInstantiator);\n      }\n\n      final BasicMapReduceContext context =\n        new BasicMapReduceContext(program, runId, options.getUserArguments(), spec,\n                                  logicalStartTime, programNameInWorkflow, workflowToken, discoveryServiceClient,\n                                  metricsCollectionService, txSystemClient, datasetFramework, streamAdmin,\n                                  getPluginArchive(options), pluginInstantiator);\n\n      Reflections.visit(mapReduce, mapReduce.getClass(),\n                        new PropertyFieldSetter(context.getSpecification().getProperties()),\n                        new MetricsFieldSetter(context.getMetrics()),\n                        new DataSetFieldSetter(context));\n\n      // note: this sets logging context on the thread level\n      LoggingContextAccessor.setLoggingContext(context.getLoggingContext());\n\n      final Service mapReduceRuntimeService = new MapReduceRuntimeService(injector, cConf, hConf, mapReduce, spec,\n                                                                          context, program.getJarLocation(),\n                                                                          locationFactory, streamAdmin,\n                                                                          txSystemClient, usageRegistry);\n      mapReduceRuntimeService.addListener(\n        createRuntimeServiceListener(program, runId, closeables, arguments, options.getUserArguments()),\n        Threads.SAME_THREAD_EXECUTOR);\n\n      final ProgramController controller = new MapReduceProgramController(mapReduceRuntimeService, context);\n\n      LOG.info(\"Starting MapReduce Job: {}\", context.toString());\n      // if security is not enabled, start the job as the user we're using to access hdfs with.\n      // if this is not done, the mapred job will be launched as the user that runs the program\n      // runner, which is probably the yarn user. This may cause permissions issues if the program\n      // tries to access cdap data. For example, writing to a FileSet will fail, as the yarn user will\n      // be running the job, but the data directory will be owned by cdap.\n      if (MapReduceTaskContextProvider.isLocal(hConf) || UserGroupInformation.isSecurityEnabled()) {\n        mapReduceRuntimeService.start();\n      } else {\n        ProgramRunners.startAsUser(cConf.get(Constants.CFG_HDFS_USER), mapReduceRuntimeService);\n      }\n      return controller;\n    } catch (Exception e) {\n      closeAllQuietly(closeables);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"87ef67e1c45a1d3c7b3654edc143fc95b9bc3a3b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns true if in local mode.\n   */\n  public boolean isLocal() {\n    return !hConf.getBoolean(HCONF_ATTR_CLUSTER_MODE, false);\n  }","id":77398,"modified_method":"/**\n   * Returns true if in local mode.\n   */\n  public boolean isLocal() {\n    return isLocal(hConf);\n  }","commit_id":"87ef67e1c45a1d3c7b3654edc143fc95b9bc3a3b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ProgramController run(Program program, ProgramOptions options) {\n    // Extract and verify parameters\n    final ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.SPARK, \"Only Spark process type is supported.\");\n\n    final SparkSpecification spec = appSpec.getSpark().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing SparkSpecification for %s\", program.getName());\n\n    // Optionally get runId. If the spark started by other program (e.g. Workflow), it inherit the runId.\n    Arguments arguments = options.getArguments();\n    RunId runId = RunIds.fromString(arguments.getOption(ProgramOptionConstants.RUN_ID));\n\n    long logicalStartTime = arguments.hasOption(ProgramOptionConstants.LOGICAL_START_TIME)\n      ? Long.parseLong(arguments.getOption(ProgramOptionConstants.LOGICAL_START_TIME)) : System.currentTimeMillis();\n\n    WorkflowToken workflowToken = null;\n    if (arguments.hasOption(ProgramOptionConstants.WORKFLOW_TOKEN)) {\n      workflowToken = GSON.fromJson(arguments.getOption(ProgramOptionConstants.WORKFLOW_TOKEN),\n                                    BasicWorkflowToken.class);\n    }\n\n    // Setup dataset framework context, if required\n    if (datasetFramework instanceof ProgramContextAware) {\n      Id.Program programId = program.getId();\n      ((ProgramContextAware) datasetFramework).initContext(new Id.Run(programId, runId.getId()));\n    }\n\n    List<Closeable> closeables = new ArrayList<>();\n    try {\n      PluginInstantiator pluginInstantiator = createPluginInstantiator(options, program.getClassLoader());\n      if (pluginInstantiator != null) {\n        closeables.add(pluginInstantiator);\n      }\n\n      ClientSparkContext context = new ClientSparkContext(program, runId, logicalStartTime,\n                                                          options.getUserArguments().asMap(),\n                                                          txSystemClient, datasetFramework,\n                                                          discoveryServiceClient, metricsCollectionService,\n                                                          getPluginArchive(options), pluginInstantiator, workflowToken);\n      closeables.add(context);\n      Spark spark;\n      try {\n        spark = new InstantiatorFactory(false).get(TypeToken.of(program.<Spark>getMainClass())).create();\n\n        // Fields injection\n        Reflections.visit(spark, spark.getClass(),\n                          new PropertyFieldSetter(spec.getProperties()),\n                          new DataSetFieldSetter(context),\n                          new MetricsFieldSetter(context.getMetrics()));\n      } catch (Exception e) {\n        LOG.error(\"Failed to instantiate Spark class for {}\", spec.getClassName(), e);\n        throw Throwables.propagate(e);\n      }\n\n      SparkSubmitter submitter = new SparkContextConfig(hConf).isLocal() ? new LocalSparkSubmitter()\n        : new DistributedSparkSubmitter();\n      Service sparkRuntimeService = new SparkRuntimeService(\n        cConf, hConf, spark, new SparkContextFactory(hConf, context, datasetFramework, txSystemClient, streamAdmin),\n        submitter, program.getJarLocation(), txSystemClient\n      );\n\n      sparkRuntimeService.addListener(\n        createRuntimeServiceListener(program.getId(), runId, arguments, options.getUserArguments(), closeables),\n        Threads.SAME_THREAD_EXECUTOR);\n      ProgramController controller = new SparkProgramController(sparkRuntimeService, context);\n\n      LOG.info(\"Starting Spark Job: {}\", context.toString());\n      sparkRuntimeService.start();\n      return controller;\n    } catch (Throwable t) {\n      closeAll(closeables);\n      throw t;\n    }\n  }","id":77399,"modified_method":"@Override\n  public ProgramController run(Program program, ProgramOptions options) {\n    // Extract and verify parameters\n    final ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.SPARK, \"Only Spark process type is supported.\");\n\n    final SparkSpecification spec = appSpec.getSpark().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing SparkSpecification for %s\", program.getName());\n\n    // Optionally get runId. If the spark started by other program (e.g. Workflow), it inherit the runId.\n    Arguments arguments = options.getArguments();\n    RunId runId = RunIds.fromString(arguments.getOption(ProgramOptionConstants.RUN_ID));\n\n    long logicalStartTime = arguments.hasOption(ProgramOptionConstants.LOGICAL_START_TIME)\n      ? Long.parseLong(arguments.getOption(ProgramOptionConstants.LOGICAL_START_TIME)) : System.currentTimeMillis();\n\n    WorkflowToken workflowToken = null;\n    if (arguments.hasOption(ProgramOptionConstants.WORKFLOW_TOKEN)) {\n      workflowToken = GSON.fromJson(arguments.getOption(ProgramOptionConstants.WORKFLOW_TOKEN),\n                                    BasicWorkflowToken.class);\n    }\n\n    // Setup dataset framework context, if required\n    if (datasetFramework instanceof ProgramContextAware) {\n      Id.Program programId = program.getId();\n      ((ProgramContextAware) datasetFramework).initContext(new Id.Run(programId, runId.getId()));\n    }\n\n    List<Closeable> closeables = new ArrayList<>();\n    try {\n      PluginInstantiator pluginInstantiator = createPluginInstantiator(options, program.getClassLoader());\n      if (pluginInstantiator != null) {\n        closeables.add(pluginInstantiator);\n      }\n\n      ClientSparkContext context = new ClientSparkContext(program, runId, logicalStartTime,\n                                                          options.getUserArguments().asMap(),\n                                                          txSystemClient, datasetFramework,\n                                                          discoveryServiceClient, metricsCollectionService,\n                                                          getPluginArchive(options), pluginInstantiator, workflowToken);\n      closeables.add(context);\n      Spark spark;\n      try {\n        spark = new InstantiatorFactory(false).get(TypeToken.of(program.<Spark>getMainClass())).create();\n\n        // Fields injection\n        Reflections.visit(spark, spark.getClass(),\n                          new PropertyFieldSetter(spec.getProperties()),\n                          new DataSetFieldSetter(context),\n                          new MetricsFieldSetter(context.getMetrics()));\n      } catch (Exception e) {\n        LOG.error(\"Failed to instantiate Spark class for {}\", spec.getClassName(), e);\n        throw Throwables.propagate(e);\n      }\n\n      SparkSubmitter submitter = SparkContextConfig.isLocal(hConf) ? new LocalSparkSubmitter()\n        : new DistributedSparkSubmitter();\n      Service sparkRuntimeService = new SparkRuntimeService(\n        cConf, hConf, spark, new SparkContextFactory(hConf, context, datasetFramework, txSystemClient, streamAdmin),\n        submitter, program.getJarLocation(), txSystemClient\n      );\n\n      sparkRuntimeService.addListener(\n        createRuntimeServiceListener(program.getId(), runId, arguments, options.getUserArguments(), closeables),\n        Threads.SAME_THREAD_EXECUTOR);\n      ProgramController controller = new SparkProgramController(sparkRuntimeService, context);\n\n      LOG.info(\"Starting Spark Job: {}\", context.toString());\n      if (SparkContextConfig.isLocal(hConf) || UserGroupInformation.isSecurityEnabled()) {\n        sparkRuntimeService.start();\n      } else {\n        ProgramRunners.startAsUser(cConf.get(Constants.CFG_HDFS_USER), sparkRuntimeService);\n      }\n      return controller;\n    } catch (Throwable t) {\n      closeAll(closeables);\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"87ef67e1c45a1d3c7b3654edc143fc95b9bc3a3b","url":"https://github.com/caskdata/cdap"},{"original_method":"UserGroupInformation ugi() throws IOException {\n    if (UserGroupInformation.isSecurityEnabled()) {\n      return tokenUGI();\n    }\n\n    final String usernameFromQuery = params.userName();\n    final String doAsUserFromQuery = params.doAsUser();\n    final String remoteUser = usernameFromQuery == null\n        ? JspHelper.getDefaultWebUserName(params.conf()) // not specified in\n        // request\n        : usernameFromQuery;\n\n    UserGroupInformation ugi = UserGroupInformation.createRemoteUser(remoteUser);\n    JspHelper.checkUsername(ugi.getShortUserName(), usernameFromQuery);\n    if (doAsUserFromQuery != null) {\n      // create and attempt to authorize a proxy user\n      ugi = UserGroupInformation.createProxyUser(doAsUserFromQuery, ugi);\n    }\n    return ugi;\n  }","id":77400,"modified_method":"UserGroupInformation ugi() throws IOException {\n    UserGroupInformation ugi;\n\n    try {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        final Token<DelegationTokenIdentifier> token = params.delegationToken();\n\n        ugi = ugiCache.get(buildTokenCacheKey(token),\n            new Callable<UserGroupInformation>() {\n              @Override\n              public UserGroupInformation call() throws Exception {\n                return tokenUGI(token);\n              }\n            });\n      } else {\n        final String usernameFromQuery = params.userName();\n        final String doAsUserFromQuery = params.doAsUser();\n        final String remoteUser = usernameFromQuery == null ? JspHelper\n            .getDefaultWebUserName(params.conf()) // not specified in request\n            : usernameFromQuery;\n\n        ugi = ugiCache.get(\n            buildNonTokenCacheKey(doAsUserFromQuery, remoteUser),\n            new Callable<UserGroupInformation>() {\n              @Override\n              public UserGroupInformation call() throws Exception {\n                return nonTokenUGI(usernameFromQuery, doAsUserFromQuery,\n                    remoteUser);\n              }\n            });\n      }\n    } catch (ExecutionException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof IOException) {\n        throw (IOException) cause;\n      } else {\n        throw new IOException(cause);\n      }\n    }\n\n    return ugi;\n  }","commit_id":"fe5624b85d71720ae9da90a01cad9a3d1ea41160","url":"https://github.com/apache/hadoop"},{"original_method":"public DatanodeHttpServer(final Configuration conf,\n      final DataNode datanode,\n      final ServerSocketChannel externalHttpChannel)\n    throws IOException {\n    this.conf = conf;\n\n    Configuration confForInfoServer = new Configuration(conf);\n    confForInfoServer.setInt(HttpServer2.HTTP_MAX_THREADS, 10);\n    HttpServer2.Builder builder = new HttpServer2.Builder()\n        .setName(\"datanode\")\n        .setConf(confForInfoServer)\n        .setACL(new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .hostName(getHostnameForSpnegoPrincipal(confForInfoServer))\n        .addEndpoint(URI.create(\"http://localhost:0\"))\n        .setFindPort(true);\n\n    this.infoServer = builder.build();\n\n    this.infoServer.setAttribute(\"datanode\", datanode);\n    this.infoServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    this.infoServer.addServlet(null, \"/blockScannerReport\",\n                               BlockScanner.Servlet.class);\n\n    this.infoServer.start();\n    final InetSocketAddress jettyAddr = infoServer.getConnectorAddress(0);\n\n    this.confForCreate = new Configuration(conf);\n    confForCreate.set(FsPermission.UMASK_LABEL, \"000\");\n\n    this.bossGroup = new NioEventLoopGroup();\n    this.workerGroup = new NioEventLoopGroup();\n    this.externalHttpChannel = externalHttpChannel;\n    HttpConfig.Policy policy = DFSUtil.getHttpPolicy(conf);\n\n    if (policy.isHttpEnabled()) {\n      this.httpServer = new ServerBootstrap().group(bossGroup, workerGroup)\n        .childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n          ch.pipeline().addLast(new PortUnificationServerHandler(jettyAddr,\n              conf, confForCreate));\n        }\n      });\n\n      this.httpServer.childOption(\n          ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK,\n          conf.getInt(\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_HIGH_WATERMARK,\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_HIGH_WATERMARK_DEFAULT));\n      this.httpServer.childOption(\n          ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,\n          conf.getInt(\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_LOW_WATERMARK,\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_LOW_WATERMARK_DEFAULT));\n\n      if (externalHttpChannel == null) {\n        httpServer.channel(NioServerSocketChannel.class);\n      } else {\n        httpServer.channelFactory(new ChannelFactory<NioServerSocketChannel>() {\n          @Override\n          public NioServerSocketChannel newChannel() {\n            return new NioServerSocketChannel(externalHttpChannel) {\n              // The channel has been bounded externally via JSVC,\n              // thus bind() becomes a no-op.\n              @Override\n              protected void doBind(SocketAddress localAddress) throws Exception {}\n            };\n          }\n        });\n      }\n    } else {\n      this.httpServer = null;\n    }\n\n    if (policy.isHttpsEnabled()) {\n      this.sslFactory = new SSLFactory(SSLFactory.Mode.SERVER, conf);\n      try {\n        sslFactory.init();\n      } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n      }\n      this.httpsServer = new ServerBootstrap().group(bossGroup, workerGroup)\n        .channel(NioServerSocketChannel.class)\n        .childHandler(new ChannelInitializer<SocketChannel>() {\n          @Override\n          protected void initChannel(SocketChannel ch) throws Exception {\n            ChannelPipeline p = ch.pipeline();\n            p.addLast(\n              new SslHandler(sslFactory.createSSLEngine()),\n              new HttpRequestDecoder(),\n              new HttpResponseEncoder(),\n              new ChunkedWriteHandler(),\n              new URLDispatcher(jettyAddr, conf, confForCreate));\n          }\n        });\n    } else {\n      this.httpsServer = null;\n      this.sslFactory = null;\n    }\n  }","id":77401,"modified_method":"public DatanodeHttpServer(final Configuration conf,\n      final DataNode datanode,\n      final ServerSocketChannel externalHttpChannel)\n    throws IOException {\n    this.conf = conf;\n\n    Configuration confForInfoServer = new Configuration(conf);\n    confForInfoServer.setInt(HttpServer2.HTTP_MAX_THREADS, 10);\n    HttpServer2.Builder builder = new HttpServer2.Builder()\n        .setName(\"datanode\")\n        .setConf(confForInfoServer)\n        .setACL(new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .hostName(getHostnameForSpnegoPrincipal(confForInfoServer))\n        .addEndpoint(URI.create(\"http://localhost:0\"))\n        .setFindPort(true);\n\n    this.infoServer = builder.build();\n\n    this.infoServer.setAttribute(\"datanode\", datanode);\n    this.infoServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    this.infoServer.addServlet(null, \"/blockScannerReport\",\n                               BlockScanner.Servlet.class);\n    DataNodeUGIProvider.init(conf);\n    this.infoServer.start();\n    final InetSocketAddress jettyAddr = infoServer.getConnectorAddress(0);\n\n    this.confForCreate = new Configuration(conf);\n    confForCreate.set(FsPermission.UMASK_LABEL, \"000\");\n\n    this.bossGroup = new NioEventLoopGroup();\n    this.workerGroup = new NioEventLoopGroup();\n    this.externalHttpChannel = externalHttpChannel;\n    HttpConfig.Policy policy = DFSUtil.getHttpPolicy(conf);\n\n    if (policy.isHttpEnabled()) {\n      this.httpServer = new ServerBootstrap().group(bossGroup, workerGroup)\n        .childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n          ch.pipeline().addLast(new PortUnificationServerHandler(jettyAddr,\n              conf, confForCreate));\n        }\n      });\n\n      this.httpServer.childOption(\n          ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK,\n          conf.getInt(\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_HIGH_WATERMARK,\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_HIGH_WATERMARK_DEFAULT));\n      this.httpServer.childOption(\n          ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,\n          conf.getInt(\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_LOW_WATERMARK,\n              DFSConfigKeys.DFS_WEBHDFS_NETTY_LOW_WATERMARK_DEFAULT));\n\n      if (externalHttpChannel == null) {\n        httpServer.channel(NioServerSocketChannel.class);\n      } else {\n        httpServer.channelFactory(new ChannelFactory<NioServerSocketChannel>() {\n          @Override\n          public NioServerSocketChannel newChannel() {\n            return new NioServerSocketChannel(externalHttpChannel) {\n              // The channel has been bounded externally via JSVC,\n              // thus bind() becomes a no-op.\n              @Override\n              protected void doBind(SocketAddress localAddress) throws Exception {}\n            };\n          }\n        });\n      }\n    } else {\n      this.httpServer = null;\n    }\n\n    if (policy.isHttpsEnabled()) {\n      this.sslFactory = new SSLFactory(SSLFactory.Mode.SERVER, conf);\n      try {\n        sslFactory.init();\n      } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n      }\n      this.httpsServer = new ServerBootstrap().group(bossGroup, workerGroup)\n        .channel(NioServerSocketChannel.class)\n        .childHandler(new ChannelInitializer<SocketChannel>() {\n          @Override\n          protected void initChannel(SocketChannel ch) throws Exception {\n            ChannelPipeline p = ch.pipeline();\n            p.addLast(\n              new SslHandler(sslFactory.createSSLEngine()),\n              new HttpRequestDecoder(),\n              new HttpResponseEncoder(),\n              new ChunkedWriteHandler(),\n              new URLDispatcher(jettyAddr, conf, confForCreate));\n          }\n        });\n    } else {\n      this.httpsServer = null;\n      this.sslFactory = null;\n    }\n  }","commit_id":"fe5624b85d71720ae9da90a01cad9a3d1ea41160","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\t\t\tif ( player != null && event.getTargetId().equals(source.getControllerId())) {\r\n\t\t\t\tManaCostsImpl propagandaTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Constants.Outcome.Benefit, \"Pay {2} to declare attacker?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tpropagandaTax.pay(source, game, this.getId(), event.getPlayerId(), false);\r\n\r\n\t\t\t\t\tif ( propagandaTax.isPaid() ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":77402,"modified_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\t\t\tif ( player != null && event.getTargetId().equals(source.getControllerId())) {\r\n\t\t\t\tManaCostsImpl propagandaTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Constants.Outcome.Benefit, \"Pay {2} to declare attacker?\", game) ) {\r\n\t\t\t\t\tif (propagandaTax.payOrRollback(source, game, this.getId(), event.getPlayerId())) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n                return true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"15f75f8d11f47df152b081551c3e76868af0745c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == EventType.SEARCH_LIBRARY && !paidPlayers.contains(event.getPlayerId()) ) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\r\n\t\t\tif ( player != null ) {\r\n\t\t\t\tManaCostsImpl arbiterTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( arbiterTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Outcome.Neutral, \"Pay {2} to search your library?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tarbiterTax.pay(source, game, this.getId(), event.getPlayerId(), false);\r\n\r\n\t\t\t\t\tif ( arbiterTax.isPaid() ) {\r\n\t\t\t\t\t\tpaidPlayers.add(event.getPlayerId());\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":77403,"modified_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == EventType.SEARCH_LIBRARY && !paidPlayers.contains(event.getPlayerId()) ) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\r\n\t\t\tif ( player != null ) {\r\n\t\t\t\tManaCostsImpl arbiterTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( arbiterTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Outcome.Neutral, \"Pay {2} to search your library?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tif (arbiterTax.payOrRollback(source, game, this.getId(), event.getPlayerId()) ) {\r\n\t\t\t\t\t\tpaidPlayers.add(event.getPlayerId());\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"15f75f8d11f47df152b081551c3e76868af0745c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        if (event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n            Player player = game.getPlayer(event.getPlayerId());\r\n            if (player != null && event.getTargetId().equals(source.getControllerId())) {\r\n                ManaCostsImpl propagandaTax = new ManaCostsImpl(\"{WP}\");\r\n                if (propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n                        player.chooseUse(Constants.Outcome.Benefit, \"Pay {WP} to declare attacker?\", game)) {\r\n                    propagandaTax.pay(source, game, this.getId(), event.getPlayerId(), false);\r\n\r\n                    if (propagandaTax.isPaid()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":77404,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        if (event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n            Player player = game.getPlayer(event.getPlayerId());\r\n            if (player != null && event.getTargetId().equals(source.getControllerId())) {\r\n                ManaCostsImpl propagandaTax = new ManaCostsImpl(\"{WP}\");\r\n                if (propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n                        player.chooseUse(Constants.Outcome.Benefit, \"Pay {WP} to declare attacker?\", game)) {\r\n                    if (propagandaTax.payOrRollback(source, game, this.getId(), event.getPlayerId())) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"15f75f8d11f47df152b081551c3e76868af0745c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\r\n\t\t\tif ( player != null ) {\r\n\t\t\t\tManaCostsImpl propagandaTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Constants.Outcome.Neutral, \"Pay {2} to declare attacker?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tpropagandaTax.pay(source, game, this.getId(), event.getPlayerId(), false);\r\n\r\n\t\t\t\t\tif ( propagandaTax.isPaid() ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":77405,"modified_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\r\n\t\t\tif ( player != null ) {\r\n\t\t\t\tManaCostsImpl propagandaTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Constants.Outcome.Neutral, \"Pay {2} to declare attacker?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tif (propagandaTax.payOrRollback(source, game, this.getId(), event.getPlayerId()) ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"15f75f8d11f47df152b081551c3e76868af0745c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        ManaCostsImpl cost = new ManaCostsImpl(\"{X}\");\r\n        cost.clearPaid();\r\n        if (cost.pay(source, game, source.getId(), source.getControllerId(), false)) {\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            player.gainLife(cost.getX(), game);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }","id":77406,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        ManaCostsImpl cost = new ManaCostsImpl(\"{X}\");\r\n        cost.clearPaid();\r\n        if (cost.payOrRollback(source, game, source.getId(), source.getControllerId())) {\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            player.gainLife(cost.getX(), game);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }","commit_id":"15f75f8d11f47df152b081551c3e76868af0745c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\t\t\tif ( player != null && event.getTargetId().equals(source.getControllerId())) {\r\n\t\t\t\tManaCostsImpl propagandaTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Constants.Outcome.Benefit, \"Pay {2} to declare attacker?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tpropagandaTax.pay(source, game, this.getId(), event.getPlayerId(), false);\r\n\r\n\t\t\t\t\tif ( propagandaTax.isPaid() ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":77407,"modified_method":"@Override\r\n\tpublic boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n\t\tif ( event.getType() == GameEvent.EventType.DECLARE_ATTACKER) {\r\n\t\t\tPlayer player = game.getPlayer(event.getPlayerId());\r\n\t\t\tif ( player != null && event.getTargetId().equals(source.getControllerId())) {\r\n\t\t\t\tManaCostsImpl propagandaTax = new ManaCostsImpl(\"{2}\");\r\n\t\t\t\tif ( propagandaTax.canPay(source.getSourceId(), event.getPlayerId(), game) &&\r\n\t\t\t\t\t player.chooseUse(Constants.Outcome.Benefit, \"Pay {2} to declare attacker?\", game) )\r\n\t\t\t\t{\r\n\t\t\t\t\tif (propagandaTax.payOrRollback(source, game, this.getId(), event.getPlayerId())) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"15f75f8d11f47df152b081551c3e76868af0745c","url":"https://github.com/magefree/mage"},{"original_method":"public AbstractCollectionConverter(TypeDescriptor sourceCollectionType, TypeDescriptor targetCollectionType, GenericTypeConverter conversionService) {\n\t\tthis.conversionService = conversionService;\n\t\tthis.sourceCollectionType = sourceCollectionType;\n\t\tthis.targetCollectionType = targetCollectionType;\n\t\tClass<?> sourceElementType = sourceCollectionType.getElementType();\n\t\tClass<?> targetElementType = targetCollectionType.getElementType();\n\t\tif (sourceElementType != null && targetElementType != null) {\n\t\t\telementConverter = conversionService.getConversionExecutor(sourceElementType, TypeDescriptor.valueOf(targetElementType));\n\t\t} else {\n\t\t\telementConverter = NoOpConversionExecutor.INSTANCE;\n\t\t}\n\t}","id":77408,"modified_method":"public AbstractCollectionConverter(TypeDescriptor sourceCollectionType, TypeDescriptor targetCollectionType, GenericTypeConverter conversionService) {\n\t\tthis.conversionService = conversionService;\n\t\tthis.sourceCollectionType = sourceCollectionType;\n\t\tthis.targetCollectionType = targetCollectionType;\n\t\tClass<?> sourceElementType = sourceCollectionType.getElementType();\n\t\tClass<?> targetElementType = targetCollectionType.getElementType();\n\t\tif (sourceElementType != null && targetElementType != null) {\n\t\t\tConversionExecutor executor = conversionService.getConversionExecutor(sourceElementType, TypeDescriptor.valueOf(targetElementType));\n\t\t\tif (executor != null) {\n\t\t\t\telementConverter = executor;\n\t\t\t} else {\n\t\t\t\telementConverter = NoOpConversionExecutor.INSTANCE;\n\t\t\t}\n\t\t} else {\n\t\t\telementConverter = NoOpConversionExecutor.INSTANCE;\n\t\t}\n\t}","commit_id":"16ad6a3617b4b954bf10602f0393cf7601bec1e1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public AbstractCollectionConverter(TypeDescriptor sourceCollectionType, TypeDescriptor targetCollectionType, ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t\tthis.sourceCollectionType = sourceCollectionType;\n\t\tthis.targetCollectionType = targetCollectionType;\n\t\tClass<?> sourceElementType = sourceCollectionType.getElementType();\n\t\tClass<?> targetElementType = targetCollectionType.getElementType();\n\t\tif (sourceElementType != null && targetElementType != null) {\n\t\t\telementConverter = conversionService.getConversionExecutor(sourceElementType, TypeDescriptor.valueOf(targetElementType));\n\t\t} else {\n\t\t\telementConverter = NoOpConversionExecutor.INSTANCE;\n\t\t}\n\t}","id":77409,"modified_method":"public AbstractCollectionConverter(TypeDescriptor sourceCollectionType, TypeDescriptor targetCollectionType, GenericConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t\tthis.sourceCollectionType = sourceCollectionType;\n\t\tthis.targetCollectionType = targetCollectionType;\n\t\tClass<?> sourceElementType = sourceCollectionType.getElementType();\n\t\tClass<?> targetElementType = targetCollectionType.getElementType();\n\t\tif (sourceElementType != null && targetElementType != null) {\n\t\t\telementConverter = conversionService.getConversionExecutor(sourceElementType, TypeDescriptor.valueOf(targetElementType));\n\t\t} else {\n\t\t\telementConverter = NoOpConversionExecutor.INSTANCE;\n\t\t}\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected ConversionService getConversionService() {\n\t\treturn conversionService;\n\t}","id":77410,"modified_method":"protected GenericConversionService getConversionService() {\n\t\treturn conversionService;\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Creates a new default conversion service, installing the default converters.\n\t */\n\tpublic DefaultConversionService() {\n\t\taddDefaultConverters();\n\t\taddDefaultAliases();\n\t}","id":77411,"modified_method":"/**\n\t * Creates a new default conversion service, installing the default converters.\n\t */\n\tpublic DefaultConversionService() {\n\t\taddDefaultConverters();\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Test the service can convert what we are about to use in the expression evaluation tests.\n\t */\n\tpublic void testConversionsAvailable() throws Exception {\n\t\tTypeConvertorUsingConversionService tcs = new TypeConvertorUsingConversionService();\n\t\t\n\t\t// ArrayList containing List<Integer> to List<String>\n\t\tClass<?> clazz = typeDescriptorForListOfString.getElementType();\n\t\tassertEquals(String.class,clazz);\n\t\tConversionExecutor executor = tcs.getConversionExecutor(ArrayList.class, typeDescriptorForListOfString);\n\t\tassertNotNull(executor);\n\t\tList l = (List)executor.execute(listOfInteger);\n\t\tassertNotNull(l); \n\n\t\t// ArrayList containing List<String> to List<Integer>\n\t\tclazz = typeDescriptorForListOfInteger.getElementType();\n\t\tassertEquals(Integer.class,clazz);\n\t\texecutor = tcs.getConversionExecutor(ArrayList.class, typeDescriptorForListOfInteger);\n\t\tassertNotNull(executor);\n\t\tl = (List)executor.execute(listOfString);\n\t\tassertNotNull(l);\n\t}","id":77412,"modified_method":"/**\n\t * Test the service can convert what we are about to use in the expression evaluation tests.\n\t */\n\tpublic void testConversionsAvailable() throws Exception {\n\t\tTypeConvertorUsingConversionService tcs = new TypeConvertorUsingConversionService();\n\t\t\n\t\t// ArrayList containing List<Integer> to List<String>\n\t\tClass<?> clazz = typeDescriptorForListOfString.getElementType();\n\t\tassertEquals(String.class,clazz);\n\t\tList l = (List) tcs.executeConversion(listOfInteger, typeDescriptorForListOfString);\n\t\tassertNotNull(l); \n\n\t\t// ArrayList containing List<String> to List<Integer>\n\t\tclazz = typeDescriptorForListOfInteger.getElementType();\n\t\tassertEquals(Integer.class,clazz);\n\t\t\n\t\tl = (List) tcs.executeConversion(listOfString, typeDescriptorForListOfString);\n\t\tassertNotNull(l);\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Object executeConversion(Object source, TypeDescriptor targetType)\n\t\t\tthrows ConversionExecutorNotFoundException, ConversionException {\n\t\tif (source == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getConversionExecutor(source.getClass(), targetType).execute(source);\n\t}","id":77413,"modified_method":"public Object executeConversion(Object source, TypeDescriptor targetType) {\n\t\tif (source == null) {\n\t\t\treturn null;\n\t\t}\n\t\tConversionExecutor executor = getConversionExecutor(source.getClass(), targetType);\n\t\tif (executor != null) {\n\t\t\treturn executor.execute(source);\n\t\t} else {\n\t\t\tif (parent != null) {\n\t\t\t\treturn parent.executeConversion(source, targetType);\n\t\t\t} else {\n\t\t\t\tthrow new ConverterNotFoundException(source.getClass(), targetType,\n\t\t\t\t\t\t\"No converter found that can convert from sourceType [\" + source.getClass().getName()\n\t\t\t\t\t\t\t\t+ \"] to targetType [\" + targetType.getName() + \"]\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ConversionExecutor getConversionExecutor(Class sourceClass, TypeDescriptor targetType)\n\t\t\tthrows ConversionExecutorNotFoundException {\n\t\tAssert.notNull(sourceClass, \"The sourceType to convert from is required\");\n\t\tAssert.notNull(targetType, \"The targetType to convert to is required\");\n\t\tTypeDescriptor sourceType = TypeDescriptor.valueOf(sourceClass);\n\t\tif (sourceType.isArray()) {\n\t\t\tif (targetType.isArray()) {\n\t\t\t\treturn new ArrayToArray(sourceType, targetType, this);\n\t\t\t} else if (targetType.isCollection()) {\n\t\t\t\tif (targetType.isAbstractClass()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Conversion target class [\" + targetType.getName()\n\t\t\t\t\t\t\t+ \"] is invalid; cannot convert to abstract collection types--\"\n\t\t\t\t\t\t\t+ \"request an interface or concrete implementation instead\");\n\t\t\t\t}\n\t\t\t\treturn new ArrayToCollection(sourceType, targetType, this);\n\t\t\t}\n\t\t}\n\t\tif (targetType.isArray()) {\n\t\t\tif (sourceType.isCollection()) {\n\t\t\t\treturn new CollectionToArray(sourceType, targetType, this);\n\t\t\t} else {\n\t\t\t\tthrow new ConversionExecutorNotFoundException(sourceType, targetType, \"Object to Array conversion not yet supported\");\n\t\t\t}\n\t\t}\n\t\tif (sourceType.isCollection()) {\n\t\t\tif (targetType.isCollection()) {\n\t\t\t\treturn new CollectionToCollection(sourceType, targetType, this);\n\t\t\t} else {\n\t\t\t\tthrow new ConversionExecutorNotFoundException(sourceType, targetType, \"Object to Collection conversion not yet supported\");\n\t\t\t}\n\t\t}\n\t\tif (sourceType.isMap()) {\n\t\t\tif (targetType.isMap()) {\n\t\t\t\treturn new MapToMap(sourceType, targetType, this);\n\t\t\t} else {\n\t\t\t\tthrow new ConversionExecutorNotFoundException(sourceType, targetType, \"Object to Map conversion not yet supported\");\n\t\t\t}\n\t\t}\n\t\tConverter converter = findRegisteredConverter(sourceClass, targetType.getType());\n\t\tif (converter != null) {\n\t\t\treturn new StaticConversionExecutor(sourceType, targetType, converter);\n\t\t} else {\n\t\t\tSuperConverter superConverter = findRegisteredSuperConverter(sourceClass, targetType.getType());\n\t\t\tif (superConverter != null) {\n\t\t\t\treturn new StaticSuperConversionExecutor(sourceType, targetType, superConverter);\n\t\t\t}\n\t\t\tif (parent != null) {\n\t\t\t\treturn parent.getConversionExecutor(sourceClass, targetType);\n\t\t\t} else {\n\t\t\t\tif (sourceType.isAssignableTo(targetType)) {\n\t\t\t\t\treturn new StaticConversionExecutor(sourceType, targetType, NoOpConverter.INSTANCE);\n\t\t\t\t}\n\t\t\t\tthrow new ConversionExecutorNotFoundException(sourceType, targetType,\n\t\t\t\t\t\t\"No ConversionExecutor found for converting from sourceType [\" + sourceType.getName()\n\t\t\t\t\t\t\t\t+ \"] to targetType [\" + targetType.getName() + \"]\");\n\t\t\t}\n\t\t}\n\t}","id":77414,"modified_method":"ConversionExecutor getConversionExecutor(Class sourceClass, TypeDescriptor targetType)\n\t\t\tthrows ConverterNotFoundException {\n\t\tAssert.notNull(sourceClass, \"The sourceType to convert from is required\");\n\t\tAssert.notNull(targetType, \"The targetType to convert to is required\");\n\t\tTypeDescriptor sourceType = TypeDescriptor.valueOf(sourceClass);\n\t\tif (sourceType.isArray()) {\n\t\t\tif (targetType.isArray()) {\n\t\t\t\treturn new ArrayToArray(sourceType, targetType, this);\n\t\t\t} else if (targetType.isCollection()) {\n\t\t\t\tif (targetType.isAbstractClass()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Conversion target class [\" + targetType.getName()\n\t\t\t\t\t\t\t+ \"] is invalid; cannot convert to abstract collection types--\"\n\t\t\t\t\t\t\t+ \"request an interface or concrete implementation instead\");\n\t\t\t\t}\n\t\t\t\treturn new ArrayToCollection(sourceType, targetType, this);\n\t\t\t}\n\t\t}\n\t\tif (targetType.isArray()) {\n\t\t\tif (sourceType.isCollection()) {\n\t\t\t\treturn new CollectionToArray(sourceType, targetType, this);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (sourceType.isCollection()) {\n\t\t\tif (targetType.isCollection()) {\n\t\t\t\treturn new CollectionToCollection(sourceType, targetType, this);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (sourceType.isMap()) {\n\t\t\tif (targetType.isMap()) {\n\t\t\t\treturn new MapToMap(sourceType, targetType, this);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tConverter converter = findRegisteredConverter(sourceClass, targetType.getType());\n\t\tif (converter != null) {\n\t\t\treturn new StaticConversionExecutor(sourceType, targetType, converter);\n\t\t} else {\n\t\t\tSuperConverter superConverter = findRegisteredSuperConverter(sourceClass, targetType.getType());\n\t\t\tif (superConverter != null) {\n\t\t\t\treturn new StaticSuperConversionExecutor(sourceType, targetType, superConverter);\n\t\t\t} else {\n\t\t\t\tif (sourceType.isAssignableTo(targetType)) {\n\t\t\t\t\treturn new StaticConversionExecutor(sourceType, targetType, NoOpConverter.INSTANCE);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean canConvert(Class<?> sourceType, TypeDescriptor targetType) {\n\t\ttry {\n\t\t\tgetConversionExecutor(sourceType, targetType);\n\t\t\treturn true;\n\t\t} catch (ConversionExecutorNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}","id":77415,"modified_method":"public boolean canConvert(Class<?> sourceType, TypeDescriptor targetType) {\n\t\tConversionExecutor executor = getConversionExecutor(sourceType, targetType);\n\t\tif (executor != null) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (parent != null) {\n\t\t\t\treturn parent.canConvert(sourceType, targetType);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void convertNoSuperTargetType() {\n\t\tservice.addConverter(new Converter<CharSequence, Number>() {\n\t\t\tpublic Integer convert(CharSequence source) throws Exception {\n\t\t\t\treturn Integer.valueOf(source.toString());\n\t\t\t}\n\n\t\t\tpublic CharSequence convertBack(Number target) throws Exception {\n\t\t\t\treturn target.toString();\n\t\t\t}\n\t\t});\n\t\ttry {\n\t\t\tConversionExecutor executor = service.getConversionExecutor(String.class, type(Integer.class));\n\t\t\tfail(\"Should have failed\");\n\t\t} catch (ConversionExecutorNotFoundException e) {\n\n\t\t}\n\t}","id":77416,"modified_method":"@Test\n\tpublic void convertNoSuperTargetType() {\n\t\tservice.addConverter(new Converter<CharSequence, Number>() {\n\t\t\tpublic Integer convert(CharSequence source) throws Exception {\n\t\t\t\treturn Integer.valueOf(source.toString());\n\t\t\t}\n\n\t\t\tpublic CharSequence convertBack(Number target) throws Exception {\n\t\t\t\treturn target.toString();\n\t\t\t}\n\t\t});\n\t\ttry {\n\t\t\tservice.executeConversion(\"3\", type(Integer.class));\n\t\t\tfail(\"Should have failed\");\n\t\t} catch (ConverterNotFoundException e) {\n\n\t\t}\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void convertExecutorNotFound() {\n\t\ttry {\n\t\t\tservice.getConversionExecutor(String.class, type(Integer.class));\n\t\t\tfail(\"Should have thrown an exception\");\n\t\t} catch (ConversionExecutorNotFoundException e) {\n\t\t}\n\t}","id":77417,"modified_method":"@Test\n\tpublic void convertExecutorNotFound() {\n\t\ttry {\n\t\t\tservice.executeConversion(\"3\", type(Integer.class));\n\t\t\tfail(\"Should have thrown an exception\");\n\t\t} catch (ConverterNotFoundException e) {\n\t\t}\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Creates a new map-to-map converter\n\t * @param sourceType the source map type\n\t * @param targetType the target map type\n\t * @param conversionService the conversion service\n\t */\n\tpublic MapToMap(TypeDescriptor sourceType, TypeDescriptor targetType, ConversionService conversionService) {\n\t\tthis.sourceType = sourceType;\n\t\tthis.targetType = targetType;\n\t\tthis.conversionService = conversionService;\n\t\tthis.entryConverter = createEntryConverter();\n\t}","id":77418,"modified_method":"/**\n\t * Creates a new map-to-map converter\n\t * @param sourceType the source map type\n\t * @param targetType the target map type\n\t * @param conversionService the conversion service\n\t */\n\tpublic MapToMap(TypeDescriptor sourceType, TypeDescriptor targetType, GenericConversionService conversionService) {\n\t\tthis.sourceType = sourceType;\n\t\tthis.targetType = targetType;\n\t\tthis.conversionService = conversionService;\n\t\tthis.entryConverter = createEntryConverter();\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Object convertValue(Object value, TypeDescriptor typeDescriptor) throws EvaluationException {\r\n\t\ttry {\r\n\t\t\treturn conversionService.executeConversion(value, typeDescriptor);\r\n\t\t} catch (ConversionExecutorNotFoundException cenfe) {\r\n\t\t\tthrow new SpelException(cenfe, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t} catch (ConversionException ce) {\r\n\t\t\tthrow new SpelException(ce, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t}\r\n\t}","id":77419,"modified_method":"public Object convertValue(Object value, TypeDescriptor typeDescriptor) throws EvaluationException {\r\n\t\ttry {\r\n\t\t\treturn conversionService.executeConversion(value, typeDescriptor);\r\n\t\t} catch (ConverterNotFoundException cenfe) {\r\n\t\t\tthrow new SpelException(cenfe, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t} catch (ConversionException ce) {\r\n\t\t\tthrow new SpelException(ce, SpelMessages.TYPE_CONVERSION_ERROR, value.getClass(), typeDescriptor.asString());\r\n\t\t}\r\n\t}","commit_id":"d7c90cff145edc3193a63b1b7751aee203d5c4d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n    public void testValueMapTypes() throws IOException {\n        Resource resource1 = context.resourceResolver().getResource(testRoot().getPath() + \"/node1\");\n\n        // ensure that value map has only supported primitive types (all other supported types converted to string)\n        ValueMap valueMap = resource1.getValueMap();\n        for (Map.Entry<String, Object> entry : valueMap.entrySet()) {\n            assertTrue(NoSqlValueMap.isValidPrimitveType(entry.getValue().getClass()));\n        }\n    }","id":77420,"modified_method":"@Test\n    public void testValueMapTypes() throws IOException {\n        Resource resource1 = context.resourceResolver().getResource(testRoot().getPath() + \"/node1\");\n\n        // ensure that value map has only supported primitive types (all other supported types converted to string)\n        ValueMap valueMap = resource1.getValueMap();\n        for (Map.Entry<String, Object> entry : valueMap.entrySet()) {\n            assertTrue(NoSqlValueMap.isValidType(entry.getValue().getClass()));\n        }\n    }","commit_id":"1233522b21c30618cb67fb6a2a8417075c7bf184","url":"https://github.com/apache/sling"},{"original_method":"public NoSqlResourceProvider(NoSqlAdapter adapter, EventAdmin eventAdmin) {\n        this.adapter = adapter;\n        this.eventAdmin = eventAdmin;\n    }","id":77421,"modified_method":"public NoSqlResourceProvider(NoSqlAdapter adapter, EventAdmin eventAdmin) {\n        this.adapter = new ValueMapConvertingNoSqlAdapter(adapter);\n        this.eventAdmin = eventAdmin;\n    }","commit_id":"1233522b21c30618cb67fb6a2a8417075c7bf184","url":"https://github.com/apache/sling"},{"original_method":"private static Object convertForWrite(Object value) {\n        if (value instanceof Calendar) {\n            value = getISO8601Format().format(((Calendar)value).getTime());\n        }\n        if (value instanceof Date) {\n            value = getISO8601Format().format((Date)value);\n        }\n        else if (value instanceof InputStream) {\n            // Store InputStream values as byte array\n            try {\n                value = convertForWrite(IOUtils.toByteArray((InputStream)value));\n            } catch (IOException ex) {\n                throw new RuntimeException(\"Unable to convert input stream to byte array.\");\n            }\n        }\n        else if (value instanceof byte[]) {\n            value = DatatypeConverter.printBase64Binary((byte[])value);\n        }\n        else if (value != null && !isValidPrimitveType(value.getClass())) {\n            throw new IllegalArgumentException(\"Data type not supported for NoSqlValueMap: \" + value.getClass());\n        }\n        return value;\n    }","id":77422,"modified_method":"private static Object convertForWrite(Object value) {\n        if (value instanceof Date) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.setTime((Date)value);\n            value = calendar;\n        }\n        else if (value instanceof InputStream) {\n            // Store InputStream values as byte array\n            try {\n                value = convertForWrite(IOUtils.toByteArray((InputStream)value));\n            } catch (IOException ex) {\n                throw new RuntimeException(\"Unable to convert input stream to byte array.\");\n            }\n        }\n        else if (value != null && !isValidType(value.getClass())) {\n            throw new IllegalArgumentException(\"Data type not supported for NoSqlValueMap: \" + value.getClass());\n        }\n        return value;\n    }","commit_id":"1233522b21c30618cb67fb6a2a8417075c7bf184","url":"https://github.com/apache/sling"},{"original_method":"static boolean isValidPrimitveType(Class clazz) {\n        if (clazz.isArray()) {\n            return isValidPrimitveType(clazz.getComponentType());\n        }\n        else {\n            return clazz == String.class\n                    || clazz == Integer.class\n                    || clazz == Long.class\n                    || clazz == Double.class\n                    || clazz == Boolean.class;\n        }\n    }","id":77423,"modified_method":"static boolean isValidType(Class clazz) {\n        if (clazz.isArray()) {\n            if (clazz.getComponentType() == byte.class) {\n                // byte only supported as array\n                return true;\n            }\n            return isValidType(clazz.getComponentType());\n        }\n        else {\n            return clazz == String.class\n                    || clazz == Integer.class\n                    || clazz == Long.class\n                    || clazz == Double.class\n                    || clazz == Boolean.class\n                    || Calendar.class.isAssignableFrom(clazz);\n        }\n    }","commit_id":"1233522b21c30618cb67fb6a2a8417075c7bf184","url":"https://github.com/apache/sling"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T get(String name, Class<T> type) {\n        \n        if (type == Calendar.class) {\n            Date date = get(name, Date.class);\n            if (date != null) {\n                Calendar calendar = Calendar.getInstance();\n                calendar.setTime(date);\n                return (T)calendar;\n            }\n            else {\n                return null;\n            }\n        }\n        else if (type == Date.class) {\n            Object value = get(name);\n            if (value instanceof String) {\n                try {\n                    return (T)getISO8601Format().parse((String)value);\n                } catch (ParseException e) {\n                    return null;\n                }\n            }\n        }\n        else if (type == InputStream.class) {\n            // Support conversion from byte array to InputStream\n            byte[] data = get(name, byte[].class);\n            if (data != null) {\n                return (T)new ByteArrayInputStream(data);\n            }\n            else {\n                return null;\n            }\n        }\n        else if (type == byte[].class) {\n            // Support conversion from base64 string to byte array\n            Object value = get(name);\n            if (value instanceof String) {\n                return (T)DatatypeConverter.parseBase64Binary((String)value);\n            }\n        }\n        else if ( type == null ) {\n            return (T) super.get(name);\n        }\n        return super.get(name, type);\n    }","id":77424,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T get(String name, Class<T> type) {\n        \n        if (type == Date.class) {\n            Calendar value = get(name, Calendar.class);\n            if (value != null) {\n                return (T)value.getTime();\n            }\n        }\n        else if (type == InputStream.class) {\n            // Support conversion from byte array to InputStream\n            byte[] data = get(name, byte[].class);\n            if (data != null) {\n                return (T)new ByteArrayInputStream(data);\n            }\n            else {\n                return null;\n            }\n        }\n        else if ( type == null ) {\n            return (T) super.get(name);\n        }\n        return super.get(name, type);\n    }","commit_id":"1233522b21c30618cb67fb6a2a8417075c7bf184","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @throws JspException\n     */\n    @Override\n    public int doStartTag() throws JspException {\n\n        if (value == null) {\n            return EVAL_PAGE;\n        }\n\n        try {\n            JspWriter out = pageContext.getOut();\n\n            renderMomentInclude(out);\n\n            out.append(\"  <time\");\n            out.append(getCssClass());\n            out.append(\" data-reference-date=\\\"\" +\n                    isoFormatter.format(getReference()) + \"\\\"\");\n            out.append(\" datetime=\\\"\" +\n                    isoFormatter.format(getValue()) + \"\\\">\");\n            out.append(getFormattedDate());\n            out.append(\"  <\/time>\");\n        }\n        catch (IOException ioe) {\n            throw new JspException(\"IO error writing to JSP file:\", ioe);\n        }\n        return (SKIP_BODY);\n    }","id":77425,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @throws JspException\n     */\n    @Override\n    public int doStartTag() throws JspException {\n\n        if (value == null) {\n            return EVAL_PAGE;\n        }\n\n        try {\n            JspWriter out = pageContext.getOut();\n\n            Calendar refDate = Calendar.getInstance();\n            refDate.setTime(getReference());\n            Calendar valDate = Calendar.getInstance();\n            valDate.setTime(getValue());\n\n            renderMomentInclude(out);\n            out.append(\"  <time\");\n            out.append(getCssClass());\n            out.append(\" data-reference-date=\\\"\" +\n                    DatatypeConverter.printDateTime(refDate) + \"\\\"\");\n            out.append(\" datetime=\\\"\" +\n                    DatatypeConverter.printDateTime(valDate) + \"\\\">\");\n            out.append(getFormattedDate());\n            out.append(\"  <\/time>\");\n        }\n        catch (IOException ioe) {\n            throw new JspException(\"IO error writing to JSP file:\", ioe);\n        }\n        return (SKIP_BODY);\n    }","commit_id":"ff4d8499193cf59c215468beccfd62a552e26d0c","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public boolean isExcluded(ModuleRevisionResolveState moduleRevision) {\r\n            boolean excluded = dependency.descriptor.doesExclude(new String[]{from.configurationName}, new ArtifactId(moduleRevision.descriptor.getModuleRevisionId().getModuleId(), \"ivy\", \"ivy\", \"ivy\"));\r\n            if (excluded) {\r\n                System.out.println(\"   excluded by \" + this);\r\n                return true;\r\n            }\r\n            return path.isExcluded(moduleRevision);\r\n        }","id":77426,"modified_method":"public boolean isExcluded(ModuleRevisionResolveState moduleRevision) {\r\n            String[] configurations = from.heirarchy.toArray(new String[from.heirarchy.size()]);\r\n            boolean excluded = dependency.descriptor.doesExclude(configurations, new ArtifactId(moduleRevision.descriptor.getModuleRevisionId().getModuleId(), \"ivy\", \"ivy\", \"ivy\"));\r\n            if (excluded) {\r\n                System.out.println(\"   excluded by \" + this);\r\n                return true;\r\n            }\r\n            return path.isExcluded(moduleRevision);\r\n        }","commit_id":"79c3366e65b3db85b8dada253b318283bdd73875","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\r\n        public void attachToParents(ConfigurationResolveState childConfiguration, ResolvedArtifactFactory resolvedArtifactFactory, ArtifactToFileResolver resolver, ResolvedConfigurationImpl result) {\r\n            System.out.println(\"  attach via \" + this);\r\n            System.out.println(\"    \" + from + \" -> \" + childConfiguration);\r\n            DefaultResolvedDependency parent = from.getResult();\r\n            DefaultResolvedDependency child = childConfiguration.getResult();\r\n            parent.addChild(child);\r\n\r\n            Set<ResolvedArtifact> artifacts = getArtifacts(childConfiguration, resolvedArtifactFactory, resolver);\r\n            if (artifacts.isEmpty()) {\r\n                artifacts = childConfiguration.getArtifacts(resolvedArtifactFactory, resolver);\r\n            }\r\n            child.addParentSpecificArtifacts(parent, artifacts);\r\n            for (ResolvedArtifact artifact : artifacts) {\r\n                result.addArtifact(artifact);\r\n            }\r\n\r\n            if (parent == result.getRoot()) {\r\n                EnhancedDependencyDescriptor enhancedDependencyDescriptor = (EnhancedDependencyDescriptor) dependency.descriptor;\r\n                result.addFirstLevelDependency(enhancedDependencyDescriptor.getModuleDependency(), child);\r\n            }\r\n        }","id":77427,"modified_method":"@Override\r\n        public void attachToParents(ConfigurationResolveState childConfiguration, ResolvedArtifactFactory resolvedArtifactFactory, ArtifactToFileResolver resolver, ResolvedConfigurationImpl result) {\r\n            System.out.println(\"  attach via \" + this);\r\n            System.out.println(\"    \" + from + \" -> \" + childConfiguration);\r\n            DefaultResolvedDependency parent = from.getResult();\r\n            DefaultResolvedDependency child = childConfiguration.getResult();\r\n            parent.addChild(child);\r\n\r\n            Set<ResolvedArtifact> artifacts = getArtifacts(childConfiguration, resolvedArtifactFactory, resolver);\r\n            if (!artifacts.isEmpty()) {\r\n                child.addParentSpecificArtifacts(parent, artifacts);\r\n            }\r\n            \r\n            boolean includeDefaults = dependency.descriptor instanceof EnhancedDependencyDescriptor && ((EnhancedDependencyDescriptor) dependency.descriptor).isIncludeDefaultArtifacts();\r\n            if (artifacts.isEmpty() || includeDefaults) {\r\n                child.addParentSpecificArtifacts(parent, childConfiguration.getArtifacts(resolvedArtifactFactory, resolver));\r\n            }\r\n            for (ResolvedArtifact artifact : child.getParentArtifacts(parent)) {\r\n                result.addArtifact(artifact);\r\n            }\r\n\r\n            if (parent == result.getRoot()) {\r\n                EnhancedDependencyDescriptor enhancedDependencyDescriptor = (EnhancedDependencyDescriptor) dependency.descriptor;\r\n                result.addFirstLevelDependency(enhancedDependencyDescriptor.getModuleDependency(), child);\r\n            }\r\n        }","commit_id":"79c3366e65b3db85b8dada253b318283bdd73875","url":"https://github.com/gradle/gradle"},{"original_method":"void addOutgoingDependencies(ResolvePath incomingPath, Collection<DependencyResolvePath> dependencies) {\r\n            incomingPaths.add(incomingPath);\r\n            for (DependencyResolveState dependency : moduleRevision.getDependencies()) {\r\n                Set<String> targetConfigurations = new LinkedHashSet<String>();\r\n                for (String moduleConfiguration : dependency.descriptor.getModuleConfigurations()) {\r\n                    if (heirarchy.contains(moduleConfiguration)) {\r\n                        for (String targetConfiguration : dependency.descriptor.getDependencyConfigurations(moduleConfiguration)) {\r\n                            targetConfigurations.add(targetConfiguration);\r\n                        }\r\n                    }\r\n                }\r\n                if (!targetConfigurations.isEmpty()) {\r\n                    DependencyResolvePath dependencyResolvePath = new DependencyResolvePath(incomingPath, this, dependency, targetConfigurations);\r\n                    dependencies.add(dependencyResolvePath);\r\n                }\r\n            }\r\n        }","id":77428,"modified_method":"void addOutgoingDependencies(ResolvePath incomingPath, Collection<DependencyResolvePath> dependencies) {\r\n            if (incomingPath.canReach(this)) {\r\n                System.out.println(\"    skipping \" + incomingPath + \" as it already traverses \" + this);\r\n                return;\r\n            }\r\n            incomingPaths.add(incomingPath);\r\n            for (DependencyResolveState dependency : moduleRevision.getDependencies()) {\r\n                Set<String> targetConfigurations = new LinkedHashSet<String>();\r\n                for (String moduleConfiguration : dependency.descriptor.getModuleConfigurations()) {\r\n                    if (heirarchy.contains(moduleConfiguration)) {\r\n                        for (String targetConfiguration : dependency.descriptor.getDependencyConfigurations(moduleConfiguration)) {\r\n                            targetConfigurations.add(targetConfiguration);\r\n                        }\r\n                    }\r\n                }\r\n                if (!targetConfigurations.isEmpty()) {\r\n                    DependencyResolvePath dependencyResolvePath = new DependencyResolvePath(incomingPath, this, dependency, targetConfigurations);\r\n                    dependencies.add(dependencyResolvePath);\r\n                }\r\n            }\r\n        }","commit_id":"79c3366e65b3db85b8dada253b318283bdd73875","url":"https://github.com/gradle/gradle"},{"original_method":"private void resolve(DependencyToModuleResolver resolver, ResolvedConfigurationImpl result, ConfigurationResolveState root, ResolveState resolveState, ResolveData resolveData, ArtifactToFileResolver artifactResolver, Configuration configuration) {\r\n        System.out.println(\"-> RESOLVE \" + root);\r\n\r\n        SetMultimap<ModuleId, DependencyResolvePath> conflicts = LinkedHashMultimap.create();\r\n\r\n        List<DependencyResolvePath> queue = new ArrayList<DependencyResolvePath>();\r\n        root.addOutgoingDependencies(new RootPath(), queue);\r\n\r\n        while (!queue.isEmpty() || !conflicts.isEmpty()) {\r\n            if (queue.isEmpty()) {\r\n                ModuleId moduleId = conflicts.keySet().iterator().next();\r\n                Set<ModuleRevisionResolveState> candidates = resolveState.getRevisions(moduleId);\r\n                System.out.println(\"selecting moduleId from conflicts \" + candidates);\r\n                List<ModuleResolveStateBackedArtifactInfo> artifactInfos = new ArrayList<ModuleResolveStateBackedArtifactInfo>();\r\n                for (final ModuleRevisionResolveState moduleRevision : candidates) {\r\n                    artifactInfos.add(new ModuleResolveStateBackedArtifactInfo(moduleRevision));\r\n                }\r\n                List<ModuleResolveStateBackedArtifactInfo> sorted = new LatestRevisionStrategy().sort(artifactInfos.toArray(new ArtifactInfo[artifactInfos.size()]));\r\n                ModuleRevisionResolveState selected = sorted.get(sorted.size() - 1).moduleRevision;\r\n                System.out.println(\"  selected \" + selected);\r\n                selected.status = Status.Include;\r\n                for (ModuleRevisionResolveState candidate : candidates) {\r\n                    if (candidate != selected) {\r\n                        candidate.status = Status.Evict;\r\n                        for (DependencyResolvePath path : candidate.outgoingPaths) {\r\n                            path.restart(selected, queue);\r\n                        }\r\n                    }\r\n                }\r\n                Set<DependencyResolvePath> paths = conflicts.removeAll(moduleId);\r\n                for (DependencyResolvePath path : paths) {\r\n                    path.restart(selected, queue);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            DependencyResolvePath path = queue.remove(0);\r\n            System.out.println(\"* path \" + path);\r\n\r\n            try {\r\n                path.resolve(resolver, resolveState);\r\n            } catch (Throwable t) {\r\n                result.addUnresolvedDependency(path.dependency.descriptor, t);\r\n                continue;\r\n            }\r\n\r\n            if (path.targetModuleRevision.status == Status.Conflict) {\r\n                conflicts.put(path.targetModuleRevision.descriptor.getModuleRevisionId().getModuleId(), path);\r\n            } else {\r\n                path.addOutgoingDependencies(resolveData, resolveState, queue);\r\n            }\r\n        }\r\n        \r\n        for (ConfigurationResolveState resolvedConfiguration : resolveState.getConfigurations()) {\r\n            resolvedConfiguration.attachToParents(resolvedArtifactFactory, artifactResolver, result);\r\n        }\r\n    }","id":77429,"modified_method":"private void resolve(DependencyToModuleResolver resolver, ResolvedConfigurationImpl result, ConfigurationResolveState root, ResolveState resolveState, ResolveData resolveData, ArtifactToFileResolver artifactResolver) {\r\n        System.out.println(\"-> RESOLVE \" + root);\r\n\r\n        SetMultimap<ModuleId, DependencyResolvePath> conflicts = LinkedHashMultimap.create();\r\n\r\n        List<DependencyResolvePath> queue = new ArrayList<DependencyResolvePath>();\r\n        root.addOutgoingDependencies(new RootPath(), queue);\r\n\r\n        while (!queue.isEmpty() || !conflicts.isEmpty()) {\r\n            if (queue.isEmpty()) {\r\n                ModuleId moduleId = conflicts.keySet().iterator().next();\r\n                Set<ModuleRevisionResolveState> candidates = resolveState.getRevisions(moduleId);\r\n                System.out.println(\"selecting moduleId from conflicts \" + candidates);\r\n                List<ModuleResolveStateBackedArtifactInfo> artifactInfos = new ArrayList<ModuleResolveStateBackedArtifactInfo>();\r\n                for (final ModuleRevisionResolveState moduleRevision : candidates) {\r\n                    artifactInfos.add(new ModuleResolveStateBackedArtifactInfo(moduleRevision));\r\n                }\r\n                List<ModuleResolveStateBackedArtifactInfo> sorted = new LatestRevisionStrategy().sort(artifactInfos.toArray(new ArtifactInfo[artifactInfos.size()]));\r\n                ModuleRevisionResolveState selected = sorted.get(sorted.size() - 1).moduleRevision;\r\n                System.out.println(\"  selected \" + selected);\r\n                selected.status = Status.Include;\r\n                for (ModuleRevisionResolveState candidate : candidates) {\r\n                    if (candidate != selected) {\r\n                        candidate.status = Status.Evict;\r\n                        for (DependencyResolvePath path : candidate.outgoingPaths) {\r\n                            path.restart(selected, queue);\r\n                        }\r\n                    }\r\n                }\r\n                Set<DependencyResolvePath> paths = conflicts.removeAll(moduleId);\r\n                for (DependencyResolvePath path : paths) {\r\n                    path.restart(selected, queue);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            DependencyResolvePath path = queue.remove(0);\r\n            System.out.println(\"* path \" + path);\r\n\r\n            try {\r\n                path.resolve(resolver, resolveState);\r\n            } catch (Throwable t) {\r\n                result.addUnresolvedDependency(path.dependency.descriptor, t);\r\n                continue;\r\n            }\r\n\r\n            if (path.targetModuleRevision.status == Status.Conflict) {\r\n                conflicts.put(path.targetModuleRevision.descriptor.getModuleRevisionId().getModuleId(), path);\r\n            } else {\r\n                path.addOutgoingDependencies(resolveData, resolveState, queue);\r\n            }\r\n        }\r\n        \r\n        for (ConfigurationResolveState resolvedConfiguration : resolveState.getConfigurations()) {\r\n            resolvedConfiguration.attachToParents(resolvedArtifactFactory, artifactResolver, result);\r\n        }\r\n    }","commit_id":"79c3366e65b3db85b8dada253b318283bdd73875","url":"https://github.com/gradle/gradle"},{"original_method":"public ResolvedConfiguration resolve(ConfigurationInternal configuration) throws ResolveException {\r\n        Ivy ivy = ivyFactory.create(configuration.getResolutionStrategy());\r\n\r\n        IvyConfig ivyConfig = new IvyConfig(ivy.getSettings(), configuration.getResolutionStrategy());\r\n        ModuleDescriptor moduleDescriptor = moduleDescriptorConverter.convert(configuration.getAll(), configuration.getModule(), ivyConfig);\r\n        DependencyResolver resolver = ivy.getSettings().getDefaultResolver();\r\n        ResolveOptions options = new ResolveOptions();\r\n        options.setDownload(false);\r\n        options.setConfs(WrapUtil.toArray(configuration.getName()));\r\n        ResolveData resolveData = new ResolveData(ivy.getResolveEngine(), options);\r\n        DependencyToModuleResolver dependencyResolver = new IvyResolverBackedDependencyToModuleResolver(ivy, resolveData, resolver);\r\n        IvyResolverBackedArtifactToFileResolver artifactResolver = new IvyResolverBackedArtifactToFileResolver(resolver);\r\n        ResolveState resolveState = new ResolveState();\r\n        ConfigurationResolveState root = resolveState.getConfiguration(moduleDescriptor, configuration.getName());\r\n        ResolvedConfigurationImpl result = new ResolvedConfigurationImpl(configuration, root.getResult());\r\n        resolve(dependencyResolver, result, root, resolveState, resolveData, artifactResolver, configuration);\r\n\r\n        System.out.println(\"-> RESULT\");\r\n        for (ResolvedArtifact artifact : result.getResolvedArtifacts()) {\r\n            System.out.println(\"  \" + artifact.getModule().getId() + \" \" + artifact.getName());\r\n        }\r\n        for (UnresolvedDependency dependency : result.getUnresolvedDependencies()) {\r\n            System.out.println(\"  unresolved \" + dependency.getId());\r\n        }\r\n\r\n        return result;\r\n    }","id":77430,"modified_method":"public ResolvedConfiguration resolve(ConfigurationInternal configuration) throws ResolveException {\r\n        Ivy ivy = ivyFactory.create(configuration.getResolutionStrategy());\r\n\r\n        IvyConfig ivyConfig = new IvyConfig(ivy.getSettings(), configuration.getResolutionStrategy());\r\n        ModuleDescriptor moduleDescriptor = moduleDescriptorConverter.convert(configuration.getAll(), configuration.getModule(), ivyConfig);\r\n        DependencyResolver resolver = ivy.getSettings().getDefaultResolver();\r\n        ResolveOptions options = new ResolveOptions();\r\n        options.setDownload(false);\r\n        options.setConfs(WrapUtil.toArray(configuration.getName()));\r\n        ResolveData resolveData = new ResolveData(ivy.getResolveEngine(), options);\r\n        DependencyToModuleResolver dependencyResolver = new IvyResolverBackedDependencyToModuleResolver(ivy, resolveData, resolver);\r\n        IvyResolverBackedArtifactToFileResolver artifactResolver = new IvyResolverBackedArtifactToFileResolver(resolver);\r\n        ResolveState resolveState = new ResolveState();\r\n        ConfigurationResolveState root = resolveState.getConfiguration(moduleDescriptor, configuration.getName());\r\n        ResolvedConfigurationImpl result = new ResolvedConfigurationImpl(configuration, root.getResult());\r\n        resolve(dependencyResolver, result, root, resolveState, resolveData, artifactResolver);\r\n\r\n        System.out.println(\"-> RESULT\");\r\n        for (ResolvedArtifact artifact : result.getResolvedArtifacts()) {\r\n            System.out.println(\"  \" + artifact.getModule().getId() + \" \" + artifact.getName());\r\n        }\r\n        for (UnresolvedDependency dependency : result.getUnresolvedDependencies()) {\r\n            System.out.println(\"  unresolved \" + dependency.getId());\r\n        }\r\n\r\n        return result;\r\n    }","commit_id":"79c3366e65b3db85b8dada253b318283bdd73875","url":"https://github.com/gradle/gradle"},{"original_method":"private Set<ResolvedArtifact> getArtifacts(ConfigurationResolveState childConfiguration, ResolvedArtifactFactory resolvedArtifactFactory, ArtifactToFileResolver resolver) {\r\n            DependencyArtifactDescriptor[] dependencyArtifacts = dependency.descriptor.getDependencyArtifacts(from.configurationName);\r\n            if (dependencyArtifacts.length == 0) {\r\n                return Collections.emptySet();\r\n            }\r\n            Set<ResolvedArtifact> artifacts = new LinkedHashSet<ResolvedArtifact>();\r\n            for (DependencyArtifactDescriptor artifactDescriptor : dependencyArtifacts) {\r\n                MDArtifact artifact = new MDArtifact(childConfiguration.descriptor, artifactDescriptor.getName(), artifactDescriptor.getType(), artifactDescriptor.getExt(), artifactDescriptor.getUrl(), artifactDescriptor.getQualifiedExtraAttributes());\r\n                artifacts.add(resolvedArtifactFactory.create(childConfiguration.getResult(), artifact, resolver));\r\n            }\r\n            return artifacts;\r\n        }","id":77431,"modified_method":"private Set<ResolvedArtifact> getArtifacts(ConfigurationResolveState childConfiguration, ResolvedArtifactFactory resolvedArtifactFactory, ArtifactToFileResolver resolver) {\r\n            String[] targetConfigurations = from.heirarchy.toArray(new String[from.heirarchy.size()]);\r\n            DependencyArtifactDescriptor[] dependencyArtifacts = dependency.descriptor.getDependencyArtifacts(targetConfigurations);\r\n            if (dependencyArtifacts.length == 0) {\r\n                return Collections.emptySet();\r\n            }\r\n            Set<ResolvedArtifact> artifacts = new LinkedHashSet<ResolvedArtifact>();\r\n            for (DependencyArtifactDescriptor artifactDescriptor : dependencyArtifacts) {\r\n                MDArtifact artifact = new MDArtifact(childConfiguration.descriptor, artifactDescriptor.getName(), artifactDescriptor.getType(), artifactDescriptor.getExt(), artifactDescriptor.getUrl(), artifactDescriptor.getQualifiedExtraAttributes());\r\n                artifacts.add(resolvedArtifactFactory.create(childConfiguration.getResult(), artifact, resolver));\r\n            }\r\n            return artifacts;\r\n        }","commit_id":"79c3366e65b3db85b8dada253b318283bdd73875","url":"https://github.com/gradle/gradle"},{"original_method":"public static DefaultResolvedArtifact createResolvedArtifact(Mockery context, final String name, final String type, final String extension, final File file) {\n        final Artifact artifactStub = context.mock(Artifact.class, \"artifact\" + name);\n        context.checking(new Expectations() {{\n            allowing(artifactStub).getName();\n            will(returnValue(name));\n            allowing(artifactStub).getType();\n            will(returnValue(type));\n            allowing(artifactStub).getExt();\n            will(returnValue(extension));\n            allowing(artifactStub).getExtraAttributes();\n            will(returnValue(Collections.emptyMap()));\n            allowing(artifactStub).getExtraAttribute(with(org.hamcrest.Matchers.notNullValue(String.class)));\n            will(returnValue(null));\n        }});\n        final FileSource artifactSource = context.mock(FileSource.class);\n        context.checking(new Expectations() {{\n            allowing(artifactSource).get();\n            will(returnValue(file));\n        }});\n        return new DefaultResolvedArtifact(context.mock(ResolvedDependency.class), artifactStub, artifactSource);\n    }","id":77432,"modified_method":"public static DefaultResolvedArtifact createResolvedArtifact(final Mockery context, final String name, final String type, final String extension, final File file) {\r\n        final Artifact artifactStub = context.mock(Artifact.class, \"artifact\" + name);\r\n        context.checking(new Expectations() {{\r\n            allowing(artifactStub).getName();\r\n            will(returnValue(name));\r\n            allowing(artifactStub).getType();\r\n            will(returnValue(type));\r\n            allowing(artifactStub).getExt();\r\n            will(returnValue(extension));\r\n            allowing(artifactStub).getExtraAttributes();\r\n            will(returnValue(Collections.emptyMap()));\r\n            allowing(artifactStub).getExtraAttribute(with(org.hamcrest.Matchers.notNullValue(String.class)));\r\n            will(returnValue(null));\r\n        }});\r\n        final FileSource artifactSource = context.mock(FileSource.class);\r\n        context.checking(new Expectations() {{\r\n            allowing(artifactSource).get();\r\n            will(returnValue(file));\r\n        }});\r\n        final ResolvedDependency resolvedDependency = context.mock(ResolvedDependency.class);\r\n        final ResolvedModule resolvedModule = context.mock(ResolvedModule.class);\r\n        context.checking(new Expectations() {{\r\n            allowing(resolvedDependency).getModule();\r\n            will(returnValue(resolvedModule));\r\n            allowing(resolvedModule).getId();\r\n            will(returnValue(new DefaultResolvedModuleId(\"group\", name, \"1.2\")));\r\n        }});\r\n        return new DefaultResolvedArtifact(resolvedDependency, artifactStub, artifactSource);\r\n    }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<ResolvedArtifact> getResolvedArtifacts() throws ResolveException {\r\n            throw new UnsupportedOperationException();\r\n        }","id":77433,"modified_method":"public Set<ResolvedArtifact> getResolvedArtifacts() throws ResolveException {\r\n            return artifacts;\r\n        }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\r\n        public void attachToParents(ConfigurationResolveState childConfiguration, ResolvedArtifactFactory resolvedArtifactFactory, ArtifactToFileResolver resolver, ResolvedConfigurationImpl result) {\r\n            System.out.println(\"  attach via \" + this);\r\n            System.out.println(\"    \" + from + \" -> \" + childConfiguration);\r\n            DefaultResolvedDependency parent = from.getResult();\r\n            DefaultResolvedDependency child = childConfiguration.getResult();\r\n            parent.addChild(child);\r\n\r\n            Set<ResolvedArtifact> artifacts = getArtifacts(childConfiguration, resolvedArtifactFactory, resolver);\r\n            if (!artifacts.isEmpty()) {\r\n                child.addParentSpecificArtifacts(parent, artifacts);\r\n            } else {\r\n                child.addParentSpecificArtifacts(parent, childConfiguration.getArtifacts(resolvedArtifactFactory, resolver));\r\n            }\r\n\r\n            if (parent == result.getRoot()) {\r\n                EnhancedDependencyDescriptor enhancedDependencyDescriptor = (EnhancedDependencyDescriptor) descriptor;\r\n                result.addFirstLevelDependency(enhancedDependencyDescriptor.getModuleDependency(), child);\r\n            }\r\n        }","id":77434,"modified_method":"@Override\r\n        public void attachToParents(ConfigurationResolveState childConfiguration, ResolvedArtifactFactory resolvedArtifactFactory, ArtifactToFileResolver resolver, ResolvedConfigurationImpl result) {\r\n            System.out.println(\"  attach via \" + this);\r\n            System.out.println(\"    \" + from + \" -> \" + childConfiguration);\r\n            DefaultResolvedDependency parent = from.getResult();\r\n            DefaultResolvedDependency child = childConfiguration.getResult();\r\n            parent.addChild(child);\r\n\r\n            Set<ResolvedArtifact> artifacts = getArtifacts(childConfiguration, resolvedArtifactFactory, resolver);\r\n            if (artifacts.isEmpty()) {\r\n                artifacts = childConfiguration.getArtifacts(resolvedArtifactFactory, resolver);\r\n            }\r\n            child.addParentSpecificArtifacts(parent, artifacts);\r\n            for (ResolvedArtifact artifact : artifacts) {\r\n                result.addArtifact(artifact);\r\n            }\r\n\r\n            if (parent == result.getRoot()) {\r\n                EnhancedDependencyDescriptor enhancedDependencyDescriptor = (EnhancedDependencyDescriptor) descriptor;\r\n                result.addFirstLevelDependency(enhancedDependencyDescriptor.getModuleDependency(), child);\r\n            }\r\n        }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null || obj.getClass() != getClass()) {\n            return false;\n        }\n        DefaultResolvedArtifact other = (DefaultResolvedArtifact) obj;\n        if (!other.resolvedDependency.equals(resolvedDependency)) {\n            return false;\n        }\n        if (!other.getName().equals(getName())) {\n            return false;\n        }\n        if (!other.getType().equals(getType())) {\n            return false;\n        }\n        if (!other.getExtension().equals(getExtension())) {\n            return false;\n        }\n        if (!other.artifact.getExtraAttributes().equals(artifact.getExtraAttributes())) {\n            return false;\n        }\n        return true;\n    }","id":77435,"modified_method":"@Override\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (obj == null || obj.getClass() != getClass()) {\r\n            return false;\r\n        }\r\n        DefaultResolvedArtifact other = (DefaultResolvedArtifact) obj;\r\n        if (!other.resolvedDependency.getModule().getId().equals(resolvedDependency.getModule().getId())) {\r\n            return false;\r\n        }\r\n        if (!other.getName().equals(getName())) {\r\n            return false;\r\n        }\r\n        if (!other.getType().equals(getType())) {\r\n            return false;\r\n        }\r\n        if (!other.getExtension().equals(getExtension())) {\r\n            return false;\r\n        }\r\n        if (!other.artifact.getExtraAttributes().equals(artifact.getExtraAttributes())) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public int hashCode() {\n        return resolvedDependency.hashCode() ^ getName().hashCode() ^ getType().hashCode() ^ getExtension().hashCode() ^ artifact.getExtraAttributes().hashCode();\n    }","id":77436,"modified_method":"@Override\r\n    public int hashCode() {\r\n        return resolvedDependency.getModule().getId().hashCode() ^ getName().hashCode() ^ getType().hashCode() ^ getExtension().hashCode() ^ artifact.getExtraAttributes().hashCode();\r\n    }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void init() {\n        String someGroup = \"someGroup\";\n        String someName = \"someName\";\n        String someVersion = \"someVersion\";\n        String someConfiguration = \"someConfiguration\";\n        Set<ResolvedArtifact> someArtifacts = WrapUtil.toSet(createArtifact(\"someName\"));\n        DefaultResolvedDependency resolvedDependency = new DefaultResolvedDependency(someGroup, someName, someVersion, someConfiguration);\n        assertThat(resolvedDependency.getName(), equalTo(someGroup + \":\" + someName + \":\" + someVersion));\n        assertThat(resolvedDependency.getModuleGroup(), equalTo(someGroup));\n        assertThat(resolvedDependency.getModuleName(), equalTo(someName));\n        assertThat(resolvedDependency.getModuleVersion(), equalTo(someVersion));\n        assertThat(resolvedDependency.getConfiguration(), equalTo(someConfiguration));\n        assertThat(resolvedDependency.getModuleArtifacts(), equalTo(Collections.<ResolvedArtifact>emptySet()));\n        assertThat(resolvedDependency.getChildren(), equalTo(Collections.<ResolvedDependency>emptySet()));\n        assertThat(resolvedDependency.getParents(), equalTo(Collections.<ResolvedDependency>emptySet()));\n    }","id":77437,"modified_method":"@Test\r\n    public void init() {\r\n        String someGroup = \"someGroup\";\r\n        String someName = \"someName\";\r\n        String someVersion = \"someVersion\";\r\n        String someConfiguration = \"someConfiguration\";\r\n        DefaultResolvedDependency resolvedDependency = new DefaultResolvedDependency(someGroup, someName, someVersion, someConfiguration);\r\n        assertThat(resolvedDependency.getName(), equalTo(someGroup + \":\" + someName + \":\" + someVersion));\r\n        assertThat(resolvedDependency.getModuleGroup(), equalTo(someGroup));\r\n        assertThat(resolvedDependency.getModuleName(), equalTo(someName));\r\n        assertThat(resolvedDependency.getModuleVersion(), equalTo(someVersion));\r\n        assertThat(resolvedDependency.getConfiguration(), equalTo(someConfiguration));\r\n        assertThat(resolvedDependency.getModuleArtifacts(), equalTo(Collections.<ResolvedArtifact>emptySet()));\r\n        assertThat(resolvedDependency.getChildren(), equalTo(Collections.<ResolvedDependency>emptySet()));\r\n        assertThat(resolvedDependency.getParents(), equalTo(Collections.<ResolvedDependency>emptySet()));\r\n    }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleIdentifier getId() {\n        return new ModuleIdentifier() {\n            public String getGroup() {\n                return moduleRevisionId.getOrganisation();\n            }\n\n            public String getName() {\n                return moduleRevisionId.getName();\n            }\n\n            public String getVersion() {\n                return moduleRevisionId.getRevision();\n            }\n        };\n    }","id":77438,"modified_method":"public ModuleIdentifier getId() {\r\n        return new DefaultResolvedModuleId(moduleRevisionId.getOrganisation(), moduleRevisionId.getName(), moduleRevisionId.getRevision());\r\n    }","commit_id":"4f51636400567c4e99b97c3de96072943b52bfb3","url":"https://github.com/gradle/gradle"},{"original_method":"public void attachToParents(ConfigurationNode childConfiguration, ResolvedArtifactFactory artifactFactory, ResolvedConfigurationBuilder result) {\n            DefaultResolvedDependency parent = from.getResult();\n            DefaultResolvedDependency child = childConfiguration.getResult();\n            parent.addChild(child);\n\n            Set<ResolvedArtifact> artifacts = getArtifacts(childConfiguration, artifactFactory);\n            if (!artifacts.isEmpty()) {\n                child.addParentSpecificArtifacts(parent, artifacts);\n            }\n\n            if (artifacts.isEmpty()) {\n                child.addParentSpecificArtifacts(parent, childConfiguration.getArtifacts(artifactFactory));\n            }\n            for (ResolvedArtifact artifact : child.getParentArtifacts(parent)) {\n                result.addArtifact(artifact);\n            }\n\n            if (parent == result.getRoot()) {\n                EnhancedDependencyDescriptor enhancedDependencyDescriptor = (EnhancedDependencyDescriptor) dependencyDescriptor;\n                result.addFirstLevelDependency(enhancedDependencyDescriptor.getModuleDependency(), child);\n            }\n        }","id":77439,"modified_method":"public void attachToParents(ConfigurationNode childConfiguration, ResolvedArtifactFactory artifactFactory, ResolvedConfigurationBuilder result) {\n            DefaultResolvedDependency parent = from.getResult();\n            DefaultResolvedDependency child = childConfiguration.getResult();\n            parent.addChild(child);\n\n            Set<ResolvedArtifact> artifacts = getArtifacts(childConfiguration, artifactFactory);\n            if (artifacts.isEmpty()) {\n                artifacts = childConfiguration.getArtifacts(artifactFactory);\n            }\n            child.addParentSpecificArtifacts(parent, artifacts);\n\n            for (ResolvedArtifact artifact : artifacts) {\n                result.addArtifact(artifact);\n            }\n\n            if (parent == result.getRoot()) {\n                EnhancedDependencyDescriptor enhancedDependencyDescriptor = (EnhancedDependencyDescriptor) dependencyDescriptor;\n                result.addFirstLevelDependency(enhancedDependencyDescriptor.getModuleDependency(), child);\n            }\n        }","commit_id":"6ac5aa713f0ce0770eb34edcee1a3d3c67d71338","url":"https://github.com/gradle/gradle"},{"original_method":"/** Returns a rect for the image describing the texture region to be packed, or null if the image should not be packed. */\n\tRect processImage (BufferedImage image, String name) {\n\t\tif (scale <= 0) throw new IllegalArgumentException(\"scale cannot be <= 0: \" + scale);\n\n\t\tint width = image.getWidth(), height = image.getHeight();\n\n\t\tif (image.getType() != BufferedImage.TYPE_4BYTE_ABGR) {\n\t\t\tBufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\t\tnewImage.getGraphics().drawImage(image, 0, 0, null);\n\t\t\timage = newImage;\n\t\t}\n\n\t\tboolean isPatch = name.endsWith(\".9\");\n\t\tint[] splits = null, pads = null;\n\t\tRect rect = null;\n\t\tif (isPatch) {\n\t\t\t// Strip \".9\" from file name, read ninepatch split pixels, and strip ninepatch split pixels.\n\t\t\tname = name.substring(0, name.length() - 2);\n\t\t\tsplits = getSplits(image, name);\n\t\t\tpads = getPads(image, name, splits);\n\t\t\t// Strip split pixels.\n\t\t\twidth -= 2;\n\t\t\theight -= 2;\n\t\t\tBufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\t\tnewImage.getGraphics().drawImage(image, 0, 0, width, height, 1, 1, width + 1, height + 1, null);\n\t\t\timage = newImage;\n\t\t}\n\n\t\t// Scale image.\n\t\tif (scale != 1) {\n\t\t\tint originalWidth = width, originalHeight = height;\n\t\t\twidth = Math.round(width * scale);\n\t\t\theight = Math.round(height * scale);\n\t\t\tBufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\t\tif (scale < 1) {\n\t\t\t\tnewImage.getGraphics().drawImage(image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING), 0, 0, null);\n\t\t\t} else {\n\t\t\t\tGraphics2D g = (Graphics2D)newImage.getGraphics();\n\t\t\t\tg.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n\t\t\t\tg.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n\t\t\t\tg.drawImage(image, 0, 0, width, height, null);\n\t\t\t}\n\t\t\timage = newImage;\n\t\t}\n\n\t\tif (isPatch) {\n\t\t\t// Ninepatches aren't rotated or whitespace stripped.\n\t\t\trect = new Rect(image, 0, 0, width, height, true);\n\t\t\trect.splits = splits;\n\t\t\trect.pads = pads;\n\t\t\trect.canRotate = false;\n\t\t} else {\n\t\t\trect = stripWhitespace(image);\n\t\t\tif (rect == null) return null;\n\t\t}\n\n\t\t// Strip digits off end of name and use as index.\n\t\tint index = -1;\n\t\tif (settings.useIndexes) {\n\t\t\tMatcher matcher = indexPattern.matcher(name);\n\t\t\tif (matcher.matches()) {\n\t\t\t\tname = matcher.group(1);\n\t\t\t\tindex = Integer.parseInt(matcher.group(2));\n\t\t\t}\n\t\t}\n\n\t\trect.name = name;\n\t\trect.index = index;\n\t\treturn rect;\n\t}","id":77440,"modified_method":"/** Returns a rect for the image describing the texture region to be packed, or null if the image should not be packed. */\n\tRect processImage (BufferedImage image, String name) {\n\t\tif (scale <= 0) throw new IllegalArgumentException(\"scale cannot be <= 0: \" + scale);\n\n\t\tint width = image.getWidth(), height = image.getHeight();\n\n\t\tif (image.getType() != BufferedImage.TYPE_4BYTE_ABGR) {\n\t\t\tBufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\t\tnewImage.getGraphics().drawImage(image, 0, 0, null);\n\t\t\timage = newImage;\n\t\t}\n\n\t\tboolean isPatch = name.endsWith(\".9\");\n\t\tint[] splits = null, pads = null;\n\t\tRect rect = null;\n\t\tif (isPatch) {\n\t\t\t// Strip \".9\" from file name, read ninepatch split pixels, and strip ninepatch split pixels.\n\t\t\tname = name.substring(0, name.length() - 2);\n\t\t\tsplits = getSplits(image, name);\n\t\t\tpads = getPads(image, name, splits);\n\t\t\t// Strip split pixels.\n\t\t\twidth -= 2;\n\t\t\theight -= 2;\n\t\t\tBufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\t\tnewImage.getGraphics().drawImage(image, 0, 0, width, height, 1, 1, width + 1, height + 1, null);\n\t\t\timage = newImage;\n\t\t}\n\n\t\t// Scale image.\n\t\tif (scale != 1) {\n\t\t\tint originalWidth = width, originalHeight = height;\n\t\t\twidth = Math.max(1, Math.round(width * scale));\n\t\t\theight = Math.max(1, Math.round(height * scale));\n\t\t\tBufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\t\tif (scale < 1) {\n\t\t\t\tnewImage.getGraphics().drawImage(image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING), 0, 0, null);\n\t\t\t} else {\n\t\t\t\tGraphics2D g = (Graphics2D)newImage.getGraphics();\n\t\t\t\tg.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n\t\t\t\tg.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n\t\t\t\tg.drawImage(image, 0, 0, width, height, null);\n\t\t\t}\n\t\t\timage = newImage;\n\t\t}\n\n\t\tif (isPatch) {\n\t\t\t// Ninepatches aren't rotated or whitespace stripped.\n\t\t\trect = new Rect(image, 0, 0, width, height, true);\n\t\t\trect.splits = splits;\n\t\t\trect.pads = pads;\n\t\t\trect.canRotate = false;\n\t\t} else {\n\t\t\trect = stripWhitespace(image);\n\t\t\tif (rect == null) return null;\n\t\t}\n\n\t\t// Strip digits off end of name and use as index.\n\t\tint index = -1;\n\t\tif (settings.useIndexes) {\n\t\t\tMatcher matcher = indexPattern.matcher(name);\n\t\t\tif (matcher.matches()) {\n\t\t\t\tname = matcher.group(1);\n\t\t\t\tindex = Integer.parseInt(matcher.group(2));\n\t\t\t}\n\t\t}\n\n\t\trect.name = name;\n\t\trect.index = index;\n\t\treturn rect;\n\t}","commit_id":"624839715239b823ba1ae0293128d52c4f531344","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Settings (Settings settings) {\r\n\t\t\tfast = settings.fast;\r\n\t\t\trotation = settings.rotation;\r\n\t\t\tpot = settings.pot;\r\n\t\t\tminWidth = settings.minWidth;\r\n\t\t\tminHeight = settings.minHeight;\r\n\t\t\tmaxWidth = settings.maxWidth;\r\n\t\t\tmaxHeight = settings.maxHeight;\r\n\t\t\tpaddingX = settings.paddingX;\r\n\t\t\tpaddingY = settings.paddingY;\r\n\t\t\tedgePadding = settings.edgePadding;\r\n\t\t\tduplicatePadding = settings.duplicatePadding;\r\n\t\t\talphaThreshold = settings.alphaThreshold;\r\n\t\t\tignoreBlankImages = settings.ignoreBlankImages;\r\n\t\t\tstripWhitespaceX = settings.stripWhitespaceX;\r\n\t\t\tstripWhitespaceY = settings.stripWhitespaceY;\r\n\t\t\talias = settings.alias;\r\n\t\t\tformat = settings.format;\r\n\t\t\tjpegQuality = settings.jpegQuality;\r\n\t\t\toutputFormat = settings.outputFormat;\r\n\t\t\tfilterMin = settings.filterMin;\r\n\t\t\tfilterMag = settings.filterMag;\r\n\t\t\twrapX = settings.wrapX;\r\n\t\t\twrapY = settings.wrapY;\r\n\t\t\tdebug = settings.debug;\r\n\t\t\tsilent = settings.silent;\r\n\t\t\tcombineSubdirectories = settings.combineSubdirectories;\r\n\t\t\tflattenPaths = settings.flattenPaths;\r\n\t\t\tpremultiplyAlpha = settings.premultiplyAlpha;\r\n\t\t\tsquare = settings.square;\r\n\t\t\tuseIndexes = settings.useIndexes;\r\n\t\t\tbleed = settings.bleed;\r\n\t\t\tlimitMemory = settings.limitMemory;\r\n\t\t\tgrid = settings.grid;\r\n\t\t\tscale = settings.scale;\r\n\t\t\tscaleSuffix = settings.scaleSuffix;\r\n\t\t\tatlasExtension = settings.atlasExtension;\r\n\t\t}","id":77441,"modified_method":"public Settings (Settings settings) {\r\n\t\t\tfast = settings.fast;\r\n\t\t\trotation = settings.rotation;\r\n\t\t\tpot = settings.pot;\r\n\t\t\tminWidth = settings.minWidth;\r\n\t\t\tminHeight = settings.minHeight;\r\n\t\t\tmaxWidth = settings.maxWidth;\r\n\t\t\tmaxHeight = settings.maxHeight;\r\n\t\t\tpaddingX = settings.paddingX;\r\n\t\t\tpaddingY = settings.paddingY;\r\n\t\t\tedgePadding = settings.edgePadding;\r\n\t\t\tduplicatePadding = settings.duplicatePadding;\r\n\t\t\talphaThreshold = settings.alphaThreshold;\r\n\t\t\tignoreBlankImages = settings.ignoreBlankImages;\r\n\t\t\tstripWhitespaceX = settings.stripWhitespaceX;\r\n\t\t\tstripWhitespaceY = settings.stripWhitespaceY;\r\n\t\t\talias = settings.alias;\r\n\t\t\tformat = settings.format;\r\n\t\t\tjpegQuality = settings.jpegQuality;\r\n\t\t\toutputFormat = settings.outputFormat;\r\n\t\t\tfilterMin = settings.filterMin;\r\n\t\t\tfilterMag = settings.filterMag;\r\n\t\t\twrapX = settings.wrapX;\r\n\t\t\twrapY = settings.wrapY;\r\n\t\t\tdebug = settings.debug;\r\n\t\t\tsilent = settings.silent;\r\n\t\t\tcombineSubdirectories = settings.combineSubdirectories;\r\n\t\t\tignore = settings.ignore;\r\n\t\t\tflattenPaths = settings.flattenPaths;\r\n\t\t\tpremultiplyAlpha = settings.premultiplyAlpha;\r\n\t\t\tsquare = settings.square;\r\n\t\t\tuseIndexes = settings.useIndexes;\r\n\t\t\tbleed = settings.bleed;\r\n\t\t\tlimitMemory = settings.limitMemory;\r\n\t\t\tgrid = settings.grid;\r\n\t\t\tscale = settings.scale;\r\n\t\t\tscaleSuffix = settings.scaleSuffix;\r\n\t\t\tatlasExtension = settings.atlasExtension;\r\n\t\t}","commit_id":"624839715239b823ba1ae0293128d52c4f531344","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void processDir (Entry inputDir, ArrayList<Entry> files) throws Exception {\n\t\tif (ignoreDirs.contains(inputDir.inputFile)) return;\n\n\t\t// Find first parent with settings, or use defaults.\n\t\tSettings settings = null;\n\t\tFile parent = inputDir.inputFile;\n\t\twhile (true) {\n\t\t\tsettings = dirToSettings.get(parent);\n\t\t\tif (settings != null) break;\n\t\t\tif (parent == null || parent.equals(root)) break;\n\t\t\tparent = parent.getParentFile();\n\t\t}\n\t\tif (settings == null) settings = defaultSettings;\n\n\t\tif (settings.combineSubdirectories) {\n\t\t\t// Collect all files under subdirectories and ignore subdirectories so they won't be packed twice.\n\t\t\tfiles = new FileProcessor(this) {\n\t\t\t\tprotected void processDir (Entry entryDir, ArrayList<Entry> files) {\n\t\t\t\t\tignoreDirs.add(entryDir.inputFile);\n\t\t\t\t}\n\n\t\t\t\tprotected void processFile (Entry entry) {\n\t\t\t\t\taddProcessedFile(entry);\n\t\t\t\t}\n\t\t\t}.process(inputDir.inputFile, null);\n\t\t}\n\n\t\tif (files.isEmpty()) return;\n\n\t\t// Sort by name using numeric suffix, then alpha.\n\t\tCollections.sort(files, new Comparator<Entry>() {\n\t\t\tfinal Pattern digitSuffix = Pattern.compile(\"(.*?)(\\\\d+)$\");\n\n\t\t\tpublic int compare (Entry entry1, Entry entry2) {\n\t\t\t\tString full1 = entry1.inputFile.getName();\n\t\t\t\tint dotIndex = full1.lastIndexOf('.');\n\t\t\t\tif (dotIndex != -1) full1 = full1.substring(0, dotIndex);\n\n\t\t\t\tString full2 = entry2.inputFile.getName();\n\t\t\t\tdotIndex = full2.lastIndexOf('.');\n\t\t\t\tif (dotIndex != -1) full2 = full2.substring(0, dotIndex);\n\n\t\t\t\tString name1 = full1, name2 = full2;\n\t\t\t\tint num1 = 0, num2 = 0;\n\n\t\t\t\tMatcher matcher = digitSuffix.matcher(full1);\n\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnum1 = Integer.parseInt(matcher.group(2));\n\t\t\t\t\t\tname1 = matcher.group(1);\n\t\t\t\t\t} catch (Exception ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatcher = digitSuffix.matcher(full2);\n\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnum2 = Integer.parseInt(matcher.group(2));\n\t\t\t\t\t\tname2 = matcher.group(1);\n\t\t\t\t\t} catch (Exception ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint compare = name1.compareTo(name2);\n\t\t\t\tif (compare != 0 || num1 == num2) return compare;\n\t\t\t\treturn num1 - num2;\n\t\t\t}\n\t\t});\n\n\t\t// Pack.\n\t\tif (!settings.silent) System.out.println(inputDir.inputFile.getName());\n\t\tTexturePacker packer = new TexturePacker(root, settings);\n\t\tfor (Entry file : files)\n\t\t\tpacker.addImage(file.inputFile);\n\t\tpacker.pack(inputDir.outputDir, packFileName);\n\t}","id":77442,"modified_method":"protected void processDir (Entry inputDir, ArrayList<Entry> files) throws Exception {\n\t\tif (ignoreDirs.contains(inputDir.inputFile)) return;\n\n\t\t// Find first parent with settings, or use defaults.\n\t\tSettings settings = null;\n\t\tFile parent = inputDir.inputFile;\n\t\twhile (true) {\n\t\t\tsettings = dirToSettings.get(parent);\n\t\t\tif (settings != null) break;\n\t\t\tif (parent == null || parent.equals(root)) break;\n\t\t\tparent = parent.getParentFile();\n\t\t}\n\t\tif (settings == null) settings = defaultSettings;\n\n\t\tif (settings.ignore) return;\n\n\t\tif (settings.combineSubdirectories) {\n\t\t\t// Collect all files under subdirectories and ignore subdirectories so they won't be packed twice.\n\t\t\tfiles = new FileProcessor(this) {\n\t\t\t\tprotected void processDir (Entry entryDir, ArrayList<Entry> files) {\n\t\t\t\t\tignoreDirs.add(entryDir.inputFile);\n\t\t\t\t}\n\n\t\t\t\tprotected void processFile (Entry entry) {\n\t\t\t\t\taddProcessedFile(entry);\n\t\t\t\t}\n\t\t\t}.process(inputDir.inputFile, null);\n\t\t}\n\n\t\tif (files.isEmpty()) return;\n\n\t\t// Sort by name using numeric suffix, then alpha.\n\t\tCollections.sort(files, new Comparator<Entry>() {\n\t\t\tfinal Pattern digitSuffix = Pattern.compile(\"(.*?)(\\\\d+)$\");\n\n\t\t\tpublic int compare (Entry entry1, Entry entry2) {\n\t\t\t\tString full1 = entry1.inputFile.getName();\n\t\t\t\tint dotIndex = full1.lastIndexOf('.');\n\t\t\t\tif (dotIndex != -1) full1 = full1.substring(0, dotIndex);\n\n\t\t\t\tString full2 = entry2.inputFile.getName();\n\t\t\t\tdotIndex = full2.lastIndexOf('.');\n\t\t\t\tif (dotIndex != -1) full2 = full2.substring(0, dotIndex);\n\n\t\t\t\tString name1 = full1, name2 = full2;\n\t\t\t\tint num1 = 0, num2 = 0;\n\n\t\t\t\tMatcher matcher = digitSuffix.matcher(full1);\n\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnum1 = Integer.parseInt(matcher.group(2));\n\t\t\t\t\t\tname1 = matcher.group(1);\n\t\t\t\t\t} catch (Exception ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatcher = digitSuffix.matcher(full2);\n\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnum2 = Integer.parseInt(matcher.group(2));\n\t\t\t\t\t\tname2 = matcher.group(1);\n\t\t\t\t\t} catch (Exception ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint compare = name1.compareTo(name2);\n\t\t\t\tif (compare != 0 || num1 == num2) return compare;\n\t\t\t\treturn num1 - num2;\n\t\t\t}\n\t\t});\n\n\t\t// Pack.\n\t\tif (!settings.silent) System.out.println(inputDir.inputFile.getName());\n\t\tTexturePacker packer = new TexturePacker(root, settings);\n\t\tfor (Entry file : files)\n\t\t\tpacker.addImage(file.inputFile);\n\t\tpacker.pack(inputDir.outputDir, packFileName);\n\t}","commit_id":"624839715239b823ba1ae0293128d52c4f531344","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n    public CandidateSet drawCandidates(CandidateSet set) throws IOException {\n        Candidate original = set.originalTerm;\n        BytesRef term = preFilter(original.term, spare, byteSpare);\n        final long frequency = original.frequency;\n        spellchecker.setThresholdFrequency(thresholdFrequency(frequency, dictSize));\n        SuggestWord[] suggestSimilar = spellchecker.suggestSimilar(new Term(field, term), numCandidates, reader, this.suggestMode);\n        List<Candidate> candidates = new ArrayList<Candidate>(suggestSimilar.length);\n        for (int i = 0; i < suggestSimilar.length; i++) {\n            SuggestWord suggestWord = suggestSimilar[i];\n            BytesRef candidate = new BytesRef(suggestWord.string);\n            postFilter(new Candidate(candidate, internalFrequency(candidate), suggestWord.score, score(suggestWord.freq, suggestWord.score, dictSize)), spare, byteSpare, candidates);\n        }\n        set.addCandidates(candidates);\n        return set;\n    }","id":77443,"modified_method":"@Override\n    public CandidateSet drawCandidates(CandidateSet set) throws IOException {\n        Candidate original = set.originalTerm;\n        BytesRef term = preFilter(original.term, spare, byteSpare);\n        final long frequency = original.frequency;\n        spellchecker.setThresholdFrequency(this.suggestMode == SuggestMode.SUGGEST_ALWAYS ? 0 : thresholdFrequency(frequency, dictSize));\n        SuggestWord[] suggestSimilar = spellchecker.suggestSimilar(new Term(field, term), numCandidates, reader, this.suggestMode);\n        List<Candidate> candidates = new ArrayList<Candidate>(suggestSimilar.length);\n        for (int i = 0; i < suggestSimilar.length; i++) {\n            SuggestWord suggestWord = suggestSimilar[i];\n            BytesRef candidate = new BytesRef(suggestWord.string);\n            postFilter(new Candidate(candidate, internalFrequency(candidate), suggestWord.score, score(suggestWord.freq, suggestWord.score, dictSize)), spare, byteSpare, candidates);\n        }\n        set.addCandidates(candidates);\n        return set;\n    }","commit_id":"8235b89e9cd4f222ee689d47ca2ef4686b7a6971","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected long thresholdFrequency(long termFrequency, long dictionarySize) {\n        if (termFrequency > 0) {\n            return (long) Math.round(termFrequency * (Math.log10(termFrequency - frequencyPlateau) * (1.0 / Math.log10(logBase))) + 1);\n        }\n        return 0;\n        \n    }","id":77444,"modified_method":"protected long thresholdFrequency(long termFrequency, long dictionarySize) {\n        if (termFrequency > 0) {\n            return (long) Math.max(0, Math.round(termFrequency * (Math.log10(termFrequency - frequencyPlateau) * (1.0 / Math.log10(logBase))) + 1));\n        }\n        return 0;\n        \n    }","commit_id":"8235b89e9cd4f222ee689d47ca2ef4686b7a6971","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        // define visible variables\r\n        prop.put(\"proxyPrefetchDepth\", env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n        prop.put(\"crawlingDepth\", env.getConfig(\"crawlingDepth\", \"0\"));\r\n        prop.put(\"crawlingFilter\", env.getConfig(\"crawlingFilter\", \"0\"));\r\n        \r\n        int crawlingIfOlder = (int) env.getConfigLong(\"crawlingIfOlder\", -1);\r\n        prop.put(\"crawlingIfOlderCheck\", (crawlingIfOlder == -1) ? \"0\" : \"1\");\r\n        prop.put(\"crawlingIfOlderUnitYearCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitMonthCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitDayCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitHourCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitMinuteCheck\", \"0\");\r\n        if ((crawlingIfOlder == -1) || (crawlingIfOlder == Integer.MAX_VALUE)) {\r\n            prop.put(\"crawlingIfOlderNumber\", \"1\");\r\n            prop.put(\"crawlingIfOlderUnitYearCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60*24*365) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round((float)crawlingIfOlder / (float)(60*24*365)));\r\n            prop.put(\"crawlingIfOlderUnitYearCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60*24*30) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round((float)crawlingIfOlder / (float)(60*24*30)));\r\n            prop.put(\"crawlingIfOlderUnitMonthCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60*24) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round((float)crawlingIfOlder / (float)(60*24)));\r\n            prop.put(\"crawlingIfOlderUnitDayCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round(crawlingIfOlder / 60f));\r\n            prop.put(\"crawlingIfOlderUnitHourCheck\", \"1\");\r\n        } else {\r\n            prop.put(\"crawlingIfOlderNumber\", crawlingIfOlder);\r\n            prop.put(\"crawlingIfOlderUnitMinuteCheck\", \"1\");\r\n        }\r\n        int crawlingDomFilterDepth = (int) env.getConfigLong(\"crawlingDomFilterDepth\", -1);\r\n        prop.put(\"crawlingDomFilterCheck\", (crawlingDomFilterDepth == -1) ? \"0\" : \"1\");\r\n        prop.put(\"crawlingDomFilterDepth\", (crawlingDomFilterDepth == -1) ? 1 : crawlingDomFilterDepth);\r\n        int crawlingDomMaxPages = (int) env.getConfigLong(\"crawlingDomMaxPages\", -1);\r\n        prop.put(\"crawlingDomMaxCheck\", (crawlingDomMaxPages == -1) ? \"0\" : \"1\");\r\n        prop.put(\"crawlingDomMaxPages\", (crawlingDomMaxPages == -1) ? 10000 : crawlingDomMaxPages);\r\n        prop.put(\"crawlingQChecked\", env.getConfig(\"crawlingQ\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"storeHTCacheChecked\", env.getConfig(\"storeHTCache\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"indexingTextChecked\", env.getConfig(\"indexText\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"indexingMediaChecked\", env.getConfig(\"indexMedia\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"crawlOrderChecked\", env.getConfig(\"crawlOrder\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        \r\n        long LCbusySleep = Integer.parseInt(env.getConfig(plasmaSwitchboard.CRAWLJOB_LOCAL_CRAWL_BUSYSLEEP, \"100\"));\r\n        int LCppm = (LCbusySleep == 0) ? 1000 : (int) (60000L / LCbusySleep);\r\n        prop.put(\"crawlingSpeedMaxChecked\", (LCppm >= 1000) ? \"1\" : \"0\");\r\n        prop.put(\"crawlingSpeedCustChecked\", ((LCppm > 10) && (LCppm < 1000)) ? \"1\" : \"0\");\r\n        prop.put(\"crawlingSpeedMinChecked\", (LCppm <= 10) ? \"1\" : \"0\");\r\n        prop.put(\"customPPMdefault\", ((LCppm > 10) && (LCppm < 1000)) ? Integer.toString(LCppm) : \"\");\r\n        \r\n        prop.put(\"xsstopwChecked\", env.getConfig(\"xsstopw\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"xdstopwChecked\", env.getConfig(\"xdstopw\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"xpstopwChecked\", env.getConfig(\"xpstopw\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":77445,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        // return variable that accumulates replacements\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        // define visible variables\r\n        prop.put(\"proxyPrefetchDepth\", env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n        prop.put(\"crawlingDepth\", env.getConfig(\"crawlingDepth\", \"0\"));\r\n        prop.put(\"crawlingFilter\", env.getConfig(\"crawlingFilter\", \"0\"));\r\n        \r\n        int crawlingIfOlder = (int) env.getConfigLong(\"crawlingIfOlder\", -1);\r\n        prop.put(\"crawlingIfOlderCheck\", (crawlingIfOlder == -1) ? \"0\" : \"1\");\r\n        prop.put(\"crawlingIfOlderUnitYearCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitMonthCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitDayCheck\", \"0\");\r\n        prop.put(\"crawlingIfOlderUnitHourCheck\", \"0\");\r\n        if ((crawlingIfOlder == -1) || (crawlingIfOlder == Integer.MAX_VALUE)) {\r\n            prop.put(\"crawlingIfOlderNumber\", \"1\");\r\n            prop.put(\"crawlingIfOlderUnitYearCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60*24*365) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round((float)crawlingIfOlder / (float)(60*24*365)));\r\n            prop.put(\"crawlingIfOlderUnitYearCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60*24*30) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round((float)crawlingIfOlder / (float)(60*24*30)));\r\n            prop.put(\"crawlingIfOlderUnitMonthCheck\", \"1\");\r\n        } else if (crawlingIfOlder >= 60*24) {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.round((float)crawlingIfOlder / (float)(60*24)));\r\n            prop.put(\"crawlingIfOlderUnitDayCheck\", \"1\");\r\n        } else {\r\n            prop.put(\"crawlingIfOlderNumber\", Math.max(1, Math.round(crawlingIfOlder / 60f)));\r\n            prop.put(\"crawlingIfOlderUnitHourCheck\", \"1\");\r\n        }\r\n        int crawlingDomFilterDepth = (int) env.getConfigLong(\"crawlingDomFilterDepth\", -1);\r\n        prop.put(\"crawlingDomFilterCheck\", (crawlingDomFilterDepth == -1) ? \"0\" : \"1\");\r\n        prop.put(\"crawlingDomFilterDepth\", (crawlingDomFilterDepth == -1) ? 1 : crawlingDomFilterDepth);\r\n        int crawlingDomMaxPages = (int) env.getConfigLong(\"crawlingDomMaxPages\", -1);\r\n        prop.put(\"crawlingDomMaxCheck\", (crawlingDomMaxPages == -1) ? \"0\" : \"1\");\r\n        prop.put(\"crawlingDomMaxPages\", (crawlingDomMaxPages == -1) ? 10000 : crawlingDomMaxPages);\r\n        prop.put(\"crawlingQChecked\", env.getConfig(\"crawlingQ\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"storeHTCacheChecked\", env.getConfig(\"storeHTCache\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"indexingTextChecked\", env.getConfig(\"indexText\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"indexingMediaChecked\", env.getConfig(\"indexMedia\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"crawlOrderChecked\", env.getConfig(\"crawlOrder\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        \r\n        long LCbusySleep = Integer.parseInt(env.getConfig(plasmaSwitchboard.CRAWLJOB_LOCAL_CRAWL_BUSYSLEEP, \"100\"));\r\n        int LCppm = (LCbusySleep == 0) ? 1000 : (int) (60000L / LCbusySleep);\r\n        prop.put(\"crawlingSpeedMaxChecked\", (LCppm >= 1000) ? \"1\" : \"0\");\r\n        prop.put(\"crawlingSpeedCustChecked\", ((LCppm > 10) && (LCppm < 1000)) ? \"1\" : \"0\");\r\n        prop.put(\"crawlingSpeedMinChecked\", (LCppm <= 10) ? \"1\" : \"0\");\r\n        prop.put(\"customPPMdefault\", ((LCppm > 10) && (LCppm < 1000)) ? Integer.toString(LCppm) : \"\");\r\n        \r\n        prop.put(\"xsstopwChecked\", env.getConfig(\"xsstopw\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"xdstopwChecked\", env.getConfig(\"xdstopw\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        prop.put(\"xpstopwChecked\", env.getConfig(\"xpstopw\", \"\").equals(\"true\") ? \"1\" : \"0\");\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"8e179f6588a0ffc723c22372185287b947d29254","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static int recrawlIfOlderC(boolean recrawlIfOlderCheck, int recrawlIfOlderNumber, String crawlingIfOlderUnit) {\n        if (!recrawlIfOlderCheck) return -1;\n        if (crawlingIfOlderUnit.equals(\"year\")) return recrawlIfOlderNumber * 60 * 24 * 365;\n        if (crawlingIfOlderUnit.equals(\"month\")) return recrawlIfOlderNumber * 60 * 24 * 30;\n        if (crawlingIfOlderUnit.equals(\"day\")) return recrawlIfOlderNumber * 60 * 24;\n        if (crawlingIfOlderUnit.equals(\"hour\")) return recrawlIfOlderNumber * 60;\n        if (crawlingIfOlderUnit.equals(\"minute\")) return recrawlIfOlderNumber;\n        return -1;\n    }","id":77446,"modified_method":"private static int recrawlIfOlderC(boolean recrawlIfOlderCheck, int recrawlIfOlderNumber, String crawlingIfOlderUnit) {\n        if (!recrawlIfOlderCheck) return -1;\n        if (crawlingIfOlderUnit.equals(\"year\")) return recrawlIfOlderNumber * 60 * 24 * 365;\n        if (crawlingIfOlderUnit.equals(\"month\")) return recrawlIfOlderNumber * 60 * 24 * 30;\n        if (crawlingIfOlderUnit.equals(\"day\")) return recrawlIfOlderNumber * 60 * 24;\n        if (crawlingIfOlderUnit.equals(\"hour\")) return recrawlIfOlderNumber * 60;\n        return recrawlIfOlderNumber;\n    }","commit_id":"8e179f6588a0ffc723c22372185287b947d29254","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n  public void draw(Graphics2D g2, GraphPrintCell row) {\n    this.g2 = g2;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    for (ShortEdge edge : row.getUpEdges()) {\n      if (edge.isMarked()) {\n        setStroke(edge.isUsual(), true);\n        paintUpLine(edge.getDownPosition(), edge.getUpPosition(), markColor);\n      }\n      setStroke(edge.isUsual(), edge.isSelected());\n      paintUpLine(edge.getDownPosition(), edge.getUpPosition(), ColorGenerator.getColor(edge.getEdge().getBranch()));\n    }\n    for (ShortEdge edge : row.getDownEdges()) {\n      if (edge.isMarked()) {\n        setStroke(edge.isUsual(), true);\n        paintDownLine(edge.getUpPosition(), edge.getDownPosition(), markColor);\n      }\n      setStroke(edge.isUsual(), edge.isSelected());\n      paintDownLine(edge.getUpPosition(), edge.getDownPosition(), ColorGenerator.getColor(edge.getEdge().getBranch()));\n    }\n    for (SpecialPrintElement printElement : row.getSpecialPrintElements()) {\n      Edge edge;\n      switch (printElement.getType()) {\n        case COMMIT_NODE:\n          Node node = printElement.getGraphElement().getNode();\n          assert node != null;\n          if (printElement.isMarked()) {\n            paintCircle(printElement.getPosition(), markColor, true);\n          }\n          paintCircle(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()), printElement.isSelected());\n          break;\n        case UP_ARROW:\n          edge = printElement.getGraphElement().getEdge();\n          assert edge != null;\n          if (printElement.isMarked()) {\n            setStroke(edge.getType() == Edge.EdgeType.USUAL, true);\n            paintShow(printElement.getPosition(), markColor);\n          }\n          setStroke(edge.getType() == Edge.EdgeType.USUAL, printElement.isSelected());\n          paintShow(printElement.getPosition(), ColorGenerator.getColor(edge.getBranch()));\n          break;\n        case DOWN_ARROW:\n          edge = printElement.getGraphElement().getEdge();\n          assert edge != null;\n          if (printElement.isMarked()) {\n            setStroke(edge.getType() == Edge.EdgeType.USUAL, true);\n            paintHide(printElement.getPosition(), markColor);\n          }\n          setStroke(edge.getType() == Edge.EdgeType.USUAL, printElement.isSelected());\n          paintHide(printElement.getPosition(), ColorGenerator.getColor(edge.getBranch()));\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n\n  }","id":77447,"modified_method":"@Override\n  public void draw(Graphics2D g2, GraphPrintCell row) {\n    this.g2 = g2;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    for (final ShortEdge edge : row.getUpEdges()) {\n      drawLogick(edge.isSelected(), edge.isMarked(), edge.isUsual(), ColorGenerator.getColor(edge.getEdge().getBranch()),\n                 new LitePrinter() {\n                   @Override\n                   public void print(Color color) {\n                     paintUpLine(edge.getDownPosition(), edge.getUpPosition(), color);\n                   }\n                 });\n    }\n    for (final ShortEdge edge : row.getDownEdges()) {\n      drawLogick(edge.isSelected(), edge.isMarked(), edge.isUsual(), ColorGenerator.getColor(edge.getEdge().getBranch()),\n                 new LitePrinter() {\n                   @Override\n                   public void print(Color color) {\n                     paintDownLine(edge.getUpPosition(), edge.getDownPosition(), color);\n                   }\n                 });\n\n    }\n    for (final SpecialPrintElement printElement : row.getSpecialPrintElements()) {\n      final Edge edge;\n      switch (printElement.getType()) {\n        case COMMIT_NODE:\n          Node node = printElement.getGraphElement().getNode();\n          assert node != null;\n          if (printElement.isSelected()) {\n            paintCircle(printElement.getPosition(), markColor, true);\n            paintCircle(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()), false);\n          } else {\n            paintCircle(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()), printElement.isMarked());\n          }\n          break;\n        case UP_ARROW:\n          edge = printElement.getGraphElement().getEdge();\n          assert edge != null;\n          drawLogick(printElement.isSelected(), printElement.isMarked(), edge.getType() == Edge.EdgeType.USUAL,\n                     ColorGenerator.getColor(edge.getBranch()),\n                     new LitePrinter() {\n                       @Override\n                       public void print(Color color) {\n                         paintShow(printElement.getPosition(), color);\n                       }\n                     });\n          break;\n        case DOWN_ARROW:\n          edge = printElement.getGraphElement().getEdge();\n          assert edge != null;\n          drawLogick(printElement.isSelected(), printElement.isMarked(), edge.getType() == Edge.EdgeType.USUAL,\n                     ColorGenerator.getColor(edge.getBranch()),\n                     new LitePrinter() {\n                       @Override\n                       public void print(Color color) {\n                         paintHide(printElement.getPosition(), color);\n                       }\n                     });\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n\n  }","commit_id":"e38a2b87bed9c41ed845a865cfb30ec4a6f2d5bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Node getNode(@Nullable GraphPrintCell cell) {\n    if (cell == null) {\n      return null;\n    }\n    for (SpecialPrintElement element : cell.getSpecialPrintElements()) {\n      Node node = element.getGraphElement().getNode();\n      if (node != null) {\n        return node;\n      }\n    }\n    return null;\n  }","id":77448,"modified_method":"@Nullable\n  public static Node getNode(@Nullable GraphCell cell) {\n    if (cell == null) {\n      return null;\n    }\n    for (SpecialRowElement element : cell.getSpecialRowElements()) {\n      GraphElement graphElement = element.getElement();\n      if (graphElement instanceof Node) {\n        return (Node) graphElement;\n      }\n    }\n    return null;\n  }","commit_id":"dfc41b03ebd848f0bddffea1e46e273e43af14c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public SpecialPrintElement mouseOverArrow(@NotNull GraphPrintCell row, int x, int y) {\n    for (SpecialPrintElement printElement : row.getSpecialPrintElements()) {\n      if (printElement.getType() != SpecialPrintElement.Type.COMMIT_NODE) {\n        if (PositionUtil.overNode(printElement.getPosition(), x, y)) {\n          return printElement;\n        }\n      }\n    }\n    return null;\n  }","id":77449,"modified_method":"@Nullable\n  @Override\n  public SpecialRowElement mouseOverArrow(@NotNull GraphCell graphCell, int x, int y) {\n    for (SpecialRowElement rowElement : graphCell.getSpecialRowElements()) {\n      if (rowElement.getType() != SpecialRowElement.Type.NODE) {\n        if (PositionUtil.overNode(rowElement.getPosition(), x, y)) {\n          return rowElement;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"dfc41b03ebd848f0bddffea1e46e273e43af14c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public GraphElement mouseOver(@NotNull GraphPrintCell row, int x, int y) {\n    for (SpecialPrintElement printElement : row.getSpecialPrintElements()) {\n      if (printElement.getType() == SpecialPrintElement.Type.COMMIT_NODE) {\n        if (PositionUtil.overNode(printElement.getPosition(), x, y)) {\n          return printElement.getGraphElement();\n        }\n      }\n    }\n    for (ShortEdge edge : row.getUpEdges()) {\n      if (PositionUtil.overUpEdge(edge, x, y)) {\n        return edge.getEdge();\n      }\n    }\n    for (ShortEdge edge : row.getDownEdges()) {\n      if (PositionUtil.overDownEdge(edge, x, y)) {\n        return edge.getEdge();\n      }\n    }\n\n    return null;\n  }","id":77450,"modified_method":"@Nullable\n  @Override\n  public GraphElement mouseOver(@NotNull GraphCell graphCell, int x, int y) {\n    for (SpecialRowElement printElement : graphCell.getSpecialRowElements()) {\n      if (printElement.getType() == SpecialRowElement.Type.NODE) {\n        if (PositionUtil.overNode(printElement.getPosition(), x, y)) {\n          return printElement.getElement();\n        }\n      }\n    }\n    for (ShortEdge edge : graphCell.getUpEdges()) {\n      if (PositionUtil.overUpEdge(edge, x, y)) {\n        return edge.getEdge();\n      }\n    }\n    for (ShortEdge edge : graphCell.getDownEdges()) {\n      if (PositionUtil.overDownEdge(edge, x, y)) {\n        return edge.getEdge();\n      }\n    }\n\n    return null;\n  }","commit_id":"dfc41b03ebd848f0bddffea1e46e273e43af14c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintUpLine(int from, int to, Color color) {\n    int x1 = PrintParameters.WIDTH_NODE * from + PrintParameters.WIDTH_NODE / 2;\n    int y1 = PrintParameters.HEIGHT_CELL / 2;\n    int x2 = PrintParameters.WIDTH_NODE * to + PrintParameters.WIDTH_NODE / 2;\n    int y2 = -PrintParameters.HEIGHT_CELL / 2;\n    g2.setColor(color);\n    g2.drawLine(x2, y2, x1, y1);\n  }","id":77451,"modified_method":"public SimpleGraphCellPainter(ThickHoverController thickHoverController) {\n    myThickHoverController = thickHoverController;\n  }","commit_id":"dfc41b03ebd848f0bddffea1e46e273e43af14c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void draw(@NotNull Graphics2D g2, @NotNull GraphCell row) {\n    this.g2 = g2;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    for (final ShortEdge edge : row.getUpEdges()) {\n      drawLogic(edge.isSelected(), edge.isMarked(), edge.isUsual(), ColorGenerator.getColor(edge.getEdge().getBranch()), new LitePrinter() {\n        @Override\n        public void print(Color color) {\n          paintUpLine(edge.getDownPosition(), edge.getUpPosition(), color);\n        }\n      });\n    }\n    for (final ShortEdge edge : row.getDownEdges()) {\n      drawLogic(edge.isSelected(), edge.isMarked(), edge.isUsual(), ColorGenerator.getColor(edge.getEdge().getBranch()), new LitePrinter() {\n        @Override\n        public void print(Color color) {\n          paintDownLine(edge.getUpPosition(), edge.getDownPosition(), color);\n        }\n      });\n\n    }\n    for (final SpecialPrintElement printElement : row.getSpecialPrintElements()) {\n      final Edge edge;\n      switch (printElement.getType()) {\n        case COMMIT_NODE:\n          Node node = printElement.getGraphElement().getNode();\n          assert node != null;\n          if (printElement.isSelected()) {\n            paintCircle(printElement.getPosition(), MARK_COLOR, true);\n            paintCircle(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()), false);\n          } else {\n            paintCircle(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()), printElement.isMarked());\n          }\n          break;\n        case UP_ARROW:\n          edge = printElement.getGraphElement().getEdge();\n          assert edge != null;\n          drawLogic(printElement.isSelected(), printElement.isMarked(), edge.getType() == Edge.EdgeType.USUAL, ColorGenerator.getColor(\n            edge.getBranch()), new LitePrinter() {\n            @Override\n            public void print(Color color) {\n              paintShow(printElement.getPosition(), color);\n            }\n          });\n          break;\n        case DOWN_ARROW:\n          edge = printElement.getGraphElement().getEdge();\n          assert edge != null;\n          drawLogic(printElement.isSelected(), printElement.isMarked(), edge.getType() == Edge.EdgeType.USUAL, ColorGenerator.getColor(\n            edge.getBranch()), new LitePrinter() {\n            @Override\n            public void print(Color color) {\n              paintHide(printElement.getPosition(), color);\n            }\n          });\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n\n    for (final SpecialPrintElement printElement : row.getSpecialPrintElements()) {\n      if (printElement.getType() == SpecialPrintElement.Type.COMMIT_NODE && printElement.getDragAndDropSelect() != 0) {\n        Node node = printElement.getGraphElement().getNode();\n        assert node != null;\n        if (printElement.getDragAndDropSelect() > 0) {\n          paintAbove(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()));\n        } else {\n          paintBelow(printElement.getPosition(), ColorGenerator.getColor(node.getBranch()));\n        }\n      }\n    }\n  }","id":77452,"modified_method":"@Override\n  public void draw(@NotNull Graphics2D g2, @NotNull GraphCell row) {\n    this.g2 = g2;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    for (final ShortEdge shortEdge : row.getUpEdges()) {\n      Edge edge = shortEdge.getEdge();\n      drawLogic(isSelected(edge), isMarked(edge), isUsual(edge), ColorGenerator.getColor(edge), new LitePrinter() {\n        @Override\n        public void print(Color color) {\n          paintUpLine(shortEdge.getDownPosition(), shortEdge.getUpPosition(), color);\n        }\n      });\n    }\n    for (final ShortEdge shortEdge : row.getDownEdges()) {\n      Edge edge = shortEdge.getEdge();\n      drawLogic(isSelected(edge), isMarked(edge), isUsual(edge), ColorGenerator.getColor(edge), new LitePrinter() {\n        @Override\n        public void print(Color color) {\n          paintDownLine(shortEdge.getUpPosition(), shortEdge.getDownPosition(), color);\n        }\n      });\n\n    }\n    for (final SpecialRowElement rowElement : row.getSpecialRowElements()) {\n      GraphElement element = rowElement.getElement();\n      final Edge edge;\n      switch (rowElement.getType()) {\n        case NODE:\n          assert element instanceof Node;\n          Node node = (Node) element;\n          if (isSelected(node)) {\n            paintCircle(rowElement.getPosition(), MARK_COLOR, true);\n            paintCircle(rowElement.getPosition(), ColorGenerator.getColor(node), false);\n          } else {\n            paintCircle(rowElement.getPosition(), ColorGenerator.getColor(node), isMarked(node));\n          }\n          break;\n        case UP_ARROW:\n          assert element instanceof Edge;\n          edge = (Edge) element;\n          drawLogic(isSelected(edge), isMarked(edge), isUsual(edge), ColorGenerator.getColor(edge), new LitePrinter() {\n            @Override\n            public void print(Color color) {\n              paintShow(rowElement.getPosition(), color);\n            }\n          });\n          break;\n        case DOWN_ARROW:\n          assert element instanceof Edge;\n          edge = (Edge) element;\n          drawLogic(isSelected(edge), isMarked(edge), isUsual(edge), ColorGenerator.getColor(edge), new LitePrinter() {\n            @Override\n            public void print(Color color) {\n              paintHide(rowElement.getPosition(), color);\n            }\n          });\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n\n  }","commit_id":"dfc41b03ebd848f0bddffea1e46e273e43af14c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void getIp(NicProfile nic, DataCenter dc, VirtualMachineProfile<? extends VirtualMachine> vm, Network network) throws InsufficientVirtualNetworkCapcityException, InsufficientAddressCapacityException, ConcurrentOperationException {\n        if (nic.getIp4Address() == null) {\n            PublicIp ip = _networkMgr.assignPublicIpAddress(dc.getId(), vm.getOwner(), dc.getNetworkType().equals(NetworkType.Basic) ?  VlanType.DirectAttached : VlanType.VirtualNetwork, null);\n            nic.setIp4Address(ip.getAddress());\n            nic.setGateway(ip.getGateway());\n            nic.setNetmask(ip.getNetmask());\n            if(ip.getVlanTag().equalsIgnoreCase(\"untagged\"))\n            \tnic.setIsolationUri(URI.create(\"vlan://untagged\"));\n            else\t\n            \tnic.setIsolationUri(IsolationType.Vlan.toUri(ip.getVlanTag()));\n            nic.setBroadcastType(BroadcastDomainType.Vlan);\n            if(!ip.getVlanTag().equalsIgnoreCase(\"untagged\"))\n            \tnic.setBroadcastUri(URI.create(\"vlan://untagged\"));\n            else\n            \tnic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(ip.getVlanTag()));\n            nic.setFormat(AddressFormat.Ip4);\n            nic.setReservationId(String.valueOf(ip.getVlanTag()));\n            nic.setMacAddress(ip.getMacAddress());\n        }\n        nic.setDns1(dc.getDns1());\n        nic.setDns2(dc.getDns2());\n    }","id":77453,"modified_method":"protected void getIp(NicProfile nic, DataCenter dc, VirtualMachineProfile<? extends VirtualMachine> vm, Network network) throws InsufficientVirtualNetworkCapcityException, InsufficientAddressCapacityException, ConcurrentOperationException {\n        if (nic.getIp4Address() == null) {\n            PublicIp ip = _networkMgr.assignPublicIpAddress(dc.getId(), vm.getOwner(), dc.getNetworkType().equals(NetworkType.Basic) ?  VlanType.DirectAttached : VlanType.VirtualNetwork, null);\n            nic.setIp4Address(ip.getAddress());\n            nic.setGateway(ip.getGateway());\n            nic.setNetmask(ip.getNetmask());\n            if(ip.getVlanTag() != null && ip.getVlanTag().equalsIgnoreCase(\"untagged\")) {\n                nic.setIsolationUri(URI.create(\"vlan://untagged\"));\n                nic.setBroadcastUri(URI.create(\"vlan://untagged\"));\n                nic.setBroadcastType(BroadcastDomainType.Native);\n            } else if (ip.getVlanTag() != null){\n                nic.setIsolationUri(IsolationType.Vlan.toUri(ip.getVlanTag()));\n                nic.setBroadcastUri(IsolationType.Vlan.toUri(ip.getVlanTag()));\n                nic.setBroadcastType(BroadcastDomainType.Vlan);\n            }\n            \t\n            nic.setFormat(AddressFormat.Ip4);\n            nic.setReservationId(String.valueOf(ip.getVlanTag()));\n            nic.setMacAddress(ip.getMacAddress());\n        }\n        nic.setDns1(dc.getDns1());\n        nic.setDns2(dc.getDns2());\n    }","commit_id":"51d1aa2f9578dc078505c65a9d27dd2d78e1cc60","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void shutdown(NetworkProfile profile, NetworkOffering offering) {\n        s_logger.debug(\"Releasing vnet for the network id=\" + profile.getId());\n        _dcDao.releaseVnet(profile.getBroadcastUri().getHost(), profile.getDataCenterId(), profile.getAccountId(), profile.getReservationId());\n        profile.setBroadcastUri(null);\n    }","id":77454,"modified_method":"@Override\n    public void shutdown(NetworkProfile profile, NetworkOffering offering) {\n        s_logger.debug(\"Releasing vnet for the network id=\" + profile.getId());\n        if (profile.getBroadcastUri() != null) {\n            _dcDao.releaseVnet(profile.getBroadcastUri().getHost(), profile.getDataCenterId(), profile.getAccountId(), profile.getReservationId());\n            profile.setBroadcastUri(null);\n        }\n    }","commit_id":"d7ec734b01ab05da905356abbd542d68b5fa0e68","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public NicProfile allocate(Network network, NicProfile nic, VirtualMachineProfile<? extends VirtualMachine> vm) throws InsufficientVirtualNetworkCapcityException,\n            InsufficientAddressCapacityException {\n\n        assert (network.getTrafficType() == TrafficType.Guest) : \"Look at my name!  Why are you calling me when the traffic type is : \" + network.getTrafficType();\n\n        if (nic == null) {\n            nic = new NicProfile(ReservationStrategy.Start, null, null, null, null);\n        }\n\n        DataCenter dc = _dcDao.findById(network.getDataCenterId());\n\n        if (nic.getIp4Address() == null) {\n            nic.setBroadcastUri(network.getBroadcastUri());\n            nic.setIsolationUri(network.getBroadcastUri());\n            nic.setGateway(network.getGateway());\n            nic.setIp4Address(acquireGuestIpAddress(network));\n            nic.setNetmask(NetUtils.cidr2Netmask(network.getCidr()));\n            nic.setFormat(AddressFormat.Ip4);\n\n            nic.setDns1(dc.getDns1());\n            nic.setDns2(dc.getDns2());\n        }\n\n        nic.setStrategy(ReservationStrategy.Start);\n\n        if (nic.getMacAddress() == null) {\n            nic.setMacAddress(_networkMgr.getNextAvailableMacAddressInNetwork(network.getId()));\n            if (nic.getMacAddress() == null) {\n                throw new InsufficientAddressCapacityException(\"Unable to allocate more mac addresses\", Network.class, network.getId());\n            }\n        }\n\n        return nic;\n    }","id":77455,"modified_method":"@Override\n    public NicProfile allocate(Network network, NicProfile nic, VirtualMachineProfile<? extends VirtualMachine> vm) throws InsufficientVirtualNetworkCapcityException,\n            InsufficientAddressCapacityException {\n\n        assert (network.getTrafficType() == TrafficType.Guest) : \"Look at my name!  Why are you calling me when the traffic type is : \" + network.getTrafficType();\n\n        if (nic == null) {\n            nic = new NicProfile(ReservationStrategy.Start, null, null, null, null);\n        }\n\n        DataCenter dc = _dcDao.findById(network.getDataCenterId());\n\n        if (nic.getIp4Address() == null) {\n            nic.setBroadcastUri(network.getBroadcastUri());\n            nic.setIsolationUri(network.getBroadcastUri());\n            nic.setGateway(network.getGateway());\n\n            String guestIp = acquireGuestIpAddress(network);\n            if (guestIp == null) {\n                throw new InsufficientVirtualNetworkCapcityException(\"Unable to acquire guest IP address for network \" + network, DataCenter.class, dc.getId());\n            }\n\n            nic.setIp4Address(guestIp);\n            nic.setNetmask(NetUtils.cidr2Netmask(network.getCidr()));\n            nic.setFormat(AddressFormat.Ip4);\n\n            nic.setDns1(dc.getDns1());\n            nic.setDns2(dc.getDns2());\n        }\n\n        nic.setStrategy(ReservationStrategy.Start);\n\n        if (nic.getMacAddress() == null) {\n            nic.setMacAddress(_networkMgr.getNextAvailableMacAddressInNetwork(network.getId()));\n            if (nic.getMacAddress() == null) {\n                throw new InsufficientAddressCapacityException(\"Unable to allocate more mac addresses\", Network.class, network.getId());\n            }\n        }\n\n        return nic;\n    }","commit_id":"d7ec734b01ab05da905356abbd542d68b5fa0e68","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n   * Retrieve an Annotator from the pool. If the named Annotator has not yet\n   * been requested, it will be created. Otherwise, the existing instance of\n   * the Annotator will be returned.\n   *\n   * @param name The annotator to retrieve from the pool\n   * @return The annotator\n   * @throws IllegalArgumentException If the annotator cannot be created\n   */\n  public synchronized Annotator get(String name) {\n    if (!this.annotators.containsKey(name)) {\n      AnnotatorFactory factory = this.factories.get(name);\n      if (factory == null) {\n        throw new IllegalArgumentException(\"No annotator named \" + name);\n      }\n      this.annotators.put(name, factory.create());\n    }\n    return this.annotators.get(name);\n  }","id":77456,"modified_method":"/**\n   * Retrieve an Annotator from the pool. If the named Annotator has not yet\n   * been requested, it will be created. Otherwise, the existing instance of\n   * the Annotator will be returned.\n   *\n   * @param name The annotator to retrieve from the pool\n   * @return The annotator\n   * @throws IllegalArgumentException If the annotator cannot be created\n   */\n  public synchronized Annotator get(String name) {\n    if (!this.annotators.containsKey(name)) {\n      // Get the factory\n      AnnotatorFactory factory = this.factories.get(name);\n      if (factory == null) {\n        throw new IllegalArgumentException(\"No annotator named \" + name);\n      }\n      Annotator annotator;\n      // Check the cache\n      Pair<String, String> key = Pair.makePair(name, factory.signature());\n      SoftReference<Annotator> value;\n      synchronized (cache) {\n        if ((value = cache.get(key)) != null) {\n          annotator = value.get();\n          if (annotator == null) {\n            annotator = factory.create();\n            cache.put(key, new SoftReference<>(annotator));\n          }\n        } else {\n          annotator = factory.create();\n          cache.put(key, new SoftReference<>(annotator));\n        }\n      }\n      // Register the annotator\n      assert annotator != null;\n      this.annotators.put(name, annotator);\n    }\n\n    // Clean garbage collected annotators from the cache\n    if (lastSweepMillis < System.currentTimeMillis() - (1000 * 60 * 15)) {  // 15 minutes\n      synchronized (cache) {\n        int numRemoved = 0;\n        Iterator<Map.Entry<Pair<String, String>, SoftReference<Annotator>>> iter = cache.entrySet().iterator();\n        while (iter.hasNext()) {\n          if (iter.next().getValue().get() == null) {\n            iter.remove();\n            numRemoved += 1;\n          }\n        }\n        if (numRemoved > 0) {\n          log.info(\"Removed \" + numRemoved + \" evicted annotators from the AnnotatorPool cache\");\n        }\n      }\n      lastSweepMillis = System.currentTimeMillis();\n    }\n\n    // Return\n    return this.annotators.get(name);\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public MentionAnnotator(Properties props) {\n    try {\n      corefProperties = props;\n      //System.out.println(\"corefProperties: \"+corefProperties);\n      dictionaries = new Dictionaries(props);\n      //System.out.println(\"got dictionaries\");\n      headFinder = getHeadFinder(props);\n      //System.out.println(\"got head finder\");\n      md = getMentionFinder(props, headFinder);\n      log.info(\"Using mention detector type: \"+mdName);\n      mentionAnnotatorRequirements.addAll(Arrays.asList(\n          CoreAnnotations.TokensAnnotation.class,\n          CoreAnnotations.SentencesAnnotation.class,\n          CoreAnnotations.PartOfSpeechAnnotation.class,\n          CoreAnnotations.NamedEntityTagAnnotation.class,\n          CoreAnnotations.IndexAnnotation.class,\n          CoreAnnotations.TextAnnotation.class,\n          CoreAnnotations.ValueAnnotation.class,\n          SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class,\n          SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class\n\n      ));\n    } catch (Exception e) {\n      log.info(\"Error with building coref mention annotator!\");\n    }\n  }","id":77457,"modified_method":"public MentionAnnotator(Properties props) {\n    try {\n      corefProperties = props;\n      //System.out.println(\"corefProperties: \"+corefProperties);\n      dictionaries = new Dictionaries(props);\n      //System.out.println(\"got dictionaries\");\n      headFinder = getHeadFinder(props);\n      //System.out.println(\"got head finder\");\n      md = getMentionFinder(props, headFinder);\n      log.info(\"Using mention detector type: \"+mdName);\n      mentionAnnotatorRequirements.addAll(Arrays.asList(\n          CoreAnnotations.TokensAnnotation.class,\n          CoreAnnotations.SentencesAnnotation.class,\n          CoreAnnotations.PartOfSpeechAnnotation.class,\n          CoreAnnotations.NamedEntityTagAnnotation.class,\n          CoreAnnotations.IndexAnnotation.class,\n          CoreAnnotations.TextAnnotation.class,\n          CoreAnnotations.ValueAnnotation.class,\n          SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class,\n          SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class\n\n      ));\n    } catch (Exception e) {\n      log.info(\"Error with building coref mention annotator!\");\n    }\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public StanfordCoreNLP(String propsFileNamePrefix, boolean enforceRequirements) {\n    Properties props = loadProperties(propsFileNamePrefix);\n    if (props == null) {\n      throw new RuntimeIOException(\"ERROR: cannot find properties file \\\"\" + propsFileNamePrefix + \"\\\" in the classpath!\");\n    }\n    construct(props, enforceRequirements, getAnnotatorImplementations());\n  }","id":77458,"modified_method":"public StanfordCoreNLP(String propsFileNamePrefix, boolean enforceRequirements) {\n    Properties props = loadProperties(propsFileNamePrefix);\n    if (props == null) {\n      throw new RuntimeIOException(\"ERROR: cannot find properties file \\\"\" + propsFileNamePrefix + \"\\\" in the classpath!\");\n    }\n    AnnotatorImplementations impl = getAnnotatorImplementations();\n    construct(props, enforceRequirements, impl, getDefaultAnnotatorPool(props, impl));\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Construct the default annotator pool from the passed properties, and overwriting annotations which have changed\n   * since the last\n   * @param inputProps\n   * @param annotatorImplementation\n   * @return A populated AnnotatorPool\n   */\n  public static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps, final AnnotatorImplementations annotatorImplementation) {\n    // if the pool already exists reuse!\n    if (pool == null) {\n      pool = new AnnotatorPool();\n    }\n\n    for (Map.Entry<String, BiFunction<Properties, AnnotatorImplementations, AnnotatorFactory>> entry : getNamedAnnotators().entrySet()) {\n      pool.register(entry.getKey(), entry.getValue().apply(inputProps, annotatorImplementation));\n    }\n\n\n    // add annotators loaded via reflection from class names specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n            property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        logger.info(\"Registering annotator \" + customName + \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(customClassName, inputProps) {\n          private static final long serialVersionUID = 1L;\n          @Override\n          public Annotator create() {\n            return annotatorImplementation.custom(properties, property);\n          }\n          @Override\n          public String additionalSignature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for (String skey : properties.stringPropertyNames()) {\n              os.append(skey).append(':').append(properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n    return pool;\n  }","id":77459,"modified_method":"/**\n   * Construct the default annotator pool, and save it as the static annotator pool\n   * for CoreNLP.\n   *\n   * @see StanfordCoreNLP#constructAnnotatorPool(Properties, AnnotatorImplementations)\n   */\n  public static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps, final AnnotatorImplementations annotatorImplementation) {\n    // if the pool already exists reuse!\n    if (pool == null) {\n      pool = constructAnnotatorPool(inputProps, annotatorImplementation);\n    }\n    return pool;\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public StanfordCoreNLP(Properties props, boolean enforceRequirements)  {\n    construct(props, enforceRequirements, getAnnotatorImplementations());\n  }","id":77460,"modified_method":"public StanfordCoreNLP(Properties props, boolean enforceRequirements)  {\n    AnnotatorImplementations impl = getAnnotatorImplementations();\n    construct(props, enforceRequirements, impl, getDefaultAnnotatorPool(props, impl));\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void construct(Properties props, boolean enforceRequirements, AnnotatorImplementations annotatorImplementations) {\n    Timing tim = new Timing();\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props, annotatorImplementations);\n\n    // Set threading\n    if (this.properties.containsKey(\"threads\")) {\n      ArgumentParser.threads = PropertiesUtils.getInt(this.properties, \"threads\");\n      this.availableProcessors = new Semaphore(ArgumentParser.threads);\n    } else {\n      this.availableProcessors = new Semaphore(1);\n    }\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Class<? extends CoreAnnotation>> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      logger.info(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Class<? extends CoreAnnotation>> allRequirements = an.requires();\n        for (Class<? extends CoreAnnotation> requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotation \\\"%s\\\". The usual requirements for this annotator are: %s\";\n            throw new IllegalArgumentException(\n                String.format(fmt, name, requirement.getSimpleName(),\n                    StringUtils.join(Annotator.DEFAULT_REQUIREMENTS.getOrDefault(name, Collections.singleton(\"unknown\")), \",\")\n                ));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n    this.pipelineSetupTime = tim.report();\n  }","id":77461,"modified_method":"private void construct(Properties props, boolean enforceRequirements, AnnotatorImplementations annotatorImplementations, AnnotatorPool pool) {\n    Timing tim = new Timing();\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n\n    // Set threading\n    if (this.properties.containsKey(\"threads\")) {\n      ArgumentParser.threads = PropertiesUtils.getInt(this.properties, \"threads\");\n      this.availableProcessors = new Semaphore(ArgumentParser.threads);\n    } else {\n      this.availableProcessors = new Semaphore(1);\n    }\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Class<? extends CoreAnnotation>> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      logger.info(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Class<? extends CoreAnnotation>> allRequirements = an.requires();\n        for (Class<? extends CoreAnnotation> requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotation \\\"%s\\\". The usual requirements for this annotator are: %s\";\n            throw new IllegalArgumentException(\n                String.format(fmt, name, requirement.getSimpleName(),\n                    StringUtils.join(Annotator.DEFAULT_REQUIREMENTS.getOrDefault(name, Collections.singleton(\"unknown\")), \",\")\n                ));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n    this.pipelineSetupTime = tim.report();\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Create (or retrieve) a StanfordCoreNLP object corresponding to these properties.\n   * @param props The properties to create the object with.\n   * @return A pipeline parameterized by these properties.\n   */\n  private StanfordCoreNLP mkStanfordCoreNLP(Properties props) {\n    StanfordCoreNLP impl;\n    synchronized (pipelineCache) {\n      impl = pipelineCache.get(props);\n      if (impl == null) {\n        impl = new StanfordCoreNLP(props);\n        pipelineCache.put(props, impl);\n      }\n    }\n    return impl;\n  }","id":77462,"modified_method":"/**\n   * Create (or retrieve) a StanfordCoreNLP object corresponding to these properties.\n   * @param props The properties to create the object with.\n   * @return A pipeline parameterized by these properties.\n   */\n  private StanfordCoreNLP mkStanfordCoreNLP(Properties props) {\n    StanfordCoreNLP impl;\n    synchronized (pipelineCache) {\n      impl = pipelineCache.get(props);\n      if (impl == null) {\n        AnnotatorPool pool = StanfordCoreNLP.constructAnnotatorPool(props, new AnnotatorImplementations());\n        impl = new StanfordCoreNLP(props, pool);\n        pipelineCache.put(props, impl);\n      }\n    }\n    return impl;\n  }","commit_id":"536376e6771b97bf9f0a6f48edfdeff51f76c043","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Retrieve an Annotator from the pool. If the named Annotator has not yet\n   * been requested, it will be created. Otherwise, the existing instance of\n   * the Annotator will be returned.\n   *\n   * @param name The annotator to retrieve from the pool\n   * @return The annotator\n   * @throws IllegalArgumentException If the annotator cannot be created\n   */\n  public synchronized Annotator get(String name) {\n    if (!this.annotators.containsKey(name)) {\n      AnnotatorFactory factory = this.factories.get(name);\n      if (factory == null) {\n        throw new IllegalArgumentException(\"No annotator named \" + name);\n      }\n      this.annotators.put(name, factory.create());\n    }\n    return this.annotators.get(name);\n  }","id":77463,"modified_method":"/**\n   * Retrieve an Annotator from the pool. If the named Annotator has not yet\n   * been requested, it will be created. Otherwise, the existing instance of\n   * the Annotator will be returned.\n   *\n   * @param name The annotator to retrieve from the pool\n   * @return The annotator\n   * @throws IllegalArgumentException If the annotator cannot be created\n   */\n  public synchronized Annotator get(String name) {\n    if (!this.annotators.containsKey(name)) {\n      // Get the factory\n      AnnotatorFactory factory = this.factories.get(name);\n      if (factory == null) {\n        throw new IllegalArgumentException(\"No annotator named \" + name);\n      }\n      Annotator annotator;\n      // Check the cache\n      Pair<String, String> key = Pair.makePair(name, factory.signature());\n      SoftReference<Annotator> value;\n      synchronized (cache) {\n        if ((value = cache.get(key)) != null) {\n          annotator = value.get();\n          if (annotator == null) {\n            annotator = factory.create();\n            cache.put(key, new SoftReference<>(annotator));\n          }\n        } else {\n          annotator = factory.create();\n          cache.put(key, new SoftReference<>(annotator));\n        }\n      }\n      // Register the annotator\n      assert annotator != null;\n      this.annotators.put(name, annotator);\n    }\n\n    // Clean garbage collected annotators from the cache\n    if (lastSweepMillis < System.currentTimeMillis() - (1000 * 60 * 15)) {  // 15 minutes\n      synchronized (cache) {\n        int numRemoved = 0;\n        Iterator<Map.Entry<Pair<String, String>, SoftReference<Annotator>>> iter = cache.entrySet().iterator();\n        while (iter.hasNext()) {\n          if (iter.next().getValue().get() == null) {\n            iter.remove();\n            numRemoved += 1;\n          }\n        }\n        if (numRemoved > 0) {\n          log.info(\"Removed \" + numRemoved + \" evicted annotators from the AnnotatorPool cache\");\n        }\n      }\n      lastSweepMillis = System.currentTimeMillis();\n    }\n\n    // Return\n    return this.annotators.get(name);\n  }","commit_id":"b02f5a2c4ac8f3f257b0921b079631b3bf4f5fd3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public StanfordCoreNLP(Properties props, boolean enforceRequirements)  {\n    construct(props, enforceRequirements, getAnnotatorImplementations());\n  }","id":77464,"modified_method":"public StanfordCoreNLP(Properties props, boolean enforceRequirements)  {\n    AnnotatorImplementations impl = getAnnotatorImplementations();\n    construct(props, enforceRequirements, impl, getDefaultAnnotatorPool(props, impl));\n  }","commit_id":"b02f5a2c4ac8f3f257b0921b079631b3bf4f5fd3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Construct the default annotator pool from the passed properties, and overwriting annotations which have changed\n   * since the last\n   * @param inputProps\n   * @param annotatorImplementation\n   * @return A populated AnnotatorPool\n   */\n  public static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps, final AnnotatorImplementations annotatorImplementation) {\n    // if the pool already exists reuse!\n    if (pool == null) {\n      pool = new AnnotatorPool();\n    }\n\n    for (Map.Entry<String, BiFunction<Properties, AnnotatorImplementations, AnnotatorFactory>> entry : getNamedAnnotators().entrySet()) {\n      pool.register(entry.getKey(), entry.getValue().apply(inputProps, annotatorImplementation));\n    }\n\n\n    // add annotators loaded via reflection from class names specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n            property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        logger.info(\"Registering annotator \" + customName + \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(customClassName, inputProps) {\n          private static final long serialVersionUID = 1L;\n          @Override\n          public Annotator create() {\n            return annotatorImplementation.custom(properties, property);\n          }\n          @Override\n          public String additionalSignature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for (String skey : properties.stringPropertyNames()) {\n              os.append(skey).append(':').append(properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n    return pool;\n  }","id":77465,"modified_method":"/**\n   * Construct the default annotator pool, and save it as the static annotator pool\n   * for CoreNLP.\n   *\n   * @see StanfordCoreNLP#constructAnnotatorPool(Properties, AnnotatorImplementations)\n   */\n  public static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps, final AnnotatorImplementations annotatorImplementation) {\n    // if the pool already exists reuse!\n    if (pool == null) {\n      pool = constructAnnotatorPool(inputProps, annotatorImplementation);\n    }\n    return pool;\n  }","commit_id":"b02f5a2c4ac8f3f257b0921b079631b3bf4f5fd3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public StanfordCoreNLP(String propsFileNamePrefix, boolean enforceRequirements) {\n    Properties props = loadProperties(propsFileNamePrefix);\n    if (props == null) {\n      throw new RuntimeIOException(\"ERROR: cannot find properties file \\\"\" + propsFileNamePrefix + \"\\\" in the classpath!\");\n    }\n    construct(props, enforceRequirements, getAnnotatorImplementations());\n  }","id":77466,"modified_method":"public StanfordCoreNLP(String propsFileNamePrefix, boolean enforceRequirements) {\n    Properties props = loadProperties(propsFileNamePrefix);\n    if (props == null) {\n      throw new RuntimeIOException(\"ERROR: cannot find properties file \\\"\" + propsFileNamePrefix + \"\\\" in the classpath!\");\n    }\n    AnnotatorImplementations impl = getAnnotatorImplementations();\n    construct(props, enforceRequirements, impl, getDefaultAnnotatorPool(props, impl));\n  }","commit_id":"b02f5a2c4ac8f3f257b0921b079631b3bf4f5fd3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void construct(Properties props, boolean enforceRequirements, AnnotatorImplementations annotatorImplementations) {\n    Timing tim = new Timing();\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props, annotatorImplementations);\n\n    // Set threading\n    if (this.properties.containsKey(\"threads\")) {\n      ArgumentParser.threads = PropertiesUtils.getInt(this.properties, \"threads\");\n      this.availableProcessors = new Semaphore(ArgumentParser.threads);\n    } else {\n      this.availableProcessors = new Semaphore(1);\n    }\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Class<? extends CoreAnnotation>> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      logger.info(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Class<? extends CoreAnnotation>> allRequirements = an.requires();\n        for (Class<? extends CoreAnnotation> requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotation \\\"%s\\\". The usual requirements for this annotator are: %s\";\n            throw new IllegalArgumentException(\n                String.format(fmt, name, requirement.getSimpleName(),\n                    StringUtils.join(Annotator.DEFAULT_REQUIREMENTS.getOrDefault(name, Collections.singleton(\"unknown\")), \",\")\n                ));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n    this.pipelineSetupTime = tim.report();\n  }","id":77467,"modified_method":"private void construct(Properties props, boolean enforceRequirements, AnnotatorImplementations annotatorImplementations, AnnotatorPool pool) {\n    Timing tim = new Timing();\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n\n    // Set threading\n    if (this.properties.containsKey(\"threads\")) {\n      ArgumentParser.threads = PropertiesUtils.getInt(this.properties, \"threads\");\n      this.availableProcessors = new Semaphore(ArgumentParser.threads);\n    } else {\n      this.availableProcessors = new Semaphore(1);\n    }\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Class<? extends CoreAnnotation>> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      logger.info(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Class<? extends CoreAnnotation>> allRequirements = an.requires();\n        for (Class<? extends CoreAnnotation> requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotation \\\"%s\\\". The usual requirements for this annotator are: %s\";\n            throw new IllegalArgumentException(\n                String.format(fmt, name, requirement.getSimpleName(),\n                    StringUtils.join(Annotator.DEFAULT_REQUIREMENTS.getOrDefault(name, Collections.singleton(\"unknown\")), \",\")\n                ));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n    this.pipelineSetupTime = tim.report();\n  }","commit_id":"b02f5a2c4ac8f3f257b0921b079631b3bf4f5fd3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Create (or retrieve) a StanfordCoreNLP object corresponding to these properties.\n   * @param props The properties to create the object with.\n   * @return A pipeline parameterized by these properties.\n   */\n  private StanfordCoreNLP mkStanfordCoreNLP(Properties props) {\n    StanfordCoreNLP impl;\n    synchronized (pipelineCache) {\n      impl = pipelineCache.get(props);\n      if (impl == null) {\n        impl = new StanfordCoreNLP(props);\n        pipelineCache.put(props, impl);\n      }\n    }\n    return impl;\n  }","id":77468,"modified_method":"/**\n   * Create (or retrieve) a StanfordCoreNLP object corresponding to these properties.\n   * @param props The properties to create the object with.\n   * @return A pipeline parameterized by these properties.\n   */\n  private StanfordCoreNLP mkStanfordCoreNLP(Properties props) {\n    StanfordCoreNLP impl;\n    synchronized (pipelineCache) {\n      impl = pipelineCache.get(props);\n      if (impl == null) {\n        AnnotatorPool pool = StanfordCoreNLP.constructAnnotatorPool(props, new AnnotatorImplementations());\n        impl = new StanfordCoreNLP(props, pool);\n        pipelineCache.put(props, impl);\n      }\n    }\n    return impl;\n  }","commit_id":"b02f5a2c4ac8f3f257b0921b079631b3bf4f5fd3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public WOComponent nextPage(WOComponent sender) {\n        if (_object != null && _object.editingContext() != null) {\n            EOEditingContext editingContext = _object.editingContext();\n            NSValidation.ValidationException exception = null;\n            try {\n                if (_dataSource != null) _dataSource.deleteObject(_object);\n                if (editingContext instanceof EOSharedEditingContext) {\n                    //fault the eo into another ec, one cannot delete objects\n                    // in an shared editing context\n                    EOEditingContext ec = ERXEC.newEditingContext();\n                    ec.lock();\n                    try {\n                        ec.setSharedEditingContext(null);\n                        EOEnterpriseObject object = EOUtilities.localInstanceOfObject(ec, _object);\n                        ec.deleteObject(object);\n                        ec.saveChanges();\n                    } finally {\n                        ec.unlock();\n                        ec.dispose();\n                    }\n                } else {\n                    editingContext.deleteObject(_object);\n                    editingContext.saveChanges();\n                    _object = null;\n                }\n            } catch (EOObjectNotAvailableException e) {\n                exception = ERXValidationFactory.defaultFactory().createCustomException(_object, \"EOObjectNotAvailableException\");\n            } catch (EOGeneralAdaptorException e) {\n                EODatabaseOperation op = (EODatabaseOperation)e.userInfo().objectForKey(\n                        EODatabaseContext.FailedDatabaseOperationKey);\n                if(op.databaseOperator() == EODatabaseOperation.DatabaseDeleteOperator) {\n                    exception = ERXValidationFactory.defaultFactory().createCustomException(_object, \"EOObjectNotAvailableException\");\n                } else {\n                    exception = ERXValidationFactory.defaultFactory().createCustomException(_object, \"Database error: \" + e.getMessage());\n               }\n            } catch (NSValidation.ValidationException e) {\n                exception = e;\n            }\n            if(exception != null) {\n                if (exception instanceof ERXValidationException) {\n                    ERXValidationException ex = (ERXValidationException) exception;\n                    D2WContext context = (D2WContext) sender.valueForKey(\"d2wContext\");\n                    Object o = ex.object();\n\n                    if (o instanceof EOEnterpriseObject) {\n                        EOEnterpriseObject eo = (EOEnterpriseObject) o;\n                        context.takeValueForKey(eo.entityName(), \"entityName\");\n                        context.takeValueForKey(ex.propertyKey(), \"propertyKey\");\n                    }\n                    ((ERXValidationException) exception).setContext(context);\n                }\n                log.info(\"Validation Exception: \" + exception + exception.getMessage());\n                editingContext.revert();\n                String errorMessage = \" Could not save your changes: \" + exception.getMessage() + \" \";\n                ErrorPageInterface epf = D2W.factory().errorPage(sender.session());\n                if (epf instanceof ERDErrorPageInterface) {\n                    ((ERDErrorPageInterface) epf).setException(exception);\n                }\n                epf.setMessage(errorMessage);\n                epf.setNextPage(followPage(sender));\n                return (WOComponent) epf;\n            }\n        }\n        return followPage(sender);\n    }","id":77469,"modified_method":"public WOComponent nextPage(WOComponent sender) {\n        if (_object != null && _object.editingContext() != null) {\n            EOEditingContext editingContext = _object.editingContext();\n            NSValidation.ValidationException exception = null;\n            try {\n                if (_dataSource != null) _dataSource.deleteObject(_object);\n                if (editingContext instanceof EOSharedEditingContext) {\n                    //fault the eo into another ec, one cannot delete objects\n                    // in an shared editing context\n                    EOEditingContext ec = ERXEC.newEditingContext();\n                    ec.lock();\n                    try {\n                        ec.setSharedEditingContext(null);\n                        EOEnterpriseObject object = EOUtilities.localInstanceOfObject(ec, _object);\n                        ec.deleteObject(object);\n                        ec.saveChanges();\n                    } finally {\n                        ec.unlock();\n                        ec.dispose();\n                    }\n                } else {\n                    editingContext.deleteObject(_object);\n                    editingContext.saveChanges();\n                    _object = null;\n                }\n            } catch (EOObjectNotAvailableException e) {\n                exception = ERXValidationFactory.defaultFactory().createCustomException(_object, \"EOObjectNotAvailableException\");\n            } catch (EOGeneralAdaptorException e) {\n            \tNSDictionary userInfo = e.userInfo();\n            \tif(userInfo != null) {\n            \t\tEODatabaseOperation op = (EODatabaseOperation)userInfo.objectForKey(EODatabaseContext.FailedDatabaseOperationKey);\n            \t\tif(op.databaseOperator() == EODatabaseOperation.DatabaseDeleteOperator) {\n            \t\t\texception = ERXValidationFactory.defaultFactory().createCustomException(_object, \"EOObjectNotAvailableException\");\n            \t\t}\n            \t}\n            \tif(exception == null) {\n            \t\texception = ERXValidationFactory.defaultFactory().createCustomException(_object, \"Database error: \" + e.getMessage());\n            \t}\n            } catch (NSValidation.ValidationException e) {\n                exception = e;\n            }\n            if(exception != null) {\n                if (exception instanceof ERXValidationException) {\n                    ERXValidationException ex = (ERXValidationException) exception;\n                    D2WContext context = (D2WContext) sender.valueForKey(\"d2wContext\");\n                    Object o = ex.object();\n\n                    if (o instanceof EOEnterpriseObject) {\n                        EOEnterpriseObject eo = (EOEnterpriseObject) o;\n                        context.takeValueForKey(eo.entityName(), \"entityName\");\n                        context.takeValueForKey(ex.propertyKey(), \"propertyKey\");\n                    }\n                    ((ERXValidationException) exception).setContext(context);\n                }\n                log.info(\"Validation Exception: \" + exception + exception.getMessage());\n                editingContext.revert();\n                String errorMessage = \" Could not save your changes: \" + exception.getMessage() + \" \";\n                ErrorPageInterface epf = D2W.factory().errorPage(sender.session());\n                if (epf instanceof ERDErrorPageInterface) {\n                    ((ERDErrorPageInterface) epf).setException(exception);\n                }\n                epf.setMessage(errorMessage);\n                epf.setNextPage(followPage(sender));\n                return (WOComponent) epf;\n            }\n        }\n        return followPage(sender);\n    }","commit_id":"a67df617afde713d2f32beb2fc889d530b69c8f0","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected NSMutableDictionary _userInfo() { return (NSMutableDictionary)super.userInfo(); }","id":77470,"modified_method":"protected NSMutableDictionary _userInfo() {\n        if(_mutableUserInfo == null) {\n            Object info = super.userInfo();\n            if(info == null) {\n                _mutableUserInfo = new NSMutableDictionary();\n            } else if(info.getClass() == NSDictionary.class) {\n                _mutableUserInfo = new NSMutableDictionary((NSDictionary)info);\n            } else if(info instanceof NSMutableDictionary) {\n                _mutableUserInfo = (NSMutableDictionary)info;\n            }\n        }\n        return _mutableUserInfo;\n    }","commit_id":"49e94e9b3bc8ee21226493f1e329db74e4ba965d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static boolean isIMRequest(WORequest _request) {\n    return _request.userInfo().objectForKey(InstantMessengerAdaptor.IS_IM_KEY) != null;\n  }","id":77471,"modified_method":"public static boolean isIMRequest(WORequest _request) {\n    NSDictionary userInfo = _request.userInfo();\n    return (userInfo != null && userInfo.objectForKey(InstantMessengerAdaptor.IS_IM_KEY) != null);\n  }","commit_id":"bad03934d25b0bde566beef483f480ef54ce3ce7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public LocalChange(EOObjectStoreCoordinator osc, NSDictionary userInfo) {\n\t\t\tsuper((NSArray) userInfo.objectForKey(EOObjectStore.DeletedKey), (NSArray) userInfo.objectForKey(EOObjectStore.UpdatedKey), (NSArray) userInfo.objectForKey(EOObjectStore.InsertedKey));\n\t\t\t_coordinator = osc;\n\t\t\t_deleted = snapshotsGroupedByEntity(deletedGIDs(), _coordinator);\n\t\t\t_updated = snapshotsGroupedByEntity(updatedGIDs(), _coordinator);\n\t\t\t_inserted = snapshotsGroupedByEntity(insertedGIDs(), _coordinator);\n\t\t}","id":77472,"modified_method":"public LocalChange(EOObjectStoreCoordinator osc, NSDictionary userInfo) {\n\t\t\tsuper((NSArray) userInfo.objectForKey(EOObjectStore.DeletedKey), (NSArray) userInfo.objectForKey(EOObjectStore.UpdatedKey), (NSArray) userInfo.objectForKey(EOObjectStore.InsertedKey), (NSArray) userInfo.objectForKey(EOObjectStore.InvalidatedKey));\n\t\t\t_coordinator = osc;\n\t\t\t_deleted = snapshotsGroupedByEntity(deletedGIDs(), _coordinator);\n\t\t\t_updated = snapshotsGroupedByEntity(updatedGIDs(), _coordinator);\n\t\t\t_inserted = snapshotsGroupedByEntity(insertedGIDs(), _coordinator);\n\t\t\t_invalidated = snapshotsGroupedByEntity(invalidatedGIDs(), _coordinator);\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void publishChange(NSNotification n) {\n\t\tif (_coordinators.size() >= 2 || _multicastSynchronizer != null) {\n\t\t\tLocalChange changes = new LocalChange((EOObjectStoreCoordinator) n.object(), n.userInfo());\n\t\t\t_queueThread.addChange(changes);\n\t\t}\n\t}","id":77473,"modified_method":"public void publishChange(NSNotification n) {\n\t\tif (_coordinators.size() >= 2 || _multicastSynchronizer != null) {\n\t\t\tNSDictionary userInfo = n.userInfo();\n\t\t\tSystem.out.println(\"ERXObjectStoreCoordinatorSynchronizer.publishChange: \" + n.object() + \", \" + n);\n\t\t\tif (userInfo == null || userInfo.valueForKey(ERXObjectStoreCoordinatorSynchronizer.SYNCHRONIZER_KEY) == null) {\n\t\t\t\tLocalChange changes = new LocalChange((EOObjectStoreCoordinator) n.object(), userInfo);\n\t\t\t\t_queueThread.addChange(changes);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void processSnapshots(EODatabase database, NSDictionary snapshots) {\n\t\t\t\tdatabase.forgetSnapshotsForGlobalIDs(snapshots.allKeys());\n\t\t\t\tdatabase.recordSnapshots(snapshots);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"update: \" + snapshots);\n\t\t\t\t}\n\t\t\t}","id":77474,"modified_method":"public void processSnapshots(EODatabaseContext dbc, EODatabase database, NSDictionary snapshots) {\n\t\t\t\tNSArray gids = snapshots.allKeys();\n\t\t\t\t//database.forgetSnapshotsForGlobalIDs(gids);\n\t\t\t\tdatabase.recordSnapshots(snapshots);\n\t\t\t\t\n\t\t\t\tNSMutableDictionary userInfo = new NSMutableDictionary(gids, EODatabaseContext.UpdatedKey);\n\t\t\t\tuserInfo.setObjectForKey(Boolean.TRUE, ERXObjectStoreCoordinatorSynchronizer.SYNCHRONIZER_KEY);\n\t\t\t\tNSNotificationCenter.defaultCenter().postNotification(EODatabaseContext.ObjectsChangedInStoreNotification, dbc, userInfo);\n\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"update: \" + snapshots);\n\t\t\t\t}\n\t\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void run() {\n\t\t\tboolean run = true;\n\t\t\twhile (run) {\n\t\t\t\tChange changes = null;\n\t\t\t\tsynchronized (_elements) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (_elements.isEmpty()) {\n\t\t\t\t\t\t\t_elements.wait();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!_elements.isEmpty()) {\n\t\t\t\t\t\t\tchanges = (Change) _elements.remove(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException e) {\n\t\t\t\t\t\trun = false;\n\t\t\t\t\t\tlog.warn(\"Interrupted: \" + e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (changes != null) {\n\t\t\t\t\tif (changes instanceof LocalChange) {\n\t\t\t\t\t\tLocalChange localChanges = (LocalChange) changes;\n\t\t\t\t\t\tEOObjectStoreCoordinator sender = localChanges.coordinator();\n\n\t\t\t\t\t\tprocess(sender, _deleteProcessor, localChanges.deleted());\n\t\t\t\t\t\tprocess(sender, _insertProcessor, localChanges.inserted());\n\t\t\t\t\t\tprocess(sender, _updateProcessor, localChanges.updated());\n\n\t\t\t\t\t\tif (_multicastSynchronizer != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t_multicastSynchronizer.writeChanges(localChanges);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\t\t\t\tERXObjectStoreCoordinatorSynchronizer.log.error(\"Failed to send multicast notification.\", t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (changes instanceof RemoteChange) {\n\t\t\t\t\t\tRemoteChange remoteChanges = (RemoteChange) changes;\n\t\t\t\t\t\tprocess(_deleteGIDProcessor, remoteChanges.deletedGIDs());\n\t\t\t\t\t\tprocess(_insertGIDProcessor, remoteChanges.insertedGIDs());\n\t\t\t\t\t\tprocess(_updateGIDProcessor, remoteChanges.updatedGIDs());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":77475,"modified_method":"public void run() {\n\t\t\tboolean run = true;\n\t\t\twhile (run) {\n\t\t\t\tChange changes = null;\n\t\t\t\tsynchronized (_elements) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (_elements.isEmpty()) {\n\t\t\t\t\t\t\t_elements.wait();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!_elements.isEmpty()) {\n\t\t\t\t\t\t\tchanges = (Change) _elements.remove(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException e) {\n\t\t\t\t\t\trun = false;\n\t\t\t\t\t\tlog.warn(\"Interrupted: \" + e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (changes != null) {\n\t\t\t\t\tif (changes instanceof LocalChange) {\n\t\t\t\t\t\tLocalChange localChanges = (LocalChange) changes;\n\t\t\t\t\t\tEOObjectStoreCoordinator sender = localChanges.coordinator();\n\n\t\t\t\t\t\tprocess(sender, _deleteProcessor, localChanges.deleted(), EODatabaseContext.DeletedKey);\n\t\t\t\t\t\tprocess(sender, _insertProcessor, localChanges.inserted(), EODatabaseContext.InsertedKey);\n\t\t\t\t\t\tprocess(sender, _updateProcessor, localChanges.updated(), EODatabaseContext.UpdatedKey);\n\t\t\t\t\t\tprocess(sender, _invalidateProcessor, localChanges.invalidated(), EODatabaseContext.InvalidatedKey);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (_multicastSynchronizer != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t_multicastSynchronizer.writeChanges(localChanges);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\t\t\t\tERXObjectStoreCoordinatorSynchronizer.log.error(\"Failed to send multicast notification.\", t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (changes instanceof RemoteChange) {\n\t\t\t\t\t\tRemoteChange remoteChanges = (RemoteChange) changes;\n\t\t\t\t\t\tprocess(_deleteGIDProcessor, remoteChanges.deletedGIDs());\n\t\t\t\t\t\tprocess(_insertGIDProcessor, remoteChanges.insertedGIDs());\n\t\t\t\t\t\tprocess(_updateGIDProcessor, remoteChanges.updatedGIDs());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t\t * @param dictionary\n\t\t * @param sender\n\t\t */\n\t\tprotected void process(EOObjectStoreCoordinator sender, SnapshotProcessor processor, NSDictionary changesByEntity) {\n\t\t\tNSMutableDictionary dbcs = new NSMutableDictionary();\n\t\t\tfor (Enumeration oscs = _synchronizer.coordinators(); oscs.hasMoreElements();) {\n\t\t\t\tEOObjectStoreCoordinator osc = (EOObjectStoreCoordinator) oscs.nextElement();\n\t\t\t\tif (osc != sender) {\n\t\t\t\t\tNSMutableDictionary snapshotsByGlobalID = new NSMutableDictionary();\n\t\t\t\t\tfor (Enumeration entityNames = changesByEntity.allKeys().objectEnumerator(); entityNames.hasMoreElements();) {\n\t\t\t\t\t\tString entityName = (String) entityNames.nextElement();\n\t\t\t\t\t\tString key = entityName + \"/\" + System.identityHashCode(osc);\n\t\t\t\t\t\tEOEntity entity = EOModelGroup.modelGroupForObjectStoreCoordinator(sender).entityNamed(entityName);\n\t\t\t\t\t\tNSArray snapshots = (NSArray) changesByEntity.objectForKey(entityName);\n\t\t\t\t\t\tEODatabaseContext dbc = (EODatabaseContext) dbcs.objectForKey(key);\n\t\t\t\t\t\tif (dbc == null) {\n\t\t\t\t\t\t\tdbc = ERXEOAccessUtilities.databaseContextForEntityNamed(osc, entityName);\n\t\t\t\t\t\t\tdbcs.setObjectForKey(dbc, key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEODatabase database = dbc.database();\n\t\t\t\t\t\tfor (Enumeration snapshotsEnumerator = snapshots.objectEnumerator(); snapshotsEnumerator.hasMoreElements();) {\n\t\t\t\t\t\t\tNSDictionary snapshot = (NSDictionary) snapshotsEnumerator.nextElement();\n\t\t\t\t\t\t\tEOGlobalID globalID = entity.globalIDForRow(snapshot);\n\t\t\t\t\t\t\tsnapshotsByGlobalID.setObjectForKey(snapshot, globalID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snapshotsByGlobalID.count() > 0) {\n\t\t\t\t\t\t\tEODatabaseContext._EOAssertSafeMultiThreadedAccess(dbc);\n\t\t\t\t\t\t\tdbc.lock();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tprocessor.processSnapshots(database, snapshotsByGlobalID);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tdbc.unlock();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":77476,"modified_method":"/**\n\t\t * @param dictionary\n\t\t * @param sender\n\t\t */\n\t\tprotected void process(EOObjectStoreCoordinator sender, SnapshotProcessor processor, NSDictionary changesByEntity, String userInfoKey) {\n\t\t\tNSMutableDictionary dbcs = new NSMutableDictionary();\n\t\t\tfor (Enumeration oscs = _synchronizer.coordinators(); oscs.hasMoreElements();) {\n\t\t\t\tEOObjectStoreCoordinator osc = (EOObjectStoreCoordinator) oscs.nextElement();\n\t\t\t\tif (osc != sender) {\n\t\t\t\t\tNSMutableDictionary snapshotsByGlobalID = new NSMutableDictionary();\n\t\t\t\t\tfor (Enumeration entityNames = changesByEntity.allKeys().objectEnumerator(); entityNames.hasMoreElements();) {\n\t\t\t\t\t\tString entityName = (String) entityNames.nextElement();\n\t\t\t\t\t\tString key = entityName + \"/\" + System.identityHashCode(osc);\n\t\t\t\t\t\tEOEntity entity = EOModelGroup.modelGroupForObjectStoreCoordinator(sender).entityNamed(entityName);\n\t\t\t\t\t\tNSArray snapshots = (NSArray) changesByEntity.objectForKey(entityName);\n\t\t\t\t\t\tEODatabaseContext dbc = (EODatabaseContext) dbcs.objectForKey(key);\n\t\t\t\t\t\tif (dbc == null) {\n\t\t\t\t\t\t\tdbc = ERXEOAccessUtilities.databaseContextForEntityNamed(osc, entityName);\n\t\t\t\t\t\t\tdbcs.setObjectForKey(dbc, key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEODatabase database = dbc.database();\n\t\t\t\t\t\tfor (Enumeration snapshotsEnumerator = snapshots.objectEnumerator(); snapshotsEnumerator.hasMoreElements();) {\n\t\t\t\t\t\t\tNSDictionary snapshot = (NSDictionary) snapshotsEnumerator.nextElement();\n\t\t\t\t\t\t\tEOGlobalID globalID = entity.globalIDForRow(snapshot);\n\t\t\t\t\t\t\tsnapshotsByGlobalID.setObjectForKey(snapshot, globalID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snapshotsByGlobalID.count() > 0) {\n\t\t\t\t\t\t\tEODatabaseContext._EOAssertSafeMultiThreadedAccess(dbc);\n\t\t\t\t\t\t\tdbc.lock();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tprocessor.processSnapshots(dbc, database, snapshotsByGlobalID);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tdbc.unlock();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void _listen() {\n\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(_identifier) + \" listening.\");\n\t\t\t}\n\t\t\t_listening = true;\n\t\t\tbyte[] buffer = new byte[_maxPacketSize];\n\t\t\twhile (_listening) {\n\t\t\t\tDatagramPacket receivePacket = new DatagramPacket(buffer, 0, buffer.length);\n\t\t\t\ttry {\n\t\t\t\t\t_multicastSocket.receive(receivePacket);\n\t\t\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(receivePacket.getData(), 0, receivePacket.getLength());\n\t\t\t\t\tDataInputStream dis = new DataInputStream(bais);\n\t\t\t\t\tboolean processPacket = true;\n\t\t\t\t\tif (_whitelist != null) {\n\t\t\t\t\t\tInetAddress remoteAddress = receivePacket.getAddress();\n\t\t\t\t\t\tString remoteHostAddress = remoteAddress.getHostAddress();\n\t\t\t\t\t\tprocessPacket = _whitelist.containsObject(remoteHostAddress);\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] identifier = new byte[MulticastSynchronizer.IDENTIFIER_LENGTH];\n\t\t\t\t\tdis.readFully(identifier);\n\t\t\t\t\tif (processPacket && !Arrays.equals(identifier, _identifier)) {\n\t\t\t\t\t\tint messageType = dis.readByte();\n\t\t\t\t\t\tif (messageType == MulticastSynchronizer.JOIN) {\n\t\t\t\t\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") joined.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.LEAVE) {\n\t\t\t\t\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") left.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.INSERT) {\n\t\t\t\t\t\t\tNSArray gids = readGIDs(receivePacket, dis);\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") inserted \" + gids);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRemoteChange changes = new RemoteChange(NSArray.EmptyArray, NSArray.EmptyArray, gids);\n\t\t\t\t\t\t\t_listener.addChange(changes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.UPDATE) {\n\t\t\t\t\t\t\tNSArray gids = readGIDs(receivePacket, dis);\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") updated \" + gids);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRemoteChange changes = new RemoteChange(NSArray.EmptyArray, gids, NSArray.EmptyArray);\n\t\t\t\t\t\t\t_listener.addChange(changes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.DELETE) {\n\t\t\t\t\t\t\tNSArray gids = readGIDs(receivePacket, dis);\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") deleted \" + gids);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRemoteChange changes = new RemoteChange(gids, NSArray.EmptyArray, NSArray.EmptyArray);\n\t\t\t\t\t\t\t_listener.addChange(changes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown multicast message type #\" + messageType + \".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \"): skipping our own message\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tERXObjectStoreCoordinatorSynchronizer.log.error(\"Failed to read multicast notification.\", t);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":77477,"modified_method":"protected void _listen() {\n\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(_identifier) + \" listening.\");\n\t\t\t}\n\t\t\t_listening = true;\n\t\t\tbyte[] buffer = new byte[_maxPacketSize];\n\t\t\twhile (_listening) {\n\t\t\t\tDatagramPacket receivePacket = new DatagramPacket(buffer, 0, buffer.length);\n\t\t\t\ttry {\n\t\t\t\t\t_multicastSocket.receive(receivePacket);\n\t\t\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(receivePacket.getData(), 0, receivePacket.getLength());\n\t\t\t\t\tDataInputStream dis = new DataInputStream(bais);\n\t\t\t\t\tboolean processPacket = true;\n\t\t\t\t\tif (_whitelist != null) {\n\t\t\t\t\t\tInetAddress remoteAddress = receivePacket.getAddress();\n\t\t\t\t\t\tString remoteHostAddress = remoteAddress.getHostAddress();\n\t\t\t\t\t\tprocessPacket = _whitelist.containsObject(remoteHostAddress);\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] identifier = new byte[MulticastSynchronizer.IDENTIFIER_LENGTH];\n\t\t\t\t\tdis.readFully(identifier);\n\t\t\t\t\tif (processPacket && !Arrays.equals(identifier, _identifier)) {\n\t\t\t\t\t\tint messageType = dis.readByte();\n\t\t\t\t\t\tif (messageType == MulticastSynchronizer.JOIN) {\n\t\t\t\t\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") joined.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.LEAVE) {\n\t\t\t\t\t\t\tif (log.isInfoEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") left.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.INSERT) {\n\t\t\t\t\t\t\tNSArray gids = readGIDs(receivePacket, dis);\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") inserted \" + gids);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRemoteChange changes = new RemoteChange(NSArray.EmptyArray, NSArray.EmptyArray, gids, NSArray.EmptyArray);\n\t\t\t\t\t\t\t_listener.addChange(changes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.UPDATE) {\n\t\t\t\t\t\t\tNSArray gids = readGIDs(receivePacket, dis);\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") updated \" + gids);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRemoteChange changes = new RemoteChange(NSArray.EmptyArray, gids, NSArray.EmptyArray, NSArray.EmptyArray);\n\t\t\t\t\t\t\t_listener.addChange(changes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (messageType == MulticastSynchronizer.DELETE) {\n\t\t\t\t\t\t\tNSArray gids = readGIDs(receivePacket, dis);\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \") deleted \" + gids);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRemoteChange changes = new RemoteChange(gids, NSArray.EmptyArray, NSArray.EmptyArray, NSArray.EmptyArray);\n\t\t\t\t\t\t\t_listener.addChange(changes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown multicast message type #\" + messageType + \".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\tlog.info(\"Multicast instance \" + ERXStringUtilities.byteArrayToHexString(identifier) + \" (\" + receivePacket.getAddress() + \"): skipping our own message\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\tERXObjectStoreCoordinatorSynchronizer.log.error(\"Failed to read multicast notification.\", t);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t\t * @param dictionary\n\t\t * @param sender\n\t\t */\n\t\tprotected void process(SnapshotGIDProcessor processor, NSArray changesByEntity) {\n\t\t\tif (changesByEntity.count() > 0) {\n\t\t\t\tNSMutableDictionary dbcs = new NSMutableDictionary();\n\t\t\t\tfor (Enumeration oscs = _synchronizer.coordinators(); oscs.hasMoreElements();) {\n\t\t\t\t\tEOObjectStoreCoordinator osc = (EOObjectStoreCoordinator) oscs.nextElement();\n\t\t\t\t\tEOKeyGlobalID firstGID = (EOKeyGlobalID) changesByEntity.objectAtIndex(0);\n\t\t\t\t\tString entityName = firstGID.entityName();\n\t\t\t\t\tEOEntity entity = EOModelGroup.modelGroupForObjectStoreCoordinator(osc).entityNamed(entityName);\n\t\t\t\t\tEODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed(osc, entityName);\n\t\t\t\t\tEODatabase database = dbc.database();\n\t\t\t\t\tEODatabaseContext._EOAssertSafeMultiThreadedAccess(dbc);\n\t\t\t\t\tdbc.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.processSnapshots(database, changesByEntity);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tdbc.unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":77478,"modified_method":"/**\n\t\t * @param dictionary\n\t\t * @param sender\n\t\t */\n\t\tprotected void process(SnapshotGIDProcessor processor, NSArray changesByEntity) {\n\t\t\tif (changesByEntity.count() > 0) {\n\t\t\t\tNSMutableDictionary dbcs = new NSMutableDictionary();\n\t\t\t\tfor (Enumeration oscs = _synchronizer.coordinators(); oscs.hasMoreElements();) {\n\t\t\t\t\tEOObjectStoreCoordinator osc = (EOObjectStoreCoordinator) oscs.nextElement();\n\t\t\t\t\tEOKeyGlobalID firstGID = (EOKeyGlobalID) changesByEntity.objectAtIndex(0);\n\t\t\t\t\tString entityName = firstGID.entityName();\n\t\t\t\t\tEOEntity entity = EOModelGroup.modelGroupForObjectStoreCoordinator(osc).entityNamed(entityName);\n\t\t\t\t\tEODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed(osc, entityName);\n\t\t\t\t\tEODatabase database = dbc.database();\n\t\t\t\t\tEODatabaseContext._EOAssertSafeMultiThreadedAccess(dbc);\n\t\t\t\t\tdbc.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.processSnapshots(dbc, database, changesByEntity);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tdbc.unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void processSnapshots(EODatabase database, NSArray gids) {\n\t\t\t\tdatabase.forgetSnapshotsForGlobalIDs(gids);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"forget gids: \" + gids);\n\t\t\t\t}\n\t\t\t}","id":77479,"modified_method":"public void processSnapshots(EODatabaseContext dbc, EODatabase database, NSArray gids) {\n\t\t\t\tdatabase.forgetSnapshotsForGlobalIDs(gids);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"forget gids: \" + gids);\n\t\t\t\t}\n\t\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void processSnapshots(EODatabase database, NSDictionary snapshots) {\n\t\t\t\tdatabase.recordSnapshots(snapshots);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"insert: \" + snapshots);\n\t\t\t\t}\n\t\t\t}","id":77480,"modified_method":"public void processSnapshots(EODatabaseContext dbc, EODatabase database, NSDictionary snapshots) {\n\t\t\t\tNSArray gids = snapshots.allKeys();\n\t\t\t\tdatabase.recordSnapshots(snapshots);\n\t\t\t\t\n\t\t\t\tEnumeration gidsEnum = gids.objectEnumerator();\n\t\t\t\twhile (gidsEnum.hasMoreElements()) {\n\t\t\t\t\tEOKeyGlobalID gid = (EOKeyGlobalID)gidsEnum.nextElement();\n\t\t\t\t\tEOEntity entity = database.entityNamed(gid.entityName());\n\t\t\t\t\tNSDictionary snapshot = (NSDictionary)snapshots.objectForKey(gid);\n\t\t\t\t\tEnumeration relationshipsEnum = entity.relationships().objectEnumerator();\n\t\t\t\t\twhile (relationshipsEnum.hasMoreElements()) {\n\t\t\t\t\t\tEORelationship relationship = (EORelationship)relationshipsEnum.nextElement();\n\t\t\t\t\t\tif (!relationship.isToMany()) {\n\t\t\t\t\t\t\tEORelationship inverseRelationship = relationship.inverseRelationship();\n\t\t\t\t\t\t\tif (inverseRelationship != null && inverseRelationship.isToMany()) {\n\t\t\t\t\t\t\t\tEOEntity destEntity = inverseRelationship.entity();\n\t\t\t\t\t\t\t\tNSDictionary destPK = relationship._foreignKeyForSourceRow(snapshot);\n\t\t\t\t\t\t\t\tEOGlobalID destGID = destEntity.globalIDForRow(destPK);\n\t\t\t\t\t\t\t\tif (destGID != null) {\n\t\t\t\t\t\t\t\t\tString inverseRelationshipName = inverseRelationship.name();\n\t\t\t\t\t\t\t\t\tNSArray inverseRelationshipGIDs = database.snapshotForSourceGlobalID(destGID, inverseRelationshipName);\n\t\t\t\t\t\t\t\t\tif (inverseRelationshipGIDs != null) {\n\t\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdatabase.recordSnapshotForSourceGlobalID(inverseRelationshipGIDs.arrayByAddingObject(gid), destGID, inverseRelationshipName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tNSMutableDictionary userInfo = new NSMutableDictionary(gids, EODatabaseContext.InsertedKey);\n\t\t\t\tuserInfo.setObjectForKey(Boolean.TRUE, ERXObjectStoreCoordinatorSynchronizer.SYNCHRONIZER_KEY);\n\t\t\t\tNSNotificationCenter.defaultCenter().postNotification(EODatabaseContext.ObjectsChangedInStoreNotification, dbc, userInfo);\n\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"insert: \" + snapshots);\n\t\t\t\t}\n\t\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void processSnapshots(EODatabase database, NSDictionary snapshots) {\n\t\t\t\tdatabase.forgetSnapshotsForGlobalIDs(snapshots.allKeys());\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"forget: \" + snapshots);\n\t\t\t\t}\n\t\t\t}","id":77481,"modified_method":"public void processSnapshots(EODatabaseContext dbc, EODatabase database, NSDictionary snapshots) {\n\t\t\t\tNSArray gids = snapshots.allKeys();\n\t\t\t\tdatabase.forgetSnapshotsForGlobalIDs(gids);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"forget: \" + snapshots);\n\t\t\t\t}\n\t\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Change(NSArray deletedGIDs, NSArray updatedGIDs, NSArray insertedGIDs) {\n\t\t\t_deletedGIDs = deletedGIDs;\n\t\t\t_updatedGIDs = updatedGIDs;\n\t\t\t_insertedGIDs = insertedGIDs;\n\t\t}","id":77482,"modified_method":"public Change(NSArray deletedGIDs, NSArray updatedGIDs, NSArray insertedGIDs, NSArray invalidatedGIDs) {\n\t\t\t_deletedGIDs = deletedGIDs;\n\t\t\t_updatedGIDs = updatedGIDs;\n\t\t\t_insertedGIDs = insertedGIDs;\n\t\t\t_invalidatedGIDs = invalidatedGIDs;\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void processSnapshots(EODatabase database, NSArray gids) {\n\t\t\t\t// database.recordSnapshots(snapshots);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"insert: \" + gids);\n\t\t\t\t}\n\t\t\t}","id":77483,"modified_method":"public void processSnapshots(EODatabaseContext dbc, EODatabase database, NSArray gids) {\n\t\t\t\tSystem.out.println(\"InsertSnapshotGIDProcessor.processSnapshots: \" + gids);\n\t\t\t\t// database.recordSnapshots(snapshots);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"insert: \" + gids);\n\t\t\t\t}\n\t\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public abstract void processSnapshots(EODatabase database, NSArray gids);","id":77484,"modified_method":"public abstract void processSnapshots(EODatabaseContext dbc, EODatabase database, NSArray gids);","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public RemoteChange(NSArray deletedGIDs, NSArray updatedGIDs, NSArray insertedGIDs) {\n\t\t\tsuper(deletedGIDs, updatedGIDs, insertedGIDs);\n\t\t}","id":77485,"modified_method":"public RemoteChange(NSArray deletedGIDs, NSArray updatedGIDs, NSArray insertedGIDs, NSArray invalidatedGIDs) {\n\t\t\tsuper(deletedGIDs, updatedGIDs, insertedGIDs, invalidatedGIDs);\n\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void processSnapshots(EODatabase database, NSArray gids) {\n\t\t\t\tNSMutableArray existingGIDs = new NSMutableArray();\n\t\t\t\tEnumeration gidsEnum = gids.objectEnumerator();\n\t\t\t\twhile (gidsEnum.hasMoreElements()) {\n\t\t\t\t\tEOGlobalID gid = (EOGlobalID)gidsEnum.nextElement();\n\t\t\t\t\tNSDictionary snapshot = database.snapshotForGlobalID(gid);\n\t\t\t\t\tif (snapshot != null) {\n\t\t\t\t\t\texistingGIDs.addObject(gid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEOEditingContext editingContext = ERXEC.newEditingContext();\n\t\t\t\teditingContext.lock();\n\t\t\t\ttry {\n\t\t\t\t\tERXEOGlobalIDUtilities.fetchObjectsWithGlobalIDs(editingContext, existingGIDs, true);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\teditingContext.unlock();\n\t\t\t\t}\n\t\t\t\t//database.forgetSnapshotsForGlobalIDs(gids);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"update gids: \" + gids);\n\t\t\t\t}\n\t\t\t}","id":77486,"modified_method":"public void processSnapshots(EODatabaseContext dbc, EODatabase database, NSArray gids) {\n\t\t\t\tNSMutableArray existingGIDs = new NSMutableArray();\n\t\t\t\tEnumeration gidsEnum = gids.objectEnumerator();\n\t\t\t\twhile (gidsEnum.hasMoreElements()) {\n\t\t\t\t\tEOGlobalID gid = (EOGlobalID)gidsEnum.nextElement();\n\t\t\t\t\tNSDictionary snapshot = database.snapshotForGlobalID(gid);\n\t\t\t\t\tif (snapshot != null) {\n\t\t\t\t\t\texistingGIDs.addObject(gid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEOEditingContext editingContext = ERXEC.newEditingContext();\n\t\t\t\teditingContext.lock();\n\t\t\t\ttry {\n\t\t\t\t\tERXEOGlobalIDUtilities.fetchObjectsWithGlobalIDs(editingContext, existingGIDs, true);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\teditingContext.unlock();\n\t\t\t\t}\n\t\t\t\t//database.forgetSnapshotsForGlobalIDs(gids);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"update gids: \" + gids);\n\t\t\t\t}\n\t\t\t}","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public abstract void processSnapshots(EODatabase database, NSDictionary snapshots);","id":77487,"modified_method":"public abstract void processSnapshots(EODatabaseContext dbc, EODatabase database, NSDictionary snapshots);","commit_id":"b6885cc2818004145198d766bff5dd4e3e0eda09","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isCreateSdkProject() {\n    return this.createSDKProject.getSelection();\n  }","id":77488,"modified_method":"public boolean isCreateSdkProject() {\n    boolean _and = false;\n    boolean _selection = this.createUiProject.getSelection();\n    if (!_selection) {\n      _and = false;\n    } else {\n      boolean _selection_1 = this.createSDKProject.getSelection();\n      _and = _selection_1;\n    }\n    return _and;\n  }","commit_id":"70dc2a175d68724df323880959859ef792d51873","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean isCreateP2Project() {\n    return this.createP2Project.getSelection();\n  }","id":77489,"modified_method":"public boolean isCreateP2Project() {\n    boolean _and = false;\n    boolean _selection = this.createUiProject.getSelection();\n    if (!_selection) {\n      _and = false;\n    } else {\n      boolean _selection_1 = this.createP2Project.getSelection();\n      _and = _selection_1;\n    }\n    return _and;\n  }","commit_id":"70dc2a175d68724df323880959859ef792d51873","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n   * We made this one synchronized in the JVM because otherwise, this is not thread safe. In that case if (on an\n   * application server for example) several HTTP's are running at the same time, you get into problems because the\n   * System.setProperty() calls are system wide!\n   */\n  @Override\n  public synchronized Result execute( Result previousResult, int nr ) {\n    Result result = previousResult;\n    result.setResult( false );\n\n    logBasic( BaseMessages.getString( PKG, \"JobHTTP.StartJobEntry\" ) );\n\n    // Get previous result rows...\n    List<RowMetaAndData> resultRows;\n    String urlFieldnameToUse;\n\n    if ( Const.isEmpty( urlFieldname ) ) {\n      urlFieldnameToUse = URL_FIELDNAME;\n    } else {\n      urlFieldnameToUse = urlFieldname;\n    }\n\n    if ( runForEveryRow ) {\n      resultRows = previousResult.getRows();\n      if ( resultRows == null ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.UnableGetResultPrevious\" ) );\n        return result;\n      }\n    } else {\n      resultRows = new ArrayList<RowMetaAndData>();\n      RowMetaAndData row = new RowMetaAndData();\n      row.addValue(\n        new ValueMetaString( urlFieldnameToUse ), environmentSubstitute( url ) );\n      resultRows.add( row );\n    }\n\n    URL server = null;\n\n    String beforeProxyHost = System.getProperty( \"http.proxyHost\" );\n    String beforeProxyPort = System.getProperty( \"http.proxyPort\" );\n    String beforeNonProxyHosts = System.getProperty( \"http.nonProxyHosts\" );\n\n    for ( int i = 0; i < resultRows.size() && result.getNrErrors() == 0; i++ ) {\n      RowMetaAndData row = resultRows.get( i );\n\n      OutputStream outputFile = null;\n      OutputStream uploadStream = null;\n      BufferedInputStream fileStream = null;\n      InputStream input = null;\n\n      try {\n        String urlToUse = environmentSubstitute( row.getString( urlFieldnameToUse, \"\" ) );\n\n        logBasic( BaseMessages.getString( PKG, \"JobHTTP.Log.ConnectingURL\", urlToUse ) );\n\n        if ( !Const.isEmpty( proxyHostname ) ) {\n          System.setProperty( \"http.proxyHost\", environmentSubstitute( proxyHostname ) );\n          System.setProperty( \"http.proxyPort\", environmentSubstitute( proxyPort ) );\n          if ( nonProxyHosts != null ) {\n            System.setProperty( \"http.nonProxyHosts\", environmentSubstitute( nonProxyHosts ) );\n          }\n        }\n\n        if ( !Const.isEmpty( username ) ) {\n          Authenticator.setDefault( new Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n              String realPassword = Encr.decryptPasswordOptionallyEncrypted( environmentSubstitute( password ) );\n              return new PasswordAuthentication( environmentSubstitute( username ), realPassword != null\n                ? realPassword.toCharArray() : new char[] {} );\n            }\n          } );\n        }\n\n        String realTargetFile = environmentSubstitute( targetFilename );\n        if ( dateTimeAdded ) {\n          SimpleDateFormat daf = new SimpleDateFormat();\n          Date now = new Date();\n\n          daf.applyPattern( \"yyyMMdd\" );\n          realTargetFile += \"_\" + daf.format( now );\n          daf.applyPattern( \"HHmmss\" );\n          realTargetFile += \"_\" + daf.format( now );\n\n          if ( !Const.isEmpty( targetFilenameExtention ) ) {\n            realTargetFile += \".\" + environmentSubstitute( targetFilenameExtention );\n          }\n        }\n\n        // Create the output File...\n        outputFile = KettleVFS.getOutputStream( realTargetFile, this, fileAppended );\n\n        // Get a stream for the specified URL\n        server = new URL( urlToUse );\n        URLConnection connection = server.openConnection();\n\n        // if we have HTTP headers, add them\n        if ( !Const.isEmpty( headerName ) ) {\n          if ( log.isDebug() ) {\n            log.logDebug( BaseMessages.getString( PKG, \"JobHTTP.Log.HeadersProvided\" ) );\n          }\n          for ( int j = 0; j < headerName.length; j++ ) {\n            if ( !Const.isEmpty( headerValue[j] ) ) {\n              connection.setRequestProperty(\n                environmentSubstitute( headerName[j] ), environmentSubstitute( headerValue[j] ) );\n              if ( log.isDebug() ) {\n                log.logDebug( BaseMessages.getString(\n                  PKG, \"JobHTTP.Log.HeaderSet\", environmentSubstitute( headerName[j] ),\n                  environmentSubstitute( headerValue[j] ) ) );\n              }\n            }\n          }\n        }\n\n        connection.setDoOutput( true );\n\n        // See if we need to send a file over?\n        String realUploadFilename = environmentSubstitute( uploadFilename );\n        if ( !Const.isEmpty( realUploadFilename ) ) {\n          if ( log.isDetailed() ) {\n            logDetailed( BaseMessages.getString( PKG, \"JobHTTP.Log.SendingFile\", realUploadFilename ) );\n          }\n\n          // Grab an output stream to upload data to web server\n          uploadStream = connection.getOutputStream();\n          fileStream = new BufferedInputStream( new FileInputStream( new File( realUploadFilename ) ) );\n          try {\n            int c;\n            while ( ( c = fileStream.read() ) >= 0 ) {\n              uploadStream.write( c );\n            }\n          } finally {\n            // Close upload and file\n            if ( uploadStream != null ) {\n              uploadStream.close();\n              uploadStream = null;\n            }\n            if ( fileStream != null ) {\n              fileStream.close();\n              fileStream = null;\n            }\n          }\n          if ( log.isDetailed() ) {\n            logDetailed( BaseMessages.getString( PKG, \"JobHTTP.Log.FinishedSendingFile\" ) );\n          }\n        }\n\n        if ( log.isDetailed() ) {\n          logDetailed( BaseMessages.getString( PKG, \"JobHTTP.Log.StartReadingReply\" ) );\n        }\n\n        // Read the result from the server...\n        input = connection.getInputStream();\n        Date date = new Date( connection.getLastModified() );\n        logBasic( BaseMessages.getString( PKG, \"JobHTTP.Log.ReplayInfo\", connection.getContentType(), date ) );\n\n        int oneChar;\n        long bytesRead = 0L;\n        while ( ( oneChar = input.read() ) != -1 ) {\n          outputFile.write( oneChar );\n          bytesRead++;\n        }\n\n        logBasic( BaseMessages.getString( PKG, \"JobHTTP.Log.FinisedWritingReply\", bytesRead, realTargetFile ) );\n\n        if ( addfilenameresult ) {\n          // Add to the result files...\n          ResultFile resultFile =\n            new ResultFile(\n              ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject( realTargetFile, this ), parentJob\n                .getJobname(), toString() );\n          result.getResultFiles().put( resultFile.getFile().toString(), resultFile );\n        }\n\n        result.setResult( true );\n      } catch ( MalformedURLException e ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.NotValidURL\", url, e.getMessage() ) );\n        logError( Const.getStackTracker( e ) );\n      } catch ( IOException e ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.CanNotSaveHTTPResult\", e.getMessage() ) );\n        logError( Const.getStackTracker( e ) );\n      } catch ( Exception e ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.ErrorGettingFromHTTP\", e.getMessage() ) );\n        logError( Const.getStackTracker( e ) );\n      } finally {\n        // Close it all\n        try {\n          if ( uploadStream != null ) {\n            uploadStream.close(); // just to make sure\n          }\n          if ( fileStream != null ) {\n            fileStream.close(); // just to make sure\n          }\n\n          if ( input != null ) {\n            input.close();\n          }\n          if ( outputFile != null ) {\n            outputFile.close();\n          }\n        } catch ( Exception e ) {\n          logError( BaseMessages.getString( PKG, \"JobHTTP.Error.CanNotCloseStream\", e.getMessage() ) );\n          result.setNrErrors( 1 );\n        }\n\n        // Set the proxy settings back as they were on the system!\n        System.setProperty( \"http.proxyHost\", Const.NVL( beforeProxyHost, \"\" ) );\n        System.setProperty( \"http.proxyPort\", Const.NVL( beforeProxyPort, \"\" ) );\n        System.setProperty( \"http.nonProxyHosts\", Const.NVL( beforeNonProxyHosts, \"\" ) );\n      }\n\n    }\n\n    return result;\n  }","id":77490,"modified_method":"/**\n   * We made this one synchronized in the JVM because otherwise, this is not thread safe. In that case if (on an\n   * application server for example) several HTTP's are running at the same time, you get into problems because the\n   * System.setProperty() calls are system wide!\n   */\n  @Override\n  public synchronized Result execute( Result previousResult, int nr ) {\n    Result result = previousResult;\n    result.setResult( false );\n\n    logBasic( BaseMessages.getString( PKG, \"JobHTTP.StartJobEntry\" ) );\n\n    // Get previous result rows...\n    List<RowMetaAndData> resultRows;\n    String urlFieldnameToUse, uploadFieldnameToUse, destinationFieldnameToUse;\n\n    if ( Const.isEmpty( urlFieldname ) ) {\n      urlFieldnameToUse = URL_FIELDNAME;\n    } else {\n      urlFieldnameToUse = urlFieldname;\n    }\n\n    if ( Const.isEmpty( uploadFieldname ) )  {\n      uploadFieldnameToUse = UPLOADFILE_FIELDNAME;\n    } else {\n      uploadFieldnameToUse = uploadFieldname;\n    }\n\n    if ( Const.isEmpty( destinationFieldname ) )  {\n      destinationFieldnameToUse = TARGETFILE_FIELDNAME;\n    } else {\n      destinationFieldnameToUse = destinationFieldname;\n    }\n\n    if ( runForEveryRow ) {\n      resultRows = previousResult.getRows();\n      if ( resultRows == null ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.UnableGetResultPrevious\" ) );\n        return result;\n      }\n    } else {\n      resultRows = new ArrayList<RowMetaAndData>();\n      RowMetaAndData row = new RowMetaAndData();\n      row.addValue(\n        new ValueMetaString( urlFieldnameToUse ), environmentSubstitute( url ) );\n      row.addValue(\n        new ValueMetaString( uploadFieldnameToUse ), environmentSubstitute( uploadFilename ) );\n      row.addValue(\n        new ValueMetaString( destinationFieldnameToUse ), environmentSubstitute( targetFilename ) );\n      resultRows.add( row );\n    }\n\n    URL server = null;\n\n    String beforeProxyHost = System.getProperty( \"http.proxyHost\" );\n    String beforeProxyPort = System.getProperty( \"http.proxyPort\" );\n    String beforeNonProxyHosts = System.getProperty( \"http.nonProxyHosts\" );\n\n    for ( int i = 0; i < resultRows.size() && result.getNrErrors() == 0; i++ ) {\n      RowMetaAndData row = resultRows.get( i );\n\n      OutputStream outputFile = null;\n      OutputStream uploadStream = null;\n      BufferedInputStream fileStream = null;\n      InputStream input = null;\n\n      try {\n        String urlToUse = environmentSubstitute( row.getString( urlFieldnameToUse, \"\" ) );\n        String realUploadFile = environmentSubstitute( row.getString( uploadFieldnameToUse, \"\" ) );\n        String realTargetFile = environmentSubstitute( row.getString(  destinationFieldnameToUse,  \"\" ) );\n\n        logBasic( BaseMessages.getString( PKG, \"JobHTTP.Log.ConnectingURL\", urlToUse ) );\n\n        if ( !Const.isEmpty( proxyHostname ) ) {\n          System.setProperty( \"http.proxyHost\", environmentSubstitute( proxyHostname ) );\n          System.setProperty( \"http.proxyPort\", environmentSubstitute( proxyPort ) );\n          if ( nonProxyHosts != null ) {\n            System.setProperty( \"http.nonProxyHosts\", environmentSubstitute( nonProxyHosts ) );\n          }\n        }\n\n        if ( !Const.isEmpty( username ) ) {\n          Authenticator.setDefault( new Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n              String realPassword = Encr.decryptPasswordOptionallyEncrypted( environmentSubstitute( password ) );\n              return new PasswordAuthentication( environmentSubstitute( username ), realPassword != null\n                ? realPassword.toCharArray() : new char[] {} );\n            }\n          } );\n        }\n\n        if ( dateTimeAdded ) {\n          SimpleDateFormat daf = new SimpleDateFormat();\n          Date now = new Date();\n\n          daf.applyPattern( \"yyyMMdd\" );\n          realTargetFile += \"_\" + daf.format( now );\n          daf.applyPattern( \"HHmmss\" );\n          realTargetFile += \"_\" + daf.format( now );\n\n          if ( !Const.isEmpty( targetFilenameExtension ) ) {\n            realTargetFile += \".\" + environmentSubstitute( targetFilenameExtension );\n          }\n        }\n\n        // Create the output File...\n        outputFile = KettleVFS.getOutputStream( realTargetFile, this, fileAppended );\n\n        // Get a stream for the specified URL\n        server = new URL( urlToUse );\n        URLConnection connection = server.openConnection();\n\n        // if we have HTTP headers, add them\n        if ( !Const.isEmpty( headerName ) ) {\n          if ( log.isDebug() ) {\n            log.logDebug( BaseMessages.getString( PKG, \"JobHTTP.Log.HeadersProvided\" ) );\n          }\n          for ( int j = 0; j < headerName.length; j++ ) {\n            if ( !Const.isEmpty( headerValue[j] ) ) {\n              connection.setRequestProperty(\n                environmentSubstitute( headerName[j] ), environmentSubstitute( headerValue[j] ) );\n              if ( log.isDebug() ) {\n                log.logDebug( BaseMessages.getString(\n                  PKG, \"JobHTTP.Log.HeaderSet\", environmentSubstitute( headerName[j] ),\n                  environmentSubstitute( headerValue[j] ) ) );\n              }\n            }\n          }\n        }\n\n        connection.setDoOutput( true );\n\n        // See if we need to send a file over?\n        if ( !Const.isEmpty( realUploadFile ) ) {\n          if ( log.isDetailed() ) {\n            logDetailed( BaseMessages.getString( PKG, \"JobHTTP.Log.SendingFile\", realUploadFile ) );\n          }\n\n          // Grab an output stream to upload data to web server\n          uploadStream = connection.getOutputStream();\n          fileStream = new BufferedInputStream( new FileInputStream( new File( realUploadFile ) ) );\n          try {\n            int c;\n            while ( ( c = fileStream.read() ) >= 0 ) {\n              uploadStream.write( c );\n            }\n          } finally {\n            // Close upload and file\n            if ( uploadStream != null ) {\n              uploadStream.close();\n              uploadStream = null;\n            }\n            if ( fileStream != null ) {\n              fileStream.close();\n              fileStream = null;\n            }\n          }\n          if ( log.isDetailed() ) {\n            logDetailed( BaseMessages.getString( PKG, \"JobHTTP.Log.FinishedSendingFile\" ) );\n          }\n        }\n\n        if ( log.isDetailed() ) {\n          logDetailed( BaseMessages.getString( PKG, \"JobHTTP.Log.StartReadingReply\" ) );\n        }\n\n        // Read the result from the server...\n        input = connection.getInputStream();\n        Date date = new Date( connection.getLastModified() );\n        logBasic( BaseMessages.getString( PKG, \"JobHTTP.Log.ReplayInfo\", connection.getContentType(), date ) );\n\n        int oneChar;\n        long bytesRead = 0L;\n        while ( ( oneChar = input.read() ) != -1 ) {\n          outputFile.write( oneChar );\n          bytesRead++;\n        }\n\n        logBasic( BaseMessages.getString( PKG, \"JobHTTP.Log.FinisedWritingReply\", bytesRead, realTargetFile ) );\n\n        if ( addfilenameresult ) {\n          // Add to the result files...\n          ResultFile resultFile =\n            new ResultFile(\n              ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject( realTargetFile, this ), parentJob\n                .getJobname(), toString() );\n          result.getResultFiles().put( resultFile.getFile().toString(), resultFile );\n        }\n\n        result.setResult( true );\n      } catch ( MalformedURLException e ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.NotValidURL\", url, e.getMessage() ) );\n        logError( Const.getStackTracker( e ) );\n      } catch ( IOException e ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.CanNotSaveHTTPResult\", e.getMessage() ) );\n        logError( Const.getStackTracker( e ) );\n      } catch ( Exception e ) {\n        result.setNrErrors( 1 );\n        logError( BaseMessages.getString( PKG, \"JobHTTP.Error.ErrorGettingFromHTTP\", e.getMessage() ) );\n        logError( Const.getStackTracker( e ) );\n      } finally {\n        // Close it all\n        try {\n          if ( uploadStream != null ) {\n            uploadStream.close(); // just to make sure\n          }\n          if ( fileStream != null ) {\n            fileStream.close(); // just to make sure\n          }\n\n          if ( input != null ) {\n            input.close();\n          }\n          if ( outputFile != null ) {\n            outputFile.close();\n          }\n        } catch ( Exception e ) {\n          logError( BaseMessages.getString( PKG, \"JobHTTP.Error.CanNotCloseStream\", e.getMessage() ) );\n          result.setNrErrors( 1 );\n        }\n\n        // Set the proxy settings back as they were on the system!\n        System.setProperty( \"http.proxyHost\", Const.NVL( beforeProxyHost, \"\" ) );\n        System.setProperty( \"http.proxyPort\", Const.NVL( beforeProxyPort, \"\" ) );\n        System.setProperty( \"http.nonProxyHosts\", Const.NVL( beforeNonProxyHosts, \"\" ) );\n      }\n\n    }\n\n    return result;\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @return Returns the uploadFilenameExtention.\n   */\n  public String getTargetFilenameExtention() {\n    return targetFilenameExtention;\n  }","id":77491,"modified_method":"/**\n   * @return Returns the uploadFilenameExtension.\n   * @deprecated Use {@link JobEntryHTTP#getTargetFilenameExtension()} instead\n   */\n  @Deprecated\n  public String getTargetFilenameExtention() {\n    return targetFilenameExtension;\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_job ) throws KettleException {\n    try {\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"url\", url );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"targetfilename\", targetFilename );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"file_appended\", fileAppended );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"date_time_added\", dateTimeAdded );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"targetfilename_extention\", targetFilenameExtention );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"uploadfilename\", uploadFilename );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"url_fieldname\", urlFieldname );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"run_every_row\", runForEveryRow );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"username\", username );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"password\", Encr\n        .encryptPasswordIfNotUsingVariables( password ) );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"proxy_host\", proxyHostname );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"proxy_port\", proxyPort );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"non_proxy_hosts\", nonProxyHosts );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"addfilenameresult\", addfilenameresult );\n      if ( headerName != null ) {\n        for ( int i = 0; i < headerName.length; i++ ) {\n          rep.saveJobEntryAttribute( id_job, getObjectId(), i, \"header_name\", headerName[i] );\n          rep.saveJobEntryAttribute( id_job, getObjectId(), i, \"header_value\", headerValue[i] );\n        }\n      }\n    } catch ( KettleDatabaseException dbe ) {\n      throw new KettleException(\n        \"Unable to load job entry of type 'HTTP' to the repository for id_job=\" + id_job, dbe );\n    }\n  }","id":77492,"modified_method":"@Override\n  public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_job ) throws KettleException {\n    try {\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"url\", url );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"targetfilename\", targetFilename );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"file_appended\", fileAppended );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"date_time_added\", dateTimeAdded );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"targetfilename_extension\", targetFilenameExtension );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"uploadfilename\", uploadFilename );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"url_fieldname\", urlFieldname );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"upload_fieldname\", uploadFieldname );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"dest_fieldname\", destinationFieldname );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"run_every_row\", runForEveryRow );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"username\", username );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"password\", Encr\n        .encryptPasswordIfNotUsingVariables( password ) );\n\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"proxy_host\", proxyHostname );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"proxy_port\", proxyPort );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"non_proxy_hosts\", nonProxyHosts );\n      rep.saveJobEntryAttribute( id_job, getObjectId(), \"addfilenameresult\", addfilenameresult );\n      if ( headerName != null ) {\n        for ( int i = 0; i < headerName.length; i++ ) {\n          rep.saveJobEntryAttribute( id_job, getObjectId(), i, \"header_name\", headerName[i] );\n          rep.saveJobEntryAttribute( id_job, getObjectId(), i, \"header_value\", headerValue[i] );\n        }\n      }\n    } catch ( KettleDatabaseException dbe ) {\n      throw new KettleException(\n        \"Unable to load job entry of type 'HTTP' to the repository for id_job=\" + id_job, dbe );\n    }\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public void loadXML( Node entrynode, List<DatabaseMeta> databases, List<SlaveServer> slaveServers,\n    Repository rep, IMetaStore metaStore ) throws KettleXMLException {\n    try {\n      super.loadXML( entrynode, databases, slaveServers );\n      url = XMLHandler.getTagValue( entrynode, \"url\" );\n      targetFilename = XMLHandler.getTagValue( entrynode, \"targetfilename\" );\n      fileAppended = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( entrynode, \"file_appended\" ) );\n      dateTimeAdded = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( entrynode, \"date_time_added\" ) );\n      targetFilenameExtention = XMLHandler.getTagValue( entrynode, \"targetfilename_extention\" );\n\n      uploadFilename = XMLHandler.getTagValue( entrynode, \"uploadfilename\" );\n\n      urlFieldname = XMLHandler.getTagValue( entrynode, \"url_fieldname\" );\n      runForEveryRow = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( entrynode, \"run_every_row\" ) );\n\n      username = XMLHandler.getTagValue( entrynode, \"username\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( entrynode, \"password\" ) );\n\n      proxyHostname = XMLHandler.getTagValue( entrynode, \"proxy_host\" );\n      proxyPort = XMLHandler.getTagValue( entrynode, \"proxy_port\" );\n      nonProxyHosts = XMLHandler.getTagValue( entrynode, \"non_proxy_hosts\" );\n      addfilenameresult =\n        \"Y\".equalsIgnoreCase( Const.NVL( XMLHandler.getTagValue( entrynode, \"addfilenameresult\" ), \"Y\" ) );\n      Node headers = XMLHandler.getSubNode( entrynode, \"headers\" );\n\n      // How many field headerName?\n      int nrHeaders = XMLHandler.countNodes( headers, \"header\" );\n      allocate( nrHeaders );\n      for ( int i = 0; i < nrHeaders; i++ ) {\n        Node fnode = XMLHandler.getSubNodeByNr( headers, \"header\", i );\n        headerName[i] = XMLHandler.getTagValue( fnode, \"header_name\" );\n        headerValue[i] = XMLHandler.getTagValue( fnode, \"header_value\" );\n      }\n    } catch ( KettleXMLException xe ) {\n      throw new KettleXMLException( \"Unable to load job entry of type 'HTTP' from XML node\", xe );\n    }\n  }","id":77493,"modified_method":"@Override\n  public void loadXML( Node entrynode, List<DatabaseMeta> databases, List<SlaveServer> slaveServers,\n    Repository rep, IMetaStore metaStore ) throws KettleXMLException {\n    try {\n      super.loadXML( entrynode, databases, slaveServers );\n      url = XMLHandler.getTagValue( entrynode, \"url\" );\n      targetFilename = XMLHandler.getTagValue( entrynode, \"targetfilename\" );\n      fileAppended = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( entrynode, \"file_appended\" ) );\n      dateTimeAdded = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( entrynode, \"date_time_added\" ) );\n      targetFilenameExtension = Const.NVL( XMLHandler.getTagValue( entrynode, \"targetfilename_extension\" ),\n          XMLHandler.getTagValue( entrynode, \"targetfilename_extention\" ) );\n\n      uploadFilename = XMLHandler.getTagValue( entrynode, \"uploadfilename\" );\n\n      urlFieldname = XMLHandler.getTagValue( entrynode, \"url_fieldname\" );\n      uploadFieldname = XMLHandler.getTagValue( entrynode, \"upload_fieldname\" );\n      destinationFieldname = XMLHandler.getTagValue( entrynode, \"dest_fieldname\" );\n      runForEveryRow = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( entrynode, \"run_every_row\" ) );\n\n      username = XMLHandler.getTagValue( entrynode, \"username\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( entrynode, \"password\" ) );\n\n      proxyHostname = XMLHandler.getTagValue( entrynode, \"proxy_host\" );\n      proxyPort = XMLHandler.getTagValue( entrynode, \"proxy_port\" );\n      nonProxyHosts = XMLHandler.getTagValue( entrynode, \"non_proxy_hosts\" );\n      addfilenameresult =\n        \"Y\".equalsIgnoreCase( Const.NVL( XMLHandler.getTagValue( entrynode, \"addfilenameresult\" ), \"Y\" ) );\n      Node headers = XMLHandler.getSubNode( entrynode, \"headers\" );\n\n      // How many field headerName?\n      int nrHeaders = XMLHandler.countNodes( headers, \"header\" );\n      allocate( nrHeaders );\n      for ( int i = 0; i < nrHeaders; i++ ) {\n        Node fnode = XMLHandler.getSubNodeByNr( headers, \"header\", i );\n        headerName[i] = XMLHandler.getTagValue( fnode, \"header_name\" );\n        headerValue[i] = XMLHandler.getTagValue( fnode, \"header_value\" );\n      }\n    } catch ( KettleXMLException xe ) {\n      throw new KettleXMLException( \"Unable to load job entry of type 'HTTP' from XML node\", xe );\n    }\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @param uploadFilenameExtention\n   *          The uploadFilenameExtention to set.\n   */\n  public void setTargetFilenameExtention( String uploadFilenameExtention ) {\n    this.targetFilenameExtention = uploadFilenameExtention;\n  }","id":77494,"modified_method":"/**\n   * @param uploadFilenameExtension\n   *          The uploadFilenameExtension to set.\n   * @deprecated Use {@link JobEntryHTTP#setTargetFilenameExtension( String uploadFilenameExtension )} instead\n   */\n  @Deprecated\n  public void setTargetFilenameExtention( String uploadFilenameExtension ) {\n    this.targetFilenameExtension = uploadFilenameExtension;\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public void loadRep( Repository rep, IMetaStore metaStore, ObjectId id_jobentry, List<DatabaseMeta> databases,\n    List<SlaveServer> slaveServers ) throws KettleException {\n    try {\n      url = rep.getJobEntryAttributeString( id_jobentry, \"url\" );\n      targetFilename = rep.getJobEntryAttributeString( id_jobentry, \"targetfilename\" );\n      fileAppended = rep.getJobEntryAttributeBoolean( id_jobentry, \"file_appended\" );\n      dateTimeAdded = rep.getJobEntryAttributeBoolean( id_jobentry, \"date_time_added\" );\n      targetFilenameExtention = rep.getJobEntryAttributeString( id_jobentry, \"targetfilename_extention\" );\n\n      uploadFilename = rep.getJobEntryAttributeString( id_jobentry, \"uploadfilename\" );\n\n      urlFieldname = rep.getJobEntryAttributeString( id_jobentry, \"url_fieldname\" );\n      runForEveryRow = rep.getJobEntryAttributeBoolean( id_jobentry, \"run_every_row\" );\n\n      username = rep.getJobEntryAttributeString( id_jobentry, \"username\" );\n      password =\n        Encr.decryptPasswordOptionallyEncrypted( rep.getJobEntryAttributeString( id_jobentry, \"password\" ) );\n\n      proxyHostname = rep.getJobEntryAttributeString( id_jobentry, \"proxy_host\" );\n      proxyPort = rep.getJobEntryAttributeString( id_jobentry, \"proxy_port\" ); // backward compatible.\n\n      nonProxyHosts = rep.getJobEntryAttributeString( id_jobentry, \"non_proxy_hosts\" );\n      addfilenameresult =\n        \"Y\".equalsIgnoreCase( Const\n          .NVL( rep.getJobEntryAttributeString( id_jobentry, \"addfilenameresult\" ), \"Y\" ) );\n\n      // How many headerName?\n      int argnr = rep.countNrJobEntryAttributes( id_jobentry, \"header_name\" );\n      allocate( argnr );\n\n      for ( int a = 0; a < argnr; a++ ) {\n        headerName[a] = rep.getJobEntryAttributeString( id_jobentry, a, \"header_name\" );\n        headerValue[a] = rep.getJobEntryAttributeString( id_jobentry, a, \"header_value\" );\n      }\n    } catch ( KettleException dbe ) {\n      throw new KettleException( \"Unable to load job entry of type 'HTTP' from the repository for id_jobentry=\"\n        + id_jobentry, dbe );\n    }\n  }","id":77495,"modified_method":"@Override\n  public void loadRep( Repository rep, IMetaStore metaStore, ObjectId id_jobentry, List<DatabaseMeta> databases,\n    List<SlaveServer> slaveServers ) throws KettleException {\n    try {\n      url = rep.getJobEntryAttributeString( id_jobentry, \"url\" );\n      targetFilename = rep.getJobEntryAttributeString( id_jobentry, \"targetfilename\" );\n      fileAppended = rep.getJobEntryAttributeBoolean( id_jobentry, \"file_appended\" );\n      dateTimeAdded = rep.getJobEntryAttributeBoolean( id_jobentry, \"date_time_added\" );\n      targetFilenameExtension = Const.NVL( rep.getJobEntryAttributeString( id_jobentry, \"targetfilename_extension\" ),\n          rep.getJobEntryAttributeString( id_jobentry, \"targetfilename_extention\" ) );\n\n      uploadFilename = rep.getJobEntryAttributeString( id_jobentry, \"uploadfilename\" );\n\n      urlFieldname = rep.getJobEntryAttributeString( id_jobentry, \"url_fieldname\" );\n      uploadFieldname = rep.getJobEntryAttributeString( id_jobentry, \"upload_fieldname\" );\n      destinationFieldname = rep.getJobEntryAttributeString( id_jobentry, \"dest_fieldname\" );\n      runForEveryRow = rep.getJobEntryAttributeBoolean( id_jobentry, \"run_every_row\" );\n\n      username = rep.getJobEntryAttributeString( id_jobentry, \"username\" );\n      password =\n        Encr.decryptPasswordOptionallyEncrypted( rep.getJobEntryAttributeString( id_jobentry, \"password\" ) );\n\n      proxyHostname = rep.getJobEntryAttributeString( id_jobentry, \"proxy_host\" );\n      proxyPort = rep.getJobEntryAttributeString( id_jobentry, \"proxy_port\" ); // backward compatible.\n\n      nonProxyHosts = rep.getJobEntryAttributeString( id_jobentry, \"non_proxy_hosts\" );\n      addfilenameresult =\n        \"Y\".equalsIgnoreCase( Const\n          .NVL( rep.getJobEntryAttributeString( id_jobentry, \"addfilenameresult\" ), \"Y\" ) );\n\n      // How many headerName?\n      int argnr = rep.countNrJobEntryAttributes( id_jobentry, \"header_name\" );\n      allocate( argnr );\n\n      for ( int a = 0; a < argnr; a++ ) {\n        headerName[a] = rep.getJobEntryAttributeString( id_jobentry, a, \"header_name\" );\n        headerValue[a] = rep.getJobEntryAttributeString( id_jobentry, a, \"header_value\" );\n      }\n    } catch ( KettleException dbe ) {\n      throw new KettleException( \"Unable to load job entry of type 'HTTP' from the repository for id_jobentry=\"\n        + id_jobentry, dbe );\n    }\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public String getXML() {\n    StringBuilder retval = new StringBuilder( 300 );\n\n    retval.append( super.getXML() );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"url\", url ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"targetfilename\", targetFilename ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"file_appended\", fileAppended ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"date_time_added\", dateTimeAdded ) );\n    retval\n      .append( \"      \" ).append( XMLHandler.addTagValue( \"targetfilename_extention\", targetFilenameExtention ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"uploadfilename\", uploadFilename ) );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"url_fieldname\", urlFieldname ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"run_every_row\", runForEveryRow ) );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"username\", username ) );\n    retval.append( \"      \" ).append(\n      XMLHandler.addTagValue( \"password\", Encr.encryptPasswordIfNotUsingVariables( password ) ) );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"proxy_host\", proxyHostname ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"proxy_port\", proxyPort ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"non_proxy_hosts\", nonProxyHosts ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"addfilenameresult\", addfilenameresult ) );\n    retval.append( \"      <headers>\" ).append( Const.CR );\n    if ( headerName != null ) {\n      for ( int i = 0; i < headerName.length; i++ ) {\n        retval.append( \"        <header>\" ).append( Const.CR );\n        retval.append( \"          \" ).append( XMLHandler.addTagValue( \"header_name\", headerName[i] ) );\n        retval.append( \"          \" ).append( XMLHandler.addTagValue( \"header_value\", headerValue[i] ) );\n        retval.append( \"        <\/header>\" ).append( Const.CR );\n      }\n    }\n    retval.append( \"      <\/headers>\" ).append( Const.CR );\n\n    return retval.toString();\n  }","id":77496,"modified_method":"@Override\n  public String getXML() {\n    StringBuilder retval = new StringBuilder( 300 );\n\n    retval.append( super.getXML() );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"url\", url ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"targetfilename\", targetFilename ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"file_appended\", fileAppended ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"date_time_added\", dateTimeAdded ) );\n    retval\n      .append( \"      \" ).append( XMLHandler.addTagValue( \"targetfilename_extension\", targetFilenameExtension ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"uploadfilename\", uploadFilename ) );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"run_every_row\", runForEveryRow ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"url_fieldname\", urlFieldname ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"upload_fieldname\", uploadFieldname ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"dest_fieldname\", destinationFieldname ) );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"username\", username ) );\n    retval.append( \"      \" ).append(\n      XMLHandler.addTagValue( \"password\", Encr.encryptPasswordIfNotUsingVariables( password ) ) );\n\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"proxy_host\", proxyHostname ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"proxy_port\", proxyPort ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"non_proxy_hosts\", nonProxyHosts ) );\n    retval.append( \"      \" ).append( XMLHandler.addTagValue( \"addfilenameresult\", addfilenameresult ) );\n    retval.append( \"      <headers>\" ).append( Const.CR );\n    if ( headerName != null ) {\n      for ( int i = 0; i < headerName.length; i++ ) {\n        retval.append( \"        <header>\" ).append( Const.CR );\n        retval.append( \"          \" ).append( XMLHandler.addTagValue( \"header_name\", headerName[i] ) );\n        retval.append( \"          \" ).append( XMLHandler.addTagValue( \"header_value\", headerValue[i] ) );\n        retval.append( \"        <\/header>\" ).append( Const.CR );\n      }\n    }\n    retval.append( \"      <\/headers>\" ).append( Const.CR );\n\n    return retval.toString();\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobHTTP.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Job entry name line\n    wlName = new Label( shell, SWT.RIGHT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobHTTP.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( middle, 0 );\n    fdName.top = new FormAttachment( 0, margin );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobHTTP.Tab.General.Label\" ) );\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // URL line\n    wlURL = new Label( wGeneralComp, SWT.RIGHT );\n    wlURL.setText( BaseMessages.getString( PKG, \"JobHTTP.URL.Label\" ) );\n    props.setLook( wlURL );\n    fdlURL = new FormData();\n    fdlURL.left = new FormAttachment( 0, 0 );\n    fdlURL.top = new FormAttachment( wName, 2 * margin );\n    fdlURL.right = new FormAttachment( middle, -margin );\n    wlURL.setLayoutData( fdlURL );\n    wURL =\n      new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobHTTP.URL.Tooltip\" ) );\n    props.setLook( wURL );\n    wURL.addModifyListener( lsMod );\n    fdURL = new FormData();\n    fdURL.left = new FormAttachment( middle, 0 );\n    fdURL.top = new FormAttachment( wName, 2 * margin );\n    fdURL.right = new FormAttachment( 100, 0 );\n    wURL.setLayoutData( fdURL );\n\n    // RunEveryRow line\n    wlRunEveryRow = new Label( wGeneralComp, SWT.RIGHT );\n    wlRunEveryRow.setText( BaseMessages.getString( PKG, \"JobHTTP.RunForEveryRow.Label\" ) );\n    props.setLook( wlRunEveryRow );\n    fdlRunEveryRow = new FormData();\n    fdlRunEveryRow.left = new FormAttachment( 0, 0 );\n    fdlRunEveryRow.top = new FormAttachment( wURL, margin );\n    fdlRunEveryRow.right = new FormAttachment( middle, -margin );\n    wlRunEveryRow.setLayoutData( fdlRunEveryRow );\n    wRunEveryRow = new Button( wGeneralComp, SWT.CHECK );\n    wRunEveryRow.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.RunForEveryRow.Tooltip\" ) );\n    props.setLook( wRunEveryRow );\n    fdRunEveryRow = new FormData();\n    fdRunEveryRow.left = new FormAttachment( middle, 0 );\n    fdRunEveryRow.top = new FormAttachment( wURL, margin );\n    fdRunEveryRow.right = new FormAttachment( 100, 0 );\n    wRunEveryRow.setLayoutData( fdRunEveryRow );\n    wRunEveryRow.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        setFlags();\n      }\n    } );\n\n    // FieldURL line\n    wlFieldURL = new Label( wGeneralComp, SWT.RIGHT );\n    wlFieldURL.setText( BaseMessages.getString( PKG, \"JobHTTP.InputField.Label\" ) );\n    props.setLook( wlFieldURL );\n    fdlFieldURL = new FormData();\n    fdlFieldURL.left = new FormAttachment( 0, 0 );\n    fdlFieldURL.top = new FormAttachment( wRunEveryRow, margin );\n    fdlFieldURL.right = new FormAttachment( middle, -margin );\n    wlFieldURL.setLayoutData( fdlFieldURL );\n    wFieldURL = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wFieldURL );\n    wFieldURL.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.InputField.Tooltip\" ) );\n    wFieldURL.addModifyListener( lsMod );\n    fdFieldURL = new FormData();\n    fdFieldURL.left = new FormAttachment( middle, 0 );\n    fdFieldURL.top = new FormAttachment( wRunEveryRow, margin );\n    fdFieldURL.right = new FormAttachment( 100, 0 );\n    wFieldURL.setLayoutData( fdFieldURL );\n\n    // ////////////////////////\n    // START OF AuthenticationGROUP///\n    // /\n    wAuthentication = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wAuthentication );\n    wAuthentication.setText( BaseMessages.getString( PKG, \"JobHTTP.Authentication.Group.Label\" ) );\n\n    FormLayout AuthenticationgroupLayout = new FormLayout();\n    AuthenticationgroupLayout.marginWidth = 10;\n    AuthenticationgroupLayout.marginHeight = 10;\n    wAuthentication.setLayout( AuthenticationgroupLayout );\n\n    // UserName line\n    wlUserName = new Label( wAuthentication, SWT.RIGHT );\n    wlUserName.setText( BaseMessages.getString( PKG, \"JobHTTP.UploadUser.Label\" ) );\n    props.setLook( wlUserName );\n    fdlUserName = new FormData();\n    fdlUserName.left = new FormAttachment( 0, 0 );\n    fdlUserName.top = new FormAttachment( wFieldURL, margin );\n    fdlUserName.right = new FormAttachment( middle, -margin );\n    wlUserName.setLayoutData( fdlUserName );\n    wUserName = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wUserName );\n    wUserName.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.UploadUser.Tooltip\" ) );\n    wUserName.addModifyListener( lsMod );\n    fdUserName = new FormData();\n    fdUserName.left = new FormAttachment( middle, 0 );\n    fdUserName.top = new FormAttachment( wFieldURL, margin );\n    fdUserName.right = new FormAttachment( 100, 0 );\n    wUserName.setLayoutData( fdUserName );\n\n    // Password line\n    wlPassword = new Label( wAuthentication, SWT.RIGHT );\n    wlPassword.setText( BaseMessages.getString( PKG, \"JobHTTP.UploadPassword.Label\" ) );\n    props.setLook( wlPassword );\n    fdlPassword = new FormData();\n    fdlPassword.left = new FormAttachment( 0, 0 );\n    fdlPassword.top = new FormAttachment( wUserName, margin );\n    fdlPassword.right = new FormAttachment( middle, -margin );\n    wlPassword.setLayoutData( fdlPassword );\n    wPassword = new PasswordTextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wPassword );\n    wPassword.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.UploadPassword.Tooltip\" ) );\n    wPassword.addModifyListener( lsMod );\n    fdPassword = new FormData();\n    fdPassword.left = new FormAttachment( middle, 0 );\n    fdPassword.top = new FormAttachment( wUserName, margin );\n    fdPassword.right = new FormAttachment( 100, 0 );\n    wPassword.setLayoutData( fdPassword );\n\n    // ProxyServer line\n    wlProxyServer = new Label( wAuthentication, SWT.RIGHT );\n    wlProxyServer.setText( BaseMessages.getString( PKG, \"JobHTTP.ProxyHost.Label\" ) );\n    props.setLook( wlProxyServer );\n    fdlProxyServer = new FormData();\n    fdlProxyServer.left = new FormAttachment( 0, 0 );\n    fdlProxyServer.top = new FormAttachment( wPassword, 3 * margin );\n    fdlProxyServer.right = new FormAttachment( middle, -margin );\n    wlProxyServer.setLayoutData( fdlProxyServer );\n    wProxyServer = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wProxyServer );\n    wProxyServer.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.ProxyHost.Tooltip\" ) );\n    wProxyServer.addModifyListener( lsMod );\n    fdProxyServer = new FormData();\n    fdProxyServer.left = new FormAttachment( middle, 0 );\n    fdProxyServer.top = new FormAttachment( wPassword, 3 * margin );\n    fdProxyServer.right = new FormAttachment( 100, 0 );\n    wProxyServer.setLayoutData( fdProxyServer );\n\n    // ProxyPort line\n    wlProxyPort = new Label( wAuthentication, SWT.RIGHT );\n    wlProxyPort.setText( BaseMessages.getString( PKG, \"JobHTTP.ProxyPort.Label\" ) );\n    props.setLook( wlProxyPort );\n    fdlProxyPort = new FormData();\n    fdlProxyPort.left = new FormAttachment( 0, 0 );\n    fdlProxyPort.top = new FormAttachment( wProxyServer, margin );\n    fdlProxyPort.right = new FormAttachment( middle, -margin );\n    wlProxyPort.setLayoutData( fdlProxyPort );\n    wProxyPort = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wProxyPort );\n    wProxyPort.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.ProxyPort.Tooltip\" ) );\n    wProxyPort.addModifyListener( lsMod );\n    fdProxyPort = new FormData();\n    fdProxyPort.left = new FormAttachment( middle, 0 );\n    fdProxyPort.top = new FormAttachment( wProxyServer, margin );\n    fdProxyPort.right = new FormAttachment( 100, 0 );\n    wProxyPort.setLayoutData( fdProxyPort );\n\n    // IgnoreHosts line\n    wlNonProxyHosts = new Label( wAuthentication, SWT.RIGHT );\n    wlNonProxyHosts.setText( BaseMessages.getString( PKG, \"JobHTTP.ProxyIgnoreRegexp.Label\" ) );\n    props.setLook( wlNonProxyHosts );\n    fdlNonProxyHosts = new FormData();\n    fdlNonProxyHosts.left = new FormAttachment( 0, 0 );\n    fdlNonProxyHosts.top = new FormAttachment( wProxyPort, margin );\n    fdlNonProxyHosts.right = new FormAttachment( middle, -margin );\n    wlNonProxyHosts.setLayoutData( fdlNonProxyHosts );\n    wNonProxyHosts = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wNonProxyHosts );\n    wNonProxyHosts.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.ProxyIgnoreRegexp.Tooltip\" ) );\n    wNonProxyHosts.addModifyListener( lsMod );\n    fdNonProxyHosts = new FormData();\n    fdNonProxyHosts.left = new FormAttachment( middle, 0 );\n    fdNonProxyHosts.top = new FormAttachment( wProxyPort, margin );\n    fdNonProxyHosts.right = new FormAttachment( 100, 0 );\n    wNonProxyHosts.setLayoutData( fdNonProxyHosts );\n\n    fdAuthentication = new FormData();\n    fdAuthentication.left = new FormAttachment( 0, margin );\n    fdAuthentication.top = new FormAttachment( wFieldURL, margin );\n    fdAuthentication.right = new FormAttachment( 100, -margin );\n    wAuthentication.setLayoutData( fdAuthentication );\n    // ///////////////////////////////////////////////////////////\n    // / END OF AuthenticationGROUP GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF UpLoadFileGROUP///\n    // /\n    wUpLoadFile = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wUpLoadFile );\n    wUpLoadFile.setText( BaseMessages.getString( PKG, \"JobHTTP.UpLoadFile.Group.Label\" ) );\n\n    FormLayout UpLoadFilegroupLayout = new FormLayout();\n    UpLoadFilegroupLayout.marginWidth = 10;\n    UpLoadFilegroupLayout.marginHeight = 10;\n    wUpLoadFile.setLayout( UpLoadFilegroupLayout );\n\n    // UploadFile line\n    wlUploadFile = new Label( wUpLoadFile, SWT.RIGHT );\n    wlUploadFile.setText( BaseMessages.getString( PKG, \"JobHTTP.UploadFile.Label\" ) );\n    props.setLook( wlUploadFile );\n    fdlUploadFile = new FormData();\n    fdlUploadFile.left = new FormAttachment( 0, 0 );\n    fdlUploadFile.top = new FormAttachment( wAuthentication, margin );\n    fdlUploadFile.right = new FormAttachment( middle, -margin );\n    wlUploadFile.setLayoutData( fdlUploadFile );\n\n    wbUploadFile = new Button( wUpLoadFile, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbUploadFile );\n    wbUploadFile.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbUploadFile = new FormData();\n    fdbUploadFile.right = new FormAttachment( 100, 0 );\n    fdbUploadFile.top = new FormAttachment( wAuthentication, margin );\n    wbUploadFile.setLayoutData( fdbUploadFile );\n\n    wUploadFile = new TextVar( jobMeta, wUpLoadFile, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wUploadFile );\n    wUploadFile.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.UploadFile.Tooltip\" ) );\n    wUploadFile.addModifyListener( lsMod );\n    fdUploadFile = new FormData();\n    fdUploadFile.left = new FormAttachment( middle, 0 );\n    fdUploadFile.top = new FormAttachment( wAuthentication, margin );\n    fdUploadFile.right = new FormAttachment( wbUploadFile, -margin );\n    wUploadFile.setLayoutData( fdUploadFile );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wUploadFile.addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        wUploadFile.setToolTipText( jobMeta.environmentSubstitute( wUploadFile.getText() ) );\n      }\n    } );\n\n    wbUploadFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wUploadFile.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wUploadFile.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wUploadFile.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    fdUpLoadFile = new FormData();\n    fdUpLoadFile.left = new FormAttachment( 0, margin );\n    fdUpLoadFile.top = new FormAttachment( wAuthentication, margin );\n    fdUpLoadFile.right = new FormAttachment( 100, -margin );\n    wUpLoadFile.setLayoutData( fdUpLoadFile );\n    // ///////////////////////////////////////////////////////////\n    // / END OF UpLoadFileGROUP GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF TargetFileGroupGROUP///\n    // /\n    wTargetFileGroup = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wTargetFileGroup );\n    wTargetFileGroup.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileGroup.Group.Label\" ) );\n\n    FormLayout TargetFileGroupgroupLayout = new FormLayout();\n    TargetFileGroupgroupLayout.marginWidth = 10;\n    TargetFileGroupgroupLayout.marginHeight = 10;\n    wTargetFileGroup.setLayout( TargetFileGroupgroupLayout );\n\n    // TargetFile line\n    wlTargetFile = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlTargetFile.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFile.Label\" ) );\n    props.setLook( wlTargetFile );\n    fdlTargetFile = new FormData();\n    fdlTargetFile.left = new FormAttachment( 0, 0 );\n    fdlTargetFile.top = new FormAttachment( wUploadFile, margin );\n    fdlTargetFile.right = new FormAttachment( middle, -margin );\n    wlTargetFile.setLayoutData( fdlTargetFile );\n\n    wbTargetFile = new Button( wTargetFileGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTargetFile );\n    wbTargetFile.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbTargetFile = new FormData();\n    fdbTargetFile.right = new FormAttachment( 100, 0 );\n    fdbTargetFile.top = new FormAttachment( wUploadFile, margin );\n    wbTargetFile.setLayoutData( fdbTargetFile );\n\n    wTargetFile = new TextVar( jobMeta, wTargetFileGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wTargetFile );\n    wTargetFile.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFile.Tooltip\" ) );\n    wTargetFile.addModifyListener( lsMod );\n    fdTargetFile = new FormData();\n    fdTargetFile.left = new FormAttachment( middle, 0 );\n    fdTargetFile.top = new FormAttachment( wUploadFile, margin );\n    fdTargetFile.right = new FormAttachment( wbTargetFile, -margin );\n    wTargetFile.setLayoutData( fdTargetFile );\n\n    wbTargetFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.SAVE );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wTargetFile.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wTargetFile.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wTargetFile.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Append line\n    wlAppend = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlAppend.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileAppend.Label\" ) );\n    props.setLook( wlAppend );\n    fdlAppend = new FormData();\n    fdlAppend.left = new FormAttachment( 0, 0 );\n    fdlAppend.top = new FormAttachment( wTargetFile, margin );\n    fdlAppend.right = new FormAttachment( middle, -margin );\n    wlAppend.setLayoutData( fdlAppend );\n    wAppend = new Button( wTargetFileGroup, SWT.CHECK );\n    props.setLook( wAppend );\n    wAppend.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileAppend.Tooltip\" ) );\n    fdAppend = new FormData();\n    fdAppend.left = new FormAttachment( middle, 0 );\n    fdAppend.top = new FormAttachment( wTargetFile, margin );\n    fdAppend.right = new FormAttachment( 100, 0 );\n    wAppend.setLayoutData( fdAppend );\n\n    // DateTimeAdded line\n    wlDateTimeAdded = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlDateTimeAdded.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFilenameAddDate.Label\" ) );\n    props.setLook( wlDateTimeAdded );\n    fdlDateTimeAdded = new FormData();\n    fdlDateTimeAdded.left = new FormAttachment( 0, 0 );\n    fdlDateTimeAdded.top = new FormAttachment( wAppend, margin );\n    fdlDateTimeAdded.right = new FormAttachment( middle, -margin );\n    wlDateTimeAdded.setLayoutData( fdlDateTimeAdded );\n    wDateTimeAdded = new Button( wTargetFileGroup, SWT.CHECK );\n    props.setLook( wDateTimeAdded );\n    wDateTimeAdded.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFilenameAddDate.Tooltip\" ) );\n    fdDateTimeAdded = new FormData();\n    fdDateTimeAdded.left = new FormAttachment( middle, 0 );\n    fdDateTimeAdded.top = new FormAttachment( wAppend, margin );\n    fdDateTimeAdded.right = new FormAttachment( 100, 0 );\n    wDateTimeAdded.setLayoutData( fdDateTimeAdded );\n    wDateTimeAdded.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        setFlags();\n      }\n    } );\n\n    // TargetExt line\n    wlTargetExt = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlTargetExt.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileExt.Label\" ) );\n    props.setLook( wlTargetExt );\n    fdlTargetExt = new FormData();\n    fdlTargetExt.left = new FormAttachment( 0, 0 );\n    fdlTargetExt.top = new FormAttachment( wDateTimeAdded, margin );\n    fdlTargetExt.right = new FormAttachment( middle, -margin );\n    wlTargetExt.setLayoutData( fdlTargetExt );\n    wTargetExt = new TextVar( jobMeta, wTargetFileGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wTargetExt );\n    wTargetExt.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileExt.Tooltip\" ) );\n    wTargetExt.addModifyListener( lsMod );\n    fdTargetExt = new FormData();\n    fdTargetExt.left = new FormAttachment( middle, 0 );\n    fdTargetExt.top = new FormAttachment( wDateTimeAdded, margin );\n    fdTargetExt.right = new FormAttachment( 100, 0 );\n    wTargetExt.setLayoutData( fdTargetExt );\n\n    // Add filenames to result filenames...\n    wlAddFilenameToResult = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlAddFilenameToResult.setText( BaseMessages.getString( PKG, \"JobHTTP.AddFilenameToResult.Label\" ) );\n    props.setLook( wlAddFilenameToResult );\n    fdlAddFilenameToResult = new FormData();\n    fdlAddFilenameToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFilenameToResult.top = new FormAttachment( wTargetExt, margin );\n    fdlAddFilenameToResult.right = new FormAttachment( middle, -margin );\n    wlAddFilenameToResult.setLayoutData( fdlAddFilenameToResult );\n    wAddFilenameToResult = new Button( wTargetFileGroup, SWT.CHECK );\n    wAddFilenameToResult.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.AddFilenameToResult.Tooltip\" ) );\n    props.setLook( wAddFilenameToResult );\n    fdAddFilenameToResult = new FormData();\n    fdAddFilenameToResult.left = new FormAttachment( middle, 0 );\n    fdAddFilenameToResult.top = new FormAttachment( wTargetExt, margin );\n    fdAddFilenameToResult.right = new FormAttachment( 100, 0 );\n    wAddFilenameToResult.setLayoutData( fdAddFilenameToResult );\n\n    fdTargetFileGroup = new FormData();\n    fdTargetFileGroup.left = new FormAttachment( 0, margin );\n    fdTargetFileGroup.top = new FormAttachment( wUpLoadFile, margin );\n    fdTargetFileGroup.right = new FormAttachment( 100, -margin );\n    wTargetFileGroup.setLayoutData( fdTargetFileGroup );\n    // ///////////////////////////////////////////////////////////\n    // / END OF TargetFileGroupGROUP GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( wName, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Headers TAB ///\n    // ////////////////////////\n\n    wHeadersTab = new CTabItem( wTabFolder, SWT.NONE );\n    wHeadersTab.setText( BaseMessages.getString( PKG, \"JobHTTP.Tab.Headers.Label\" ) );\n    wHeadersComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wHeadersComp );\n    FormLayout HeadersLayout = new FormLayout();\n    HeadersLayout.marginWidth = 3;\n    HeadersLayout.marginHeight = 3;\n    wHeadersComp.setLayout( HeadersLayout );\n\n    int rows =\n      jobEntry.getHeaderName() == null ? 1 : ( jobEntry.getHeaderName().length == 0 ? 0 : jobEntry\n        .getHeaderName().length );\n\n    colinf =\n      new ColumnInfo[] {\n\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobHTTP.ColumnInfo.Name\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n          HTTPProtocol.getRequestHeaders(), false ),\n\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobHTTP.ColumnInfo.Value\" ), ColumnInfo.COLUMN_TYPE_TEXT, false ), };\n    colinf[0].setUsingVariables( true );\n    colinf[1].setUsingVariables( true );\n\n    wHeaders =\n      new TableView(\n        jobMeta, wHeadersComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, rows, lsMod, props );\n\n    fdHeaders = new FormData();\n    fdHeaders.left = new FormAttachment( 0, margin );\n    fdHeaders.top = new FormAttachment( wName, margin );\n    fdHeaders.right = new FormAttachment( 100, -margin );\n    fdHeaders.bottom = new FormAttachment( 100, -margin );\n    wHeaders.setLayoutData( fdHeaders );\n\n    fdHeadersComp = new FormData();\n    fdHeadersComp.left = new FormAttachment( 0, 0 );\n    fdHeadersComp.top = new FormAttachment( 0, 0 );\n    fdHeadersComp.right = new FormAttachment( 100, 0 );\n    fdHeadersComp.bottom = new FormAttachment( 100, 0 );\n    wHeadersComp.setLayoutData( fdHeadersComp );\n\n    wHeadersComp.layout();\n    wHeadersTab.setControl( wHeadersComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Headers TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wURL.addSelectionListener( lsDef );\n    wTargetFile.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    props.setDialogSize( shell, \"JobHTTPDialogSize\" );\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","id":77497,"modified_method":"public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobHTTP.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Job entry name line\n    wlName = new Label( shell, SWT.RIGHT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobHTTP.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( middle, 0 );\n    fdName.top = new FormAttachment( 0, margin );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobHTTP.Tab.General.Label\" ) );\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // URL line\n    wlURL = new Label( wGeneralComp, SWT.RIGHT );\n    wlURL.setText( BaseMessages.getString( PKG, \"JobHTTP.URL.Label\" ) );\n    props.setLook( wlURL );\n    fdlURL = new FormData();\n    fdlURL.left = new FormAttachment( 0, 0 );\n    fdlURL.top = new FormAttachment( wName, 2 * margin );\n    fdlURL.right = new FormAttachment( middle, -margin );\n    wlURL.setLayoutData( fdlURL );\n    wURL =\n      new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobHTTP.URL.Tooltip\" ) );\n    props.setLook( wURL );\n    wURL.addModifyListener( lsMod );\n    fdURL = new FormData();\n    fdURL.left = new FormAttachment( middle, 0 );\n    fdURL.top = new FormAttachment( wName, 2 * margin );\n    fdURL.right = new FormAttachment( 100, 0 );\n    wURL.setLayoutData( fdURL );\n\n    // RunEveryRow line\n    wlRunEveryRow = new Label( wGeneralComp, SWT.RIGHT );\n    wlRunEveryRow.setText( BaseMessages.getString( PKG, \"JobHTTP.RunForEveryRow.Label\" ) );\n    props.setLook( wlRunEveryRow );\n    fdlRunEveryRow = new FormData();\n    fdlRunEveryRow.left = new FormAttachment( 0, 0 );\n    fdlRunEveryRow.top = new FormAttachment( wURL, margin );\n    fdlRunEveryRow.right = new FormAttachment( middle, -margin );\n    wlRunEveryRow.setLayoutData( fdlRunEveryRow );\n    wRunEveryRow = new Button( wGeneralComp, SWT.CHECK );\n    wRunEveryRow.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.RunForEveryRow.Tooltip\" ) );\n    props.setLook( wRunEveryRow );\n    fdRunEveryRow = new FormData();\n    fdRunEveryRow.left = new FormAttachment( middle, 0 );\n    fdRunEveryRow.top = new FormAttachment( wURL, margin );\n    fdRunEveryRow.right = new FormAttachment( 100, 0 );\n    wRunEveryRow.setLayoutData( fdRunEveryRow );\n    wRunEveryRow.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        setFlags();\n      }\n    } );\n\n    // FieldURL line\n    wlFieldURL = new Label( wGeneralComp, SWT.RIGHT );\n    wlFieldURL.setText( BaseMessages.getString( PKG, \"JobHTTP.InputField.Label\" ) );\n    props.setLook( wlFieldURL );\n    fdlFieldURL = new FormData();\n    fdlFieldURL.left = new FormAttachment( 0, 0 );\n    fdlFieldURL.top = new FormAttachment( wRunEveryRow, margin );\n    fdlFieldURL.right = new FormAttachment( middle, -margin );\n    wlFieldURL.setLayoutData( fdlFieldURL );\n    wFieldURL = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wFieldURL );\n    wFieldURL.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.InputField.Tooltip\" ) );\n    wFieldURL.addModifyListener( lsMod );\n    fdFieldURL = new FormData();\n    fdFieldURL.left = new FormAttachment( middle, 0 );\n    fdFieldURL.top = new FormAttachment( wRunEveryRow, margin );\n    fdFieldURL.right = new FormAttachment( 100, 0 );\n    wFieldURL.setLayoutData( fdFieldURL );\n\n    // FieldUpload line\n\n    wlFieldUpload = new Label( wGeneralComp, SWT.RIGHT );\n    wlFieldUpload.setText( BaseMessages.getString( PKG, \"JobHTTP.InputFieldUpload.Label\" ) );\n    props.setLook( wlFieldUpload );\n    fdlFieldUpload = new FormData();\n    fdlFieldUpload.left = new FormAttachment( 0, 0 );\n    fdlFieldUpload.top = new FormAttachment( wFieldURL, margin );\n    fdlFieldUpload.right = new FormAttachment( middle, -margin );\n    wlFieldUpload.setLayoutData( fdlFieldUpload );\n    wFieldUpload = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wFieldUpload );\n    wFieldUpload.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.InputFieldUpload.Tooltip\" ) );\n    wFieldUpload.addModifyListener( lsMod );\n    fdFieldUpload = new FormData();\n    fdFieldUpload.left = new FormAttachment( middle, 0 );\n    fdFieldUpload.top = new FormAttachment( wFieldURL, margin );\n    fdFieldUpload.right = new FormAttachment( 100, 0 );\n    wFieldUpload.setLayoutData( fdFieldUpload );\n\n    // FieldTarget line\n    wlFieldTarget = new Label( wGeneralComp, SWT.RIGHT );\n    wlFieldTarget.setText( BaseMessages.getString( PKG, \"JobHTTP.InputFieldDest.Label\" ) );\n    props.setLook( wlFieldTarget );\n    fdlFieldTarget = new FormData();\n    fdlFieldTarget.left = new FormAttachment( 0, 0 );\n    fdlFieldTarget.top = new FormAttachment( wFieldUpload, margin );\n    fdlFieldTarget.right = new FormAttachment( middle, -margin );\n    wlFieldTarget.setLayoutData( fdlFieldTarget );\n    wFieldTarget = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wFieldTarget );\n    wFieldTarget.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.InputFieldDest.Tooltip\" ) );\n    wFieldTarget.addModifyListener( lsMod );\n    fdFieldTarget = new FormData();\n    fdFieldTarget.left = new FormAttachment( middle, 0 );\n    fdFieldTarget.top = new FormAttachment( wFieldUpload, margin );\n    fdFieldTarget.right = new FormAttachment( 100, 0 );\n    wFieldTarget.setLayoutData( fdFieldTarget );\n\n    // ////////////////////////\n    // START OF AuthenticationGROUP///\n    // /\n    wAuthentication = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wAuthentication );\n    wAuthentication.setText( BaseMessages.getString( PKG, \"JobHTTP.Authentication.Group.Label\" ) );\n\n    FormLayout AuthenticationgroupLayout = new FormLayout();\n    AuthenticationgroupLayout.marginWidth = 10;\n    AuthenticationgroupLayout.marginHeight = 10;\n    wAuthentication.setLayout( AuthenticationgroupLayout );\n\n    // UserName line\n    wlUserName = new Label( wAuthentication, SWT.RIGHT );\n    wlUserName.setText( BaseMessages.getString( PKG, \"JobHTTP.UploadUser.Label\" ) );\n    props.setLook( wlUserName );\n    fdlUserName = new FormData();\n    fdlUserName.left = new FormAttachment( 0, 0 );\n    fdlUserName.top = new FormAttachment( wFieldTarget, margin );\n    fdlUserName.right = new FormAttachment( middle, -margin );\n    wlUserName.setLayoutData( fdlUserName );\n    wUserName = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wUserName );\n    wUserName.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.UploadUser.Tooltip\" ) );\n    wUserName.addModifyListener( lsMod );\n    fdUserName = new FormData();\n    fdUserName.left = new FormAttachment( middle, 0 );\n    fdUserName.top = new FormAttachment( wFieldTarget, margin );\n    fdUserName.right = new FormAttachment( 100, 0 );\n    wUserName.setLayoutData( fdUserName );\n\n    // Password line\n    wlPassword = new Label( wAuthentication, SWT.RIGHT );\n    wlPassword.setText( BaseMessages.getString( PKG, \"JobHTTP.UploadPassword.Label\" ) );\n    props.setLook( wlPassword );\n    fdlPassword = new FormData();\n    fdlPassword.left = new FormAttachment( 0, 0 );\n    fdlPassword.top = new FormAttachment( wUserName, margin );\n    fdlPassword.right = new FormAttachment( middle, -margin );\n    wlPassword.setLayoutData( fdlPassword );\n    wPassword = new PasswordTextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wPassword );\n    wPassword.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.UploadPassword.Tooltip\" ) );\n    wPassword.addModifyListener( lsMod );\n    fdPassword = new FormData();\n    fdPassword.left = new FormAttachment( middle, 0 );\n    fdPassword.top = new FormAttachment( wUserName, margin );\n    fdPassword.right = new FormAttachment( 100, 0 );\n    wPassword.setLayoutData( fdPassword );\n\n    // ProxyServer line\n    wlProxyServer = new Label( wAuthentication, SWT.RIGHT );\n    wlProxyServer.setText( BaseMessages.getString( PKG, \"JobHTTP.ProxyHost.Label\" ) );\n    props.setLook( wlProxyServer );\n    fdlProxyServer = new FormData();\n    fdlProxyServer.left = new FormAttachment( 0, 0 );\n    fdlProxyServer.top = new FormAttachment( wPassword, 3 * margin );\n    fdlProxyServer.right = new FormAttachment( middle, -margin );\n    wlProxyServer.setLayoutData( fdlProxyServer );\n    wProxyServer = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wProxyServer );\n    wProxyServer.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.ProxyHost.Tooltip\" ) );\n    wProxyServer.addModifyListener( lsMod );\n    fdProxyServer = new FormData();\n    fdProxyServer.left = new FormAttachment( middle, 0 );\n    fdProxyServer.top = new FormAttachment( wPassword, 3 * margin );\n    fdProxyServer.right = new FormAttachment( 100, 0 );\n    wProxyServer.setLayoutData( fdProxyServer );\n\n    // ProxyPort line\n    wlProxyPort = new Label( wAuthentication, SWT.RIGHT );\n    wlProxyPort.setText( BaseMessages.getString( PKG, \"JobHTTP.ProxyPort.Label\" ) );\n    props.setLook( wlProxyPort );\n    fdlProxyPort = new FormData();\n    fdlProxyPort.left = new FormAttachment( 0, 0 );\n    fdlProxyPort.top = new FormAttachment( wProxyServer, margin );\n    fdlProxyPort.right = new FormAttachment( middle, -margin );\n    wlProxyPort.setLayoutData( fdlProxyPort );\n    wProxyPort = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wProxyPort );\n    wProxyPort.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.ProxyPort.Tooltip\" ) );\n    wProxyPort.addModifyListener( lsMod );\n    fdProxyPort = new FormData();\n    fdProxyPort.left = new FormAttachment( middle, 0 );\n    fdProxyPort.top = new FormAttachment( wProxyServer, margin );\n    fdProxyPort.right = new FormAttachment( 100, 0 );\n    wProxyPort.setLayoutData( fdProxyPort );\n\n    // IgnoreHosts line\n    wlNonProxyHosts = new Label( wAuthentication, SWT.RIGHT );\n    wlNonProxyHosts.setText( BaseMessages.getString( PKG, \"JobHTTP.ProxyIgnoreRegexp.Label\" ) );\n    props.setLook( wlNonProxyHosts );\n    fdlNonProxyHosts = new FormData();\n    fdlNonProxyHosts.left = new FormAttachment( 0, 0 );\n    fdlNonProxyHosts.top = new FormAttachment( wProxyPort, margin );\n    fdlNonProxyHosts.right = new FormAttachment( middle, -margin );\n    wlNonProxyHosts.setLayoutData( fdlNonProxyHosts );\n    wNonProxyHosts = new TextVar( jobMeta, wAuthentication, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wNonProxyHosts );\n    wNonProxyHosts.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.ProxyIgnoreRegexp.Tooltip\" ) );\n    wNonProxyHosts.addModifyListener( lsMod );\n    fdNonProxyHosts = new FormData();\n    fdNonProxyHosts.left = new FormAttachment( middle, 0 );\n    fdNonProxyHosts.top = new FormAttachment( wProxyPort, margin );\n    fdNonProxyHosts.right = new FormAttachment( 100, 0 );\n    wNonProxyHosts.setLayoutData( fdNonProxyHosts );\n\n    fdAuthentication = new FormData();\n    fdAuthentication.left = new FormAttachment( 0, margin );\n    fdAuthentication.top = new FormAttachment( wFieldTarget, margin );\n    fdAuthentication.right = new FormAttachment( 100, -margin );\n    wAuthentication.setLayoutData( fdAuthentication );\n    // ///////////////////////////////////////////////////////////\n    // / END OF AuthenticationGROUP GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF UpLoadFileGROUP///\n    // /\n    wUpLoadFile = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wUpLoadFile );\n    wUpLoadFile.setText( BaseMessages.getString( PKG, \"JobHTTP.UpLoadFile.Group.Label\" ) );\n\n    FormLayout UpLoadFilegroupLayout = new FormLayout();\n    UpLoadFilegroupLayout.marginWidth = 10;\n    UpLoadFilegroupLayout.marginHeight = 10;\n    wUpLoadFile.setLayout( UpLoadFilegroupLayout );\n\n    // UploadFile line\n    wlUploadFile = new Label( wUpLoadFile, SWT.RIGHT );\n    wlUploadFile.setText( BaseMessages.getString( PKG, \"JobHTTP.UploadFile.Label\" ) );\n    props.setLook( wlUploadFile );\n    fdlUploadFile = new FormData();\n    fdlUploadFile.left = new FormAttachment( 0, 0 );\n    fdlUploadFile.top = new FormAttachment( wAuthentication, margin );\n    fdlUploadFile.right = new FormAttachment( middle, -margin );\n    wlUploadFile.setLayoutData( fdlUploadFile );\n\n    wbUploadFile = new Button( wUpLoadFile, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbUploadFile );\n    wbUploadFile.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbUploadFile = new FormData();\n    fdbUploadFile.right = new FormAttachment( 100, 0 );\n    fdbUploadFile.top = new FormAttachment( wAuthentication, margin );\n    wbUploadFile.setLayoutData( fdbUploadFile );\n\n    wUploadFile = new TextVar( jobMeta, wUpLoadFile, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wUploadFile );\n    wUploadFile.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.UploadFile.Tooltip\" ) );\n    wUploadFile.addModifyListener( lsMod );\n    fdUploadFile = new FormData();\n    fdUploadFile.left = new FormAttachment( middle, 0 );\n    fdUploadFile.top = new FormAttachment( wAuthentication, margin );\n    fdUploadFile.right = new FormAttachment( wbUploadFile, -margin );\n    wUploadFile.setLayoutData( fdUploadFile );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wUploadFile.addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        wUploadFile.setToolTipText( jobMeta.environmentSubstitute( wUploadFile.getText() ) );\n      }\n    } );\n\n    wbUploadFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wUploadFile.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wUploadFile.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wUploadFile.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    fdUpLoadFile = new FormData();\n    fdUpLoadFile.left = new FormAttachment( 0, margin );\n    fdUpLoadFile.top = new FormAttachment( wAuthentication, margin );\n    fdUpLoadFile.right = new FormAttachment( 100, -margin );\n    wUpLoadFile.setLayoutData( fdUpLoadFile );\n    // ///////////////////////////////////////////////////////////\n    // / END OF UpLoadFileGROUP GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF TargetFileGroupGROUP///\n    // /\n    wTargetFileGroup = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wTargetFileGroup );\n    wTargetFileGroup.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileGroup.Group.Label\" ) );\n\n    FormLayout TargetFileGroupgroupLayout = new FormLayout();\n    TargetFileGroupgroupLayout.marginWidth = 10;\n    TargetFileGroupgroupLayout.marginHeight = 10;\n    wTargetFileGroup.setLayout( TargetFileGroupgroupLayout );\n\n    // TargetFile line\n    wlTargetFile = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlTargetFile.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFile.Label\" ) );\n    props.setLook( wlTargetFile );\n    fdlTargetFile = new FormData();\n    fdlTargetFile.left = new FormAttachment( 0, 0 );\n    fdlTargetFile.top = new FormAttachment( wUploadFile, margin );\n    fdlTargetFile.right = new FormAttachment( middle, -margin );\n    wlTargetFile.setLayoutData( fdlTargetFile );\n\n    wbTargetFile = new Button( wTargetFileGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbTargetFile );\n    wbTargetFile.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbTargetFile = new FormData();\n    fdbTargetFile.right = new FormAttachment( 100, 0 );\n    fdbTargetFile.top = new FormAttachment( wUploadFile, margin );\n    wbTargetFile.setLayoutData( fdbTargetFile );\n\n    wTargetFile = new TextVar( jobMeta, wTargetFileGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wTargetFile );\n    wTargetFile.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFile.Tooltip\" ) );\n    wTargetFile.addModifyListener( lsMod );\n    fdTargetFile = new FormData();\n    fdTargetFile.left = new FormAttachment( middle, 0 );\n    fdTargetFile.top = new FormAttachment( wUploadFile, margin );\n    fdTargetFile.right = new FormAttachment( wbTargetFile, -margin );\n    wTargetFile.setLayoutData( fdTargetFile );\n\n    wbTargetFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.SAVE );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wTargetFile.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wTargetFile.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wTargetFile.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Append line\n    wlAppend = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlAppend.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileAppend.Label\" ) );\n    props.setLook( wlAppend );\n    fdlAppend = new FormData();\n    fdlAppend.left = new FormAttachment( 0, 0 );\n    fdlAppend.top = new FormAttachment( wTargetFile, margin );\n    fdlAppend.right = new FormAttachment( middle, -margin );\n    wlAppend.setLayoutData( fdlAppend );\n    wAppend = new Button( wTargetFileGroup, SWT.CHECK );\n    props.setLook( wAppend );\n    wAppend.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileAppend.Tooltip\" ) );\n    fdAppend = new FormData();\n    fdAppend.left = new FormAttachment( middle, 0 );\n    fdAppend.top = new FormAttachment( wTargetFile, margin );\n    fdAppend.right = new FormAttachment( 100, 0 );\n    wAppend.setLayoutData( fdAppend );\n\n    // DateTimeAdded line\n    wlDateTimeAdded = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlDateTimeAdded.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFilenameAddDate.Label\" ) );\n    props.setLook( wlDateTimeAdded );\n    fdlDateTimeAdded = new FormData();\n    fdlDateTimeAdded.left = new FormAttachment( 0, 0 );\n    fdlDateTimeAdded.top = new FormAttachment( wAppend, margin );\n    fdlDateTimeAdded.right = new FormAttachment( middle, -margin );\n    wlDateTimeAdded.setLayoutData( fdlDateTimeAdded );\n    wDateTimeAdded = new Button( wTargetFileGroup, SWT.CHECK );\n    props.setLook( wDateTimeAdded );\n    wDateTimeAdded.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFilenameAddDate.Tooltip\" ) );\n    fdDateTimeAdded = new FormData();\n    fdDateTimeAdded.left = new FormAttachment( middle, 0 );\n    fdDateTimeAdded.top = new FormAttachment( wAppend, margin );\n    fdDateTimeAdded.right = new FormAttachment( 100, 0 );\n    wDateTimeAdded.setLayoutData( fdDateTimeAdded );\n    wDateTimeAdded.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        setFlags();\n      }\n    } );\n\n    // TargetExt line\n    wlTargetExt = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlTargetExt.setText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileExt.Label\" ) );\n    props.setLook( wlTargetExt );\n    fdlTargetExt = new FormData();\n    fdlTargetExt.left = new FormAttachment( 0, 0 );\n    fdlTargetExt.top = new FormAttachment( wDateTimeAdded, margin );\n    fdlTargetExt.right = new FormAttachment( middle, -margin );\n    wlTargetExt.setLayoutData( fdlTargetExt );\n    wTargetExt = new TextVar( jobMeta, wTargetFileGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wTargetExt );\n    wTargetExt.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.TargetFileExt.Tooltip\" ) );\n    wTargetExt.addModifyListener( lsMod );\n    fdTargetExt = new FormData();\n    fdTargetExt.left = new FormAttachment( middle, 0 );\n    fdTargetExt.top = new FormAttachment( wDateTimeAdded, margin );\n    fdTargetExt.right = new FormAttachment( 100, 0 );\n    wTargetExt.setLayoutData( fdTargetExt );\n\n    // Add filenames to result filenames...\n    wlAddFilenameToResult = new Label( wTargetFileGroup, SWT.RIGHT );\n    wlAddFilenameToResult.setText( BaseMessages.getString( PKG, \"JobHTTP.AddFilenameToResult.Label\" ) );\n    props.setLook( wlAddFilenameToResult );\n    fdlAddFilenameToResult = new FormData();\n    fdlAddFilenameToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFilenameToResult.top = new FormAttachment( wTargetExt, margin );\n    fdlAddFilenameToResult.right = new FormAttachment( middle, -margin );\n    wlAddFilenameToResult.setLayoutData( fdlAddFilenameToResult );\n    wAddFilenameToResult = new Button( wTargetFileGroup, SWT.CHECK );\n    wAddFilenameToResult.setToolTipText( BaseMessages.getString( PKG, \"JobHTTP.AddFilenameToResult.Tooltip\" ) );\n    props.setLook( wAddFilenameToResult );\n    fdAddFilenameToResult = new FormData();\n    fdAddFilenameToResult.left = new FormAttachment( middle, 0 );\n    fdAddFilenameToResult.top = new FormAttachment( wTargetExt, margin );\n    fdAddFilenameToResult.right = new FormAttachment( 100, 0 );\n    wAddFilenameToResult.setLayoutData( fdAddFilenameToResult );\n\n    fdTargetFileGroup = new FormData();\n    fdTargetFileGroup.left = new FormAttachment( 0, margin );\n    fdTargetFileGroup.top = new FormAttachment( wUpLoadFile, margin );\n    fdTargetFileGroup.right = new FormAttachment( 100, -margin );\n    wTargetFileGroup.setLayoutData( fdTargetFileGroup );\n    // ///////////////////////////////////////////////////////////\n    // / END OF TargetFileGroupGROUP GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( wName, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Headers TAB ///\n    // ////////////////////////\n\n    wHeadersTab = new CTabItem( wTabFolder, SWT.NONE );\n    wHeadersTab.setText( BaseMessages.getString( PKG, \"JobHTTP.Tab.Headers.Label\" ) );\n    wHeadersComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wHeadersComp );\n    FormLayout HeadersLayout = new FormLayout();\n    HeadersLayout.marginWidth = 3;\n    HeadersLayout.marginHeight = 3;\n    wHeadersComp.setLayout( HeadersLayout );\n\n    int rows =\n      jobEntry.getHeaderName() == null ? 1 : ( jobEntry.getHeaderName().length == 0 ? 0 : jobEntry\n        .getHeaderName().length );\n\n    colinf =\n      new ColumnInfo[] {\n\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobHTTP.ColumnInfo.Name\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n          HTTPProtocol.getRequestHeaders(), false ),\n\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobHTTP.ColumnInfo.Value\" ), ColumnInfo.COLUMN_TYPE_TEXT, false ), };\n    colinf[0].setUsingVariables( true );\n    colinf[1].setUsingVariables( true );\n\n    wHeaders =\n      new TableView(\n        jobMeta, wHeadersComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, rows, lsMod, props );\n\n    fdHeaders = new FormData();\n    fdHeaders.left = new FormAttachment( 0, margin );\n    fdHeaders.top = new FormAttachment( wName, margin );\n    fdHeaders.right = new FormAttachment( 100, -margin );\n    fdHeaders.bottom = new FormAttachment( 100, -margin );\n    wHeaders.setLayoutData( fdHeaders );\n\n    fdHeadersComp = new FormData();\n    fdHeadersComp.left = new FormAttachment( 0, 0 );\n    fdHeadersComp.top = new FormAttachment( 0, 0 );\n    fdHeadersComp.right = new FormAttachment( 100, 0 );\n    fdHeadersComp.bottom = new FormAttachment( 100, 0 );\n    wHeadersComp.setLayoutData( fdHeadersComp );\n\n    wHeadersComp.layout();\n    wHeadersTab.setControl( wHeadersComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Headers TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wURL.addSelectionListener( lsDef );\n    wTargetFile.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    props.setDialogSize( shell, \"JobHTTPDialogSize\" );\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void setFlags() {\n    wlURL.setEnabled( !wRunEveryRow.getSelection() );\n    wURL.setEnabled( !wRunEveryRow.getSelection() );\n    wlFieldURL.setEnabled( wRunEveryRow.getSelection() );\n    wFieldURL.setEnabled( wRunEveryRow.getSelection() );\n\n    wlTargetExt.setEnabled( wDateTimeAdded.getSelection() );\n    wTargetExt.setEnabled( wDateTimeAdded.getSelection() );\n    wlAppend.setEnabled( !wDateTimeAdded.getSelection() );\n    wAppend.setEnabled( !wDateTimeAdded.getSelection() );\n  }","id":77498,"modified_method":"private void setFlags() {\n    wlURL.setEnabled( !wRunEveryRow.getSelection() );\n    wURL.setEnabled( !wRunEveryRow.getSelection() );\n    wlFieldURL.setEnabled( wRunEveryRow.getSelection() );\n    wFieldURL.setEnabled( wRunEveryRow.getSelection() );\n    wlFieldUpload.setEnabled( wRunEveryRow.getSelection() );\n    wFieldUpload.setEnabled( wRunEveryRow.getSelection() );\n    wlFieldTarget.setEnabled(  wRunEveryRow.getSelection() );\n    wFieldTarget.setEnabled( wRunEveryRow.getSelection() );\n\n    wlUploadFile.setEnabled( !wRunEveryRow.getSelection() );\n    wUploadFile.setEnabled( !wRunEveryRow.getSelection() );\n    wbUploadFile.setEnabled( !wRunEveryRow.getSelection() );\n    wlTargetFile.setEnabled( !wRunEveryRow.getSelection() );\n    wbTargetFile.setEnabled( !wRunEveryRow.getSelection() );\n    wTargetFile.setEnabled( !wRunEveryRow.getSelection() );\n    wlDateTimeAdded.setEnabled( !wRunEveryRow.getSelection() );\n    wDateTimeAdded.setEnabled( !wRunEveryRow.getSelection() );\n    wlAppend.setEnabled( wRunEveryRow.getSelection() ? false : !wDateTimeAdded.getSelection() );\n    wAppend.setEnabled( wRunEveryRow.getSelection() ? false : !wDateTimeAdded.getSelection() );\n    wlTargetExt.setEnabled( wRunEveryRow.getSelection() ? false : wDateTimeAdded.getSelection() );\n    wTargetExt.setEnabled( wRunEveryRow.getSelection() ? false : wDateTimeAdded.getSelection() );\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    wName.setText( Const.NVL( jobEntry.getName(), \"\" ) );\n\n    wURL.setText( Const.NVL( jobEntry.getUrl(), \"\" ) );\n    wRunEveryRow.setSelection( jobEntry.isRunForEveryRow() );\n    wFieldURL.setText( Const.NVL( jobEntry.getUrlFieldname(), \"\" ) );\n    wTargetFile.setText( Const.NVL( jobEntry.getTargetFilename(), \"\" ) );\n    wAppend.setSelection( jobEntry.isFileAppended() );\n    wDateTimeAdded.setSelection( jobEntry.isDateTimeAdded() );\n    wTargetExt.setText( Const.NVL( jobEntry.getTargetFilenameExtention(), \"\" ) );\n\n    wUploadFile.setText( Const.NVL( jobEntry.getUploadFilename(), \"\" ) );\n\n    jobEntry.setDateTimeAdded( wDateTimeAdded.getSelection() );\n    jobEntry.setTargetFilenameExtention( wTargetExt.getText() );\n\n    wUserName.setText( Const.NVL( jobEntry.getUsername(), \"\" ) );\n    wPassword.setText( Const.NVL( jobEntry.getPassword(), \"\" ) );\n\n    wProxyServer.setText( Const.NVL( jobEntry.getProxyHostname(), \"\" ) );\n    wProxyPort.setText( Const.NVL( jobEntry.getProxyPort(), \"\" ) );\n    wNonProxyHosts.setText( Const.NVL( jobEntry.getNonProxyHosts(), \"\" ) );\n\n    String[] headerNames = jobEntry.getHeaderName();\n    String[] headerValues = jobEntry.getHeaderValue();\n    if ( headerNames != null ) {\n      for ( int i = 0; i < headerNames.length; i++ ) {\n        TableItem ti = wHeaders.table.getItem( i );\n        if ( headerNames[i] != null ) {\n          ti.setText( 1, headerNames[i] );\n        }\n        if ( headerValues[i] != null ) {\n          ti.setText( 2, headerValues[i] );\n        }\n      }\n      wHeaders.setRowNums();\n      wHeaders.optWidth( true );\n    }\n\n    wAddFilenameToResult.setSelection( jobEntry.isAddFilenameToResult() );\n    setFlags();\n\n    wName.selectAll();\n    wName.setFocus();\n  }","id":77499,"modified_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    wName.setText( Const.NVL( jobEntry.getName(), \"\" ) );\n\n    wURL.setText( Const.NVL( jobEntry.getUrl(), \"\" ) );\n    wRunEveryRow.setSelection( jobEntry.isRunForEveryRow() );\n    wFieldURL.setText( Const.NVL( jobEntry.getUrlFieldname(), \"\" ) );\n    wFieldUpload.setText( Const.NVL( jobEntry.getUploadFieldname(), \"\" ) );\n    wFieldTarget.setText( Const.NVL( jobEntry.getDestinationFieldname(), \"\" ) );\n    wTargetFile.setText( Const.NVL( jobEntry.getTargetFilename(), \"\" ) );\n    wAppend.setSelection( jobEntry.isFileAppended() );\n    wDateTimeAdded.setSelection( jobEntry.isDateTimeAdded() );\n    wTargetExt.setText( Const.NVL( jobEntry.getTargetFilenameExtension(), \"\" ) );\n\n    wUploadFile.setText( Const.NVL( jobEntry.getUploadFilename(), \"\" ) );\n\n    jobEntry.setDateTimeAdded( wDateTimeAdded.getSelection() );\n    jobEntry.setTargetFilenameExtension( wTargetExt.getText() );\n\n    wUserName.setText( Const.NVL( jobEntry.getUsername(), \"\" ) );\n    wPassword.setText( Const.NVL( jobEntry.getPassword(), \"\" ) );\n\n    wProxyServer.setText( Const.NVL( jobEntry.getProxyHostname(), \"\" ) );\n    wProxyPort.setText( Const.NVL( jobEntry.getProxyPort(), \"\" ) );\n    wNonProxyHosts.setText( Const.NVL( jobEntry.getNonProxyHosts(), \"\" ) );\n\n    String[] headerNames = jobEntry.getHeaderName();\n    String[] headerValues = jobEntry.getHeaderValue();\n    if ( headerNames != null ) {\n      for ( int i = 0; i < headerNames.length; i++ ) {\n        TableItem ti = wHeaders.table.getItem( i );\n        if ( headerNames[i] != null ) {\n          ti.setText( 1, headerNames[i] );\n        }\n        if ( headerValues[i] != null ) {\n          ti.setText( 2, headerValues[i] );\n        }\n      }\n      wHeaders.setRowNums();\n      wHeaders.optWidth( true );\n    }\n\n    wAddFilenameToResult.setSelection( jobEntry.isAddFilenameToResult() );\n    setFlags();\n\n    wName.selectAll();\n    wName.setFocus();\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok() {\n    if ( Const.isEmpty( wName.getText() ) ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setText( BaseMessages.getString( PKG, \"System.StepJobEntryNameMissing.Title\" ) );\n      mb.setMessage( BaseMessages.getString( PKG, \"System.JobEntryNameMissing.Msg\" ) );\n      mb.open();\n      return;\n    }\n    jobEntry.setName( wName.getText() );\n    jobEntry.setUrl( wURL.getText() );\n    jobEntry.setRunForEveryRow( wRunEveryRow.getSelection() );\n    jobEntry.setUrlFieldname( wFieldURL.getText() );\n    jobEntry.setTargetFilename( wTargetFile.getText() );\n    jobEntry.setFileAppended( wAppend.getSelection() );\n\n    jobEntry.setDateTimeAdded( wDateTimeAdded.getSelection() );\n    jobEntry.setTargetFilenameExtention( wTargetExt.getText() );\n\n    jobEntry.setUploadFilename( wUploadFile.getText() );\n\n    jobEntry.setUsername( wUserName.getText() );\n    jobEntry.setPassword( wPassword.getText() );\n\n    jobEntry.setProxyHostname( wProxyServer.getText() );\n    jobEntry.setProxyPort( wProxyPort.getText() );\n    jobEntry.setNonProxyHosts( wNonProxyHosts.getText() );\n    jobEntry.setAddFilenameToResult( wAddFilenameToResult.getSelection() );\n\n    int nritems = wHeaders.nrNonEmpty();\n    int nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String arg = wHeaders.getNonEmpty( i ).getText( 1 );\n      if ( arg != null && arg.length() != 0 ) {\n        nr++;\n      }\n    }\n    String[] headerNames = new String[nr];\n    String[] headerValues = new String[nr];\n\n    nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String varname = wHeaders.getNonEmpty( i ).getText( 1 );\n      String varvalue = wHeaders.getNonEmpty( i ).getText( 2 );\n\n      if ( varname != null && varname.length() != 0 ) {\n        headerNames[nr] = varname;\n        headerValues[nr] = varvalue;\n        nr++;\n      }\n    }\n    jobEntry.setHeaderName( headerNames );\n    jobEntry.setHeaderValue( headerValues );\n\n    dispose();\n  }","id":77500,"modified_method":"private void ok() {\n    if ( Const.isEmpty( wName.getText() ) ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setText( BaseMessages.getString( PKG, \"System.StepJobEntryNameMissing.Title\" ) );\n      mb.setMessage( BaseMessages.getString( PKG, \"System.JobEntryNameMissing.Msg\" ) );\n      mb.open();\n      return;\n    }\n    jobEntry.setName( wName.getText() );\n    jobEntry.setUrl( wURL.getText() );\n    jobEntry.setRunForEveryRow( wRunEveryRow.getSelection() );\n    jobEntry.setUrlFieldname( wFieldURL.getText() );\n    jobEntry.setUploadFieldname( wFieldUpload.getText() );\n    jobEntry.setDestinationFieldname( wFieldTarget.getText() );\n\n    jobEntry.setUsername( wUserName.getText() );\n    jobEntry.setPassword( wPassword.getText() );\n    jobEntry.setProxyHostname( wProxyServer.getText() );\n    jobEntry.setProxyPort( wProxyPort.getText() );\n    jobEntry.setNonProxyHosts( wNonProxyHosts.getText() );\n\n    jobEntry.setUploadFilename( wUploadFile.getText() );\n\n    jobEntry.setTargetFilename( wRunEveryRow.getSelection() ? \"\" : wTargetFile.getText() );\n    jobEntry.setFileAppended( wRunEveryRow.getSelection() ? false : wAppend.getSelection() );\n    jobEntry.setDateTimeAdded( wRunEveryRow.getSelection() ? false : wDateTimeAdded.getSelection() );\n    jobEntry.setTargetFilenameExtension( wRunEveryRow.getSelection() ? \"\" : wTargetExt.getText() );\n    jobEntry.setAddFilenameToResult( wAddFilenameToResult.getSelection() );\n\n    int nritems = wHeaders.nrNonEmpty();\n    int nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String arg = wHeaders.getNonEmpty( i ).getText( 1 );\n      if ( arg != null && arg.length() != 0 ) {\n        nr++;\n      }\n    }\n    String[] headerNames = new String[nr];\n    String[] headerValues = new String[nr];\n\n    nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String varname = wHeaders.getNonEmpty( i ).getText( 1 );\n      String varvalue = wHeaders.getNonEmpty( i ).getText( 2 );\n\n      if ( varname != null && varname.length() != 0 ) {\n        headerNames[nr] = varname;\n        headerValues[nr] = varvalue;\n        nr++;\n      }\n    }\n    jobEntry.setHeaderName( headerNames );\n    jobEntry.setHeaderValue( headerValues );\n\n    dispose();\n  }","commit_id":"151a7e32247f28c8f695bd5ed8ff82383630054c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n         * Allows for entities to be altered\n         * before they have a custom class description\n         * registered. Sub classes can override this method\n         * to provide any extra alterings before the description\n         * is registered. However be sure to call super as this\n         * method does convert the class name from EOGenericRecord\n         * to ERXGenericRecord, which unfortunately is required\n         * for custom validation to work at the moment.\n         * @param eoentity to be prepared for registration\n         */\n        public void prepareEntityForRegistration(EOEntity eoentity) {\n            String className = eoentity.className();\n            String defaultClassName = ERXProperties.stringForKeyWithDefault(\"er.extensions.ERXEntityClassDescription.defaultClassName\", ERXGenericRecord.class.getName());\n            String alternateClassName = ERXProperties.stringForKey(\"er.extensions.ERXEntityClassDescription.\" + eoentity.name() + \".ClassName\");\n            if (alternateClassName != null) {\n                log.debug(eoentity.name() + \": setting class from: \" + className + \" to: \" + alternateClassName);\n                eoentity.setClassName(alternateClassName);\n            } else if (className.equals(\"EOGenericRecord\")) {\n                eoentity.setClassName(defaultClassName);\n            }\n            String notificationName = hasPreparedEntities() ? WillRegisterEntityNotification : DidPrepareEntityNotification;\n            NSNotificationCenter.defaultCenter().postNotification( notificationName, eoentity );\n        }","id":77501,"modified_method":"/**\n         * Allows for entities to be altered\n         * before they have a custom class description\n         * registered. Sub classes can override this method\n         * to provide any extra alterings before the description\n         * is registered. However be sure to call super as this\n         * method does convert the class name from EOGenericRecord\n         * to ERXGenericRecord, which unfortunately is required\n         * for custom validation to work at the moment.\n         * @param eoentity to be prepared for registration\n         */\n        protected void prepareEntityForRegistration(EOEntity eoentity) {\n            String className = eoentity.className();\n            String defaultClassName = ERXProperties.stringForKeyWithDefault(\"er.extensions.ERXEntityClassDescription.defaultClassName\", ERXGenericRecord.class.getName());\n            String alternateClassName = ERXProperties.stringForKey(\"er.extensions.ERXEntityClassDescription.\" + eoentity.name() + \".ClassName\");\n            if (alternateClassName != null) {\n                log.debug(eoentity.name() + \": setting class from: \" + className + \" to: \" + alternateClassName);\n                eoentity.setClassName(alternateClassName);\n            } else if (className.equals(\"EOGenericRecord\")) {\n                eoentity.setClassName(defaultClassName);\n            }\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * Factory method that is used to create a new class\n         * description for a given entity. Sub classes that\n         * wish to provide a sub class of ERXEntityClassDescription\n         * should override this method to create that custom\n         * description. By default this method returns a new\n         * ERXEntityClassDescription.\n         * @param entity to create the class description for\n         * @return new class description for the given entity\n         */\n        public ERXEntityClassDescription newClassDescriptionForEntity(EOEntity entity) {\n        \tString key = entity.name();\n        \tEOModel model = entity.model();\n        \tif (model != null) {\n        \t\tkey = model.name() + \" \" + key;\n        \t}\n        \tERXEntityClassDescription classDescription = (ERXEntityClassDescription)_classDescriptionForEntity.objectForKey(key);\n        \tif (classDescription == null) {\n        \t\tclassDescription = new ERXEntityClassDescription(entity);\n        \t\t_classDescriptionForEntity.setObjectForKey(classDescription, key);\n        \t}\n        \treturn classDescription;\n        }","id":77502,"modified_method":"/**\n         * Factory method that is used to create a new class\n         * description for a given entity. Sub classes that\n         * wish to provide a sub class of ERXEntityClassDescription\n         * should override this method to create that custom\n         * description. By default this method returns a new\n         * ERXEntityClassDescription.\n         * @param entity to create the class description for\n         * @return new class description for the given entity\n         */\n        protected ERXEntityClassDescription newClassDescriptionForEntity(EOEntity entity) {\n        \tString key = entity.name();\n        \tEOModel model = entity.model();\n        \tif (model != null) {\n        \t\tkey = model.name() + \" \" + key;\n        \t}\n        \tERXEntityClassDescription classDescription = (ERXEntityClassDescription)_classDescriptionForEntity.objectForKey(key);\n        \tif (classDescription == null) {\n        \t\tclassDescription = new ERXEntityClassDescription(entity);\n        \t\t_classDescriptionForEntity.setObjectForKey(classDescription, key);\n        \t}\n        \treturn classDescription;\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void modelFileDidChange(NSNotification n) {\n        File file = (File)n.object();\n        try {\n            defaultLog.debug(\"Reading .plist for entity <\"+entity()+\">\");\n\n            NSDictionary userInfo = (NSDictionary)NSPropertyListSerialization.propertyListFromString(ERXFileUtilities.stringFromFile(file));\n            entity().setUserInfo((NSDictionary)userInfo.objectForKey(\"userInfo\"));\n            \n            _validationInfo = ERXValueUtilities.dictionaryValue(entity().userInfo().objectForKey(\"ERXValidation\"));\n            _validationQualiferCache = (NSMutableDictionary) ERXMutableDictionary.synchronizedDictionary();\n            _initialDefaultValues = null;\n            readDefaultValues();\n        } catch(Exception ex) {\n            defaultLog.error(\"Can't read file <\"+file.getAbsolutePath()+\">\", ex);\n        }\n    }","id":77503,"modified_method":"public void modelFileDidChange(NSNotification n) {\n        File file = (File)n.object();\n        try {\n            defaultLog.debug(\"Reading .plist for entity <\"+entity()+\">\");\n\n            NSDictionary userInfo = (NSDictionary)NSPropertyListSerialization.propertyListFromString(ERXFileUtilities.stringFromFile(file));\n            entity().setUserInfo((NSDictionary)userInfo.objectForKey(\"userInfo\"));\n            \n            _validationInfo = ERXValueUtilities.dictionaryValue(entity().userInfo().objectForKey(\"ERXValidation\"));\n            _validationQualiferCache = ERXMutableDictionary.synchronizedDictionary();\n            _initialDefaultValues = null;\n            readDefaultValues();\n        } catch(Exception ex) {\n            defaultLog.error(\"Can't read file <\"+file.getAbsolutePath()+\">\", ex);\n        }\n    }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Public constructor\n     * @param entity that this class description corresponds to\n     */\n    public ERXEntityClassDescription(EOEntity entity) {\n        super(entity);\n        _validationInfo = ERXValueUtilities.dictionaryValue(entity.userInfo().objectForKey(\"ERXValidation\"));\n        _validationQualiferCache = (NSMutableDictionary) ERXMutableDictionary.synchronizedDictionary();\n    }","id":77504,"modified_method":"/**\n     * Public constructor\n     * @param entity that this class description corresponds to\n     */\n    public ERXEntityClassDescription(EOEntity entity) {\n        super(entity);\n        _validationInfo = ERXValueUtilities.dictionaryValue(entity.userInfo().objectForKey(\"ERXValidation\"));\n        _validationQualiferCache = ERXMutableDictionary.synchronizedDictionary();\n    }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** Public constructor */\n        public Factory() {}","id":77505,"modified_method":"/** Public constructor */\n    \tpublic Factory() {\n    \t\t// Need to be able to preempt the model registering descriptions.\n    \t\tNSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"modelWasAdded\", ERXConstant.NotificationClassArray), EOModelGroup.ModelAddedNotification, null);\n    \t\tNSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"modelGroupWasAdded\", ERXConstant.NotificationClassArray), ERXModelGroup.ModelGroupAddedNotification, null);\n    \t\tNSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"classDescriptionNeededForEntityName\", ERXConstant.NotificationClassArray), EOClassDescription.ClassDescriptionNeededForEntityNameNotification, null);\n    \t\tNSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"classDescriptionNeededForClass\", ERXConstant.NotificationClassArray), EOClassDescription.ClassDescriptionNeededForClassNotification, null);\n    \t}","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * This method is called when a class description is\n         * needed for a particular class. Here we use the\n         * previous cache that we constructed of class to\n         * entity map when the models were loaded. In this\n         * way we can register all of the custom class\n         * descriptions for a given class if need be.\n         * @param class1 class object to have a custom class\n         *\t\tdescription registered for.\n         */\n        public void registerDescriptionForClass(Class class1) {\n            NSArray entities = (NSArray)_entitiesForClass.objectForKey(class1.getName());\n            if (entities != null) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Registering descriptions for class: \" + class1.getName() + \" found entities: \" + entities.valueForKey(\"name\"));\n                for (Enumeration e = entities.objectEnumerator(); e.hasMoreElements();) {\n                    EOEntity entity = (EOEntity)e.nextElement();\n                    ERXEntityClassDescription cd = newClassDescriptionForEntity(entity);\n                    EOClassDescription.registerClassDescription(cd, class1);\n                    _setClassDescriptionOnEntity(entity, cd);\n                }\n            } else {\n            \tif(class1.getName().indexOf('$') < 0) {\n            \t\tlog.error(\"Unable to register descriptions for class: \" + class1.getName(), new RuntimeException(\"Dummy\"));\n            \t}\n            }\n        }","id":77506,"modified_method":"/**\n         * This method is called when a class description is\n         * needed for a particular class. Here we use the\n         * previous cache that we constructed of class to\n         * entity map when the models were loaded. In this\n         * way we can register all of the custom class\n         * descriptions for a given class if need be.\n         * @param class1 class object to have a custom class\n         *\t\tdescription registered for.\n         */\n        protected void registerDescriptionForClass(Class class1) {\n            NSArray entities = (NSArray)_entitiesForClass.objectForKey(class1.getName());\n            if (entities != null) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Registering descriptions for class: \" + class1.getName() + \" found entities: \" + entities.valueForKey(\"name\"));\n                for (Enumeration e = entities.objectEnumerator(); e.hasMoreElements();) {\n                    EOEntity entity = (EOEntity)e.nextElement();\n                    ERXEntityClassDescription cd = newClassDescriptionForEntity(entity);\n                    EOClassDescription.registerClassDescription(cd, class1);\n                    _setClassDescriptionOnEntity(entity, cd);\n                }\n            } else {\n            \tif(class1.getName().indexOf('$') < 0) {\n            \t\tlog.error(\"Unable to register descriptions for class: \" + class1.getName(), new RuntimeException(\"Dummy\"));\n            \t}\n            }\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * Registers a custom class description for the given\n         * entity using the method <code>newClassDescriptionForEntity<\/code>\n         * which can be overridden by subclasses to provide a\n         * different class description subclass.\n         * @param entity to register the class description for\n         */\n        public void registerDescriptionForEntity(EOEntity entity) {\n            Class entityClass = EOGenericRecord.class;\n            try {\n                String className = entity.className();\n                if (log.isDebugEnabled())\n                    log.debug(\"Registering description for entity: \" + entity.name() + \" with class: \" + className);\n                entityClass = className.equals(\"EOGenericRecord\") ? EOGenericRecord.class : Class.forName(className);\n            } catch (java.lang.ClassNotFoundException ex) {\n                log.warn(\"Invalid class name for entity: \" + entity.name() + \" exception: \" + ex + \" using \" + entityClass.getName() + \" instead\");\n                entity.setClassName(\"EOGenericRecord\");\n            }\n            ERXEntityClassDescription cd = newClassDescriptionForEntity(entity);\n            EOClassDescription.registerClassDescription(cd, entityClass);\n            _setClassDescriptionOnEntity(entity, cd);\n        }","id":77507,"modified_method":"/**\n         * Registers a custom class description for the given\n         * entity using the method <code>newClassDescriptionForEntity<\/code>\n         * which can be overridden by subclasses to provide a\n         * different class description subclass.\n         * @param entity to register the class description for\n         */\n        protected void registerDescriptionForEntity(EOEntity entity) {\n            Class entityClass = EOGenericRecord.class;\n            try {\n                String className = entity.className();\n                if (log.isDebugEnabled())\n                    log.debug(\"Registering description for entity: \" + entity.name() + \" with class: \" + className);\n                entityClass = className.equals(\"EOGenericRecord\") ? EOGenericRecord.class : Class.forName(className);\n            } catch (java.lang.ClassNotFoundException ex) {\n                log.warn(\"Invalid class name for entity: \" + entity.name() + \" exception: \" + ex + \" using \" + entityClass.getName() + \" instead\");\n                entity.setClassName(\"EOGenericRecord\");\n            }\n            ERXEntityClassDescription cd = newClassDescriptionForEntity(entity);\n            EOClassDescription.registerClassDescription(cd, entityClass);\n            _setClassDescriptionOnEntity(entity, cd);\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isRapidTurnaroundEnabled() {\n            if(_isRapidTurnaroundEnabled == null) {\n                _isRapidTurnaroundEnabled = ERXProperties.booleanForKey(\"er.extensions.ERXEntityClassDescription.isRapidTurnaroundEnabled\") ? Boolean.TRUE : Boolean.FALSE;\n            }\n            return _isRapidTurnaroundEnabled.booleanValue();\n        }","id":77508,"modified_method":"protected boolean isRapidTurnaroundEnabled() {\n            return ERXProperties.booleanForKey(\"er.extensions.ERXEntityClassDescription.isRapidTurnaroundEnabled\");\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * This method is called by the principal class\n     * of the framework when the framework's NSBundle is\n     * loaded. This method registers an observer, either\n     * a Factory object, ehich is an inner class of this class\n     * or a custom Factory subclass specified in the property:\n     * <b>er.extensions.ERXClassDescription.factoryClass<\/b>.\n     * This observer listens for notifications when a model\n     * is loaded or a class description is needed and responds\n     * by creating and registering custom class descriptions.\n     */\n    public static void registerDescription() {\n        if (!_registered) {\n            _factory = null;\n            try {\n                String className = System.getProperty(\"er.extensions.ERXClassDescription.factoryClass\");\n                if (className != null) {\n                    _factory = (Factory)Class.forName(className).newInstance();\n                }\n            } catch(Exception ex) {\n                log.warn(\"Exception while registering factory, using default: \" + ex );\n            }\n            \n            if(_factory == null)\n                _factory=new Factory();\n\n            // Need to be able to preempt the model registering descriptions.\n            NSNotificationCenter.defaultCenter().addObserver(_factory, new NSSelector(\"modelWasAddedNotification\", ERXConstant.NotificationClassArray), EOModelGroup.ModelAddedNotification, null);\n            NSNotificationCenter.defaultCenter().addObserver(_factory, new NSSelector(\"applicationDidFinishLaunching\", ERXConstant.NotificationClassArray), WOApplication.ApplicationWillFinishLaunchingNotification, null);\n            NSNotificationCenter.defaultCenter().addObserver(_factory, new NSSelector(\"classDescriptionNeededForEntityName\", ERXConstant.NotificationClassArray), EOClassDescription.ClassDescriptionNeededForEntityNameNotification, null);\n            NSNotificationCenter.defaultCenter().addObserver(_factory, new NSSelector(\"classDescriptionNeededForClass\", ERXConstant.NotificationClassArray), EOClassDescription.ClassDescriptionNeededForClassNotification, null);\n            _registered = true;\n        }\n    }","id":77509,"modified_method":"/**\n     * This method is called by the principal class\n     * of the framework when the framework's NSBundle is\n     * loaded. This method registers an observer, either\n     * a Factory object, ehich is an inner class of this class\n     * or a custom Factory subclass specified in the property:\n     * <b>er.extensions.ERXClassDescription.factoryClass<\/b>.\n     * This observer listens for notifications when a model\n     * is loaded or a class description is needed and responds\n     * by creating and registering custom class descriptions.\n     */\n    public static void registerDescription() {\n    \tif (_factory == null) {\n    \t\t_factory = null;\n    \t\ttry {\n    \t\t\tString className = System.getProperty(\"er.extensions.ERXClassDescription.factoryClass\");\n    \t\t\tif (className != null) {\n    \t\t\t\t_factory = (Factory)Class.forName(className).newInstance();\n    \t\t\t}\n    \t\t} catch(Exception ex) {\n    \t\t\tlog.warn(\"Exception while registering factory, using default: \" + ex );\n    \t\t}\n\n    \t\tif(_factory == null)\n    \t\t\t_factory=new Factory();\n    \t}\n    }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * This method registers custom class descriptions for all\n         * of the entities in a given model. This method is called\n         * when a model is loaded. The reason for this method is\n         * to preempt the usual class description loading mechanism\n         * which has a race condition involved for the order in\n         * which the notifications are recieved.\n         * @param model that contains all of the entities to be registerd\n         */\n        public void registerDescriptionForEntitiesInModel(EOModel model) {\n            if (!_registeredModelNames.containsObject(model.name())) {\n                for (Enumeration e = model.entities().objectEnumerator(); e.hasMoreElements();) {\n                    EOEntity eoentity = (EOEntity)e.nextElement();\n                    String className = eoentity.className();\n\n                    prepareEntityForRegistration(eoentity);\n\n                    NSMutableArray array = (NSMutableArray)_entitiesForClass.objectForKey(className);\n                    if(array == null) {\n                        array = new NSMutableArray();\n                    }\n                    if (log.isDebugEnabled())\n                        log.debug(\"Adding entity \" +eoentity.name()+ \" with class \" + eoentity.className());\n                    array.addObject(eoentity);\n                    _entitiesForClass.setObjectForKey(array, eoentity.className());\n\n                    //HACK ALERT: (ak) We work around classDescriptionForNewInstances() of EOEntity being broken here...\n                    registerDescriptionForEntity(eoentity);\n                }\n                _registeredModelNames.addObject(model.name());\n            }\n            \n            // Don't want this guy getting in our way later on ;\n            NSNotificationCenter.defaultCenter().removeObserver(model);\n        }","id":77510,"modified_method":"/**\n         * This method registers custom class descriptions for all\n         * of the entities in a given model. This method is called\n         * when a model is loaded. The reason for this method is\n         * to preempt the usual class description loading mechanism\n         * which has a race condition involved for the order in\n         * which the notifications are recieved.\n         * @param model that contains all of the entities to be registerd\n         */\n        protected void registerDescriptionForEntitiesInModel(EOModel model) {\n            if (!_registeredModelNames.containsObject(model.name())) {\n                for (Enumeration e = model.entities().objectEnumerator(); e.hasMoreElements();) {\n                    EOEntity eoentity = (EOEntity)e.nextElement();\n                    String className = eoentity.className();\n\n                    prepareEntityForRegistration(eoentity);\n\n                    NSMutableArray array = (NSMutableArray)_entitiesForClass.objectForKey(className);\n                    if(array == null) {\n                        array = new NSMutableArray();\n                    }\n                    if (log.isDebugEnabled())\n                        log.debug(\"Adding entity \" +eoentity.name()+ \" with class \" + eoentity.className());\n                    array.addObject(eoentity);\n                    _entitiesForClass.setObjectForKey(array, eoentity.className());\n\n                    //HACK ALERT: (ak) We work around classDescriptionForNewInstances() of EOEntity being broken here...\n                    registerDescriptionForEntity(eoentity);\n                }\n                _registeredModelNames.addObject(model.name());\n            }\n            \n            // Don't want this guy getting in our way later on ;\n            NSNotificationCenter.defaultCenter().removeObserver(model);\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * Method called by the {@link com.webobjects.foundation.NSNotificationCenter NSNotificationCenter}   \n         * when an EOModel is loaded. \n         * This method just calls the method\n         * <code>registerDescriptionForEntitiesInModel<\/code>\n         * \n         * @param n notification that has the EOModel that was loaded.\n         */\n        public void modelWasAddedNotification(NSNotification n) {\n            log.debug(\"ModelWasAddedNotification: \" + ((EOModel)n.object()).name());\n            // Don't want this guy getting in our way.\n            // FIXME: This is done twice\n            NSNotificationCenter.defaultCenter().removeObserver((EOModel)n.object());\n            try {\n                registerDescriptionForEntitiesInModel((EOModel)n.object());\n            } catch (RuntimeException e) {\n                log.error(\"Error registering model: \" + ((EOModel)n.object()).name(), e);\n                throw e;\n            }\n        }","id":77511,"modified_method":"/**\n         * Method called by the {@link com.webobjects.foundation.NSNotificationCenter NSNotificationCenter}   \n         * when an EOModel is loaded. \n         * This method just calls the method\n         * <code>registerDescriptionForEntitiesInModel<\/code>\n         * \n         * @param n notification that has the EOModel that was loaded.\n         */\n        public final void modelWasAdded(NSNotification n) {\n        \tEOModel model = ((EOModel)n.object());\n            log.debug(\"ModelWasAddedNotification: \" + model.name());\n            // Don't want this guy getting in our way.\n            NSNotificationCenter.defaultCenter().removeObserver(model);\n            try {\n                registerDescriptionForEntitiesInModel(model);\n            } catch (RuntimeException e) {\n                log.error(\"Error registering model: \" + model.name(), e);\n                throw e;\n            }\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isFixingRelationshipsEnabled() {\n            if(_isFixingRelationshipsEnabled == null) {\n                _isFixingRelationshipsEnabled = ERXProperties.booleanForKey(\"er.extensions.ERXEntityClassDescription.isFixingRelationshipsEnabled\") ? Boolean.TRUE : Boolean.FALSE;\n            }\n            return _isFixingRelationshipsEnabled.booleanValue();\n        }","id":77512,"modified_method":"protected boolean isFixingRelationshipsEnabled() {\n            return ERXProperties.booleanForKey(\"er.extensions.ERXEntityClassDescription.isFixingRelationshipsEnabled\");\n        }","commit_id":"b146105a5642c151bfc9a7833e06356c0573714e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws IOException {\n    String[] taggerTokens;\n    \n    List<AnalyzedTokenReadings> tokenReadings = new ArrayList<AnalyzedTokenReadings>();\n    int pos = 0;\n    //caching Lametyzator instance - lazy init\n    if (morfologik == null) {   \n       File resourceFile = JLanguageTool.getAbsoluteFile(RESOURCE_FILENAME); \n       morfologik = new Lametyzator(Tools.getInputStream(resourceFile.getAbsolutePath()),\n              \"iso8859-2\", '+', true, true);\n    }\n    \n    for (Iterator<String> iter = sentenceTokens.iterator(); iter.hasNext();) {\n      String word = iter.next();\n      List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();      \n      String[] lowerTaggerTokens = null;\n        taggerTokens = morfologik.stemAndForm(word);\n        if (word != word.toLowerCase()) {\n        lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());\n        }\n                \n    if (taggerTokens != null) {\n       int i = 0;\n        while (i < taggerTokens.length) {\n            //Lametyzator returns data as String[]\n            //first lemma, then annotations\n            l.add(new AnalyzedToken(word, taggerTokens[i + 1], taggerTokens[i]));\n            i = i + 2;\n        } \n      }     \n    if (lowerTaggerTokens != null) {\n      int i = 0;\n       while (i < lowerTaggerTokens.length) {\n           //Lametyzator returns data as String[]\n           //first lemma, then annotations\n           l.add(new AnalyzedToken(word, lowerTaggerTokens[i + 1], lowerTaggerTokens[i]));\n           i = i + 2;\n       } \n     }        \n    \n    if (lowerTaggerTokens == null && taggerTokens == null) {\n            l.add(new AnalyzedToken(word, null, pos));                       \n    }\n      pos += word.length();\n      tokenReadings.add(new AnalyzedTokenReadings((AnalyzedToken[])l.toArray(new AnalyzedToken[0])));\n   }\n    \n    return tokenReadings;\n\n  }","id":77513,"modified_method":"public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws IOException {\n    String[] taggerTokens;\n    \n    List<AnalyzedTokenReadings> tokenReadings = new ArrayList<AnalyzedTokenReadings>();\n    int pos = 0;\n    //caching Lametyzator instance - lazy init\n    if (morfologik == null) {   \n       File resourceFile = JLanguageTool.getAbsoluteFile(RESOURCE_FILENAME); \n       morfologik = new Lametyzator(Tools.getInputStream(resourceFile.getAbsolutePath()),\n              \"iso8859-2\", '+', true, true);\n    }\n    \n    for (Iterator<String> iter = sentenceTokens.iterator(); iter.hasNext();) {\n      String word = iter.next();\n      List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();      \n      String[] lowerTaggerTokens = null;\n      taggerTokens = morfologik.stemAndForm(word);\n      if (word != word.toLowerCase()) {\n        lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());\n        }\n        \n      \n\n      if (taggerTokens != null) {\n        // Lametyzator returns data as String[]\n        // first lemma, then annotations\n/*\n        if(taggerTokens.length > 2)\n        {\n          for (String currStr : taggerTokens)\n            System.out.print(currStr + \" \");\n          \n          System.out.println();\n        }\n    */    \n        String lemma = new String();\n        int i = 0;\n        while (i < taggerTokens.length) {\n          // Czech POS tags:\n          // If there are multiple tags, they behave as one, i.e. they\n          // are connected\n          // on one line with '+' character\n          lemma = taggerTokens[i];\n          String[] tagsArr = taggerTokens[i + 1].split(\"\\\\+\");\n\n          for (String currTag : tagsArr)\n            l.add(new AnalyzedToken(word, currTag, lemma));\n\n          i += 2;\n        }\n      }     \n    \n      if (lowerTaggerTokens != null) {\n        \n        String lemma = new String();\n        int i = 0;\n        while (i < lowerTaggerTokens.length) {\n          // Czech POS tags again\n          lemma = lowerTaggerTokens[i];\n          String[] tagsArr = lowerTaggerTokens[i + 1].split(\"\\\\+\");\n\n          for (String currTag : tagsArr)\n            l.add(new AnalyzedToken(word, currTag, lemma));\n\n          i += 2;\n        }\n      }\n\n      if (lowerTaggerTokens == null && taggerTokens == null) {\n        l.add(new AnalyzedToken(word, null, pos));\n      }\n      pos += word.length();\n      tokenReadings.add(new AnalyzedTokenReadings((AnalyzedToken[])l.toArray(new AnalyzedToken[0])));\n   }\n    \n    return tokenReadings;\n\n  }","commit_id":"cd73b083f50d2959533b6b1607220621d01619be","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testTagger() throws IOException {\n\t  TestTools.myAssert(\"Ukonuje vtu rozkazovac i zvolac.\", \"Ukonuje/[ukonovat]k5eAaImIp3nS vtu/[vta]k1gFnSc4 rozkazovac/[rozkazovac]k2eAgFnPc1d1 i/[i]k8 zvolac/[zvolac]k2eAgFnPc1d1\", tokenizer, tagger);\n    TestTools.myAssert(\"Nahrazuje vynechan psmeno, pouv se pro zkracovn letopot.\", \"Nahrazuje/[nahrazovat]k5eAaImIp3nS vynechan/[vynechan]k2eAgFnPc1d1 psmeno/[psmeno]k1gNnSc1|psmeno/[psmena]k1gFnSc5 pouv/[pouvat]k5eAaImIp3nS se/[se]k3c4 pro/[pro]k7 zkracovn/[zkracovn]k1gNnPc1 letopot/[letopoet]k1gInPc2\", tokenizer, tagger);\n    TestTools.myAssert(\"blablabla\",\"blablabla/[null]null\", tokenizer, tagger);\n\t}","id":77514,"modified_method":"public void testTagger() throws IOException {\n\t  //TestTools.myAssert(\"Ukonuje vtu rozkazovac i zvolac.\", \"Ukonuje/[ukonovat]k5eAaImIp3nS vtu/[vta]k1gFnSc4 rozkazovac/[rozkazovac]k2eAgFnPc1d1 i/[i]k8 zvolac/[zvolac]k2eAgFnPc1d1\", tokenizer, tagger);\n    //TestTools.myAssert(\"Nahrazuje vynechan psmeno, pouv se pro zkracovn letopot.\", \"Nahrazuje/[nahrazovat]k5eAaImIp3nS vynechan/[vynechan]k2eAgFnPc1d1 psmeno/[psmeno]k1gNnSc1|psmeno/[psmena]k1gFnSc5 pouv/[pouvat]k5eAaImIp3nS se/[se]k3c4 pro/[pro]k7 zkracovn/[zkracovn]k1gNnPc1 letopot/[letopoet]k1gInPc2\", tokenizer, tagger);\n    \n\t  TestTools.myAssert(\"Nejkrat vta.\", \"Nejkrat/[krtk]k2eAgFnPc1d3|Nejkrat/[krtk]k2eAgFnPc4d3|Nejkrat/[krtk]k2eAgFnPc5d3|Nejkrat/[krtk]k2eAgFnSc1d3|Nejkrat/[krtk]k2eAgFnSc2d3|Nejkrat/[krtk]k2eAgFnSc3d3|Nejkrat/[krtk]k2eAgFnSc4d3|Nejkrat/[krtk]k2eAgFnSc5d3|Nejkrat/[krtk]k2eAgFnSc6d3|Nejkrat/[krtk]k2eAgFnSc7d3|Nejkrat/[krtk]k2eAgInPc1d3|Nejkrat/[krtk]k2eAgInPc4d3|Nejkrat/[krtk]k2eAgInPc5d3|Nejkrat/[krtk]k2eAgInSc1d3|Nejkrat/[krtk]k2eAgInSc4d3|Nejkrat/[krtk]k2eAgInSc5d3|Nejkrat/[krtk]k2eAgMnPc1d3|Nejkrat/[krtk]k2eAgMnPc4d3|Nejkrat/[krtk]k2eAgMnPc5d3|Nejkrat/[krtk]k2eAgMnSc1d3|Nejkrat/[krtk]k2eAgMnSc5d3|Nejkrat/[krtk]k2eAgNnPc1d3|Nejkrat/[krtk]k2eAgNnPc4d3|Nejkrat/[krtk]k2eAgNnPc5d3|Nejkrat/[krtk]k2eAgNnSc1d3|Nejkrat/[krtk]k2eAgNnSc4d3|Nejkrat/[krtk]k2eAgNnSc5d3 vta/[vta]k1gFnSc1\", tokenizer, tagger);\n    TestTools.myAssert(\"zvolac.\", \"zvolac/[zvolac]k2eAgFnPc1d1|zvolac/[zvolac]k2eAgFnPc4d1|zvolac/[zvolac]k2eAgFnPc5d1|zvolac/[zvolac]k2eAgFnSc1d1|zvolac/[zvolac]k2eAgFnSc2d1|zvolac/[zvolac]k2eAgFnSc3d1|zvolac/[zvolac]k2eAgFnSc4d1|zvolac/[zvolac]k2eAgFnSc5d1|zvolac/[zvolac]k2eAgFnSc6d1|zvolac/[zvolac]k2eAgFnSc7d1|zvolac/[zvolac]k2eAgInPc1d1|zvolac/[zvolac]k2eAgInPc4d1|zvolac/[zvolac]k2eAgInPc5d1|zvolac/[zvolac]k2eAgInSc1d1|zvolac/[zvolac]k2eAgInSc4d1|zvolac/[zvolac]k2eAgInSc5d1|zvolac/[zvolac]k2eAgMnPc1d1|zvolac/[zvolac]k2eAgMnPc4d1|zvolac/[zvolac]k2eAgMnPc5d1|zvolac/[zvolac]k2eAgMnSc1d1|zvolac/[zvolac]k2eAgMnSc5d1|zvolac/[zvolac]k2eAgNnPc1d1|zvolac/[zvolac]k2eAgNnPc4d1|zvolac/[zvolac]k2eAgNnPc5d1|zvolac/[zvolac]k2eAgNnSc1d1|zvolac/[zvolac]k2eAgNnSc4d1|zvolac/[zvolac]k2eAgNnSc5d1\", tokenizer, tagger);\n\t  TestTools.myAssert(\"blablabla\",\"blablabla/[null]null\", tokenizer, tagger);\n\t}","commit_id":"cd73b083f50d2959533b6b1607220621d01619be","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Command line arguments for this program:\n   * <br>\n   * -output: the model file to output\n   * -input: a list of model files to input\n   */\n  public static void main(String[] args) {\n    String outputModelFilename = null;\n    List<String> inputModelFilenames = Generics.newArrayList();\n    \n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        outputModelFilename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        for (++argIndex; argIndex < args.length && !args[argIndex].startsWith(\"-\"); ++argIndex) {\n          inputModelFilenames.add(args[argIndex]);\n        }\n      } else {\n        throw new RuntimeException(\"Unknown argument \" + args[argIndex]);\n      }\n    }\n\n    System.err.println(outputModelFilename);\n    System.err.println(inputModelFilenames);\n\n    LexicalizedParser lexparser = null;\n    List<DVModel> models = Generics.newArrayList();\n    for (String filename : inputModelFilenames) {\n      LexicalizedParser parser = LexicalizedParser.loadModel(filename);\n      if (lexparser == null) {\n        lexparser = parser;\n      }\n      models.add(DVParser.getModelFromLexicalizedParser(parser));\n    }\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryTransform;\n          }\n        });\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryTransform;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> wordMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.wordVectors;\n          }\n        });\n\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryTransformAverages = averageBinaryMatrices(binaryTransformMaps);\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreAverages = averageBinaryMatrices(binaryScoreMaps);\n    Map<String, SimpleMatrix> unaryTransformAverages = averageUnaryMatrices(unaryTransformMaps);\n    Map<String, SimpleMatrix> unaryScoreAverages = averageUnaryMatrices(unaryScoreMaps);\n    Map<String, SimpleMatrix> wordAverages = averageUnaryMatrices(wordMaps);\n\n    DVModel newModel = new DVModel(binaryTransformAverages, unaryTransformAverages,\n                                   binaryScoreAverages, unaryScoreAverages,\n                                   wordAverages, lexparser.getOp());\n    DVParser newParser = new DVParser(newModel, lexparser);\n    newParser.saveModel(outputModelFilename);\n  }","id":77515,"modified_method":"/**\n   * Command line arguments for this program:\n   * <br>\n   * -output: the model file to output\n   * -input: a list of model files to input\n   */\n  public static void main(String[] args) {\n    String outputModelFilename = null;\n    List<String> inputModelFilenames = Generics.newArrayList();\n    \n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        outputModelFilename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        for (++argIndex; argIndex < args.length && !args[argIndex].startsWith(\"-\"); ++argIndex) {\n          inputModelFilenames.addAll(Arrays.asList(args[argIndex].split(\",\")));\n        }\n      } else {\n        throw new RuntimeException(\"Unknown argument \" + args[argIndex]);\n      }\n    }\n\n    if (outputModelFilename == null) {\n      System.err.println(\"Need to specify output model name with -output\");\n      System.exit(2);\n    }\n\n    if (inputModelFilenames.size() == 0) {\n      System.err.println(\"Need to specify input model names with -input\");\n      System.exit(2);\n    }\n\n    System.err.println(\"Averaging \" + inputModelFilenames);\n    System.err.println(\"Outputting result to \" + outputModelFilename);\n\n    LexicalizedParser lexparser = null;\n    List<DVModel> models = Generics.newArrayList();\n    for (String filename : inputModelFilenames) {\n      LexicalizedParser parser = LexicalizedParser.loadModel(filename);\n      if (lexparser == null) {\n        lexparser = parser;\n      }\n      models.add(DVParser.getModelFromLexicalizedParser(parser));\n    }\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryTransform;\n          }\n        });\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryTransform;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> wordMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.wordVectors;\n          }\n        });\n\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryTransformAverages = averageBinaryMatrices(binaryTransformMaps);\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreAverages = averageBinaryMatrices(binaryScoreMaps);\n    Map<String, SimpleMatrix> unaryTransformAverages = averageUnaryMatrices(unaryTransformMaps);\n    Map<String, SimpleMatrix> unaryScoreAverages = averageUnaryMatrices(unaryScoreMaps);\n    Map<String, SimpleMatrix> wordAverages = averageUnaryMatrices(wordMaps);\n\n    DVModel newModel = new DVModel(binaryTransformAverages, unaryTransformAverages,\n                                   binaryScoreAverages, unaryScoreAverages,\n                                   wordAverages, lexparser.getOp());\n    DVParser newParser = new DVParser(newModel, lexparser);\n    newParser.saveModel(outputModelFilename);\n  }","commit_id":"5560b28e649494240e2acc3f0527a18eec5890dd","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Command line arguments for this program:\n   * <br>\n   * -output: the model file to output\n   * -input: a list of model files to input\n   */\n  public static void main(String[] args) {\n    String outputModelFilename = null;\n    List<String> inputModelFilenames = Generics.newArrayList();\n    \n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        outputModelFilename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        for (++argIndex; argIndex < args.length && !args[argIndex].startsWith(\"-\"); ++argIndex) {\n          inputModelFilenames.add(args[argIndex]);\n        }\n      } else {\n        throw new RuntimeException(\"Unknown argument \" + args[argIndex]);\n      }\n    }\n\n    System.err.println(outputModelFilename);\n    System.err.println(inputModelFilenames);\n\n    LexicalizedParser lexparser = null;\n    List<DVModel> models = Generics.newArrayList();\n    for (String filename : inputModelFilenames) {\n      LexicalizedParser parser = LexicalizedParser.loadModel(filename);\n      if (lexparser == null) {\n        lexparser = parser;\n      }\n      models.add(DVParser.getModelFromLexicalizedParser(parser));\n    }\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryTransform;\n          }\n        });\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryTransform;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> wordMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.wordVectors;\n          }\n        });\n\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryTransformAverages = averageBinaryMatrices(binaryTransformMaps);\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreAverages = averageBinaryMatrices(binaryScoreMaps);\n    Map<String, SimpleMatrix> unaryTransformAverages = averageUnaryMatrices(unaryTransformMaps);\n    Map<String, SimpleMatrix> unaryScoreAverages = averageUnaryMatrices(unaryScoreMaps);\n    Map<String, SimpleMatrix> wordAverages = averageUnaryMatrices(wordMaps);\n\n    DVModel newModel = new DVModel(binaryTransformAverages, unaryTransformAverages,\n                                   binaryScoreAverages, unaryScoreAverages,\n                                   wordAverages, lexparser.getOp());\n    DVParser newParser = new DVParser(newModel, lexparser);\n    newParser.saveModel(outputModelFilename);\n  }","id":77516,"modified_method":"/**\n   * Command line arguments for this program:\n   * <br>\n   * -output: the model file to output\n   * -input: a list of model files to input\n   */\n  public static void main(String[] args) {\n    String outputModelFilename = null;\n    List<String> inputModelFilenames = Generics.newArrayList();\n    \n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-output\")) {\n        outputModelFilename = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        for (++argIndex; argIndex < args.length && !args[argIndex].startsWith(\"-\"); ++argIndex) {\n          inputModelFilenames.addAll(Arrays.asList(args[argIndex].split(\",\")));\n        }\n      } else {\n        throw new RuntimeException(\"Unknown argument \" + args[argIndex]);\n      }\n    }\n\n    if (outputModelFilename == null) {\n      System.err.println(\"Need to specify output model name with -output\");\n      System.exit(2);\n    }\n\n    if (inputModelFilenames.size() == 0) {\n      System.err.println(\"Need to specify input model names with -input\");\n      System.exit(2);\n    }\n\n    System.err.println(\"Averaging \" + inputModelFilenames);\n    System.err.println(\"Outputting result to \" + outputModelFilename);\n\n    LexicalizedParser lexparser = null;\n    List<DVModel> models = Generics.newArrayList();\n    for (String filename : inputModelFilenames) {\n      LexicalizedParser parser = LexicalizedParser.loadModel(filename);\n      if (lexparser == null) {\n        lexparser = parser;\n      }\n      models.add(DVParser.getModelFromLexicalizedParser(parser));\n    }\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryTransform;\n          }\n        });\n\n    List<TwoDimensionalMap<String, String, SimpleMatrix>> binaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, TwoDimensionalMap<String, String, SimpleMatrix>>() {\n          public TwoDimensionalMap<String, String, SimpleMatrix> apply(DVModel model) {\n            return model.binaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryTransformMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryTransform;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> unaryScoreMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.unaryScore;\n          }\n        });\n\n    List<Map<String, SimpleMatrix>> wordMaps =\n      CollectionUtils.transformAsList(models, new Function<DVModel, Map<String, SimpleMatrix>>() {\n          public Map<String, SimpleMatrix> apply(DVModel model) {\n            return model.wordVectors;\n          }\n        });\n\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryTransformAverages = averageBinaryMatrices(binaryTransformMaps);\n    TwoDimensionalMap<String, String, SimpleMatrix> binaryScoreAverages = averageBinaryMatrices(binaryScoreMaps);\n    Map<String, SimpleMatrix> unaryTransformAverages = averageUnaryMatrices(unaryTransformMaps);\n    Map<String, SimpleMatrix> unaryScoreAverages = averageUnaryMatrices(unaryScoreMaps);\n    Map<String, SimpleMatrix> wordAverages = averageUnaryMatrices(wordMaps);\n\n    DVModel newModel = new DVModel(binaryTransformAverages, unaryTransformAverages,\n                                   binaryScoreAverages, unaryScoreAverages,\n                                   wordAverages, lexparser.getOp());\n    DVParser newParser = new DVParser(newModel, lexparser);\n    newParser.saveModel(outputModelFilename);\n  }","commit_id":"cffbcf5619fcab3a5fe8a7f65fffbbe25707f296","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"protected boolean tryRemoveInternal(final Data key, final long timeout, final TimeUnit timeunit) {\n        TryRemoveOperation operation = new TryRemoveOperation(name, key, getTimeInMillis(timeout, timeunit));\n        boolean removed = (Boolean) invokeOperation(key, operation);\n        if (removed) {\n            invalidateLocalNearCache(key);\n        }\n        return removed;\n    }","id":77517,"modified_method":"protected boolean tryRemoveInternal(final Data key, final long timeout, final TimeUnit timeunit) {\n        TryRemoveOperation operation = new TryRemoveOperation(name, key, getTimeInMillis(timeout, timeunit));\n        boolean removed = (Boolean) invokeOperation(key, operation);\n        invalidateLocalNearCache(key);\n        return removed;\n    }","commit_id":"3fa80529807e5c9616342919bd47aa85db1aa3f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected Data replaceInternal(final Data key, final Data value) {\n        ReplaceOperation operation = new ReplaceOperation(name, key, value);\n        final Data result = (Data) invokeOperation(key, operation);\n        if (result != null) {\n            invalidateLocalNearCache(key);\n        }\n        return result;\n    }","id":77518,"modified_method":"protected Data replaceInternal(final Data key, final Data value) {\n        ReplaceOperation operation = new ReplaceOperation(name, key, value);\n        final Data result = (Data) invokeOperation(key, operation);\n        invalidateLocalNearCache(key);\n        return result;\n    }","commit_id":"3fa80529807e5c9616342919bd47aa85db1aa3f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected boolean evictInternal(final Data key) {\n        EvictOperation operation = new EvictOperation(name, key, false);\n        final boolean evictSuccess = (Boolean) invokeOperation(key, operation);\n        if (evictSuccess) {\n            invalidateLocalNearCache(key);\n        }\n        return evictSuccess;\n    }","id":77519,"modified_method":"protected boolean evictInternal(final Data key) {\n        EvictOperation operation = new EvictOperation(name, key, false);\n        final boolean evictSuccess = (Boolean) invokeOperation(key, operation);\n        invalidateLocalNearCache(key);\n        return evictSuccess;\n    }","commit_id":"3fa80529807e5c9616342919bd47aa85db1aa3f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected boolean tryPutInternal(final Data key, final Data value, final long timeout, final TimeUnit timeunit) {\n        TryPutOperation operation = new TryPutOperation(name, key, value, getTimeInMillis(timeout, timeunit));\n        boolean putSuccessful = (Boolean) invokeOperation(key, operation);\n        if (putSuccessful) {\n            invalidateLocalNearCache(key);\n        }\n        return putSuccessful;\n    }","id":77520,"modified_method":"protected boolean tryPutInternal(final Data key, final Data value, final long timeout, final TimeUnit timeunit) {\n        TryPutOperation operation = new TryPutOperation(name, key, value, getTimeInMillis(timeout, timeunit));\n        boolean putSuccessful = (Boolean) invokeOperation(key, operation);\n        invalidateLocalNearCache(key);\n        return putSuccessful;\n    }","commit_id":"3fa80529807e5c9616342919bd47aa85db1aa3f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected boolean replaceInternal(final Data key, final Data oldValue, final Data newValue) {\n        ReplaceIfSameOperation operation = new ReplaceIfSameOperation(name, key, oldValue, newValue);\n        boolean replaceSuccessful = (Boolean) invokeOperation(key, operation);\n        if (replaceSuccessful) {\n            invalidateLocalNearCache(key);\n        }\n        return replaceSuccessful;\n    }","id":77521,"modified_method":"protected boolean replaceInternal(final Data key, final Data oldValue, final Data newValue) {\n        ReplaceIfSameOperation operation = new ReplaceIfSameOperation(name, key, oldValue, newValue);\n        boolean replaceSuccessful = (Boolean) invokeOperation(key, operation);\n        invalidateLocalNearCache(key);\n        return replaceSuccessful;\n    }","commit_id":"3fa80529807e5c9616342919bd47aa85db1aa3f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected boolean removeInternal(final Data key, final Data value) {\n        RemoveIfSameOperation operation = new RemoveIfSameOperation(name, key, value);\n        boolean removed = (Boolean) invokeOperation(key, operation);\n        if (removed) {\n            invalidateLocalNearCache(key);\n        }\n        return removed;\n    }","id":77522,"modified_method":"protected boolean removeInternal(final Data key, final Data value) {\n        RemoveIfSameOperation operation = new RemoveIfSameOperation(name, key, value);\n        boolean removed = (Boolean) invokeOperation(key, operation);\n        invalidateLocalNearCache(key);\n        return removed;\n    }","commit_id":"3fa80529807e5c9616342919bd47aa85db1aa3f6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n  @NotNull\n  @NonNls\n  public String getName() {\n    return myName;\n  }","id":77523,"modified_method":"/**\n   * Pre-evaluated name of the file. This method doesn't require model access.\n   */\n  @Override\n  @NotNull\n  @NonNls\n  public String getName() {\n    return myName;\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public /*FIXME: package*/ void invalidate() {\n    myNode = null;\n  }","id":77524,"modified_method":"void invalidate() {\n    myRepoFiles.forgetVirtualFile(myNode);\n    myNode = null;\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String getPresentableName() {\n    return myPresentationName;\n  }","id":77525,"modified_method":"/**\n   * Pre-evaluated user-presentable name of the file, may include extra information to distinguish nodes with the same {@linkplain #getName() name}.\n   * This method doesn't require model access.\n   */\n  @Override\n  public String getPresentableName() {\n    return myPresentationName;\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public /*FIXME: package*/ void updateFields() {\n    myRepoFiles.getRepository().getModelAccess().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        SNode node = myNode.resolve(myRepoFiles.getRepository());\n        if (node == null) {\n          LOG.error(new Throwable(\"Cannot find node for passed SNodeReference: \" + myNode.toString()));\n          myName = myPresentationName = \"\";\n          myPath = \"\";\n        } else {\n          myName = myPresentationName = String.valueOf(node.getPresentation());\n          if (node.getModel() != null && node.getModel().getModule() instanceof TransientSModule) {\n            // it's common to open same node from different generation steps (transient models)\n            // and to tell nodes from different steps we append model's identification\n            final String s = node.getModel().getName().getStereotype();\n            if (!s.isEmpty()) {\n              myPresentationName = myName + '@' + s;\n            }\n          }\n          myPath = NODE_PREFIX + myRepoFiles.getPathFacility().serializeNode(node);\n          myTimeStamp = node.getModel().getSource().getTimestamp();\n        }\n      }\n    });\n  }","id":77526,"modified_method":"void updateFields() {\n    myRepoFiles.getRepository().getModelAccess().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        SNode node = myNode.resolve(myRepoFiles.getRepository());\n        if (node == null) {\n          LOG.error(new Throwable(\"Cannot find node for passed SNodeReference: \" + myNode.toString()));\n          myName = myPresentationName = \"\";\n          myPath = \"\";\n        } else {\n          myName = myPresentationName = String.valueOf(node.getPresentation());\n          if (node.getModel() != null && node.getModel().getModule() instanceof TransientSModule) {\n            // it's common to open same node from different generation steps (transient models)\n            // and to tell nodes from different steps we append model's identification\n            final String s = node.getModel().getName().getStereotype();\n            if (!s.isEmpty()) {\n              myPresentationName = myName + '@' + s;\n            }\n          }\n          myPath = NODE_PREFIX + myRepoFiles.getPathFacility().serializeNode(node);\n          myTimeStamp = node.getModel().getSource().getTimestamp();\n        }\n      }\n    });\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MPSModelVirtualFile getFileFor(@NotNull SRepository repository, @NotNull final SModelReference modelReference) {\n    return myGlobalRepoFiles.getFileFor(modelReference);\n  }","id":77527,"modified_method":"public MPSModelVirtualFile getFileFor(@NotNull SRepository repository, @NotNull final SModelReference modelReference) {\n    final RepositoryVirtualFiles rvf = findForRepository(repository);\n    return rvf != null ? rvf.getFileFor(modelReference) : myGlobalRepoFiles.getFileFor(modelReference);\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void eventsHappenedInCommand(final List<SModelEvent> events) {\n      MyModelEventVisitor visitor = new MyModelEventVisitor();\n      for (SModelEvent e : events) {\n        e.accept(visitor);\n      }\n      final VFSNotifier vfsNotifier = new VFSNotifier(visitor.myDeletedFiles, visitor.myRenamedFiles);\n      if (vfsNotifier.hasPendingNotifications()) {\n        for (MPSNodeVirtualFile deletedFile : visitor.myDeletedFiles) {\n          forgetVirtualFile(deletedFile.getSNodePointer());\n        }\n        ModelAccess.instance().runWriteInEDT(vfsNotifier);\n      }\n    }","id":77528,"modified_method":"@Override\n    public void eventsHappenedInCommand(final List<SModelEvent> events) {\n      MyModelEventVisitor visitor = new MyModelEventVisitor();\n      for (SModelEvent e : events) {\n        e.accept(visitor);\n      }\n      final VFSNotifier vfsNotifier = new VFSNotifier(myGlobalRepoFiles); // FIXME use of global repo shall get replaced with actual repo\n      vfsNotifier.deleted(visitor.myDeletedFiles);\n      vfsNotifier.renamed(visitor.myRenamedFiles);\n      vfsNotifier.execute();\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void forget(SModel modelDescriptor) {\n      if (!(modelDescriptor.isLoaded())) {\n        return;\n      }\n\n      Collection<MPSNodeVirtualFile> deletedFiles = new ArrayList<MPSNodeVirtualFile>();\n      for (SNode root : modelDescriptor.getRootNodes()) {\n        SNodeReference pointer = root.getReference();\n        MPSNodeVirtualFile vf = getVirtualFile(pointer);\n        if (vf != null) {\n          deletedFiles.add(vf);\n          forgetVirtualFile(pointer);\n        }\n      }\n      VFSNotifier vfsNotifier = new VFSNotifier(deletedFiles, Collections.<Pair<MPSNodeVirtualFile, String>>emptyList());\n      if (vfsNotifier.hasPendingNotifications()) {\n        myRepository.getModelAccess().runWriteInEDT(vfsNotifier);\n      }\n    }","id":77529,"modified_method":"private void forget(SModel modelDescriptor) {\n      final RepositoryVirtualFiles rvf = findRepoFiles(modelDescriptor);\n      if (rvf == null) {\n        return;\n      }\n      VFSNotifier vfsNotifier = new VFSNotifier(rvf);\n      vfsNotifier.deleted(rvf.getKnownVirtualFilesIn(modelDescriptor.getReference()));\n      vfsNotifier.execute();\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NodeVirtualFileSystem(MPSCoreComponents coreComponents) {\n    // FIXME this component shall be ProjectComponent, pass MPSProject.getRepository(); initialize in projectOpened()\n    SRepository myRepository = coreComponents.getModuleRepository();\n    myGlobalRepoFiles = new RepositoryVirtualFiles(this, myRepository);\n    myRepositoryListener = new MyRepositoryListener(myRepository);\n  }","id":77530,"modified_method":"public NodeVirtualFileSystem(MPSCoreComponents coreComponents) {\n    // FIXME this component shall be ProjectComponent, pass MPSProject.getRepository(); initialize in projectOpened()\n    SRepository myRepository = coreComponents.getModuleRepository();\n    myGlobalRepoFiles = new RepositoryVirtualFiles(this, myRepository);\n    myRepositoryListener = new MyRepositoryListener();\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MyRepositoryListener(SRepository repo) {\n      myRepository = repo;\n    }","id":77531,"modified_method":"public MyRepositoryListener() {\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"void register(@NotNull RepositoryVirtualFiles repoFiles) {\n    // assert not more than 1 file container per repository\n  }","id":77532,"modified_method":"synchronized void register(@NotNull RepositoryVirtualFiles repoFiles) {\n    // assert not more than 1 file container per repository\n    RepositoryVirtualFiles existing = findForRepository(repoFiles.getRepository());\n    if (existing != null) {\n      throw new IllegalArgumentException(\"Attempt to register another VirtualFile container for the same repository\");\n    }\n    // sort of stack, most recent first. just for fun, no hidden assumptions.\n    myPerRepositoryFiles.add(0, repoFiles);\n    new RepoListenerRegistrar(repoFiles.getRepository(), myRepositoryListener).attach();\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void eventFired(SModelEvent event) {\n      SNode root = event.getAffectedRoot();\n      if (root != null) {\n        updateModificationStamp(Collections.singleton(root));\n      }\n    }","id":77533,"modified_method":"@Override\n    public void eventFired(SModelEvent event) {\n      SNode root = event.getAffectedRoot();\n      MPSNodeVirtualFile vf;\n      if (root != null && (vf = getVirtualFile(root.getReference())) != null) {\n        // FIXME is affectedRoot is null for model dependencies/imports changed event? Why then we listen to SModelEvent?\n        updateModificationStamp(Collections.singleton(vf));\n      }\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void run() {\n      if (myDisposed) {\n        return;\n      }\n      for (MPSNodeVirtualFile deletedFile : myDeleterFiles) {\n        fireBeforeFileDeletion(this, deletedFile);\n        deletedFile.invalidate();\n        fireFileDeleted(this, deletedFile, deletedFile.getName(), null);\n      }\n\n      for (Pair<MPSNodeVirtualFile, String> renamedFile : myRenamedFiles) {\n        MPSNodeVirtualFile vf = renamedFile.o1;\n        vf.updateFields();\n      }\n    }","id":77534,"modified_method":"@Override\n    public void run() {\n      if (myDisposed) {\n        return;\n      }\n      ArrayList<MPSNodeVirtualFile> deletedFiles;\n      ArrayList<Pair<MPSNodeVirtualFile, String>> renamedFiles;\n      synchronized (this) {\n        deletedFiles = new ArrayList<>(myDeletedFiles);\n        renamedFiles = new ArrayList<>(myRenamedFiles);\n        myDeletedFiles.clear();\n        myRenamedFiles.clear();\n      }\n\n      for (MPSNodeVirtualFile deletedFile : deletedFiles) {\n        fireBeforeFileDeletion(this, deletedFile);\n        deletedFile.invalidate();\n        fireFileDeleted(this, deletedFile, deletedFile.getName(), null);\n      }\n\n      for (Pair<MPSNodeVirtualFile, String> renamedFile : renamedFiles) {\n        MPSNodeVirtualFile vf = renamedFile.o1;\n        firePropertyChanged(this, vf, VirtualFile.PROP_NAME, renamedFile.o2, vf.getName());\n      }\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"void updateModificationStamp(Iterable<SNode> roots) {\n    // identical timestamp for all roots touched simultaneously\n    final long vfsStamp = LocalTimeCounter.currentTime();\n    final long localStamp = System.currentTimeMillis();\n    for (SNode rootNode : roots) {\n      if (rootNode.getModel() == null) {\n        continue;\n      }\n      MPSNodeVirtualFile vf = getVirtualFile(rootNode.getReference());\n      if (vf != null) {\n        vf.setModificationStamp(vfsStamp);\n        vf.setTimeStamp(localStamp);\n      }\n    }\n  }","id":77535,"modified_method":"void updateModificationStamp(Collection<MPSNodeVirtualFile> files) {\n    // identical timestamp for all roots touched simultaneously\n    final long vfsStamp = LocalTimeCounter.currentTime();\n    final long localStamp = System.currentTimeMillis();\n    for (MPSNodeVirtualFile vf : files) {\n      vf.setModificationStamp(vfsStamp);\n      vf.setTimeStamp(localStamp);\n    }\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MPSNodeVirtualFile getFileFor(@NotNull SRepository repository, @NotNull final SNodeReference nodePointer) {\n    return myGlobalRepoFiles.getFileFor(nodePointer);\n  }","id":77536,"modified_method":"public MPSNodeVirtualFile getFileFor(@NotNull SRepository repository, @NotNull final SNodeReference nodePointer) {\n    final RepositoryVirtualFiles rvf = findForRepository(repository);\n    return rvf != null ? rvf.getFileFor(nodePointer) : myGlobalRepoFiles.getFileFor(nodePointer);\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void visitPropertyEvent(final SModelPropertyEvent event) {\n      MPSNodeVirtualFile vf = getVirtualFile(new jetbrains.mps.smodel.SNodePointer(event.getModel().getReference(), event.getNode().getNodeId()));\n      if (!(event.getNode().getModel() != null && event.getNode().getParent() == null) || vf == null)\n        return;\n      String newName = event.getNode().getPresentation();\n      if (!newName.equals(vf.getName())) {\n        myRenamedFiles.add(new Pair<MPSNodeVirtualFile, String>(vf, newName));\n      }\n    }","id":77537,"modified_method":"@Override\n    public void visitPropertyEvent(final SModelPropertyEvent event) {\n      MPSNodeVirtualFile vf = getVirtualFile(new jetbrains.mps.smodel.SNodePointer(event.getModel().getReference(), event.getNode().getNodeId()));\n      if (event.getNode().getModel() == null || event.getNode().getParent() != null || vf == null) {\n        return;\n      }\n      String newName = event.getNode().getPresentation();\n      if (!newName.equals(vf.getName())) {\n        myRenamedFiles.add(new Pair<MPSNodeVirtualFile, String>(vf, newName));\n      }\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"void unregister(@NotNull RepositoryVirtualFiles repoFiles) {\n\n  }","id":77538,"modified_method":"synchronized void unregister(@NotNull RepositoryVirtualFiles repoFiles) {\n    new RepoListenerRegistrar(repoFiles.getRepository(), myRepositoryListener).detach();\n    myPerRepositoryFiles.remove(repoFiles);\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void modelReplaced(SModel md) {\n      updateModificationStamp(md.getRootNodes());\n\n      Collection<MPSNodeVirtualFile> deletedFiles = new ArrayList<MPSNodeVirtualFile>();\n      Collection<Pair<MPSNodeVirtualFile, String>> renamedFiles = new ArrayList<Pair<MPSNodeVirtualFile, String>>();\n      for (MPSNodeVirtualFile vf : myGlobalRepoFiles.getKnownVirtualFilesIn(md.getReference())) {\n        // XXX reconsider vf.getNode() (with SRepository in file construction time), vf.getNode(myRepository) and explicit resolve here\n        SNode node = vf.getSNodePointer().resolve(myRepository);\n        if (node == null) {\n          deletedFiles.add(vf);\n          forgetVirtualFile(vf.getSNodePointer());\n        } else {\n          String oldName = vf.getName();\n          String newName = node.getPresentation(); // FIXME extract code that builds name of a file from node\n          if (!oldName.equals(newName)) {\n            renamedFiles.add(new Pair<MPSNodeVirtualFile, String>(vf, newName));\n          }\n        }\n      }\n\n      VFSNotifier vfsNotifier = new VFSNotifier(deletedFiles, renamedFiles);\n      if (vfsNotifier.hasPendingNotifications()) {\n        myRepository.getModelAccess().runWriteInEDT(vfsNotifier);\n      }\n    }","id":77539,"modified_method":"@Override\n    public void modelReplaced(SModel md) {\n      final RepositoryVirtualFiles rvf = findRepoFiles(md);\n      if (rvf == null) {\n        return;\n      }\n      final Collection<MPSNodeVirtualFile> filesInModel = rvf.getKnownVirtualFilesIn(md.getReference());\n      updateModificationStamp(filesInModel);\n\n      Collection<MPSNodeVirtualFile> deletedFiles = new ArrayList<MPSNodeVirtualFile>();\n      Collection<Pair<MPSNodeVirtualFile, String>> renamedFiles = new ArrayList<Pair<MPSNodeVirtualFile, String>>();\n      for (MPSNodeVirtualFile vf : filesInModel) {\n        // XXX reconsider vf.getNode() (with SRepository in file construction time), vf.getNode(myRepository) and explicit resolve here\n        if (vf.getNode() == null) {\n          deletedFiles.add(vf);\n        } else {\n          String oldName = vf.getName();\n          // updateFields needs exclusive read in fact. Here we are in model write, and it's ok to change internal state of the file\n          // FIXME to fire beforePropChange, shall not decide about rename here, but in VFSNotifier. Report these as changed and let VFSNotifier decide whether it's rename or not.\n          vf.updateFields();\n          String newName = vf.getName();\n          if (!oldName.equals(newName)) {\n            renamedFiles.add(new Pair<MPSNodeVirtualFile, String>(vf, oldName));\n          }\n        }\n      }\n      VFSNotifier vfsNotifier = new VFSNotifier(rvf);\n      vfsNotifier.deleted(deletedFiles);\n      vfsNotifier.renamed(renamedFiles);\n      vfsNotifier.execute();\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean hasPendingNotifications() {\n      return !myDeleterFiles.isEmpty() || !myRenamedFiles.isEmpty();\n    }","id":77540,"modified_method":"private boolean hasPendingNotifications() {\n      return !myDeletedFiles.isEmpty() || !myRenamedFiles.isEmpty();\n    }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public /*FIXME: package*/ Collection<MPSNodeVirtualFile> getKnownVirtualFilesIn(SModelReference modelRef) {\n    ArrayList<MPSNodeVirtualFile> rv = new ArrayList<MPSNodeVirtualFile>();\n    for (MPSNodeVirtualFile vf : myVirtualFiles.values()) {\n      if (modelRef.equals(vf.getSNodePointer().getModelReference())) {\n        rv.add(vf);\n      }\n    }\n    return rv;\n  }","id":77541,"modified_method":"Collection<MPSNodeVirtualFile> getKnownVirtualFilesIn(SModelReference modelRef) {\n    ArrayList<MPSNodeVirtualFile> rv = new ArrayList<MPSNodeVirtualFile>();\n    for (MPSNodeVirtualFile vf : myVirtualFiles.values()) {\n      if (modelRef.equals(vf.getSNodePointer().getModelReference())) {\n        rv.add(vf);\n      }\n    }\n    return rv;\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public /*FIXME: package*/ SRepository getRepository() {\n    return myRepository;\n  }","id":77542,"modified_method":"@NotNull\n  /*package*/ SRepository getRepository() {\n    return myRepository;\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public /*FIXME: package*/ MPSNodeVirtualFile getVirtualFile(SNodeReference nodeRef) {\n    return myVirtualFiles.get(nodeRef);\n  }","id":77543,"modified_method":"@Nullable\n  /*package*/ MPSNodeVirtualFile getVirtualFile(SNodeReference nodeRef) {\n    return myVirtualFiles.get(nodeRef);\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public /*FIXME: package*/ void forgetVirtualFile(SNodeReference nodeRef) {\n    myVirtualFiles.remove(nodeRef);\n  }","id":77544,"modified_method":"void forgetVirtualFile(SNodeReference nodeRef) {\n    myVirtualFiles.remove(nodeRef);\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public VirtualFile findFileByPath(final @NotNull String path) {\n    return new ModelAccessHelper(myRepository).runReadAction(new Computable<VirtualFile>() {\n      @Override\n      public VirtualFile compute() {\n        try {\n          if (path.startsWith(MPSNodeVirtualFile.NODE_PREFIX)) {\n            SNode node = getPathFacility().deserializeNode(path.substring(MPSNodeVirtualFile.NODE_PREFIX.length()));\n            if (node == null) {\n              return null;\n            }\n            return getFileFor(node.getReference());\n          } else if (path.startsWith(MPSModelVirtualFile.MODEL_PREFIX)) {\n            SModel model = getPathFacility().deserializeModel(path.substring(MPSModelVirtualFile.MODEL_PREFIX.length()));\n            if (model == null) {\n              return null;\n            }\n            return getFileFor(model.getReference());\n          }\n        } catch (IllegalArgumentException e) {\n          // ignore, parse model ref exception\n        }\n        return null;\n      }\n    });\n  }","id":77545,"modified_method":"@Nullable\n  /*package*/ VirtualFile findFileByPath(final @NotNull String path) {\n    return new ModelAccessHelper(myRepository).runReadAction(new Computable<VirtualFile>() {\n      @Override\n      public VirtualFile compute() {\n        try {\n          if (path.startsWith(MPSNodeVirtualFile.NODE_PREFIX)) {\n            SNode node = getPathFacility().deserializeNode(path.substring(MPSNodeVirtualFile.NODE_PREFIX.length()));\n            if (node == null) {\n              return null;\n            }\n            return getFileFor(node.getReference());\n          } else if (path.startsWith(MPSModelVirtualFile.MODEL_PREFIX)) {\n            SModel model = getPathFacility().deserializeModel(path.substring(MPSModelVirtualFile.MODEL_PREFIX.length()));\n            if (model == null) {\n              return null;\n            }\n            return getFileFor(model.getReference());\n          }\n        } catch (IllegalArgumentException e) {\n          // ignore, parse model ref exception\n        }\n        return null;\n      }\n    });\n  }","commit_id":"6eac015da514eda4cfaa2d8c3ede07b009dff86c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isGlobal() {\n    return wrapped.isGlobal();\n  }","id":77546,"modified_method":"public boolean isGlobal() {\n    return myIsGlobal;\n  }","commit_id":"7aca4bc43a0960079f76391480e321dc28cc64b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public final void undo() throws UnexpectedUndoException {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        if (myFile != null) {\n          myFile.setModificationStamp(myModifcationStamp);\n        }\n        wrapped.undo();\n      }\n    });\n  }","id":77547,"modified_method":"public final void undo() throws UnexpectedUndoException {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        for (Entry<MPSNodeVirtualFile, Long> e : myChangedTimestamps.entrySet()) {\n          e.getKey().setModificationStamp(e.getValue());\n        }\n        for (SNodeUndoableAction a : myWrapped) {\n          a.undo();\n        }\n      }\n    });\n  }","commit_id":"7aca4bc43a0960079f76391480e321dc28cc64b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"SNodeIdeaUndoableAction(SNodeUndoableAction wrapped) {\n    this.wrapped = wrapped;\n    if (wrapped.getRoot() == null) {\n      myAffectedDocuments = new DocumentReference[0];\n    } else {\n      myFile = MPSNodesVirtualFileSystem.getInstance().getFileFor(wrapped.getRoot());\n      assert myFile.isValid() : \"Invalid file was returned by VFS node is not available: \" + myFile.getNode();\n      myAffectedDocuments = new DocumentReference[]{DocumentReferenceManager.getInstance().create(myFile)};\n      myModifcationStamp = myFile.getModificationStamp();\n    }\n  }","id":77548,"modified_method":"SNodeIdeaUndoableAction(List<SNodeUndoableAction> wrapped) {\n    myWrapped = wrapped;\n    List<DocumentReference> affected = new LinkedList<DocumentReference>();\n\n    myIsGlobal = wrapped.get(0).isGlobal();\n\n    for (SNodeUndoableAction a : wrapped) {\n      if (a.getRoot() != null) {\n        MPSNodeVirtualFile file = MPSNodesVirtualFileSystem.getInstance().getFileFor(a.getRoot());\n        assert file.isValid() : \"Invalid file was returned by VFS node is not available: \" + file.getNode();\n        affected.add(DocumentReferenceManager.getInstance().create(file));\n        myChangedTimestamps.put(file, file.getModificationStamp());\n      }\n\n      assert a.isGlobal() == myIsGlobal : \"Global and non-global actions should not be mixed inside one command\";\n    }\n\n    myAffectedDocuments = affected.toArray(new DocumentReference[affected.size()]);\n  }","commit_id":"7aca4bc43a0960079f76391480e321dc28cc64b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public final void redo() throws UnexpectedUndoException {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        wrapped.redo();\n      }\n    });\n  }","id":77549,"modified_method":"public final void redo() throws UnexpectedUndoException {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        for (SNodeUndoableAction a : myWrapped) {\n          a.redo();\n        }\n      }\n    });\n  }","commit_id":"7aca4bc43a0960079f76391480e321dc28cc64b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void flushCommand() {\n    \n  }","id":77550,"modified_method":"public void flushCommand() {\n    Project project = CommandProcessor.getInstance().getCurrentCommandProject();\n    if (project == null) return;\n\n    UndoManager undoManager = UndoManager.getInstance(project);\n    if (undoManager.isUndoInProgress() || undoManager.isRedoInProgress()) return;\n\n    undoManager.undoableActionPerformed(new SNodeIdeaUndoableAction(myActions));\n    myActions = new LinkedList<SNodeUndoableAction>();\n  }","commit_id":"7aca4bc43a0960079f76391480e321dc28cc64b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addUndoableAction(SNodeUndoableAction action) {\n    Project project = CommandProcessor.getInstance().getCurrentCommandProject();\n    if (project == null) return;\n\n    UndoManager undoManager = UndoManager.getInstance(project);\n    if (undoManager.isUndoInProgress() || undoManager.isRedoInProgress()) return;\n\n    undoManager.undoableActionPerformed(new SNodeIdeaUndoableAction(action));\n  }","id":77551,"modified_method":"public void addUndoableAction(SNodeUndoableAction action) {\n    Project project = CommandProcessor.getInstance().getCurrentCommandProject();\n    if (project == null) return;\n\n    myActions.add(action);\n  }","commit_id":"7aca4bc43a0960079f76391480e321dc28cc64b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void testCaseFunction_00() throws Exception {\n\t\tXtendFile xtendFile = file(\"class Foo { def dispatch foo(Object x) {null} def dispatch foo(String x) {null}}\");\n\t\tJvmGenericType inferredType = getInferredType(xtendFile);\n\n\t\t// one main dispatch\n\t\tIterable<JvmOperation> operations = inferredType.getDeclaredOperations();\n\t\tJvmOperation dispatch = find(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"foo\")\n\t\t\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tassertEquals(\"java.lang.Object\", dispatch.getReturnType().getIdentifier());\n\t\t\n\t\t// two internal case methods\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(String.class.getName());\n\t\t\t}\n\t\t});\n\t\tfor(JvmMember member: inferredType.getMembers()) {\n\t\t\tif (member instanceof JvmExecutable) {\n\t\t\t\tassertEquals(JvmVisibility.PUBLIC, member.getVisibility());\n\t\t\t} else {\n\t\t\t\tassertEquals(JvmVisibility.PRIVATE, member.getVisibility());\n\t\t\t}\n\t\t}\n\t}","id":77552,"modified_method":"public void testCaseFunction_00() throws Exception {\n\t\tXtendFile xtendFile = file(\"class Foo { def dispatch foo(Object x) {null} def dispatch foo(String x) {null}}\");\n\t\tJvmGenericType inferredType = getInferredType(xtendFile);\n\n\t\t// one main dispatch\n\t\tIterable<JvmOperation> operations = inferredType.getDeclaredOperations();\n\t\tJvmOperation dispatch = find(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"foo\")\n\t\t\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tassertEquals(\"java.lang.Object\", dispatch.getReturnType().getIdentifier());\n\t\t\n\t\t// two internal case methods\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(String.class.getName());\n\t\t\t}\n\t\t});\n\t\tfor(JvmMember member: inferredType.getMembers()) {\n\t\t\tif (member instanceof JvmExecutable) {\n\t\t\t\tif (member.getSimpleName().startsWith(\"_\"))\n\t\t\t\t\tassertEquals(JvmVisibility.PROTECTED, member.getVisibility());\n\t\t\t\telse\n\t\t\t\t\tassertEquals(JvmVisibility.PUBLIC, member.getVisibility());\n\t\t\t} else {\n\t\t\t\tassertEquals(JvmVisibility.PRIVATE, member.getVisibility());\n\t\t\t}\n\t\t}\n\t}","commit_id":"7457301150894d131c824869efb457a9fcd02b16","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void generateDispatchMethod(JvmOperation dispatchOperation, Collection<JvmOperation> collection,\n\t\t\tIAppendable a) {\n\t\ta.openScope();\n\t\ta.append(\"\\n\\npublic \");\n\t\tserialize(dispatchOperation.getReturnType(), dispatchOperation, a);\n\t\ta.append(\" \");\n\t\ta.append(dispatchOperation.getSimpleName()).append(\"(\");\n\t\tdeclareJvmParameters(dispatchOperation.getParameters(), a);\n\t\ta.append(\") \");\n\t\tdeclareExceptions(dispatchOperation, a);\n\t\ta.append(\"{\");\n\t\ta.increaseIndentation();\n\t\ta.append(\"\\n\");\n\t\tfor (JvmOperation operation : dispatchingSupport.sort(collection)) {\n\t\t\ta.append(\"if (\");\n\t\t\ta.increaseIndentation().increaseIndentation();\n\t\t\tIterator<JvmFormalParameter> iter1 = dispatchOperation.getParameters().iterator();\n\t\t\tfor (Iterator<JvmFormalParameter> iter2 = operation.getParameters().iterator(); iter2.hasNext();) {\n\t\t\t\tJvmFormalParameter p1 = iter1.next();\n\t\t\t\tJvmFormalParameter p2 = iter2.next();\n\t\t\t\tfinal JvmTypeReference type = p2.getParameterType();\n\t\t\t\tfinal String name = getVarName(p1, a);\n\t\t\t\tif (getTypeReferences().is(type, Void.class)) {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" == null)\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" instanceof \");\n\t\t\t\t\ta.append(getPrimitives().asWrapperTypeIfPrimitive(type).getType()).append(\")\");\n\t\t\t\t}\n\t\t\t\tif (iter2.hasNext()) {\n\t\t\t\t\ta.append(\"\\n && \");\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.decreaseIndentation().decreaseIndentation();\n\t\t\ta.append(\") {\").increaseIndentation();\n\t\t\ta.append(\"\\n\");\n\t\t\tfinal boolean isCurrentVoid = getTypeReferences().is(operation.getReturnType(), Void.TYPE);\n\t\t\tfinal boolean isDispatchVoid = getTypeReferences().is(dispatchOperation.getReturnType(), Void.TYPE);\n\t\t\tif (isDispatchVoid) {\n\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\ta.append(\";\");\n\t\t\t} else {\n\t\t\t\tif (isCurrentVoid) {\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t\ta.append(\";\\nreturn null\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"return \");\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t}\n\t\t\t\ta.append(\";\");\n\t\t\t}\n\t\t\ta.decreaseIndentation().append(\"\\n} else \");\n\t\t}\n\t\ta.append(\"{\").increaseIndentation();\n\t\ta.append(\"\\nthrow new IllegalArgumentException();\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.closeScope();\n\t}","id":77553,"modified_method":"protected void generateDispatchMethod(JvmOperation dispatchOperation, Collection<JvmOperation> collection,\n\t\t\tIAppendable a) {\n\t\ta.openScope();\n\t\ta.append(\"\\n\\n\").append(getJavaVisibility(dispatchOperation.getVisibility())).append(\" \");\n\t\tserialize(dispatchOperation.getReturnType(), dispatchOperation, a);\n\t\ta.append(\" \");\n\t\ta.append(dispatchOperation.getSimpleName()).append(\"(\");\n\t\tdeclareJvmParameters(dispatchOperation.getParameters(), a);\n\t\ta.append(\") \");\n\t\tdeclareExceptions(dispatchOperation, a);\n\t\ta.append(\"{\");\n\t\ta.increaseIndentation();\n\t\ta.append(\"\\n\");\n\t\tfor (JvmOperation operation : dispatchingSupport.sort(collection)) {\n\t\t\ta.append(\"if (\");\n\t\t\ta.increaseIndentation().increaseIndentation();\n\t\t\tIterator<JvmFormalParameter> iter1 = dispatchOperation.getParameters().iterator();\n\t\t\tfor (Iterator<JvmFormalParameter> iter2 = operation.getParameters().iterator(); iter2.hasNext();) {\n\t\t\t\tJvmFormalParameter p1 = iter1.next();\n\t\t\t\tJvmFormalParameter p2 = iter2.next();\n\t\t\t\tfinal JvmTypeReference type = p2.getParameterType();\n\t\t\t\tfinal String name = getVarName(p1, a);\n\t\t\t\tif (getTypeReferences().is(type, Void.class)) {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" == null)\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" instanceof \");\n\t\t\t\t\ta.append(getPrimitives().asWrapperTypeIfPrimitive(type).getType()).append(\")\");\n\t\t\t\t}\n\t\t\t\tif (iter2.hasNext()) {\n\t\t\t\t\ta.append(\"\\n && \");\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.decreaseIndentation().decreaseIndentation();\n\t\t\ta.append(\") {\").increaseIndentation();\n\t\t\ta.append(\"\\n\");\n\t\t\tfinal boolean isCurrentVoid = getTypeReferences().is(operation.getReturnType(), Void.TYPE);\n\t\t\tfinal boolean isDispatchVoid = getTypeReferences().is(dispatchOperation.getReturnType(), Void.TYPE);\n\t\t\tif (isDispatchVoid) {\n\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\ta.append(\";\");\n\t\t\t} else {\n\t\t\t\tif (isCurrentVoid) {\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t\ta.append(\";\\nreturn null\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"return \");\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t}\n\t\t\t\ta.append(\";\");\n\t\t\t}\n\t\t\ta.decreaseIndentation().append(\"\\n} else \");\n\t\t}\n\t\ta.append(\"{\").increaseIndentation();\n\t\ta.append(\"\\nthrow new IllegalArgumentException();\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.closeScope();\n\t}","commit_id":"7457301150894d131c824869efb457a9fcd02b16","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void compile(XtendFunction obj, IAppendable appendable) {\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tdeclareCreateExtensionCache(obj, appendable);\n\t\t}\n\t\t\n\t\tappendable.openScope();\n\t\tJvmTypeReference returnType = associations.getDirectlyInferredOperation(obj).getReturnType();\n\t\tString name = obj.getName();\n\t\tif (obj.isDispatch()) {\n\t\t\tname = \"_\" + name;\n\t\t}\n\t\tappendable.append(\"\\n\");\n\t\tgenerateAnnotations(obj, appendable);\n\t\tappendable.append(\"\\npublic \");\n\t\tappendTypeParameterDeclaration(obj.getTypeParameters(), appendable);\n\t\tserialize(resolveMultiType(returnType), obj, appendable);\n\t\tappendable.append(\" \").append(name).append(\"(\");\n\t\tfinal EList<XtendParameter> parameters = obj.getParameters();\n\t\tdeclareParameters(parameters, appendable);\n\t\tappendable.append(\") \");\n\t\tJvmOperation operation = associations.getDirectlyInferredOperation(obj);\n\t\tdeclareExceptions(operation, appendable);\n\t\tappendable.append(\"{\");\n\t\tappendable.increaseIndentation();\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tcompileCreateExtensionBody(obj, appendable);\n\t\t} else {\n\t\t\tcompile(obj.getExpression(), appendable, returnType);\n\t\t}\n\t\tappendable.decreaseIndentation();\n\t\tappendable.append(\"\\n}\").closeScope();\n\t}","id":77554,"modified_method":"protected void compile(XtendFunction obj, IAppendable appendable) {\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tdeclareCreateExtensionCache(obj, appendable);\n\t\t}\n\t\t\n\t\tappendable.openScope();\n\t\tfinal JvmOperation directlyInferredOperation = associations.getDirectlyInferredOperation(obj);\n\t\tJvmTypeReference returnType = directlyInferredOperation.getReturnType();\n\t\tString name = obj.getName();\n\t\tif (obj.isDispatch()) {\n\t\t\tname = \"_\" + name;\n\t\t}\n\t\tappendable.append(\"\\n\");\n\t\tgenerateAnnotations(obj, appendable);\n\t\tappendable.append(\"\\n\").append(getJavaVisibility(directlyInferredOperation.getVisibility())).append(\" \");\n\t\tappendTypeParameterDeclaration(obj.getTypeParameters(), appendable);\n\t\tserialize(resolveMultiType(returnType), obj, appendable);\n\t\tappendable.append(\" \").append(name).append(\"(\");\n\t\tfinal EList<XtendParameter> parameters = obj.getParameters();\n\t\tdeclareParameters(parameters, appendable);\n\t\tappendable.append(\") \");\n\t\tJvmOperation operation = directlyInferredOperation;\n\t\tdeclareExceptions(operation, appendable);\n\t\tappendable.append(\"{\");\n\t\tappendable.increaseIndentation();\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tcompileCreateExtensionBody(obj, appendable);\n\t\t} else {\n\t\t\tcompile(obj.getExpression(), appendable, returnType);\n\t\t}\n\t\tappendable.decreaseIndentation();\n\t\tappendable.append(\"\\n}\").closeScope();\n\t}","commit_id":"7457301150894d131c824869efb457a9fcd02b16","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmMember transform(XtendMember sourceMember, JvmGenericType container) {\n\t\tif (sourceMember instanceof XtendFunction) {\n\t\t\tXtendFunction source = (XtendFunction) sourceMember;\n\t\t\tJvmOperation target = typesFactory.createJvmOperation();\n\t\t\tcontainer.getMembers().add(target);\n\t\t\tassociator.associatePrimary(source, target);\n\t\t\tString sourceName = source.getName();\n\t\t\tif (source.isDispatch()) {\n\t\t\t\tsourceName = \"_\" + sourceName;\n\t\t\t}\n\t\t\ttarget.setSimpleName(sourceName);\n\t\t\ttarget.setVisibility(JvmVisibility.PUBLIC);\n\t\t\tfor (XtendParameter parameter : source.getParameters()) {\n\t\t\t\tJvmFormalParameter jvmParam = typesFactory.createJvmFormalParameter();\n\t\t\t\tjvmParam.setName(parameter.getName());\n\t\t\t\tjvmParam.setParameterType(EcoreUtil2.cloneWithProxies(parameter.getParameterType()));\n\t\t\t\ttarget.getParameters().add(jvmParam);\n\t\t\t}\n\t\t\tif (source.getReturnType()!=null) {\n\t\t\t\ttarget.setReturnType(EcoreUtil2.cloneWithProxies(source.getReturnType()));\n\t\t\t} else {\n\t\t\t\ttarget.setReturnType(getTypeProxy(target));\n\t\t\t}\n\t\t\tfor (JvmTypeParameter typeParameter : source.getTypeParameters())\n\t\t\t\ttarget.getTypeParameters().add(EcoreUtil2.cloneWithProxies(typeParameter));\n\t\t\treturn target;\n\t\t} else if (sourceMember instanceof XtendField) {\n\t\t\tXtendField dep = (XtendField) sourceMember;\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(dep, field);\n\t\t\tfield.setVisibility(JvmVisibility.PRIVATE);\n\t\t\tfield.setSimpleName(dep.getName());\n\t\t\tfield.setType(EcoreUtil2.cloneWithProxies(dep.getType()));\n\t\t\treturn field;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot transform \" + notNull(sourceMember) + \" to a JvmMember\");\n\t}","id":77555,"modified_method":"protected JvmMember transform(XtendMember sourceMember, JvmGenericType container) {\n\t\tif (sourceMember instanceof XtendFunction) {\n\t\t\tXtendFunction source = (XtendFunction) sourceMember;\n\t\t\tJvmOperation target = typesFactory.createJvmOperation();\n\t\t\tcontainer.getMembers().add(target);\n\t\t\tassociator.associatePrimary(source, target);\n\t\t\tString sourceName = source.getName();\n\t\t\tJvmVisibility visibility = JvmVisibility.PUBLIC;\n\t\t\tif (source.isDispatch()) {\n\t\t\t\tsourceName = \"_\" + sourceName;\n\t\t\t\tvisibility = JvmVisibility.PROTECTED;\n\t\t\t}\n\t\t\ttarget.setSimpleName(sourceName);\n\t\t\ttarget.setVisibility(visibility);\n\t\t\tfor (XtendParameter parameter : source.getParameters()) {\n\t\t\t\tJvmFormalParameter jvmParam = typesFactory.createJvmFormalParameter();\n\t\t\t\tjvmParam.setName(parameter.getName());\n\t\t\t\tjvmParam.setParameterType(EcoreUtil2.cloneWithProxies(parameter.getParameterType()));\n\t\t\t\ttarget.getParameters().add(jvmParam);\n\t\t\t}\n\t\t\tif (source.getReturnType()!=null) {\n\t\t\t\ttarget.setReturnType(EcoreUtil2.cloneWithProxies(source.getReturnType()));\n\t\t\t} else {\n\t\t\t\ttarget.setReturnType(getTypeProxy(target));\n\t\t\t}\n\t\t\tfor (JvmTypeParameter typeParameter : source.getTypeParameters())\n\t\t\t\ttarget.getTypeParameters().add(EcoreUtil2.cloneWithProxies(typeParameter));\n\t\t\treturn target;\n\t\t} else if (sourceMember instanceof XtendField) {\n\t\t\tXtendField dep = (XtendField) sourceMember;\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(dep, field);\n\t\t\tfield.setVisibility(JvmVisibility.PRIVATE);\n\t\t\tfield.setSimpleName(dep.getName());\n\t\t\tfield.setType(EcoreUtil2.cloneWithProxies(dep.getType()));\n\t\t\treturn field;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot transform \" + notNull(sourceMember) + \" to a JvmMember\");\n\t}","commit_id":"7457301150894d131c824869efb457a9fcd02b16","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testNoException_08() throws Exception {\n\t\tXtendFile file = file(\"package org.eclipse.xtext.xtend2.tests.smoke\\n\" + \n\t\t\t\t\"import java.util.ArrayList\\n\" + \n\t\t\t\t\"import static.*\\n\" + \n\t\t\t\t\"import static extension java.util.Collections.*\\n\" + \n\t\t\t\t\"class Case_5 {\\n\" + \n\t\t\t\t\"\t@Inject\\n\" + \n\t\t\t\t\"\tArrayList as myList\\n\" + \n\t\t\t\t\"\t@Inject extension String\\n\" + \n\t\t\t\t\"\tboolean something(int i) {\\n\" + \n\t\t\t\t\"\t  if (i.indexOf() == 0) {\\n\" + \n\t\t\t\t\"\t    return myList.contains(i)\\n\" + \n\t\t\t\t\"\t  } \\n\" + \n\t\t\t\t\"\t  asList(i)\\n\" + \n\t\t\t\t\"\t  i.singletonList()\\n\" + \n\t\t\t\t\"\t  false\\n\" + \n\t\t\t\t\"\t}\\n\" + \n\t\t\t\t\"}\");\n\t\tassertNoExceptions(file);\n\t}","id":77556,"modified_method":"public void testNoException_08() throws Exception {\n\t\tXtendFile file = file(\"package org.eclipse.xtext.xtend2.tests.linking\\n\" + \n\t\t\t\t\"import java.util.ArrayList\\n\" + \n\t\t\t\t\"import static.*\\n\" + \n\t\t\t\t\"import static extension java.util.Collections.*\\n\" + \n\t\t\t\t\"class NoException {\\n\" + \n\t\t\t\t\"\t@Inject\\n\" + \n\t\t\t\t\"\tArrayList as myList\\n\" + \n\t\t\t\t\"\t@Inject extension String\\n\" + \n\t\t\t\t\"\tboolean something(int i) {\\n\" + \n\t\t\t\t\"\t  if (i.indexOf() == 0) {\\n\" + \n\t\t\t\t\"\t    return myList.contains(i)\\n\" + \n\t\t\t\t\"\t  } \\n\" + \n\t\t\t\t\"\t  asList(i)\\n\" + \n\t\t\t\t\"\t  i.singletonList()\\n\" + \n\t\t\t\t\"\t  false\\n\" + \n\t\t\t\t\"\t}\\n\" + \n\t\t\t\t\"}\");\n\t\tassertNoExceptions(file);\n\t}","commit_id":"0990789d8e067f4059965e3a33395356960f8884","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void assertNoExceptions(EObject object) {\n\t\tResource resource = object.eResource();\n\t\tif (resource instanceof LazyLinkingResource)\n\t\t\t((LazyLinkingResource) resource).resolveLazyCrossReferences(CancelIndicator.NullImpl);\n\t\tList<Diagnostic> errors = object.eResource().getErrors();\n\t\tfor(Diagnostic error: errors) {\n\t\t\tif (error instanceof ExceptionDiagnostic) {\n\t\t\t\t((ExceptionDiagnostic) error).getException().printStackTrace();\n\t\t\t}\n\t\t\tassertFalse(error.toString(), error instanceof ExceptionDiagnostic);\n\t\t}\n\t}","id":77557,"modified_method":"protected void assertNoExceptions(EObject object) {\n\t\tResource resource = object.eResource();\n\t\tif (resource instanceof LazyLinkingResource)\n\t\t\t((LazyLinkingResource) resource).resolveLazyCrossReferences(CancelIndicator.NullImpl);\n\t\tList<Diagnostic> errors = object.eResource().getErrors();\n\t\tfor(Diagnostic error: errors) {\n\t\t\tif (error instanceof ExceptionDiagnostic) {\n\t\t\t\t((ExceptionDiagnostic) error).getException().printStackTrace();\n\t\t\t}\n\t\t\tassertFalse(error.toString(), error instanceof ExceptionDiagnostic);\n\t\t}\n\t\tvalidateWithoutException((XtextResource) resource);\n\t}","commit_id":"0990789d8e067f4059965e3a33395356960f8884","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testNoExceptionInValidator_01() throws Exception {\n\t\tXtendClass clazz = clazz(\"package pack class Case_2 {\\n\" + \n\t\t\t\t\"\\n\" + \n\t\t\t\t\"\taOrB(String a, String b) {\\n\" + \n\t\t\t\t\"\t\tif (a.isNullOrEmpty()) \\n\" + \n\t\t\t\t\"\t\t\tb\\n\" + \n\t\t\t\t\"\t\telse\\n\" + \n\t\t\t\t\"\t\t\ta \\n\" + \n\t\t\t\t\"\t}\\n\" + \n\t\t\t\t\"\t\\n\" + \n\t\t\t\t\"\t() {\\n\" + \n\t\t\t\t\"\t\tif ('x'!='x') return 'xx' else return 'yy'\\n\" + \n\t\t\t\t\"\t}\\n\" + \n\t\t\t\t\"\\n\" + \n\t\t\t\t\"}\");\n\t\tassertNoExceptions(clazz);\n\t\tXtextResource resource = (XtextResource) clazz.eResource();\n\t\tResourceValidatorImpl validator = new ResourceValidatorImpl();\n\t\tassertNotSame(validator, resource.getResourceServiceProvider().getResourceValidator());\n\t\tgetInjector().injectMembers(validator);\n\t\tvalidator.setDiagnosticConverter(new IDiagnosticConverter() {\n\t\t\tpublic void convertValidatorDiagnostic(org.eclipse.emf.common.util.Diagnostic diagnostic, IAcceptor<Issue> acceptor) {\n\t\t\t\tif (diagnostic instanceof BasicDiagnostic) {\n\t\t\t\t\tList<?> data = diagnostic.getData();\n\t\t\t\t\tif (!data.isEmpty() && data.get(0) instanceof Throwable) {\n\t\t\t\t\t\tThrowable t = (Throwable) data.get(0);\n\t\t\t\t\t\t// the framework catches runtime exception\n\t\t\t\t\t\t// and AssertionError does not take a throwable as argument\n\t\t\t\t\t\tthrow new Error(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic void convertResourceDiagnostic(Diagnostic diagnostic, Severity severity, IAcceptor<Issue> acceptor) {\n\t\t\t\tif (diagnostic instanceof ExceptionDiagnostic) {\n\t\t\t\t\tException e = ((ExceptionDiagnostic) diagnostic).getException();\n\t\t\t\t\t// the framework catches runtime exception\n\t\t\t\t\t// and AssertionError does not take a throwable as argument\n\t\t\t\t\tthrow new Error(new RuntimeException(e));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvalidator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);\n\t}","id":77558,"modified_method":"public void testNoExceptionInValidator_01() throws Exception {\n\t\tXtendClass clazz = clazz(\"package pack class Case_2 {\\n\" + \n\t\t\t\t\"\\n\" + \n\t\t\t\t\"\taOrB(String a, String b) {\\n\" + \n\t\t\t\t\"\t\tif (a.isNullOrEmpty()) \\n\" + \n\t\t\t\t\"\t\t\tb\\n\" + \n\t\t\t\t\"\t\telse\\n\" + \n\t\t\t\t\"\t\t\ta \\n\" + \n\t\t\t\t\"\t}\\n\" + \n\t\t\t\t\"\t\\n\" + \n\t\t\t\t\"\t() {\\n\" + \n\t\t\t\t\"\t\tif ('x'!='x') return 'xx' else return 'yy'\\n\" + \n\t\t\t\t\"\t}\\n\" + \n\t\t\t\t\"\\n\" + \n\t\t\t\t\"}\");\n\t\tassertNoExceptions(clazz);\n\t\tXtextResource resource = (XtextResource) clazz.eResource();\n\t\tvalidateWithoutException(resource);\n\t}","commit_id":"0990789d8e067f4059965e3a33395356960f8884","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmOperation findOverriddenOperation(XtendFunction function) {\n\t\tfinal JvmParameterizedTypeReference typeRef = typeReferences\n\t\t\t\t.createTypeRef(xtend2jvmAssociations.getDirectlyInferredOperation(function).getDeclaringType());\n\t\tTypeArgumentContext typeArgumentContext = typeArgumentContextProvider.getReceiverContext(typeRef);\n\t\tJvmOperation inferredJvmOperation = xtend2jvmAssociations.getDirectlyInferredOperation(function);\n\t\tif (function.getDeclaringType().getExtends() != null || !function.getDeclaringType().getImplements().isEmpty()) {\n\t\t\tfor (JvmOperation superOperation : allSuperOperations(function.getDeclaringType())) {\n\t\t\t\tif (superOperation.getVisibility() != JvmVisibility.PRIVATE) {\n\t\t\t\t\tif (featureOverridesService.isOverridden(inferredJvmOperation, superOperation, typeArgumentContext,\n\t\t\t\t\t\t\tfalse)) {\n\t\t\t\t\t\treturn superOperation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":77559,"modified_method":"public JvmOperation findOverriddenOperation(XtendFunction function) {\n\t\tJvmOperation inferredOperation = xtend2jvmAssociations.getDirectlyInferredOperation(function);\n\t\tif (inferredOperation == null)\n\t\t\treturn null;\n\t\tfinal JvmParameterizedTypeReference typeRef = typeReferences.createTypeRef(inferredOperation.getDeclaringType());\n\t\tTypeArgumentContext typeArgumentContext = typeArgumentContextProvider.getReceiverContext(typeRef);\n\t\tif (function.getDeclaringType().getExtends() != null || !function.getDeclaringType().getImplements().isEmpty()) {\n\t\t\tfor (JvmOperation superOperation : allSuperOperations(function.getDeclaringType())) {\n\t\t\t\tif (superOperation.getVisibility() != JvmVisibility.PRIVATE) {\n\t\t\t\t\tif (featureOverridesService.isOverridden(inferredOperation, superOperation, typeArgumentContext,\n\t\t\t\t\t\t\tfalse)) {\n\t\t\t\t\t\treturn superOperation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"0990789d8e067f4059965e3a33395356960f8884","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testCaseFunction_00() throws Exception {\n\t\tXtendFile xtendFile = file(\"class Foo { def dispatch foo(Object x) {null} def dispatch foo(String x) {null}}\");\n\t\tJvmGenericType inferredType = getInferredType(xtendFile);\n\n\t\t// one main dispatch\n\t\tIterable<JvmOperation> operations = inferredType.getDeclaredOperations();\n\t\tJvmOperation dispatch = find(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"foo\")\n\t\t\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tassertEquals(\"java.lang.Object\", dispatch.getReturnType().getIdentifier());\n\t\t\n\t\t// two internal case methods\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(String.class.getName());\n\t\t\t}\n\t\t});\n\t\tfor(JvmMember member: inferredType.getMembers()) {\n\t\t\tif (member instanceof JvmExecutable) {\n\t\t\t\tassertEquals(JvmVisibility.PUBLIC, member.getVisibility());\n\t\t\t} else {\n\t\t\t\tassertEquals(JvmVisibility.PRIVATE, member.getVisibility());\n\t\t\t}\n\t\t}\n\t}","id":77560,"modified_method":"public void testCaseFunction_00() throws Exception {\n\t\tXtendFile xtendFile = file(\"class Foo { def dispatch foo(Object x) {null} def dispatch foo(String x) {null}}\");\n\t\tJvmGenericType inferredType = getInferredType(xtendFile);\n\n\t\t// one main dispatch\n\t\tIterable<JvmOperation> operations = inferredType.getDeclaredOperations();\n\t\tJvmOperation dispatch = find(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"foo\")\n\t\t\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tassertEquals(\"java.lang.Object\", dispatch.getReturnType().getIdentifier());\n\t\t\n\t\t// two internal case methods\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(Object.class.getName());\n\t\t\t}\n\t\t});\n\t\tfind(operations, new Predicate<JvmOperation>() {\n\t\t\tpublic boolean apply(JvmOperation input) {\n\t\t\t\treturn input.getSimpleName().equals(\"_foo\")\n\t\t\t\t&& input.getParameters().get(0).getParameterType().getIdentifier()\n\t\t\t\t.equals(String.class.getName());\n\t\t\t}\n\t\t});\n\t\tfor(JvmMember member: inferredType.getMembers()) {\n\t\t\tif (member instanceof JvmExecutable) {\n\t\t\t\tif (member.getSimpleName().startsWith(\"_\"))\n\t\t\t\t\tassertEquals(JvmVisibility.PROTECTED, member.getVisibility());\n\t\t\t\telse\n\t\t\t\t\tassertEquals(JvmVisibility.PUBLIC, member.getVisibility());\n\t\t\t} else {\n\t\t\t\tassertEquals(JvmVisibility.PRIVATE, member.getVisibility());\n\t\t\t}\n\t\t}\n\t}","commit_id":"0451ff583bab6ebe36d29c15df63124165d6760a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void generateDispatchMethod(JvmOperation dispatchOperation, Collection<JvmOperation> collection,\n\t\t\tIAppendable a) {\n\t\ta.openScope();\n\t\ta.append(\"\\n\\npublic \");\n\t\tserialize(dispatchOperation.getReturnType(), dispatchOperation, a);\n\t\ta.append(\" \");\n\t\ta.append(dispatchOperation.getSimpleName()).append(\"(\");\n\t\tdeclareJvmParameters(dispatchOperation.getParameters(), a);\n\t\ta.append(\") \");\n\t\tdeclareExceptions(dispatchOperation, a);\n\t\ta.append(\"{\");\n\t\ta.increaseIndentation();\n\t\ta.append(\"\\n\");\n\t\tfor (JvmOperation operation : dispatchingSupport.sort(collection)) {\n\t\t\ta.append(\"if (\");\n\t\t\ta.increaseIndentation().increaseIndentation();\n\t\t\tIterator<JvmFormalParameter> iter1 = dispatchOperation.getParameters().iterator();\n\t\t\tfor (Iterator<JvmFormalParameter> iter2 = operation.getParameters().iterator(); iter2.hasNext();) {\n\t\t\t\tJvmFormalParameter p1 = iter1.next();\n\t\t\t\tJvmFormalParameter p2 = iter2.next();\n\t\t\t\tfinal JvmTypeReference type = p2.getParameterType();\n\t\t\t\tfinal String name = getVarName(p1, a);\n\t\t\t\tif (getTypeReferences().is(type, Void.class)) {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" == null)\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" instanceof \");\n\t\t\t\t\ta.append(getPrimitives().asWrapperTypeIfPrimitive(type).getType()).append(\")\");\n\t\t\t\t}\n\t\t\t\tif (iter2.hasNext()) {\n\t\t\t\t\ta.append(\"\\n && \");\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.decreaseIndentation().decreaseIndentation();\n\t\t\ta.append(\") {\").increaseIndentation();\n\t\t\ta.append(\"\\n\");\n\t\t\tfinal boolean isCurrentVoid = getTypeReferences().is(operation.getReturnType(), Void.TYPE);\n\t\t\tfinal boolean isDispatchVoid = getTypeReferences().is(dispatchOperation.getReturnType(), Void.TYPE);\n\t\t\tif (isDispatchVoid) {\n\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\ta.append(\";\");\n\t\t\t} else {\n\t\t\t\tif (isCurrentVoid) {\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t\ta.append(\";\\nreturn null\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"return \");\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t}\n\t\t\t\ta.append(\";\");\n\t\t\t}\n\t\t\ta.decreaseIndentation().append(\"\\n} else \");\n\t\t}\n\t\ta.append(\"{\").increaseIndentation();\n\t\ta.append(\"\\nthrow new IllegalArgumentException();\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.closeScope();\n\t}","id":77561,"modified_method":"protected void generateDispatchMethod(JvmOperation dispatchOperation, Collection<JvmOperation> collection,\n\t\t\tIAppendable a) {\n\t\ta.openScope();\n\t\ta.append(\"\\n\\n\").append(getJavaVisibility(dispatchOperation.getVisibility())).append(\" \");\n\t\tserialize(dispatchOperation.getReturnType(), dispatchOperation, a);\n\t\ta.append(\" \");\n\t\ta.append(dispatchOperation.getSimpleName()).append(\"(\");\n\t\tdeclareJvmParameters(dispatchOperation.getParameters(), a);\n\t\ta.append(\") \");\n\t\tdeclareExceptions(dispatchOperation, a);\n\t\ta.append(\"{\");\n\t\ta.increaseIndentation();\n\t\ta.append(\"\\n\");\n\t\tfor (JvmOperation operation : dispatchingSupport.sort(collection)) {\n\t\t\ta.append(\"if (\");\n\t\t\ta.increaseIndentation().increaseIndentation();\n\t\t\tIterator<JvmFormalParameter> iter1 = dispatchOperation.getParameters().iterator();\n\t\t\tfor (Iterator<JvmFormalParameter> iter2 = operation.getParameters().iterator(); iter2.hasNext();) {\n\t\t\t\tJvmFormalParameter p1 = iter1.next();\n\t\t\t\tJvmFormalParameter p2 = iter2.next();\n\t\t\t\tfinal JvmTypeReference type = p2.getParameterType();\n\t\t\t\tfinal String name = getVarName(p1, a);\n\t\t\t\tif (getTypeReferences().is(type, Void.class)) {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" == null)\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"(\").append(name).append(\" instanceof \");\n\t\t\t\t\ta.append(getPrimitives().asWrapperTypeIfPrimitive(type).getType()).append(\")\");\n\t\t\t\t}\n\t\t\t\tif (iter2.hasNext()) {\n\t\t\t\t\ta.append(\"\\n && \");\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.decreaseIndentation().decreaseIndentation();\n\t\t\ta.append(\") {\").increaseIndentation();\n\t\t\ta.append(\"\\n\");\n\t\t\tfinal boolean isCurrentVoid = getTypeReferences().is(operation.getReturnType(), Void.TYPE);\n\t\t\tfinal boolean isDispatchVoid = getTypeReferences().is(dispatchOperation.getReturnType(), Void.TYPE);\n\t\t\tif (isDispatchVoid) {\n\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\ta.append(\";\");\n\t\t\t} else {\n\t\t\t\tif (isCurrentVoid) {\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t\ta.append(\";\\nreturn null\");\n\t\t\t\t} else {\n\t\t\t\t\ta.append(\"return \");\n\t\t\t\t\tgenerateActualDispatchCall(dispatchOperation, operation, a);\n\t\t\t\t}\n\t\t\t\ta.append(\";\");\n\t\t\t}\n\t\t\ta.decreaseIndentation().append(\"\\n} else \");\n\t\t}\n\t\ta.append(\"{\").increaseIndentation();\n\t\ta.append(\"\\nthrow new IllegalArgumentException();\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.decreaseIndentation().append(\"\\n}\");\n\t\ta.closeScope();\n\t}","commit_id":"0451ff583bab6ebe36d29c15df63124165d6760a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void compile(XtendFunction obj, IAppendable appendable) {\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tdeclareCreateExtensionCache(obj, appendable);\n\t\t}\n\t\t\n\t\tappendable.openScope();\n\t\tJvmTypeReference returnType = associations.getDirectlyInferredOperation(obj).getReturnType();\n\t\tString name = obj.getName();\n\t\tif (obj.isDispatch()) {\n\t\t\tname = \"_\" + name;\n\t\t}\n\t\tappendable.append(\"\\n\");\n\t\tgenerateAnnotations(obj, appendable);\n\t\tappendable.append(\"\\npublic \");\n\t\tappendTypeParameterDeclaration(obj.getTypeParameters(), appendable);\n\t\tserialize(resolveMultiType(returnType), obj, appendable);\n\t\tappendable.append(\" \").append(name).append(\"(\");\n\t\tfinal EList<XtendParameter> parameters = obj.getParameters();\n\t\tdeclareParameters(parameters, appendable);\n\t\tappendable.append(\") \");\n\t\tJvmOperation operation = associations.getDirectlyInferredOperation(obj);\n\t\tdeclareExceptions(operation, appendable);\n\t\tappendable.append(\"{\");\n\t\tappendable.increaseIndentation();\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tcompileCreateExtensionBody(obj, appendable);\n\t\t} else {\n\t\t\tcompile(obj.getExpression(), appendable, returnType);\n\t\t}\n\t\tappendable.decreaseIndentation();\n\t\tappendable.append(\"\\n}\").closeScope();\n\t}","id":77562,"modified_method":"protected void compile(XtendFunction obj, IAppendable appendable) {\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tdeclareCreateExtensionCache(obj, appendable);\n\t\t}\n\t\t\n\t\tappendable.openScope();\n\t\tfinal JvmOperation directlyInferredOperation = associations.getDirectlyInferredOperation(obj);\n\t\tJvmTypeReference returnType = directlyInferredOperation.getReturnType();\n\t\tString name = obj.getName();\n\t\tif (obj.isDispatch()) {\n\t\t\tname = \"_\" + name;\n\t\t}\n\t\tappendable.append(\"\\n\");\n\t\tgenerateAnnotations(obj, appendable);\n\t\tappendable.append(\"\\n\").append(getJavaVisibility(directlyInferredOperation.getVisibility())).append(\" \");\n\t\tappendTypeParameterDeclaration(obj.getTypeParameters(), appendable);\n\t\tserialize(resolveMultiType(returnType), obj, appendable);\n\t\tappendable.append(\" \").append(name).append(\"(\");\n\t\tfinal EList<XtendParameter> parameters = obj.getParameters();\n\t\tdeclareParameters(parameters, appendable);\n\t\tappendable.append(\") \");\n\t\tJvmOperation operation = directlyInferredOperation;\n\t\tdeclareExceptions(operation, appendable);\n\t\tappendable.append(\"{\");\n\t\tappendable.increaseIndentation();\n\t\tif (obj.getCreateExtensionInfo()!=null) {\n\t\t\tcompileCreateExtensionBody(obj, appendable);\n\t\t} else {\n\t\t\tcompile(obj.getExpression(), appendable, returnType);\n\t\t}\n\t\tappendable.decreaseIndentation();\n\t\tappendable.append(\"\\n}\").closeScope();\n\t}","commit_id":"0451ff583bab6ebe36d29c15df63124165d6760a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmMember transform(XtendMember sourceMember, JvmGenericType container) {\n\t\tif (sourceMember instanceof XtendFunction) {\n\t\t\tXtendFunction source = (XtendFunction) sourceMember;\n\t\t\tJvmOperation target = typesFactory.createJvmOperation();\n\t\t\tcontainer.getMembers().add(target);\n\t\t\tassociator.associatePrimary(source, target);\n\t\t\tString sourceName = source.getName();\n\t\t\tif (source.isDispatch()) {\n\t\t\t\tsourceName = \"_\" + sourceName;\n\t\t\t}\n\t\t\ttarget.setSimpleName(sourceName);\n\t\t\ttarget.setVisibility(JvmVisibility.PUBLIC);\n\t\t\tfor (XtendParameter parameter : source.getParameters()) {\n\t\t\t\tJvmFormalParameter jvmParam = typesFactory.createJvmFormalParameter();\n\t\t\t\tjvmParam.setName(parameter.getName());\n\t\t\t\tjvmParam.setParameterType(EcoreUtil2.cloneWithProxies(parameter.getParameterType()));\n\t\t\t\ttarget.getParameters().add(jvmParam);\n\t\t\t}\n\t\t\tif (source.getReturnType()!=null) {\n\t\t\t\ttarget.setReturnType(EcoreUtil2.cloneWithProxies(source.getReturnType()));\n\t\t\t} else {\n\t\t\t\ttarget.setReturnType(getTypeProxy(target));\n\t\t\t}\n\t\t\tfor (JvmTypeParameter typeParameter : source.getTypeParameters())\n\t\t\t\ttarget.getTypeParameters().add(EcoreUtil2.cloneWithProxies(typeParameter));\n\t\t\treturn target;\n\t\t} else if (sourceMember instanceof XtendField) {\n\t\t\tXtendField dep = (XtendField) sourceMember;\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(dep, field);\n\t\t\tfield.setVisibility(JvmVisibility.PRIVATE);\n\t\t\tfield.setSimpleName(dep.getName());\n\t\t\tfield.setType(EcoreUtil2.cloneWithProxies(dep.getType()));\n\t\t\treturn field;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot transform \" + notNull(sourceMember) + \" to a JvmMember\");\n\t}","id":77563,"modified_method":"protected JvmMember transform(XtendMember sourceMember, JvmGenericType container) {\n\t\tif (sourceMember instanceof XtendFunction) {\n\t\t\tXtendFunction source = (XtendFunction) sourceMember;\n\t\t\tJvmOperation target = typesFactory.createJvmOperation();\n\t\t\tcontainer.getMembers().add(target);\n\t\t\tassociator.associatePrimary(source, target);\n\t\t\tString sourceName = source.getName();\n\t\t\tJvmVisibility visibility = JvmVisibility.PUBLIC;\n\t\t\tif (source.isDispatch()) {\n\t\t\t\tsourceName = \"_\" + sourceName;\n\t\t\t\tvisibility = JvmVisibility.PROTECTED;\n\t\t\t}\n\t\t\ttarget.setSimpleName(sourceName);\n\t\t\ttarget.setVisibility(visibility);\n\t\t\tfor (XtendParameter parameter : source.getParameters()) {\n\t\t\t\tJvmFormalParameter jvmParam = typesFactory.createJvmFormalParameter();\n\t\t\t\tjvmParam.setName(parameter.getName());\n\t\t\t\tjvmParam.setParameterType(EcoreUtil2.cloneWithProxies(parameter.getParameterType()));\n\t\t\t\ttarget.getParameters().add(jvmParam);\n\t\t\t}\n\t\t\tif (source.getReturnType()!=null) {\n\t\t\t\ttarget.setReturnType(EcoreUtil2.cloneWithProxies(source.getReturnType()));\n\t\t\t} else {\n\t\t\t\ttarget.setReturnType(getTypeProxy(target));\n\t\t\t}\n\t\t\tfor (JvmTypeParameter typeParameter : source.getTypeParameters())\n\t\t\t\ttarget.getTypeParameters().add(EcoreUtil2.cloneWithProxies(typeParameter));\n\t\t\treturn target;\n\t\t} else if (sourceMember instanceof XtendField) {\n\t\t\tXtendField dep = (XtendField) sourceMember;\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(dep, field);\n\t\t\tfield.setVisibility(JvmVisibility.PRIVATE);\n\t\t\tfield.setSimpleName(dep.getName());\n\t\t\tfield.setType(EcoreUtil2.cloneWithProxies(dep.getType()));\n\t\t\treturn field;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot transform \" + notNull(sourceMember) + \" to a JvmMember\");\n\t}","commit_id":"0451ff583bab6ebe36d29c15df63124165d6760a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            final int numOrds = globalOrdinals.setDocument(doc);\n            for (int i = 0; i < numOrds; i++) {\n                final long globalOrd = globalOrdinals.nextOrd();\n                long bucketOrd = bucketOrds.add(globalOrd);\n                if (bucketOrd < 0) {\n                    bucketOrd = -1 - bucketOrd;\n                }\n                collectBucket(doc, bucketOrd);\n            }\n        }","id":77564,"modified_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            final int numOrds = globalOrdinals.setDocument(doc);\n            for (int i = 0; i < numOrds; i++) {\n                final long globalOrd = globalOrdinals.nextOrd();\n                long bucketOrd = bucketOrds.add(globalOrd);\n                if (bucketOrd < 0) {\n                    bucketOrd = -1 - bucketOrd;\n                    collectExistingBucket(doc, bucketOrd);\n                } else {\n                    collectBucket(doc, bucketOrd);\n                }\n            }\n        }","commit_id":"34fb5e48e2e0e606973d832d47bfd03bb8cbe645","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            numCollectedDocs++;\n            final int numOrds = globalOrdinals.setDocument(doc);\n            for (int i = 0; i < numOrds; i++) {\n                final long globalOrd = globalOrdinals.nextOrd();\n                long bucketOrd = bucketOrds.add(globalOrd);\n                if (bucketOrd < 0) {\n                    bucketOrd = -1 - bucketOrd;\n                }\n                collectBucket(doc, bucketOrd);\n            }\n        }","id":77565,"modified_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            numCollectedDocs++;\n            final int numOrds = globalOrdinals.setDocument(doc);\n            for (int i = 0; i < numOrds; i++) {\n                final long globalOrd = globalOrdinals.nextOrd();\n                long bucketOrd = bucketOrds.add(globalOrd);\n                if (bucketOrd < 0) {\n                    bucketOrd = -1 - bucketOrd;\n                    collectExistingBucket(doc, bucketOrd);\n                } else {\n                    collectBucket(doc, bucketOrd);\n                }\n            }\n        }","commit_id":"5a0070071afa9631f4b9d5860d67924feb930b21","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final double val = values.nextValue();\n            final long bits = Double.doubleToRawLongBits(val);\n            long bucketOrdinal = bucketOrds.add(bits);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n            }\n            collectBucket(doc, bucketOrdinal);\n        }\n    }","id":77566,"modified_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final double val = values.nextValue();\n            final long bits = Double.doubleToRawLongBits(val);\n            long bucketOrdinal = bucketOrds.add(bits);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n                collectExistingBucket(doc, bucketOrdinal);\n            } else {\n                collectBucket(doc, bucketOrdinal);\n            }\n        }\n    }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final long val = values.nextValue();\n            long bucketOrdinal = bucketOrds.add(val);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n            }\n            collectBucket(doc, bucketOrdinal);\n        }\n    }","id":77567,"modified_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final long val = values.nextValue();\n            long bucketOrdinal = bucketOrds.add(val);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n                collectExistingBucket(doc, bucketOrdinal);\n            } else {\n                collectBucket(doc, bucketOrdinal);\n            }\n        }\n    }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        long previousKey = Long.MIN_VALUE;\n        for (int i = 0; i < valuesCount; ++i) {\n            long value = values.nextValue();\n            long key = rounding.roundKey(value);\n            assert key >= previousKey;\n            if (key == previousKey) {\n                continue;\n            }\n            long bucketOrd = bucketOrds.add(key);\n            if (bucketOrd < 0) { // already seen\n                bucketOrd = -1 - bucketOrd;\n            }\n            collectBucket(doc, bucketOrd);\n            previousKey = key;\n        }\n    }","id":77568,"modified_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        long previousKey = Long.MIN_VALUE;\n        for (int i = 0; i < valuesCount; ++i) {\n            long value = values.nextValue();\n            long key = rounding.roundKey(value);\n            assert key >= previousKey;\n            if (key == previousKey) {\n                continue;\n            }\n            long bucketOrd = bucketOrds.add(key);\n            if (bucketOrd < 0) { // already seen\n                bucketOrd = -1 - bucketOrd;\n                collectExistingBucket(doc, bucketOrd);\n            } else {\n                collectBucket(doc, bucketOrd);\n            }\n            previousKey = key;\n        }\n    }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final long val = values.nextValue();\n            long bucketOrdinal = bucketOrds.add(val);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n            }\n            collectBucket(doc, bucketOrdinal);\n        }\n    }","id":77569,"modified_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final long val = values.nextValue();\n            long bucketOrdinal = bucketOrds.add(val);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n                collectExistingBucket(doc, bucketOrdinal);\n            } else {\n                collectBucket(doc, bucketOrdinal);\n            }\n        }\n    }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            assert owningBucketOrdinal == 0 : \"this is a per_bucket aggregator\";\n            numCollectedDocs++;\n            final int valuesCount = ordinals.setDocument(doc);\n\n            for (int i = 0; i < valuesCount; ++i) {\n                final long ord = ordinals.nextOrd();\n                long bucketOrd = ordinalToBucket.get(ord);\n                if (bucketOrd < 0) { // unlikely condition on a low-cardinality field\n                    final BytesRef bytes = bytesValues.getValueByOrd(ord);\n                    final int hash = bytesValues.currentValueHash();\n                    assert hash == bytes.hashCode();\n                    bucketOrd = bucketOrds.add(bytes, hash);\n                    if (bucketOrd < 0) { // already seen in another segment\n                        bucketOrd = -1 - bucketOrd;\n                    }\n                    ordinalToBucket.set(ord, bucketOrd);\n                }\n\n                collectBucket(doc, bucketOrd);\n            }\n        }","id":77570,"modified_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            assert owningBucketOrdinal == 0 : \"this is a per_bucket aggregator\";\n            numCollectedDocs++;\n            final int valuesCount = ordinals.setDocument(doc);\n\n            for (int i = 0; i < valuesCount; ++i) {\n                final long ord = ordinals.nextOrd();\n                long bucketOrd = ordinalToBucket.get(ord);\n                if (bucketOrd < 0) { // unlikely condition on a low-cardinality field\n                    final BytesRef bytes = bytesValues.getValueByOrd(ord);\n                    final int hash = bytesValues.currentValueHash();\n                    assert hash == bytes.hashCode();\n                    bucketOrd = bucketOrds.add(bytes, hash);\n                    if (bucketOrd < 0) { // already seen in another segment\n                        bucketOrd = -1 - bucketOrd;\n                        collectExistingBucket(doc, bucketOrd);\n                    } else {\n                        collectBucket(doc, bucketOrd);\n                    }\n                    ordinalToBucket.set(ord, bucketOrd);\n                } else {\n                    collectExistingBucket(doc, bucketOrd);\n                }\n\n            }\n        }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            assert owningBucketOrdinal == 0 : \"this is a per_bucket aggregator\";\n            final int valuesCount = ordinals.setDocument(doc);\n\n            for (int i = 0; i < valuesCount; ++i) {\n                final long ord = ordinals.nextOrd();\n                long bucketOrd = ordinalToBucket.get(ord);\n                if (bucketOrd < 0) { // unlikely condition on a low-cardinality field\n                    final BytesRef bytes = bytesValues.getValueByOrd(ord);\n                    final int hash = bytesValues.currentValueHash();\n                    assert hash == bytes.hashCode();\n                    bucketOrd = bucketOrds.add(bytes, hash);\n                    if (bucketOrd < 0) { // already seen in another segment\n                        bucketOrd = - 1 - bucketOrd;\n                    }\n                    ordinalToBucket.set(ord, bucketOrd);\n                }\n\n                collectBucket(doc, bucketOrd);\n            }\n        }","id":77571,"modified_method":"@Override\n        public void collect(int doc, long owningBucketOrdinal) throws IOException {\n            assert owningBucketOrdinal == 0 : \"this is a per_bucket aggregator\";\n            final int valuesCount = ordinals.setDocument(doc);\n\n            for (int i = 0; i < valuesCount; ++i) {\n                final long ord = ordinals.nextOrd();\n                long bucketOrd = ordinalToBucket.get(ord);\n                if (bucketOrd < 0) { // unlikely condition on a low-cardinality field\n                    final BytesRef bytes = bytesValues.getValueByOrd(ord);\n                    final int hash = bytesValues.currentValueHash();\n                    assert hash == bytes.hashCode();\n                    bucketOrd = bucketOrds.add(bytes, hash);\n                    if (bucketOrd < 0) { // already seen in another segment\n                        bucketOrd = - 1 - bucketOrd;\n                        collectExistingBucket(doc, bucketOrd);\n                    } else {\n                        collectBucket(doc, bucketOrd);\n                    }\n                    ordinalToBucket.set(ord, bucketOrd);\n                } else {\n                    collectExistingBucket(doc, bucketOrd);\n                }\n            }\n        }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final BytesRef bytes = values.nextValue();\n            if (includeExclude != null && !includeExclude.accept(bytes)) {\n                continue;\n            }\n            final int hash = values.currentValueHash();\n            assert hash == bytes.hashCode();\n            long bucketOrdinal = bucketOrds.add(bytes, hash);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n            }\n            collectBucket(doc, bucketOrdinal);\n        }\n    }","id":77572,"modified_method":"@Override\n    public void collect(int doc, long owningBucketOrdinal) throws IOException {\n        assert owningBucketOrdinal == 0;\n        final int valuesCount = values.setDocument(doc);\n\n        for (int i = 0; i < valuesCount; ++i) {\n            final BytesRef bytes = values.nextValue();\n            if (includeExclude != null && !includeExclude.accept(bytes)) {\n                continue;\n            }\n            final int hash = values.currentValueHash();\n            assert hash == bytes.hashCode();\n            long bucketOrdinal = bucketOrds.add(bytes, hash);\n            if (bucketOrdinal < 0) { // already seen\n                bucketOrdinal = - 1 - bucketOrdinal;\n                collectExistingBucket(doc, bucketOrdinal);\n            } else {\n                collectBucket(doc, bucketOrdinal);\n            }\n        }\n    }","commit_id":"fc3efda6afdbbac0852ada27c0ef29588630271b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static AnnotationCodegen forAnnotationDefaultValue(final MethodVisitor mv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return mv.visitAnnotationDefault();\n            }\n        };\n    }","id":77573,"modified_method":"public static AnnotationCodegen forAnnotationDefaultValue(final MethodVisitor mv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @NotNull\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return safe(mv.visitAnnotationDefault());\n            }\n        };\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static AnnotationCodegen forParameter(final int parameter, final MethodVisitor mv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return mv.visitParameterAnnotation(parameter, descr, visible);\n            }\n        };\n    }","id":77574,"modified_method":"public static AnnotationCodegen forParameter(final int parameter, final MethodVisitor mv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @NotNull\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return safe(mv.visitParameterAnnotation(parameter, descr, visible));\n            }\n        };\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static AnnotationCodegen forField(final FieldVisitor fv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return fv.visitAnnotation(descr, visible);\n            }\n        };\n    }","id":77575,"modified_method":"public static AnnotationCodegen forField(final FieldVisitor fv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @NotNull\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return safe(fv.visitAnnotation(descr, visible));\n            }\n        };\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static AnnotationCodegen forClass(final ClassVisitor cv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return cv.visitAnnotation(descr, visible);\n            }\n        };\n    }","id":77576,"modified_method":"public static AnnotationCodegen forClass(final ClassVisitor cv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @NotNull\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return safe(cv.visitAnnotation(descr, visible));\n            }\n        };\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static AnnotationCodegen forMethod(final MethodVisitor mv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return mv.visitAnnotation(descr, visible);\n            }\n        };\n    }","id":77577,"modified_method":"public static AnnotationCodegen forMethod(final MethodVisitor mv, JetTypeMapper mapper) {\n        return new AnnotationCodegen(mapper) {\n            @NotNull\n            @Override\n            AnnotationVisitor visitAnnotation(String descr, boolean visible) {\n                return safe(mv.visitAnnotation(descr, visible));\n            }\n        };\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    private void generateJetValueParameterAnnotations(\n            @NotNull MethodVisitor mv,\n            @NotNull FunctionDescriptor functionDescriptor,\n            @NotNull JvmMethodSignature jvmSignature\n    ) {\n        Iterator<ValueParameterDescriptor> descriptors = functionDescriptor.getValueParameters().iterator();\n        List<JvmMethodParameterSignature> kotlinParameterTypes = jvmSignature.getKotlinParameterTypes();\n\n        for (int i = 0; i < kotlinParameterTypes.size(); i++) {\n            JvmMethodParameterKind kind = kotlinParameterTypes.get(i).getKind();\n            if (kind == JvmMethodParameterKind.ENUM_NAME || kind == JvmMethodParameterKind.ENUM_ORDINAL) {\n                markEnumConstructorParameterAsSynthetic(mv, i);\n                continue;\n            }\n\n            String name;\n            boolean nullableType;\n            if (kind == JvmMethodParameterKind.VALUE) {\n                ValueParameterDescriptor descriptor = descriptors.next();\n                name = descriptor.getName().asString();\n                nullableType = descriptor.getType().isNullable();\n            }\n            else {\n                String lowercaseKind = kind.name().toLowerCase();\n                if (needIndexForVar(kind)) {\n                    name = \"$\" + lowercaseKind + \"$\" + i;\n                }\n                else {\n                    name = \"$\" + lowercaseKind;\n                }\n\n                if (kind == JvmMethodParameterKind.RECEIVER) {\n                    ReceiverParameterDescriptor receiver = functionDescriptor.getReceiverParameter();\n                    nullableType = receiver == null || receiver.getType().isNullable();\n                }\n                else {\n                    nullableType = true;\n                }\n            }\n\n            AnnotationVisitor av =\n                    mv.visitParameterAnnotation(i, asmDescByFqNameWithoutInnerClasses(fqNameByClass(JetValueParameter.class)), true);\n            av.visit(\"name\", name);\n            if (nullableType) {\n                av.visit(\"type\", \"?\");\n            }\n            av.visitEnd();\n        }\n    }","id":77578,"modified_method":"@SuppressWarnings(\"deprecation\")\n    private void generateJetValueParameterAnnotations(\n            @NotNull MethodVisitor mv,\n            @NotNull FunctionDescriptor functionDescriptor,\n            @NotNull JvmMethodSignature jvmSignature\n    ) {\n        Iterator<ValueParameterDescriptor> descriptors = functionDescriptor.getValueParameters().iterator();\n        List<JvmMethodParameterSignature> kotlinParameterTypes = jvmSignature.getKotlinParameterTypes();\n\n        for (int i = 0; i < kotlinParameterTypes.size(); i++) {\n            JvmMethodParameterKind kind = kotlinParameterTypes.get(i).getKind();\n            if (kind == JvmMethodParameterKind.ENUM_NAME || kind == JvmMethodParameterKind.ENUM_ORDINAL) {\n                markEnumConstructorParameterAsSynthetic(mv, i);\n                continue;\n            }\n\n            String name;\n            boolean nullableType;\n            if (kind == JvmMethodParameterKind.VALUE) {\n                ValueParameterDescriptor descriptor = descriptors.next();\n                name = descriptor.getName().asString();\n                nullableType = descriptor.getType().isNullable();\n            }\n            else {\n                String lowercaseKind = kind.name().toLowerCase();\n                if (needIndexForVar(kind)) {\n                    name = \"$\" + lowercaseKind + \"$\" + i;\n                }\n                else {\n                    name = \"$\" + lowercaseKind;\n                }\n\n                if (kind == JvmMethodParameterKind.RECEIVER) {\n                    ReceiverParameterDescriptor receiver = functionDescriptor.getReceiverParameter();\n                    nullableType = receiver == null || receiver.getType().isNullable();\n                }\n                else {\n                    nullableType = true;\n                }\n            }\n\n            AnnotationVisitor av =\n                    mv.visitParameterAnnotation(i, asmDescByFqNameWithoutInnerClasses(fqNameByClass(JetValueParameter.class)), true);\n            if (av != null) {\n                av.visit(\"name\", name);\n                if (nullableType) {\n                    av.visit(\"type\", \"?\");\n                }\n                av.visitEnd();\n            }\n        }\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void markEnumConstructorParameterAsSynthetic(MethodVisitor mv, int i) {\n        // IDEA's ClsPsi builder fails to annotate synthetic parameters\n        if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES) return;\n\n        // This is needed to avoid RuntimeInvisibleParameterAnnotations error in javac:\n        // see MethodWriter.visitParameterAnnotation()\n\n        AnnotationVisitor av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", true);\n        av.visitEnd();\n    }","id":77579,"modified_method":"private void markEnumConstructorParameterAsSynthetic(MethodVisitor mv, int i) {\n        // IDEA's ClsPsi builder fails to annotate synthetic parameters\n        if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES) return;\n\n        // This is needed to avoid RuntimeInvisibleParameterAnnotations error in javac:\n        // see MethodWriter.visitParameterAnnotation()\n\n        AnnotationVisitor av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", true);\n        if (av != null) {\n            av.visitEnd();\n        }\n    }","commit_id":"f3901d28448a60ff9d9d56f07306ccb2b525ae22","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testIntGenerics () throws Exception {\n        loadText(\"class L<T>(var a : T) {} fun foo() = L<Int>(5).a\");\n//        System.out.println(generateToText());\n        Method foo = generateFunction();\n        Object invoke = foo.invoke(null);\n        System.out.println(invoke.getClass());\n        assertTrue(invoke instanceof Integer);\n    }","id":77580,"modified_method":"public void testIntGenerics () throws Exception {\n        loadText(\"class L<T>(var a : T) {} fun foo() = L<Int>(5).a\");\n        System.out.println(generateToText());\n        Method foo = generateFunction();\n        Object invoke = foo.invoke(null);\n        System.out.println(invoke.getClass());\n        assertTrue(invoke instanceof Integer);\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"NamespaceCodegen forNamespace(JetFile file) {\n        assert !isDone : \"Already done!\";\n        FqName fqName = JetPsiUtil.getFQName(file);\n        NamespaceCodegen codegen = ns2codegen.get(fqName);\n        if (codegen == null) {\n            final ClassBuilder builder = newVisitor(NamespaceCodegen.getJVMClassNameForKotlinNs(fqName).getInternalName() + \".class\");\n            codegen = new NamespaceCodegen(builder, fqName, state, file.getContainingFile());\n            ns2codegen.put(fqName, codegen);\n        }\n\n        return codegen;\n    }","id":77581,"modified_method":"NamespaceCodegen forNamespace(FqName fqName, Collection<JetFile> files) {\n        assert !isDone : \"Already done!\";\n        NamespaceCodegen codegen = ns2codegen.get(fqName);\n        if (codegen == null) {\n            final ClassBuilder builder = newVisitor(NamespaceCodegen.getJVMClassNameForKotlinNs(fqName).getInternalName() + \".class\");\n            codegen = new NamespaceCodegen(builder, fqName, state, files);\n            ns2codegen.put(fqName, codegen);\n        }\n\n        return codegen;\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void compileCorrectFiles(@NotNull CompilationErrorHandler errorHandler) {\n        MultiMap<String, JetFile> namespaceGrouping = new MultiMap<String, JetFile>();\n        for (JetFile file : this.files) {\n            if (file == null) throw new IllegalArgumentException(\"A null file given for compilation\");\n            namespaceGrouping.putValue(JetPsiUtil.getFQName(file).getFqName(), file);\n        }\n\n        for (Map.Entry<String, Collection<JetFile>> entry : namespaceGrouping.entrySet()) {\n            for (JetFile file : entry.getValue()) {\n                VirtualFile vFile = file.getVirtualFile();\n                String path = vFile != null ? vFile.getPath() : \"no_virtual_file/\" + file.getName();\n                progress.log(\"For source: \" + path + \"\\tFor namespace: \" + entry.getKey());\n                try {\n                    generateNamespace(file);\n                }\n                catch (ProcessCanceledException e) {\n                    throw e;\n                }\n                catch (Throwable e) {\n                    errorHandler.reportException(e, vFile == null ? \"no file\" : vFile.getUrl());\n                    DiagnosticUtils.throwIfRunningOnServer(e);\n                    if (ApplicationManager.getApplication().isInternal()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }","id":77582,"modified_method":"public void compileCorrectFiles(@NotNull CompilationErrorHandler errorHandler) {\n        MultiMap<FqName, JetFile> namespaceGrouping = new MultiMap<FqName, JetFile>();\n        for (JetFile file : this.files) {\n            if (file == null) throw new IllegalArgumentException(\"A null file given for compilation\");\n            namespaceGrouping.putValue(JetPsiUtil.getFQName(file), file);\n        }\n\n        for (Map.Entry<FqName, Collection<JetFile>> entry : namespaceGrouping.entrySet()) {\n            generateNamespace(entry.getKey(), entry.getValue(), errorHandler, progress);\n        }\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public NamespaceCodegen forNamespace(JetFile namespace) {\n        return getFactory().forNamespace(namespace);\n    }","id":77583,"modified_method":"public NamespaceCodegen forNamespace(FqName fqName, Collection<JetFile> namespace) {\n        return getFactory().forNamespace(fqName, namespace);\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private PsiJavaFileStub calcStub() {\n        final PsiJavaFileStubImpl answer = new PsiJavaFileStubImpl(JetPsiUtil.getFQName(file).getFqName(), true);\n        final Project project = getProject();\n\n        final Stack<StubElement> stubStack = new Stack<StubElement>();\n\n        final ClassBuilderFactory builderFactory = new ClassBuilderFactory() {\n            @NotNull\n            @Override\n            public ClassBuilderMode getClassBuilderMode() {\n                return ClassBuilderMode.SIGNATURES;\n            }\n\n            @Override\n            public ClassBuilder newClassBuilder() {\n                return new StubClassBuilder(stubStack);\n            }\n\n            @Override\n            public String asText(ClassBuilder builder) {\n                throw new UnsupportedOperationException(\"asText is not implemented\"); // TODO\n            }\n\n            @Override\n            public byte[] asBytes(ClassBuilder builder) {\n                throw new UnsupportedOperationException(\"asBytes is not implemented\"); // TODO\n            }\n        };\n\n        // The context must reflect _all files in the module_. not only the current file\n        // Otherwise, the analyzer gets confused and can't, for example, tell which files come as sources and which\n        // must be loaded from .class files\n        AnalyzeExhaust context = AnalyzerFacadeForJVM.shallowAnalyzeFiles(\n            JetFilesProvider.getInstance(project).sampleToAllFilesInModule().fun(file),\n                // TODO: wrong environment // stepan.koltsov@ 2012-04-09\n                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR));\n\n        if (context.isError()) {\n            throw new IllegalStateException(\"failed to analyze: \" + context.getError(), context.getError());\n        }\n\n        final GenerationState state = new GenerationState(project, builderFactory, context, Collections.singletonList(file)) {\n            @Override\n            protected void generateNamespace(JetFile namespace) {\n                PsiManager manager = PsiManager.getInstance(project);\n                stubStack.push(answer);\n\n                answer.setPsiFactory(new ClsWrapperStubPsiFactory());\n                final ClsFileImpl fakeFile =\n                    new ClsFileImpl((PsiManagerImpl)manager, new ClassFileViewProvider(manager, file.getVirtualFile())) {\n                        @NotNull\n                        @Override\n                        public PsiClassHolderFileStub getStub() {\n                            return answer;\n                        }\n                    };\n\n                fakeFile.setPhysical(false);\n                answer.setPsi(fakeFile);\n\n                super.generateNamespace(namespace);\n                final StubElement pop = stubStack.pop();\n                if (pop != answer) {\n                    LOG.error(\"Unbalanced stack operations: \" + pop);\n                }\n            }\n        };\n\n\n        state.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);\n        state.getFactory().files();\n\n        return answer;\n    }","id":77584,"modified_method":"private PsiJavaFileStub calcStub() {\n        final PsiJavaFileStubImpl answer = new PsiJavaFileStubImpl(JetPsiUtil.getFQName(file).getFqName(), true);\n        final Project project = getProject();\n\n        final Stack<StubElement> stubStack = new Stack<StubElement>();\n\n        final ClassBuilderFactory builderFactory = new ClassBuilderFactory() {\n            @NotNull\n            @Override\n            public ClassBuilderMode getClassBuilderMode() {\n                return ClassBuilderMode.SIGNATURES;\n            }\n\n            @Override\n            public ClassBuilder newClassBuilder() {\n                return new StubClassBuilder(stubStack);\n            }\n\n            @Override\n            public String asText(ClassBuilder builder) {\n                throw new UnsupportedOperationException(\"asText is not implemented\"); // TODO\n            }\n\n            @Override\n            public byte[] asBytes(ClassBuilder builder) {\n                throw new UnsupportedOperationException(\"asBytes is not implemented\"); // TODO\n            }\n        };\n\n        // The context must reflect _all files in the module_. not only the current file\n        // Otherwise, the analyzer gets confused and can't, for example, tell which files come as sources and which\n        // must be loaded from .class files\n        AnalyzeExhaust context = AnalyzerFacadeForJVM.shallowAnalyzeFiles(\n            JetFilesProvider.getInstance(project).sampleToAllFilesInModule().fun(file),\n                // TODO: wrong environment // stepan.koltsov@ 2012-04-09\n                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR));\n\n        if (context.isError()) {\n            throw new IllegalStateException(\"failed to analyze: \" + context.getError(), context.getError());\n        }\n\n        final GenerationState state = new GenerationState(project, builderFactory, context, Collections.singletonList(file)) {\n            @Override\n            protected void generateNamespace(FqName fqName, Collection<JetFile> namespace, CompilationErrorHandler errorHandler, Progress progress) {\n                PsiManager manager = PsiManager.getInstance(project);\n                stubStack.push(answer);\n\n                answer.setPsiFactory(new ClsWrapperStubPsiFactory());\n                final ClsFileImpl fakeFile =\n                    new ClsFileImpl((PsiManagerImpl)manager, new ClassFileViewProvider(manager, file.getVirtualFile())) {\n                        @NotNull\n                        @Override\n                        public PsiClassHolderFileStub getStub() {\n                            return answer;\n                        }\n                    };\n\n                fakeFile.setPhysical(false);\n                answer.setPsi(fakeFile);\n\n                super.generateNamespace(fqName, namespace, errorHandler, progress);\n                final StubElement pop = stubStack.pop();\n                if (pop != answer) {\n                    LOG.error(\"Unbalanced stack operations: \" + pop);\n                }\n            }\n        };\n\n\n        state.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);\n        state.getFactory().files();\n\n        return answer;\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generate(JetFile file) {\n\n        for (JetDeclaration declaration : file.getDeclarations()) {\n            if (declaration instanceof JetProperty || declaration instanceof JetNamedFunction) {\n                NamespaceDescriptor descriptor = state.getBindingContext().get(BindingContext.FILE_TO_NAMESPACE, file);\n                final CodegenContext context = CodegenContexts.STATIC.intoNamespace(descriptor);\n                state.getInjector().getMemberCodegen().generateFunctionOrProperty(\n                        (JetTypeParameterListOwner) declaration, context, v);\n            }\n            else if (declaration instanceof JetClassOrObject) {\n                NamespaceDescriptor descriptor = state.getBindingContext().get(BindingContext.FILE_TO_NAMESPACE, file);\n                final CodegenContext context = CodegenContexts.STATIC.intoNamespace(descriptor);\n                state.getInjector().getClassCodegen().generate(context, (JetClassOrObject) declaration);\n            }\n            else if (declaration instanceof JetScript) {\n                state.getInjector().getScriptCodegen().generate((JetScript) declaration);\n            }\n//            else if (declaration instanceof JetFile) {\n//                JetFile childNamespace = (JetFile) declaration;\n//                state.forNamespace(childNamespace).generate(childNamespace);\n//            }\n        }\n\n        if (hasNonConstantPropertyInitializers(file)) {\n            generateStaticInitializers(file);\n        }\n    }","id":77585,"modified_method":"private void generate(JetFile file) {\n        for (JetDeclaration declaration : file.getDeclarations()) {\n            if (declaration instanceof JetProperty || declaration instanceof JetNamedFunction) {\n                NamespaceDescriptor descriptor = state.getBindingContext().get(BindingContext.FILE_TO_NAMESPACE, file);\n                final CodegenContext context = CodegenContexts.STATIC.intoNamespace(descriptor);\n                state.getInjector().getMemberCodegen().generateFunctionOrProperty(\n                        (JetTypeParameterListOwner) declaration, context, v);\n            }\n            else if (declaration instanceof JetClassOrObject) {\n                NamespaceDescriptor descriptor = state.getBindingContext().get(BindingContext.FILE_TO_NAMESPACE, file);\n                final CodegenContext context = CodegenContexts.STATIC.intoNamespace(descriptor);\n                state.getInjector().getClassCodegen().generate(context, (JetClassOrObject) declaration);\n            }\n            else if (declaration instanceof JetScript) {\n                state.getInjector().getScriptCodegen().generate((JetScript) declaration);\n            }\n        }\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateStaticInitializers(JetFile namespace) {\n        MethodVisitor mv = v.newMethod(namespace, ACC_PUBLIC | ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n        if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n            mv.visitCode();\n\n            FrameMap frameMap = new FrameMap();\n            ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, CodegenContexts.STATIC, state);\n\n            for (JetDeclaration declaration : namespace.getDeclarations()) {\n                if (declaration instanceof JetProperty) {\n                    final JetExpression initializer = ((JetProperty) declaration).getInitializer();\n                    if (initializer != null && !(initializer instanceof JetConstantExpression)) {\n                        final PropertyDescriptor descriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, declaration);\n                        assert descriptor != null;\n                        if(descriptor.getReceiverParameter().exists()) {\n                            continue;\n                        }\n                        codegen.genToJVMStack(initializer);\n                        codegen.intermediateValueForProperty(descriptor, true, null).store(new InstructionAdapter(mv));\n                    }\n                }\n            }\n\n            mv.visitInsn(RETURN);\n            FunctionCodegen.endVisit(mv, \"static initializer for namespace\", namespace);\n            mv.visitEnd();\n        }\n    }","id":77586,"modified_method":"private void generateStaticInitializers() {\n        JetFile namespace = files.iterator().next(); // @todo: hack\n\n        MethodVisitor mv = v.newMethod(namespace, ACC_PUBLIC | ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n        for (JetFile file : files) {\n            if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                mv.visitCode();\n\n                FrameMap frameMap = new FrameMap();\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, CodegenContexts.STATIC, state);\n\n                for (JetDeclaration declaration : file.getDeclarations()) {\n                    if (declaration instanceof JetProperty) {\n                        final JetExpression initializer = ((JetProperty) declaration).getInitializer();\n                        if (initializer != null && !(initializer instanceof JetConstantExpression)) {\n                            final PropertyDescriptor descriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, declaration);\n                            assert descriptor != null;\n                            if(descriptor.getReceiverParameter().exists()) {\n                                continue;\n                            }\n                            codegen.genToJVMStack(initializer);\n                            codegen.intermediateValueForProperty(descriptor, true, null).store(new InstructionAdapter(mv));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n            mv.visitInsn(RETURN);\n            FunctionCodegen.endVisit(mv, \"static initializer for namespace\", namespace);\n            mv.visitEnd();\n        }\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean hasNonConstantPropertyInitializers(JetFile namespace) {\n        for (JetDeclaration declaration : namespace.getDeclarations()) {\n            if (declaration instanceof JetProperty) {\n                final JetExpression initializer = ((JetProperty) declaration).getInitializer();\n                if (initializer != null && !(initializer instanceof JetConstantExpression)) {\n                    return true;\n                }\n\n            }\n        }\n        return false;\n    }","id":77587,"modified_method":"private boolean hasNonConstantPropertyInitializers() {\n        for (JetFile file : files) {\n            for (JetDeclaration declaration : file.getDeclarations()) {\n                if (declaration instanceof JetProperty) {\n                    final JetExpression initializer = ((JetProperty) declaration).getInitializer();\n                    if (initializer != null && !(initializer instanceof JetConstantExpression)) {\n                        return true;\n                    }\n\n                }\n            }\n        }\n        return false;\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public NamespaceCodegen(ClassBuilder v, @NotNull FqName fqName, GenerationState state, PsiFile sourceFile) {\n        this.v = v;\n        this.state = state;\n\n        v.defineClass(sourceFile, V1_6,\n                      ACC_PUBLIC/*|ACC_SUPER*/,\n                      getJVMClassNameForKotlinNs(fqName).getInternalName(),\n                      null,\n                      //\"jet/lang/Namespace\",\n                      \"java/lang/Object\",\n                      new String[0]\n        );\n        // TODO figure something out for a namespace that spans multiple files\n        v.visitSource(sourceFile.getName(), null);\n    }","id":77588,"modified_method":"public NamespaceCodegen(ClassBuilder v, @NotNull FqName fqName, GenerationState state, Collection<JetFile> files) {\n        this.v = v;\n        name = fqName;\n        this.state = state;\n        this.files = files;\n\n        PsiFile sourceFile = files.iterator().next().getContainingFile();\n        v.defineClass(sourceFile, V1_6,\n                      ACC_PUBLIC/*|ACC_SUPER*/,\n                      getJVMClassNameForKotlinNs(fqName).getInternalName(),\n                      null,\n                      //\"jet/lang/Namespace\",\n                      \"java/lang/Object\",\n                      new String[0]\n        );\n        // TODO figure something out for a namespace that spans multiple files\n        v.visitSource(sourceFile.getName(), null);\n    }","commit_id":"7d938dd98f91f977b9b26d681df79061566f234d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  public void visitPyReferenceExpression(PyReferenceExpression node) {\n    if (node.getQualifier() == null) {\n      PyFunction function = PsiTreeUtil.getParentOfType(node, PyFunction.class);\n      if (function != null) {\n        final PyNamedParameter element = (PyNamedParameter) function.getParameterList().getElementNamed(node.getReferencedName());\n        if (element != null) {\n          Annotation annotation = getHolder().createInfoAnnotation(node, null);\n          annotation.setTextAttributes(isSelf(element, function) ? PyHighlighter.PY_SELF_PARAMETER : PyHighlighter.PY_PARAMETER);\n        }\n      }\n    }\n  }","id":77589,"modified_method":"@Override\n  public void visitPyReferenceExpression(PyReferenceExpression node) {\n    final String referencedName = node.getReferencedName();\n    if (node.getQualifier() == null && referencedName != null) {\n      PyFunction function = PsiTreeUtil.getParentOfType(node, PyFunction.class);\n      if (function != null) {\n        final PyNamedParameter element = function.getParameterList().findParameterByName(referencedName);\n        if (element != null) {\n          Annotation annotation = getHolder().createInfoAnnotation(node, null);\n          annotation.setTextAttributes(isSelf(element, function) ? PyHighlighter.PY_SELF_PARAMETER : PyHighlighter.PY_PARAMETER);\n        }\n      }\n    }\n  }","commit_id":"abacb9632965a669acb93e49fe392988ac71cc34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public ResolveResult[] multiResolve(boolean incompleteCode) {\n    PsiElement call = PsiTreeUtil.getParentOfType(myElement, PyCallExpression.class, PyClass.class);\n    if (!(call instanceof PyCallExpression)) {\n      return new ResolveResult[0];\n    }\n    final PyExpression callee = ((PyCallExpression)call).getCallee();\n    if (callee == null) return ResolveResult.EMPTY_ARRAY;\n    final PsiPolyVariantReference calleeReference = (PsiPolyVariantReference) callee.getReference();\n    if (calleeReference == null) return ResolveResult.EMPTY_ARRAY;\n    final ResolveResult[] calleeCandidates = calleeReference.multiResolve(incompleteCode);\n    List<ResolveResult> resultList = new ArrayList<ResolveResult>();\n    for (ResolveResult calleeCandidate : calleeCandidates) {\n      if (!calleeCandidate.isValidResult()) continue;\n      final PsiElement element = calleeCandidate.getElement();\n      if (element == null) continue;\n      final PyFunction calleeFunction = resolveToFunction(element, new HashSet<PsiElement>());\n      if (calleeFunction != null) {\n        final PsiElement result = calleeFunction.getParameterList().getElementNamed(myElement.getKeyword());\n        if (result != null) {\n          resultList.add(new PsiElementResolveResult(result));\n        }\n      }\n    }\n    return resultList.toArray(new ResolveResult[resultList.size()]);\n  }","id":77590,"modified_method":"@NotNull\n  @Override\n  public ResolveResult[] multiResolve(boolean incompleteCode) {\n    final String keyword = myElement.getKeyword();\n    if (keyword == null) {\n      return ResolveResult.EMPTY_ARRAY;\n    }\n    PsiElement call = PsiTreeUtil.getParentOfType(myElement, PyCallExpression.class, PyClass.class);\n    if (!(call instanceof PyCallExpression)) {\n      return ResolveResult.EMPTY_ARRAY;\n    }\n    final PyExpression callee = ((PyCallExpression)call).getCallee();\n    if (callee == null) return ResolveResult.EMPTY_ARRAY;\n    final PsiPolyVariantReference calleeReference = (PsiPolyVariantReference) callee.getReference();\n    if (calleeReference == null) return ResolveResult.EMPTY_ARRAY;\n    final ResolveResult[] calleeCandidates = calleeReference.multiResolve(incompleteCode);\n    List<ResolveResult> resultList = new ArrayList<ResolveResult>();\n    for (ResolveResult calleeCandidate : calleeCandidates) {\n      if (!calleeCandidate.isValidResult()) continue;\n      final PsiElement element = calleeCandidate.getElement();\n      if (element == null) continue;\n      final PyFunction calleeFunction = resolveToFunction(element, new HashSet<PsiElement>());\n      if (calleeFunction != null) {\n        final PsiElement result = calleeFunction.getParameterList().findParameterByName(keyword);\n        if (result != null) {\n          resultList.add(new PsiElementResolveResult(result));\n        }\n      }\n    }\n    return resultList.toArray(new ResolveResult[resultList.size()]);\n  }","commit_id":"abacb9632965a669acb93e49fe392988ac71cc34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BindingContext analyzeNamespace(@NotNull JetNamespace namespace, @NotNull JetControlFlowDataTraceFactory flowDataTraceFactory) {\n        Project project = namespace.getProject();\n\n        BindingTraceContext bindingTraceContext = new BindingTraceContext();\n        JetSemanticServices semanticServices = JetSemanticServices.createSemanticServices(project, flowDataTraceFactory);\n\n        JetScope libraryScope = semanticServices.getStandardLibrary().getLibraryScope();\n        ModuleDescriptor owner = new ModuleDescriptor(\"<module>\");\n        final WritableScope scope = new WritableScopeImpl(libraryScope, owner, new TraceBasedRedeclarationHandler(bindingTraceContext)).setDebugName(\"Root scope in analyzeNamespace\");\n        importingStrategy.addImports(project, semanticServices, bindingTraceContext, scope);\n        TopDownAnalyzer.process(semanticServices, bindingTraceContext, scope, new NamespaceLike.Adapter(owner) {\n\n            @Override\n            public NamespaceDescriptorImpl getNamespace(String name) {\n                return null;\n            }\n\n            @Override\n            public void addNamespace(@NotNull NamespaceDescriptor namespaceDescriptor) {\n                scope.addNamespace(namespaceDescriptor);\n            }\n\n            @Override\n            public void addClassifierDescriptor(@NotNull MutableClassDescriptor classDescriptor) {\n                scope.addClassifierDescriptor(classDescriptor);\n            }\n\n            @Override\n            public void addFunctionDescriptor(@NotNull FunctionDescriptor functionDescriptor) {\n                scope.addFunctionDescriptor(functionDescriptor);\n            }\n\n            @Override\n            public void addPropertyDescriptor(@NotNull PropertyDescriptor propertyDescriptor) {\n                scope.addVariableDescriptor(propertyDescriptor);\n            }\n\n            @Override\n            public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptor classObjectDescriptor) {\n                throw new IllegalStateException(\"Must be guaranteed not to happen by the parser\");\n            }\n        }, Collections.<JetDeclaration>singletonList(namespace));\n        return bindingTraceContext.getBindingContext();\n    }","id":77591,"modified_method":"public BindingContext analyzeNamespace(@NotNull JetNamespace namespace, @NotNull JetControlFlowDataTraceFactory flowDataTraceFactory) {\n        Project project = namespace.getProject();\n        List<JetDeclaration> declarations = Collections.<JetDeclaration>singletonList(namespace);\n\n        return analyzeNamespaces(project, declarations, flowDataTraceFactory);\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public VariableDescriptor resolveSimpleProperty(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull ReceiverDescriptor receiver,\n            @NotNull final JetSimpleNameExpression nameExpression,\n            @NotNull JetType expectedType) {\n        Call call = CallMaker.makePropertyCall(nameExpression);\n        List<ResolutionTask<VariableDescriptor>> prioritizedTasks = PROPERTY_TASK_PRIORITIZER.computePrioritizedTasks(scope, receiver, call, nameExpression.getReferencedName());\n        return resolveCallToDescriptor(trace, scope, call, nameExpression.getNode(), expectedType, prioritizedTasks, nameExpression);\n    }","id":77592,"modified_method":"@Nullable\n    public VariableDescriptor resolveSimpleProperty(\n            @NotNull BindingTrace trace,\n            @NotNull JetScope scope,\n            @NotNull ReceiverDescriptor receiver,\n            @NotNull final JetSimpleNameExpression nameExpression,\n            @NotNull JetType expectedType) {\n        String referencedName = nameExpression.getReferencedName();\n        if (referencedName == null) {\n            return null;\n        }\n        Call call = CallMaker.makePropertyCall(nameExpression);\n        List<ResolutionTask<VariableDescriptor>> prioritizedTasks = PROPERTY_TASK_PRIORITIZER.computePrioritizedTasks(scope, receiver, call, referencedName);\n        return resolveCallToDescriptor(trace, scope, call, nameExpression.getNode(), expectedType, prioritizedTasks, nameExpression);\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void compile(JetFile psiFile) {\n        final JetNamespace namespace = psiFile.getRootNamespace();\n        NamespaceCodegen codegen = forNamespace(namespace);\n        final BindingContext bindingContext = AnalyzingUtils.getInstance(JavaDefaultImports.JAVA_DEFAULT_IMPORTS).analyzeNamespace(namespace, JetControlFlowDataTraceFactory.EMPTY);\n        bindingContexts.push(bindingContext);\n        typeMapper = new JetTypeMapper(standardLibrary, bindingContext);\n        try {\n            AnalyzingUtils.throwExceptionOnErrors(bindingContext);\n\n            codegen.generate(namespace);\n        }\n        finally {\n            bindingContexts.pop();\n            typeMapper = null;\n        }\n    }","id":77593,"modified_method":"public void compile(JetFile psiFile) {\n        final JetNamespace namespace = psiFile.getRootNamespace();\n        final BindingContext bindingContext = AnalyzingUtils.getInstance(JavaDefaultImports.JAVA_DEFAULT_IMPORTS).analyzeNamespace(namespace, JetControlFlowDataTraceFactory.EMPTY);\n        AnalyzingUtils.throwExceptionOnErrors(bindingContext);\n        compileCorrectNamespaces(bindingContext, Collections.singletonList(namespace));\n//        NamespaceCodegen codegen = forNamespace(namespace);\n//        bindingContexts.push(bindingContext);\n//        typeMapper = new JetTypeMapper(standardLibrary, bindingContext);\n//        try {\n//            AnalyzingUtils.throwExceptionOnErrors(bindingContext);\n//\n//            codegen.generate(namespace);\n//        }\n//        finally {\n//            bindingContexts.pop();\n//            typeMapper = null;\n//        }\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void compile(CompileContext compileContext, Chunk<Module> moduleChunk, VirtualFile[] virtualFiles, OutputSink outputSink) {\n        Map<Module, ModuleCompileState> moduleMap = new HashMap<Module, ModuleCompileState>();\n\n        for (VirtualFile virtualFile : virtualFiles) {\n            Module module = compileContext.getModuleByFile(virtualFile);\n            ModuleCompileState state = moduleMap.get(module);\n            if (state == null) {\n                state = new ModuleCompileState(compileContext, module, outputSink);\n                moduleMap.put(module, state);\n            }\n            state.compile(virtualFile);\n        }\n\n        for (ModuleCompileState state : moduleMap.values()) {\n            state.done();\n        }\n\n    }","id":77594,"modified_method":"@Override\n    public void compile(final CompileContext compileContext, Chunk<Module> moduleChunk, final VirtualFile[] virtualFiles, OutputSink outputSink) {\n        if (virtualFiles.length == 0) return;\n\n        Module module = compileContext.getModuleByFile(virtualFiles[0]);\n        final VirtualFile outputDir = compileContext.getModuleOutputDirectory(module);\n        if (outputDir == null) {\n            compileContext.addMessage(ERROR, \"[Internal Error] No output directory\", \"\", -1, -1);\n            return;\n        }\n\n        ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n                GenerationState generationState = new GenerationState(compileContext.getProject(), false);\n                List<JetNamespace> namespaces = Lists.newArrayList();\n                for (VirtualFile virtualFile : virtualFiles) {\n                    PsiFile psiFile = PsiManager.getInstance(compileContext.getProject()).findFile(virtualFile);\n                    if (psiFile instanceof JetFile) {\n                        namespaces.add(((JetFile) psiFile).getRootNamespace());\n                    }\n                }\n\n                BindingContext bindingContext = AnalyzingUtils.getInstance(JavaDefaultImports.JAVA_DEFAULT_IMPORTS).analyzeNamespaces(compileContext.getProject(), namespaces, JetControlFlowDataTraceFactory.EMPTY);\n\n                boolean errors = false;\n                for (Diagnostic diagnostic : bindingContext.getDiagnostics()) {\n                    switch (diagnostic.getSeverity()) {\n                        case ERROR:\n                            errors = true;\n                            report(diagnostic, CompilerMessageCategory.ERROR, compileContext);\n                            break;\n                        case INFO:\n                            report(diagnostic, CompilerMessageCategory.INFORMATION, compileContext);                            \n                            break;\n                        case WARNING:\n                            report(diagnostic, CompilerMessageCategory.WARNING, compileContext);                            \n                            break;\n                    }\n                }\n                \n                if (!errors) {\n                    generationState.compileCorrectNamespaces(bindingContext, namespaces);\n\n                    final ClassFileFactory factory = generationState.getFactory();\n                    List<String> files = factory.files();\n                    for (String file : files) {\n                        File target = new File(outputDir.getPath(), file);\n                        try {\n                            FileUtil.writeToFile(target, factory.asBytes(file));\n                        } catch (IOException e) {\n                            compileContext.addMessage(ERROR, e.getMessage(), null, 0, 0);\n                        }\n                    }\n                }\n            }\n        });\n        \n//        Map<Module, ModuleCompileState> moduleMap = new HashMap<Module, ModuleCompileState>();\n//\n//        for (VirtualFile virtualFile : virtualFiles) {\n//            Module module = compileContext.getModuleByFile(virtualFile);\n//            ModuleCompileState state = moduleMap.get(module);\n//            if (state == null) {\n//                state = new ModuleCompileState(compileContext, module, outputSink);\n//                moduleMap.put(module, state);\n//            }\n//            state.compile(virtualFile);\n//        }\n//\n//        for (ModuleCompileState state : moduleMap.values()) {\n//            state.done();\n//        }\n\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void process(\n            @NotNull JetSemanticServices semanticServices,\n            @NotNull BindingTrace trace,\n            @NotNull JetScope outerScope, NamespaceLike owner, @NotNull List<JetDeclaration> declarations) {\n        TopDownAnalysisContext context = new TopDownAnalysisContext(semanticServices, trace);\n        new TypeHierarchyResolver(context).process(outerScope, owner, declarations);\n        new DeclarationResolver(context).process();\n        new DelegationResolver(context).process();\n        new OverrideResolver(context).process();\n        new BodyResolver(context).resolveBehaviorDeclarationBodies();\n    }","id":77595,"modified_method":"public static void process(\n            @NotNull JetSemanticServices semanticServices,\n            @NotNull BindingTrace trace,\n            @NotNull JetScope outerScope, NamespaceLike owner, @NotNull List<? extends JetDeclaration> declarations) {\n        TopDownAnalysisContext context = new TopDownAnalysisContext(semanticServices, trace);\n        new TypeHierarchyResolver(context).process(outerScope, owner, declarations);\n        new DeclarationResolver(context).process();\n        new DelegationResolver(context).process();\n        new OverrideResolver(context).process();\n        new BodyResolver(context).resolveBehaviorDeclarationBodies();\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void collectNamespacesAndClassifiers(\n            @NotNull final JetScope outerScope,\n            @NotNull final NamespaceLike owner,\n            @NotNull Collection<JetDeclaration> declarations) {\n        for (JetDeclaration declaration : declarations) {\n            declaration.accept(new JetVisitorVoid() {\n                @Override\n                public void visitNamespace(JetNamespace namespace) {\n                    String name = JetPsiUtil.safeName(namespace.getName());\n\n                    NamespaceDescriptorImpl namespaceDescriptor = owner.getNamespace(name);\n                    if (namespaceDescriptor == null) {\n                        namespaceDescriptor = new NamespaceDescriptorImpl(\n                                owner.getOriginal(),\n                                Collections.<AnnotationDescriptor>emptyList(), // TODO: annotations\n                                name\n                        );\n                        namespaceDescriptor.initialize(new WritableScopeImpl(JetScope.EMPTY, namespaceDescriptor, new TraceBasedRedeclarationHandler(context.getTrace())).setDebugName(\"Namespace member scope\"));\n                        owner.addNamespace(namespaceDescriptor);\n                        context.getTrace().record(BindingContext.NAMESPACE, namespace, namespaceDescriptor);\n                    }\n                    context.getNamespaceDescriptors().put(namespace, namespaceDescriptor);\n\n                    WriteThroughScope namespaceScope = new WriteThroughScope(outerScope, namespaceDescriptor.getMemberScope(), new TraceBasedRedeclarationHandler(context.getTrace()));\n                    context.getNamespaceScopes().put(namespace, namespaceScope);\n\n                    processImports(namespace, namespaceScope, outerScope);\n\n                    collectNamespacesAndClassifiers(namespaceScope, namespaceDescriptor, namespace.getDeclarations());\n                }\n\n                @Override\n                public void visitClass(JetClass klass) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, getClassKind(klass));\n\n                    if (klass.hasModifier(JetTokens.ENUM_KEYWORD)) {\n                        MutableClassDescriptor classObjectDescriptor = new MutableClassDescriptor(context.getTrace(), mutableClassDescriptor, outerScope, ClassKind.OBJECT);\n                        classObjectDescriptor.setName(\"class-object-for-\" + klass.getName());\n                        classObjectDescriptor.setModality(Modality.FINAL);\n                        classObjectDescriptor.setVisibility(ClassDescriptorResolver.resolveVisibilityFromModifiers(context.getTrace(), klass.getModifierList()));\n                        classObjectDescriptor.createTypeConstructor();\n                        createPrimaryConstructorForObject(null, classObjectDescriptor);\n                        mutableClassDescriptor.setClassObjectDescriptor(classObjectDescriptor);\n                    }\n                    visitClassOrObject(\n                            klass,\n                            (Map) context.getClasses(),\n                            owner,\n                            outerScope,\n                            mutableClassDescriptor);\n                    owner.addClassifierDescriptor(mutableClassDescriptor);\n                }\n\n                @Override\n                public void visitObjectDeclaration(JetObjectDeclaration declaration) {\n                    createClassDescriptorForObject(declaration, owner);\n                }\n\n                @Override\n                public void visitEnumEntry(JetEnumEntry enumEntry) {\n                    MutableClassDescriptor classObjectDescriptor = ((MutableClassDescriptor) owner).getClassObjectDescriptor();\n                    assert classObjectDescriptor != null : enumEntry.getParent().getText();\n                    if (enumEntry.getPrimaryConstructorParameterList() == null) {\n                        MutableClassDescriptor classDescriptor = createClassDescriptorForObject(enumEntry, classObjectDescriptor);\n                        context.getObjects().remove(enumEntry);\n                        context.getClasses().put(enumEntry, classDescriptor);\n                    }\n                    else {\n                        MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), classObjectDescriptor, outerScope, ClassKind.CLASS); // TODO : Special kind for enum entry classes?\n                        visitClassOrObject(\n                                enumEntry,\n                                (Map) context.getClasses(),\n                                classObjectDescriptor,\n                                outerScope,\n                                mutableClassDescriptor);\n                        classObjectDescriptor.addClassifierDescriptor(mutableClassDescriptor);\n                    }\n                }\n\n                private MutableClassDescriptor createClassDescriptorForObject(@NotNull JetClassOrObject declaration, @NotNull NamespaceLike owner) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, ClassKind.OBJECT) {\n                        @Override\n                        public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptor classObjectDescriptor) {\n                            return ClassObjectStatus.NOT_ALLOWED;\n                        }\n                    };\n                    visitClassOrObject(declaration, (Map) context.getObjects(), owner, outerScope, mutableClassDescriptor);\n                    createPrimaryConstructorForObject((JetDeclaration) declaration, mutableClassDescriptor);\n                    context.getTrace().record(BindingContext.CLASS, declaration, mutableClassDescriptor);\n                    return mutableClassDescriptor;\n                }\n\n                private void createPrimaryConstructorForObject(@Nullable JetDeclaration object, MutableClassDescriptor mutableClassDescriptor) {\n                    ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(mutableClassDescriptor, Collections.<AnnotationDescriptor>emptyList(), true);\n                    constructorDescriptor.initialize(Collections.<TypeParameterDescriptor>emptyList(), Collections.<ValueParameterDescriptor>emptyList(),\n                                                     Modality.FINAL, Visibility.INTERNAL);//TODO check set mutableClassDescriptor.getVisibility()\n                    // TODO : make the constructor private?\n                    mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor);\n                    if (object != null) {\n                        context.getTrace().record(CONSTRUCTOR, object, constructorDescriptor);\n                    }\n                }\n\n                private void visitClassOrObject(@NotNull JetClassOrObject declaration, Map<JetClassOrObject, MutableClassDescriptor> map, NamespaceLike owner, JetScope outerScope, MutableClassDescriptor mutableClassDescriptor) {\n                    mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));\n\n                    map.put(declaration, mutableClassDescriptor);\n//                    declaringScopes.put((JetDeclaration) declaration, outerScope);\n\n                    JetScope classScope = mutableClassDescriptor.getScopeForMemberResolution();\n                    collectNamespacesAndClassifiers(classScope, mutableClassDescriptor, declaration.getDeclarations());\n                }\n\n                @Override\n                public void visitTypedef(JetTypedef typedef) {\n//                    context.getTrace().getErrorHandler().genericError(typedef.getNode(), \"Unsupported [TopDownAnalyzer]\");\n                    context.getTrace().report(UNSUPPORTED.on(typedef, \"TypeHierarchyResolver\"));\n                }\n\n                @Override\n                public void visitClassObject(JetClassObject classObject) {\n                    JetObjectDeclaration objectDeclaration = classObject.getObjectDeclaration();\n                    if (objectDeclaration != null) {\n                        NamespaceLike.ClassObjectStatus status = owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration, owner));\n                        switch (status) {\n                            case DUPLICATE:\n//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), \"Only one class object is allowed per class\");\n                                context.getTrace().report(MANY_CLASS_OBJECTS.on(classObject));\n                                break;\n                            case NOT_ALLOWED:\n//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), \"A class object is not allowed here\");\n                                context.getTrace().report(CLASS_OBJECT_NOT_ALLOWED.on(classObject));\n                                break;\n                        }\n                    }\n                }\n            });\n        }\n    }","id":77596,"modified_method":"private void collectNamespacesAndClassifiers(\n            @NotNull final JetScope outerScope,\n            @NotNull final NamespaceLike owner,\n            @NotNull Collection<? extends JetDeclaration> declarations) {\n        for (JetDeclaration declaration : declarations) {\n            declaration.accept(new JetVisitorVoid() {\n                @Override\n                public void visitNamespace(JetNamespace namespace) {\n                    String name = JetPsiUtil.safeName(namespace.getName());\n\n                    NamespaceDescriptorImpl namespaceDescriptor = owner.getNamespace(name);\n                    if (namespaceDescriptor == null) {\n                        namespaceDescriptor = new NamespaceDescriptorImpl(\n                                owner.getOriginal(),\n                                Collections.<AnnotationDescriptor>emptyList(), // TODO: annotations\n                                name\n                        );\n                        namespaceDescriptor.initialize(new WritableScopeImpl(JetScope.EMPTY, namespaceDescriptor, new TraceBasedRedeclarationHandler(context.getTrace())).setDebugName(\"Namespace member scope\"));\n                        owner.addNamespace(namespaceDescriptor);\n                        context.getTrace().record(BindingContext.NAMESPACE, namespace, namespaceDescriptor);\n                    }\n                    context.getNamespaceDescriptors().put(namespace, namespaceDescriptor);\n\n                    WriteThroughScope namespaceScope = new WriteThroughScope(outerScope, namespaceDescriptor.getMemberScope(), new TraceBasedRedeclarationHandler(context.getTrace()));\n                    context.getNamespaceScopes().put(namespace, namespaceScope);\n\n                    processImports(namespace, namespaceScope, outerScope);\n\n                    collectNamespacesAndClassifiers(namespaceScope, namespaceDescriptor, namespace.getDeclarations());\n                }\n\n                @Override\n                public void visitClass(JetClass klass) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, getClassKind(klass));\n\n                    if (klass.hasModifier(JetTokens.ENUM_KEYWORD)) {\n                        MutableClassDescriptor classObjectDescriptor = new MutableClassDescriptor(context.getTrace(), mutableClassDescriptor, outerScope, ClassKind.OBJECT);\n                        classObjectDescriptor.setName(\"class-object-for-\" + klass.getName());\n                        classObjectDescriptor.setModality(Modality.FINAL);\n                        classObjectDescriptor.setVisibility(ClassDescriptorResolver.resolveVisibilityFromModifiers(context.getTrace(), klass.getModifierList()));\n                        classObjectDescriptor.createTypeConstructor();\n                        createPrimaryConstructorForObject(null, classObjectDescriptor);\n                        mutableClassDescriptor.setClassObjectDescriptor(classObjectDescriptor);\n                    }\n                    visitClassOrObject(\n                            klass,\n                            (Map) context.getClasses(),\n                            owner,\n                            outerScope,\n                            mutableClassDescriptor);\n                    owner.addClassifierDescriptor(mutableClassDescriptor);\n                }\n\n                @Override\n                public void visitObjectDeclaration(JetObjectDeclaration declaration) {\n                    createClassDescriptorForObject(declaration, owner);\n                }\n\n                @Override\n                public void visitEnumEntry(JetEnumEntry enumEntry) {\n                    MutableClassDescriptor classObjectDescriptor = ((MutableClassDescriptor) owner).getClassObjectDescriptor();\n                    assert classObjectDescriptor != null : enumEntry.getParent().getText();\n                    if (enumEntry.getPrimaryConstructorParameterList() == null) {\n                        MutableClassDescriptor classDescriptor = createClassDescriptorForObject(enumEntry, classObjectDescriptor);\n                        context.getObjects().remove(enumEntry);\n                        context.getClasses().put(enumEntry, classDescriptor);\n                    }\n                    else {\n                        MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), classObjectDescriptor, outerScope, ClassKind.CLASS); // TODO : Special kind for enum entry classes?\n                        visitClassOrObject(\n                                enumEntry,\n                                (Map) context.getClasses(),\n                                classObjectDescriptor,\n                                outerScope,\n                                mutableClassDescriptor);\n                        classObjectDescriptor.addClassifierDescriptor(mutableClassDescriptor);\n                    }\n                }\n\n                private MutableClassDescriptor createClassDescriptorForObject(@NotNull JetClassOrObject declaration, @NotNull NamespaceLike owner) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, ClassKind.OBJECT) {\n                        @Override\n                        public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptor classObjectDescriptor) {\n                            return ClassObjectStatus.NOT_ALLOWED;\n                        }\n                    };\n                    visitClassOrObject(declaration, (Map) context.getObjects(), owner, outerScope, mutableClassDescriptor);\n                    createPrimaryConstructorForObject((JetDeclaration) declaration, mutableClassDescriptor);\n                    context.getTrace().record(BindingContext.CLASS, declaration, mutableClassDescriptor);\n                    return mutableClassDescriptor;\n                }\n\n                private void createPrimaryConstructorForObject(@Nullable JetDeclaration object, MutableClassDescriptor mutableClassDescriptor) {\n                    ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(mutableClassDescriptor, Collections.<AnnotationDescriptor>emptyList(), true);\n                    constructorDescriptor.initialize(Collections.<TypeParameterDescriptor>emptyList(), Collections.<ValueParameterDescriptor>emptyList(),\n                                                     Modality.FINAL, Visibility.INTERNAL);//TODO check set mutableClassDescriptor.getVisibility()\n                    // TODO : make the constructor private?\n                    mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor);\n                    if (object != null) {\n                        context.getTrace().record(CONSTRUCTOR, object, constructorDescriptor);\n                    }\n                }\n\n                private void visitClassOrObject(@NotNull JetClassOrObject declaration, Map<JetClassOrObject, MutableClassDescriptor> map, NamespaceLike owner, JetScope outerScope, MutableClassDescriptor mutableClassDescriptor) {\n                    mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));\n\n                    map.put(declaration, mutableClassDescriptor);\n//                    declaringScopes.put((JetDeclaration) declaration, outerScope);\n\n                    JetScope classScope = mutableClassDescriptor.getScopeForMemberResolution();\n                    collectNamespacesAndClassifiers(classScope, mutableClassDescriptor, declaration.getDeclarations());\n                }\n\n                @Override\n                public void visitTypedef(JetTypedef typedef) {\n//                    context.getTrace().getErrorHandler().genericError(typedef.getNode(), \"Unsupported [TopDownAnalyzer]\");\n                    context.getTrace().report(UNSUPPORTED.on(typedef, \"TypeHierarchyResolver\"));\n                }\n\n                @Override\n                public void visitClassObject(JetClassObject classObject) {\n                    JetObjectDeclaration objectDeclaration = classObject.getObjectDeclaration();\n                    if (objectDeclaration != null) {\n                        NamespaceLike.ClassObjectStatus status = owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration, owner));\n                        switch (status) {\n                            case DUPLICATE:\n//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), \"Only one class object is allowed per class\");\n                                context.getTrace().report(MANY_CLASS_OBJECTS.on(classObject));\n                                break;\n                            case NOT_ALLOWED:\n//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), \"A class object is not allowed here\");\n                                context.getTrace().report(CLASS_OBJECT_NOT_ALLOWED.on(classObject));\n                                break;\n                        }\n                    }\n                }\n            });\n        }\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void process(@NotNull JetScope outerScope, NamespaceLike owner, @NotNull List<JetDeclaration> declarations) {\n        collectNamespacesAndClassifiers(outerScope, owner, declarations); // namespaceScopes, classes\n\n        createTypeConstructors(); // create type constructors for classes and generic parameters, supertypes are not filled in\n        resolveTypesInClassHeaders(); // Generic bounds and types in supertype lists (no expressions or constructor resolution)\n\n        topologicalOrder = topologicallySortClassesAndObjects();\n\n        // Detect and disconnect all loops in the hierarchy\n        detectAndDisconnectLoops();\n\n        // At this point, there are no loops in the type hierarchy\n\n        checkSupertypesForConsistency();\n//        computeSuperclasses();\n\n        // Add supertypes to resolution scopes of classes\n        addSupertypesToScopes();\n\n        checkTypesInClassHeaders(); // Check bounds in the types used in generic bounds and supertype lists\n    }","id":77597,"modified_method":"public void process(@NotNull JetScope outerScope, NamespaceLike owner, @NotNull List<? extends JetDeclaration> declarations) {\n        collectNamespacesAndClassifiers(outerScope, owner, declarations); // namespaceScopes, classes\n\n        createTypeConstructors(); // create type constructors for classes and generic parameters, supertypes are not filled in\n        resolveTypesInClassHeaders(); // Generic bounds and types in supertype lists (no expressions or constructor resolution)\n\n        topologicalOrder = topologicallySortClassesAndObjects();\n\n        // Detect and disconnect all loops in the hierarchy\n        detectAndDisconnectLoops();\n\n        // At this point, there are no loops in the type hierarchy\n\n        checkSupertypesForConsistency();\n//        computeSuperclasses();\n\n        // Add supertypes to resolution scopes of classes\n        addSupertypesToScopes();\n\n        checkTypesInClassHeaders(); // Check bounds in the types used in generic bounds and supertype lists\n    }","commit_id":"2317464a49bd374f8e00d61b678f7268a1b6f6a3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public PyClassStub createStub(final PyClass psi, final StubElement parentStub) {\n    final PyExpression[] exprs = psi.getSuperClassExpressions();\n    String[] superClasses = new String[exprs.length];\n    for(int i=0; i<exprs.length; i++) {\n      final PyExpression expression = exprs[i];\n      if (expression instanceof PyReferenceExpression) {\n        superClasses [i] = ((PyReferenceExpression) expression).getReferencedName();\n      }\n      else {\n        superClasses [i] = expression.getText();\n      }\n    }\n    return new PyClassStubImpl(psi.getName(), parentStub, superClasses);\n  }","id":77598,"modified_method":"public PyClassStub createStub(final PyClass psi, final StubElement parentStub) {\n    final PyExpression[] exprs = psi.getSuperClassExpressions();\n    List<String> superClasses = new ArrayList<String>();\n    for (final PyExpression expression : exprs) {\n      if (expression instanceof PyReferenceExpression) {\n        final String referencedName = ((PyReferenceExpression)expression).getReferencedName();\n        if (referencedName != null) {\n          superClasses.add(referencedName);\n        }\n      }\n    }\n    return new PyClassStubImpl(psi.getName(), parentStub, superClasses.toArray(new String[superClasses.size()]));\n  }","commit_id":"6c884986e19d5404a264fd4230b62c0c638fedad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addDynPropertyIfNeeds(Annotation annotation, GrReferenceExpression refExpr) {\n    String dynamicValueTypeDefinitionText;\n\n    final Project project = refExpr.getProject();\n    final DynamicPropertiesManager dynamicPropertiesManager = DynamicPropertiesManager.getInstance(project);\n    Module module = ProjectRootManager.getInstance(project).getFileIndex().getModuleForFile(refExpr.getContainingFile().getVirtualFile());\n\n    if (refExpr.isQualified()) {\n      dynamicValueTypeDefinitionText = refExpr.getQualifierExpression().getType().getCanonicalText();\n\n    } else {\n      PsiElement refParent = refExpr.getParent();\n\n      while (refParent != null && !(refParent instanceof GroovyFileBase)) {\n        refParent = refParent.getParent();\n      }\n\n      if (refParent == null) return;\n      dynamicValueTypeDefinitionText = ((GroovyFileBase) refParent).getScriptClass().getQualifiedName();\n    }\n\n    DynamicProperty dynamicProperty = new DynamicPropertyBase(refExpr.getName(), dynamicValueTypeDefinitionText, module.getName());\n    final Element dynPropElement = dynamicPropertiesManager.findDynamicProperty(dynamicProperty);\n\n    if (dynPropElement == null) {\n      annotation.registerFix(new DynamicPropertyIntention(dynamicProperty));\n    }\n  }","id":77599,"modified_method":"private void addDynPropertyIfNeeds(Annotation annotation, GrReferenceExpression refExpr) {\n    String dynamicValueTypeDefinitionText = null;\n\n    final Project project = refExpr.getProject();\n    final DynamicPropertiesManager dynamicPropertiesManager = DynamicPropertiesManager.getInstance(project);\n    Module module = ProjectRootManager.getInstance(project).getFileIndex().getModuleForFile(refExpr.getContainingFile().getVirtualFile());\n\n    // todo [dimaskin] module may be null, for library sources\n    if (module != null) {\n      if (refExpr.isQualified()) {\n        GrExpression qualifier = refExpr.getQualifierExpression();\n        PsiType type = qualifier.getType();\n        if (type != null) {\n          dynamicValueTypeDefinitionText = type.getCanonicalText();\n        }\n      } else {\n        PsiElement refParent = refExpr.getParent();\n\n        while (refParent != null && !(refParent instanceof GroovyFileBase)) {\n          refParent = refParent.getParent();\n        }\n\n        if (refParent == null) return;\n        PsiClass scriptClass = ((GroovyFileBase) refParent).getScriptClass();\n        if (scriptClass != null) {\n          dynamicValueTypeDefinitionText = scriptClass.getQualifiedName();\n        }\n      }\n\n      // todo [dimaskin], altered to prevent NPE, please, be careful\n      dynamicValueTypeDefinitionText = dynamicValueTypeDefinitionText != null ? dynamicValueTypeDefinitionText : \"\";\n      DynamicProperty dynamicProperty = new DynamicPropertyBase(refExpr.getName(), dynamicValueTypeDefinitionText, module.getName());\n      final Element dynPropElement = dynamicPropertiesManager.findDynamicProperty(dynamicProperty);\n\n      if (dynPropElement == null) {\n        annotation.registerFix(new DynamicPropertyIntention(dynamicProperty));\n      }\n    }\n  }","commit_id":"8d8b558dfe89d3071f71f31442741cec10bcd28a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n      if (referenceExpression.getQualifierExpression() != null) {\n        super.visitReferenceExpression(referenceExpression);\n      }\n      else {\n        GroovyResolveResult result = referenceExpression.advancedResolve();\n        PsiElement element = result.getElement();\n        if (isPrintOrPrintln(element)) return; //print & println are resolved in all places\n\n        GroovyPsiElement resolveContext = result.getCurrentFileResolveContext();\n        if (resolveContext != null) return;\n        if (element instanceof PsiClass && ((PsiClass)element).getContainingClass() == null) return;\n        if (element instanceof PsiMember && !((PsiMember)element).hasModifierProperty(PsiModifier.STATIC)) {\n          myMay = false;\n        }\n      }\n    }","id":77600,"modified_method":"@Override\n    public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n      GrExpression qualifier = referenceExpression.getQualifierExpression();\n      if (qualifier == null || qualifier instanceof GrThisSuperReferenceExpression) {\n        GroovyResolveResult result = referenceExpression.advancedResolve();\n        PsiElement element = result.getElement();\n        if (isPrintOrPrintln(element)) return; //print & println are resolved in all places\n\n        GroovyPsiElement resolveContext = result.getCurrentFileResolveContext();\n        if (qualifier == null && resolveContext != null) return;\n        if (element instanceof PsiClass && ((PsiClass)element).getContainingClass() == null) return;\n        if (element instanceof PsiMember && !((PsiMember)element).hasModifierProperty(PsiModifier.STATIC)) {\n          myMay = false;\n        }\n      }\n      else {\n        super.visitReferenceExpression(referenceExpression);\n      }\n    }","commit_id":"4e90d0e35b449ef9b88c9f9a432b93d0d684e717","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiType getType() {\n    GrTypeElement typeElement = getTypeElementGroovy();\n    if (typeElement!= null) return typeElement.getType();\n    PsiElement parent = getParent();\n    if (parent instanceof GrForInClause) {\n      GrExpression iteratedExpression = ((GrForInClause) parent).getIteratedExpression();\n      if (iteratedExpression instanceof GrRangeExpression) {\n        return getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Integer\", getResolveScope());\n      } else {\n        PsiType iterType = iteratedExpression.getType();\n        if (iterType instanceof PsiArrayType) return ((PsiArrayType) iterType).getComponentType();\n        if (iterType instanceof PsiClassType) {\n          PsiClassType.ClassResolveResult result = ((PsiClassType) iterType).resolveGenerics();\n          PsiClass clazz = result.getElement();\n          if (clazz != null) {\n            PsiManagerEx manager = getManager();\n            PsiClass collectionClass = manager.findClass(\"java.util.Collection\", getResolveScope());\n            if (collectionClass != null && collectionClass.getTypeParameters().length == 1) {\n              PsiSubstitutor substitutor = TypeConversionUtil.getClassSubstitutor(collectionClass, clazz, result.getSubstitutor());\n              if (substitutor != null) {\n                PsiType substed = substitutor.substitute(collectionClass.getTypeParameters()[0]);\n                if (substed != null) {\n                  return substed;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Object\", getResolveScope());\n  }","id":77601,"modified_method":"@Nullable\n  public PsiType getTypeGroovy() {\n    GrTypeElement typeElement = getTypeElementGroovy();\n    if (typeElement != null) return typeElement.getType();\n    PsiElement parent = getParent();\n    if (parent instanceof GrForInClause) {\n      GrExpression iteratedExpression = ((GrForInClause) parent).getIteratedExpression();\n      if (iteratedExpression instanceof GrRangeExpression) {\n        return getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Integer\", getResolveScope());\n      } else {\n        PsiType iterType = iteratedExpression.getType();\n        if (iterType instanceof PsiArrayType) return ((PsiArrayType) iterType).getComponentType();\n        if (iterType instanceof PsiClassType) {\n          PsiClassType.ClassResolveResult result = ((PsiClassType) iterType).resolveGenerics();\n          PsiClass clazz = result.getElement();\n          if (clazz != null) {\n            PsiManagerEx manager = getManager();\n            PsiClass collectionClass = manager.findClass(\"java.util.Collection\", getResolveScope());\n            if (collectionClass != null && collectionClass.getTypeParameters().length == 1) {\n              PsiSubstitutor substitutor = TypeConversionUtil.getClassSubstitutor(collectionClass, clazz, result.getSubstitutor());\n              if (substitutor != null) {\n                PsiType substed = substitutor.substitute(collectionClass.getTypeParameters()[0]);\n                if (substed != null) {\n                  return substed;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"b886a146831b14e89c9ddacdc4334f03de3be22f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType fun(GrReferenceExpressionImpl refExpr) {\n      IElementType dotType = refExpr.getDotTokenType();\n      PsiElement resolved = refExpr.resolve();\n      PsiType result = null;\n      PsiManager manager = refExpr.getManager();\n      if (resolved instanceof PsiClass) {\n        result = manager.getElementFactory().createType((PsiClass) resolved);\n      } else if (resolved instanceof PsiVariable) {\n        result = ((PsiVariable) resolved).getType();\n      } else if (resolved instanceof PsiMethod) {\n        if (dotType == GroovyTokenTypes.mMEMBER_POINTER) {\n          return manager.getElementFactory().createTypeByFQClassName(\"groovy.lang.Closure\", refExpr.getResolveScope());\n        }\n        PsiMethod method = (PsiMethod) resolved;\n        if (PropertyUtil.isSimplePropertySetter(method)) {\n          result = method.getParameterList().getParameters()[0].getType();\n        } else {\n          result = method.getReturnType();\n        }\n      } else if (resolved instanceof GrReferenceExpression) {\n        PsiElement parent = resolved.getParent();\n        if (parent instanceof GrAssignmentExpression) {\n          GrAssignmentExpression assignment = (GrAssignmentExpression) parent;\n          if (resolved.equals(assignment.getLValue())) {\n            GrExpression rValue = assignment.getRValue();\n            if (rValue != null) {\n              PsiType rType = rValue.getType();\n              if (rType != null) result = rType;\n            }\n          }\n        }\n      }\n\n      result = TypesUtil.boxPrimitiveType(result, manager, refExpr.getResolveScope());\n      if (dotType != GroovyTokenTypes.mSPREAD_DOT) {\n        return result;\n      } else {\n        return ResolveUtil.getListTypeForSpreadOperator(refExpr, result);\n      }\n    }","id":77602,"modified_method":"public PsiType fun(GrReferenceExpressionImpl refExpr) {\n      IElementType dotType = refExpr.getDotTokenType();\n      PsiElement resolved = refExpr.resolve();\n      PsiType result = null;\n      PsiManager manager = refExpr.getManager();\n      if (resolved instanceof PsiClass) {\n        result = manager.getElementFactory().createType((PsiClass) resolved);\n      } else if (resolved instanceof GrVariable) {\n        result = ((GrVariable) resolved).getTypeGroovy();\n      } else if (resolved instanceof PsiVariable) {\n        result = ((PsiVariable) resolved).getType();\n      } else if (resolved instanceof PsiMethod) {\n        if (dotType == GroovyTokenTypes.mMEMBER_POINTER) {\n          return manager.getElementFactory().createTypeByFQClassName(\"groovy.lang.Closure\", refExpr.getResolveScope());\n        }\n        PsiMethod method = (PsiMethod) resolved;\n        if (PropertyUtil.isSimplePropertySetter(method)) {\n          result = method.getParameterList().getParameters()[0].getType();\n        } else {\n          result = method.getReturnType();\n        }\n      } else if (resolved instanceof GrReferenceExpression) {\n        PsiElement parent = resolved.getParent();\n        if (parent instanceof GrAssignmentExpression) {\n          GrAssignmentExpression assignment = (GrAssignmentExpression) parent;\n          if (resolved.equals(assignment.getLValue())) {\n            GrExpression rValue = assignment.getRValue();\n            if (rValue != null) {\n              PsiType rType = rValue.getType();\n              if (rType != null) result = rType;\n            }\n          }\n        }\n      }\n\n      result = TypesUtil.boxPrimitiveType(result, manager, refExpr.getResolveScope());\n      if (dotType != GroovyTokenTypes.mSPREAD_DOT) {\n        return result;\n      } else {\n        return ResolveUtil.getListTypeForSpreadOperator(refExpr, result);\n      }\n    }","commit_id":"b886a146831b14e89c9ddacdc4334f03de3be22f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiType getType() {\n    GrTypeElement typeElement = ((GrVariableDeclaration) getParent()).getTypeElementGroovy();\n    if (typeElement != null) return typeElement.getType();\n\n    GrExpression initializer = getInitializerGroovy();\n    if (initializer != null) {\n      if (!(initializer instanceof GrReferenceExpression) || !initializer.getText().equals(getName())) { //prevent infinite recursion\n        PsiType initializerType = initializer.getType();\n        if (initializerType != null) return initializerType;\n      }\n    }\n\n    return getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Object\", getResolveScope());\n  }","id":77603,"modified_method":"@NotNull\n  public PsiType getType() {\n    PsiType type = getTypeGroovy();\n    return type != null ? type : getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Object\", getResolveScope());\n  }","commit_id":"b886a146831b14e89c9ddacdc4334f03de3be22f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    PsiElement element = resolveResult.getElement();\n    if (element != null) {\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (element instanceof PsiMethod && element.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        PsiType[] argumentTypes = PsiUtil.getArgumentTypes(refExpr);\n        if (argumentTypes != null && !PsiUtil.isApplicable(argumentTypes, (PsiMethod)element)) {\n          GroovyPsiElement elementToHighlight = PsiUtil.getArgumentsElement(refExpr);\n          LOG.assertTrue(elementToHighlight != null);\n          //todo more specific error message\n          String message = GroovyBundle.message(\"cannot.apply.method\", refExpr.getReferenceName());\n          holder.createWarningAnnotation(elementToHighlight, message);\n        }\n      }\n    } else {\n      if (isAssignmentLHS(refExpr)) return;\n\n      if (refExpr.getQualifierExpression() == null) {\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n        } else {\n          if (refExpr.getParent() instanceof GrReferenceExpression) {\n            Annotation annotation = holder.createWarningAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n            registerAddImportFixes(refExpr, annotation);\n          }\n        }\n      }\n    }\n  }","id":77604,"modified_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    PsiElement element = resolveResult.getElement();\n    if (element != null) {\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (element instanceof PsiMethod && element.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        PsiType[] argumentTypes = PsiUtil.getArgumentTypes(refExpr);\n        if (argumentTypes != null && !PsiUtil.isApplicable(argumentTypes, (PsiMethod)element)) {\n          GroovyPsiElement elementToHighlight = PsiUtil.getArgumentsElement(refExpr);\n          LOG.assertTrue(elementToHighlight != null);\n          //todo more specific error message\n          String message = GroovyBundle.message(\"cannot.apply.method\", refExpr.getReferenceName());\n          holder.createWarningAnnotation(elementToHighlight, message);\n        }\n      }\n      if (isAssignmentLHS(refExpr) || element instanceof PsiPackage) return;\n    } else {\n      if (isAssignmentLHS(refExpr)) return;\n\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n        } else {\n          if (refExpr.getParent() instanceof GrReferenceExpression) {\n            Annotation annotation = holder.createWarningAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n            registerAddImportFixes(refExpr, annotation);\n          }\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      Annotation annotation = holder.createInformationAnnotation(refExpr.getReferenceNameElement(),\n          GroovyBundle.message(\"untyped.access\", refExpr.getReferenceName()));\n\n      annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.MAGENTA, EffectType.LINE_UNDERSCORE, 0));\n    }\n  }","commit_id":"b886a146831b14e89c9ddacdc4334f03de3be22f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String generateOptionalUnwrap(String stream, @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n                                               PsiExpression trueExpression, PsiExpression falseExpression, PsiType targetType) {\n    PsiVariable var = tb.getVariable();\n    if (!StreamApiMigrationInspection.isIdentityMapping(var, trueExpression)) {\n      if(trueExpression instanceof PsiTypeCastExpression && ExpressionUtils.isNullLiteral(falseExpression)) {\n        PsiTypeCastExpression castExpression = (PsiTypeCastExpression)trueExpression;\n        PsiTypeElement castType = castExpression.getCastType();\n        // pull cast outside to avoid the .map() step\n        if(castType != null && StreamApiMigrationInspection.isIdentityMapping(var, castExpression.getOperand())) {\n          return \"(\" + castType.getText() + \")\" + stream + \".orElse(null)\";\n        }\n      }\n      if(ExpressionUtils.isLiteral(falseExpression, Boolean.FALSE) && PsiType.BOOLEAN.equals(trueExpression.getType())) {\n        return stream + \".filter(\" + LambdaUtil.createLambda(var, trueExpression) + \").isPresent()\";\n      }\n      if(trueExpression instanceof PsiConditionalExpression) {\n        PsiConditionalExpression condition = (PsiConditionalExpression)trueExpression;\n        if(EquivalenceChecker.getCanonicalPsiEquivalence().expressionsAreEquivalent(falseExpression, condition.getElseExpression())) {\n          return generateOptionalUnwrap(\n            stream + \".filter(\" + LambdaUtil.createLambda(var, condition.getCondition()) + \")\", tb,\n            condition.getThenExpression(), falseExpression, targetType);\n        }\n      }\n      trueExpression =\n        targetType == null ? trueExpression : RefactoringUtil.convertInitializerToNormalExpression(trueExpression, targetType);\n      stream += \".map(\" + LambdaUtil.createLambda(var, trueExpression) + \")\";\n    }\n    stream += \".orElse(\" + falseExpression.getText() + \")\";\n    return stream;\n  }","id":77605,"modified_method":"private static String generateOptionalUnwrap(String stream, @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n                                               PsiExpression trueExpression, PsiExpression falseExpression, PsiType targetType) {\n    PsiVariable var = tb.getVariable();\n    if (!StreamApiMigrationInspection.isIdentityMapping(var, trueExpression)) {\n      if(trueExpression instanceof PsiTypeCastExpression && ExpressionUtils.isNullLiteral(falseExpression)) {\n        PsiTypeCastExpression castExpression = (PsiTypeCastExpression)trueExpression;\n        PsiTypeElement castType = castExpression.getCastType();\n        // pull cast outside to avoid the .map() step\n        if(castType != null && StreamApiMigrationInspection.isIdentityMapping(var, castExpression.getOperand())) {\n          return \"(\" + castType.getText() + \")\" + stream + \".orElse(null)\";\n        }\n      }\n      if(ExpressionUtils.isLiteral(falseExpression, Boolean.FALSE) && PsiType.BOOLEAN.equals(trueExpression.getType())) {\n        return stream + \".filter(\" + LambdaUtil.createLambda(var, trueExpression) + \").isPresent()\";\n      }\n      if(trueExpression instanceof PsiConditionalExpression) {\n        PsiConditionalExpression condition = (PsiConditionalExpression)trueExpression;\n        PsiExpression elseExpression = condition.getElseExpression();\n        if(elseExpression != null && PsiEquivalenceUtil.areElementsEquivalent(falseExpression, elseExpression)) {\n          return generateOptionalUnwrap(\n            stream + \".filter(\" + LambdaUtil.createLambda(var, condition.getCondition()) + \")\", tb,\n            condition.getThenExpression(), falseExpression, targetType);\n        }\n      }\n      trueExpression =\n        targetType == null ? trueExpression : RefactoringUtil.convertInitializerToNormalExpression(trueExpression, targetType);\n      stream += \".map(\" + LambdaUtil.createLambda(var, trueExpression) + \")\";\n    }\n    stream += \".orElse(\" + falseExpression.getText() + \")\";\n    return stream;\n  }","commit_id":"bb9b1ee7701254605bca91e5dd5f051062df4854","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  static PsiMethodCallExpression extractToArrayExpression(PsiForeachStatement statement, PsiMethodCallExpression expression) {\n    // return collection.toArray() or collection.toArray(new Type[0]) or collection.toArray(new Type[collection.size()]);\n    PsiElement nextElement = PsiTreeUtil.skipSiblingsForward(statement, PsiComment.class, PsiWhiteSpace.class);\n    PsiExpression toArrayCandidate;\n    if (nextElement instanceof PsiReturnStatement) {\n      toArrayCandidate = ((PsiReturnStatement)nextElement).getReturnValue();\n    }\n    else {\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(nextElement);\n      if (assignment != null) {\n        toArrayCandidate = assignment.getRExpression();\n      }\n      else if (nextElement instanceof PsiDeclarationStatement) {\n        PsiElement[] elements = ((PsiDeclarationStatement)nextElement).getDeclaredElements();\n        if (elements.length == 1 && elements[0] instanceof PsiLocalVariable) {\n          toArrayCandidate = ((PsiLocalVariable)elements[0]).getInitializer();\n        }\n        else {\n          return null;\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    if (!(toArrayCandidate instanceof PsiMethodCallExpression)) return null;\n    PsiMethodCallExpression call = (PsiMethodCallExpression)toArrayCandidate;\n    PsiReferenceExpression methodExpression = call.getMethodExpression();\n    if (!\"toArray\".equals(methodExpression.getReferenceName())) return null;\n    PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n    if (!(qualifierExpression instanceof PsiReferenceExpression)) return null;\n    PsiLocalVariable collectionVariable = extractCollectionVariable(expression.getMethodExpression().getQualifierExpression());\n    if (collectionVariable == null || ((PsiReferenceExpression)qualifierExpression).resolve() != collectionVariable) return null;\n    PsiExpression initializer = collectionVariable.getInitializer();\n    if (initializer == null) return null;\n    PsiType type = initializer.getType();\n    if (!(type instanceof PsiClassType) || !COLLECTION_TO_ARRAY.containsKey(((PsiClassType)type).rawType().getCanonicalText())) {\n      return null;\n    }\n\n    if (!(nextElement instanceof PsiReturnStatement) && !ReferencesSearch.search(collectionVariable, collectionVariable.getUseScope())\n      .forEach(ref ->\n                 ref.getElement() == collectionVariable || PsiTreeUtil.isAncestor(statement, ref.getElement(), false) ||\n                 PsiTreeUtil.isAncestor(toArrayCandidate, ref.getElement(), false)\n      )) {\n      return null;\n    }\n\n    PsiExpression[] args = call.getArgumentList().getExpressions();\n    if (args.length == 0) return call;\n    if (args.length != 1 || !(args[0] instanceof PsiNewExpression)) return null;\n    PsiNewExpression newArray = (PsiNewExpression)args[0];\n    PsiExpression[] dimensions = newArray.getArrayDimensions();\n    if (dimensions.length != 1) return null;\n    if (ExpressionUtils.isLiteral(dimensions[0], 0)) return call;\n    if (!(dimensions[0] instanceof PsiMethodCallExpression)) return null;\n    PsiMethodCallExpression maybeSizeCall = (PsiMethodCallExpression)dimensions[0];\n    if (maybeSizeCall.getArgumentList().getExpressions().length != 0) return null;\n    PsiReferenceExpression maybeSizeExpression = maybeSizeCall.getMethodExpression();\n    if (!\"size\".equals(maybeSizeExpression.getReferenceName()) || !EquivalenceChecker.getCanonicalPsiEquivalence()\n      .expressionsAreEquivalent(qualifierExpression, maybeSizeExpression.getQualifierExpression())) {\n      return null;\n    }\n    return call;\n  }","id":77606,"modified_method":"@Nullable\n  static PsiMethodCallExpression extractToArrayExpression(PsiForeachStatement statement, PsiMethodCallExpression expression) {\n    // return collection.toArray() or collection.toArray(new Type[0]) or collection.toArray(new Type[collection.size()]);\n    PsiElement nextElement = PsiTreeUtil.skipSiblingsForward(statement, PsiComment.class, PsiWhiteSpace.class);\n    PsiExpression toArrayCandidate;\n    if (nextElement instanceof PsiReturnStatement) {\n      toArrayCandidate = ((PsiReturnStatement)nextElement).getReturnValue();\n    }\n    else {\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(nextElement);\n      if (assignment != null) {\n        toArrayCandidate = assignment.getRExpression();\n      }\n      else if (nextElement instanceof PsiDeclarationStatement) {\n        PsiElement[] elements = ((PsiDeclarationStatement)nextElement).getDeclaredElements();\n        if (elements.length == 1 && elements[0] instanceof PsiLocalVariable) {\n          toArrayCandidate = ((PsiLocalVariable)elements[0]).getInitializer();\n        }\n        else {\n          return null;\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    if (!(toArrayCandidate instanceof PsiMethodCallExpression)) return null;\n    PsiMethodCallExpression call = (PsiMethodCallExpression)toArrayCandidate;\n    PsiReferenceExpression methodExpression = call.getMethodExpression();\n    if (!\"toArray\".equals(methodExpression.getReferenceName())) return null;\n    PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n    if (!(qualifierExpression instanceof PsiReferenceExpression)) return null;\n    PsiLocalVariable collectionVariable = extractCollectionVariable(expression.getMethodExpression().getQualifierExpression());\n    if (collectionVariable == null || ((PsiReferenceExpression)qualifierExpression).resolve() != collectionVariable) return null;\n    PsiExpression initializer = collectionVariable.getInitializer();\n    if (initializer == null) return null;\n    PsiType type = initializer.getType();\n    if (!(type instanceof PsiClassType) || !COLLECTION_TO_ARRAY.containsKey(((PsiClassType)type).rawType().getCanonicalText())) {\n      return null;\n    }\n\n    if (!(nextElement instanceof PsiReturnStatement) && !ReferencesSearch.search(collectionVariable, collectionVariable.getUseScope())\n      .forEach(ref ->\n                 ref.getElement() == collectionVariable || PsiTreeUtil.isAncestor(statement, ref.getElement(), false) ||\n                 PsiTreeUtil.isAncestor(toArrayCandidate, ref.getElement(), false)\n      )) {\n      return null;\n    }\n\n    PsiExpression[] args = call.getArgumentList().getExpressions();\n    if (args.length == 0) return call;\n    if (args.length != 1 || !(args[0] instanceof PsiNewExpression)) return null;\n    PsiNewExpression newArray = (PsiNewExpression)args[0];\n    PsiExpression[] dimensions = newArray.getArrayDimensions();\n    if (dimensions.length != 1) return null;\n    if (ExpressionUtils.isLiteral(dimensions[0], 0)) return call;\n    if (!(dimensions[0] instanceof PsiMethodCallExpression)) return null;\n    PsiMethodCallExpression maybeSizeCall = (PsiMethodCallExpression)dimensions[0];\n    if (maybeSizeCall.getArgumentList().getExpressions().length != 0) return null;\n    PsiReferenceExpression maybeSizeExpression = maybeSizeCall.getMethodExpression();\n    PsiExpression sizeQualifier = maybeSizeExpression.getQualifierExpression();\n    if (sizeQualifier != null &&\n        !(\"size\".equals(maybeSizeExpression.getReferenceName()) &&\n          PsiEquivalenceUtil.areElementsEquivalent(qualifierExpression, sizeQualifier))) {\n      return null;\n    }\n    return call;\n  }","commit_id":"bb9b1ee7701254605bca91e5dd5f051062df4854","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public T[] getExtensions() {\n    processAdapters();\n\n    T[] result = myExtensionsCache;\n    if (result == null) {\n      //noinspection unchecked\n      myExtensionsCache = result = myExtensions.toArray((T[])Array.newInstance(getExtensionClass(), myExtensions.size()));\n    }\n    for (int i = 1; i < result.length; i++) {\n      assert result[i] != result[i - 1] : \"Result: \"+ Arrays.asList(result)+\"; myExtensions: \"+myExtensions+\"; getExtensionClass()=\"+getExtensionClass()+\"; size=\"+myExtensions.size()+\";\"+result.length;\n    }\n    return result;\n  }","id":77607,"modified_method":"@NotNull\n  public T[] getExtensions() {\n    T[] result = myExtensionsArray;\n    if (result == null) {\n      synchronized (this) {\n        result = myExtensionsArray;\n        if (result == null) {\n          processAdapters();\n          myExtensionsArray = result = myExtensions.toArray((T[])Array.newInstance(getExtensionClass(), myExtensions.size()));\n        }\n      }\n    }\n    for (int i = 1; i < result.length; i++) {\n      assert result[i] != result[i - 1] : \"Result: \"+ Arrays.asList(result)+\"; myExtensions: \"+myExtensions+\"; getExtensionClass()=\"+getExtensionClass()+\"; size=\"+myExtensions.size()+\";\"+result.length;\n    }\n    return result;\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized void internalUnregisterExtension(T extension, PluginDescriptor pluginDescriptor) {\n    int index = getExtensionIndex(extension);\n    myExtensionsCache = null;\n    myExtensions.remove(index);\n\n    myLoadedAdapters.remove(index);\n\n    notifyListenersOnRemove(extension, pluginDescriptor);\n\n    if (extension instanceof Extension) {\n      Extension o = (Extension)extension;\n      try {\n        o.extensionRemoved(this);\n      }\n      catch (Throwable e) {\n        myLogger.error(e);\n      }\n    }\n  }","id":77608,"modified_method":"private void internalUnregisterExtension(T extension, PluginDescriptor pluginDescriptor) {\n    int index = getExtensionIndex(extension);\n    myExtensions.remove(index);\n\n    myLoadedAdapters.remove(index);\n\n    notifyListenersOnRemove(extension, pluginDescriptor);\n\n    if (extension instanceof Extension) {\n      Extension o = (Extension)extension;\n      try {\n        o.extensionRemoved(this);\n      }\n      catch (Throwable e) {\n        myLogger.error(e);\n      }\n    }\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void internalRegisterExtension(T extension, ExtensionComponentAdapter adapter, int index, boolean runNotifications) {\n    myExtensionsCache = null;\n\n    if (myExtensions.contains(extension)) {\n      myLogger.error(\"Extension was already added: \" + extension);\n    }\n    else {\n      myExtensions.add(index, extension);\n      myLoadedAdapters.add(index, adapter);\n      if (runNotifications) {\n        if (extension instanceof Extension) {\n          try {\n            ((Extension)extension).extensionAdded(this);\n          }\n          catch (Throwable e) {\n            myLogger.error(e);\n          }\n        }\n\n        notifyListenersOnAdd(extension, adapter.getPluginDescriptor());\n      }\n    }\n  }","id":77609,"modified_method":"private void internalRegisterExtension(T extension, ExtensionComponentAdapter adapter, int index, boolean runNotifications) {\n    if (myExtensions.contains(extension)) {\n      myLogger.error(\"Extension was already added: \" + extension);\n    }\n    else {\n      myExtensions.add(index, extension);\n      myLoadedAdapters.add(index, adapter);\n      if (runNotifications) {\n        if (extension instanceof Extension) {\n          try {\n            ((Extension)extension).extensionAdded(this);\n          }\n          catch (Throwable e) {\n            myLogger.error(e);\n          }\n        }\n\n        notifyListenersOnAdd(extension, adapter.getPluginDescriptor());\n      }\n    }\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addExtensionPointListener(@NotNull ExtensionPointListener<T> listener) {\n    processAdapters();\n\n    if (myEPListeners.add(listener)) {\n      for (ExtensionComponentAdapter componentAdapter : myLoadedAdapters) {\n        try {\n          //noinspection unchecked\n          listener.extensionAdded((T)componentAdapter.getExtension(), componentAdapter.getPluginDescriptor());\n        } catch (Throwable e) {\n          myLogger.error(e);\n        }\n      }\n    }\n  }","id":77610,"modified_method":"public void addExtensionPointListener(@NotNull ExtensionPointListener<T> listener) {\n    synchronized (this) {\n      processAdapters();\n    }\n    if (myEPListeners.add(listener)) {\n      for (ExtensionComponentAdapter componentAdapter : myLoadedAdapters) {\n        try {\n          //noinspection unchecked\n          listener.extensionAdded((T)componentAdapter.getExtension(), componentAdapter.getPluginDescriptor());\n        } catch (Throwable e) {\n          myLogger.error(e);\n        }\n      }\n    }\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void unregisterExtension(@NotNull final T extension) {\n    final int index = getExtensionIndex(extension);\n    final ExtensionComponentAdapter adapter = myLoadedAdapters.get(index);\n\n    myOwner.getMutablePicoContainer().unregisterComponent(adapter.getComponentKey());\n    final MutablePicoContainer[] pluginContainers = myOwner.getPluginContainers();\n    for (MutablePicoContainer pluginContainer : pluginContainers) {\n      pluginContainer.unregisterComponent(adapter.getComponentKey());\n    }\n\n    processAdapters();\n\n    internalUnregisterExtension(extension, null);\n  }","id":77611,"modified_method":"public synchronized void unregisterExtension(@NotNull final T extension) {\n    final int index = getExtensionIndex(extension);\n    final ExtensionComponentAdapter adapter = myLoadedAdapters.get(index);\n\n    myOwner.getMutablePicoContainer().unregisterComponent(adapter.getComponentKey());\n    final MutablePicoContainer[] pluginContainers = myOwner.getPluginContainers();\n    for (MutablePicoContainer pluginContainer : pluginContainers) {\n      pluginContainer.unregisterComponent(adapter.getComponentKey());\n    }\n    processAdapters();\n    internalUnregisterExtension(extension, null);\n    clearCache();\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean unregisterComponentAdapter(final ExtensionComponentAdapter componentAdapter) {\n    if (myExtensionAdapters.contains(componentAdapter)) {\n      myExtensionAdapters.remove(componentAdapter);\n      return true;\n    }\n    else if (myLoadedAdapters.contains(componentAdapter)) {\n      final Object componentKey = componentAdapter.getComponentKey();\n      myOwner.getMutablePicoContainer().unregisterComponent(componentKey);\n      final MutablePicoContainer[] pluginContainers = myOwner.getPluginContainers();\n      for (MutablePicoContainer pluginContainer : pluginContainers) {\n        pluginContainer.unregisterComponent(componentKey);\n      }\n\n      //noinspection unchecked\n      internalUnregisterExtension((T)componentAdapter.getExtension(), componentAdapter.getPluginDescriptor());\n      return true;\n    }\n    return false;\n  }","id":77612,"modified_method":"synchronized boolean unregisterComponentAdapter(final ExtensionComponentAdapter componentAdapter) {\n    try {\n      if (myExtensionAdapters.remove(componentAdapter)) {\n        return true;\n      }\n      if (myLoadedAdapters.contains(componentAdapter)) {\n        final Object componentKey = componentAdapter.getComponentKey();\n        myOwner.getMutablePicoContainer().unregisterComponent(componentKey);\n        final MutablePicoContainer[] pluginContainers = myOwner.getPluginContainers();\n        for (MutablePicoContainer pluginContainer : pluginContainers) {\n          pluginContainer.unregisterComponent(componentKey);\n        }\n\n        //noinspection unchecked\n        internalUnregisterExtension((T)componentAdapter.getExtension(), componentAdapter.getPluginDescriptor());\n        return true;\n      }\n      return false;\n    }\n    finally {\n      clearCache();\n    }\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getExtensionIndex(final T extension) {\n    if (!myExtensions.contains(extension)) {\n      throw new IllegalArgumentException(\"Extension to be removed not found: \" + extension);\n    }\n\n    return myExtensions.indexOf(extension);\n  }","id":77613,"modified_method":"private int getExtensionIndex(@NotNull T extension) {\n    int i = myExtensions.indexOf(extension);\n    if (i == -1) {\n      throw new IllegalArgumentException(\"Extension to be removed not found: \" + extension);\n    }\n    return i;\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ObjectComponentAdapter(Object extension, LoadingOrder loadingOrder) {\n      super(Object.class.getName(), null, null, null, false);\n      myExtension = extension;\n      myLoadingOrder = loadingOrder;\n    }","id":77614,"modified_method":"private ObjectComponentAdapter(Object extension, LoadingOrder loadingOrder) {\n      super(Object.class.getName(), null, null, null, false);\n      myExtension = extension;\n      myLoadingOrder = loadingOrder;\n    }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void registerExtension(@NotNull T extension, @NotNull LoadingOrder order) {\n    assert myExtensions.size() == myLoadedAdapters.size();\n\n    if (LoadingOrder.ANY == order) {\n      int index = myLoadedAdapters.size();\n      if (index > 0) {\n        ExtensionComponentAdapter lastAdapter = myLoadedAdapters.get(index - 1);\n        if (lastAdapter.getOrder() == LoadingOrder.LAST) {\n          index--;\n        }\n      }\n      internalRegisterExtension(extension, new ObjectComponentAdapter(extension, order), index, true);\n    }\n    else {\n      myExtensionAdapters.add(new ObjectComponentAdapter(extension, order));\n      processAdapters();\n    }\n  }","id":77615,"modified_method":"public synchronized void registerExtension(@NotNull T extension, @NotNull LoadingOrder order) {\n    assert myExtensions.size() == myLoadedAdapters.size();\n\n    if (LoadingOrder.ANY == order) {\n      int index = myLoadedAdapters.size();\n      if (index > 0) {\n        ExtensionComponentAdapter lastAdapter = myLoadedAdapters.get(index - 1);\n        if (lastAdapter.getOrder() == LoadingOrder.LAST) {\n          index--;\n        }\n      }\n      internalRegisterExtension(extension, new ObjectComponentAdapter(extension, order), index, true);\n      clearCache();\n    }\n    else {\n      myExtensionAdapters.add(new ObjectComponentAdapter(extension, order));\n      processAdapters();\n    }\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean hasExtension(@NotNull T extension) {\n    processAdapters();\n\n    return myExtensions.contains(extension);\n  }","id":77616,"modified_method":"public boolean hasExtension(@NotNull T extension) {\n    synchronized (this) {\n      processAdapters();\n    }\n    return myExtensions.contains(extension);\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized void processAdapters() {\n    if (!myExtensionAdapters.isEmpty()) {\n      List<ExtensionComponentAdapter> allAdapters = new ArrayList<ExtensionComponentAdapter>(myExtensionAdapters.size() + myLoadedAdapters.size());\n      allAdapters.addAll(myExtensionAdapters);\n      allAdapters.addAll(myLoadedAdapters);\n      myExtensions.clear();\n      myExtensionsCache = null;\n      ExtensionComponentAdapter[] loadedAdapters = myLoadedAdapters.toArray(new ExtensionComponentAdapter[myLoadedAdapters.size()]);\n      myLoadedAdapters.clear();\n      ExtensionComponentAdapter[] adapters = allAdapters.toArray(new ExtensionComponentAdapter[myExtensionAdapters.size()]);\n      LoadingOrder.sort(adapters);\n      for (int i = 0; i < adapters.length; i++) {\n        ExtensionComponentAdapter adapter = adapters[i];\n\n        //noinspection unchecked\n        T extension = (T)adapter.getExtension();\n        internalRegisterExtension(extension, adapter, i, ArrayUtil.find(loadedAdapters, adapter) == -1);\n      }\n      myExtensionAdapters.clear();\n    }\n  }","id":77617,"modified_method":"private void processAdapters() {\n    int totalSize = myExtensionAdapters.size() + myLoadedAdapters.size();\n    if (totalSize != 0) {\n      List<ExtensionComponentAdapter> allAdapters = new ArrayList<ExtensionComponentAdapter>(totalSize);\n      allAdapters.addAll(myExtensionAdapters);\n      allAdapters.addAll(myLoadedAdapters);\n\n      myExtensions.clear();\n      ExtensionComponentAdapter[] loadedAdapters = myLoadedAdapters.isEmpty() ? ExtensionComponentAdapter.EMPTY_ARRAY : myLoadedAdapters.toArray(new ExtensionComponentAdapter[myLoadedAdapters.size()]);\n      myLoadedAdapters.clear();\n      ExtensionComponentAdapter[] adapters = allAdapters.toArray(new ExtensionComponentAdapter[myExtensionAdapters.size()]);\n      LoadingOrder.sort(adapters);\n      for (int i = 0; i < adapters.length; i++) {\n        ExtensionComponentAdapter adapter = adapters[i];\n\n        //noinspection unchecked\n        T extension = (T)adapter.getExtension();\n        internalRegisterExtension(extension, adapter, i, ArrayUtil.find(loadedAdapters, adapter) == -1);\n      }\n      myExtensionAdapters.clear();\n    }\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"synchronized void registerExtensionAdapter(ExtensionComponentAdapter adapter) {\n    myExtensionAdapters.add(adapter);\n  }","id":77618,"modified_method":"synchronized void registerExtensionAdapter(ExtensionComponentAdapter adapter) {\n    myExtensionAdapters.add(adapter);\n    clearCache();\n  }","commit_id":"7013d8b9581041d8af1676552f39e982751d358e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isPyTestInstalled(Project project, String sdkHome) {\n    if (ourListener == null) {\n      ourListener = new VFSTestFrameworkListener(project, sdkHome);\n      LocalFileSystem.getInstance().addVirtualFileListener(ourListener);\n    }\n    return Boolean.parseBoolean(TestRunnerService.getInstance(project).isPyTestInstalled());\n  }","id":77619,"modified_method":"public static boolean isPyTestInstalled(Project project, String sdkHome) {\n    if (ourListener == null) {\n      ourListener = new VFSTestFrameworkListener(project);\n      LocalFileSystem.getInstance().addVirtualFileListener(ourListener);\n    }\n    TestRunnerService service = TestRunnerService.getInstance(project);\n    if (!service.getSdks().contains(sdkHome))\n      VFSTestFrameworkListener.updateTestFrameworks(service, sdkHome);\n\n    return service.isPyTestInstalled(sdkHome);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isNoseTestInstalled(Project project, String sdkHome) {\n    if (ourListener == null) {\n      ourListener = new VFSTestFrameworkListener(project, sdkHome);\n      LocalFileSystem.getInstance().addVirtualFileListener(ourListener);\n    }\n    return Boolean.parseBoolean(TestRunnerService.getInstance(project).isNoseTestInstalled());\n  }","id":77620,"modified_method":"public static boolean isNoseTestInstalled(Project project, String sdkHome) {\n    if (ourListener == null) {\n      ourListener = new VFSTestFrameworkListener(project);\n      LocalFileSystem.getInstance().addVirtualFileListener(ourListener);\n    }\n    TestRunnerService service = TestRunnerService.getInstance(project);\n    if (!service.getSdks().contains(sdkHome))\n      VFSTestFrameworkListener.updateTestFrameworks(service, sdkHome);\n\n    return service.isNoseTestInstalled(sdkHome);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isAtTestInstalled(Project project, String sdkHome) {\n    if (ourListener == null) {\n      ourListener = new VFSTestFrameworkListener(project, sdkHome);\n      LocalFileSystem.getInstance().addVirtualFileListener(ourListener);\n    }\n    return Boolean.parseBoolean(TestRunnerService.getInstance(project).isAtTestInstalled());\n  }","id":77621,"modified_method":"public static boolean isAtTestInstalled(Project project, String sdkHome) {\n    if (ourListener == null) {\n      ourListener = new VFSTestFrameworkListener(project);\n      LocalFileSystem.getInstance().addVirtualFileListener(ourListener);\n    }\n    TestRunnerService service = TestRunnerService.getInstance(project);\n    if (!service.getSdks().contains(sdkHome))\n      VFSTestFrameworkListener.updateTestFrameworks(service, sdkHome);\n\n    return service.isAtTestInstalled(sdkHome);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void noseTestInstalled(String installed) {\n    NOSE_TEST_INSTALLED = installed;\n  }","id":77622,"modified_method":"public boolean isNoseTestInstalled(String sdkHome) {\n    Boolean isInstalled = SDK_TO_NOSETEST.get(sdkHome);\n    return isInstalled == null? true: isInstalled;\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pyTestInstalled(String installed) {\n    PY_TEST_INSTALLED = installed;\n  }","id":77623,"modified_method":"public boolean isPyTestInstalled(String sdkHome) {\n    Boolean isInstalled = SDK_TO_PYTEST.get(sdkHome);\n    return isInstalled == null? true: isInstalled;\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestRunnerService() {\n    myConfigurations.add(PythonTestConfigurationsModel.PYTHONS_UNITTEST_NAME);\n    myConfigurations.add(PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME);\n    myConfigurations.add(PythonTestConfigurationsModel.PY_TEST_NAME);\n    myConfigurations.add(PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME);\n  }","id":77624,"modified_method":"public TestRunnerService() {\n    SDK_TO_PYTEST = new HashMap<String, Boolean>();\n    SDK_TO_NOSETEST = new HashMap<String, Boolean>();\n    SDK_TO_ATTEST = new HashMap<String, Boolean>();\n    PROCESSED_SDK = new ArrayList<String>();\n    myConfigurations.add(PythonTestConfigurationsModel.PYTHONS_UNITTEST_NAME);\n    myConfigurations.add(PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME);\n    myConfigurations.add(PythonTestConfigurationsModel.PY_TEST_NAME);\n    myConfigurations.add(PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String isNoseTestInstalled() {\n    return NOSE_TEST_INSTALLED;\n  }","id":77625,"modified_method":"public void noseTestInstalled(boolean installed, String sdkHome) {\n    SDK_TO_NOSETEST.put(sdkHome, installed);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void atTestInstalled(String installed) {\n    AT_TEST_INSTALLED = installed;\n  }","id":77626,"modified_method":"public boolean isAtTestInstalled(String sdkHome) {\n    Boolean isInstalled = SDK_TO_ATTEST.get(sdkHome);\n    return isInstalled == null? true: isInstalled;\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void updateTestFrameworks(TestRunnerService service, String sdkHome) {\n    String testFrameWork = service.getProjectConfiguration();\n    if (testFrameWork.equals(PythonTestConfigurationsModel.PY_TEST_NAME))\n      service.pyTestInstalled(String.valueOf(isTestFrameworkInstalled(sdkHome, PYTESTSEARCHER)));\n    else if (testFrameWork.equals(PythonTestConfigurationsModel.PYTHONS_NOSETEST_NAME))\n      service.noseTestInstalled(String.valueOf(isTestFrameworkInstalled(sdkHome, NOSETESTSEARCHER)));\n    else if (testFrameWork.equals(PythonTestConfigurationsModel.PYTHONS_ATTEST_NAME))\n      service.atTestInstalled(String.valueOf(isTestFrameworkInstalled(sdkHome, ATTESTSEARCHER)));\n  }","id":77627,"modified_method":"public static void updateTestFrameworks(TestRunnerService service, String sdkHome) {\n    service.addSdk(sdkHome);\n    service.pyTestInstalled(isTestFrameworkInstalled(sdkHome, PYTESTSEARCHER), sdkHome);\n    service.noseTestInstalled(isTestFrameworkInstalled(sdkHome, NOSETESTSEARCHER), sdkHome);\n    service.atTestInstalled(isTestFrameworkInstalled(sdkHome, ATTESTSEARCHER), sdkHome);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fileDeleted(VirtualFileEvent event) {\n    updateTestFrameworks(myService, mySdkHome);\n  }","id":77628,"modified_method":"@Override\n  public void fileDeleted(VirtualFileEvent event) {\n    updateTestFrameworks(myService);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fileCreated(VirtualFileEvent event) {\n    updateTestFrameworks(myService, mySdkHome);\n  }","id":77629,"modified_method":"@Override\n  public void fileCreated(VirtualFileEvent event) {\n    updateTestFrameworks(myService);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fileMoved(VirtualFileMoveEvent event) {\n    updateTestFrameworks(myService, mySdkHome);\n  }","id":77630,"modified_method":"@Override\n  public void fileMoved(VirtualFileMoveEvent event) {\n    updateTestFrameworks(myService);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VFSTestFrameworkListener(Project project, String sdkHome) {\n    mySdkHome = sdkHome;\n    myService = TestRunnerService.getInstance(project);\n    updateTestFrameworks(myService, mySdkHome);\n  }","id":77631,"modified_method":"public VFSTestFrameworkListener(Project project) {\n    myService = TestRunnerService.getInstance(project);\n    updateTestFrameworks(myService);\n  }","commit_id":"46e2f242aea147af21190161bab6e52162292256","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ComponentSelectionRules all(Closure<?> closure) {\n        addRule(createAllSpecRulesAction(createRuleActionFromClosure(closure)));\n        return this;\n    }","id":77632,"modified_method":"public ComponentSelectionRules all(Closure<?> closure) {\n        addRule(createAllSpecRulesAction(ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)));\n        return this;\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSelectionRules module(Object id, Action<? super ComponentSelection> selectionAction) {\n        addRule(createSpecRuleActionFromId(id, createRuleActionFromAction(selectionAction)));\n        return this;\n    }","id":77633,"modified_method":"public ComponentSelectionRules module(Object id, Action<? super ComponentSelection> selectionAction) {\n        return addRule(createSpecRuleActionFromId(id, ruleActionAdapter.createFromAction(selectionAction)));\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSelectionRules module(Object id, Closure<?> closure) {\n        addRule(createSpecRuleActionFromId(id, createRuleActionFromClosure(closure)));\n        return this;\n    }","id":77634,"modified_method":"public ComponentSelectionRules module(Object id, Closure<?> closure) {\n        return addRule(createSpecRuleActionFromId(id, ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)));\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSelectionRules all(Action<? super ComponentSelection> selectionAction) {\n        addRule(createAllSpecRulesAction(createRuleActionFromAction(selectionAction)));\n        return this;\n    }","id":77635,"modified_method":"public ComponentSelectionRules all(Action<? super ComponentSelection> selectionAction) {\n        return addRule(createAllSpecRulesAction(ruleActionAdapter.createFromAction(selectionAction)));\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"private void addRule(SpecRuleAction<? super ComponentSelection> specRuleAction) {\n        rules.add(specRuleAction);\n    }","id":77636,"modified_method":"private ComponentSelectionRules addRule(SpecRuleAction<? super ComponentSelection> specRuleAction) {\n        rules.add(specRuleAction);\n        return this;\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSelectionRules all(RuleAction<? super ComponentSelection> ruleAction) {\n        addRule(createAllSpecRulesAction(ruleActionValidator.validate(ruleAction)));\n        return this;\n    }","id":77637,"modified_method":"public ComponentSelectionRules all(RuleAction<? super ComponentSelection> ruleAction) {\n        return addRule(createAllSpecRulesAction(ruleActionValidator.validate(ruleAction)));\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSelectionRules module(Object id, RuleAction<? super ComponentSelection> ruleAction) {\n        addRule(createSpecRuleActionFromId(id, ruleActionValidator.validate(ruleAction)));\n        return this;\n    }","id":77638,"modified_method":"public ComponentSelectionRules module(Object id, RuleAction<? super ComponentSelection> ruleAction) {\n        return addRule(createSpecRuleActionFromId(id, ruleActionValidator.validate(ruleAction)));\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public RuleAction<? super T> createFromClosure(Class<T> subjectType, Closure<?> closure) {\n        RuleAction<T> ruleAction = new ClosureBackedRuleAction<T>(subjectType, closure);\n        return ruleActionValidator.validate(ruleAction);\n    }","id":77639,"modified_method":"public RuleAction<? super T> createFromClosure(Class<T> subjectType, Closure<?> closure) {\n        try {\n            return ruleActionValidator.validate(new ClosureBackedRuleAction<T>(subjectType, closure));\n        } catch (RuleActionValidationException e) {\n            throw new InvalidUserCodeException(String.format(INVALID_CLOSURE_ERROR, context), e);\n        }\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultRuleActionAdapter(RuleActionValidator<T> ruleActionValidator) {\n        this.ruleActionValidator = ruleActionValidator;\n    }","id":77640,"modified_method":"public DefaultRuleActionAdapter(RuleActionValidator<T> ruleActionValidator, String context) {\n        this.ruleActionValidator = ruleActionValidator;\n        this.context = context;\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"public RuleAction<? super T> createFromAction(Action<? super T> action) {\n        RuleAction<T> ruleAction = new NoInputsRuleAction<T>(action);\n        return ruleActionValidator.validate(ruleAction);\n    }","id":77641,"modified_method":"public RuleAction<? super T> createFromAction(Action<? super T> action) {\n        try {\n            return ruleActionValidator.validate(new NoInputsRuleAction<T>(action));\n        } catch (RuleActionValidationException e) {\n            throw new InvalidUserCodeException(String.format(INVALID_ACTION_ERROR, context), e);\n        }\n    }","commit_id":"be8a462b59f1d7a27df9d86d24268ba4071a8d51","url":"https://github.com/gradle/gradle"},{"original_method":"private SpecRuleAction<? super ComponentSelection> createSpecRuleActionFromId(Object id, RuleAction<? super ComponentSelection> ruleAction) {\n        final NotationParser<Object, ModuleIdentifier> parser = NotationParserBuilder\n                .toType(ModuleIdentifier.class)\n                .parser(new ModuleIdentiferNotationParser())\n                .toComposite();\n        final ModuleIdentifier moduleIdentifier;\n\n        try {\n            moduleIdentifier = parser.parseNotation(id);\n        } catch (UnsupportedNotationException e) {\n            throw new InvalidUserCodeException(String.format(INVALID_SPEC_ERROR, id == null ? \"null\" : id.toString()), e);\n        }\n\n        Spec<ComponentSelection> spec = new ComponentSelectionMatchingSpec(moduleIdentifier);\n        return new SpecRuleAction<ComponentSelection>(ruleAction, spec);\n    }","id":77642,"modified_method":"private SpecRuleAction<? super ComponentSelection> createSpecRuleActionFromId(Object id, RuleAction<? super ComponentSelection> ruleAction) {\n        final ModuleIdentifier moduleIdentifier;\n\n        try {\n            moduleIdentifier = moduleIdentifierNotationParser.parseNotation(id);\n        } catch (UnsupportedNotationException e) {\n            throw new InvalidUserCodeException(String.format(INVALID_SPEC_ERROR, id == null ? \"null\" : id.toString()), e);\n        }\n\n        Spec<ComponentSelection> spec = new ComponentSelectionMatchingSpec(moduleIdentifier);\n        return new SpecRuleAction<ComponentSelection>(ruleAction, spec);\n    }","commit_id":"ccf1cc5e693003fc8f2c4abd1a3d28c13b3afec4","url":"https://github.com/gradle/gradle"},{"original_method":"public ComponentSelectionRules all(Closure<?> closure) {\n        addRule(createAllSpecRulesAction(ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)));\n        return this;\n    }","id":77643,"modified_method":"public ComponentSelectionRules all(Closure<?> closure) {\n        return addRule(createAllSpecRulesAction(ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)));\n    }","commit_id":"ccf1cc5e693003fc8f2c4abd1a3d28c13b3afec4","url":"https://github.com/gradle/gradle"},{"original_method":"@NotNull\n  public List<StackFrame> getFrames() {\n    if (myCurrentSuspendContext != null) {\n      return myCurrentSuspendContext.getFrames();\n    }\n    return Collections.emptyList();\n  }","id":77644,"modified_method":"@NotNull\n  public List<StackFrame> getFrames() {\n    if (myCurrentSuspendContext != null) {\n      ThreadReference thread = myCurrentSuspendContext.getThread();\n      if (thread == null) {\n        List<ThreadReference> threads = myEventsProcessor.getVirtualMachine().allThreads();\n        thread = threads.get(0);\n        for (ThreadReference t : threads) {\n          // TODO this is a hack\n          if (!t.threadGroup().name().equals(\"system\")) {\n            thread = t;\n            break;\n          }\n        }\n      }\n      try {\n        return thread.frames();\n      } catch (IncompatibleThreadStateException e) {\n        LOG.error(e);\n      }\n    }\n    return Collections.emptyList();\n  }","commit_id":"c7ed64ec40e93f77a6237cda5e59149f3cc5b41a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void resume() {\n    myEventsProcessor.resume();\n  }","id":77645,"modified_method":"public void resume() {\n    myEventsProcessor.resume(myCurrentSuspendContext);\n  }","commit_id":"c7ed64ec40e93f77a6237cda5e59149f3cc5b41a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected void action() throws Exception {\n      System.err.println(\"Pausing execution!\");\n      // see DebugProcessImpl.PauseCommand in idea\n      getVirtualMachine().suspend();\n      // TODO the context we create here is not in SuspendManager paused list. WHY?\n      SuspendContext suspendContext = getSuspendManager().pushSuspendContextWithVotesNumber(EventRequest.SUSPEND_ALL, 0);\n\n      List<ThreadReference> threads = getVirtualMachine().allThreads();\n      ThreadReference thread = threads.get(0);\n      for (ThreadReference t : threads) {\n        // TODO this is a hack\n        if (!t.threadGroup().name().equals(\"system\")){\n          thread = t;\n          break;\n        }\n      }\n      suspendContext.setThread(thread);\n      getMulticaster().paused(suspendContext, DebugVMEventsProcessor.this);\n    }","id":77646,"modified_method":"@Override\n    protected void action() throws Exception {\n      System.err.println(\"Pausing execution!\");\n      // see DebugProcessImpl.PauseCommand in idea\n      getVirtualMachine().suspend();\n      // TODO the context we create here is not in SuspendManager paused list. WHY?\n      SuspendContext suspendContext = getSuspendManager().pushSuspendContextWithVotesNumber(EventRequest.SUSPEND_ALL, 0);\n      getMulticaster().paused(suspendContext, DebugVMEventsProcessor.this);\n    }","commit_id":"c7ed64ec40e93f77a6237cda5e59149f3cc5b41a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int nextStep(SuspendContext context) {\n    if (myStepType == StepRequest.STEP_OVER || myStepType == StepRequest.STEP_INTO) {\n      StackFrame frame = context.getFrame();\n      int frameCount = -1;\n      Location location = frame.location();\n      try {\n        frameCount = context.getThread().frameCount();\n      } catch (IncompatibleThreadStateException e) {\n        LOG.error(e);\n      }\n      boolean filesEqual = myDeclaringType.equals(location.declaringType().name());\n      // if we are on the same place we should step again\n      if (filesEqual && myLineNumber == location.lineNumber() && myFrameCount == frameCount) {\n        return myStepType;\n      }\n    }\n    return STOP;\n  }","id":77647,"modified_method":"public int nextStep(SuspendContext context) {\n    if (myStepType == StepRequest.STEP_OVER || myStepType == StepRequest.STEP_INTO) {\n      ThreadReference thread = context.getThread();\n      StackFrame frame = context.getFrame();\n      if (frame == null || thread == null) return myStepType;\n      int frameCount = -1;\n      Location location = frame.location();\n      try {\n        frameCount = thread.frameCount();\n      } catch (IncompatibleThreadStateException e) {\n        LOG.error(e);\n      }\n      boolean filesEqual = myDeclaringType.equals(location.declaringType().name());\n      // if we are on the same place we should step again\n      if (filesEqual && myLineNumber == location.lineNumber() && myFrameCount == frameCount) {\n        return myStepType;\n      }\n    }\n    return STOP;\n  }","commit_id":"c7ed64ec40e93f77a6237cda5e59149f3cc5b41a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public StepRequestor(SuspendContext context, int stepType) {\n    myStepType = stepType;\n    StackFrame frame = context.getFrame();\n    try {\n      myFrameCount = context.getThread().frameCount();\n    } catch (IncompatibleThreadStateException e) {\n      LOG.error(e);\n    }\n    myDeclaringType = frame.location().declaringType().name();\n    myLineNumber = frame.location().lineNumber();\n  }","id":77648,"modified_method":"public StepRequestor(SuspendContext context, int stepType) {\n    myStepType = stepType;\n    try {\n      ThreadReference thread = context.getThread();\n      if (thread != null) {\n        myFrameCount = thread.frameCount();\n        StackFrame frame = thread.frame(0);\n        if (frame != null) {\n          myDeclaringType = frame.location().declaringType().name();\n          myLineNumber = frame.location().lineNumber();\n        }\n      }\n    } catch (IncompatibleThreadStateException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"c7ed64ec40e93f77a6237cda5e59149f3cc5b41a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public List<StackFrame> getFrames() {\n    assertNotResumed();\n    try {\n      return myThread != null ? myThread.frames() : Collections.<StackFrame>emptyList();\n    } catch (IncompatibleThreadStateException e) {\n      return Collections.<StackFrame>emptyList();\n    }\n  }","id":77649,"modified_method":"@NotNull\n  private List<StackFrame> getFrames() {\n    assertNotResumed();\n    try {\n      return myThread != null ? myThread.frames() : Collections.<StackFrame>emptyList();\n    } catch (IncompatibleThreadStateException e) {\n      return Collections.<StackFrame>emptyList();\n    }\n  }","commit_id":"c7ed64ec40e93f77a6237cda5e59149f3cc5b41a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * This constructor is called when user selects some thread from ui\n   */\n  /*package*/ JavaUiStateImpl(@NotNull JavaUiStateImpl previousState, DebugSession debugSession, int currentThreadIndex) {\n    super(debugSession);\n    myDebugSession = debugSession;\n    myThreadIndex = currentThreadIndex;\n    if (currentThreadIndex < 0) {\n      myContext = null;\n      myStackFrameIndex = AbstractUiState.NO_FRAME;\n    } else {\n      myContext = findContext(previousState);\n      LOG.assertLog(myContext != null);\n      //  in case some botva is going on \n      myStackFrameIndex = findStackFrameIndex();\n    }\n  }","id":77650,"modified_method":"/**\n   * This constructor is called when user selects some thread from ui\n   */\n  /*package*/ JavaUiStateImpl(@NotNull JavaUiStateImpl previousState, DebugSession debugSession, int currentThreadIndex) {\n    super(debugSession);\n    myDebugSession = debugSession;\n    myThreadIndex = currentThreadIndex;\n    if (currentThreadIndex < 0) {\n      myContext = null;\n      myStackFrameIndex = AbstractUiState.NO_FRAME;\n    } else {\n      myContext = findContext(previousState);\n      assert myContext != null;\n      //  in case some botva is going on \n      myStackFrameIndex = findStackFrameIndex();\n    }\n  }","commit_id":"4caf935db24cdfe85c340bb7b19406a783336c75","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SuspendContext findContext(@NotNull JavaUiStateImpl previousState) {\n    SuspendContext newContext = previousState.myContext;\n    if (newContext == null) {\n      LOG.errorAssertionFailed();\n      return null;\n    }\n    if (!(newContext.suspends(getThread().getThread()))) {\n      newContext = null;\n      for (SuspendContext context : getAllPausedContexts()) {\n        if (context.suspends(getThread().getThread())) {\n          newContext = context;\n          break;\n        }\n      }\n    }\n    return newContext;\n  }","id":77651,"modified_method":"private SuspendContext findContext(@NotNull JavaUiStateImpl previousState) {\n    SuspendContext newContext = previousState.myContext;\n    if (newContext == null) {\n      return null;\n    }\n    JavaThread thread = getThread();\n    if (thread == null) {\n      return null;\n    }\n    if (!(newContext.suspends(thread.getThread()))) {\n      newContext = null;\n      for (SuspendContext context : getAllPausedContexts()) {\n        if (context.suspends(thread.getThread())) {\n          newContext = context;\n          break;\n        }\n      }\n    }\n    return newContext;\n  }","commit_id":"4caf935db24cdfe85c340bb7b19406a783336c75","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized void initializeThreads() {\n    if (myInitialized) {\n      return;\n    }\n    myInitialized = true;\n    if (getExecutionState().equals(AbstractDebugSession.ExecutionState.Paused)) {\n      for (ThreadReference threadReference : getEventsProcessor().getVirtualMachine().allThreads()) {\n        if (threadReference.isSuspended()) {\n          myThreads.add(new JavaThread(threadReference));\n        }\n      }\n      assert myThreadIndex < ListSequence.fromList(myThreads).count();\n    } else {\n      assert myThreadIndex < 0;\n    }\n  }","id":77652,"modified_method":"private synchronized void initializeThreads() {\n    if (myInitialized) {\n      return;\n    }\n    assert !(ModelAccess.instance().isInEDT());\n    myInitialized = true;\n    if (getExecutionState().equals(AbstractDebugSession.ExecutionState.Paused)) {\n      for (ThreadReference threadReference : getEventsProcessor().getVirtualMachine().allThreads()) {\n        if (threadReference.isSuspended()) {\n          myThreads.add(new JavaThread(threadReference));\n        }\n      }\n      assert myThreadIndex < ListSequence.fromList(myThreads).count();\n    } else {\n      assert myThreadIndex < 0;\n    }\n  }","commit_id":"4caf935db24cdfe85c340bb7b19406a783336c75","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * This constructor is called when user selects some frame from ui\n   */\n  /*package*/ JavaUiStateImpl(@NotNull JavaUiStateImpl previousState, int frameIndex, DebugSession debugSession) {\n    super(debugSession);\n    myDebugSession = debugSession;\n    LOG.assertLog(frameIndex == AbstractUiState.NO_FRAME || (frameIndex >= 0 && frameIndex < previousState.getCurrentThread().getFramesCount()));\n    myContext = previousState.myContext;\n    myThreadIndex = previousState.myThreadIndex;\n    myStackFrameIndex = frameIndex;\n  }","id":77653,"modified_method":"/**\n   * This constructor is called when user selects some frame from ui\n   */\n  /*package*/ JavaUiStateImpl(@NotNull JavaUiStateImpl previousState, int frameIndex, DebugSession debugSession) {\n    super(debugSession);\n    myDebugSession = debugSession;\n    assert frameIndex == NO_FRAME || (frameIndex >= 0 && frameIndex < previousState.getCurrentThread().getFramesCount());\n    myContext = previousState.myContext;\n    myThreadIndex = previousState.myThreadIndex;\n    myStackFrameIndex = frameIndex;\n  }","commit_id":"4caf935db24cdfe85c340bb7b19406a783336c75","url":"https://github.com/JetBrains/MPS"},{"original_method":"JavaUiStateImpl(@Nullable SuspendContext context, DebugSession debugSession) {\n    super(debugSession);\n    myDebugSession = debugSession;\n    myContext = context;\n    if (context == null) {\n      myThreadIndex = -1;\n      myStackFrameIndex = AbstractUiState.NO_FRAME;\n    } else {\n      myThreadIndex = findThreadIndex();\n      LOG.assertLog(myThreadIndex >= 0);\n      myStackFrameIndex = findStackFrameIndex();\n    }\n  }","id":77654,"modified_method":"JavaUiStateImpl(@Nullable SuspendContext context, DebugSession debugSession) {\n    super(debugSession);\n    myDebugSession = debugSession;\n    myContext = context;\n    if (context == null) {\n      myThreadIndex = -1;\n      myStackFrameIndex = AbstractUiState.NO_FRAME;\n    } else {\n      myThreadIndex = findThreadIndex();\n      assert myThreadIndex >= 0;\n      myStackFrameIndex = findStackFrameIndex();\n    }\n  }","commit_id":"4caf935db24cdfe85c340bb7b19406a783336c75","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void testGenerate125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77655,"modified_method":"@Test\n    public void testGenerate125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = WebSocketFrame.text(builder.toString());\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65535ByteTextCase1_1_6()\n    {\n        int length = 65535;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77656,"modified_method":"@Test\n    public void testGenerate65535ByteTextCase1_1_6()\n    {\n        int length = 65535;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = WebSocketFrame.text(builder.toString());\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateEmptyTextCase1_1_1()\n    {\n        WebSocketFrame textFrame = FrameBuilder.text(\"\").asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77657,"modified_method":"@Test\n    public void testGenerateEmptyTextCase1_1_1()\n    {\n        WebSocketFrame textFrame = WebSocketFrame.text(\"\");\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length >> 8));\n        expected.put((byte)(length & 0xFF));\n        // expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77658,"modified_method":"@Test\n    public void testGenerate128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = WebSocketFrame.text(builder.toString());\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length >> 8));\n        expected.put((byte)(length & 0xFF));\n        // expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77659,"modified_method":"@Test\n    public void testGenerate127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = WebSocketFrame.text(builder.toString());\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77660,"modified_method":"@Test\n    public void testGenerate65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = WebSocketFrame.text(builder.toString());\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77661,"modified_method":"@Test\n    public void testGenerate126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = WebSocketFrame.text(builder.toString());\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65535ByteBinaryCase1_2_6()\n    {\n        int length = 65535;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]{ (byte)0xff, (byte)0xff});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77662,"modified_method":"@Test\n    public void testGenerate65535ByteBinaryCase1_2_6()\n    {\n        int length = 65535;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]{ (byte)0xff, (byte)0xff});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65536ByteBinaryCase1_2_7()\n    {\n        int length = 65536;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00});\n\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77663,"modified_method":"@Test\n    public void testGenerate65536ByteBinaryCase1_2_7()\n    {\n        int length = 65536;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00});\n\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate128ByteBinaryCase1_2_5()\n    {\n        int length = 128;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length>>8));\n        expected.put((byte)(length & 0xFF));\n        //expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77664,"modified_method":"@Test\n    public void testGenerate128ByteBinaryCase1_2_5()\n    {\n        int length = 128;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length>>8));\n        expected.put((byte)(length & 0xFF));\n        //expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate125ByteBinaryCase1_2_2()\n    {\n        int length = 125;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77665,"modified_method":"@Test\n    public void testGenerate125ByteBinaryCase1_2_2()\n    {\n        int length = 125;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate127ByteBinaryCase1_2_4()\n    {\n        int length = 127;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77666,"modified_method":"@Test\n    public void testGenerate127ByteBinaryCase1_2_4()\n    {\n        int length = 127;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate126ByteBinaryCase1_2_3()\n    {\n        int length = 126;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77667,"modified_method":"@Test\n    public void testGenerate126ByteBinaryCase1_2_3()\n    {\n        int length = 126;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateEmptyBinaryCase1_2_1()\n    {\n        WebSocketFrame binaryFrame = FrameBuilder.binary(new byte[] {}).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":77668,"modified_method":"@Test\n    public void testGenerateEmptyBinaryCase1_2_1()\n    {\n        WebSocketFrame binaryFrame = WebSocketFrame.binary(new byte[] {});\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static WebSocketFrame binar(byte buf[])\n    {\n        return new WebSocketFrame(OpCode.BINARY).setPayload(buf);\n    }","id":77669,"modified_method":"public static WebSocketFrame binary(byte buf[])\n    {\n        return new WebSocketFrame(OpCode.BINARY).setPayload(buf);\n    }","commit_id":"8c6820a812d7f4dd921dfd1b930ac8b7b74afaa9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public <C> void ping(C context, Callback<C> callback, byte[] payload) throws IOException\n    {\n        WebSocketFrame frame = FrameBuilder.ping().payload(payload).asFrame();\n        ControlFrameBytes<C> bytes = new ControlFrameBytes<C>(this,callback,context,frame);\n        scheduleTimeout(bytes);\n        queue.prepend(bytes);\n    }","id":77670,"modified_method":"@Override\n    public <C> void ping(C context, Callback<C> callback, byte[] payload) throws IOException\n    {\n        WebSocketFrame frame = new WebSocketFrame(OpCode.PING).setPayload(payload);\n        ControlFrameBytes<C> bytes = new ControlFrameBytes<C>(this,callback,context,frame);\n        scheduleTimeout(bytes);\n        queue.prepend(bytes);\n    }","commit_id":"cd0edafa6882459e96c42789608b991ea9bc7e29","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, byte buf[], int offset, int len) throws IOException\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},byte[],{},{})\",callback,offset,len);\n        }\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n\n        WebSocketFrame frame = FrameBuilder.binary(buf,offset,len).fin(true).asFrame();\n        DataFrameBytes<C> bytes = new DataFrameBytes<C>(this,callback,context,frame);\n        scheduleTimeout(bytes);\n        queue.append(bytes);\n    }","id":77671,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, byte buf[], int offset, int len) throws IOException\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},byte[],{},{})\",callback,offset,len);\n        }\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n\n        WebSocketFrame frame = WebSocketFrame.binary().setPayload(buf,offset,len);\n        DataFrameBytes<C> bytes = new DataFrameBytes<C>(this,callback,context,frame);\n        scheduleTimeout(bytes);\n        queue.append(bytes);\n        flush();\n    }","commit_id":"cd0edafa6882459e96c42789608b991ea9bc7e29","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, String message) throws IOException\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},message.length:{})\",callback,message.length());\n        }\n\n        WebSocketFrame frame = FrameBuilder.text(message).fin(true).asFrame();\n        DataFrameBytes<C> bytes = new DataFrameBytes<C>(this,callback,context,frame);\n        scheduleTimeout(bytes);\n        queue.append(bytes);\n    }","id":77672,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, String message) throws IOException\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},message.length:{})\",callback,message.length());\n        }\n\n        WebSocketFrame frame = WebSocketFrame.text(message);\n        DataFrameBytes<C> bytes = new DataFrameBytes<C>(this,callback,context,frame);\n        scheduleTimeout(bytes);\n        queue.append(bytes);\n        flush();\n    }","commit_id":"cd0edafa6882459e96c42789608b991ea9bc7e29","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * For terminating connections forcefully.\n     * \n     * @param statusCode\n     *            the WebSocket status code.\n     * @param reason\n     *            the (optional) reason string. (null is allowed)\n     * @see StatusCode\n     */\n    private void terminateConnection(int statusCode, String reason)\n    {\n        WebSocketFrame close = FrameBuilder.close(statusCode,reason).asFrame();\n\n        ByteBuffer buf = generator.generate(close);\n        BufferUtil.flipToFlush(buf,0);\n        getEndPoint().write(null,new WebSocketCloseCallback(this,buf),buf);\n    }","id":77673,"modified_method":"/**\n     * For terminating connections forcefully.\n     * \n     * @param statusCode\n     *            the WebSocket status code.\n     * @param reason\n     *            the (optional) reason string. (null is allowed)\n     * @see StatusCode\n     */\n    private void terminateConnection(int statusCode, String reason)\n    {\n        CloseInfo close = new CloseInfo(statusCode,reason);\n        FutureCallback<Void> nop = new FutureCallback<>();\n        ControlFrameBytes<Void> frameBytes = new ControlFrameBytes<Void>(this,nop,null,close.asFrame());\n        queue.prepend(frameBytes);\n        flush();\n    }","commit_id":"cd0edafa6882459e96c42789608b991ea9bc7e29","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Send a binary message.\n     * <p>\n     * Basic usage, results in a blocking write.\n     */\n    public void write(byte[] data, int offset, int length) throws IOException\n    {\n        WebSocketFrame frame = FrameBuilder.binary(data,offset,length).asFrame();\n        try\n        {\n            FutureCallback<Void> blocking = new FutureCallback<>();\n            DataFrameBytes<Void> bytes = new DataFrameBytes<>(conn,blocking,null,frame);\n            this.conn.getQueue().append(bytes);\n            blocking.get(); // block till finished\n        }\n        catch (InterruptedException e)\n        {\n            throw new IOException(\"Blocking write failed\",e);\n        }\n        catch (ExecutionException e)\n        {\n            FutureCallback.rethrow(e);\n        }\n    }","id":77674,"modified_method":"/**\n     * Send a binary message.\n     * <p>\n     * Basic usage, results in a blocking write.\n     */\n    public void write(byte[] data, int offset, int length) throws IOException\n    {\n        WebSocketFrame frame = WebSocketFrame.binary().setPayload(data,offset,length);\n        try\n        {\n            FutureCallback<Void> blocking = new FutureCallback<>();\n            DataFrameBytes<Void> bytes = new DataFrameBytes<>(conn,blocking,null,frame);\n            this.conn.getQueue().append(bytes);\n            blocking.get(); // block till finished\n        }\n        catch (InterruptedException e)\n        {\n            throw new IOException(\"Blocking write failed\",e);\n        }\n        catch (ExecutionException e)\n        {\n            FutureCallback.rethrow(e);\n        }\n    }","commit_id":"cd0edafa6882459e96c42789608b991ea9bc7e29","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Send text message.\n     * <p>\n     * Basic usage, results in a blocking write.\n     */\n    public void write(String message) throws IOException\n    {\n        WebSocketFrame frame = FrameBuilder.text(message).asFrame();\n        try\n        {\n            FutureCallback<Void> blocking = new FutureCallback<>();\n            DataFrameBytes<Void> bytes = new DataFrameBytes<>(conn,blocking,null,frame);\n            this.conn.getQueue().append(bytes);\n            blocking.get(); // block till finished\n        }\n        catch (InterruptedException e)\n        {\n            throw new IOException(\"Blocking write failed\",e);\n        }\n        catch (ExecutionException e)\n        {\n            FutureCallback.rethrow(e);\n        }\n    }","id":77675,"modified_method":"/**\n     * Send text message.\n     * <p>\n     * Basic usage, results in a blocking write.\n     */\n    public void write(String message) throws IOException\n    {\n        WebSocketFrame frame = WebSocketFrame.text(message);\n        try\n        {\n            FutureCallback<Void> blocking = new FutureCallback<>();\n            DataFrameBytes<Void> bytes = new DataFrameBytes<>(conn,blocking,null,frame);\n            this.conn.getQueue().append(bytes);\n            blocking.get(); // block till finished\n        }\n        catch (InterruptedException e)\n        {\n            throw new IOException(\"Blocking write failed\",e);\n        }\n        catch (ExecutionException e)\n        {\n            FutureCallback.rethrow(e);\n        }\n    }","commit_id":"cd0edafa6882459e96c42789608b991ea9bc7e29","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParserAndGeneratorMasked() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        policy.setMasker(new RandomMasker());\n\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy,bufferPool);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Setup Frame\n            WebSocketFrame txt = FrameBuilder.text().payload(message.getBytes()).asFrame();\n\n            // Add masking\n            byte mask[] = new byte[4];\n            new FixedMasker().genMask(mask);\n            txt.setMask(mask);\n\n            // Generate Buffer\n            out = gen.generate(policy.getBufferSize(),txt);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertTrue(\"Text.isMasked\",txt.isMasked());\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","id":77676,"modified_method":"@Test\n    public void testParserAndGeneratorMasked() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        policy.setMasker(new RandomMasker());\n\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy,bufferPool);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Setup Frame\n            WebSocketFrame frame = WebSocketFrame.text(message);\n\n            // Add masking\n            byte mask[] = new byte[4];\n            new FixedMasker().genMask(mask);\n            frame.setMask(mask);\n\n            // Generate Buffer\n            out = gen.generate(policy.getBufferSize(),frame);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertTrue(\"Text.isMasked\",txt.isMasked());\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParserAndGenerator() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy,bufferPool);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            out = gen.generate(FrameBuilder.text().payload(message.getBytes()).asFrame());\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","id":77677,"modified_method":"@Test\n    public void testParserAndGenerator() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy,bufferPool);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            WebSocketFrame frame = WebSocketFrame.text(message);\n            out = gen.generate(frame);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleMaskedTextMessage()\n    {\n        WebSocketFrame text = FrameBuilder.text(\"Hello\").mask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d }).asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n\n        Generator gen = new Generator(policy);\n        ByteBuffer actual = gen.generate(text);\n\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // A single-frame masked text message\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"masked text buffers are not equal\",expected,actual);\n    }","id":77678,"modified_method":"@Test\n    public void testSingleMaskedTextMessage()\n    {\n        WebSocketFrame text = WebSocketFrame.text(\"Hello\");\n        text.setMask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d });\n\n        Generator gen = new UnitGenerator();\n        ;\n        ByteBuffer actual = gen.generate(text);\n\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // A single-frame masked text message\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"masked text buffers are not equal\",expected,actual);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked64KBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = gen.generate(binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64k bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7F });\n        expected.putInt(0x00_00_00_00);\n        expected.putInt(0x00_01_00_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","id":77679,"modified_method":"@Test\n    public void testSingleUnmasked64KBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        WebSocketFrame binary = WebSocketFrame.binary();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        Generator gen = new UnitGenerator();\n\n        ByteBuffer actual = gen.generate(binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64k bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7F });\n        expected.putInt(0x00_00_00_00);\n        expected.putInt(0x00_01_00_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testFragmentedUnmaskedTextMessage()\n    {\n        WebSocketFrame text1 = FrameBuilder.text(\"Hel\").fin(false).asFrame();\n        WebSocketFrame text2 = FrameBuilder.continuation(\"lo\").asFrame();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual1 = generator.generate(text1);\n        ByteBuffer actual2 = generator.generate(text2);\n\n        ByteBuffer expected1 = ByteBuffer.allocate(5);\n\n        expected1.put(new byte[]\n                { (byte)0x01, (byte)0x03, (byte)0x48, (byte)0x65, (byte)0x6c });\n\n        ByteBuffer expected2 = ByteBuffer.allocate(4);\n\n        expected2.put(new byte[]\n                { (byte)0x80, (byte)0x02, (byte)0x6c, (byte)0x6f });\n\n        expected1.flip();\n        actual1.flip();\n        expected2.flip();\n        actual2.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected1,actual1);\n        ByteBufferAssert.assertEquals(\"t2 buffers are not equal\",expected2,actual2);\n    }","id":77680,"modified_method":"@Test\n    public void testFragmentedUnmaskedTextMessage()\n    {\n        WebSocketFrame text1 = WebSocketFrame.text(\"Hel\").setFin(false);\n        WebSocketFrame text2 = new WebSocketFrame(OpCode.CONTINUATION).setPayload(\"lo\");\n\n        Generator generator = new UnitGenerator();\n\n        ByteBuffer actual1 = generator.generate(text1);\n        ByteBuffer actual2 = generator.generate(text2);\n\n        ByteBuffer expected1 = ByteBuffer.allocate(5);\n\n        expected1.put(new byte[]\n                { (byte)0x01, (byte)0x03, (byte)0x48, (byte)0x65, (byte)0x6c });\n\n        ByteBuffer expected2 = ByteBuffer.allocate(4);\n\n        expected2.put(new byte[]\n                { (byte)0x80, (byte)0x02, (byte)0x6c, (byte)0x6f });\n\n        expected1.flip();\n        actual1.flip();\n        expected2.flip();\n        actual2.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected1,actual1);\n        ByteBufferAssert.assertEquals(\"t2 buffers are not equal\",expected2,actual2);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmaskedTextMessage()\n    {\n        WebSocketFrame text = FrameBuilder.text(\"Hello\").asFrame();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual = generator.generate(text);\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n\n        expected.flip();\n        actual.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected,actual);\n    }","id":77681,"modified_method":"@Test\n    public void testSingleUnmaskedTextMessage()\n    {\n        WebSocketFrame text = WebSocketFrame.text(\"Hello\");\n\n        Generator generator = new UnitGenerator();\n\n        ByteBuffer actual = generator.generate(text);\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n\n        expected.flip();\n        actual.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected,actual);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmaskedPingRequest() throws Exception\n    {\n        WebSocketFrame ping = FrameBuilder.ping(\"Hello\").asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n\n        Generator gen = new Generator(policy);\n        ByteBuffer actual = gen.generate(ping);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n        expected.put(new byte[]\n                { (byte)0x89, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"Ping buffers\",expected,actual);\n    }","id":77682,"modified_method":"@Test\n    public void testSingleUnmaskedPingRequest() throws Exception\n    {\n        WebSocketFrame ping = new WebSocketFrame(OpCode.PING).setPayload(\"Hello\");\n\n        Generator gen = new UnitGenerator();\n        ByteBuffer actual = gen.generate(ping);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n        expected.put(new byte[]\n                { (byte)0x89, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"Ping buffers\",expected,actual);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleMaskedPongRequest()\n    {\n        WebSocketFrame pong = FrameBuilder.pong(\"Hello\").mask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d }).asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = gen.generate(pong);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // Unmasked Pong request\n        expected.put(new byte[]\n                { (byte)0x8a, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"pong buffers are not equal\",expected,actual);\n    }","id":77683,"modified_method":"@Test\n    public void testSingleMaskedPongRequest()\n    {\n        WebSocketFrame pong = new WebSocketFrame(OpCode.PONG);\n        pong.setPayload(\"Hello\");\n        pong.setMask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d });\n\n        Generator gen = new UnitGenerator();\n\n        ByteBuffer actual = gen.generate(pong);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // Unmasked Pong request\n        expected.put(new byte[]\n                { (byte)0x8a, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"pong buffers are not equal\",expected,actual);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = gen.generate(binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + FUDGE);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7E });\n        expected.putShort((short)0x01_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","id":77684,"modified_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        WebSocketFrame binary = WebSocketFrame.binary();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        Generator gen = new UnitGenerator();\n\n        ByteBuffer actual = gen.generate(binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + FUDGE);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7E });\n        expected.putShort((short)0x01_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private WebSocketFrame makeBinaryFrame(String content, boolean fin)\n    {\n        return FrameBuilder.binary().fin(fin).payload((content.getBytes(StringUtil.__UTF8_CHARSET))).asFrame();\n    }","id":77685,"modified_method":"private WebSocketFrame makeBinaryFrame(String content, boolean fin)\n    {\n        return WebSocketFrame.binary().setFin(fin).setPayload(content);\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAnnotated_Frames()\n    {\n        AnnotatedFramesSocket socket = new AnnotatedFramesSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.ping(\"PING\").asFrame());\n        driver.onFrame(FrameBuilder.text().payload(\"Text Me\").asFrame());\n        driver.onFrame(FrameBuilder.binary().payload(StringUtil.getUtf8Bytes(\"Hello Bin\")).asFrame());\n        driver.onFrame(FrameBuilder.close(StatusCode.SHUTDOWN).asFrame());\n\n        socket.capture.assertEventCount(6);\n        socket.capture.assertEventStartsWith(0,\"onConnect(\");\n        socket.capture.assertEventStartsWith(1,\"onFrame(PING[\");\n        socket.capture.assertEventStartsWith(2,\"onFrame(TEXT[\");\n        socket.capture.assertEventStartsWith(3,\"onFrame(BINARY[\");\n        socket.capture.assertEventStartsWith(4,\"onFrame(CLOSE[\");\n        socket.capture.assertEventStartsWith(5,\"onClose(1001,\");\n    }","id":77686,"modified_method":"@Test\n    public void testAnnotated_Frames()\n    {\n        AnnotatedFramesSocket socket = new AnnotatedFramesSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(new WebSocketFrame(OpCode.PING).setPayload(\"PING\"));\n        driver.onFrame(WebSocketFrame.text(\"Text Me\"));\n        driver.onFrame(WebSocketFrame.binary().setPayload(\"Hello Bin\"));\n        driver.onFrame(new CloseInfo(StatusCode.SHUTDOWN).asFrame());\n\n        socket.capture.assertEventCount(6);\n        socket.capture.assertEventStartsWith(0,\"onConnect(\");\n        socket.capture.assertEventStartsWith(1,\"onFrame(PING[\");\n        socket.capture.assertEventStartsWith(2,\"onFrame(TEXT[\");\n        socket.capture.assertEventStartsWith(3,\"onFrame(BINARY[\");\n        socket.capture.assertEventStartsWith(4,\"onFrame(CLOSE[\");\n        socket.capture.assertEventStartsWith(5,\"onClose(1001,\");\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testListener_Text()\n    {\n        ListenerBasicSocket socket = new ListenerBasicSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.text(\"Hello World\").asFrame());\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketText(\\\"Hello World\\\")\");\n        socket.capture.assertEventStartsWith(2,\"onWebSocketClose(1000,\");\n    }","id":77687,"modified_method":"@Test\n    public void testListener_Text()\n    {\n        ListenerBasicSocket socket = new ListenerBasicSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(WebSocketFrame.text(\"Hello World\"));\n        driver.onFrame(new CloseInfo(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketText(\\\"Hello World\\\")\");\n        socket.capture.assertEventStartsWith(2,\"onWebSocketClose(1000,\");\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAnnotated_ByteArray()\n    {\n        AnnotatedBinaryArraySocket socket = new AnnotatedBinaryArraySocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEvent(1,\"onBinary([11],0,11)\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","id":77688,"modified_method":"@Test\n    public void testAnnotated_ByteArray()\n    {\n        AnnotatedBinaryArraySocket socket = new AnnotatedBinaryArraySocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(new CloseInfo(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEvent(1,\"onBinary([11],0,11)\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAnnotated_InputStream()\n    {\n        AnnotatedBinaryStreamSocket socket = new AnnotatedBinaryStreamSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEventRegex(1,\"^onBinary\\\\(.*InputStream.*\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","id":77689,"modified_method":"@Test\n    public void testAnnotated_InputStream()\n    {\n        AnnotatedBinaryStreamSocket socket = new AnnotatedBinaryStreamSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(makeBinaryFrame(\"Hello World\",true));\n        driver.onFrame(new CloseInfo(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(3);\n        socket.capture.assertEventStartsWith(0,\"onConnect\");\n        socket.capture.assertEventRegex(1,\"^onBinary\\\\(.*InputStream.*\");\n        socket.capture.assertEventStartsWith(2,\"onClose(1000,\");\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testAdapter_ConnectClose()\n    {\n        AdapterConnectCloseSocket socket = new AdapterConnectCloseSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(FrameBuilder.close(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(2);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketClose\");\n    }","id":77690,"modified_method":"@Test\n    public void testAdapter_ConnectClose()\n    {\n        AdapterConnectCloseSocket socket = new AdapterConnectCloseSocket();\n        WebSocketEventDriver driver = newDriver(socket);\n\n        LocalWebSocketConnection conn = new LocalWebSocketConnection(testname);\n        driver.setConnection(conn);\n        driver.onConnect();\n        driver.onFrame(new CloseInfo(StatusCode.NORMAL).asFrame());\n\n        socket.capture.assertEventCount(2);\n        socket.capture.assertEventStartsWith(0,\"onWebSocketConnect\");\n        socket.capture.assertEventStartsWith(1,\"onWebSocketClose\");\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private WebSocketFrame setPayload(String str)\n    {\n        setPayload(BufferUtil.toBuffer(str,StringUtil.__UTF8_CHARSET));\n        return this;\n    }","id":77691,"modified_method":"public WebSocketFrame setPayload(String str)\n    {\n        setPayload(BufferUtil.toBuffer(str,StringUtil.__UTF8_CHARSET));\n        return this;\n    }","commit_id":"b46ba628cd8fea77d894f488513c532522d81c64","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testPutAndGetWithModel() throws Exception {\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint startEndpoint = context.getEndpoint(\"direct:start\");\n            Endpoint startWithModelEndpoint = context.getEndpoint(\"direct:start-with-model\");\n            Exchange putExchange = startEndpoint.createExchange(ExchangePattern.InOut);\n\n            int index = 1;\n            for (int row = 0; row < key.length; row++) {\n                for (int fam = 0; fam < family.length; fam++) {\n                    for (int col = 0; col < column[fam].length; col++) {\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(index), key[row]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(index), family[fam]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(index), column[fam][col]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_VALUE.asHeader(index++), body[row][fam][col]);\n                    }\n                }\n            }\n            putExchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            template.send(startEndpoint, putExchange);\n\n            Exchange getExchange = startWithModelEndpoint.createExchange(ExchangePattern.InOut);\n            getExchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            getExchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(startWithModelEndpoint, getExchange);\n\n            assertEquals(body[0][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n            assertEquals(body[0][1][2], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2)));\n        }\n    }","id":77692,"modified_method":"@Test\n    public void testPutAndGetWithModel() throws Exception {\n        if (systemReady) {\n            Map<String, Object> headers = new HashMap<String, Object>();\n            headers.put(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            int index = 1;\n            for (int row = 0; row < key.length; row++) {\n                for (int fam = 0; fam < family.length; fam++) {\n                    for (int col = 0; col < column[fam].length; col++) {\n                        headers.put(HbaseAttribute.HBASE_ROW_ID.asHeader(index), key[row]);\n                        headers.put(HbaseAttribute.HBASE_FAMILY.asHeader(index), family[fam]);\n                        headers.put(HbaseAttribute.HBASE_QUALIFIER.asHeader(index), column[fam][col]);\n                        headers.put(HbaseAttribute.HBASE_VALUE.asHeader(index++), body[row][fam][col]);\n                    }\n                }\n            }\n\n            template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n            Exchange resp = template.request(\"direct:start-with-model\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n                    exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n                }\n            });\n\n            assertEquals(body[0][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n            assertEquals(body[0][1][2], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2)));\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutAndGetMultiColumns() throws Exception {\n        testPutMultiColumns();\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint endpoint = context.getEndpoint(\"direct:start\");\n            Exchange exchange = endpoint.createExchange(ExchangePattern.InOut);\n            for (int col = 0; col < column[0].length; col++) {\n                exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(col + 1), key[0]);\n                exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(col + 1), family[0]);\n                exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(col + 1), column[0][col]);\n            }\n\n            exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(endpoint, exchange);\n            for (int col = 0; col < column[0].length; col++) {\n                assertEquals(body[0][col][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(col + 1)));\n            }\n        }\n    }","id":77693,"modified_method":"@Test\n    public void testPutAndGetMultiColumns() throws Exception {\n        testPutMultiColumns();\n        if (systemReady) {\n            Exchange resp = template.request(\"direct:start\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n                    for (int col = 0; col < column[0].length; col++) {\n                        exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(col + 1), key[0]);\n                        exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(col + 1), family[0]);\n                        exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(col + 1), column[0][col]);\n                    }\n                }\n            });\n\n            for (int col = 0; col < column[0].length; col++) {\n                assertEquals(body[0][col][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(col + 1)));\n            }\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutAndGet() throws Exception {\n        testPut();\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint endpoint = context.getEndpoint(\"direct:start\");\n            Exchange exchange = endpoint.createExchange(ExchangePattern.InOut);\n            exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n            exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n            exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(endpoint, exchange);\n            assertEquals(body[0][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n        }\n    }","id":77694,"modified_method":"@Test\n    public void testPutAndGet() throws Exception {\n        testPut();\n        if (systemReady) {\n            Exchange resp = template.request(\"direct:start\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n                    exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n                }\n            });\n\n            assertEquals(body[0][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutMultiRowsAndScan() throws Exception {\n        testPutMultiRows();\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint endpoint = context.getEndpoint(\"direct:scan\");\n\n            Exchange exchange = endpoint.createExchange(ExchangePattern.InOut);\n            exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n            exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n            Exchange resp = template.send(endpoint, exchange);\n            Object result1 = resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(1));\n            Object result2 = resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2));\n            Object result3 = resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(3));\n\n            List<?> bodies = Arrays.asList(body[0][0][0], body[1][0][0], body[2][0][0]);\n            assertTrue(bodies.contains(result1) && bodies.contains(result2) && bodies.contains(result3));\n        }\n    }","id":77695,"modified_method":"@Test\n    public void testPutMultiRowsAndScan() throws Exception {\n        testPutMultiRows();\n        if (systemReady) {\n            Exchange resp = template.request(\"direct:scan\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n                }\n            });\n\n            Object result1 = resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(1));\n            Object result2 = resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2));\n            Object result3 = resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(3));\n\n            List<?> bodies = Arrays.asList(body[0][0][0], body[1][0][0], body[2][0][0]);\n            assertTrue(bodies.contains(result1) && bodies.contains(result2) && bodies.contains(result3));\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutAndGetMultiRows() throws Exception {\n        testPutMultiRows();\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint endpoint = context.getEndpoint(\"direct:start\");\n            Exchange exchange = endpoint.createExchange(ExchangePattern.InOut);\n            for (int row = 0; row < key.length; row++) {\n                exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(row + 1), key[row]);\n                exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(row + 1), family[0]);\n                exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(row + 1), column[0][0]);\n            }\n            exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(endpoint, exchange);\n            for (int row = 0; row < key.length; row++) {\n                assertEquals(body[row][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(row + 1)));\n            }\n        }\n    }","id":77696,"modified_method":"@Test\n    public void testPutAndGetMultiRows() throws Exception {\n        testPutMultiRows();\n        if (systemReady) {\n            Exchange resp = template.request(\"direct:start\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n                    for (int row = 0; row < key.length; row++) {\n                        exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(row + 1), key[row]);\n                        exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(row + 1), family[0]);\n                        exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(row + 1), column[0][0]);\n                    }\n                }\n            });\n\n            for (int row = 0; row < key.length; row++) {\n                assertEquals(body[row][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(row + 1)));\n            }\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutMultiColumns() throws Exception {\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Map<String, Object> headers = new HashMap<String, Object>();\n\n            for (int col = 0; col < column[0].length; col++) {\n                headers.put(HbaseAttribute.HBASE_ROW_ID.asHeader(col + 1), key[0]);\n                headers.put(HbaseAttribute.HBASE_FAMILY.asHeader(col + 1), family[0]);\n                headers.put(HbaseAttribute.HBASE_QUALIFIER.asHeader(col + 1), column[0][col]);\n                headers.put(HbaseAttribute.HBASE_VALUE.asHeader(col + 1), body[0][col][0]);\n            }\n\n            headers.put(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n            Configuration configuration = hbaseUtil.getHBaseAdmin().getConfiguration();\n            HTable bar = new HTable(configuration, PERSON_TABLE.getBytes());\n\n            for (int col = 0; col < column[0].length; col++) {\n                Get get = new Get(key[0].getBytes());\n                get.addColumn(family[0].getBytes(), column[0][col].getBytes());\n                Result result = bar.get(get);\n                byte[] resultValue = result.value();\n                assertArrayEquals(body[0][col][0].getBytes(), resultValue);\n            }\n\n            IOHelper.close(bar);\n        }\n    }","id":77697,"modified_method":"@Test\n    public void testPutMultiColumns() throws Exception {\n        if (systemReady) {\n            Map<String, Object> headers = new HashMap<String, Object>();\n            headers.put(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            for (int col = 0; col < column[0].length; col++) {\n                headers.put(HbaseAttribute.HBASE_ROW_ID.asHeader(col + 1), key[0]);\n                headers.put(HbaseAttribute.HBASE_FAMILY.asHeader(col + 1), family[0]);\n                headers.put(HbaseAttribute.HBASE_QUALIFIER.asHeader(col + 1), column[0][col]);\n                headers.put(HbaseAttribute.HBASE_VALUE.asHeader(col + 1), body[0][col][0]);\n            }\n\n            template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n            Configuration configuration = hbaseUtil.getHBaseAdmin().getConfiguration();\n            HTable bar = new HTable(configuration, PERSON_TABLE.getBytes());\n\n            for (int col = 0; col < column[0].length; col++) {\n                Get get = new Get(key[0].getBytes());\n                get.addColumn(family[0].getBytes(), column[0][col].getBytes());\n                Result result = bar.get(get);\n                byte[] resultValue = result.value();\n                assertArrayEquals(body[0][col][0].getBytes(), resultValue);\n            }\n\n            IOHelper.close(bar);\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutAndGetAndDeleteMultiRows() throws Exception {\n        testPutMultiRows();\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint endpoint = context.getEndpoint(\"direct:start\");\n\n            Exchange exchange1 = endpoint.createExchange(ExchangePattern.InOnly);\n            exchange1.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            exchange1.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.DELETE);\n            template.send(endpoint, exchange1);\n\n            Exchange exchange2 = endpoint.createExchange(ExchangePattern.InOut);\n            exchange2.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            exchange2.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n            exchange2.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n\n            exchange2.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(2), key[1]);\n            exchange2.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(2), family[0]);\n            exchange2.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(2), column[0][0]);\n            exchange2.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(endpoint, exchange2);\n            assertEquals(null, resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n            assertEquals(body[1][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2)));\n        }\n    }","id":77698,"modified_method":"@Test\n    public void testPutAndGetAndDeleteMultiRows() throws Exception {\n        testPutMultiRows();\n        if (systemReady) {\n            Map<String, Object> headers = new HashMap<String, Object>();\n            headers.put(HBaseConstants.OPERATION, HBaseConstants.DELETE);\n            headers.put(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n            Exchange resp = template.request(\"direct:start\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(2), key[1]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(2), family[0]);\n                    exchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(2), column[0][0]);\n                }\n            });\n\n            assertEquals(null, resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n            assertEquals(body[1][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2)));\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPutMultiRows() throws Exception {\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Map<String, Object> headers = new HashMap<String, Object>();\n\n            for (int row = 0; row < key.length; row++) {\n                headers.put(HbaseAttribute.HBASE_ROW_ID.asHeader(row + 1), key[row]);\n                headers.put(HbaseAttribute.HBASE_FAMILY.asHeader(row + 1), family[0]);\n                headers.put(HbaseAttribute.HBASE_QUALIFIER.asHeader(row + 1), column[0][0]);\n                headers.put(HbaseAttribute.HBASE_VALUE.asHeader(row + 1), body[row][0][0]);\n            }\n\n            headers.put(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n            Configuration configuration = hbaseUtil.getHBaseAdmin().getConfiguration();\n            HTable bar = new HTable(configuration, PERSON_TABLE.getBytes());\n\n            //Check row 1\n            for (int row = 0; row < key.length; row++) {\n                Get get = new Get(key[row].getBytes());\n                get.addColumn(family[0].getBytes(), column[0][0].getBytes());\n                Result result = bar.get(get);\n                byte[] resultValue = result.value();\n                assertArrayEquals(body[row][0][0].getBytes(), resultValue);\n            }\n\n            IOHelper.close(bar);\n        }\n    }","id":77699,"modified_method":"@Test\n    public void testPutMultiRows() throws Exception {\n        if (systemReady) {\n            Map<String, Object> headers = new HashMap<String, Object>();\n            headers.put(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            for (int row = 0; row < key.length; row++) {\n                headers.put(HbaseAttribute.HBASE_ROW_ID.asHeader(row + 1), key[row]);\n                headers.put(HbaseAttribute.HBASE_FAMILY.asHeader(row + 1), family[0]);\n                headers.put(HbaseAttribute.HBASE_QUALIFIER.asHeader(row + 1), column[0][0]);\n                headers.put(HbaseAttribute.HBASE_VALUE.asHeader(row + 1), body[row][0][0]);\n            }\n\n            template.sendBodyAndHeaders(\"direct:start\", null, headers);\n\n            Configuration configuration = hbaseUtil.getHBaseAdmin().getConfiguration();\n            HTable bar = new HTable(configuration, PERSON_TABLE.getBytes());\n\n            //Check row 1\n            for (int row = 0; row < key.length; row++) {\n                Get get = new Get(key[row].getBytes());\n                get.addColumn(family[0].getBytes(), column[0][0].getBytes());\n                Result result = bar.get(get);\n                byte[] resultValue = result.value();\n                assertArrayEquals(body[row][0][0].getBytes(), resultValue);\n            }\n\n            IOHelper.close(bar);\n        }\n    }","commit_id":"5e97f9238fc292cc6fde3d75d8b98d4b26b7e66d","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(DIALOG_TYPE);\n        // set the publishing type: publish project or direct publish\n       \n        if (CmsStringUtil.isNotEmpty(getParamResource())) {\n            setParamDirectpublish(\"true\");\n        }\n        // set the action for the JSP switch \n        if (DIALOG_CONFIRMED.equals(getParamAction())) {\n            if (showUnlockConfirmation()) {\n                // show unlock confirmation dialog\n                setAction(ACTION_UNLOCK_CONFIRMATION);\n            } else {\n                // skip unlock confirmation dialog\n                setAction(ACTION_CONFIRMED);\n            }\n        } else if (DIALOG_UNLOCK_CONFIRMED.equals(getParamAction())) {\n            setAction(ACTION_CONFIRMED);\n        } else if (REPORT_UPDATE.equals(getParamAction())) {\n            setAction(ACTION_REPORT_UPDATE);\n        } else if (REPORT_BEGIN.equals(getParamAction())) {\n            setAction(ACTION_REPORT_BEGIN);\n        } else if (REPORT_END.equals(getParamAction())) {\n            if (\"true\".equals(getParamThreadHasNext())) {\n                // after the link check start the publish thread\n                startPublishThread();\n\n                setParamAction(REPORT_UPDATE);\n                setAction(ACTION_REPORT_UPDATE);\n            } else {\n                // ends the publish thread\n                setAction(ACTION_REPORT_END);\n            }\n        } else if (DIALOG_CANCEL.equals(getParamAction())) {\n            setAction(ACTION_CANCEL);\n        } else {\n            setAction(ACTION_DEFAULT);\n            // set parameters depending on publishing type\n            if (\"true\".equals(getParamDirectpublish())) {\n                // check the required permissions to publish the resource directly     \n                if (! checkResourcePermissions(CmsPermissionSet.ACCESS_DIRECT_PUBLISH, false)) {\n                    // no publish permissions for the resource, set cancel action to close dialog\n                    setAction(ACTION_CANCEL);\n                    return;\n                }\n                // determine resource name, last modified date and last modified user of resource\n                computePublishResource();\n                // add the title for the direct publish dialog \n                setParamTitle(key(\"messagebox.title.publishresource\") + \": \" + getParamResourcename());\n            } else {\n                // add the title for the publish project dialog \n                setParamTitle(key(\"project.publish.title\"));\n                // determine the project id and name for publishing\n                computePublishProject();\n                // determine target to close the report\n            }\n        }\n    }","id":77700,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(DIALOG_TYPE);\n        // set the publishing type: publish project or direct publish\n       \n        if (CmsStringUtil.isNotEmpty(getParamResource())) {\n            setParamDirectpublish(String.valueOf(true));\n        }\n        // set the action for the JSP switch \n        if (DIALOG_CONFIRMED.equals(getParamAction())) {\n            if (showUnlockConfirmation()) {\n                // show unlock confirmation dialog\n                setAction(ACTION_UNLOCK_CONFIRMATION);\n            } else {\n                // skip unlock confirmation dialog\n                setAction(ACTION_CONFIRMED);\n            }\n        } else if (DIALOG_UNLOCK_CONFIRMED.equals(getParamAction())) {\n            setAction(ACTION_CONFIRMED);\n        } else if (REPORT_UPDATE.equals(getParamAction())) {\n            setAction(ACTION_REPORT_UPDATE);\n        } else if (REPORT_BEGIN.equals(getParamAction())) {\n            setAction(ACTION_REPORT_BEGIN);\n        } else if (REPORT_END.equals(getParamAction())) {\n            if (Boolean.valueOf(getParamThreadHasNext()).booleanValue()) {\n                // after the link check start the publish thread\n                startPublishThread();\n\n                setParamAction(REPORT_UPDATE);\n                setAction(ACTION_REPORT_UPDATE);\n            } else {\n                // ends the publish thread\n                setAction(ACTION_REPORT_END);\n            }\n        } else if (DIALOG_CANCEL.equals(getParamAction())) {\n            setAction(ACTION_CANCEL);\n        } else {\n            setAction(ACTION_DEFAULT);\n            // set parameters depending on publishing type\n            if (Boolean.valueOf(getParamDirectpublish()).booleanValue()) {\n                // check the required permissions to publish the resource directly\n                if (!getCms().isManagerOfProject()\n                    && !checkResourcePermissions(CmsPermissionSet.ACCESS_DIRECT_PUBLISH, false)) {\n                    // no publish permissions for the resource, set cancel action to close dialog\n                    setAction(ACTION_CANCEL);\n                    return;\n                }\n                // determine resource name, last modified date and last modified user of resource\n                computePublishResource();\n                // add the title for the direct publish dialog \n                setParamTitle(key(\"messagebox.title.publishresource\") + \": \" + getParamResourcename());\n            } else {\n                // add the title for the publish project dialog \n                setParamTitle(key(\"project.publish.title\"));\n                // determine the project id and name for publishing\n                computePublishProject();\n                // determine target to close the report\n            }\n        }\n    }","commit_id":"cd7bd7a080ec09977415d2665f6d5b69bd29df51","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the editor action for a \"cancel\" button.<p>\n     * \n     * This overwrites the cancel method of the CmsDialog class.<p>\n     * \n     * Always use this value, do not write anything directly in the html page.<p>\n     * \n     * @return the default action for a \"cancel\" button\n     */\n    public String buttonActionCancel() {\n        String target = OpenCms.getLinkManager().substituteLink(getCms(), CmsWorkplaceAction.C_JSP_WORKPLACE_URI);\n        return \"onClick=\\\"top.location.href='\" + target + \"';\\\"\";\n    }","id":77701,"modified_method":"/**\n     * Returns the editor action for a \"cancel\" button.<p>\n     * \n     * This overwrites the cancel method of the CmsDialog class.<p>\n     * \n     * Always use this value, do not write anything directly in the html page.<p>\n     * \n     * @return the default action for a \"cancel\" button\n     */\n    public String buttonActionCancel() {\n        String target = null;\n        if (\"true\".equals(getParamDirectedit())) {\n            // editor is in direct edit mode\n            if (!\"\".equals(getParamBacklink())) {\n                // set link to the specified back link target\n                target = getParamBacklink();\n            } else {\n                // set link to the edited resource\n                target = getParamResource();\n            }\n        } else {\n            // in workplace mode, show explorer view\n            target = OpenCms.getLinkManager().substituteLink(getCms(), CmsWorkplaceAction.C_JSP_WORKPLACE_URI);\n        }\n        return \"onclick=\\\"top.location.href='\" + getJsp().link(target) + \"';\\\"\";\n    }","commit_id":"bff85dfd6a0efe59ee569132dc8a1dc028532201","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.editor.I_CmsEditorHandler#getEditorUri(java.lang.String, CmsJspActionElement)\n     */\n    public String getEditorUri(String resource, CmsJspActionElement jsp) {\n        // first try to get the \"edit as text\" and \"load default\" parameters from the request\n        boolean editAsText = \"true\".equals(jsp.getRequest().getParameter(CmsEditor.PARAM_EDITASTEXT));\n        boolean loadDefault = \"true\".equals(jsp.getRequest().getParameter(CmsEditor.PARAM_LOADDEFAULT));\n        // initialize resource type with -1 (unknown resource type)\n        int resTypeId = -1;\n        String resourceType = \"\";\n        if (editAsText) {\n            // the resource should be treated as text, set the plain resource id\n            resTypeId = CmsResourceTypePlain.C_RESOURCE_TYPE_ID;\n        } else {\n            try {\n                // get the resource type id of the edited resource\n                CmsResource res = jsp.getCmsObject().readFileHeader(resource, CmsResourceFilter.ALL);\n                resTypeId = res.getType();\n            } catch (CmsException e) {\n                // resource could not be read, show error dialog\n                return showErrorDialog(jsp, e);\n            }\n        }\n        \n        try {\n            // get the resource type name\n            resourceType = jsp.getCmsObject().getResourceType(resTypeId).getResourceTypeName();\n        } catch (CmsException e) {\n            // resource type name can not be determined, show error dialog\n            return showErrorDialog(jsp, e);\n        }\n        \n        // get the editor URI from the editor manager\n        String editorUri = null;\n        \n        // get the browser identification from the request\n        String userAgent = jsp.getRequest().getHeader(\"user-agent\");\n        \n        if (loadDefault) {\n            // get default editor because loaddefault parameter was found\n            editorUri = OpenCms.getWorkplaceManager().getWorkplaceEditorManager().getDefaultEditorUri(jsp.getRequestContext(), resourceType, userAgent);        \n        } else {\n            // get preferred editor\n            editorUri = OpenCms.getWorkplaceManager().getWorkplaceEditorManager().getEditorUri(jsp.getRequestContext(), resourceType, userAgent);\n        }\n        \n        try {\n            // check the presence of the editor\n            jsp.getCmsObject().readFileHeader(editorUri);\n        } catch (CmsException e) {\n            // preferred or selected editor not found, try default editor\n            editorUri = OpenCms.getWorkplaceManager().getWorkplaceEditorManager().getDefaultEditorUri(jsp.getRequestContext(), resourceType, userAgent);\n        }\n        \n        if (editorUri == null) {\n            // no valid editor was found, show the error dialog\n            return showErrorDialog(jsp, null);\n        }\n        return editorUri;\n    }","id":77702,"modified_method":"/**\n     * @see org.opencms.workplace.editor.I_CmsEditorHandler#getEditorUri(java.lang.String, CmsJspActionElement)\n     */\n    public String getEditorUri(String resource, CmsJspActionElement jsp) {\n        // first try to get the \"edit as text\" and \"load default\" parameters from the request\n        boolean editAsText = Boolean.valueOf(jsp.getRequest().getParameter(CmsEditor.PARAM_EDITASTEXT)).booleanValue();\n        boolean loadDefault = Boolean.valueOf(jsp.getRequest().getParameter(CmsEditor.PARAM_LOADDEFAULT)).booleanValue();\n        // initialize resource type with -1 (unknown resource type)\n        int resTypeId = -1;\n        String resourceType = \"\";\n        if (editAsText) {\n            // the resource should be treated as text, set the plain resource id\n            resTypeId = CmsResourceTypePlain.C_RESOURCE_TYPE_ID;\n        } else {\n            try {\n                // get the resource type id of the edited resource\n                CmsResource res = jsp.getCmsObject().readFileHeader(resource, CmsResourceFilter.ALL);\n                resTypeId = res.getType();\n            } catch (CmsException e) {\n                // resource could not be read, show error dialog\n                return showErrorDialog(jsp, e);\n            }\n        }\n        \n        try {\n            // get the resource type name\n            resourceType = jsp.getCmsObject().getResourceType(resTypeId).getResourceTypeName();\n        } catch (CmsException e) {\n            // resource type name can not be determined, show error dialog\n            return showErrorDialog(jsp, e);\n        }\n        \n        // get the editor URI from the editor manager\n        String editorUri = null;\n        \n        // get the browser identification from the request\n        String userAgent = jsp.getRequest().getHeader(\"user-agent\");\n        \n        if (loadDefault) {\n            // get default editor because loaddefault parameter was found\n            editorUri = OpenCms.getWorkplaceManager().getWorkplaceEditorManager().getDefaultEditorUri(jsp.getRequestContext(), resourceType, userAgent);        \n        } else {\n            // get preferred editor\n            editorUri = OpenCms.getWorkplaceManager().getWorkplaceEditorManager().getEditorUri(jsp.getRequestContext(), resourceType, userAgent);\n        }\n        \n        try {\n            // check the presence of the editor\n            jsp.getCmsObject().readFileHeader(editorUri);\n        } catch (Throwable t) {\n            // preferred or selected editor not found, try default editor\n            editorUri = OpenCms.getWorkplaceManager().getWorkplaceEditorManager().getDefaultEditorUri(jsp.getRequestContext(), resourceType, userAgent);\n        }\n        \n        if (editorUri == null) {\n            // no valid editor was found, show the error dialog\n            return showErrorDialog(jsp, null);\n        }\n        return editorUri;\n    }","commit_id":"bff85dfd6a0efe59ee569132dc8a1dc028532201","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the move report, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionReport() throws JspException {\n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        switch (getAction()) {\n            case ACTION_CONFIRMED:\n            default:\n                Map eventData = (Map) new HashMap();\n                CmsEvent event=new CmsEvent(getJsp().getCmsObject(), I_CmsEventListener.EVENT_WORKPLACE_UPDATE, eventData);\n                OpenCms.fireCmsEvent(event);\n                CmsStaticExportThread thread = new CmsStaticExportThread(getCms());\n                setParamAction(DIALOG_CANCEL);\n                setParamThread(thread.getId().toString());\n                //getJsp().include(C_FILE_REPORT_OUTPUT);  \n                break;\n        }\n    }","id":77703,"modified_method":"/**\n     * Performs the move report, will be called by the JSP page.<p>\n     */\n    public void actionReport() {\n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        switch (getAction()) {\n            case ACTION_CONFIRMED:\n            default:\n                Map eventData = (Map) new HashMap();\n                CmsEvent event=new CmsEvent(getJsp().getCmsObject(), I_CmsEventListener.EVENT_WORKPLACE_UPDATE, eventData);\n                OpenCms.fireCmsEvent(event);\n                CmsStaticExportThread thread = new CmsStaticExportThread(getCms());\n                setParamAction(DIALOG_CANCEL);\n                setParamThread(thread.getId().toString());\n                //getJsp().include(C_FILE_REPORT_OUTPUT);  \n                break;\n        }\n    }","commit_id":"bff85dfd6a0efe59ee569132dc8a1dc028532201","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the exit editor action.<p>\n     * \n     * @see org.opencms.workplace.editor.CmsEditor#actionExit()\n     */\n    public void actionExit() throws IOException {    \n        if (getAction() == ACTION_CANCEL) {\n            // save and exit was canceled\n            return;\n        }\n        // redirect to the workplace explorer view\n        getJsp().getResponse().sendRedirect(getJsp().link(CmsWorkplaceAction.C_JSP_WORKPLACE_URI));\n    }","id":77704,"modified_method":"/**\n     * Performs the exit editor action.<p>\n     * \n     * @see org.opencms.workplace.editor.CmsEditor#actionExit()\n     */\n    public void actionExit() throws IOException, JspException {    \n        if (getAction() == ACTION_CANCEL) {\n            // save and exit was canceled\n            return;\n        }\n        // close the editor\n        actionClose();\n    }","commit_id":"bff85dfd6a0efe59ee569132dc8a1dc028532201","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the publish report, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionReport() throws JspException {        \n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        switch (getAction()) {\n            case ACTION_REPORT_END:\n                actionCloseDialog();\n                break;\n            case ACTION_REPORT_UPDATE:\n                setParamAction(REPORT_UPDATE);   \n                getJsp().include(C_FILE_REPORT_OUTPUT);  \n                break;\n            case ACTION_REPORT_BEGIN:\n            case ACTION_CONFIRMED:\n            default:\n                try {\n                    CmsResource publishResource = null;\n                    \n                    if (\"true\".equalsIgnoreCase(getParamDirectpublish())) {\n                        // get the offline resource in direct publish mode\n                        publishResource = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n                        // check if the resource is locked in direct publish mode                     \n                        org.opencms.lock.CmsLock lock = getCms().getLock(publishResource);\n                        if (!lock.isNullLock()) {\n                            // resource is locked, so unlock it\n                            getCms().unlockResource(getParamResource());\n                        }  \n                    }\n                    \n                    if (showUnlockConfirmation()) {   \n                        // some resources are locked, unlock them before publishing                                 \n                        if (\"true\".equals(getParamDirectpublish())) {\n                            // unlock subresources of a folder\n                            String folderName = getParamResource();\n                            if (!folderName.endsWith(\"/\")) {\n                                folderName += \"/\";\n                            }\n                            getCms().lockResource(folderName);\n                            getCms().unlockResource(folderName);\n                        } else {\n                            // unlock all project resources\n                            getCms().unlockProject(Integer.parseInt(getParamProjectid()));                               \n                        }                         \n                    }\n                    \n                    // start the link validation thread before publishing\n                    CmsHtmlLinkValidatorThread thread = new CmsHtmlLinkValidatorThread(getCms(), publishResource, \"true\".equals(getParamPublishsiblings()), getSettings());\n                    setParamAction(REPORT_BEGIN);\n                    setParamThread(thread.getId().toString());\n                    \n                    // set the flag that another thread is following\n                    setParamThreadHasNext(\"true\");\n                    // set the key name for the continue checkbox\n                    setParamReportContinueKey(\"label.button.continue.brokenlinks\");\n                    getJsp().include(C_FILE_REPORT_OUTPUT); \n                    \n                } catch (CmsException e) {\n                    // error while unlocking resources, show error screen\n                    setParamErrorstack(e.getStackTraceAsString());\n                    setParamMessage(key(\"error.message.projectlockchange\"));\n                    setParamReasonSuggestion(key(\"error.reason.projectlockchange\") + \"<br>\\n\" + key(\"error.suggestion.projectlockchange\"));\n                    getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n                }                         \n        }\n    }","id":77705,"modified_method":"/**\n     * Performs the publish report, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionReport() throws JspException {        \n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        switch (getAction()) {\n            case ACTION_REPORT_END:\n                actionCloseDialog();\n                break;\n            case ACTION_REPORT_UPDATE:\n                setParamAction(REPORT_UPDATE);   \n                getJsp().include(C_FILE_REPORT_OUTPUT);  \n                break;\n            case ACTION_REPORT_BEGIN:\n            case ACTION_CONFIRMED:\n            default:\n                try {\n                    CmsResource publishResource = null;\n                    boolean directPublish = Boolean.valueOf(getParamDirectpublish()).booleanValue();\n                    \n                    if (directPublish) {\n                        // get the offline resource in direct publish mode\n                        publishResource = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n                        // check if the resource is locked in direct publish mode                     \n                        CmsLock lock = getCms().getLock(publishResource);\n                        if (!lock.isNullLock()) {\n                            // resource is locked, so unlock it\n                            getCms().unlockResource(getParamResource());\n                        }  \n                    }\n                    \n                    if (showUnlockConfirmation()) {   \n                        // some resources are locked, unlock them before publishing                                 \n                        if (directPublish) {\n                            // unlock subresources of a folder\n                            String folderName = getParamResource();\n                            if (!folderName.endsWith(\"/\")) {\n                                folderName += \"/\";\n                            }\n                            getCms().lockResource(folderName);\n                            getCms().unlockResource(folderName);\n                        } else {\n                            // unlock all project resources\n                            getCms().unlockProject(Integer.parseInt(getParamProjectid()));                               \n                        }                         \n                    }\n                    \n                    // start the link validation thread before publishing\n                    CmsHtmlLinkValidatorThread thread = new CmsHtmlLinkValidatorThread(getCms(), publishResource, \"true\".equals(getParamPublishsiblings()), getSettings());\n                    setParamAction(REPORT_BEGIN);\n                    setParamThread(thread.getId().toString());\n                    \n                    // set the flag that another thread is following\n                    setParamThreadHasNext(\"true\");\n                    // set the key name for the continue checkbox\n                    setParamReportContinueKey(\"label.button.continue.brokenlinks\");\n                    getJsp().include(C_FILE_REPORT_OUTPUT); \n                    \n                } catch (CmsException e) {\n                    // error while unlocking resources, show error screen\n                    setParamErrorstack(e.getStackTraceAsString());\n                    setParamMessage(key(\"error.message.projectlockchange\"));\n                    setParamReasonSuggestion(key(\"error.reason.projectlockchange\") + \"<br>\\n\" + key(\"error.suggestion.projectlockchange\"));\n                    getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n                }                         \n        }\n    }","commit_id":"1a1c4849c079ec87318f28ba949fa77757e27698","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Starts the publish thread for the project or a resource.<p>\n     * \n     * The type of publish thread is determined by the value of the \"directpublish\" parameter.<p>\n     */\n    private void startPublishThread() {\n        // start different publish threads for direct publish and publish project  \n        CmsPublishThread thread = null;\n        CmsPublishList publishList = null;              \n\n        publishList = getSettings().getPublishList();\n        \n        if (publishList != null) {\n            thread = new CmsPublishThread(getCms(), publishList);\n        } else {\n            // TODO check if the following code can be removed\n            \n            if (\"true\".equals(getParamDirectpublish())) {\n                // publish resource directly\n                thread = new CmsPublishThread(getCms(), getParamResource(), \"true\".equals(getParamPublishsiblings()), getSettings());\n            } else {\n                try {\n                    // switch to project which will be published\n                    int projectId = Integer.parseInt(getParamProjectid());\n                    getCms().getRequestContext().setCurrentProject(getCms().readProject(projectId));\n                } catch (Exception e) {\n                    OpenCms.getLog(this).error(\"Error switching project for publishing\", e);\n                }\n                thread = new CmsPublishThread(getCms());\n            }\n        }\n        \n        // set the new thread id and flag that no thread is following\n        setParamThread(thread.getId().toString());\n        setParamThreadHasNext(\"false\");\n        \n        // start the publish thread\n        thread.start();\n    }","id":77706,"modified_method":"/**\n     * Starts the publish thread for the project or a resource.<p>\n     * \n     * The type of publish thread is determined by the value of the \"directpublish\" parameter.<p>\n     */\n    private void startPublishThread() {\n        // create a publish thread from the current publish list\n        CmsPublishList publishList = getSettings().getPublishList();\n        CmsPublishThread thread = new CmsPublishThread(getCms(), publishList);\n        \n        // set the new thread id and flag that no thread is following\n        setParamThread(thread.getId().toString());\n        setParamThreadHasNext(\"false\");\n        \n        // start the publish thread\n        thread.start();\n    }","commit_id":"1a1c4849c079ec87318f28ba949fa77757e27698","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if the unlock confirmation dialog should be displayed.<p>\n     * \n     * @return true if some resources of the project are locked, otherwise false \n     */\n    private boolean showUnlockConfirmation() {\n        try {\n            if (\"true\".equals(getParamDirectpublish())) {\n                // direct publish: check sub resources of a folder\n                CmsResource res = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n                if (res.getState() != I_CmsConstants.C_STATE_DELETED && res.isFolder()) {\n                    return (getCms().countLockedResources(getParamResource()) > 0);\n                }               \n            } else {\n                // publish project: check all project resources\n                int id = Integer.parseInt(getParamProjectid());\n                return (getCms().countLockedResources(id) > 0);\n            }\n        } catch (CmsException e) {\n            OpenCms.getLog(this).error(\"Error displaying unlock confirmation\", e);\n        }\n        return false;\n    }","id":77707,"modified_method":"/**\n     * Checks if the unlock confirmation dialog should be displayed.<p>\n     * \n     * @return true if some resources of the project are locked, otherwise false \n     */\n    private boolean showUnlockConfirmation() {\n        try {\n            if (Boolean.valueOf(getParamDirectpublish()).booleanValue()) {\n                // direct publish: check sub resources of a folder\n                CmsResource res = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n                if (res.getState() != I_CmsConstants.C_STATE_DELETED && res.isFolder()) {\n                    return (getCms().countLockedResources(getParamResource()) > 0);\n                }               \n            } else {\n                // publish project: check all project resources\n                int id = Integer.parseInt(getParamProjectid());\n                return (getCms().countLockedResources(id) > 0);\n            }\n        } catch (CmsException e) {\n            OpenCms.getLog(this).error(\"Error displaying unlock confirmation\", e);\n        }\n        return false;\n    }","commit_id":"1a1c4849c079ec87318f28ba949fa77757e27698","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(DIALOG_TYPE);\n        // set the publishing type: publish project or direct publish\n        if (getParamResource() != null && !\"\".equals(getParamResource())) {\n            setParamDirectpublish(\"true\");\n        }       \n        // set the action for the JSP switch \n        if (DIALOG_CONFIRMED.equals(getParamAction())) {\n            if (showUnlockConfirmation()) {\n                // show unlock confirmation dialog\n                setAction(ACTION_UNLOCK_CONFIRMATION);\n            } else {\n                // skip unlock confirmation dialog\n                setAction(ACTION_CONFIRMED);\n            }\n        } else if (DIALOG_UNLOCK_CONFIRMED.equals(getParamAction())) {\n            setAction(ACTION_CONFIRMED);   \n        } else if (REPORT_UPDATE.equals(getParamAction())) {\n            setAction(ACTION_REPORT_UPDATE);         \n        } else if (REPORT_BEGIN.equals(getParamAction())) {\n            setAction(ACTION_REPORT_BEGIN);\n        } else if (REPORT_END.equals(getParamAction())) {\n            if (\"true\".equals(getParamThreadHasNext())) {\n                // after the link check start the publish thread\n                startPublishThread();\n                setParamAction(REPORT_UPDATE);\n                setAction(ACTION_REPORT_UPDATE);\n            } else {\n                // ends the publish thread\n                setAction(ACTION_REPORT_END);\n            }\n        } else if (DIALOG_CANCEL.equals(getParamAction())) {          \n            setAction(ACTION_CANCEL);\n        } else {                        \n            setAction(ACTION_DEFAULT);\n            // set parameters depending on publishing type\n            if (\"true\".equals(getParamDirectpublish())) {\n                // determine resource name, last modified date and last modified user of resource\n                computePublishResource();\n                // add the title for the direct publish dialog \n                setParamTitle(key(\"messagebox.title.publishresource\") + \": \" + getParamResourcename());\n            } else {\n                // add the title for the publish project dialog \n                setParamTitle(key(\"project.publish.title\"));\n                // determine the project id and name for publishing\n                computePublishProject(); \n                // determine target to close the report\n            }\n        }                 \n    }","id":77708,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(DIALOG_TYPE);\n        // set the publishing type: publish project or direct publish\n        if (! CmsStringUtil.isEmpty(getParamResource())) {\n            setParamDirectpublish(\"true\");\n        }       \n        // set the action for the JSP switch \n        if (DIALOG_CONFIRMED.equals(getParamAction())) {\n            if (showUnlockConfirmation()) {\n                // show unlock confirmation dialog\n                setAction(ACTION_UNLOCK_CONFIRMATION);\n            } else {\n                // skip unlock confirmation dialog\n                setAction(ACTION_CONFIRMED);\n            }\n        } else if (DIALOG_UNLOCK_CONFIRMED.equals(getParamAction())) {\n            setAction(ACTION_CONFIRMED);   \n        } else if (REPORT_UPDATE.equals(getParamAction())) {\n            setAction(ACTION_REPORT_UPDATE);         \n        } else if (REPORT_BEGIN.equals(getParamAction())) {\n            setAction(ACTION_REPORT_BEGIN);\n        } else if (REPORT_END.equals(getParamAction())) {\n            if (\"true\".equals(getParamThreadHasNext())) {\n                // after the link check start the publish thread\n                startPublishThread();\n                setParamAction(REPORT_UPDATE);\n                setAction(ACTION_REPORT_UPDATE);\n            } else {\n                // ends the publish thread\n                setAction(ACTION_REPORT_END);\n            }\n        } else if (DIALOG_CANCEL.equals(getParamAction())) {          \n            setAction(ACTION_CANCEL);\n        } else {                        \n            setAction(ACTION_DEFAULT);\n            // set parameters depending on publishing type\n            if (\"true\".equals(getParamDirectpublish())) {\n                // determine resource name, last modified date and last modified user of resource\n                computePublishResource();\n                // add the title for the direct publish dialog \n                setParamTitle(key(\"messagebox.title.publishresource\") + \": \" + getParamResourcename());\n            } else {\n                // add the title for the publish project dialog \n                setParamTitle(key(\"project.publish.title\"));\n                // determine the project id and name for publishing\n                computePublishProject(); \n                // determine target to close the report\n            }\n        }                 \n    }","commit_id":"1a1c4849c079ec87318f28ba949fa77757e27698","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see java.lang.Runnable#run()\n     */\n    public void run() {\n        try {\n            if (m_publishList != null) {\n                getReport().println(getReport().key(\"report.publish_resource_begin\"), I_CmsReport.C_FORMAT_HEADLINE);\n                getCms().publishProject(getReport(), m_publishList);\n                getReport().println(getReport().key(\"report.publish_resource_end\"), I_CmsReport.C_FORMAT_HEADLINE);                \n            } else {\n                // TODO: check if the following code can be removed\n                \n                if (m_resourceName != null) {\n                    // \"publish resource directly\" case\n                    getReport().println(getReport().key(\"report.publish_resource_begin\"), I_CmsReport.C_FORMAT_HEADLINE);\n                    getCms().publishResource(m_resourceName, m_directPublishSiblings, getReport());\n                    getReport().println(getReport().key(\"report.publish_resource_end\"), I_CmsReport.C_FORMAT_HEADLINE);\n                } else {\n                    // \"publish current project\" case\n                    getReport().println(getReport().key(\"report.publish_project_begin\"), I_CmsReport.C_FORMAT_HEADLINE);\n                    getCms().publishProject(getReport());\n                    getReport().println(getReport().key(\"report.publish_project_end\"), I_CmsReport.C_FORMAT_HEADLINE);\n                }\n            }\n        } catch (Exception e) {\n            getReport().println(e);\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error publishing project\", e);\n            }\n        } finally {\n            if (m_settings != null) {\n                // overwrite the publish list in any case with null\n                m_settings.setPublishList(null);\n            }           \n        }\n    }","id":77709,"modified_method":"/**\n     * @see java.lang.Runnable#run()\n     */\n    public void run() {\n        try {\n            getReport().println(getReport().key(\"report.publish_resource_begin\"), I_CmsReport.C_FORMAT_HEADLINE);\n            getCms().publishProject(getReport(), m_publishList);\n            getReport().println(getReport().key(\"report.publish_resource_end\"), I_CmsReport.C_FORMAT_HEADLINE);\n        } catch (Exception e) {\n            getReport().println(e);\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error publishing project\", e);\n            }\n        }\n    }","commit_id":"1a1c4849c079ec87318f28ba949fa77757e27698","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a Thread that publishes the Cms resources contained in the specified Cms publish \n     * list.<p>\n     * \n     * @param cms the current OpenCms context object\n     * @param publishList a Cms publish list\n     * @see org.opencms.file.CmsObject#getPublishList(org.opencms.file.CmsResource, boolean, I_CmsReport)\n     * @see org.opencms.file.CmsObject#getPublishList(I_CmsReport)\n     */\n    public CmsPublishThread(CmsObject cms, CmsPublishList publishList) {\n        super(cms, \"OpenCms: Publishing of resources in publish list\");\n        \n        m_resourceName = null;\n        m_directPublishSiblings = false;\n        m_publishList = publishList;  \n        \n        initHtmlReport(cms.getRequestContext().getLocale());\n    }","id":77710,"modified_method":"/**\n     * Creates a Thread that publishes the Cms resources contained in the specified Cms publish \n     * list.<p>\n     * \n     * @param cms the current OpenCms context object\n     * @param publishList a Cms publish list\n     * @see org.opencms.file.CmsObject#getPublishList(org.opencms.file.CmsResource, boolean, I_CmsReport)\n     * @see org.opencms.file.CmsObject#getPublishList(I_CmsReport)\n     */\n    public CmsPublishThread(CmsObject cms, CmsPublishList publishList) {\n        super(cms, \"OpenCms: Publishing of resources in publish list\");\n\n        m_publishList = publishList;          \n        initHtmlReport(cms.getRequestContext().getLocale());\n    }","commit_id":"1a1c4849c079ec87318f28ba949fa77757e27698","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Update the router and published address books using remote data from the\n     * subscribed address books listed in subscriptions.\n     * \n     * @param router\n     *            The router AddressBook. This is the address book read by\n     *            client applications.\n     * @param published\n     *            The published AddressBook. This address book is published on\n     *            the user's eepsite so that others may subscribe to it.\n     *            If non-null, overwrite with the new addressbook.\n     * @param subscriptions\n     *            A SubscriptionList listing the remote address books to update\n     *            from.\n     * @param log\n     *            The log to write changes and conflicts to.\n     * @since 0.8.6\n     */\n    public static void update(NamingService router, File published, SubscriptionList subscriptions, Log log) {\n        NamingService publishedNS = null;\n        Iterator<AddressBook> iter = subscriptions.iterator();\n        while (iter.hasNext()) {\n            // yes, the EepGet fetch() is done in next()\n            long start = System.currentTimeMillis();\n            AddressBook sub = iter.next();\n            long end = System.currentTimeMillis();\n            if (DEBUG && log != null)\n                log.append(\"Fetch of \" + sub.getLocation() + \" took \" + (end - start));\n            start = end;\n            int old = 0, nnew = 0, invalid = 0, conflict = 0;\n            for (Iterator<Map.Entry<String, String>> eIter = sub.iterator(); eIter.hasNext(); ) {\n                Map.Entry<String, String> entry = eIter.next();\n                String key = entry.getKey();\n                Destination oldDest = router.lookup(key);\n                try {\n                    if (oldDest == null) {\n                        if (AddressBook.isValidKey(key)) {\n                            Destination dest = new Destination(entry.getValue());\n                            boolean success = router.put(key, dest);\n                            if (log != null) {\n                                if (success)\n                                    log.append(\"New address \" + key +\n                                               \" added to address book. From: \" + sub.getLocation());\n                                else\n                                    log.append(\"Save to naming service \" + router + \" failed for new key \" + key);\n                            }\n                            // now update the published addressbook\n                            if (published != null) {\n                                if (publishedNS == null)\n                                    publishedNS = new SingleFileNamingService(I2PAppContext.getGlobalContext(), published.getAbsolutePath());\n                                success = publishedNS.putIfAbsent(key, dest);\n                                if (!success)\n                                    log.append(\"Save to published addressbook \" + published.getAbsolutePath() + \" failed for new key \" + key);\n                            }\n                            nnew++;\n                        } else if (log != null) {\n                            log.append(\"Bad hostname \" + key + \" from \"\n                                   + sub.getLocation());\n                            invalid++;\n                        }        \n                    } else if (DEBUG && log != null) {\n                        if (!oldDest.toBase64().equals(entry.getValue())) {\n                            log.append(\"Conflict for \" + key + \" from \"\n                                       + sub.getLocation()\n                                       + \". Destination in remote address book is \"\n                                       + entry.getValue());\n                            conflict++;\n                        } else {\n                            old++;\n                        }\n                    } else {\n                        old++;\n                    }\n                } catch (DataFormatException dfe) {\n                    if (log != null)\n                        log.append(\"Invalid b64 for\" + key + \" From: \" + sub.getLocation());\n                    invalid++;\n                }\n            }\n            if (DEBUG && log != null) {\n                log.append(\"Merge of \" + sub.getLocation() + \" into \" + router +\n                           \" took \" + (System.currentTimeMillis() - start) + \" ms with \" +\n                           nnew + \" new, \" +\n                           old + \" old, \" +\n                           invalid + \" invalid, \" +\n                           conflict + \" conflicts\");\n            }\n            sub.delete();\n        }\n    }","id":77711,"modified_method":"/**\n     * Update the router and published address books using remote data from the\n     * subscribed address books listed in subscriptions.\n     * Merging of the \"master\" addressbook is NOT supported.\n     * \n     * @param router\n     *            The NamingService to update, generally the root NamingService from the context.\n     *            client applications.\n     * @param published\n     *            The published AddressBook. This address book is published on\n     *            the user's eepsite so that others may subscribe to it.\n     *            May be null.\n     *            If non-null, overwrite with the new addressbook.\n     * @param subscriptions\n     *            A SubscriptionList listing the remote address books to update\n     *            from.\n     * @param log\n     *            The log to write changes and conflicts to.\n     *            May be null.\n     * @since 0.8.6\n     */\n    public static void update(NamingService router, File published, SubscriptionList subscriptions, Log log) {\n        // If the NamingService is a database, we look up as we go.\n        // If it is a text file, we do things differently, to avoid O(n**2) behavior\n        // when scanning large subscription results (i.e. those that return the whole file, not just the new entries) -\n        // we load all the known hostnames into a Set one time.\n        String nsClass = router.getClass().getSimpleName();\n        boolean isTextFile = nsClass.equals(\"HostsTxtNamingService\") || nsClass.equals(\"SingleFileNamingService\");\n        Set<String> knownNames = null;\n\n        NamingService publishedNS = null;\n        Iterator<AddressBook> iter = subscriptions.iterator();\n        while (iter.hasNext()) {\n            // yes, the EepGet fetch() is done in next()\n            long start = System.currentTimeMillis();\n            AddressBook sub = iter.next();\n            long end = System.currentTimeMillis();\n            if (DEBUG && log != null)\n                log.append(\"Fetch of \" + sub.getLocation() + \" took \" + (end - start));\n            start = end;\n            int old = 0, nnew = 0, invalid = 0, conflict = 0;\n            for (Iterator<Map.Entry<String, String>> eIter = sub.iterator(); eIter.hasNext(); ) {\n                Map.Entry<String, String> entry = eIter.next();\n                String key = entry.getKey();\n                boolean isKnown;\n                Destination oldDest = null;\n                if (isTextFile) {\n                    if (knownNames == null) {\n                        // load the hostname set\n                        Properties opts = new Properties();\n                        opts.setProperty(\"file\", \"hosts.txt\");\n                        knownNames = router.getNames(opts);\n                    }\n                    isKnown = knownNames.contains(key);\n                } else {\n                    oldDest = router.lookup(key);\n                    isKnown = oldDest != null;\n                }\n                try {\n                    if (!isKnown) {\n                        if (AddressBook.isValidKey(key)) {\n                            Destination dest = new Destination(entry.getValue());\n                            boolean success = router.put(key, dest);\n                            if (log != null) {\n                                if (success)\n                                    log.append(\"New address \" + key +\n                                               \" added to address book. From: \" + sub.getLocation());\n                                else\n                                    log.append(\"Save to naming service \" + router + \" failed for new key \" + key);\n                            }\n                            // now update the published addressbook\n                            if (published != null) {\n                                if (publishedNS == null)\n                                    publishedNS = new SingleFileNamingService(I2PAppContext.getGlobalContext(), published.getAbsolutePath());\n                                success = publishedNS.putIfAbsent(key, dest);\n                                if (!success)\n                                    log.append(\"Save to published addressbook \" + published.getAbsolutePath() + \" failed for new key \" + key);\n                            }\n                            if (isTextFile)\n                                // keep track for later dup check\n                                knownNames.add(key);\n                            nnew++;\n                        } else if (log != null) {\n                            log.append(\"Bad hostname \" + key + \" from \"\n                                   + sub.getLocation());\n                            invalid++;\n                        }        \n                    } else if (false && DEBUG && log != null) {\n                        // lookup the conflict if we haven't yet (O(n**2) for text file)\n                        if (isTextFile)\n                            oldDest = router.lookup(key);\n                        if (oldDest != null && !oldDest.toBase64().equals(entry.getValue())) {\n                            log.append(\"Conflict for \" + key + \" from \"\n                                       + sub.getLocation()\n                                       + \". Destination in remote address book is \"\n                                       + entry.getValue());\n                            conflict++;\n                        } else {\n                            old++;\n                        }\n                    } else {\n                        old++;\n                    }\n                } catch (DataFormatException dfe) {\n                    if (log != null)\n                        log.append(\"Invalid b64 for\" + key + \" From: \" + sub.getLocation());\n                    invalid++;\n                }\n            }\n            if (DEBUG && log != null) {\n                log.append(\"Merge of \" + sub.getLocation() + \" into \" + router +\n                           \" took \" + (System.currentTimeMillis() - start) + \" ms with \" +\n                           nnew + \" new, \" +\n                           old + \" old, \" +\n                           invalid + \" invalid, \" +\n                           conflict + \" conflicts\");\n            }\n            sub.delete();\n        }\n        subscriptions.write();\n    }","commit_id":"7e0d0e2b01884facd2a7ed0ea0432df6737600a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run(String[] args) {\n        _running = true;\n        String settingsLocation = \"config.txt\";\n        File homeFile;\n        if (args.length > 0) {\n            homeFile = new SecureDirectory(args[0]);\n            if (!homeFile.isAbsolute())\n                homeFile = new SecureDirectory(I2PAppContext.getGlobalContext().getRouterDir(), args[0]);\n        } else {\n            homeFile = new SecureDirectory(System.getProperty(\"user.dir\"));\n        }\n        \n        Map<String, String> defaultSettings = new HashMap();\n        defaultSettings.put(\"proxy_host\", \"127.0.0.1\");\n        defaultSettings.put(\"proxy_port\", \"4444\");\n        defaultSettings.put(\"master_addressbook\", \"../userhosts.txt\");\n        defaultSettings.put(\"router_addressbook\", \"../hosts.txt\");\n        defaultSettings.put(\"published_addressbook\", \"../eepsite/docroot/hosts.txt\");\n        defaultSettings.put(\"should_publish\", \"false\");\n        defaultSettings.put(\"log\", \"log.txt\");\n        defaultSettings.put(\"subscriptions\", \"subscriptions.txt\");\n        defaultSettings.put(\"etags\", \"etags\");\n        defaultSettings.put(\"last_modified\", \"last_modified\");\n        defaultSettings.put(\"last_fetched\", \"last_fetched\");\n        defaultSettings.put(\"update_delay\", \"12\");\n        \n        if (!homeFile.exists()) {\n            boolean created = homeFile.mkdirs();\n            if (created)\n                System.out.println(\"INFO:  Addressbook directory \" + homeFile.getName() + \" created\");\n            else\n                System.out.println(\"ERROR: Addressbook directory \" + homeFile.getName() + \" could not be created\");\n        }\n        \n        File settingsFile = new File(homeFile, settingsLocation);\n        \n        Map<String, String> settings = ConfigParser.parse(settingsFile, defaultSettings);\n        // wait\n        try {\n            Thread.sleep(5*60*1000 + I2PAppContext.getGlobalContext().random().nextLong(5*60*1000));\n\t    // Static method, and redundent Thread.currentThread().sleep(5*60*1000);\n        } catch (InterruptedException ie) {}\n        \n        while (_running) {\n            long delay = Long.parseLong(settings.get(\"update_delay\"));\n            if (delay < 1) {\n                delay = 1;\n            }\n            \n            update(settings, homeFile.getAbsolutePath());\n            try {\n                synchronized (this) {\n                    wait(delay * 60 * 60 * 1000);\n                }\n            } catch (InterruptedException exp) {\n            }\n            if (!_running)\n                break;\n            settings = ConfigParser.parse(settingsFile, defaultSettings);\n        }\n    }","id":77712,"modified_method":"public void run(String[] args) {\n        _running = true;\n        String settingsLocation = \"config.txt\";\n        File homeFile;\n        if (args.length > 0) {\n            homeFile = new SecureDirectory(args[0]);\n            if (!homeFile.isAbsolute())\n                homeFile = new SecureDirectory(I2PAppContext.getGlobalContext().getRouterDir(), args[0]);\n        } else {\n            homeFile = new SecureDirectory(System.getProperty(\"user.dir\"));\n        }\n        \n        Map<String, String> defaultSettings = new HashMap();\n        defaultSettings.put(\"proxy_host\", \"127.0.0.1\");\n        defaultSettings.put(\"proxy_port\", \"4444\");\n        defaultSettings.put(\"master_addressbook\", \"../userhosts.txt\");\n        defaultSettings.put(\"router_addressbook\", \"../hosts.txt\");\n        defaultSettings.put(\"published_addressbook\", \"../eepsite/docroot/hosts.txt\");\n        defaultSettings.put(\"should_publish\", \"false\");\n        defaultSettings.put(\"log\", \"log.txt\");\n        defaultSettings.put(\"subscriptions\", \"subscriptions.txt\");\n        defaultSettings.put(\"etags\", \"etags\");\n        defaultSettings.put(\"last_modified\", \"last_modified\");\n        defaultSettings.put(\"last_fetched\", \"last_fetched\");\n        defaultSettings.put(\"update_delay\", \"12\");\n        defaultSettings.put(\"update_direct\", \"false\");\n        defaultSettings.put(\"naming_service\", \"hosts.txt\");\n        \n        if (!homeFile.exists()) {\n            boolean created = homeFile.mkdirs();\n            if (created)\n                System.out.println(\"INFO:  Addressbook directory \" + homeFile.getName() + \" created\");\n            else\n                System.out.println(\"ERROR: Addressbook directory \" + homeFile.getName() + \" could not be created\");\n        }\n        \n        File settingsFile = new File(homeFile, settingsLocation);\n        \n        Map<String, String> settings = ConfigParser.parse(settingsFile, defaultSettings);\n        // wait\n        try {\n            Thread.sleep(5*60*1000 + I2PAppContext.getGlobalContext().random().nextLong(5*60*1000));\n\t    // Static method, and redundent Thread.currentThread().sleep(5*60*1000);\n        } catch (InterruptedException ie) {}\n        \n        while (_running) {\n            long delay = Long.parseLong(settings.get(\"update_delay\"));\n            if (delay < 1) {\n                delay = 1;\n            }\n            \n            update(settings, homeFile.getAbsolutePath());\n            try {\n                synchronized (this) {\n                    wait(delay * 60 * 60 * 1000);\n                }\n            } catch (InterruptedException exp) {\n            }\n            if (!_running)\n                break;\n            settings = ConfigParser.parse(settingsFile, defaultSettings);\n        }\n    }","commit_id":"7e0d0e2b01884facd2a7ed0ea0432df6737600a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Update the router and published address books using remote data from the\n     * subscribed address books listed in subscriptions.\n     * \n     * @param master\n     *            The master AddressBook. This address book is never\n     *            overwritten, so it is safe for the user to write to.\n     * @param router\n     *            The router AddressBook. This is the address book read by\n     *            client applications.\n     * @param published\n     *            The published AddressBook. This address book is published on\n     *            the user's eepsite so that others may subscribe to it.\n     *            If non-null, overwrite with the new addressbook.\n     * @param subscriptions\n     *            A SubscriptionList listing the remote address books to update\n     *            from.\n     * @param log\n     *            The log to write changes and conflicts to.\n     */\n    public static void update(AddressBook master, AddressBook router,\n            File published, SubscriptionList subscriptions, Log log) {\n        router.merge(master, true, null);\n        Iterator<AddressBook> iter = subscriptions.iterator();\n        while (iter.hasNext()) {\n            // yes, the EepGet fetch() is done in next()\n            router.merge(iter.next(), false, log);\n        }\n        router.write();\n        if (published != null)\n            router.write(published);\n        subscriptions.write();\n    }","id":77713,"modified_method":"/**\n     * Update the router and published address books using remote data from the\n     * subscribed address books listed in subscriptions.\n     * \n     * @param master\n     *            The master AddressBook. This address book is never\n     *            overwritten, so it is safe for the user to write to.\n     *            It is only merged to the published addressbook.\n     *            May be null.\n     * @param router\n     *            The router AddressBook. This is the address book read by\n     *            client applications.\n     * @param published\n     *            The published AddressBook. This address book is published on\n     *            the user's eepsite so that others may subscribe to it.\n     *            May be null.\n     *            If non-null, overwrite with the new addressbook.\n     * @param subscriptions\n     *            A SubscriptionList listing the remote address books to update\n     *            from.\n     * @param log\n     *            The log to write changes and conflicts to.\n     *            May be null.\n     */\n    public static void update(AddressBook master, AddressBook router,\n            File published, SubscriptionList subscriptions, Log log) {\n        Iterator<AddressBook> iter = subscriptions.iterator();\n        while (iter.hasNext()) {\n            // yes, the EepGet fetch() is done in next()\n            router.merge(iter.next(), false, log);\n        }\n        router.write();\n        if (published != null) {\n            if (master != null)\n                router.merge(master, true, null);\n            router.write(published);\n        }\n        subscriptions.write();\n    }","commit_id":"7e0d0e2b01884facd2a7ed0ea0432df6737600a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Run an update, using the Map settings to provide the parameters.\n     * \n     * @param settings\n     *            A Map containg the parameters needed by update.\n     * @param home\n     *            The directory containing addressbook's configuration files.\n     */\n    public static void update(Map<String, String> settings, String home) {\n        File masterFile = new File(home, settings\n                .get(\"master_addressbook\"));\n        File routerFile = new File(home, settings\n                .get(\"router_addressbook\"));\n        File published = null;\n        if (\"true\".equals(settings.get(\"should_publish\"))) \n            published = new File(home, settings\n                .get(\"published_addressbook\"));\n        File subscriptionFile = new File(home, settings\n                .get(\"subscriptions\"));\n        File logFile = new File(home, settings.get(\"log\"));\n        File etagsFile = new File(home, settings.get(\"etags\"));\n        File lastModifiedFile = new File(home, settings\n                .get(\"last_modified\"));\n        File lastFetchedFile = new File(home, settings\n                .get(\"last_fetched\"));\n        long delay;\n        try {\n            delay = Long.parseLong(settings.get(\"update_delay\"));\n        } catch (NumberFormatException nfe) {\n            delay = 12;\n        }\n        delay *= 60 * 60 * 1000;\n\n        AddressBook master = new AddressBook(masterFile);\n        AddressBook router = new AddressBook(routerFile);\n        \n        List<String> defaultSubs = new LinkedList();\n        // defaultSubs.add(\"http://i2p/NF2RLVUxVulR3IqK0sGJR0dHQcGXAzwa6rEO4WAWYXOHw-DoZhKnlbf1nzHXwMEJoex5nFTyiNMqxJMWlY54cvU~UenZdkyQQeUSBZXyuSweflUXFqKN-y8xIoK2w9Ylq1k8IcrAFDsITyOzjUKoOPfVq34rKNDo7fYyis4kT5bAHy~2N1EVMs34pi2RFabATIOBk38Qhab57Umpa6yEoE~rbyR~suDRvD7gjBvBiIKFqhFueXsR2uSrPB-yzwAGofTXuklofK3DdKspciclTVzqbDjsk5UXfu2nTrC1agkhLyqlOfjhyqC~t1IXm-Vs2o7911k7KKLGjB4lmH508YJ7G9fLAUyjuB-wwwhejoWqvg7oWvqo4oIok8LG6ECR71C3dzCvIjY2QcrhoaazA9G4zcGMm6NKND-H4XY6tUWhpB~5GefB3YczOqMbHq4wi0O9MzBFrOJEOs3X4hwboKWANf7DT5PZKJZ5KorQPsYRSq0E3wSOsFCSsdVCKUGsAAAA/i2p/hosts.txt\");\n        defaultSubs.add(\"http://www.i2p2.i2p/hosts.txt\");\n        \n        SubscriptionList subscriptions = new SubscriptionList(subscriptionFile,\n                etagsFile, lastModifiedFile, lastFetchedFile, delay, defaultSubs, settings\n                .get(\"proxy_host\"), Integer.parseInt(settings.get(\"proxy_port\")));\n        Log log = new Log(logFile);\n\n        if (true)\n            update(getNamingService(), published, subscriptions, log);\n        else\n            update(master, router, published, subscriptions, log);\n    }","id":77714,"modified_method":"/**\n     * Run an update, using the Map settings to provide the parameters.\n     * \n     * @param settings\n     *            A Map containg the parameters needed by update.\n     * @param home\n     *            The directory containing addressbook's configuration files.\n     */\n    public static void update(Map<String, String> settings, String home) {\n        File published = null;\n        boolean should_publish = Boolean.valueOf(settings.get(\"should_publish\")).booleanValue();\n        if (should_publish) \n            published = new File(home, settings\n                .get(\"published_addressbook\"));\n        File subscriptionFile = new File(home, settings\n                .get(\"subscriptions\"));\n        File logFile = new File(home, settings.get(\"log\"));\n        File etagsFile = new File(home, settings.get(\"etags\"));\n        File lastModifiedFile = new File(home, settings\n                .get(\"last_modified\"));\n        File lastFetchedFile = new File(home, settings\n                .get(\"last_fetched\"));\n        long delay;\n        try {\n            delay = Long.parseLong(settings.get(\"update_delay\"));\n        } catch (NumberFormatException nfe) {\n            delay = 12;\n        }\n        delay *= 60 * 60 * 1000;\n        \n        List<String> defaultSubs = new LinkedList();\n        // defaultSubs.add(\"http://i2p/NF2RLVUxVulR3IqK0sGJR0dHQcGXAzwa6rEO4WAWYXOHw-DoZhKnlbf1nzHXwMEJoex5nFTyiNMqxJMWlY54cvU~UenZdkyQQeUSBZXyuSweflUXFqKN-y8xIoK2w9Ylq1k8IcrAFDsITyOzjUKoOPfVq34rKNDo7fYyis4kT5bAHy~2N1EVMs34pi2RFabATIOBk38Qhab57Umpa6yEoE~rbyR~suDRvD7gjBvBiIKFqhFueXsR2uSrPB-yzwAGofTXuklofK3DdKspciclTVzqbDjsk5UXfu2nTrC1agkhLyqlOfjhyqC~t1IXm-Vs2o7911k7KKLGjB4lmH508YJ7G9fLAUyjuB-wwwhejoWqvg7oWvqo4oIok8LG6ECR71C3dzCvIjY2QcrhoaazA9G4zcGMm6NKND-H4XY6tUWhpB~5GefB3YczOqMbHq4wi0O9MzBFrOJEOs3X4hwboKWANf7DT5PZKJZ5KorQPsYRSq0E3wSOsFCSsdVCKUGsAAAA/i2p/hosts.txt\");\n        defaultSubs.add(\"http://www.i2p2.i2p/hosts.txt\");\n        \n        SubscriptionList subscriptions = new SubscriptionList(subscriptionFile,\n                etagsFile, lastModifiedFile, lastFetchedFile, delay, defaultSubs, settings\n                .get(\"proxy_host\"), Integer.parseInt(settings.get(\"proxy_port\")));\n        Log log = new Log(logFile);\n\n        // If false, add hosts via naming service; if true, write hosts.txt file directly\n        // Default false\n        if (Boolean.valueOf(settings.get(\"update_direct\")).booleanValue()) {\n            // Direct hosts.txt access\n            File routerFile = new File(home, settings.get(\"router_addressbook\"));\n            AddressBook master;\n            if (should_publish) {\n                File masterFile = new File(home, settings.get(\"master_addressbook\"));\n                master = new AddressBook(masterFile);\n            } else {\n                master = null;\n            }\n            AddressBook router = new AddressBook(routerFile);\n            update(master, router, published, subscriptions, log);\n        } else {\n            // Naming service - no merging of master to router and published is supported.\n            update(getNamingService(settings.get(\"naming_service\")), published, subscriptions, log);\n        }\n    }","commit_id":"7e0d0e2b01884facd2a7ed0ea0432df6737600a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** @return the NamingService for the current file name, or the root NamingService */\n    private static NamingService getNamingService()\n    {\n        NamingService root = I2PAppContext.getGlobalContext().namingService();\n        NamingService rv = searchNamingService(root, \"hosts.txt\");\n        return rv != null ? rv : root;                \n    }","id":77715,"modified_method":"/** @return the configured NamingService, or the root NamingService */\n    private static NamingService getNamingService(String srch)\n    {\n        NamingService root = I2PAppContext.getGlobalContext().namingService();\n        NamingService rv = searchNamingService(root, srch);\n        return rv != null ? rv : root;                \n    }","commit_id":"7e0d0e2b01884facd2a7ed0ea0432df6737600a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** depth-first search */\n    private static NamingService searchNamingService(NamingService ns, String srch)\n    {\n        String name = ns.getName();\n        if (name == srch)\n                return ns;\n        List<NamingService> list = ns.getNamingServices();\n        if (list != null) {\n            for (NamingService nss : list) {\n                NamingService rv = searchNamingService(nss, srch);\n                if (rv != null)\n                    return rv;\n            }\n        }\n        return null;                \n    }","id":77716,"modified_method":"/** depth-first search */\n    private static NamingService searchNamingService(NamingService ns, String srch)\n    {\n        String name = ns.getName();\n        if (name.equals(srch) || name.endsWith('/' + srch) || name.endsWith('\\\\' + srch))\n            return ns;\n        List<NamingService> list = ns.getNamingServices();\n        if (list != null) {\n            for (NamingService nss : list) {\n                NamingService rv = searchNamingService(nss, srch);\n                if (rv != null)\n                    return rv;\n            }\n        }\n        return null;                \n    }","commit_id":"7e0d0e2b01884facd2a7ed0ea0432df6737600a8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public void wait(FileSystemSubset taskFileSystemInputs, final BuildCancellationToken cancellationToken, Runnable notifier) {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        final StoppableExecutor executorService = executorFactory.create(\"continuous building - wait\");\n\n        FileWatcher watcher = fileWatcherFactory.watch(\n            taskFileSystemInputs,\n            new Action<Throwable>() {\n                @Override\n                public void execute(Throwable throwable) {\n                    error.set(throwable);\n                    latch.countDown();\n                }\n            },\n            new FileWatcherListener() {\n                private IdleTimeout timeout;\n\n                @Override\n                public void onChange(final FileWatcher watcher, FileWatcherEvent event) {\n                    if (timeout == null) {\n                        timeout = new IdleTimeout(QUIET_PERIOD, new Runnable() {\n                            @Override\n                            public void run() {\n                                watcher.stop();\n                                latch.countDown();\n                            }\n                        });\n                        executorService.execute(new Runnable() {\n                            @Override\n                            public void run() {\n                                timeout.await();\n                            }\n                        });\n                    }\n                    timeout.tick();\n                }\n            }\n        );\n\n        try {\n            notifier.run();\n            latch.await();\n            Throwable throwable = error.get();\n            if (throwable != null) {\n                throw UncheckedException.throwAsUncheckedException(throwable);\n            }\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            CompositeStoppable.stoppable(watcher, new Stoppable() {\n                @Override\n                public void stop() {\n                    executorService.shutdownNow();\n                }\n            }).stop();\n        }\n    }","id":77717,"modified_method":"@Override\n    public void wait(FileSystemSubset taskFileSystemInputs, final BuildCancellationToken cancellationToken, Runnable notifier) {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        final StoppableExecutor executorService = executorFactory.create(\"continuous building - wait\");\n\n        FileWatcher watcher = fileWatcherFactory.watch(\n            taskFileSystemInputs,\n            new Action<Throwable>() {\n                @Override\n                public void execute(Throwable throwable) {\n                    error.set(throwable);\n                    latch.countDown();\n                }\n            },\n            new FileWatcherListener() {\n                private IdleTimeout timeout;\n\n                @Override\n                public void onChange(final FileWatcher watcher, FileWatcherEvent event) {\n                    if (timeout == null) {\n                        if (!(event.getType() == FileWatcherEvent.Type.MODIFY && event.getFile().isDirectory())) {\n                            timeout = new IdleTimeout(QUIET_PERIOD, new Runnable() {\n                                @Override\n                                public void run() {\n                                    watcher.stop();\n                                    latch.countDown();\n                                }\n                            });\n                            executorService.execute(new Runnable() {\n                                @Override\n                                public void run() {\n                                    timeout.await();\n                                }\n                            });\n                            timeout.tick();\n                        }\n                    } else {\n                        timeout.tick();\n                    }\n                }\n            }\n        );\n\n        try {\n            notifier.run();\n            latch.await();\n            Throwable throwable = error.get();\n            if (throwable != null) {\n                throw UncheckedException.throwAsUncheckedException(throwable);\n            }\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            CompositeStoppable.stoppable(watcher, new Stoppable() {\n                @Override\n                public void stop() {\n                    executorService.shutdownNow();\n                }\n            }).stop();\n        }\n    }","commit_id":"c6604ea503012498ee434a821f76fa7866373ce8","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void resolve(FileCollectionResolveContext context) {\n        for (DirectoryTree directoryTree : getSrcDirTrees()) {\n            context.add(((DirectoryFileTree) directoryTree).filter(filter));\n        }\n    }","id":77718,"modified_method":"@Override\n    public void resolve(FileCollectionResolveContext context) {\n        for (DirectoryTree directoryTree : doGetSrcDirTrees()) {\n            context.add(((DirectoryFileTree) directoryTree).filter(filter));\n        }\n    }","commit_id":"c6604ea503012498ee434a821f76fa7866373ce8","url":"https://github.com/gradle/gradle"},{"original_method":"private List<FileWatcherEvent> handleWatchKey(WatchKey watchKey) {\n        final Path watchedPath = (Path) watchKey.watchable();\n        Transformer<FileWatcherEvent, WatchEvent<?>> watchEventTransformer = new Transformer<FileWatcherEvent, WatchEvent<?>>() {\n            @Override\n            public FileWatcherEvent transform(WatchEvent<?> event) {\n                WatchEvent.Kind kind = event.kind();\n                File file = null;\n                if (kind.type() == Path.class) {\n                    WatchEvent<Path> ev = Cast.uncheckedCast(event);\n                    file = watchedPath.resolve(ev.context()).toFile();\n                }\n                return toEvent(kind, file);\n            }\n        };\n\n        List<WatchEvent<?>> watchEvents = watchKey.pollEvents();\n        final List<FileWatcherEvent> events;\n        if (!watchEvents.isEmpty()) {\n            events = CollectionUtils.collect(watchEvents, watchEventTransformer);\n        } else {\n            // TODO: When deleting directories, we receive a WatchKey without any events.\n            // This seems to be the same thing as a delete event for the Path.\n            // watchKey.reset() also returns false in this case.\n            events = Collections.singletonList(FileWatcherEvent.delete(watchedPath.toFile()));\n        }\n\n        watchKey.reset();\n//        if (!valid) {\n//            // TODO: What do we do when we're no longer watching a directory that's still an input?\n//        }\n        return events;\n    }","id":77719,"modified_method":"private List<FileWatcherEvent> handleWatchKey(WatchKey watchKey) {\n        final Path watchedPath = (Path) watchKey.watchable();\n        Transformer<FileWatcherEvent, WatchEvent<?>> watchEventTransformer = new Transformer<FileWatcherEvent, WatchEvent<?>>() {\n            @Override\n            public FileWatcherEvent transform(WatchEvent<?> event) {\n                WatchEvent.Kind kind = event.kind();\n                File file = null;\n                if (kind.type() == Path.class) {\n                    WatchEvent<Path> ev = Cast.uncheckedCast(event);\n                    file = watchedPath.resolve(ev.context()).toFile();\n                }\n                return toEvent(kind, file);\n            }\n        };\n\n        List<WatchEvent<?>> watchEvents = watchKey.pollEvents();\n        watchKey.reset();\n        if (watchEvents.isEmpty()) {\n            return Collections.singletonList(FileWatcherEvent.delete(watchedPath.toFile()));\n        } else {\n            return CollectionUtils.collect(watchEvents, watchEventTransformer);\n        }\n    }","commit_id":"c6604ea503012498ee434a821f76fa7866373ce8","url":"https://github.com/gradle/gradle"},{"original_method":"@GET\n    @Timed\n    @ApiOperation(value = \"Get all input states\")\n    @RequiresPermissions(RestPermissions.INPUTS_READ)\n    public Map<String, Set<InputStateSummary>> get() {\n        final Map<String, Node> nodes = nodeService.allActive();\n        final Map<String, Set<InputStateSummary>> result = nodes.entrySet()\n                .stream()\n                .parallel()\n                .collect(Collectors.toMap(entry -> entry.getKey(), entry -> {\n                    final RemoteInputStatesResource remoteInputStatesResource = remoteInterfaceProvider.get(entry.getValue(),\n                            this.authenticationToken,\n                            RemoteInputStatesResource.class);\n                    try {\n                        final Response<InputStatesList> response = remoteInputStatesResource.list().execute();\n                        if (response.isSuccess()) {\n                            return response.body().states();\n                        } else {\n                            LOG.warn(\"Unable to fetch input states from node \" + entry.getKey() + \": \" + response.message());\n                        }\n                    } catch (IOException e) {\n                        LOG.warn(\"Unable to fetch input states from node \" + entry.getKey() + \": \", e);\n                    }\n                    return Collections.emptySet();\n                }));\n        return result;\n    }","id":77720,"modified_method":"@GET\n    @Timed\n    @ApiOperation(value = \"Get all input states\")\n    @RequiresPermissions(RestPermissions.INPUTS_READ)\n    public Map<String, Set<InputStateSummary>> get() {\n        final Map<String, Node> nodes = nodeService.allActive();\n        return nodes.entrySet()\n                .stream()\n                .parallel()\n                .collect(Collectors.toMap(Map.Entry::getKey, entry -> {\n                    final RemoteInputStatesResource remoteInputStatesResource = remoteInterfaceProvider.get(entry.getValue(),\n                            this.authenticationToken,\n                            RemoteInputStatesResource.class);\n                    try {\n                        final Response<InputStatesList> response = remoteInputStatesResource.list().execute();\n                        if (response.isSuccess()) {\n                            return response.body().states();\n                        } else {\n                            LOG.warn(\"Unable to fetch input states from node \" + entry.getKey() + \": \" + response.message());\n                        }\n                    } catch (IOException e) {\n                        LOG.warn(\"Unable to fetch input states from node \" + entry.getKey() + \": \", e);\n                    }\n                    return Collections.emptySet();\n                }));\n    }","commit_id":"da6656c1086bcb2054d2b3e57b406711a5399ee1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void checkConfiguration() throws ConfigurationException {\n        if (isNullOrEmpty(configuration.getString(CK_URL))) {\n            throw new ConfigurationException(\"URL parameter is missing!\");\n        }\n\n        try {\n            new URL(configuration.getString(CK_URL));\n        } catch (MalformedURLException e) {\n            throw new ConfigurationException(\"Malformed URL\", e);\n        }\n    }","id":77721,"modified_method":"@Override\n    public void checkConfiguration() throws ConfigurationException {\n        final String url = configuration.getString(CK_URL);\n        if (isNullOrEmpty(url)) {\n            throw new ConfigurationException(\"URL parameter is missing!\");\n        }\n\n        try {\n            new URL(url);\n        } catch (MalformedURLException e) {\n            throw new ConfigurationException(\"Malformed URL\", e);\n        }\n    }","commit_id":"da6656c1086bcb2054d2b3e57b406711a5399ee1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void doLaunch(final MessageInput input) throws MisfireException {\n        serverStatus.awaitRunning(new Runnable() {\n            @Override\n            public void run() {\n                lifecycleStateChange(Lifecycle.RUNNING);\n            }\n        });\n\n        // listen for lifecycle changes\n        serverEventBus.register(this);\n\n        final Map<String, String> headers = parseHeaders(configuration.getString(CK_HEADERS));\n\n        // figure out a reasonable remote address\n        final String url = configuration.getString(CK_URL);\n        final InetSocketAddress remoteAddress;\n        InetSocketAddress remoteAddress1;\n        try {\n            final URL url1 = new URL(url);\n            final int port = url1.getPort();\n            remoteAddress1 = new InetSocketAddress(url1.getHost(), port != -1 ? port : 80);\n        } catch (MalformedURLException e) {\n            remoteAddress1 = null;\n        }\n        remoteAddress = remoteAddress1;\n\n\n        final Runnable task = new Runnable() {\n            @Override\n            public void run() {\n                if (paused) {\n                    LOG.debug(\"Message processing paused, not polling HTTP resource {}.\", url);\n                    return;\n                }\n                if (isThrottled()) {\n                    // this transport won't block, but we can simply skip this iteration\n                    LOG.debug(\"Not polling HTTP resource {} because we are throttled.\", url);\n                }\n\n                final Request.Builder requestBuilder = new Request.Builder().get()\n                        .url(url)\n                        .headers(Headers.of(headers));\n\n                try {\n                    final Response r = httpClient.newCall(requestBuilder.build()).execute();\n\n                    if (!r.isSuccessful()) {\n                        throw new RuntimeException(\"Expected successful HTTP status code [2xx], got \" + r.code());\n                    }\n\n                    input.processRawMessage(new RawMessage(r.body().bytes(), remoteAddress));\n                } catch (IOException e) {\n                    LOG.error(\"Could not fetch HTTP resource at \" + url, e);\n                }\n            }\n        };\n\n        scheduledFuture = scheduler.scheduleAtFixedRate(task, 0,\n                configuration.getInt(CK_INTERVAL),\n                TimeUnit.valueOf(configuration.getString(CK_TIMEUNIT)));\n    }","id":77722,"modified_method":"@Override\n    public void doLaunch(final MessageInput input) throws MisfireException {\n        serverStatus.awaitRunning(() -> lifecycleStateChange(Lifecycle.RUNNING));\n\n        // listen for lifecycle changes\n        serverEventBus.register(this);\n\n        final Map<String, String> headers = parseHeaders(configuration.getString(CK_HEADERS));\n\n        // figure out a reasonable remote address\n        final String url = configuration.getString(CK_URL);\n        final InetSocketAddress remoteAddress;\n        InetSocketAddress remoteAddress1;\n        try {\n            final URL url1 = new URL(url);\n            final int port = url1.getPort();\n            remoteAddress1 = new InetSocketAddress(url1.getHost(), port != -1 ? port : 80);\n        } catch (MalformedURLException e) {\n            remoteAddress1 = null;\n        }\n        remoteAddress = remoteAddress1;\n\n        final Runnable task = () -> {\n            if (paused) {\n                LOG.debug(\"Message processing paused, not polling HTTP resource {}.\", url);\n                return;\n            }\n            if (isThrottled()) {\n                // this transport won't block, but we can simply skip this iteration\n                LOG.debug(\"Not polling HTTP resource {} because we are throttled.\", url);\n            }\n\n            final Request.Builder requestBuilder = new Request.Builder().get()\n                    .url(url)\n                    .headers(Headers.of(headers));\n\n            try {\n                final Response r = httpClient.newCall(requestBuilder.build()).execute();\n\n                if (!r.isSuccessful()) {\n                    throw new RuntimeException(\"Expected successful HTTP status code [2xx], got \" + r.code());\n                }\n\n                input.processRawMessage(new RawMessage(r.body().bytes(), remoteAddress));\n            } catch (IOException e) {\n                LOG.error(\"Could not fetch HTTP resource at \" + url, e);\n            }\n        };\n\n        scheduledFuture = scheduler.scheduleAtFixedRate(task, 0,\n                configuration.getInt(CK_INTERVAL),\n                TimeUnit.valueOf(configuration.getString(CK_TIMEUNIT)));\n    }","commit_id":"da6656c1086bcb2054d2b3e57b406711a5399ee1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public OkHttpClient get() {\n        final OkHttpClient client = new OkHttpClient();\n        client.setRetryOnConnectionFailure(true);\n        client.setConnectTimeout(connectTimeout.getQuantity(), connectTimeout.getUnit());\n        client.setWriteTimeout(writeTimeout.getQuantity(), writeTimeout.getUnit());\n        client.setReadTimeout(readTimeout.getQuantity(), readTimeout.getUnit());\n\n        if (httpProxyUri != null) {\n            final Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(httpProxyUri.getHost(), httpProxyUri.getPort()));\n            client.setProxy(proxy);\n        }\n\n        return client;\n    }","id":77723,"modified_method":"@Override\n    public OkHttpClient get() {\n        final OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder()\n                .retryOnConnectionFailure(true)\n                .connectTimeout(connectTimeout.getQuantity(), connectTimeout.getUnit())\n                .writeTimeout(writeTimeout.getQuantity(), writeTimeout.getUnit())\n                .readTimeout(readTimeout.getQuantity(), readTimeout.getUnit());\n\n        if (httpProxyUri != null) {\n            final Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(httpProxyUri.getHost(), httpProxyUri.getPort()));\n            clientBuilder.proxy(proxy);\n        }\n\n        return clientBuilder.build();\n    }","commit_id":"da6656c1086bcb2054d2b3e57b406711a5399ee1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public <T> T get(Node node, final String authorizationToken, Class<T> interfaceClass) {\n        final OkHttpClient okHttpClient = this.okHttpClient.clone();\n        okHttpClient.interceptors().add(new Interceptor() {\n            @Override\n            public Response intercept(Interceptor.Chain chain) throws IOException {\n                final Request original = chain.request();\n\n                Request.Builder builder = original.newBuilder()\n                        .header(\"Accept\", \"application/json\")\n                        .method(original.method(), original.body());\n\n                if (authorizationToken != null) {\n                    builder = builder.header(\"Authorization\", authorizationToken);\n                }\n\n                return chain.proceed(builder.build());\n            }\n        });\n        final Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(node.getTransportAddress())\n                .addConverterFactory(JacksonConverterFactory.create(objectMapper))\n                .client(okHttpClient)\n                .build();\n\n        return retrofit.create(interfaceClass);\n    }","id":77724,"modified_method":"public <T> T get(Node node, final String authorizationToken, Class<T> interfaceClass) {\n        final OkHttpClient okHttpClient = this.okHttpClient.newBuilder()\n                .addInterceptor(chain -> {\n                    final Request original = chain.request();\n\n                    Request.Builder builder = original.newBuilder()\n                            .header(HttpHeaders.ACCEPT, MediaType.JSON_UTF_8.toString())\n                            .method(original.method(), original.body());\n\n                    if (authorizationToken != null) {\n                        builder = builder.header(HttpHeaders.AUTHORIZATION, authorizationToken);\n                    }\n\n                    return chain.proceed(builder.build());\n                })\n                .build();\n        final Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(node.getTransportAddress())\n                .addConverterFactory(JacksonConverterFactory.create(objectMapper))\n                .client(okHttpClient)\n                .build();\n\n        return retrofit.create(interfaceClass);\n    }","commit_id":"da6656c1086bcb2054d2b3e57b406711a5399ee1","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@NotNull\n    public ResolveResult[] multiResolve(final boolean incompleteCode) {\n        final PsiFile containingFile = myAttribute.getContainingFile();\n        if (containingFile instanceof XmlFile && XsltSupport.isXsltFile(containingFile) && myImplicitModeElement.getQName() != null) {\n            final PsiElement[] psiElements = ResolveUtil.collect(getMatcher());\n            final ResolveResult[] results = new ResolveResult[psiElements.length];\n            for (int i = 0; i < psiElements.length; i++) {\n                results[i] = new PsiElementResolveResult(psiElements[i]);\n            }\n            return results;\n        }\n        return ResolveResult.EMPTY_ARRAY;\n    }","id":77725,"modified_method":"@NotNull\n    public ResolveResult[] multiResolve(final boolean incompleteCode) {\n        final PsiFile containingFile = myAttribute.getContainingFile();\n        if (containingFile instanceof XmlFile && XsltSupport.isXsltFile(containingFile) && myImplicitModeElement.getQName() != null) {\n          return PsiElementResolveResult.createResults(ResolveUtil.collect(getMatcher()));\n        }\n        return ResolveResult.EMPTY_ARRAY;\n    }","commit_id":"e93ddf162ae116933f54c9c55cd8f508603ff50a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public final ResolveResult[] multiResolve(final boolean incompleteCode) {\n        final PsiElement[] psiElements = ResolveUtil.collect(myMatcher);\n        final ResolveResult[] results = new ResolveResult[psiElements.length];\n        for (int i = 0; i < results.length; i++) {\n            results[i] = new PsiElementResolveResult(psiElements[i]);\n        }\n        return results;\n    }","id":77726,"modified_method":"@NotNull\n    public final ResolveResult[] multiResolve(final boolean incompleteCode) {\n      return PsiElementResolveResult.createResults(ResolveUtil.collect(myMatcher));\n    }","commit_id":"e93ddf162ae116933f54c9c55cd8f508603ff50a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    final String key = getKeyText();\n\n    List<Property> properties;\n    final List<PropertiesFile> propertiesFiles = getPropertiesFiles();\n    if (propertiesFiles == null) {\n      properties = PropertiesUtil.findPropertiesByKey(getElement().getProject(), key);\n    }\n    else {\n      properties = new ArrayList<Property>();\n      for (PropertiesFile propertiesFile : propertiesFiles) {\n        properties.addAll(propertiesFile.findPropertiesByKey(key));\n      }\n    }\n    // put default properties file first\n    ContainerUtil.quickSort(properties, new Comparator<Property>() {\n      public int compare(final Property o1, final Property o2) {\n        String name1 = o1.getContainingFile().getName();\n        String name2 = o2.getContainingFile().getName();\n        return Comparing.compare(name1, name2);\n      }\n    });\n    final ResolveResult[] result = new ResolveResult[properties.size()];\n    int i = 0;\n    for (Property property : properties) {\n      result[i++] = new PsiElementResolveResult(property);\n    }\n    return result;\n  }","id":77727,"modified_method":"@NotNull\n  public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    final String key = getKeyText();\n\n    List<Property> properties;\n    final List<PropertiesFile> propertiesFiles = getPropertiesFiles();\n    if (propertiesFiles == null) {\n      properties = PropertiesUtil.findPropertiesByKey(getElement().getProject(), key);\n    }\n    else {\n      properties = new ArrayList<Property>();\n      for (PropertiesFile propertiesFile : propertiesFiles) {\n        properties.addAll(propertiesFile.findPropertiesByKey(key));\n      }\n    }\n    // put default properties file first\n    ContainerUtil.quickSort(properties, new Comparator<Property>() {\n      public int compare(final Property o1, final Property o2) {\n        String name1 = o1.getContainingFile().getName();\n        String name2 = o2.getContainingFile().getName();\n        return Comparing.compare(name1, name2);\n      }\n    });\n    return PsiElementResolveResult.createResults(properties);\n  }","commit_id":"e93ddf162ae116933f54c9c55cd8f508603ff50a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    final PsiPackage parentPackage = getContext();\n    if (parentPackage != null) {\n      final Collection<PsiPackage> packages = myReferenceSet.resolvePackageName(parentPackage, getValue());\n      return ContainerUtil.map2Array(packages, ResolveResult.class, new Function<PsiPackage, ResolveResult>() {\n        public ResolveResult fun(final PsiPackage psiPackage) {\n          return new PsiElementResolveResult(psiPackage);\n        }\n      });\n    }\n    return ResolveResult.EMPTY_ARRAY;\n  }","id":77728,"modified_method":"@NotNull\n  public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    final PsiPackage parentPackage = getContext();\n    if (parentPackage != null) {\n      final Collection<PsiPackage> packages = myReferenceSet.resolvePackageName(parentPackage, getValue());\n      return PsiElementResolveResult.createResults(packages);\n    }\n    return ResolveResult.EMPTY_ARRAY;\n  }","commit_id":"e93ddf162ae116933f54c9c55cd8f508603ff50a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    PropertiesReferenceManager referenceManager = PropertiesReferenceManager.getInstance(myElement.getProject());\n    List<PropertiesFile> propertiesFiles = referenceManager.findPropertiesFiles(myElement.getResolveScope(), myBundleName, this);\n    final ResolveResult[] result = new ResolveResult[propertiesFiles.size()];\n    for(int i=0; i<propertiesFiles.size(); i++) {\n      PropertiesFile file = propertiesFiles.get(i);\n      result[i] = new PsiElementResolveResult(file);\n    }\n    return result;\n  }","id":77729,"modified_method":"@NotNull public ResolveResult[] multiResolve(final boolean incompleteCode) {\n    PropertiesReferenceManager referenceManager = PropertiesReferenceManager.getInstance(myElement.getProject());\n    List<PropertiesFile> propertiesFiles = referenceManager.findPropertiesFiles(myElement.getResolveScope(), myBundleName, this);\n    return PsiElementResolveResult.createResults(propertiesFiles);\n  }","commit_id":"e93ddf162ae116933f54c9c55cd8f508603ff50a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<MediaType> getCompatibleMediaTypes(ServerHttpRequest request,\n\t\t\tResolvableType elementType) {\n\n\t\tList<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(request);\n\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n\n\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n\t\t\tcompatibleMediaTypes.addAll(producibleMediaTypes.stream().\n\t\t\t\t\tfilter(acceptableMediaType::isCompatibleWith).\n\t\t\t\t\tmap(producibleType -> getMostSpecificMediaType(acceptableMediaType,\n\t\t\t\t\t\t\tproducibleType)).collect(Collectors.toList()));\n\t\t}\n\n\t\tList<MediaType> result = new ArrayList<>(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(result);\n\t\treturn result;\n\t}","id":77730,"modified_method":"private List<MediaType> getCompatibleMediaTypes(ServerHttpRequest request,\n\t\t\tResolvableType elementType) {\n\n\t\tList<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(request);\n\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n\n\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n\t\tfor (MediaType acceptable : acceptableMediaTypes) {\n\t\t\tfor (MediaType producible : producibleMediaTypes) {\n\t\t\t\tif (acceptable.isCompatibleWith(producible)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(acceptable, producible));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<MediaType> result = new ArrayList<>(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(result);\n\t\treturn result;\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private List<MediaType> getProducibleMediaTypes(ResolvableType type) {\n\t\tList<MediaType> result = this.messageConverters.stream()\n\t\t\t\t.filter(converter -> converter.canWrite(type, null))\n\t\t\t\t.flatMap(encoder -> this.mediaTypesByEncoder.get(encoder).stream())\n\t\t\t\t.collect(Collectors.toList());\n\t\tif (result.isEmpty()) {\n\t\t\tresult.add(MediaType.ALL);\n\t\t}\n\n\t\treturn result;\n\t}","id":77731,"modified_method":"private List<MediaType> getProducibleMediaTypes(ResolvableType type) {\n\t\treturn this.messageConverters.stream()\n\t\t\t\t.filter(converter -> converter.canWrite(type, null))\n\t\t\t\t.flatMap(converter -> converter.getWritableMediaTypes().stream())\n\t\t\t\t.collect(Collectors.collectingAndThen(Collectors.toList(), result -> {\n\t\t\t\t\tif (result.isEmpty()) {\n\t\t\t\t\t\tresult.add(MediaType.ALL);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}));\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Optional<MediaType> selectBestMediaType(\n\t\t\tList<MediaType> compatibleMediaTypes) {\n\t\tfor (MediaType mediaType : compatibleMediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\treturn Optional.of(mediaType);\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) ||\n\t\t\t\t\tmediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\treturn Optional.of(MediaType.APPLICATION_OCTET_STREAM);\n\t\t\t}\n\t\t}\n\t\treturn Optional.empty();\n\t}","id":77732,"modified_method":"private MediaType selectBestMediaType(List<MediaType> compatibleMediaTypes) {\n\t\tfor (MediaType mediaType : compatibleMediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\treturn mediaType;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n\t\t\t\treturn MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional<Object> value = result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher<?> publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType = result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType = returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher = Mono.just(value.get());\n\t\t\telementType = returnType;\n\t\t}\n\n\t\tList<MediaType> compatibleMediaTypes =\n\t\t\t\tgetCompatibleMediaTypes(exchange.getRequest(), elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new NotAcceptableStatusException(\n\t\t\t\t\tgetProducibleMediaTypes(elementType)));\n\t\t}\n\n\t\tOptional<MediaType> selectedMediaType = selectBestMediaType(compatibleMediaTypes);\n\n\t\tif (selectedMediaType.isPresent()) {\n\t\t\tHttpMessageConverter<?> converter =\n\t\t\t\t\tresolveEncoder(elementType, selectedMediaType.get());\n\t\t\tif (converter != null) {\n\t\t\t\tServerHttpResponse response = exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType,\n\t\t\t\t\t\tselectedMediaType.get(),\n\t\t\t\t\t\t\t\tresponse);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n\t}","id":77733,"modified_method":"@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional<Object> value = result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher<?> publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType = result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType = returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher = Mono.just(value.get());\n\t\t\telementType = returnType;\n\t\t}\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(request, elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tList<MediaType> supported = getProducibleMediaTypes(elementType);\n\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n\t\t}\n\n\t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n\t\tif (bestMediaType != null) {\n\t\t\tHttpMessageConverter<?> converter = resolveEncoder(elementType, bestMediaType);\n\t\t\tif (converter != null) {\n\t\t\t\tServerHttpResponse response = exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ResponseBodyResultHandler(List<HttpMessageConverter<?>> messageConverters,\n\t\t\tConversionService service) {\n\t\tAssert.notEmpty(messageConverters, \"At least one message converter is required.\");\n\t\tAssert.notNull(service, \"'conversionService' is required.\");\n\t\tthis.messageConverters = messageConverters;\n\t\tthis.conversionService = service;\n\t\tthis.allMediaTypes = getAllMediaTypes(messageConverters);\n\t\tthis.mediaTypesByEncoder = getMediaTypesByConverter(messageConverters);\n\t}","id":77734,"modified_method":"/**\n\t * Constructor with message converters and conversion service.\n\t * @param messageConverters converters for writing the response body with\n\t * @param conversionService for converting to Flux and Mono from other reactive types\n\t */\n\tpublic ResponseBodyResultHandler(List<HttpMessageConverter<?>> messageConverters,\n\t\t\tConversionService conversionService) {\n\n\t\tAssert.notEmpty(messageConverters, \"At least one message converter is required.\");\n\t\tAssert.notNull(conversionService, \"'conversionService' is required.\");\n\t\tthis.messageConverters = messageConverters;\n\t\tthis.conversionService = conversionService;\n\t\tthis.supportedMediaTypes = initSupportedMediaTypes(messageConverters);\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return the more specific of the acceptable and the producible media types\n\t * with the q-value of the former.\n\t */\n\tprivate MediaType getMostSpecificMediaType(MediaType acceptType, MediaType produceType) {\n\t\tproduceType = produceType.copyQualityValue(acceptType);\n\t\tComparator<MediaType> comparator = MediaType.SPECIFICITY_COMPARATOR;\n\t\treturn (comparator.compare(acceptType, produceType) <= 0 ? acceptType : produceType);\n\t}","id":77735,"modified_method":"private MediaType getMostSpecificMediaType(MediaType acceptable, MediaType producible) {\n\t\tproducible = producible.copyQualityValue(acceptable);\n\t\tComparator<MediaType> comparator = MediaType.SPECIFICITY_COMPARATOR;\n\t\treturn (comparator.compare(acceptable, producible) <= 0 ? acceptable : producible);\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private static List<MediaType> getAllMediaTypes(\n\t\t\tList<HttpMessageConverter<?>> messageConverters) {\n\t\tSet<MediaType> set = new LinkedHashSet<>();\n\t\tmessageConverters.forEach(\n\t\t\t\tconverter -> set.addAll(converter.getWritableMediaTypes()));\n\t\tList<MediaType> result = new ArrayList<>(set);\n\t\tMediaType.sortBySpecificity(result);\n\t\treturn Collections.unmodifiableList(result);\n\t}","id":77736,"modified_method":"private static List<MediaType> initSupportedMediaTypes(List<HttpMessageConverter<?>> converters) {\n\t\tSet<MediaType> set = new LinkedHashSet<>();\n\t\tconverters.forEach(converter -> set.addAll(converter.getWritableMediaTypes()));\n\t\tList<MediaType> result = new ArrayList<>(set);\n\t\tMediaType.sortBySpecificity(result);\n\t\treturn Collections.unmodifiableList(result);\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void setOrder(int order) {\n\t\tthis.order = order;\n\t}","id":77737,"modified_method":"/**\n\t * Set the order for this result handler relative to others.\n\t * <p>By default this is set to 0 and is generally save to be ahead of other\n\t * result handlers since it only gets involved if the method (or class) is\n\t * annotated with {@code @ResponseBody}.\n\t * @param order the order\n\t */\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supports() throws NoSuchMethodException {\n\t\tResponseBodyResultHandler handler = new ResponseBodyResultHandler(Collections.singletonList(\n\t\t\t\tnew CodecHttpMessageConverter<String>(new StringEncoder(), null)),\n\t\t\t\tnew DefaultConversionService());\n\t\tTestController controller = new TestController();\n\n\t\tHandlerMethod hm = new HandlerMethod(controller,TestController.class.getMethod(\"notAnnotated\"));\n\t\tResolvableType type = ResolvableType.forMethodParameter(hm.getReturnType());\n\t\tassertFalse(handler.supports(new HandlerResult(hm, null, type, new ExtendedModelMap())));\n\n\t\thm = new HandlerMethod(controller, TestController.class.getMethod(\"publisherString\"));\n\t\ttype = ResolvableType.forMethodParameter(hm.getReturnType());\n\t\tassertTrue(handler.supports(new HandlerResult(hm, null, type, new ExtendedModelMap())));\n\n\t\thm = new HandlerMethod(controller, TestController.class.getMethod(\"publisherVoid\"));\n\t\ttype = ResolvableType.forMethodParameter(hm.getReturnType());\n\t\tassertTrue(handler.supports(new HandlerResult(hm, null, type, new ExtendedModelMap())));\n\t}","id":77738,"modified_method":"@Test\n\tpublic void supports() throws NoSuchMethodException {\n\t\tResponseBodyResultHandler handler = createResultHandler(new StringEncoder());\n\t\tTestController controller = new TestController();\n\n\t\tHandlerMethod hm = new HandlerMethod(controller, TestController.class.getMethod(\"notAnnotated\"));\n\t\tResolvableType type = ResolvableType.forMethodParameter(hm.getReturnType());\n\t\tassertFalse(handler.supports(new HandlerResult(hm, null, type, new ExtendedModelMap())));\n\n\t\thm = new HandlerMethod(controller, TestController.class.getMethod(\"publisherString\"));\n\t\ttype = ResolvableType.forMethodParameter(hm.getReturnType());\n\t\tassertTrue(handler.supports(new HandlerResult(hm, null, type, new ExtendedModelMap())));\n\n\t\thm = new HandlerMethod(controller, TestController.class.getMethod(\"publisherVoid\"));\n\t\ttype = ResolvableType.forMethodParameter(hm.getReturnType());\n\t\tassertTrue(handler.supports(new HandlerResult(hm, null, type, new ExtendedModelMap())));\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isViewNameOrViewReference(Class<?> clazz) {\n\t\treturn (CharSequence.class.isAssignableFrom(clazz) || View.class.isAssignableFrom(clazz));\n\t}","id":77739,"modified_method":"private boolean isStringOrViewReference(Class<?> clazz) {\n\t\treturn (CharSequence.class.isAssignableFrom(clazz) || View.class.isAssignableFrom(clazz));\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic boolean supports(HandlerResult result) {\n\t\tClass<?> clazz = result.getReturnValueType().getRawClass();\n\t\tif (isViewNameOrViewReference(clazz)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.conversionService.canConvert(clazz, Mono.class)) {\n\t\t\tclazz = result.getReturnValueType().getGeneric(0).getRawClass();\n\t\t\treturn isViewNameOrViewReference(clazz);\n\t\t}\n\t\treturn false;\n\t}","id":77740,"modified_method":"@Override\n\tpublic boolean supports(HandlerResult result) {\n\t\tClass<?> clazz = result.getReturnValueType().getRawClass();\n\t\tif (isStringOrViewReference(clazz)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.conversionService.canConvert(clazz, Mono.class)) {\n\t\t\tclazz = result.getReturnValueType().getGeneric(0).getRawClass();\n\t\t\treturn isStringOrViewReference(clazz);\n\t\t}\n\t\treturn false;\n\t}","commit_id":"91d063899bd816cc57815ac0b2317b3ab674868e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void validate(ExtensionModel extensionModel) throws IllegalModelDefinitionException {\n      new ExtensionWalker() {\n\n        @Override\n        public void onConfiguration(ConfigurationModel model) {\n          defaultValidation(model);\n        }\n\n        @Override\n        public void onOperation(HasOperationModels owner, OperationModel model) {\n          validateOperation(model);\n          registerNamedObject(model);\n        }\n\n        @Override\n        public void onConnectionProvider(HasConnectionProviderModels owner, ConnectionProviderModel model) {\n          defaultValidation(model);\n        }\n\n        @Override\n        public void onSource(HasSourceModels owner, SourceModel model) {\n          defaultValidation(model);\n        }\n\n        @Override\n        public void onParameter(ParameterizedModel owner, ParameterModel model) {\n          validateTopLevelParameter(model, owner);\n        }\n\n        private void defaultValidation(ParameterizedModel model) {\n          validateParameterNames(model);\n          registerNamedObject(model);\n        }\n\n        private void registerNamedObject(Named named) {\n          namedObjects.add(new DescribedReference<>(named));\n        }\n      }.walk(extensionModel);\n\n      validateNameClashes(namedObjects, topLevelParameters.values(),\n                          topLevelParameters.values().stream().map(TypedTopLevelParameter::new).collect(toSet()));\n    }","id":77741,"modified_method":"private void validate(ExtensionModel extensionModel) throws IllegalModelDefinitionException {\n\n      new ExtensionWalker() {\n\n        @Override\n        public void onConfiguration(ConfigurationModel model) {\n          defaultValidation(model);\n        }\n\n        @Override\n        public void onOperation(HasOperationModels owner, OperationModel model) {\n          validateOperation(model);\n          registerNamedObject(model);\n          validateSingularizedNameClash(model);\n        }\n\n        @Override\n        public void onConnectionProvider(HasConnectionProviderModels owner, ConnectionProviderModel model) {\n          defaultValidation(model);\n        }\n\n        @Override\n        public void onSource(HasSourceModels owner, SourceModel model) {\n          defaultValidation(model);\n        }\n\n        @Override\n        public void onParameter(ParameterizedModel owner, ParameterModel model) {\n          validateTopLevelParameter(model, owner);\n        }\n\n        private void defaultValidation(ParameterizedModel model) {\n          validateParameterNames(model);\n          registerNamedObject(model);\n          validateSingularizedNameClash(model);\n        }\n\n        private void registerNamedObject(Named named) {\n          namedObjects.add(new DescribedReference<>(named));\n        }\n      }.walk(extensionModel);\n\n      validateSingularizeNameClashesWithTopLevels();\n      validateNameClashes(namedObjects, topLevelParameters.values(),\n                          topLevelParameters.values().stream().map(TypedTopLevelParameter::new).collect(toSet()));\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n      if (obj instanceof DescribedReference) {\n        return super.equals(obj);\n      }\n\n      return false;\n    }","id":77742,"modified_method":"@Override\n    public boolean equals(Object obj) {\n      return obj instanceof DescribedReference && super.equals(obj);\n\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"private void validateTopLevelParameter(ParameterModel parameter, ParameterizedModel owner) {\n      if (!isInstantiable(parameter.getType()) || !hasExposedFields(parameter.getType())) {\n        return;\n      }\n\n      final Class<?> parameterType = getType(parameter.getType());\n      final String ownerName = owner.getName();\n      final String ownerType = owner.getClass().getSimpleName();\n\n      Collection<TopLevelParameter> foundParameters = topLevelParameters.get(parameter.getName());\n      if (CollectionUtils.isEmpty(foundParameters)) {\n        Optional<XmlHintsModelProperty> hints = parameter.getModelProperty(XmlHintsModelProperty.class);\n        boolean allowsInline = hints.map(XmlHintsModelProperty::allowsInlineDefinition).orElse(true);\n\n        if (allowsInline) {\n          topLevelParameters.put(parameter.getName(), new TopLevelParameter(parameter, ownerName, ownerType));\n        }\n      } else {\n        Optional<TopLevelParameter> repeated =\n            foundParameters.stream().filter(topLevelParameter -> !topLevelParameter.type.equals(parameterType)).findFirst();\n\n        if (repeated.isPresent()) {\n          TopLevelParameter tp = repeated.get();\n          throw new IllegalModelDefinitionException(format(\"Extension '%s' defines an %s of name '%s' which contains parameter '%s' of complex type '%s'. However, \"\n              + \"%s of name '%s' defines a parameter of the same name but type '%s'. Complex parameter of different types cannot have the same name.\",\n                                                           extensionModel.getName(),\n                                                           ownerType, ownerName,\n                                                           parameter.getName(),\n                                                           parameterType,\n                                                           tp.ownerType, tp.owner, tp.type.getName()));\n        }\n      }\n    }","id":77743,"modified_method":"private void validateTopLevelParameter(ParameterModel parameter, ParameterizedModel owner) {\n      MetadataType metadataType = parameter.getType();\n      if (!isInstantiable(metadataType) || !hasExposedFields(metadataType)) {\n        return;\n      }\n\n      final Class<?> parameterType = getType(metadataType);\n      final String ownerName = owner.getName();\n      final String ownerType = owner.getClass().getSimpleName();\n\n      Collection<TopLevelParameter> foundParameters = topLevelParameters.get(parameter.getName());\n      if (CollectionUtils.isEmpty(foundParameters)) {\n        Optional<XmlHintsModelProperty> hints = parameter.getModelProperty(XmlHintsModelProperty.class);\n        boolean allowsInline = hints.map(XmlHintsModelProperty::allowsInlineDefinition).orElse(true);\n\n        if (allowsInline) {\n          topLevelParameters.put(parameter.getName(), new TopLevelParameter(parameter, ownerName, ownerType));\n        }\n      } else {\n        Optional<TopLevelParameter> repeated =\n            foundParameters.stream().filter(topLevelParameter -> !topLevelParameter.type.equals(parameterType)).findFirst();\n\n        if (repeated.isPresent()) {\n          TopLevelParameter tp = repeated.get();\n          throw new IllegalModelDefinitionException(\n                                                    format(\"Extension '%s' defines an %s of name '%s' which contains parameter '%s' of complex type '%s'. However, \"\n                                                        + \"%s of name '%s' defines a parameter of the same name but type '%s'. Complex parameter of different types cannot have the same name.\",\n                                                           extensionModel.getName(),\n                                                           ownerType, ownerName,\n                                                           parameter.getName(),\n                                                           parameterType,\n                                                           tp.ownerType, tp.owner, tp.type.getName()));\n        }\n      }\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"private void validateOperation(OperationModel operation) {\n      validateParameterNames(operation);\n      // Check clash between each operation and its parameters type\n      operation.getParameterModels().stream()\n          .forEach(parameterModel -> validateClash(operation.getName(), getType(parameterModel.getType()).getName(), \"operation\",\n                                                   \"argument\"));\n    }","id":77744,"modified_method":"private void validateOperation(OperationModel operation) {\n      validateParameterNames(operation);\n      // Check clash between each operation and its parameters type\n      operation.getParameterModels().forEach(parameterModel -> validateClash(operation.getName(),\n                                                                             getType(parameterModel.getType()).getName(),\n                                                                             \"operation\", \"argument\"));\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"private Set<String> collectRepeatedNames(List<? extends Named> namedObject) {\n      Set<String> names = new HashSet<>();\n      Set<String> repeatedNames =\n          namedObject.stream().filter(parameter -> !names.add(parameter.getName())).map(Named::getName).collect(toSet());\n\n      return repeatedNames;\n    }","id":77745,"modified_method":"private Set<String> collectRepeatedNames(List<? extends Named> namedObject) {\n      Set<String> names = new HashSet<>();\n      return namedObject.stream()\n          .filter(parameter -> !names.add(parameter.getName()))\n          .map(Named::getName).collect(toSet());\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n      if (obj instanceof TypedTopLevelParameter) {\n        return type.equals(((TypedTopLevelParameter) obj).type);\n      }\n\n      return false;\n    }","id":77746,"modified_method":"@Override\n    public boolean equals(Object obj) {\n      return obj instanceof TypedTopLevelParameter && type.equals(((TypedTopLevelParameter) obj).type);\n\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"private void validateNameClashes(Collection<? extends Named>... collections) {\n      Multimap<String, Named> names = LinkedListMultimap.create();\n      stream(collections).flatMap(Collection::stream).forEach(named -> names.put(named.getName(), named));\n\n      names.asMap().entrySet().forEach(entry -> {\n        List<Named> values = (List<Named>) entry.getValue();\n        if (values.size() > 1) {\n          Set<String> offendingTypes = values.stream().map(Named::getName).collect(toSet());\n          StringBuilder errorMessage =\n              new StringBuilder(format(\"Extension '%s' contains %d \", extensionModel.getName(), values.size()));\n\n          final int top = offendingTypes.size() - 1;\n          int i = 0;\n          for (String offender : offendingTypes) {\n            errorMessage.append(offender);\n\n            if (i + 1 == top) {\n              errorMessage.append(\" and \");\n            } else if (i != top) {\n              errorMessage.append(\", \");\n            }\n\n            i++;\n          }\n\n          errorMessage.append(format(\" which name is '%s'. Names should be unique\", entry.getKey()));\n          throw new IllegalModelDefinitionException(errorMessage.toString());\n        }\n      });\n    }","id":77747,"modified_method":"private void validateNameClashes(Collection<? extends Named>... collections) {\n      Multimap<String, Named> names = LinkedListMultimap.create();\n      stream(collections).flatMap(Collection::stream).forEach(named -> names.put(hyphenize(named.getName()), named));\n      validateNameClashBetweenElements(names);\n    }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void operationNameClashesWithParameterTypeName() {\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, Banana.class);\n    when(operationModel.getName()).thenReturn(Banana.class.getName());\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","id":77748,"modified_method":"@Test\n  public void operationNameClashesWithParameterTypeName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, Banana.class);\n    when(operationModel.getName()).thenReturn(Banana.class.getName());\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void operationClashingWithConfig() {\n    when(configurationModel.getName()).thenReturn(OPERATION_NAME);\n    validate();\n  }","id":77749,"modified_method":"@Test\n  public void operationClashingWithConfig() {\n    exception.expect(IllegalModelDefinitionException.class);\n    when(configurationModel.getName()).thenReturn(OPERATION_NAME);\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderWithRepeatedParameterName() {\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, String.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","id":77750,"modified_method":"@Test\n  public void connectionProviderWithRepeatedParameterName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, String.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void configNameClashesWithOperationParameterType() {\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, Banana.class);\n    when(configurationModel.getName()).thenReturn(Banana.class.getName());\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","id":77751,"modified_method":"@Test\n  public void configNameClashesWithOperationParameterType() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, Banana.class);\n    when(configurationModel.getName()).thenReturn(Banana.class.getName());\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void operationTopLevelParameterCrashesWithOperationName() {\n    ParameterModel offending = getParameter(OPERATION_NAME, Apple.class);\n    when(operationModel.getParameterModels()).thenReturn(asList(simpleOperationParam, topLevelOperationParam, offending));\n    validate();\n  }","id":77752,"modified_method":"@Test\n  public void operationTopLevelParameterCrashesWithOperationName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(OPERATION_NAME, Apple.class);\n    when(operationModel.getParameterModels()).thenReturn(asList(simpleOperationParam, topLevelOperationParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void configWithRepeatedParameterName() {\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, String.class);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam, offending));\n    validate();\n  }","id":77753,"modified_method":"@Test\n  public void configWithRepeatedParameterName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, String.class);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderNameClashesWithOperationParameterType() {\n    ParameterModel offending = getParameter(connectionProviderModel.getName(), Banana.class);\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","id":77754,"modified_method":"@Test\n  public void connectionProviderNameClashesWithOperationParameterType() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(connectionProviderModel.getName(), Banana.class);\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void configTopLevelParameterCrashesWithOperationName() {\n    ParameterModel offending = getParameter(TOP_LEVEL_OPERATION_PARAM_NAME, Banana.class);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam, offending));\n    validate();\n  }","id":77755,"modified_method":"@Test\n  public void configTopLevelParameterCrashesWithOperationName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(TOP_LEVEL_OPERATION_PARAM_NAME, Banana.class);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Before\n  public void before() {\n    when(extensionModel.getName()).thenReturn(\"extensionName\");\n    when(extensionModel.getConfigurationModels()).thenReturn(asList(configurationModel));\n    when(extensionModel.getOperationModels()).thenReturn(asList(operationModel));\n    when(extensionModel.getConnectionProviders()).thenReturn(asList(connectionProviderModel));\n\n    simpleConfigParam = getParameter(SIMPLE_PARAM_NAME, String.class);\n    topLevelConfigParam = getParameter(\"topLevelConfigParam\", Apple.class);\n    simpleOperationParam = getParameter(SIMPLE_PARAM_NAME, String.class);\n    topLevelOperationParam = getParameter(TOP_LEVEL_OPERATION_PARAM_NAME, Apple.class);\n    simpleConnectionProviderParam = getParameter(SIMPLE_PARAM_NAME, String.class);\n    topLevelConnectionProviderParam = getParameter(\"topLevelConnectionProviderParam\", Apple.class);\n\n    when(configurationModel.getName()).thenReturn(CONFIG_NAME);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam));\n    when(configurationModel.getOperationModels()).thenReturn(ImmutableList.of());\n    when(configurationModel.getConnectionProviders()).thenReturn(ImmutableList.of());\n\n    when(operationModel.getName()).thenReturn(OPERATION_NAME);\n    when(operationModel.getParameterModels()).thenReturn(asList(simpleOperationParam, topLevelOperationParam));\n    when(connectionProviderModel.getName()).thenReturn(CONNECTION_PROVIDER_NAME);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam));\n  }","id":77756,"modified_method":"@Before\n  public void before() {\n    when(extensionModel.getName()).thenReturn(\"extensionName\");\n    when(extensionModel.getConfigurationModels()).thenReturn(singletonList(configurationModel));\n    when(extensionModel.getOperationModels()).thenReturn(singletonList(operationModel));\n    when(extensionModel.getConnectionProviders()).thenReturn(singletonList(connectionProviderModel));\n\n    simpleConfigParam = getParameter(SIMPLE_PARAM_NAME, String.class);\n    topLevelConfigParam = getParameter(\"topLevelConfigParam\", Apple.class);\n    simpleOperationParam = getParameter(SIMPLE_PARAM_NAME, String.class);\n    topLevelOperationParam = getParameter(TOP_LEVEL_OPERATION_PARAM_NAME, Apple.class);\n    simpleConnectionProviderParam = getParameter(SIMPLE_PARAM_NAME, String.class);\n    topLevelConnectionProviderParam = getParameter(\"topLevelConnectionProviderParam\", Apple.class);\n\n    when(configurationModel.getName()).thenReturn(CONFIG_NAME);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam));\n    when(configurationModel.getOperationModels()).thenReturn(ImmutableList.of());\n    when(configurationModel.getConnectionProviders()).thenReturn(ImmutableList.of());\n\n    when(operationModel.getName()).thenReturn(OPERATION_NAME);\n    when(operationModel.getParameterModels()).thenReturn(asList(simpleOperationParam, topLevelOperationParam));\n    when(connectionProviderModel.getName()).thenReturn(CONNECTION_PROVIDER_NAME);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam));\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderTopLevelParameterCrashesWithConfigName() {\n    ParameterModel offending = getParameter(CONFIG_NAME, Apple.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","id":77757,"modified_method":"@Test\n  public void connectionProviderTopLevelParameterCrashesWithConfigName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(CONFIG_NAME, Apple.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderTopLevelParameterCrashesWithName() {\n    ParameterModel offending = getParameter(CONNECTION_PROVIDER_NAME, Apple.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","id":77758,"modified_method":"@Test\n  public void connectionProviderTopLevelParameterCrashesWithName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(CONNECTION_PROVIDER_NAME, Apple.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderClashesWithConfig() {\n    when(connectionProviderModel.getName()).thenReturn(CONFIG_NAME);\n    validate();\n  }","id":77759,"modified_method":"@Test\n  public void connectionProviderClashesWithConfig() {\n    exception.expect(IllegalModelDefinitionException.class);\n    when(connectionProviderModel.getName()).thenReturn(CONFIG_NAME);\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void operationWithRepeatedParameterName() {\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, String.class);\n    when(operationModel.getParameterModels()).thenReturn(asList(simpleOperationParam, topLevelOperationParam, offending));\n    validate();\n  }","id":77760,"modified_method":"@Test\n  public void operationWithRepeatedParameterName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, String.class);\n    when(operationModel.getParameterModels()).thenReturn(asList(simpleOperationParam, topLevelOperationParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void configTopLevelParameterCrashesWithConfigName() {\n    ParameterModel offending = getParameter(CONFIG_NAME, Apple.class);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam, offending));\n    validate();\n  }","id":77761,"modified_method":"@Test\n  public void configTopLevelParameterCrashesWithConfigName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(CONFIG_NAME, Apple.class);\n    when(configurationModel.getParameterModels()).thenReturn(asList(simpleConfigParam, topLevelConfigParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderNameClashesWithOperationParameterName() {\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, Banana.class);\n    when(connectionProviderModel.getName()).thenReturn(SIMPLE_PARAM_NAME);\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","id":77762,"modified_method":"@Test\n  public void connectionProviderNameClashesWithOperationParameterName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(SIMPLE_PARAM_NAME, Banana.class);\n    when(connectionProviderModel.getName()).thenReturn(SIMPLE_PARAM_NAME);\n    when(operationModel.getParameterModels()).thenReturn(asList(topLevelOperationParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = IllegalModelDefinitionException.class)\n  public void connectionProviderTopLevelParameterCrashesWithOperationName() {\n    ParameterModel offending = getParameter(TOP_LEVEL_OPERATION_PARAM_NAME, Banana.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","id":77763,"modified_method":"@Test\n  public void connectionProviderTopLevelParameterCrashesWithOperationName() {\n    exception.expect(IllegalModelDefinitionException.class);\n    ParameterModel offending = getParameter(TOP_LEVEL_OPERATION_PARAM_NAME, Banana.class);\n    when(connectionProviderModel.getParameterModels())\n        .thenReturn(asList(simpleConnectionProviderParam, topLevelConnectionProviderParam, offending));\n    validate();\n  }","commit_id":"472c90d5817efc0cd4ca97e7745143122370e37e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public boolean dispatch(Runnable job)\n    {\n        LOG.debug(\"{} dispatched {}\",this,job);\n        if (isRunning())\n        {\n            final int jobQ = _jobs.size();\n            final int idle = getIdleThreads();\n            if(_jobs.offer(job))\n            {\n                // If we had no idle threads or the jobQ is greater than the idle threads\n                if (idle==0 || jobQ>idle)\n                {\n                    int threads=_threadsStarted.get();\n                    if (threads<_maxThreads)\n                        startThread(threads);\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":77764,"modified_method":"@Override\n    public boolean dispatch(Runnable job)\n    {\n        LOG.debug(\"{} dispatched {}\",this,job);\n        if (isRunning())\n        {\n            return _jobs.offer(job);\n        }\n        return false;\n    }","commit_id":"b3381b4996f3cd6d9e86fe78333e7899898e2582","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Set the minimum number of threads.\n     * Delegated to the named or anonymous Pool.\n     * @see #getMinThreads\n     * @param minThreads minimum number of threads\n     */\n    @Override\n    public void setMinThreads(int minThreads)\n    {\n        _minThreads=minThreads;\n\n        if (_minThreads>_maxThreads)\n            _maxThreads=_minThreads;\n\n        int threads=_threadsStarted.get();\n        while (isStarted() && threads<_minThreads)\n        {\n            startThread(threads);\n            threads=_threadsStarted.get();\n        }\n    }","id":77765,"modified_method":"/** Set the minimum number of threads.\n     * Delegated to the named or anonymous Pool.\n     * @see #getMinThreads\n     * @param minThreads minimum number of threads\n     */\n    @Override\n    public void setMinThreads(int minThreads)\n    {\n        _minThreads=minThreads;\n\n        if (_minThreads>_maxThreads)\n            _maxThreads=_minThreads;\n\n        int threads=_threadsStarted.get();\n        if (isStarted() && threads<_minThreads)\n            startThreads(_minThreads-threads);\n    }","commit_id":"b3381b4996f3cd6d9e86fe78333e7899898e2582","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        return String.format(\"%s{%s,%d<=%d<=%d/%d,%d}\",_name,getState(),getMinThreads(),getIdleThreads(),getThreads(),getMaxThreads(),(_jobs==null?-1:_jobs.size()));\n    }","id":77766,"modified_method":"@Override\n    public String toString()\n    {\n        return String.format(\"%s{%s,%d<=%d<=%d,i=%d,q=%d}\",_name,getState(),getMinThreads(),getThreads(),getMaxThreads(),getIdleThreads(),(_jobs==null?-1:_jobs.size()));\n    }","commit_id":"b3381b4996f3cd6d9e86fe78333e7899898e2582","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void doStart() throws Exception\n    {\n        super.doStart();\n        _threadsStarted.set(0);\n\n        if (_jobs==null)\n        {\n            int maxQueued = getMaxQueued();\n            _jobs=maxQueued>0 ?new ArrayBlockingQueue<Runnable>(maxQueued)\n                :new BlockingArrayQueue<Runnable>(_minThreads,_minThreads);\n        }\n\n        int threads=_threadsStarted.get();\n        while (isRunning() && threads<_minThreads)\n        {\n            startThread(threads);\n            threads=_threadsStarted.get();\n        }\n    }","id":77767,"modified_method":"@Override\n    protected void doStart() throws Exception\n    {\n        super.doStart();\n        _threadsStarted.set(0);\n\n        if (_jobs==null)\n        {\n            int maxQueued = getMaxQueued();\n            _jobs=maxQueued>0 ?new ArrayBlockingQueue<Runnable>(maxQueued)\n                :new BlockingArrayQueue<Runnable>(_minThreads,_minThreads);\n        }\n\n        startThreads(_minThreads);\n    }","commit_id":"b3381b4996f3cd6d9e86fe78333e7899898e2582","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private boolean startThread(int threads)\n    {\n        final int next=threads+1;\n        if (!_threadsStarted.compareAndSet(threads,next))\n            return false;\n\n        boolean started=false;\n        try\n        {\n            Thread thread=newThread(_runnable);\n            thread.setDaemon(isDaemon());\n            thread.setPriority(getThreadsPriority());\n            thread.setName(_name+\"-\"+thread.getId());\n            _threads.add(thread);\n\n            thread.start();\n            started=true;\n        }\n        finally\n        {\n            if (!started)\n                _threadsStarted.decrementAndGet();\n        }\n        return started;\n    }","id":77768,"modified_method":"private boolean startThreads(int threadsToStart)\n    {\n        while(threadsToStart>0)\n        {\n            int threads=_threadsStarted.get();\n            if (threads>=_maxThreads)\n                return false;\n            \n            if (!_threadsStarted.compareAndSet(threads,threads+1))\n                continue;\n\n            boolean started=false;\n            try\n            {\n                Thread thread=newThread(_runnable);\n                thread.setDaemon(isDaemon());\n                thread.setPriority(getThreadsPriority());\n                thread.setName(_name+\"-\"+thread.getId());\n                _threads.add(thread);\n\n                thread.start();\n                started=true;\n            }\n            finally\n            {\n                if (!started)\n                    _threadsStarted.decrementAndGet();\n            }\n            if (started)\n                threadsToStart--;\n        }\n        return true;\n    }","commit_id":"b3381b4996f3cd6d9e86fe78333e7899898e2582","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    @Slow\n    public void testThreadPool() throws Exception\n    {\n        QueuedThreadPool tp= new QueuedThreadPool();\n        tp.setMinThreads(5);\n        tp.setMaxThreads(10);\n        tp.setMaxIdleTimeMs(1000);\n        tp.setThreadsPriority(Thread.NORM_PRIORITY-1);\n\n        tp.start();\n\n        waitForThreads(tp,5);\n        waitForIdle(tp,5);\n\n        Thread.sleep(1000);\n        waitForThreads(tp,5);\n        waitForIdle(tp,5);\n\n        RunningJob job=new RunningJob();\n        tp.dispatch(job);\n        waitForIdle(tp,4);\n        waitForThreads(tp,5);\n\n        job.stop();\n        waitForIdle(tp,5);\n        waitForThreads(tp,5);\n\n        Thread.sleep(200);\n        waitForIdle(tp,5);\n        waitForThreads(tp,5);\n\n        RunningJob[] jobs = new RunningJob[5];\n        for (int i=0;i<jobs.length;i++)\n        {\n            jobs[i]=new RunningJob();\n            tp.dispatch(jobs[i]);\n        }\n        waitForIdle(tp,0);\n        waitForThreads(tp,5);\n\n        job=new RunningJob();\n        tp.dispatch(job);\n        waitForThreads(tp,6);\n\n        job.stop();\n        waitForThreads(tp,5);\n\n        jobs[0].stop();\n        waitForIdle(tp,1);\n        waitForThreads(tp,5);\n\n        for (int i=1;i<jobs.length;i++)\n            jobs[i].stop();\n\n        waitForIdle(tp,5);\n        waitForThreads(tp,5);\n\n        jobs = new RunningJob[15];\n        for (int i=0;i<jobs.length;i++)\n        {\n            jobs[i]=new RunningJob();\n            tp.dispatch(jobs[i]);\n        }\n        waitForIdle(tp,0);\n        waitForThreads(tp,10);\n        for (int i=0;i<9;i++)\n            jobs[i].stop();\n        waitForThreads(tp,9);\n\n        for (int i=9;i<jobs.length;i++)\n            jobs[i].stop();\n        waitForIdle(tp,5);\n        tp.stop();\n    }","id":77769,"modified_method":"@Test\n    @Slow\n    public void testThreadPool() throws Exception\n    {\n        QueuedThreadPool tp= new QueuedThreadPool();\n        tp.setMinThreads(5);\n        tp.setMaxThreads(10);\n        tp.setMaxIdleTimeMs(1000);\n        tp.setThreadsPriority(Thread.NORM_PRIORITY-1);\n        \n        tp.start();\n       \n        waitForThreads(tp,5);\n        waitForIdle(tp,5);\n\n        Thread.sleep(1000);\n        waitForThreads(tp,5);\n        waitForIdle(tp,5);\n\n        RunningJob job=new RunningJob();\n        tp.dispatch(job);\n        waitForIdle(tp,4);\n        waitForThreads(tp,5);\n\n        job.stop();\n        waitForIdle(tp,5);\n        waitForThreads(tp,5);\n\n        Thread.sleep(200);\n        waitForIdle(tp,5);\n        waitForThreads(tp,5);\n\n        RunningJob[] jobs = new RunningJob[5];\n        for (int i=0;i<jobs.length;i++)\n        {\n            jobs[i]=new RunningJob();\n            tp.dispatch(jobs[i]);\n        }\n        \n        waitForIdle(tp,1);\n        waitForThreads(tp,6);\n\n        job=new RunningJob();\n        tp.dispatch(job);\n        waitForIdle(tp,1);\n        waitForThreads(tp,7);\n\n        job.stop();\n        waitForIdle(tp,2);\n        waitForThreads(tp,7);\n        waitForThreads(tp,6);\n        waitForIdle(tp,1);\n\n        jobs[0].stop();\n        waitForIdle(tp,1);\n        waitForThreads(tp,5);\n\n        for (int i=1;i<jobs.length;i++)\n            jobs[i].stop();\n\n        waitForIdle(tp,5);\n        waitForThreads(tp,5);\n\n        jobs = new RunningJob[15];\n        for (int i=0;i<jobs.length;i++)\n        {\n            jobs[i]=new RunningJob();\n            tp.dispatch(jobs[i]);\n        }\n\n        waitForIdle(tp,0);\n        waitForThreads(tp,10);\n        for (int i=0;i<9;i++)\n            jobs[i].stop();\n        waitForThreads(tp,9);\n\n        for (int i=9;i<jobs.length;i++)\n            jobs[i].stop();\n        waitForIdle(tp,5);\n        tp.stop();\n    }","commit_id":"b3381b4996f3cd6d9e86fe78333e7899898e2582","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString() {\n        if (packageFqName.isRoot()) return \"/\" + relativeClassName;\n        return packageFqName.toString().replace('.', '/') + \"/\" + relativeClassName;\n    }","id":77770,"modified_method":"@Override\n    public String toString() {\n        return packageFqName.isRoot() ? \"/\" + asString() : asString();\n    }","commit_id":"3b9d90429b7d81a40c55a66d446dfe4f28075dde","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JvmSerializerExtension(@NotNull JvmSerializationBindings bindings, @NotNull JetTypeMapper typeMapper) {\n        this.bindings = bindings;\n        this.typeMapper = typeMapper;\n    }","id":77771,"modified_method":"public JvmSerializerExtension(@NotNull JvmSerializationBindings bindings, @NotNull JetTypeMapper typeMapper) {\n        this.bindings = bindings;\n        this.stringTable = new JvmStringTable(typeMapper);\n        this.annotationSerializer = new AnnotationSerializer(stringTable);\n    }","commit_id":"3b9d90429b7d81a40c55a66d446dfe4f28075dde","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public int getFqNameIndex(@NotNull ClassDescriptor descriptor) {\n        if (ErrorUtils.isError(descriptor)) {\n            throw new IllegalStateException(\"Cannot get FQ name of error class: \" + descriptor);\n        }\n\n        QualifiedName.Builder builder = QualifiedName.newBuilder();\n        builder.setKind(QualifiedName.Kind.CLASS);\n\n        DeclarationDescriptor containingDeclaration = descriptor.getContainingDeclaration();\n        String shortName;\n        if (containingDeclaration instanceof PackageFragmentDescriptor) {\n            shortName = descriptor.getName().asString();\n            FqName packageFqName = ((PackageFragmentDescriptor) containingDeclaration).getFqName();\n            if (!packageFqName.isRoot()) {\n                builder.setParentQualifiedName(getPackageFqNameIndex(packageFqName));\n            }\n        }\n        else if (containingDeclaration instanceof ClassDescriptor) {\n            shortName = descriptor.getName().asString();\n            ClassDescriptor outerClass = (ClassDescriptor) containingDeclaration;\n            builder.setParentQualifiedName(getFqNameIndex(outerClass));\n        }\n        else {\n            builder.setKind(QualifiedName.Kind.LOCAL);\n            shortName = extension.getLocalClassName(descriptor);\n        }\n\n        builder.setShortName(getStringIndex(shortName));\n\n        return qualifiedNames.intern(new FqNameProto(builder));\n    }","id":77772,"modified_method":"@Override\n    public int getFqNameIndex(@NotNull ClassDescriptor descriptor) {\n        if (ErrorUtils.isError(descriptor)) {\n            throw new IllegalStateException(\"Cannot get FQ name of error class: \" + descriptor);\n        }\n\n        QualifiedName.Builder builder = QualifiedName.newBuilder();\n        builder.setKind(QualifiedName.Kind.CLASS);\n\n        DeclarationDescriptor containingDeclaration = descriptor.getContainingDeclaration();\n        if (containingDeclaration instanceof PackageFragmentDescriptor) {\n            FqName packageFqName = ((PackageFragmentDescriptor) containingDeclaration).getFqName();\n            if (!packageFqName.isRoot()) {\n                builder.setParentQualifiedName(getPackageFqNameIndex(packageFqName));\n            }\n        }\n        else if (containingDeclaration instanceof ClassDescriptor) {\n            ClassDescriptor outerClass = (ClassDescriptor) containingDeclaration;\n            builder.setParentQualifiedName(getFqNameIndex(outerClass));\n        }\n        else {\n            throw new IllegalStateException(\"Cannot get FQ name of local class: \" + descriptor);\n        }\n\n        builder.setShortName(getStringIndex(descriptor.getName().asString()));\n\n        return qualifiedNames.intern(new FqNameProto(builder));\n    }","commit_id":"3b9d90429b7d81a40c55a66d446dfe4f28075dde","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public String getPath() {\n        if (isRoot()) {\n            // shortcut\n            return \"/\";\n        }\n\n        NodeState nodeState = getNodeState();\n        if (nodeState instanceof KernelNodeState) {\n            return ((KernelNodeState) nodeState).getPath();\n        } else {\n            StringBuilder sb = new StringBuilder();\n            buildPath(sb);\n            return sb.toString();\n        }\n    }","id":77773,"modified_method":"@Override\n    public String getPath() {\n        if (path == null) {\n            if (isRoot()) {\n                // shortcut\n                path = \"/\";\n            } else {\n                StringBuilder sb = new StringBuilder();\n                ImmutableTree parent = getParent();\n                sb.append(parent.getPath());\n                if (!parent.isRoot()) {\n                    sb.append('/');\n                }\n                sb.append(getName());\n                path = sb.toString();\n            }\n        }\n        return path;\n    }","commit_id":"38c14e57fb4e02e39e53a46b5e56bcde39d0756a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n   * Determines if the key represents a folder. If false is returned, it is not guaranteed that the\n   * path exists.\n   *\n   * @param key the key to check\n   * @return whether the given key identifies a folder\n   */\n  private boolean isFolder(String key) {\n    // Root is always a folder\n    if (isRoot(key)) {\n      return true;\n    }\n    try {\n      String keyAsFolder = convertToFolderName(stripPrefixIfPresent(key));\n      mClient.getObjectMetadata(mBucketName, keyAsFolder);\n      // If no exception is thrown, the key exists as a folder\n      return true;\n    } catch (AmazonClientException e) {\n      // It is possible that the folder has not been encoded as a _$folder$ file\n      try {\n        String dir = stripPrefixIfPresent(key);\n        String dirPrefix = PathUtils.normalizePath(dir, PATH_SEPARATOR);\n        // Check if anything begins with <folder_path>/\n        ObjectListing objs = mClient.listObjects(mBucketName, dirPrefix);\n        // If there are, this is a folder and we can create the necessary metadata\n        if (objs.getObjectSummaries().size() > 0) {\n          mkdirsInternal(dir);\n          return true;\n        } else {\n          return false;\n        }\n      } catch (AmazonClientException ace) {\n        return false;\n      }\n    }\n  }","id":77774,"modified_method":"/**\n   * Determines if the key represents a folder. If false is returned, it is not guaranteed that the\n   * path exists.\n   *\n   * @param key the key to check\n   * @return whether the given key identifies a folder\n   */\n  private boolean isFolder(String key) {\n    // Root is always a folder\n    return isRoot(key) || getFolderMetadata(key) != null;\n  }","commit_id":"57b09b37b4f6a83228aee10096fd2ce81a6c8551","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @param key the key to get the object details of\n   * @return {@link ObjectMetadata} of the key, or null if the key does not exist\n   */\n  private ObjectMetadata getObjectDetails(String key) {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(stripPrefixIfPresent(key));\n        return mClient.getObjectMetadata(mBucketName, keyAsFolder);\n      } else {\n        return mClient.getObjectMetadata(mBucketName, stripPrefixIfPresent(key));\n      }\n    } catch (AmazonClientException e) {\n      return null;\n    }\n  }","id":77775,"modified_method":"/**\n   * @param key the key to get the object details of\n   * @return {@link ObjectMetadata} of the key, or null if the key does not exist\n   */\n  private ObjectMetadata getObjectDetails(String key) {\n    // We try to get the metadata as a file and then a folder without checking isFolder to reduce\n    // the number of calls to S3.\n    try {\n      return mClient.getObjectMetadata(mBucketName, stripPrefixIfPresent(key));\n    } catch (AmazonClientException e) {\n      // Its possible that the object is not a file but a folder\n      return getFolderMetadata(stripPrefixIfPresent(key));\n    }\n  }","commit_id":"57b09b37b4f6a83228aee10096fd2ce81a6c8551","url":"https://github.com/amplab/tachyon"},{"original_method":"public static final Number subtract(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return new Long(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.subtract(num0, num1);\n    }","id":77776,"modified_method":"public static final Number subtract(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return Long.valueOf(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.subtract(num0, num1);\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number subtract(Number num0, Number num1) {\n            return new Long(num0.longValue() - num1.longValue());\n        }","id":77777,"modified_method":"@Override\n        protected Number subtract(Number num0, Number num1) {\n            return Long.valueOf(num0.longValue() - num1.longValue());\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"public static final Number add(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return new Long(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.add(num0, num1);\n    }","id":77778,"modified_method":"public static final Number add(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return Long.valueOf(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.add(num0, num1);\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number add(Number num0, Number num1) {\n            return new Long(num0.longValue() + num1.longValue());\n        }","id":77779,"modified_method":"@Override\n        protected Number add(Number num0, Number num1) {\n            return Long.valueOf(num0.longValue() + num1.longValue());\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number coerce(String str) {\n            return new Long(str);\n        }","id":77780,"modified_method":"@Override\n        protected Number coerce(String str) {\n            return Long.valueOf(str);\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"protected final Number coerce(final Object obj) {\n\n        if (isNumber(obj)) {\n            return coerce((Number) obj);\n        }\n        if (obj instanceof String) {\n            return coerce((String) obj);\n        }\n        if (obj == null || \"\".equals(obj)) {\n            return coerce(ZERO);\n        }\n\n        if (obj instanceof Character) {\n            return coerce(new Short((short) ((Character) obj).charValue()));\n        }\n\n        throw new IllegalArgumentException(MessageFactory.get(\"error.convert\",\n                obj, obj.getClass(), \"Number\"));\n    }","id":77781,"modified_method":"protected final Number coerce(final Object obj) {\n\n        if (isNumber(obj)) {\n            return coerce((Number) obj);\n        }\n        if (obj instanceof String) {\n            return coerce((String) obj);\n        }\n        if (obj == null || \"\".equals(obj)) {\n            return coerce(ZERO);\n        }\n\n        if (obj instanceof Character) {\n            return coerce(Short.valueOf((short) ((Character) obj).charValue()));\n        }\n\n        throw new IllegalArgumentException(MessageFactory.get(\"error.convert\",\n                obj, obj.getClass(), \"Number\"));\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"public static final Number multiply(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return new Long(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.multiply(num0, num1);\n    }","id":77782,"modified_method":"public static final Number multiply(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return Long.valueOf(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.multiply(num0, num1);\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number coerce(Number num) {\n            if (num instanceof Long)\n                return num;\n            return new Long(num.longValue());\n        }","id":77783,"modified_method":"@Override\n        protected Number coerce(Number num) {\n            if (num instanceof Long)\n                return num;\n            return Long.valueOf(num.longValue());\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number multiply(Number num0, Number num1) {\n            return new Long(num0.longValue() * num1.longValue());\n        }","id":77784,"modified_method":"@Override\n        protected Number multiply(Number num0, Number num1) {\n            return Long.valueOf(num0.longValue() * num1.longValue());\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number divide(Number num0, Number num1) {\n            return new Long(num0.longValue() / num1.longValue());\n        }","id":77785,"modified_method":"@Override\n        protected Number divide(Number num0, Number num1) {\n            return Long.valueOf(num0.longValue() / num1.longValue());\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"public static final Number mod(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return new Long(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.mod(num0, num1);\n    }","id":77786,"modified_method":"public static final Number mod(final Object obj0, final Object obj1) {\n        if (obj0 == null && obj1 == null) {\n            return Long.valueOf(0);\n        }\n\n        final ELArithmetic delegate;\n        if (BIGDECIMAL.matches(obj0, obj1))\n            delegate = BIGDECIMAL;\n        else if (DOUBLE.matches(obj0, obj1))\n            delegate = DOUBLE;\n        else if (BIGINTEGER.matches(obj0, obj1))\n            delegate = BIGINTEGER;\n        else\n            delegate = LONG;\n\n        Number num0 = delegate.coerce(obj0);\n        Number num1 = delegate.coerce(obj1);\n\n        return delegate.mod(num0, num1);\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected Number mod(Number num0, Number num1) {\n            return new Long(num0.longValue() % num1.longValue());\n        }","id":77787,"modified_method":"@Override\n        protected Number mod(Number num0, Number num1) {\n            return Long.valueOf(num0.longValue() % num1.longValue());\n        }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"public static final Character coerceToCharacter(final Object obj)\n            throws ELException {\n        if (obj == null || \"\".equals(obj)) {\n            return new Character((char) 0);\n        }\n        if (obj instanceof String) {\n            return new Character(((String) obj).charAt(0));\n        }\n        if (ELArithmetic.isNumber(obj)) {\n            return new Character((char) ((Number) obj).shortValue());\n        }\n        Class<?> objType = obj.getClass();\n        if (obj instanceof Character) {\n            return (Character) obj;\n        }\n\n        throw new ELException(MessageFactory.get(\"error.convert\",\n                obj, objType, Character.class));\n    }","id":77788,"modified_method":"public static final Character coerceToCharacter(final Object obj)\n            throws ELException {\n        if (obj == null || \"\".equals(obj)) {\n            return Character.valueOf((char) 0);\n        }\n        if (obj instanceof String) {\n            return Character.valueOf(((String) obj).charAt(0));\n        }\n        if (ELArithmetic.isNumber(obj)) {\n            return Character.valueOf((char) ((Number) obj).shortValue());\n        }\n        Class<?> objType = obj.getClass();\n        if (obj instanceof Character) {\n            return (Character) obj;\n        }\n\n        throw new ELException(MessageFactory.get(\"error.convert\",\n                obj, objType, Character.class));\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"protected static final Number coerceToNumber(final Number number,\n            final Class<?> type) throws ELException {\n        if (Long.TYPE == type || Long.class.equals(type)) {\n            return new Long(number.longValue());\n        }\n        if (Double.TYPE == type || Double.class.equals(type)) {\n            return new Double(number.doubleValue());\n        }\n        if (Integer.TYPE == type || Integer.class.equals(type)) {\n            return new Integer(number.intValue());\n        }\n        if (BigInteger.class.equals(type)) {\n            if (number instanceof BigDecimal) {\n                return ((BigDecimal) number).toBigInteger();\n            }\n            if (number instanceof BigInteger) {\n                return number;\n            }\n            return BigInteger.valueOf(number.longValue());\n        }\n        if (BigDecimal.class.equals(type)) {\n            if (number instanceof BigDecimal) {\n                return number;\n            }\n            if (number instanceof BigInteger) {\n                return new BigDecimal((BigInteger) number);\n            }\n            return new BigDecimal(number.doubleValue());\n        }\n        if (Byte.TYPE == type || Byte.class.equals(type)) {\n            return new Byte(number.byteValue());\n        }\n        if (Short.TYPE == type || Short.class.equals(type)) {\n            return new Short(number.shortValue());\n        }\n        if (Float.TYPE == type || Float.class.equals(type)) {\n            return new Float(number.floatValue());\n        }\n        if (Number.class.equals(type)) {\n            return number;\n        }\n\n        throw new ELException(MessageFactory.get(\"error.convert\",\n                number, number.getClass(), type));\n    }","id":77789,"modified_method":"protected static final Number coerceToNumber(final Number number,\n            final Class<?> type) throws ELException {\n        if (Long.TYPE == type || Long.class.equals(type)) {\n            return Long.valueOf(number.longValue());\n        }\n        if (Double.TYPE == type || Double.class.equals(type)) {\n            return new Double(number.doubleValue());\n        }\n        if (Integer.TYPE == type || Integer.class.equals(type)) {\n            return Integer.valueOf(number.intValue());\n        }\n        if (BigInteger.class.equals(type)) {\n            if (number instanceof BigDecimal) {\n                return ((BigDecimal) number).toBigInteger();\n            }\n            if (number instanceof BigInteger) {\n                return number;\n            }\n            return BigInteger.valueOf(number.longValue());\n        }\n        if (BigDecimal.class.equals(type)) {\n            if (number instanceof BigDecimal) {\n                return number;\n            }\n            if (number instanceof BigInteger) {\n                return new BigDecimal((BigInteger) number);\n            }\n            return new BigDecimal(number.doubleValue());\n        }\n        if (Byte.TYPE == type || Byte.class.equals(type)) {\n            return Byte.valueOf(number.byteValue());\n        }\n        if (Short.TYPE == type || Short.class.equals(type)) {\n            return Short.valueOf(number.shortValue());\n        }\n        if (Float.TYPE == type || Float.class.equals(type)) {\n            return new Float(number.floatValue());\n        }\n        if (Number.class.equals(type)) {\n            return number;\n        }\n\n        throw new ELException(MessageFactory.get(\"error.convert\",\n                number, number.getClass(), type));\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"public static final Number coerceToNumber(final Object obj,\n            final Class<?> type) throws ELException {\n        if (obj == null || \"\".equals(obj)) {\n            return coerceToNumber(ZERO, type);\n        }\n        if (obj instanceof String) {\n            return coerceToNumber((String) obj, type);\n        }\n        if (ELArithmetic.isNumber(obj)) {\n            return coerceToNumber((Number) obj, type);\n        }\n\n        if (obj instanceof Character) {\n            return coerceToNumber(new Short((short) ((Character) obj)\n                    .charValue()), type);\n        }\n\n        throw new ELException(MessageFactory.get(\"error.convert\",\n                obj, obj.getClass(), type));\n    }","id":77790,"modified_method":"public static final Number coerceToNumber(final Object obj,\n            final Class<?> type) throws ELException {\n        if (obj == null || \"\".equals(obj)) {\n            return coerceToNumber(ZERO, type);\n        }\n        if (obj instanceof String) {\n            return coerceToNumber((String) obj, type);\n        }\n        if (ELArithmetic.isNumber(obj)) {\n            return coerceToNumber((Number) obj, type);\n        }\n\n        if (obj instanceof Character) {\n            return coerceToNumber(Short.valueOf((short) ((Character) obj)\n                    .charValue()), type);\n        }\n\n        throw new ELException(MessageFactory.get(\"error.convert\",\n                obj, obj.getClass(), type));\n    }","commit_id":"363d5a8c687e41645dee1d6d50cae5988d1bc1ae","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Sets output size.\n     *\n     * @param size size to set\n     */\n    public void setOutputSize(Dimension size)\n    {\n        if(size == null)\n            size = new Dimension(640, 480);\n\n        supportedOutputFormats[0] = new YUVFormat(size, -1, Format.byteArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[1] = new YUVFormat(size, -1, Format.intArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[2] = new YUVFormat(size, -1, Format.shortArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[3] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[4] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[5] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[6] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[7] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[8] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 24, -1, -1, -1);\n\n        // Set the size to the outputFormat as well.\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        /*\n         * Since the size of the Format has changed, its size-related properties\n         * should change as well. Format#intersects doesn't seem to be cool\n         * because it preserves them and thus the resulting Format is\n         * inconsistent.\n         */\n        if (outputFormat instanceof RGBFormat)\n        {\n            RGBFormat rgbOutputFormat = (RGBFormat) outputFormat;\n\n            setOutputFormat(\n                new RGBFormat(\n                        size,\n                        Format.NOT_SPECIFIED,\n                        outputFormat.getDataType(),\n                        outputFormat.getFrameRate(),\n                        rgbOutputFormat.getBitsPerPixel(),\n                        rgbOutputFormat.getRedMask(),\n                        rgbOutputFormat.getGreenMask(),\n                        rgbOutputFormat.getBlueMask(),\n                        rgbOutputFormat.getPixelStride(),\n                        size.width, // lineStride\n                        rgbOutputFormat.getFlipped(),\n                        rgbOutputFormat.getEndian()));\n        }\n        else if (outputFormat instanceof YUVFormat)\n        {\n            YUVFormat yuvOutputFormat = (YUVFormat) outputFormat;\n\n            setOutputFormat(\n                new YUVFormat(\n                        size,\n                        Format.NOT_SPECIFIED,\n                        outputFormat.getDataType(),\n                        outputFormat.getFrameRate(),\n                        yuvOutputFormat.getYuvType(),\n                        Format.NOT_SPECIFIED,\n                        Format.NOT_SPECIFIED,\n                        0,\n                        Format.NOT_SPECIFIED,\n                        Format.NOT_SPECIFIED));\n        }\n        else if (outputFormat != null)\n            logger.warn(\n                    \"SwScaler outputFormat of type \"\n                        + outputFormat.getClass().getSimpleName()\n                        + \" is not supported for optimized scaling.\");\n    }","id":77791,"modified_method":"/**\n     * Sets output size.\n     *\n     * @param size size to set\n     */\n    public void setOutputSize(Dimension size)\n    {\n        if(size == null)\n            size = new Dimension(640, 480);\n\n        supportedOutputFormats[0] = new YUVFormat(size, -1, Format.byteArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[1] = new YUVFormat(size, -1, Format.intArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[2] = new YUVFormat(size, -1, Format.shortArray,\n                -1.0f, YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[3] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[4] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[5] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[6] = new RGBFormat(size, -1, Format.byteArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[7] = new RGBFormat(size, -1, Format.intArray,\n                -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[8] = new RGBFormat(size, -1, Format.shortArray,\n                -1.0f, 24, -1, -1, -1);\n\n        // Set the size to the outputFormat as well.\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        /*\n         * Since the size of the Format has changed, its size-related properties\n         * should change as well. Format#intersects doesn't seem to be cool\n         * because it preserves them and thus the resulting Format is\n         * inconsistent.\n         */\n        if (outputFormat instanceof RGBFormat)\n        {\n            RGBFormat rgbOutputFormat = (RGBFormat) outputFormat;\n            Class<?> dataType = outputFormat.getDataType();\n            int bitsPerPixel = rgbOutputFormat.getBitsPerPixel();\n            int pixelStride = rgbOutputFormat.getPixelStride();\n\n            if ((pixelStride == Format.NOT_SPECIFIED)\n                    && (dataType != null)\n                    && (bitsPerPixel != Format.NOT_SPECIFIED))\n                pixelStride\n                    = dataType.equals(Format.byteArray)\n                        ? (bitsPerPixel / 8)\n                        : 1;\n            setOutputFormat(\n                new RGBFormat(\n                        size,\n                        Format.NOT_SPECIFIED,\n                        dataType,\n                        outputFormat.getFrameRate(),\n                        bitsPerPixel,\n                        rgbOutputFormat.getRedMask(),\n                        rgbOutputFormat.getGreenMask(),\n                        rgbOutputFormat.getBlueMask(),\n                        pixelStride,\n                        (pixelStride == Format.NOT_SPECIFIED)\n                            ? Format.NOT_SPECIFIED\n                            : (pixelStride * size.width), // lineStride\n                        rgbOutputFormat.getFlipped(),\n                        rgbOutputFormat.getEndian()));\n        }\n        else if (outputFormat instanceof YUVFormat)\n        {\n            YUVFormat yuvOutputFormat = (YUVFormat) outputFormat;\n\n            setOutputFormat(\n                new YUVFormat(\n                        size,\n                        Format.NOT_SPECIFIED,\n                        outputFormat.getDataType(),\n                        outputFormat.getFrameRate(),\n                        yuvOutputFormat.getYuvType(),\n                        Format.NOT_SPECIFIED,\n                        Format.NOT_SPECIFIED,\n                        0,\n                        Format.NOT_SPECIFIED,\n                        Format.NOT_SPECIFIED));\n        }\n        else if (outputFormat != null)\n            logger.warn(\n                    \"SwScaler outputFormat of type \"\n                        + outputFormat.getClass().getSimpleName()\n                        + \" is not supported for optimized scaling.\");\n    }","commit_id":"a04446550ed5db7aa8f171b027419145c62c4bad","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * VoltDB added method to get a non-catalog-dependent\n     * representation of this HSQLDB object.\n     * @param session The current Session object may be needed to resolve\n     * some names.\n     * @return XML, correctly indented, representing this object.\n     */\n    @Override\n    VoltXMLElement voltGetXML(Session session) throws HSQLParseException\n    {\n        VoltXMLElement exp = new VoltXMLElement(\"unset\");\n        // We want to keep track of which expressions are the same in the XML output\n        exp.attributes.put(\"id\", this.getUniqueId(session));\n\n        if (opType == OpTypes.ASTERISK) {\n            exp.name = \"asterisk\";\n        }\n        else if (isParam) {\n            exp.name = \"value\";\n            exp.attributes.put(\"type\", Types.getTypeName(dataType.typeCode));\n            exp.attributes.put(\"isparam\", \"true\");\n        }\n        else {\n            exp.name = \"columnref\";\n            if (tableName != null)\n                exp.attributes.put(\"table\", tableName);\n            exp.attributes.put(\"column\", columnName);\n            exp.attributes.put(\"alias\", (this.alias != null) && (getAlias().length() > 0) ? getAlias() : columnName);\n        }\n\n        return exp;\n    }","id":77792,"modified_method":"/**\n     * VoltDB added method to get a non-catalog-dependent\n     * representation of this HSQLDB object.\n     * @param session The current Session object may be needed to resolve\n     * some names.\n     * @return XML, correctly indented, representing this object.\n     */\n    @Override\n    VoltXMLElement voltGetXML(Session session) throws HSQLParseException\n    {\n        VoltXMLElement exp = new VoltXMLElement(\"unset\");\n        // We want to keep track of which expressions are the same in the XML output\n        exp.attributes.put(\"id\", this.getUniqueId(session));\n\n        if (opType == OpTypes.ASTERISK) {\n            exp.name = \"asterisk\";\n        }\n        else if (isParam) {\n            exp.name = \"value\";\n            // This eliminates a NullPointerException which MAY be a sign of insufficient type inference,\n            // but there MAY be cases where a parameter type can't legitimately be inferred, so let it go.\n            if (dataType != null) {\n                exp.attributes.put(\"type\", Types.getTypeName(dataType.typeCode));\n            }\n            exp.attributes.put(\"isparam\", \"true\");\n        }\n        else {\n            exp.name = \"columnref\";\n            if (tableName != null)\n                exp.attributes.put(\"table\", tableName);\n            exp.attributes.put(\"column\", columnName);\n            exp.attributes.put(\"alias\", (this.alias != null) && (getAlias().length() > 0) ? getAlias() : columnName);\n        }\n\n        return exp;\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void resolveTypes(Session session, Expression parent) {\n\n        Type[] paramTypes = m_def.getParamTypes();\n\n        for (int i = 0; i < nodes.length; i++) {\n            if (nodes[i] != null) {\n                nodes[i].resolveTypes(session, this);\n            }\n        }\n\n        switch(funcType) {\n        /*\n         * The types to the FIELD functions parameters are VARCHAR\n         */\n        case FunctionId.FUNC_VOLT_FIELD:\n            if (nodes[0].dataType == null && nodes[0].isParam) {\n                nodes[0].dataType = Type.SQL_VARCHAR;\n            }\n            if (nodes[1].dataType == null && nodes[1].isParam) {\n                nodes[1].dataType = Type.SQL_VARCHAR;\n            }\n            break;\n        default:\n            break;\n        }\n\n        for (int i = 0; i < nodes.length; i++) {\n            if (nodes[i] != null) {\n                if (i >= paramTypes.length) {\n                 // TODO support type checking for variadic functions\n                    break;\n                }\n                if (paramTypes[i] == null) {\n                    continue; // accept all argument types\n                }\n                if (paramTypes[i].canConvertFrom(nodes[i].dataType)) {\n                    continue; // accept compatible argument types\n                }\n                throw Error.error(ErrorCode.X_42565); // incompatible data type\n            }\n        }\n\n        dataType = m_def.getDataType();\n        if (dataType == null && nodes.length > 0) {\n            if (parameterArg < 0 || parameterArg >= nodes.length) {\n                throw Error.error(ErrorCode.X_42565); // incompatible data type (so says the error -- we're missing one, actually)\n            }\n            Expression like_child = nodes[parameterArg];\n            if (like_child != null) {\n                dataType = like_child.dataType;\n            }\n        }\n    }","id":77793,"modified_method":"@Override\n    public void resolveTypes(Session session, Expression parent) {\n\n        Type[] paramTypes = m_def.getParamTypes();\n\n        for (int i = 0; i < nodes.length; i++) {\n            if (nodes[i] != null) {\n                nodes[i].resolveTypes(session, this);\n            }\n        }\n\n        switch(funcType) {\n        /*\n         * The types to the FIELD functions parameters are VARCHAR\n         */\n        case FunctionId.FUNC_VOLT_FIELD:\n            if (nodes[0].dataType == null && nodes[0].isParam) {\n                nodes[0].dataType = Type.SQL_VARCHAR;\n            }\n            if (nodes[1].dataType == null && nodes[1].isParam) {\n                nodes[1].dataType = Type.SQL_VARCHAR;\n            }\n            break;\n\n            /*\n             * Infer parameter types to make the types of the 1st, 2nd, and (if not the last) 4th, 6th, etc.\n             * arguments to DECODE as consistent as possible,\n             * and the types of the 3rd, 5th, 7th, etc. and LAST arguments as consistent as possible.\n             * Punt to inferring VARCHAR if the other arguments give no clue or are inconsistent\n             * -- the VoltDB EE complains about NULL-typed parameters but is somewhat forgiving about\n             * mixed argument types.\n             */\n        case FunctionId.FUNC_VOLT_DECODE:\n            Type inferredInputType = null;\n            Type inferredResultType = null;\n            boolean needParamType = false;\n            for (int ii = 0; ii < nodes.length; ii++) {\n                if (ii >= 2 && (ii == (nodes.length - 1) || (ii % 2) == 0)) {\n                    // These arguments represent candidate result values.\n                    if (nodes[ii].dataType == null) {\n                        if (nodes[ii].isParam) {\n                            needParamType = true;\n                        }\n                    }\n                    else if (inferredResultType == null) {\n                        inferredResultType = nodes[ii].dataType; // Take the first hint.\n                    } else if (inferredResultType != nodes[ii].dataType) {\n                        inferredResultType = Type.SQL_VARCHAR; // Discard contradictory hints.\n                    }\n                } else {\n                    // These arguments represent candidate input values.\n                    if (nodes[ii].dataType == null) {\n                        if (nodes[ii].isParam) {\n                            needParamType = true;\n                        }\n                    }\n                    else if (inferredInputType == null) {\n                        inferredInputType = nodes[ii].dataType; // Take the first hint.\n                    } else if (inferredInputType != nodes[ii].dataType) {\n                        inferredInputType = Type.SQL_VARCHAR; // Discard contradictory hints.\n                    }\n                }\n            }\n            // With any luck, we don't have any parameter \"?\" arguments to worry about.\n            if ( ! needParamType) {\n                break;\n            }\n            // No luck, so we do our best to infer the parameters' types.\n            // Punt to guessing VARCHAR for lack of better information.\n            for (int ii = 0; ii < nodes.length; ii++) {\n                if (nodes[ii].dataType != null) {\n                    continue;\n                }\n                if ( ! nodes[ii].isParam) {\n                    continue;\n                }\n                if (ii >= 2 && (ii == (nodes.length - 1) || (ii % 2) == 0)) {\n                    // These arguments represent untyped parameter candidate result values.\n                    if (inferredResultType == null) {\n                        nodes[ii].dataType = Type.SQL_VARCHAR;\n                    } else {\n                        nodes[ii].dataType = inferredResultType;\n                    }\n                } else {\n                    // These arguments represent untyped parameter candidate input values.\n                    if (inferredInputType == null) {\n                        nodes[ii].dataType = Type.SQL_VARCHAR;\n                    } else {\n                        nodes[ii].dataType = inferredInputType;\n                    }\n                }\n            }\n            break;\n\n        default:\n            break;\n        }\n\n        for (int i = 0; i < nodes.length; i++) {\n            if (nodes[i] != null) {\n                if (i >= paramTypes.length) {\n                 // TODO support type checking for variadic functions\n                    break;\n                }\n                if (paramTypes[i] == null) {\n                    continue; // accept all argument types\n                }\n                if (paramTypes[i].canConvertFrom(nodes[i].dataType)) {\n                    continue; // accept compatible argument types\n                }\n                throw Error.error(ErrorCode.X_42565); // incompatible data type\n            }\n        }\n\n        dataType = m_def.getDataType();\n        if (dataType == null && nodes.length > 0) {\n            if (parameterArg < 0 || parameterArg >= nodes.length) {\n                throw Error.error(ErrorCode.X_42565); // incompatible data type (so says the error -- we're missing one, actually)\n            }\n            Expression like_child = nodes[parameterArg];\n            if (like_child != null) {\n                dataType = like_child.dataType;\n            }\n        }\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * VoltDB added method to get a non-catalog-dependent\n     * representation of this HSQLDB object.\n     * @param session The current Session object may be needed to resolve\n     * some names.\n     * @return XML, correctly indented, representing this object.\n     * @throws HSQLParseException\n     */\n    @Override\n    VoltXMLElement voltGetXML(Session session)\n    throws HSQLParseException\n    {\n        // \"select\" statements/clauses are always represented by a QueryExpression of type QuerySpecification.\n        // The only other instances of QueryExpression are direct QueryExpression instances instantiated in XreadSetOperation\n        // to represent UNION, etc.\n        // The latter are not yet supported in VoltDB.\n        if ( ! (queryExpression instanceof QuerySpecification)) {\n            throw new HSQLParseException(queryExpression.operatorName() + \" and similar tuple set operators are not supported.\");\n        }\n\n        QuerySpecification select = (QuerySpecification) queryExpression;\n\n        // select\n        VoltXMLElement query = new VoltXMLElement(\"select\");\n        if (select.isDistinctSelect)\n            query.attributes.put(\"distinct\", \"true\");\n        if (select.isGrouped)\n            query.attributes.put(\"grouped\", \"true\");\n        if (select.isAggregated)\n            query.attributes.put(\"aggregated\", \"true\");\n\n        // limit\n        if ((select.sortAndSlice != null) && (select.sortAndSlice.limitCondition != null)) {\n            Expression limitCondition = select.sortAndSlice.limitCondition;\n            if (limitCondition.nodes.length != 2) {\n                throw new HSQLParseException(\"Parser did not create limit and offset expression for LIMIT.\");\n            }\n            try {\n                // read offset. it may be a parameter token.\n                if (limitCondition.nodes[0].isParam() == false) {\n                    Integer offset = (Integer)limitCondition.nodes[0].getValue(session);\n                    if (offset > 0) {\n                        query.attributes.put(\"offset\", offset.toString());\n                    }\n                }\n                else {\n                    query.attributes.put(\"offset_paramid\", limitCondition.nodes[0].getUniqueId(session));\n                }\n\n                // read limit. it may be a parameter token.\n                if (limitCondition.nodes[1].isParam() == false) {\n                    Integer limit = (Integer)limitCondition.nodes[1].getValue(session);\n                    query.attributes.put(\"limit\", limit.toString());\n                }\n                else {\n                    query.attributes.put(\"limit_paramid\", limitCondition.nodes[1].getUniqueId(session));\n                }\n            } catch (HsqlException ex) {\n                // XXX really?\n                ex.printStackTrace();\n            }\n        }\n\n        // columns that need to be output by the scans\n        VoltXMLElement scanCols = new VoltXMLElement(\"scan_columns\");\n        query.children.add(scanCols);\n        assert(scanCols != null);\n\n        // Just gather a mish-mash of every possible relevant expression\n        // and uniq them later\n        HsqlList col_list = new HsqlArrayList();\n        select.collectAllExpressions(col_list, Expression.columnExpressionSet, Expression.emptyExpressionSet);\n        if (select.queryCondition != null)\n        {\n            Expression.collectAllExpressions(col_list, select.queryCondition,\n                                             Expression.columnExpressionSet,\n                                             Expression.emptyExpressionSet);\n        }\n        for (int i = 0; i < select.exprColumns.length; i++) {\n            Expression.collectAllExpressions(col_list, select.exprColumns[i],\n                                             Expression.columnExpressionSet,\n                                             Expression.emptyExpressionSet);\n        }\n        for (RangeVariable rv : select.rangeVariables)\n        {\n            if (rv.indexCondition != null)\n            {\n                Expression.collectAllExpressions(col_list, rv.indexCondition,\n                                                 Expression.columnExpressionSet,\n                                                 Expression.emptyExpressionSet);\n\n            }\n            if (rv.indexEndCondition != null)\n            {\n                Expression.collectAllExpressions(col_list, rv.indexEndCondition,\n                                                 Expression.columnExpressionSet,\n                                                 Expression.emptyExpressionSet);\n\n            }\n            if (rv.nonIndexJoinCondition != null)\n            {\n                Expression.collectAllExpressions(col_list, rv.nonIndexJoinCondition,\n                                                 Expression.columnExpressionSet,\n                                                 Expression.emptyExpressionSet);\n\n            }\n        }\n        HsqlList uniq_col_list = new HsqlArrayList();\n        for (int i = 0; i < col_list.size(); i++)\n        {\n            Expression orig = (Expression)col_list.get(i);\n            if (!uniq_col_list.contains(orig))\n            {\n                uniq_col_list.add(orig);\n            }\n        }\n        for (int i = 0; i < uniq_col_list.size(); i++)\n        {\n            VoltXMLElement xml = ((Expression)uniq_col_list.get(i)).voltGetXML(session);\n            scanCols.children.add(xml);\n            assert(xml != null);\n        }\n\n        // columns\n        VoltXMLElement cols = new VoltXMLElement(\"columns\");\n        query.children.add(cols);\n        assert(cols != null);\n\n        ArrayList<Expression> orderByCols = new ArrayList<Expression>();\n        ArrayList<Expression> groupByCols = new ArrayList<Expression>();\n        ArrayList<Expression> displayCols = new ArrayList<Expression>();\n        ArrayList<Pair<Integer, SimpleName>> aliases = new ArrayList<Pair<Integer, SimpleName>>();\n\n        /*\n         * select.exprColumn stores all of the columns needed by HSQL to\n         * calculate the query's result set. It contains more than just the\n         * columns in the output; for example, it contains columns representing\n         * aliases, columns for groups, etc.\n         *\n         * Volt uses multiple collections to organize these columns.\n         *\n         * Observing this loop in a debugger, the following seems true:\n         *\n         * 1. Columns in exprColumns that appear in the output schema, appear in\n         * exprColumns in the same order that they occur in the output schema.\n         *\n         * 2. expr.columnIndex is an index back in to the select.exprColumns\n         * array. This allows multiple exprColumn entries to refer to each\n         * other; for example, an OpType.SIMPLE_COLUMN type storing an alias\n         * will have its columnIndex set to the offset of the expr it aliases.\n         */\n        for (int i = 0; i < select.exprColumns.length; i++) {\n            final Expression expr = select.exprColumns[i];\n\n            if (expr.alias != null) {\n                /*\n                 * Remember how aliases relate to columns. Will iterate again later\n                 * and mutate the exprColumn entries setting the alias string on the aliased\n                 * column entry.\n                 */\n                if (expr instanceof ExpressionColumn) {\n                    ExpressionColumn exprColumn = (ExpressionColumn)expr;\n                    if (exprColumn.alias != null && exprColumn.columnName == null) {\n                        aliases.add(Pair.of(expr.columnIndex, expr.alias));\n                    }\n                } else if (expr.columnIndex > -1) {\n                    /*\n                     * Only add it to the list of aliases that need to be\n                     * propagated to columns if the column index is valid.\n                     * ExpressionArithmetic will have an alias but not\n                     * necessarily a column index.\n                     */\n                    aliases.add(Pair.of(expr.columnIndex, expr.alias));\n                }\n            }\n\n            // If the column doesn't refer to another exprColumn entry, set its\n            // column index to itself. If all columns have a valid column index,\n            // it's easier to patch up display column ordering later.\n            if (expr.columnIndex == -1) {\n                expr.columnIndex = i;\n            }\n\n            if (isGroupByColumn(select, i)) {\n                groupByCols.add(expr);\n            } else if (expr.opType == OpTypes.ORDER_BY) {\n                orderByCols.add(expr);\n            } else if (expr.opType == OpTypes.SIMPLE_COLUMN && expr.isAggregate && expr.alias != null) {\n                // Add aggregate aliases to the display columns to maintain\n                // the output schema column ordering.\n                displayCols.add(expr);\n            } else if (expr.opType == OpTypes.SIMPLE_COLUMN) {\n                // Other simple columns are ignored. If others exist, maybe\n                // volt infers a display column from another column collection?\n            } else {\n                displayCols.add(expr);\n            }\n        }\n\n        for (Pair<Integer, SimpleName> alias : aliases) {\n            // set the alias data into the expression being aliased.\n            select.exprColumns[alias.getFirst()].alias = alias.getSecond();\n        }\n\n        /*\n         * The columns chosen above as display columns aren't always the same\n         * expr objects HSQL would use as display columns - some data were\n         * unified (namely, SIMPLE_COLUMN aliases were pushed into COLUMNS).\n         *\n         * However, the correct output schema ordering was correct in exprColumns.\n         * This order was maintained by adding SIMPLE_COLUMNs to displayCols.\n         *\n         * Now need to serialize the displayCols, serializing the non-simple-columns\n         * corresponding to simple_columns for any simple_columns that woodchucks\n         * could chuck.\n         *\n         * Serialize the display columns in the exprColumn order.\n         */\n        for (int jj=0; jj < displayCols.size(); ++jj) {\n            Expression expr = displayCols.get(jj);\n            if (expr == null) {\n                continue;\n            }\n            else if (expr.opType == OpTypes.SIMPLE_COLUMN)\n            {\n                // simple columns are not serialized as display columns\n                // but they are place holders for another column\n                // in the output schema. Go find that corresponding column\n                // and serialize it in this place.\n                for (int ii=jj; ii < displayCols.size(); ++ii)\n                {\n                    Expression otherCol = displayCols.get(ii);\n                    if (otherCol == null) {\n                        continue;\n                    }\n                    else if ((otherCol.opType != OpTypes.SIMPLE_COLUMN) &&\n                             (otherCol.columnIndex == expr.columnIndex))\n                    {\n                        // serialize the column this simple column stands-in for\n                        VoltXMLElement xml = otherCol.voltGetXML(session);\n                        cols.children.add(xml);\n                        assert(xml != null);\n                        // null-out otherCol to not serialize it twice\n                        displayCols.set(ii, null);\n                        // quit seeking simple_column's replacement\n                        break;\n                    }\n                }\n            }\n            else {\n                VoltXMLElement xml = expr.voltGetXML(session);\n                cols.children.add(xml);\n                assert(xml != null);\n            }\n        }\n\n        // parameters\n        VoltXMLElement params = new VoltXMLElement(\"parameters\");\n        query.children.add(params);\n        assert(params != null);\n\n        for (int i = 0; i < parameters.length; i++) {\n            VoltXMLElement parameter = new VoltXMLElement(\"parameter\");\n            params.children.add(parameter);\n            assert(parameter != null);\n\n            parameter.attributes.put(\"index\", String.valueOf(i));\n            ExpressionColumn param = parameters[i];\n            parameter.attributes.put(\"id\", param.getUniqueId(session));\n            parameter.attributes.put(\"type\", Types.getTypeName(param.getDataType().typeCode));\n        }\n\n        // scans\n        VoltXMLElement scans = new VoltXMLElement(\"tablescans\");\n        query.children.add(scans);\n        assert(scans != null);\n\n        for (RangeVariable rangeVariable : rangeVariables)\n            scans.children.add(rangeVariable.voltGetXML(session));\n\n        // conditions\n        if (select.queryCondition != null) {\n            VoltXMLElement condition = new VoltXMLElement(\"querycondition\");\n            query.children.add(condition);\n            assert(condition != null);\n            condition.children.add(select.queryCondition.voltGetXML(session));\n        }\n        else {\n            // look for inner joins expressed on range variables\n            Expression cond = null;\n            for (int rvi=0; rvi < select.rangeVariables.length; ++rvi) {\n                RangeVariable rv = rangeVariables[rvi];\n                // joins on non-indexed columns for inner join tokens created a range variable\n                // and assigned this expression.\n                if (rv.nonIndexJoinCondition != null) {\n                    if (cond != null) {\n                        cond = new ExpressionLogical(OpTypes.AND, cond, rv.nonIndexJoinCondition);\n                    } else {\n                        cond = rv.nonIndexJoinCondition;\n                    }\n                }\n                // joins on indexed columns for inner join tokens created a range variable\n                // and assigned an expression and set the flag isJoinIndex.\n                else if (rv.isJoinIndex) {\n                    if (rv.indexCondition != null) {\n                        if (cond != null) {\n                            cond = new ExpressionLogical(OpTypes.AND, cond, rv.indexCondition);\n                        } else {\n                            cond = rv.indexCondition;\n                        }\n                    }\n                    if (rv.indexEndCondition != null) {\n                        if (cond != null) {\n                            cond = new ExpressionLogical(OpTypes.AND, cond, rv.indexCondition);\n                        } else {\n                            cond = rv.indexCondition;\n                        }\n                    }\n                }\n            }\n            if (cond != null) {\n                VoltXMLElement condition = new VoltXMLElement(\"querycondition\");\n                query.children.add(condition);\n                condition.children.add(cond.voltGetXML(session));\n            }\n        }\n\n        // having\n        if (select.havingCondition != null) {\n            throw new HSQLParseException(\"VoltDB does not yet support the HAVING clause\");\n        }\n\n        // groupby\n        if (select.isGrouped) {\n            VoltXMLElement groupCols = new VoltXMLElement(\"groupcolumns\");\n            query.children.add(groupCols);\n            for (Expression groupByCol : groupByCols) {\n                groupCols.children.add(groupByCol.voltGetXML(session));\n            }\n        }\n        // orderby\n        if (orderByCols.size() > 0) {\n            VoltXMLElement orderCols = new VoltXMLElement(\"ordercolumns\");\n            query.children.add(orderCols);\n            for (Expression orderByCol : orderByCols) {\n                orderCols.children.add(orderByCol.voltGetXML(session));\n            }\n        }\n\n        return query;\n    }","id":77794,"modified_method":"/**\n     * VoltDB added method to get a non-catalog-dependent\n     * representation of this HSQLDB object.\n     * @param session The current Session object may be needed to resolve\n     * some names.\n     * @return XML, correctly indented, representing this object.\n     * @throws HSQLParseException\n     */\n    @Override\n    VoltXMLElement voltGetXML(Session session)\n    throws HSQLParseException\n    {\n        // \"select\" statements/clauses are always represented by a QueryExpression of type QuerySpecification.\n        // The only other instances of QueryExpression are direct QueryExpression instances instantiated in XreadSetOperation\n        // to represent UNION, etc.\n        // The latter are not yet supported in VoltDB.\n        if ( ! (queryExpression instanceof QuerySpecification)) {\n            throw new HSQLParseException(queryExpression.operatorName() + \" and similar tuple set operators are not supported.\");\n        }\n\n        QuerySpecification select = (QuerySpecification) queryExpression;\n\n        // select\n        VoltXMLElement query = new VoltXMLElement(\"select\");\n        if (select.isDistinctSelect)\n            query.attributes.put(\"distinct\", \"true\");\n        if (select.isGrouped)\n            query.attributes.put(\"grouped\", \"true\");\n        if (select.isAggregated)\n            query.attributes.put(\"aggregated\", \"true\");\n\n        // limit\n        if ((select.sortAndSlice != null) && (select.sortAndSlice.limitCondition != null)) {\n            Expression limitCondition = select.sortAndSlice.limitCondition;\n            if (limitCondition.nodes.length != 2) {\n                throw new HSQLParseException(\"Parser did not create limit and offset expression for LIMIT.\");\n            }\n            try {\n                // read offset. it may be a parameter token.\n                if (limitCondition.nodes[0].isParam() == false) {\n                    Integer offset = (Integer)limitCondition.nodes[0].getValue(session);\n                    if (offset > 0) {\n                        query.attributes.put(\"offset\", offset.toString());\n                    }\n                }\n                else {\n                    query.attributes.put(\"offset_paramid\", limitCondition.nodes[0].getUniqueId(session));\n                }\n\n                // read limit. it may be a parameter token.\n                if (limitCondition.nodes[1].isParam() == false) {\n                    Integer limit = (Integer)limitCondition.nodes[1].getValue(session);\n                    query.attributes.put(\"limit\", limit.toString());\n                }\n                else {\n                    query.attributes.put(\"limit_paramid\", limitCondition.nodes[1].getUniqueId(session));\n                }\n            } catch (HsqlException ex) {\n                // XXX really?\n                ex.printStackTrace();\n            }\n        }\n\n        // columns that need to be output by the scans\n        VoltXMLElement scanCols = new VoltXMLElement(\"scan_columns\");\n        query.children.add(scanCols);\n        assert(scanCols != null);\n\n        // Just gather a mish-mash of every possible relevant expression\n        // and uniq them later\n        HsqlList col_list = new HsqlArrayList();\n        select.collectAllExpressions(col_list, Expression.columnExpressionSet, Expression.emptyExpressionSet);\n        if (select.queryCondition != null)\n        {\n            Expression.collectAllExpressions(col_list, select.queryCondition,\n                                             Expression.columnExpressionSet,\n                                             Expression.emptyExpressionSet);\n        }\n        for (int i = 0; i < select.exprColumns.length; i++) {\n            Expression.collectAllExpressions(col_list, select.exprColumns[i],\n                                             Expression.columnExpressionSet,\n                                             Expression.emptyExpressionSet);\n        }\n        for (RangeVariable rv : select.rangeVariables)\n        {\n            if (rv.indexCondition != null)\n            {\n                Expression.collectAllExpressions(col_list, rv.indexCondition,\n                                                 Expression.columnExpressionSet,\n                                                 Expression.emptyExpressionSet);\n\n            }\n            if (rv.indexEndCondition != null)\n            {\n                Expression.collectAllExpressions(col_list, rv.indexEndCondition,\n                                                 Expression.columnExpressionSet,\n                                                 Expression.emptyExpressionSet);\n\n            }\n            if (rv.nonIndexJoinCondition != null)\n            {\n                Expression.collectAllExpressions(col_list, rv.nonIndexJoinCondition,\n                                                 Expression.columnExpressionSet,\n                                                 Expression.emptyExpressionSet);\n\n            }\n        }\n        HsqlList uniq_col_list = new HsqlArrayList();\n        for (int i = 0; i < col_list.size(); i++)\n        {\n            Expression orig = (Expression)col_list.get(i);\n            if (!uniq_col_list.contains(orig))\n            {\n                uniq_col_list.add(orig);\n            }\n        }\n        for (int i = 0; i < uniq_col_list.size(); i++)\n        {\n            VoltXMLElement xml = ((Expression)uniq_col_list.get(i)).voltGetXML(session);\n            scanCols.children.add(xml);\n            assert(xml != null);\n        }\n\n        // columns\n        VoltXMLElement cols = new VoltXMLElement(\"columns\");\n        query.children.add(cols);\n        assert(cols != null);\n\n        ArrayList<Expression> orderByCols = new ArrayList<Expression>();\n        ArrayList<Expression> groupByCols = new ArrayList<Expression>();\n        ArrayList<Expression> displayCols = new ArrayList<Expression>();\n        ArrayList<Pair<Integer, SimpleName>> aliases = new ArrayList<Pair<Integer, SimpleName>>();\n\n        /*\n         * select.exprColumn stores all of the columns needed by HSQL to\n         * calculate the query's result set. It contains more than just the\n         * columns in the output; for example, it contains columns representing\n         * aliases, columns for groups, etc.\n         *\n         * Volt uses multiple collections to organize these columns.\n         *\n         * Observing this loop in a debugger, the following seems true:\n         *\n         * 1. Columns in exprColumns that appear in the output schema, appear in\n         * exprColumns in the same order that they occur in the output schema.\n         *\n         * 2. expr.columnIndex is an index back in to the select.exprColumns\n         * array. This allows multiple exprColumn entries to refer to each\n         * other; for example, an OpType.SIMPLE_COLUMN type storing an alias\n         * will have its columnIndex set to the offset of the expr it aliases.\n         */\n        for (int i = 0; i < select.exprColumns.length; i++) {\n            final Expression expr = select.exprColumns[i];\n\n            if (expr.alias != null) {\n                /*\n                 * Remember how aliases relate to columns. Will iterate again later\n                 * and mutate the exprColumn entries setting the alias string on the aliased\n                 * column entry.\n                 */\n                if (expr instanceof ExpressionColumn) {\n                    ExpressionColumn exprColumn = (ExpressionColumn)expr;\n                    if (exprColumn.alias != null && exprColumn.columnName == null) {\n                        aliases.add(Pair.of(expr.columnIndex, expr.alias));\n                    }\n                } else if (expr.columnIndex > -1) {\n                    /*\n                     * Only add it to the list of aliases that need to be\n                     * propagated to columns if the column index is valid.\n                     * ExpressionArithmetic will have an alias but not\n                     * necessarily a column index.\n                     */\n                    aliases.add(Pair.of(expr.columnIndex, expr.alias));\n                }\n            }\n\n            // If the column doesn't refer to another exprColumn entry, set its\n            // column index to itself. If all columns have a valid column index,\n            // it's easier to patch up display column ordering later.\n            if (expr.columnIndex == -1) {\n                expr.columnIndex = i;\n            }\n\n            if (isGroupByColumn(select, i)) {\n                groupByCols.add(expr);\n            } else if (expr.opType == OpTypes.ORDER_BY) {\n                orderByCols.add(expr);\n            } else if (expr.opType == OpTypes.SIMPLE_COLUMN && expr.isAggregate && expr.alias != null) {\n                // Add aggregate aliases to the display columns to maintain\n                // the output schema column ordering.\n                displayCols.add(expr);\n            } else if (expr.opType == OpTypes.SIMPLE_COLUMN) {\n                // Other simple columns are ignored. If others exist, maybe\n                // volt infers a display column from another column collection?\n            } else {\n                displayCols.add(expr);\n            }\n        }\n\n        for (Pair<Integer, SimpleName> alias : aliases) {\n            // set the alias data into the expression being aliased.\n            select.exprColumns[alias.getFirst()].alias = alias.getSecond();\n        }\n\n        /*\n         * The columns chosen above as display columns aren't always the same\n         * expr objects HSQL would use as display columns - some data were\n         * unified (namely, SIMPLE_COLUMN aliases were pushed into COLUMNS).\n         *\n         * However, the correct output schema ordering was correct in exprColumns.\n         * This order was maintained by adding SIMPLE_COLUMNs to displayCols.\n         *\n         * Now need to serialize the displayCols, serializing the non-simple-columns\n         * corresponding to simple_columns for any simple_columns that woodchucks\n         * could chuck.\n         *\n         * Serialize the display columns in the exprColumn order.\n         */\n        for (int jj=0; jj < displayCols.size(); ++jj) {\n            Expression expr = displayCols.get(jj);\n            if (expr == null) {\n                continue;\n            }\n            else if (expr.opType == OpTypes.SIMPLE_COLUMN)\n            {\n                // simple columns are not serialized as display columns\n                // but they are place holders for another column\n                // in the output schema. Go find that corresponding column\n                // and serialize it in this place.\n                for (int ii=jj; ii < displayCols.size(); ++ii)\n                {\n                    Expression otherCol = displayCols.get(ii);\n                    if (otherCol == null) {\n                        continue;\n                    }\n                    else if ((otherCol.opType != OpTypes.SIMPLE_COLUMN) &&\n                             (otherCol.columnIndex == expr.columnIndex))\n                    {\n                        // serialize the column this simple column stands-in for\n                        VoltXMLElement xml = otherCol.voltGetXML(session);\n                        cols.children.add(xml);\n                        assert(xml != null);\n                        // null-out otherCol to not serialize it twice\n                        displayCols.set(ii, null);\n                        // quit seeking simple_column's replacement\n                        break;\n                    }\n                }\n            }\n            else {\n                VoltXMLElement xml = expr.voltGetXML(session);\n                cols.children.add(xml);\n                assert(xml != null);\n            }\n        }\n\n        // parameters\n        VoltXMLElement params = new VoltXMLElement(\"parameters\");\n        query.children.add(params);\n        assert(params != null);\n\n        for (int i = 0; i < parameters.length; i++) {\n            VoltXMLElement parameter = new VoltXMLElement(\"parameter\");\n            params.children.add(parameter);\n            assert(parameter != null);\n\n            parameter.attributes.put(\"index\", String.valueOf(i));\n            ExpressionColumn param = parameters[i];\n            parameter.attributes.put(\"id\", param.getUniqueId(session));\n            Type paramType = param.getDataType();\n            if (paramType != null) {\n                parameter.attributes.put(\"type\", Types.getTypeName(paramType.typeCode));\n            }\n        }\n\n        // scans\n        VoltXMLElement scans = new VoltXMLElement(\"tablescans\");\n        query.children.add(scans);\n        assert(scans != null);\n\n        for (RangeVariable rangeVariable : rangeVariables)\n            scans.children.add(rangeVariable.voltGetXML(session));\n\n        // conditions\n        if (select.queryCondition != null) {\n            VoltXMLElement condition = new VoltXMLElement(\"querycondition\");\n            query.children.add(condition);\n            assert(condition != null);\n            condition.children.add(select.queryCondition.voltGetXML(session));\n        }\n        else {\n            // look for inner joins expressed on range variables\n            Expression cond = null;\n            for (int rvi=0; rvi < select.rangeVariables.length; ++rvi) {\n                RangeVariable rv = rangeVariables[rvi];\n                // joins on non-indexed columns for inner join tokens created a range variable\n                // and assigned this expression.\n                if (rv.nonIndexJoinCondition != null) {\n                    if (cond != null) {\n                        cond = new ExpressionLogical(OpTypes.AND, cond, rv.nonIndexJoinCondition);\n                    } else {\n                        cond = rv.nonIndexJoinCondition;\n                    }\n                }\n                // joins on indexed columns for inner join tokens created a range variable\n                // and assigned an expression and set the flag isJoinIndex.\n                else if (rv.isJoinIndex) {\n                    if (rv.indexCondition != null) {\n                        if (cond != null) {\n                            cond = new ExpressionLogical(OpTypes.AND, cond, rv.indexCondition);\n                        } else {\n                            cond = rv.indexCondition;\n                        }\n                    }\n                    if (rv.indexEndCondition != null) {\n                        if (cond != null) {\n                            cond = new ExpressionLogical(OpTypes.AND, cond, rv.indexCondition);\n                        } else {\n                            cond = rv.indexCondition;\n                        }\n                    }\n                }\n            }\n            if (cond != null) {\n                VoltXMLElement condition = new VoltXMLElement(\"querycondition\");\n                query.children.add(condition);\n                condition.children.add(cond.voltGetXML(session));\n            }\n        }\n\n        // having\n        if (select.havingCondition != null) {\n            throw new HSQLParseException(\"VoltDB does not yet support the HAVING clause\");\n        }\n\n        // groupby\n        if (select.isGrouped) {\n            VoltXMLElement groupCols = new VoltXMLElement(\"groupcolumns\");\n            query.children.add(groupCols);\n            for (Expression groupByCol : groupByCols) {\n                groupCols.children.add(groupByCol.voltGetXML(session));\n            }\n        }\n        // orderby\n        if (orderByCols.size() > 0) {\n            VoltXMLElement orderCols = new VoltXMLElement(\"ordercolumns\");\n            query.children.add(orderCols);\n            for (Expression orderByCol : orderByCols) {\n                orderCols.children.add(orderByCol.voltGetXML(session));\n            }\n        }\n\n        return query;\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFIELDFunctionWithInvalidJSON() throws Exception {\n\n        Client client = getClient();\n        ClientResponse cr;\n\n        cr = client.callProcedure(\n                \"JSBAD.insert\",1,\n                \"{\\\"id\\\":1 \\\"bool\\\": false}\"\n                );\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        cr = client.callProcedure(\n                \"JSBAD.insert\",2,\n                \"{\\\"id\\\":2, \\\"bool\\\"; false, \\\"Vo\\\":\\\"\\\"}\"\n                );\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        try {\n            cr = client.callProcedure(\"BadIdProc\", 1, \"id\", \"1\");\n            fail(\"document validity check failed\");\n        }\n        catch(ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\n                    \"'{\\\"id\\\":1 \\\"bool\\\": false}' is not valid JSON\"\n                    ));\n        }\n        try {\n            cr = client.callProcedure(\"BadIdProc\", 2, \"id\", \"2\");\n            fail(\"document validity check failed\");\n        }\n        catch(ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\n                    \"'{\\\"id\\\":2, \\\"bool\\\"; false, \\\"Vo\\\":\\\" ...' is not valid JSON\"\n                    ));\n        }\n    }","id":77795,"modified_method":"public void testFIELDFunctionWithInvalidJSON() throws Exception {\n\n        Client client = getClient();\n        ClientResponse cr;\n\n        cr = client.callProcedure(\n                \"JSBAD.insert\",1,\n                \"{\\\"id\\\":1 \\\"bool\\\": false}\"\n                );\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        cr = client.callProcedure(\n                \"JSBAD.insert\",2,\n                \"{\\\"id\\\":2, \\\"bool\\\"; false, \\\"Vo\\\":\\\"\\\"}\"\n                );\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        try {\n            cr = client.callProcedure(\"BadIdFieldProc\", 1, \"id\", \"1\");\n            fail(\"document validity check failed\");\n        }\n        catch(ProcCallException pcex) {\n            String msg = pcex.getMessage();\n            assertTrue(msg.contains(\"'{\\\"id\\\":1 \\\"bool\\\": false}' is not valid JSON\"));\n        }\n        try {\n            cr = client.callProcedure(\"BadIdFieldProc\", 2, \"id\", \"2\");\n            fail(\"document validity check failed\");\n        }\n        catch(ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\n                    \"'{\\\"id\\\":2, \\\"bool\\\"; false, \\\"Vo\\\":\\\" ...' is not valid JSON\"\n                    ));\n        }\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDECODE() throws NoConnectionsException, IOException, ProcCallException {\n        System.out.println(\"STARTING DECODE\");\n        Client client = getClient();\n        ClientResponse cr;\n        VoltTable result;\n\n        cr = client.callProcedure(\"P1.insert\", 1, \"IBM\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 2, \"Microsoft\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 3, \"Hewlett Packard\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 4, \"Gateway\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 5, null, 10, 1.1);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        // match 1st condition\n        cr = client.callProcedure(\"DECODE\", 1);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"zheng\",result.getString(1));\n\n        // match 2nd condition\n        cr = client.callProcedure(\"DECODE\", 2);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"li\",result.getString(1));\n\n        // match 3rd condition\n        cr = client.callProcedure(\"DECODE\", 3);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"at\",result.getString(1));\n\n        // match 4th condition\n        cr = client.callProcedure(\"DECODE\", 4);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"VoltDB\",result.getString(1));\n\n        // null case\n        cr = client.callProcedure(\"DECODE\", 5);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"where\",result.getString(1));\n    }","id":77796,"modified_method":"public void testDECODE() throws NoConnectionsException, IOException, ProcCallException {\n        System.out.println(\"STARTING DECODE\");\n        Client client = getClient();\n        ClientResponse cr;\n        VoltTable result;\n\n        cr = client.callProcedure(\"P1.insert\", 1, \"IBM\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 2, \"Microsoft\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 3, \"Hewlett Packard\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 4, \"Gateway\", 10, 1.1);\n        cr = client.callProcedure(\"P1.insert\", 5, null, 10, 1.1);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        // match 1st condition\n        cr = client.callProcedure(\"DECODE\", 1);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"zheng\",result.getString(1));\n\n        // match 2nd condition\n        cr = client.callProcedure(\"DECODE\", 2);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"li\",result.getString(1));\n\n        // match 3rd condition\n        cr = client.callProcedure(\"DECODE\", 3);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"at\",result.getString(1));\n\n        // match 4th condition\n        cr = client.callProcedure(\"DECODE\", 4);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"VoltDB\",result.getString(1));\n\n        // null case\n        cr = client.callProcedure(\"DECODE\", 5);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"where\",result.getString(1));\n\n        // param cases\n        // For project.addStmtProcedure(\"DECODE_PARAM_INFER_STRING\", \"select desc,  DECODE (desc,?,?,desc) from P1 where id = ?\");\n        cr = client.callProcedure(\"DECODE_PARAM_INFER_STRING\", \"Gateway\", \"You got it!\", 4);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"You got it!\",result.getString(1));\n\n        // For project.addStmtProcedure(\"DECODE_PARAM_INFER_INT\", \"select desc,  DECODE (id,?,?,id) from P1 where id = ?\");\n        cr = client.callProcedure(\"DECODE_PARAM_INFER_INT\", 4, -4, 4);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(-4,result.getLong(1));\n\n        // For project.addStmtProcedure(\"DECODE_PARAM_INFER_DEFAULT\", \"select desc,  DECODE (?,?,?,?) from P1 where id = ?\");\n        cr = client.callProcedure(\"DECODE_PARAM_INFER_DEFAULT\", \"Gateway\", \"Gateway\", \"You got it!\", \"You ain't got it!\", 4);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"You got it!\",result.getString(1));\n\n        // For project.addStmtProcedure(\"DECODE_PARAM_INFER_CONFLICTING\", \"select desc,  DECODE (id,1,?,2,99,'99') from P1 where id = ?\");\n        cr = client.callProcedure(\"DECODE_PARAM_INFER_CONFLICTING\", \"You got it!\", 1);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(\"You got it!\",result.getString(1));\n\n        // For project.addStmtProcedure(\"DECODE_PARAM_INFER_CONFLICTING\", \"select desc,  DECODE (id,1,?,2,99,'99') from P1 where id = ?\");\n        try {\n            cr = client.callProcedure(\"DECODE_PARAM_INFER_CONFLICTING\", 1000, 1);\n            fail(\"Should have thrown unfortunate type error.\");\n        } catch (ProcCallException pce) {\n            String msg = pce.getMessage();\n            assertTrue(msg.contains(\"TYPE ERROR FOR PARAMETER 0\"));\n        }\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static public junit.framework.Test suite() {\n\n        VoltServerConfig config = null;\n        MultiConfigSuiteBuilder builder =\n            new MultiConfigSuiteBuilder(TestFunctionsForVoltDBSuite.class);\n        boolean success;\n\n        VoltProjectBuilder project = new VoltProjectBuilder();\n        final String literalSchema =\n                \"CREATE TABLE P1 ( \" +\n                \"ID INTEGER DEFAULT '0' NOT NULL, \" +\n                \"DESC VARCHAR(300), \" +\n                \"NUM INTEGER, \" +\n                \"RATIO FLOAT, \" +\n                \"PRIMARY KEY (ID) ); \" +\n                \"CREATE TABLE JS1 (\\n\" +\n                \"  ID INTEGER NOT NULL, \\n\" +\n                \"  DOC VARCHAR(8192),\\n\" +\n                \"  PRIMARY KEY(ID))\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE FieldProc AS\\n\" +\n                \"   SELECT FIELD(DOC, ?) AS JFIELD FROM JS1 WHERE FIELD( DOC, ?) = ?\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE IdProc AS\\n\" +\n                \"   SELECT ID FROM JS1 WHERE FIELD( DOC, ?) = ?\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE InnerProc AS\\n\" +\n                \"   SELECT ID FROM JS1 WHERE FIELD(FIELD(DOC, 'inner'), ?) = ?\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE NullFieldProc AS\\n\" +\n                \"   SELECT ID FROM JS1 WHERE FIELD( DOC, ?) IS NULL\\n\" +\n                \";\\n\" +\n                \"CREATE TABLE JSBAD (\\n\" +\n                \"  ID INTEGER NOT NULL,\\n\" +\n                \"  DOC VARCHAR(8192),\\n\" +\n                \"  PRIMARY KEY(ID))\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE BadIdProc AS\\n\" +\n                \"  SELECT ID FROM JSBAD WHERE ID = ? AND FIELD(DOC, ?) = ?\\n\" +\n                \";\\n\" +\n                \"\";\n        try {\n            project.addLiteralSchema(literalSchema);\n        } catch (IOException e) {\n            assertFalse(true);\n        }\n        project.addPartitionInfo(\"P1\", \"ID\");\n        // Test DECODE\n        project.addStmtProcedure(\"DECODE\", \"select desc,  DECODE (desc,'IBM','zheng',\" +\n                        \"'Microsoft','li',\" +\n                        \"'Hewlett Packard','at',\" +\n                        \"'Gateway','VoltDB',\" +\n                        \"'where') from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODEND\", \"select desc,  DECODE (desc,'zheng','a') from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODEVERYLONG\", \"select desc,  DECODE (desc,'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'where') from P1 where id = ?\");\n        // Test OCTET_LENGTH\n        project.addStmtProcedure(\"OCTET_LENGTH\", \"select desc,  OCTET_LENGTH (desc) from P1 where id = ?\");\n        // Test POSITION and CHAR_LENGTH\n        project.addStmtProcedure(\"POSITION\", \"select desc, POSITION (? IN desc) from P1 where id = ?\");\n        project.addStmtProcedure(\"CHAR_LENGTH\", \"select desc, CHAR_LENGTH (desc) from P1 where id = ?\");\n\n        // CONFIG #1: Local Site/Partition running on JNI backend\n        config = new LocalCluster(\"fixedsql-onesite.jar\", 1, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        // CONFIG #2: Local Site/Partitions running on JNI backend\n        config = new LocalCluster(\"fixedsql-threesite.jar\", 3, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n/*\n\n        // CONFIG #2: HSQL -- disabled, the functions being tested are not HSQL compatible\n        config = new LocalCluster(\"fixedsql-hsql.jar\", 1, 1, 0, BackendTarget.HSQLDB_BACKEND);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n*/\n        // no clustering tests for functions\n\n        return builder;\n    }","id":77797,"modified_method":"static public junit.framework.Test suite() {\n\n        VoltServerConfig config = null;\n        MultiConfigSuiteBuilder builder =\n            new MultiConfigSuiteBuilder(TestFunctionsForVoltDBSuite.class);\n        boolean success;\n\n        VoltProjectBuilder project = new VoltProjectBuilder();\n        final String literalSchema =\n                \"CREATE TABLE P1 ( \" +\n                \"ID INTEGER DEFAULT '0' NOT NULL, \" +\n                \"DESC VARCHAR(300), \" +\n                \"NUM INTEGER, \" +\n                \"RATIO FLOAT, \" +\n                \"PRIMARY KEY (ID) ); \" +\n                \"CREATE TABLE JS1 (\\n\" +\n                \"  ID INTEGER NOT NULL, \\n\" +\n                \"  DOC VARCHAR(8192),\\n\" +\n                \"  PRIMARY KEY(ID))\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE FieldProc AS\\n\" +\n                \"   SELECT FIELD(DOC, ?) AS JFIELD FROM JS1 WHERE FIELD( DOC, ?) = ?\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE IdFieldProc AS\\n\" +\n                \"   SELECT ID FROM JS1 WHERE FIELD( DOC, ?) = ? ORDER BY ID\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE InnerFieldProc AS\\n\" +\n                \"   SELECT ID FROM JS1 WHERE FIELD(FIELD(DOC, 'inner'), ?) = ? ORDER BY ID\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE NullFieldProc AS\\n\" +\n                \"   SELECT ID FROM JS1 WHERE FIELD( DOC, ?) IS NULL ORDER BY ID\\n\" +\n                \";\\n\" +\n                \"CREATE TABLE JSBAD (\\n\" +\n                \"  ID INTEGER NOT NULL,\\n\" +\n                \"  DOC VARCHAR(8192),\\n\" +\n                \"  PRIMARY KEY(ID))\\n\" +\n                \";\\n\" +\n                \"CREATE PROCEDURE BadIdFieldProc AS\\n\" +\n                \"  SELECT ID FROM JSBAD WHERE ID = ? AND FIELD(DOC, ?) = ?\\n\" +\n                \";\\n\" +\n                \"\";\n        try {\n            project.addLiteralSchema(literalSchema);\n        } catch (IOException e) {\n            assertFalse(true);\n        }\n        project.addPartitionInfo(\"P1\", \"ID\");\n        // Test DECODE\n        project.addStmtProcedure(\"DECODE\", \"select desc,  DECODE (desc,'IBM','zheng',\" +\n                        \"'Microsoft','li',\" +\n                        \"'Hewlett Packard','at',\" +\n                        \"'Gateway','VoltDB',\" +\n                        \"'where') from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODEND\", \"select desc,  DECODE (desc,'zheng','a') from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODEVERYLONG\", \"select desc,  DECODE (desc,'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'a','a',\" +\n                \"'where') from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODE_PARAM_INFER_STRING\", \"select desc,  DECODE (desc,?,?,desc) from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODE_PARAM_INFER_INT\", \"select desc,  DECODE (id,?,?,id) from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODE_PARAM_INFER_DEFAULT\", \"select desc,  DECODE (?,?,?,?) from P1 where id = ?\");\n        project.addStmtProcedure(\"DECODE_PARAM_INFER_CONFLICTING\", \"select desc,  DECODE (id,1,?,2,99,'99') from P1 where id = ?\");\n        // Test OCTET_LENGTH\n        project.addStmtProcedure(\"OCTET_LENGTH\", \"select desc,  OCTET_LENGTH (desc) from P1 where id = ?\");\n        // Test POSITION and CHAR_LENGTH\n        project.addStmtProcedure(\"POSITION\", \"select desc, POSITION (? IN desc) from P1 where id = ?\");\n        project.addStmtProcedure(\"CHAR_LENGTH\", \"select desc, CHAR_LENGTH (desc) from P1 where id = ?\");\n\n        // CONFIG #1: Local Site/Partition running on JNI backend\n        config = new LocalCluster(\"fixedsql-onesite.jar\", 1, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        // CONFIG #2: Local Site/Partitions running on JNI backend\n        config = new LocalCluster(\"fixedsql-threesite.jar\", 3, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n/*\n\n        // CONFIG #2: HSQL -- disabled, the functions being tested are not HSQL compatible\n        config = new LocalCluster(\"fixedsql-hsql.jar\", 1, 1, 0, BackendTarget.HSQLDB_BACKEND);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n*/\n        // no clustering tests for functions\n\n        return builder;\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFIELDFunction() throws Exception {\n\n        final String jstemplate = \"{\\n\" +\n                \"    \\\"id\\\": %d,\\n\" +\n                \"    \\\"bool\\\": true,\\n\" +\n                \"    \\\"inner\\\": {\\n\" +\n                \"        \\\"veggies\\\": \\\"good for you\\\",\\n\" +\n                \"        \\\"Vo\\\": \\\"wakarimasen\\\"\\n\" +\n                \"    },\\n\" +\n                \"    \\\"arr\\\": [\\n\" +\n                \"        1,\\n\" +\n                \"        2,\\n\" +\n                \"        3,\\n\" +\n                \"        4\\n\" +\n                \"    ],\\n\" +\n                \"    \\\"tag\\\": \\\"%s\\\"\\n\" +\n                \"}\";\n\n        Client client = getClient();\n        ClientResponse cr;\n        VoltTable result;\n\n        cr = client.callProcedure(\"JS1.insert\",1,String.format(jstemplate, 1, \"one\"));\n        cr = client.callProcedure(\"JS1.insert\",2,String.format(jstemplate, 2, \"two\"));\n        cr = client.callProcedure(\"JS1.insert\",3,String.format(jstemplate, 3, \"three\"));\n        cr = client.callProcedure(\"JS1.insert\",4,\"{\\\"id\\\":4,\\\"bool\\\": false}\");\n        cr = client.callProcedure(\"JS1.insert\",5,\"{}\");\n        cr = client.callProcedure(\"JS1.insert\",6,\"[]\");\n        cr = client.callProcedure(\"JS1.insert\",7,\"{\\\"id\\\":7,\\\"funky\\\": null}\");\n        cr = client.callProcedure(\"JS1.insert\",8, null);\n        cr = client.callProcedure(\"JS1.insert\",9, \"{\\\"id\\\":9, \\\"Vo\\\":\\\"\\\"}\");\n\n        cr = client.callProcedure(\"IdProc\", \"id\",\"1\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(1L,result.getLong(0));\n\n        try {\n            cr = client.callProcedure(\"IdProc\", \"id\", 1);\n            fail(\"parameter check failed\");\n        }\n        catch ( ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\"TYPE ERROR FOR PARAMETER 1\"));\n        }\n\n        try {\n            cr = client.callProcedure(\"IdProc\", 1, \"1\");\n            fail(\"parameter check failed\");\n        }\n        catch ( ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\"TYPE ERROR FOR PARAMETER 0\"));\n        }\n\n        cr = client.callProcedure(\"IdProc\", \"tag\", \"three\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(3L,result.getLong(0));\n\n        cr = client.callProcedure(\"IdProc\", \"bool\", \"false\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(4L,result.getLong(0));\n\n        cr = client.callProcedure(\"IdProc\", \"Vo\", \"\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(9L,result.getLong(0));\n\n        cr = client.callProcedure(\"NullFieldProc\", \"funky\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(9, result.getRowCount());\n\n        cr = client.callProcedure(\"NullFieldProc\", \"id\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(3, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(5L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(6L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(8L,result.getLong(0));\n\n        cr = client.callProcedure(\"InnerProc\", \"Vo\" ,\"wakarimasen\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(3, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(1L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(2L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(3L,result.getLong(0));\n\n        cr = client.callProcedure(\"IdProc\", \"arr\" ,\"[1,2,3,4]\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(3, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(1L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(2L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(3L,result.getLong(0));\n    }","id":77798,"modified_method":"public void testFIELDFunction() throws Exception {\n\n        final String jstemplate = \"{\\n\" +\n                \"    \\\"id\\\": %d,\\n\" +\n                \"    \\\"bool\\\": true,\\n\" +\n                \"    \\\"inner\\\": {\\n\" +\n                \"        \\\"veggies\\\": \\\"good for you\\\",\\n\" +\n                \"        \\\"Vo\\\": \\\"wakarimasen\\\"\\n\" +\n                \"    },\\n\" +\n                \"    \\\"arr\\\": [\\n\" +\n                \"        1,\\n\" +\n                \"        2,\\n\" +\n                \"        3,\\n\" +\n                \"        4\\n\" +\n                \"    ],\\n\" +\n                \"    \\\"tag\\\": \\\"%s\\\"\\n\" +\n                \"}\";\n\n        Client client = getClient();\n        ClientResponse cr;\n        VoltTable result;\n\n        cr = client.callProcedure(\"JS1.insert\",1,String.format(jstemplate, 1, \"one\"));\n        cr = client.callProcedure(\"JS1.insert\",2,String.format(jstemplate, 2, \"two\"));\n        cr = client.callProcedure(\"JS1.insert\",3,String.format(jstemplate, 3, \"three\"));\n        cr = client.callProcedure(\"JS1.insert\",4,\"{\\\"id\\\":4,\\\"bool\\\": false}\");\n        cr = client.callProcedure(\"JS1.insert\",5,\"{}\");\n        cr = client.callProcedure(\"JS1.insert\",6,\"[]\");\n        cr = client.callProcedure(\"JS1.insert\",7,\"{\\\"id\\\":7,\\\"funky\\\": null}\");\n        cr = client.callProcedure(\"JS1.insert\",8, null);\n        cr = client.callProcedure(\"JS1.insert\",9, \"{\\\"id\\\":9, \\\"Vo\\\":\\\"\\\"}\");\n\n        cr = client.callProcedure(\"IdFieldProc\", \"id\",\"1\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(1L,result.getLong(0));\n\n        try {\n            cr = client.callProcedure(\"IdFieldProc\", \"id\", 1);\n            fail(\"parameter check failed\");\n        }\n        catch ( ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\"TYPE ERROR FOR PARAMETER 1\"));\n        }\n\n        try {\n            cr = client.callProcedure(\"IdFieldProc\", 1, \"1\");\n            fail(\"parameter check failed\");\n        }\n        catch ( ProcCallException pcex) {\n            assertTrue(pcex.getMessage().contains(\"TYPE ERROR FOR PARAMETER 0\"));\n        }\n\n        cr = client.callProcedure(\"IdFieldProc\", \"tag\", \"three\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(3L,result.getLong(0));\n\n        cr = client.callProcedure(\"IdFieldProc\", \"bool\", \"false\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(4L,result.getLong(0));\n\n        cr = client.callProcedure(\"IdFieldProc\", \"Vo\", \"\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(1, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(9L,result.getLong(0));\n\n        cr = client.callProcedure(\"NullFieldProc\", \"funky\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(9, result.getRowCount());\n\n        cr = client.callProcedure(\"NullFieldProc\", \"id\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(3, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(5L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(6L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(8L,result.getLong(0));\n\n        cr = client.callProcedure(\"InnerFieldProc\", \"Vo\" ,\"wakarimasen\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(3, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(1L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(2L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(3L,result.getLong(0));\n\n        cr = client.callProcedure(\"IdFieldProc\", \"arr\" ,\"[1,2,3,4]\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        result = cr.getResults()[0];\n        assertEquals(3, result.getRowCount());\n        assertTrue(result.advanceRow());\n        assertEquals(1L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(2L,result.getLong(0));\n        assertTrue(result.advanceRow());\n        assertEquals(3L,result.getLong(0));\n    }","commit_id":"56fbaaead5be7f7f14860f653a16a39c0ec197f6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private DataType resolveDataType(Object value, OperationContextAdapter operationContext)\n    {\n        String mimeType = operationContext.getTypeSafeParameter(MIME_TYPE_PARAMETER_NAME, String.class);\n        String encoding = operationContext.getTypeSafeParameter(ENCODING_PARAMETER_NAME, String.class);\n\n        if (encoding == null && mimeType == null)\n        {\n            if (value instanceof MuleMessage)\n            {\n                return ((MuleMessage) value).getDataType();\n            }\n\n            return null;\n        }\n\n        if (value == null || value instanceof NullPayload)\n        {\n            return null;\n        }\n\n        return DataTypeFactory.create(value.getClass(), mimeType, encoding);\n    }","id":77799,"modified_method":"private DataType resolveDataType(Object value, OperationContextAdapter operationContext)\n    {\n        String mimeType = operationContext.getTypeSafeParameter(MIME_TYPE_PARAMETER_NAME, String.class);\n        String encoding = operationContext.getTypeSafeParameter(ENCODING_PARAMETER_NAME, String.class);\n        DataType dataType = null;\n        Class<?> type = value != null ? value.getClass() : NullPayload.class;\n\n        if (value instanceof MuleMessage)\n        {\n            dataType = ((MuleMessage) value).getDataType();\n            type = dataType.getType();\n            if (encoding == null && mimeType == null)\n            {\n                return dataType;\n            }\n\n            if (encoding == null)\n            {\n                encoding = dataType.getEncoding();\n            }\n\n            if (mimeType == null)\n            {\n                mimeType = dataType.getMimeType();\n            }\n        }\n\n        if (dataType != null && encoding == null && mimeType == null)\n        {\n            return dataType;\n        }\n\n        if (value == null || value instanceof NullPayload)\n        {\n            return null;\n        }\n\n        if (encoding == null)\n        {\n            encoding = muleContext.getConfiguration().getDefaultEncoding();\n        }\n\n        return DataTypeFactory.create(type, mimeType, encoding);\n    }","commit_id":"e1ac1c1416636316309b9cd37562f78d7c80c095","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void setsContentTypeOnXml() throws Exception\n    {\n        MuleEvent response = runFlow(\"setsContentTypeOnXml\");\n        DataType dataType = response.getMessage().getDataType();\n        assertThat(dataType.getEncoding(), is(customEncoding));\n        assertThat(dataType.getMimeType(), is(MIME_TYPE));\n    }","id":77800,"modified_method":"@Test\n    public void setsContentTypeOnXml() throws Exception\n    {\n        MuleEvent response = runFlow(\"setsContentTypeOnXml\");\n        DataType dataType = response.getMessage().getDataType();\n        assertCustomEncoding(dataType);\n        assertThat(dataType.getMimeType(), is(MIME_TYPE));\n    }","commit_id":"e1ac1c1416636316309b9cd37562f78d7c80c095","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void overridesContentType() throws Exception\n    {\n        String lastSupportedEncoding = Charset.availableCharsets().keySet().stream().reduce((first, last) -> last).get();\n        MuleEvent response = runFlow(\"setsContentTypeProgrammatically\");\n\n        final DataType dataType = response.getMessage().getDataType();\n        assertThat(dataType.getMimeType(), is(\"dead/dead\"));\n        assertThat(dataType.getEncoding(), is(lastSupportedEncoding));\n    }","id":77801,"modified_method":"@Test\n    public void overridesContentType() throws Exception\n    {\n        String lastSupportedEncoding = Charset.availableCharsets().keySet().stream().reduce((first, last) -> last).get();\n        MuleEvent response = runFlow(\"setsContentTypeProgrammatically\");\n\n        final DataType dataType = response.getMessage().getDataType();\n        assertCustomMimeType(dataType);\n        assertThat(dataType.getEncoding(), is(lastSupportedEncoding));\n    }","commit_id":"e1ac1c1416636316309b9cd37562f78d7c80c095","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void maintainsContentType() throws Exception\n    {\n        FlowRunner runner = flowRunner(\"defaultContentType\").withPayload(\"\");\n\n        MuleEvent requestEvent = runner.buildEvent();\n        MuleEvent response = runner.run();\n\n        final DataType requestDataType = requestEvent.getMessage().getDataType();\n        final DataType responseDataType = response.getMessage().getDataType();\n\n        assertThat(requestDataType.getEncoding(), is(responseDataType.getEncoding()));\n        assertThat(requestDataType.getMimeType(), is(responseDataType.getMimeType()));\n    }","id":77802,"modified_method":"@Test\n    public void maintainsContentType() throws Exception\n    {\n        MuleEvent response = flowRunner(\"defaultContentType\").withPayload(\"\").run();\n        final DataType responseDataType = response.getMessage().getDataType();\n\n        assertDefaultEncoding(responseDataType);\n        assertDefaultMimeType(responseDataType);\n    }","commit_id":"e1ac1c1416636316309b9cd37562f78d7c80c095","url":"https://github.com/mulesoft/mule"},{"original_method":"public String getString(byte[] bytes)\n    {\n        if (bytes.length != 16)\n        {\n            throw new MarshalException(\"UUIDs must be exactly 16 bytes\");\n        }\n        return getUUID(bytes).toString();\n    }","id":77803,"modified_method":"public String getString(byte[] bytes)\n    {\n        if (bytes.length == 0)\n        {\n            return \"\";\n        }\n        if (bytes.length != 16)\n        {\n            throw new MarshalException(\"UUIDs must be exactly 16 bytes\");\n        }\n        return getUUID(bytes).toString();\n    }","commit_id":"bb464c1f3703fc8b31be7859ca32e83e755a60dd","url":"https://github.com/apache/cassandra"},{"original_method":"public String getString(byte[] bytes)\n    {\n        if (bytes.length != 8)\n        {\n            throw new MarshalException(\"A long is exactly 8 bytes\");\n        }\n        return String.valueOf(ByteBuffer.wrap(bytes).getLong());\n    }","id":77804,"modified_method":"public String getString(byte[] bytes)\n    {\n        if (bytes.length == 0)\n        {\n            return \"\";\n        }\n        if (bytes.length != 8)\n        {\n            throw new MarshalException(\"A long is exactly 8 bytes\");\n        }\n        return String.valueOf(ByteBuffer.wrap(bytes).getLong());\n    }","commit_id":"bb464c1f3703fc8b31be7859ca32e83e755a60dd","url":"https://github.com/apache/cassandra"},{"original_method":"protected AbstractType getComparator()\n    {\n        return DatabaseDescriptor.getComparator(table, getColumnFamilyName());\n    }","id":77805,"modified_method":"protected AbstractType getComparator()\n    {\n        return queryPath.superColumnName == null\n               ? DatabaseDescriptor.getComparator(table, getColumnFamilyName())\n               : DatabaseDescriptor.getSubComparator(table, getColumnFamilyName());\n    }","commit_id":"bb464c1f3703fc8b31be7859ca32e83e755a60dd","url":"https://github.com/apache/cassandra"},{"original_method":"public String getString(byte[] bytes)\n    {\n        if (bytes.length != 16)\n        {\n            throw new MarshalException(\"UUIDs must be exactly 16 bytes\");\n        }\n        UUID uuid = LexicalUUIDType.getUUID(bytes);\n        if (uuid.version() != 1)\n        {\n            throw new MarshalException(\"TimeUUID only makes sense with version 1 UUIDs\");\n        }\n        return uuid.toString();\n    }","id":77806,"modified_method":"public String getString(byte[] bytes)\n    {\n        if (bytes.length == 0)\n        {\n            return \"\";\n        }\n        if (bytes.length != 16)\n        {\n            throw new MarshalException(\"UUIDs must be exactly 16 bytes\");\n        }\n        UUID uuid = LexicalUUIDType.getUUID(bytes);\n        if (uuid.version() != 1)\n        {\n            throw new MarshalException(\"TimeUUID only makes sense with version 1 UUIDs\");\n        }\n        return uuid.toString();\n    }","commit_id":"bb464c1f3703fc8b31be7859ca32e83e755a60dd","url":"https://github.com/apache/cassandra"},{"original_method":"public static CFMetaData inflate(org.apache.cassandra.config.avro.CfDef cf)\n    {\n        AbstractType comparator;\n        AbstractType subcolumnComparator = null;\n        AbstractReconciler reconciler;\n        AbstractType validator;\n        try\n        {\n            comparator = DatabaseDescriptor.getComparator(cf.comparator_type.toString());\n            if (cf.subcomparator_type != null)\n                subcolumnComparator = DatabaseDescriptor.getComparator(cf.subcomparator_type.toString());\n            reconciler = DatabaseDescriptor.getReconciler(cf.reconciler.toString());\n            validator = DatabaseDescriptor.getComparator(cf.default_validation_class.toString());\n        }\n        catch (Exception ex)\n        {\n            throw new RuntimeException(\"Could not inflate CFMetaData for \" + cf, ex);\n        }\n        Map<byte[], ColumnDefinition> column_metadata = new TreeMap<byte[], ColumnDefinition>(FBUtilities.byteArrayComparator);\n        Iterator<org.apache.cassandra.config.avro.ColumnDef> cditer = cf.column_metadata.iterator();\n        while (cditer.hasNext())\n        {\n            ColumnDefinition cd = ColumnDefinition.inflate(cditer.next());\n            column_metadata.put(cd.name, cd);\n        }\n        return new CFMetaData(cf.keyspace.toString(), cf.name.toString(), ColumnFamilyType.create(cf.column_type.toString()), ClockType.create(cf.clock_type.toString()), comparator, subcolumnComparator, reconciler, cf.comment.toString(), cf.row_cache_size, cf.preload_row_cache, cf.key_cache_size, cf.read_repair_chance, cf.gc_grace_seconds, validator, cf.id, column_metadata);\n    }","id":77807,"modified_method":"public static CFMetaData inflate(org.apache.cassandra.config.avro.CfDef cf)\n    {\n        AbstractType comparator;\n        AbstractType subcolumnComparator = null;\n        AbstractReconciler reconciler;\n        AbstractType validator;\n        try\n        {\n            comparator = DatabaseDescriptor.getComparator(cf.comparator_type.toString());\n            if (cf.subcomparator_type != null)\n                subcolumnComparator = DatabaseDescriptor.getComparator(cf.subcomparator_type.toString());\n            reconciler = DatabaseDescriptor.getReconciler(cf.reconciler.toString());\n            validator = cf.default_validation_class == null\n                        ? BytesType.instance\n                        : DatabaseDescriptor.getComparator(cf.default_validation_class.toString());\n        }\n        catch (Exception ex)\n        {\n            throw new RuntimeException(\"Could not inflate CFMetaData for \" + cf, ex);\n        }\n        Map<byte[], ColumnDefinition> column_metadata = new TreeMap<byte[], ColumnDefinition>(FBUtilities.byteArrayComparator);\n        for (ColumnDef aColumn_metadata : cf.column_metadata)\n        {\n            ColumnDefinition cd = ColumnDefinition.inflate(aColumn_metadata);\n            column_metadata.put(cd.name, cd);\n        }\n        return new CFMetaData(cf.keyspace.toString(), cf.name.toString(), ColumnFamilyType.create(cf.column_type.toString()), ClockType.create(cf.clock_type.toString()), comparator, subcolumnComparator, reconciler, cf.comment.toString(), cf.row_cache_size, cf.preload_row_cache, cf.key_cache_size, cf.read_repair_chance, cf.gc_grace_seconds, validator, cf.id, column_metadata);\n    }","commit_id":"ea6fb4695e73aeedeaae56f6373cbfa260f4739a","url":"https://github.com/apache/cassandra"},{"original_method":"/** clones an existing CFMetaData using the same id. */\n    public static CFMetaData rename(CFMetaData cfm, String newName)\n    {\n        CFMetaData newCfm = new CFMetaData(cfm.tableName, newName, cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.reconciler, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.gcGraceSeconds, cfm.defaultValidator, cfm.cfId, cfm.column_metadata);\n        return newCfm;\n    }","id":77808,"modified_method":"/** clones an existing CFMetaData using the same id. */\n    public static CFMetaData rename(CFMetaData cfm, String newName)\n    {\n        return new CFMetaData(cfm.tableName, newName, cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.reconciler, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.gcGraceSeconds, cfm.defaultValidator, cfm.cfId, cfm.column_metadata);\n    }","commit_id":"ea6fb4695e73aeedeaae56f6373cbfa260f4739a","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Creates a {@link StreamResequencer} instance applying the given <code>config<\/code>.\n     * \n     * @param routeContext route context.\n     * @param config stream resequencer configuration.\n     * @return the configured stream resequencer.\n     * @throws Exception can be thrwon\n     */\n    protected StreamResequencer createStreamResequencer(RouteContext routeContext,\n                                                        StreamResequencerConfig config) throws Exception {\n        Processor processor = this.createChildProcessor(routeContext, true);\n        Expression expression = getExpression().createExpression(routeContext);\n\n        // and wrap in unit of work\n        String routeId = routeContext.getRoute().idOrCreate(routeContext.getCamelContext().getNodeIdFactory());\n        CamelInternalProcessor internal = new CamelInternalProcessor(processor);\n        internal.addAdvice(new CamelInternalProcessor.UnitOfWorkProcessorAdvice(routeId));\n\n        ObjectHelper.notNull(config, \"config\", this);\n        ObjectHelper.notNull(expression, \"expression\", this);\n\n        ExpressionResultComparator comparator = config.getComparator();\n        comparator.setExpression(expression);\n\n        StreamResequencer resequencer = new StreamResequencer(routeContext.getCamelContext(), internal, comparator);\n        resequencer.setTimeout(config.getTimeout());\n        resequencer.setCapacity(config.getCapacity());\n        resequencer.setRejectOld(config.getRejectOld());\n        if (config.getIgnoreInvalidExchanges() != null) {\n            resequencer.setIgnoreInvalidExchanges(config.getIgnoreInvalidExchanges());\n        }\n        return resequencer;\n    }","id":77809,"modified_method":"/**\n     * Creates a {@link StreamResequencer} instance applying the given <code>config<\/code>.\n     * \n     * @param routeContext route context.\n     * @param config stream resequencer configuration.\n     * @return the configured stream resequencer.\n     * @throws Exception can be thrwon\n     */\n    protected StreamResequencer createStreamResequencer(RouteContext routeContext,\n                                                        StreamResequencerConfig config) throws Exception {\n        Processor processor = this.createChildProcessor(routeContext, true);\n        Expression expression = getExpression().createExpression(routeContext);\n\n        // and wrap in unit of work\n        String routeId = routeContext.getRoute().idOrCreate(routeContext.getCamelContext().getNodeIdFactory());\n        CamelInternalProcessor internal = new CamelInternalProcessor(processor);\n        internal.addAdvice(new CamelInternalProcessor.UnitOfWorkProcessorAdvice(routeId));\n\n        ObjectHelper.notNull(config, \"config\", this);\n        ObjectHelper.notNull(expression, \"expression\", this);\n\n        ExpressionResultComparator comparator;\n        if (config.getComparatorRef() != null) {\n            comparator = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), config.getComparatorRef(), ExpressionResultComparator.class);\n        } else {\n            comparator = config.getComparator();\n        }\n        comparator.setExpression(expression);\n\n        StreamResequencer resequencer = new StreamResequencer(routeContext.getCamelContext(), internal, comparator);\n        resequencer.setTimeout(config.getTimeout());\n        resequencer.setCapacity(config.getCapacity());\n        resequencer.setRejectOld(config.getRejectOld());\n        if (config.getIgnoreInvalidExchanges() != null) {\n            resequencer.setIgnoreInvalidExchanges(config.getIgnoreInvalidExchanges());\n        }\n        return resequencer;\n    }","commit_id":"546c3fd4a23dcc97e126c9f2a6e0290300b7e0f5","url":"https://github.com/apache/camel"},{"original_method":"@Override\n  public void updateStep() {\n    if (myOnValidateAttempt) {\n      // We assume that this method is called when project validation triggered by end-user fails (he or she pressed 'Next'/'Finish' \n      // button at the wizard and current state is invalid). So, there is no need to rebuild the model then.\n      myOnValidateAttempt = false;\n      return;\n    }\n\n    clear();\n\n    GradleProject project = getBuilder().getGradleProject();\n    if (project == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't init 'adjust importing settings' step. Reason: no project is defined. Context: '%s', builder: '%s'\",\n        getWizardContext(), getBuilder()\n      ));\n    }\n\n    Map<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>> entity2nodes\n      = new HashMap<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>>();\n    int counter = 0;\n    DefaultMutableTreeNode root = buildNode(project, entity2nodes, counter++);\n\n    List<GradleModule> modules = new ArrayList<GradleModule>(project.getModules());\n    Collections.sort(modules, Named.COMPARATOR);\n    List<MutableTreeNode> moduleNodes = new ArrayList<MutableTreeNode>();\n    Map<GradleModule, GradleModule> moduleMappings = new HashMap<GradleModule, GradleModule>();\n\n    for (GradleModule module : modules) {\n      GradleModule moduleCopy = module.clone();\n      moduleMappings.put(module, moduleCopy);\n      DefaultMutableTreeNode moduleNode = buildNode(module, entity2nodes, counter++);\n      moduleNodes.add(moduleNode);\n      Collection<GradleDependency> dependencies = module.getDependencies();\n      if (!dependencies.isEmpty()) {\n        DefaultMutableTreeNode dependenciesNode\n          = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.dependencies\"));\n        final List<GradleModuleDependency> moduleDependencies = new ArrayList<GradleModuleDependency>();\n        final List<GradleLibrary> libraryDependencies = new ArrayList<GradleLibrary>();\n        GradleEntityVisitor visitor = new GradleEntityVisitorAdapter() {\n          @Override\n          public void visit(@NotNull GradleModuleDependency dependency) {\n            moduleDependencies.add(dependency);\n          }\n\n          @Override\n          public void visit(@NotNull GradleLibraryDependency dependency) {\n            libraryDependencies.add(dependency.getLibrary());\n          }\n        };\n        for (GradleDependency dependency : dependencies) {\n          dependency.invite(visitor);\n        }\n        Collections.sort(moduleDependencies, GradleModuleDependency.COMPARATOR);\n        Collections.sort(libraryDependencies, Named.COMPARATOR);\n        for (GradleModuleDependency dependency : moduleDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        for (GradleLibrary dependency : libraryDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        moduleNode.add(dependenciesNode);\n      }\n    }\n\n    myTreeModel.setRoot(root);\n    myTree.setSelectionPath(new TreePath(root));\n    \n    Collection<? extends GradleLibrary> libraries = project.getLibraries();\n    if (libraries.isEmpty()) {\n      for (MutableTreeNode node : moduleNodes) {\n        root.add(node);\n      }\n    }\n    else {\n      // Insert intermediate 'modules' and 'libraries' nodes if the project has both libraries and nodes.\n      DefaultMutableTreeNode modulesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.modules\"));\n      for (MutableTreeNode node : moduleNodes) {\n        modulesNode.add(node);\n      }\n      root.add(modulesNode);\n\n      List<GradleLibrary> sortedLibraries = new ArrayList<GradleLibrary>(libraries);\n      Collections.sort(sortedLibraries, Named.COMPARATOR);\n      DefaultMutableTreeNode librariesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.libraries\"));\n      for (GradleLibrary library : sortedLibraries) {\n        librariesNode.add(buildNode(library, entity2nodes, counter++));\n      }\n      root.add(librariesNode);\n\n      myTree.expandPath(new TreePath(modulesNode.getPath()));\n      myTree.expandPath(new TreePath(librariesNode.getPath()));\n    }\n    \n    myTree.expandPath(new TreePath(root.getPath()));\n    getBuilder().setModuleMappings(moduleMappings);\n  }","id":77810,"modified_method":"@Override\n  public void updateStep() {\n    if (myOnValidateAttempt) {\n      // We assume that this method is called when project validation triggered by end-user fails (he or she pressed 'Next'/'Finish' \n      // button at the wizard and current state is invalid). So, there is no need to rebuild the model then.\n      myOnValidateAttempt = false;\n      return;\n    }\n\n    clear();\n\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder == null) {\n      return;\n    }\n    GradleProject project = builder.getGradleProject();\n    if (project == null) {\n      throw new IllegalStateException(String.format(\n        \"Can't init 'adjust importing settings' step. Reason: no project is defined. Context: '%s', builder: '%s'\",\n        getWizardContext(), getBuilder()\n      ));\n    }\n\n    Map<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>> entity2nodes\n      = new HashMap<GradleEntity, Pair<String, Collection<GradleProjectStructureNode>>>();\n    int counter = 0;\n    DefaultMutableTreeNode root = buildNode(project, entity2nodes, counter++);\n\n    List<GradleModule> modules = new ArrayList<GradleModule>(project.getModules());\n    Collections.sort(modules, Named.COMPARATOR);\n    List<MutableTreeNode> moduleNodes = new ArrayList<MutableTreeNode>();\n    Map<GradleModule, GradleModule> moduleMappings = new HashMap<GradleModule, GradleModule>();\n\n    for (GradleModule module : modules) {\n      GradleModule moduleCopy = module.clone();\n      moduleMappings.put(module, moduleCopy);\n      DefaultMutableTreeNode moduleNode = buildNode(module, entity2nodes, counter++);\n      moduleNodes.add(moduleNode);\n      Collection<GradleDependency> dependencies = module.getDependencies();\n      if (!dependencies.isEmpty()) {\n        DefaultMutableTreeNode dependenciesNode\n          = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.dependencies\"));\n        final List<GradleModuleDependency> moduleDependencies = new ArrayList<GradleModuleDependency>();\n        final List<GradleLibrary> libraryDependencies = new ArrayList<GradleLibrary>();\n        GradleEntityVisitor visitor = new GradleEntityVisitorAdapter() {\n          @Override\n          public void visit(@NotNull GradleModuleDependency dependency) {\n            moduleDependencies.add(dependency);\n          }\n\n          @Override\n          public void visit(@NotNull GradleLibraryDependency dependency) {\n            libraryDependencies.add(dependency.getLibrary());\n          }\n        };\n        for (GradleDependency dependency : dependencies) {\n          dependency.invite(visitor);\n        }\n        Collections.sort(moduleDependencies, GradleModuleDependency.COMPARATOR);\n        Collections.sort(libraryDependencies, Named.COMPARATOR);\n        for (GradleModuleDependency dependency : moduleDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        for (GradleLibrary dependency : libraryDependencies) {\n          dependenciesNode.add(buildNode(dependency, entity2nodes, counter++));\n        }\n        moduleNode.add(dependenciesNode);\n      }\n    }\n\n    myTreeModel.setRoot(root);\n    myTree.setSelectionPath(new TreePath(root));\n    \n    Collection<? extends GradleLibrary> libraries = project.getLibraries();\n    if (libraries.isEmpty()) {\n      for (MutableTreeNode node : moduleNodes) {\n        root.add(node);\n      }\n    }\n    else {\n      // Insert intermediate 'modules' and 'libraries' nodes if the project has both libraries and nodes.\n      DefaultMutableTreeNode modulesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.modules\"));\n      for (MutableTreeNode node : moduleNodes) {\n        modulesNode.add(node);\n      }\n      root.add(modulesNode);\n\n      List<GradleLibrary> sortedLibraries = new ArrayList<GradleLibrary>(libraries);\n      Collections.sort(sortedLibraries, Named.COMPARATOR);\n      DefaultMutableTreeNode librariesNode = new DefaultMutableTreeNode(GradleBundle.message(\"gradle.import.structure.tree.node.libraries\"));\n      for (GradleLibrary library : sortedLibraries) {\n        librariesNode.add(buildNode(library, entity2nodes, counter++));\n      }\n      root.add(librariesNode);\n\n      myTree.expandPath(new TreePath(modulesNode.getPath()));\n      myTree.expandPath(new TreePath(librariesNode.getPath()));\n    }\n    \n    myTree.expandPath(new TreePath(root.getPath()));\n    builder.setModuleMappings(moduleMappings);\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"SuspiciousMethodCalls\")\n  @Override\n  public boolean validate() throws ConfigurationException {\n    // Validate current card.\n    Object node = myTree.getLastSelectedPathComponent();\n    Pair<String, GradleProjectStructureNodeSettings> pair = myCards.get(node);\n    if (pair != null && !pair.second.validate()) {\n      myOnValidateAttempt = true;\n      return false;\n    }\n\n    for (Map.Entry<GradleProjectStructureNode, Pair<String, GradleProjectStructureNodeSettings>> entry : myCards.entrySet()) {\n      if (!entry.getValue().second.validate()) {\n        myTree.getSelectionModel().setSelectionPath(new TreePath(entry.getKey().getPath()));\n        //mySettingsCardLayout.show(mySettingsPanel, entry.getValue().first);\n        myOnValidateAttempt = true;\n        return false;\n      }\n    }\n    getBuilder().applyProjectSettings(getWizardContext());\n    return true;\n  }","id":77811,"modified_method":"@SuppressWarnings(\"SuspiciousMethodCalls\")\n  @Override\n  public boolean validate() throws ConfigurationException {\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder == null) {\n      return false;\n    }\n\n    // Validate current card.\n    Object node = myTree.getLastSelectedPathComponent();\n    Pair<String, GradleProjectStructureNodeSettings> pair = myCards.get(node);\n    if (pair != null && !pair.second.validate()) {\n      myOnValidateAttempt = true;\n      return false;\n    }\n\n    for (Map.Entry<GradleProjectStructureNode, Pair<String, GradleProjectStructureNodeSettings>> entry : myCards.entrySet()) {\n      if (!entry.getValue().second.validate()) {\n        myTree.getSelectionModel().setSelectionPath(new TreePath(entry.getKey().getPath()));\n        //mySettingsCardLayout.show(mySettingsPanel, entry.getValue().first);\n        myOnValidateAttempt = true;\n        return false;\n      }\n    }\n\n    builder.applyProjectSettings(getWizardContext());\n    return true;\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void apply() throws ConfigurationException {\n    useNormalColorForPath();\n    GradleSettings.getInstance(myProject).GRADLE_HOME = myPathComponent.getPath();\n  }","id":77812,"modified_method":"@Override\n  public void apply() {\n    useNormalColorForPath();\n    GradleSettings.getInstance(myProject).GRADLE_HOME = myGradleHomeComponent.getPath();\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void useNormalColorForPath() {\n    myPathComponent.getPathComponent().setForeground(UIManager.getColor(\"TextField.foreground\"));\n  }","id":77813,"modified_method":"private void useNormalColorForPath() {\n    myGradleHomeComponent.getPathComponent().setForeground(UIManager.getColor(\"TextField.foreground\"));\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createComponent() {\n    myComponent = new JPanel(new GridBagLayout());\n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.gridwidth = GridBagConstraints.REMAINDER;\n    constraints.weightx = 1;\n    constraints.weighty = 1;\n    constraints.fill = GridBagConstraints.HORIZONTAL;\n    constraints.anchor = GridBagConstraints.NORTH;\n\n    myPathComponent = new NamePathComponent(\n      \"\", GradleBundle.message(\"gradle.import.text.home.path\"), GradleBundle.message(\"gradle.import.text.home.path\"), \"\",\n      false,\n      false\n    );\n    myPathComponent.setNameComponentVisible(false);\n    myComponent.add(myPathComponent, constraints);\n    myComponent.add(Box.createVerticalGlue());\n    return myComponent;\n  }","id":77814,"modified_method":"@Override\n  public JComponent createComponent() {\n    if (myComponent == null) {\n      doCreateComponent();\n    }\n    return myComponent;\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleConfigurable(@Nullable Project project) {\n    myProject = project;\n  }","id":77815,"modified_method":"public GradleConfigurable(@Nullable Project project) {\n    myProject = project;\n    doCreateComponent();\n    deduceGradleHomeIfPossible();\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void disposeUIResources() {\n    myComponent = null;\n    myPathComponent = null;\n  }","id":77816,"modified_method":"@Override\n  public void disposeUIResources() {\n    myComponent = null;\n    myGradleHomeComponent = null;\n    myPathManuallyModified = false;\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void reset() {\n    useNormalColorForPath();\n    String valueToUse = GradleSettings.getInstance(myProject).GRADLE_HOME;\n    if (!StringUtil.isEmpty(valueToUse)) {\n      myPathComponent.setPath(valueToUse);\n      return; \n    }\n    deduceGradleHomeIfPossible();  \n  }","id":77817,"modified_method":"@Override\n  public void reset() {\n    useNormalColorForPath();\n    String valueToUse = GradleSettings.getInstance(myProject).GRADLE_HOME;\n    if (!StringUtil.isEmpty(valueToUse)) {\n      myGradleHomeSettingType = myLibraryManager.isGradleSdkHome(new File(valueToUse)) ?\n                                GradleHomeSettingType.EXPLICIT_CORRECT :\n                                GradleHomeSettingType.EXPLICIT_INCORRECT;\n      if (myGradleHomeSettingType == GradleHomeSettingType.EXPLICIT_INCORRECT) {\n        new DelayedBalloonInfo(MessageType.ERROR, myGradleHomeSettingType).run();\n      }\n      myGradleHomeComponent.setPath(valueToUse);\n      return;\n    }\n    myGradleHomeSettingType = GradleHomeSettingType.UNKNOWN;\n    deduceGradleHomeIfPossible();\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Updates GUI of the gradle configurable in order to show deduced path to gradle (if possible).\n   */\n  private void deduceGradleHomeIfPossible() {\n    File gradleHome = myLibraryManager.getGradleHome(myProject);\n    if (gradleHome == null) {\n      return;\n    }\n    myPathComponent.setPath(gradleHome.getPath());\n    myPathComponent.getPathComponent().setForeground(UIManager.getColor(\"TextField.inactiveForeground\"));\n  }","id":77818,"modified_method":"/**\n   * Updates GUI of the gradle configurable in order to show deduced path to gradle (if possible).\n   */\n  private void deduceGradleHomeIfPossible() {\n    File gradleHome = myLibraryManager.getGradleHome(myProject);\n    if (gradleHome == null) {\n      new DelayedBalloonInfo(MessageType.WARNING, GradleHomeSettingType.UNKNOWN).run();\n      return;\n    }\n    myGradleHomeSettingType = GradleHomeSettingType.DEDUCED;\n    new DelayedBalloonInfo(MessageType.INFO, GradleHomeSettingType.DEDUCED).run();\n    if (myGradleHomeComponent != null) {\n      myGradleHomeComponent.setPath(gradleHome.getPath());\n      myGradleHomeComponent.getPathComponent().setForeground(UIManager.getColor(\"TextField.inactiveForeground\"));\n    }\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isModified() {\n    if (!myPathComponent.isPathChangedByUser()) {\n      return false;\n    }\n    String newPath = myPathComponent.getPath();\n    String oldPath = GradleSettings.getInstance(myProject).GRADLE_HOME;\n    boolean modified = newPath == null ? oldPath == null : !newPath.equals(oldPath);\n    if (modified) {\n      useNormalColorForPath();\n    } \n    return modified;\n  }","id":77819,"modified_method":"@Override\n  public boolean isModified() {\n    if (!myPathManuallyModified) {\n      return false;\n    }\n    String newPath = myGradleHomeComponent.getPath();\n    String oldPath = GradleSettings.getInstance(myProject).GRADLE_HOME;\n    boolean modified = newPath == null ? oldPath == null : !newPath.equals(oldPath);\n    if (modified) {\n      useNormalColorForPath();\n    }\n    return modified;\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Asks current builder to ensure that target gradle project is defined.\n   * \n   * @throws ConfigurationException   if gradle project is not defined and can't be constructed\n   */\n  public void ensureProjectIsDefined() throws ConfigurationException {\n    if (myProjectFile == null) {\n      throw new ConfigurationException(GradleBundle.message(\"gradle.import.text.error.project.undefined\"));\n    }\n    if (myProjectFile.isDirectory()) {\n      throw new ConfigurationException(GradleBundle.message(\"gradle.import.text.error.directory.instead.file\"));\n    }\n    final Ref<String> errorReason = new Ref<String>();\n    try {\n      // TODO den derive target project for 'import module from gradle' (for 'add module' functionality).\n      Project project = ProjectManager.getInstance().getDefaultProject();\n      ProgressManager.getInstance().run(new Task.Modal(project, GradleBundle.message(\"gradle.import.progress.text\"), true) {\n        @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n        @Override\n        public void run(@NotNull ProgressIndicator indicator) {\n          indicator.setIndeterminate(true);\n          GradleApiFacadeManager manager = ServiceManager.getService(GradleApiFacadeManager.class);\n          try {\n            GradleProjectResolver resolver = manager.getFacade().getResolver();\n            myGradleProject = resolver.resolveProjectInfo(myProjectFile.getAbsolutePath(), false);\n          }\n          catch (Exception e) {\n            errorReason.set(RemoteUtil.unwrap(e).getLocalizedMessage());\n            // Ignore here because it will be reported on method exit.\n            GradleLog.LOG.warn(\"Can't resolve gradle project\", e);\n          }\n        }\n      });\n    }\n    catch (IllegalArgumentException e) {\n      throw new ConfigurationException(e.getMessage(), GradleBundle.message(\"gradle.import.text.error.cannot.parse.project\"));\n    }\n    if (myGradleProject == null) {\n      String errorMessage = GradleBundle.message(\"gradle.import.text.error.resolve.generic.without.reason\", myProjectFile.getPath());\n      String reason = errorReason.get();\n      if (reason != null) {\n        errorMessage = GradleBundle.message(\"gradle.import.text.error.resolve.generic.with.reason\", myProjectFile.getPath(), reason);\n      } \n      throw new ConfigurationException(errorMessage, GradleBundle.message(\"gradle.import.title.error.resolve.generic\"));\n    } \n  }","id":77820,"modified_method":"/**\n   * Asks current builder to ensure that target gradle project is defined.\n   *\n   * @param wizardContext             current wizard context\n   * @throws ConfigurationException   if gradle project is not defined and can't be constructed\n   */\n  public void ensureProjectIsDefined(@NotNull WizardContext wizardContext) throws ConfigurationException {\n    if (myProjectFile == null) {\n      throw new ConfigurationException(GradleBundle.message(\"gradle.import.text.error.project.undefined\"));\n    }\n    if (myProjectFile.isDirectory()) {\n      throw new ConfigurationException(GradleBundle.message(\"gradle.import.text.error.directory.instead.file\"));\n    }\n    final Ref<String> errorReason = new Ref<String>();\n    try {\n      Project project = getProject(wizardContext);\n      ProgressManager.getInstance().run(new Task.Modal(project, GradleBundle.message(\"gradle.import.progress.text\"), true) {\n        @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n        @Override\n        public void run(@NotNull ProgressIndicator indicator) {\n          indicator.setIndeterminate(true);\n          GradleApiFacadeManager manager = ServiceManager.getService(GradleApiFacadeManager.class);\n          try {\n            GradleProjectResolver resolver = manager.getFacade().getResolver();\n            myGradleProject = resolver.resolveProjectInfo(myProjectFile.getAbsolutePath(), false);\n          }\n          catch (Exception e) {\n            Throwable unwrapped = RemoteUtil.unwrap(e);\n            if (unwrapped.getClass() == NoClassDefFoundError.class) {\n              errorReason.set(GradleBundle.message(\"gradle.import.text.error.too.old.gradle\"));\n            }\n            else {\n              errorReason.set(unwrapped.getLocalizedMessage());\n            }\n            // Ignore here because it will be reported on method exit.\n            GradleLog.LOG.warn(\"Can't resolve gradle project\", e);\n          }\n        }\n      });\n    }\n    catch (IllegalArgumentException e) {\n      throw new ConfigurationException(e.getMessage(), GradleBundle.message(\"gradle.import.text.error.cannot.parse.project\"));\n    }\n    if (myGradleProject == null) {\n      String errorMessage = GradleBundle.message(\"gradle.import.text.error.resolve.generic.without.reason\", myProjectFile.getPath());\n      String reason = errorReason.get();\n      if (reason != null) {\n        errorMessage = GradleBundle.message(\"gradle.import.text.error.resolve.generic.with.reason\", myProjectFile.getPath(), reason);\n      } \n      throw new ConfigurationException(errorMessage, GradleBundle.message(\"gradle.import.title.error.resolve.generic\"));\n    } \n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void updateStep() {\n    if (isPathChanged()) {\n      myProjectPathComponent.setText(getBuilder().getProjectPath(getWizardContext()));\n    }\n  }","id":77821,"modified_method":"@Override\n  public void updateStep() {\n    if (!myGradleSettingsInitialised) {\n      initGradleSettingsControl();\n    }\n    if (myConfigurable != null) {\n      myConfigurable.reset();\n    }\n\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder != null && isPathChanged()) {\n      myProjectPathComponent.setText(builder.getProjectPath(getWizardContext()));\n    }\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isPathChanged() {\n    return !StringUtil.equals(myProjectPathComponent.getText(), getBuilder().getProjectPath(getWizardContext()));\n  }","id":77822,"modified_method":"private boolean isPathChanged() {\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder == null) {\n      return false;\n    }\n    return !StringUtil.equals(myProjectPathComponent.getText(), builder.getProjectPath(getWizardContext()));\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void storeCurrentSettings() {\n    if (isPathChanged()) {\n      getBuilder().setCurrentProjectPath(myProjectPathComponent.getText());\n    }\n  }","id":77823,"modified_method":"private void storeCurrentSettings() {\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder != null && isPathChanged()) {\n      builder.setCurrentProjectPath(myProjectPathComponent.getText());\n    }\n    if (myConfigurable != null && myConfigurable.isModified()) {\n      myConfigurable.apply();\n    }\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean validate() throws ConfigurationException {\n    storeCurrentSettings();\n    getBuilder().ensureProjectIsDefined();\n    return true;\n  }","id":77824,"modified_method":"@Override\n  public boolean validate() throws ConfigurationException {\n    if (myConfigurable.getCurrentGradleHomeSettingType() == GradleHomeSettingType.EXPLICIT_INCORRECT) {\n      GradleUtil.showBalloon(\n        myConfigurable.getGradleHomeComponent().getPathComponent(),\n        MessageType.ERROR,\n        GradleBundle.message(\"gradle.home.setting.type.explicit.incorrect\")\n      );\n      return false;\n    }\n    if (myConfigurable.getCurrentGradleHomeSettingType() == GradleHomeSettingType.UNKNOWN) {\n      GradleUtil.showBalloon(\n        myConfigurable.getGradleHomeComponent().getPathComponent(),\n        MessageType.ERROR,\n        GradleBundle.message(\"gradle.home.setting.type.unknown\")\n      );\n      return false;\n    }\n    storeCurrentSettings();\n    GradleProjectImportBuilder builder = getBuilder();\n    if (builder == null) {\n      return false;\n    }\n    builder.ensureProjectIsDefined(getWizardContext());\n    return true;\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleSelectProjectStep(@NotNull WizardContext context) {\n    super(context);\n    \n    GridBagConstraints constraints = new GridBagConstraints();\n    JLabel label = new JLabel(GradleBundle.message(\"gradle.import.label.select.project\"));\n    myComponent.add(label);\n\n    constraints.gridwidth = GridBagConstraints.REMAINDER;\n    constraints.weightx = 1;\n    constraints.fill = GridBagConstraints.HORIZONTAL;\n    \n    myProjectPathComponent = new TextFieldWithBrowseButton();\n    myProjectPathComponent.addBrowseFolderListener(\n      \"\",\n      GradleBundle.message(\"gradle.import.title.select.project\"),\n      null,\n      new FileTypeDescriptor(GradleBundle.message(\"gradle.import.label.select.project\"), \"gradle\")\n    );\n    myComponent.add(myProjectPathComponent, constraints);\n    myComponent.add(Box.createVerticalGlue());\n  }","id":77825,"modified_method":"public GradleSelectProjectStep(@NotNull WizardContext context) {\n    super(context);\n\n    myLabelConstraints.anchor = GridBagConstraints.WEST;\n    JLabel label = new JLabel(GradleBundle.message(\"gradle.import.label.select.project\"));\n    myComponent.add(label, myLabelConstraints);\n\n    myControlConstraints.gridwidth = GridBagConstraints.REMAINDER;\n    myControlConstraints.weightx = 1;\n    myControlConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n    myProjectPathComponent = new TextFieldWithBrowseButton();\n    myProjectPathComponent.addBrowseFolderListener(\n      \"\",\n      GradleBundle.message(\"gradle.import.title.select.project\"),\n      null,\n      new FileTypeDescriptor(GradleBundle.message(\"gradle.import.label.select.project\"), \"gradle\")\n    );\n    myComponent.add(myProjectPathComponent, myControlConstraints);\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NamePathComponent(String nameLabelText,\n                           String pathLabelText,\n                           final String pathChooserTitle,\n                           final String pathChooserDescription,\n                           boolean hideIgnored,\n                           boolean bold) {\n    super(new GridBagLayout());\n\n    myTfName = new JTextField();\n    myTfName.setDocument(new NameFieldDocument());\n    myTfName.setPreferredSize(new Dimension(200, myTfName.getPreferredSize().height));\n\n    myTfPath = new JTextField();\n    myTfPath.setDocument(new PathFieldDocument());\n    myTfPath.setPreferredSize(new Dimension(200, myTfPath.getPreferredSize().height));\n\n    myNameLabel = new JLabel(nameLabelText);\n    if (bold) myNameLabel.setFont(UIUtil.getLabelFont().deriveFont(Font.BOLD));\n    myNameLabel.setLabelFor(myTfName);\n    Insets insets = new Insets(0, 0, 5, 0);\n    this.add(myNameLabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                                 insets, 0, 0));\n\n    this.add(myTfName, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                              insets, 0, 0));\n    // todo: review texts\n    final FileChooserDescriptor chooserDescriptor = (FileChooserDescriptor)BrowseFilesListener.SINGLE_DIRECTORY_DESCRIPTOR.clone();\n    chooserDescriptor.setHideIgnored(hideIgnored);\n    final BrowseFilesListener browseButtonActionListener = new BrowseFilesListener(myTfPath, pathChooserTitle, pathChooserDescription, chooserDescriptor) {\n      public void actionPerformed(ActionEvent e) {\n        super.actionPerformed(e);\n        myIsPathChangedByUser = true;\n      }\n    };\n    myPathPanel = new FieldPanel(myTfPath, null, null, browseButtonActionListener, null);\n    final JLabel locationLabel = new JLabel(pathLabelText);\n    locationLabel.setLabelFor(myTfPath);\n    if (bold) locationLabel.setFont(UIUtil.getLabelFont().deriveFont(Font.BOLD));\n    this.add(locationLabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                                   insets, 0, 0));\n    this.add(myPathPanel, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                                 insets, 0, 0));\n  }","id":77826,"modified_method":"public NamePathComponent(String nameLabelText,\n                           String pathLabelText,\n                           final String pathChooserTitle,\n                           final String pathChooserDescription,\n                           boolean hideIgnored,\n                           boolean bold) {\n    super(new GridBagLayout());\n\n    myTfName = new JTextField();\n    myTfName.setDocument(new NameFieldDocument());\n    myTfName.setPreferredSize(new Dimension(200, myTfName.getPreferredSize().height));\n\n    myTfPath = new JTextField();\n    myTfPath.setDocument(new PathFieldDocument());\n    myTfPath.setPreferredSize(new Dimension(200, myTfPath.getPreferredSize().height));\n\n    myNameLabel = new JLabel(nameLabelText);\n    if (bold) myNameLabel.setFont(UIUtil.getLabelFont().deriveFont(Font.BOLD));\n    myNameLabel.setLabelFor(myTfName);\n    Insets insets = new Insets(0, 0, 5, 0);\n    this.add(myNameLabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                                 insets, 0, 0));\n\n    this.add(myTfName, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                              insets, 0, 0));\n    // todo: review texts\n    final FileChooserDescriptor chooserDescriptor = (FileChooserDescriptor)BrowseFilesListener.SINGLE_DIRECTORY_DESCRIPTOR.clone();\n    chooserDescriptor.setHideIgnored(hideIgnored);\n    final BrowseFilesListener browseButtonActionListener = new BrowseFilesListener(myTfPath, pathChooserTitle, pathChooserDescription, chooserDescriptor) {\n      public void actionPerformed(ActionEvent e) {\n        super.actionPerformed(e);\n        myIsPathChangedByUser = true;\n      }\n    };\n    myPathPanel = new FieldPanel(myTfPath, null, null, browseButtonActionListener, null);\n    myPathLabel = new JLabel(pathLabelText);\n    myPathLabel.setLabelFor(myTfPath);\n    if (bold) myPathLabel.setFont(UIUtil.getLabelFont().deriveFont(Font.BOLD));\n    this.add(myPathLabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                                   insets, 0, 0));\n    this.add(myPathPanel, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                                 insets, 0, 0));\n  }","commit_id":"b1f72375aca63655be2783bc858657819b173ede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void parseFields()\n    {\n        _lastCookies=null;\n        _cookies=null;\n        \n        Object cookies = null;\n\n        int version = 0;\n\n        // delete excess fields\n        while (LazyList.size(_lazyFields)>_fields)\n            _lazyFields=LazyList.remove(_lazyFields,_fields);\n        \n        // For each cookie field\n        for (int f=0;f<_fields;f++)\n        {\n            String hdr = LazyList.get(_lazyFields,f);\n            \n            // Parse the header\n            String name = null;\n            String value = null;\n\n            Cookie cookie = null;\n\n            byte state = STATE_NAME;\n            for (int i = 0, tokenstart = 0, length = hdr.length(); i < length; i++)\n            {\n                char c = hdr.charAt(i);\n                switch (c)\n                {\n                    case ',':\n                    case ';':\n                        switch (state)\n                        {\n                            case STATE_DELIMITER:\n                                state = STATE_NAME;\n                                tokenstart = i + 1;\n                                break;\n                            case STATE_UNQUOTED_VALUE:\n                                state = STATE_NAME;\n                                value = hdr.substring(tokenstart, i).trim();\n                                tokenstart = i + 1;\n                                break;\n                            case STATE_NAME:\n                                name = hdr.substring(tokenstart, i);\n                                value = \"\";\n                                tokenstart = i + 1;\n                                break;\n                            case STATE_VALUE:\n                                state = STATE_NAME;\n                                value = \"\";\n                                tokenstart = i + 1;\n                                break;\n                        }\n                        break;\n                    case '=':\n                        switch (state)\n                        {\n                            case STATE_NAME:\n                                state = STATE_VALUE;\n                                name = hdr.substring(tokenstart, i);\n                                tokenstart = i + 1;\n                                break;\n                            case STATE_VALUE:\n                                state = STATE_UNQUOTED_VALUE;\n                                tokenstart = i;\n                                break;\n                        }\n                        break;\n                    case '\"':\n                        switch (state)\n                        {\n                            case STATE_VALUE:\n                                state = STATE_QUOTED_VALUE;\n                                tokenstart = i + 1;\n                                break;\n                            case STATE_QUOTED_VALUE:\n                                state = STATE_DELIMITER;\n                                value = hdr.substring(tokenstart, i);\n                                break;\n                        }\n                        break;\n                    case ' ':\n                    case '\\t':\n                        break;\n                    default:\n                        switch (state)\n                        {\n                            case STATE_VALUE:\n                                state = STATE_UNQUOTED_VALUE;\n                                tokenstart = i;\n                                break;\n                            case STATE_DELIMITER:\n                                state = STATE_NAME;\n                                tokenstart = i;\n                                break;\n                        }\n                }\n\n                if (i + 1 == length)\n                {\n                    switch (state)\n                    {\n                        case STATE_UNQUOTED_VALUE:\n                            value = hdr.substring(tokenstart).trim();\n                            break;\n                        case STATE_NAME:\n                            name = hdr.substring(tokenstart);\n                            value = \"\";\n                            break;\n                        case STATE_VALUE:\n                            value = \"\";\n                            break;\n                    }\n                }\n\n                if (name != null && value != null)\n                {\n                    name = name.trim();\n\n                    try\n                    {\n                        if (name.startsWith(\"$\"))\n                        {\n                            String lowercaseName = name.toLowerCase();\n                            if (\"$path\".equals(lowercaseName))\n                            {\n                                cookie.setPath(value);\n                            }\n                            else if (\"$domain\".equals(lowercaseName))\n                            {\n                                cookie.setDomain(value);\n                            }\n                            else if (\"$version\".equals(lowercaseName))\n                            {\n                                version = Integer.parseInt(value);\n                            }\n                        }\n                        else\n                        {\n                            cookie = new Cookie(name, value);\n\n                            if (version > 0)\n                            {\n                                cookie.setVersion(version);\n                            }\n\n                            cookies = LazyList.add(cookies, cookie);\n                        }\n                    }\n                    catch (Exception e)\n                    {\n                        Log.ignore(e);\n                    }\n\n                    name = null;\n                    value = null;\n                }\n            }\n        }\n\n        _cookies = (Cookie[]) LazyList.toArray(cookies,Cookie.class);\n        _lastCookies=_cookies;\n    }","id":77827,"modified_method":"protected void parseFields()\n    {\n        _lastCookies=null;\n        _cookies=null;\n        \n        Object cookies = null;\n\n        int version = 0;\n\n        // delete excess fields\n        while (LazyList.size(_lazyFields)>_fields)\n            _lazyFields=LazyList.remove(_lazyFields,_fields);\n        \n        // For each cookie field\n        for (int f=0;f<_fields;f++)\n        {\n            String hdr = LazyList.get(_lazyFields,f);\n            \n            // Parse the header\n            String name = null;\n            String value = null;\n\n            Cookie cookie = null;\n\n            boolean invalue=false;\n            boolean quoted=false;\n            boolean escaped=false;\n            int tokenstart=-1;\n            int tokenend=-1;\n            for (int i = 0, length = hdr.length(), last=length-1; i < length; i++)\n            {\n                char c = hdr.charAt(i);\n                \n                // Handle quoted values for name or value\n                if (quoted)\n                {\n                    if (escaped)\n                    {\n                        escaped=false;\n                        continue;\n                    }\n                    \n                    switch (c)\n                    {\n                        case '\"':\n                            tokenend=i;\n                            quoted=false;\n\n                            // handle quote as last character specially\n                            if (i==last)\n                            {\n                                if (invalue)\n                                    value = hdr.substring(tokenstart, tokenend+1);\n                                else\n                                {\n                                    name = hdr.substring(tokenstart, tokenend+1);\n                                    value = \"\";\n                                }\n                            }\n                            break;\n                            \n                        case '\\\\':\n                            escaped=true;\n                            continue;\n                        default:\n                            continue;\n                    }\n                }\n                else\n                {\n                    // Handle name and value state machines\n                    if (invalue)\n                    {\n                        // parse the value\n                        switch (c)\n                        {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                                \n                            case '\"':\n                                if (tokenstart<0)\n                                {\n                                    quoted=true;\n                                    tokenstart=i;\n                                }\n                                tokenend=i;\n                                if (i==last)\n                                {\n                                    value = hdr.substring(tokenstart, tokenend+1);\n                                    break;\n                                }\n                                continue;\n\n                            case ';':\n                                if (tokenstart>=0)\n                                    value = hdr.substring(tokenstart, tokenend+1);\n                                else\n                                    value=\"\";\n                                tokenstart = -1;\n                                invalue=false;\n                                break;\n                                \n                            default:\n                                if (tokenstart<0)\n                                    tokenstart=i;\n                                tokenend=i;\n                                if (i==last)\n                                {\n                                    value = hdr.substring(tokenstart, tokenend+1);\n                                    break;\n                                }\n                                continue;\n                        }\n                    }\n                    else\n                    {\n                        // parse the name\n                        switch (c)\n                        {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                                \n                            case '\"':\n                                if (tokenstart<0)\n                                {\n                                    quoted=true;\n                                    tokenstart=i;\n                                }\n                                tokenend=i;\n                                if (i==last)\n                                {\n                                    name = hdr.substring(tokenstart, tokenend+1);\n                                    value = \"\";\n                                    break;\n                                }\n                                continue;\n\n                            case ';':\n                                if (tokenstart>=0)\n                                {\n                                    name = hdr.substring(tokenstart, tokenend+1);\n                                    value = \"\";\n                                }\n                                tokenstart = -1;\n                                break;\n\n                            case '=':\n                                if (tokenstart>=0)\n                                    name = hdr.substring(tokenstart, tokenend+1);\n                                tokenstart = -1;\n                                invalue=true;\n                                continue;\n                                \n                            default:\n                                if (tokenstart<0)\n                                    tokenstart=i;\n                                tokenend=i;\n                                if (i==last)\n                                {\n                                    name = hdr.substring(tokenstart, tokenend+1);\n                                    value = \"\";\n                                    break;\n                                }\n                                continue;\n                        }\n                    }\n                }\n\n                // If after processing the current character we have a value and a name, then it is a cookie\n                if (value!=null && name!=null)\n                {\n                    // TODO handle unquoting during parsing!  But quoting is uncommon\n                    name=QuotedStringTokenizer.unquote(name);\n                    value=QuotedStringTokenizer.unquote(value);\n                    \n                    try\n                    {\n                        if (name.startsWith(\"$\"))\n                        {\n                            String lowercaseName = name.toLowerCase();\n                            if (\"$path\".equals(lowercaseName))\n                            {\n                                if (cookie!=null)\n                                    cookie.setPath(value);\n                            }\n                            else if (\"$domain\".equals(lowercaseName))\n                            {\n                                if (cookie!=null)\n                                    cookie.setDomain(value);\n                            }\n                            else if (\"$version\".equals(lowercaseName))\n                            {\n                                version = Integer.parseInt(value);\n                            }\n                        }\n                        else\n                        {\n                            cookie = new Cookie(name, value);\n                            if (version > 0)\n                                cookie.setVersion(version);\n                            cookies = LazyList.add(cookies, cookie);\n                        }\n                    }\n                    catch (Exception e)\n                    {\n                        Log.warn(e.toString());\n                        Log.debug(e);\n                    }\n\n                    name = null;\n                    value = null;\n                }\n            }\n        }\n\n        _cookies = (Cookie[]) LazyList.toArray(cookies,Cookie.class);\n        _lastCookies=_cookies;\n    }","commit_id":"18c97123630b37d9275f00e001f9cd83a21fe90c","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void testCookies() throws Exception\n    {\n        final ArrayList cookies = new ArrayList();\n\n        _handler._checker = new RequestTester()\n        {\n            public boolean check(HttpServletRequest request,HttpServletResponse response) throws IOException\n            {\n                javax.servlet.http.Cookie[] ca = request.getCookies();\n                if (ca!=null)\n                    cookies.addAll(Arrays.asList(ca));\n                response.getOutputStream().println(\"Hello World\");\n                return true;\n            }  \n        };\n\n        String response;\n        _connector.reopen();\n\n        cookies.clear();\n        response=_connector.getResponses(\n                    \"GET / HTTP/1.1\\n\"+\n                    \"Host: whatever\\n\"+\n                    \"\\n\"\n                    );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(0,cookies.size());\n        \n\n        cookies.clear();\n        response=_connector.getResponses(\n                    \"GET / HTTP/1.1\\n\"+\n                    \"Host: whatever\\n\"+\n                    \"Cookie: name=value\\n\" +\n                    \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(1,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"GET / HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(2,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"other\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"quoted=;value\",((Cookie)cookies.get(1)).getValue());\n\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"+\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(4,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"other\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"quoted=;value\",((Cookie)cookies.get(1)).getValue());\n\n        assertTrue((Cookie)cookies.get(0)==(Cookie)cookies.get(2));\n        assertTrue((Cookie)cookies.get(1)==(Cookie)cookies.get(3));\n\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"+\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"othervalue\\\"\\n\" +\n                \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(4,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"other\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"quoted=;value\",((Cookie)cookies.get(1)).getValue());\n\n        assertTrue((Cookie)cookies.get(0)!=(Cookie)cookies.get(2));\n        assertTrue((Cookie)cookies.get(1)!=(Cookie)cookies.get(3));\n\n        \n    }","id":77828,"modified_method":"public void testCookies() throws Exception\n    {\n        final ArrayList cookies = new ArrayList();\n\n        _handler._checker = new RequestTester()\n        {\n            public boolean check(HttpServletRequest request,HttpServletResponse response) throws IOException\n            {\n                javax.servlet.http.Cookie[] ca = request.getCookies();\n                if (ca!=null)\n                    cookies.addAll(Arrays.asList(ca));\n                response.getOutputStream().println(\"Hello World\");\n                return true;\n            }  \n        };\n\n        String response;\n        _connector.reopen();\n\n        cookies.clear();\n        response=_connector.getResponses(\n                    \"GET / HTTP/1.1\\n\"+\n                    \"Host: whatever\\n\"+\n                    \"\\n\"\n                    );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(0,cookies.size());\n        \n\n        cookies.clear();\n        response=_connector.getResponses(\n                    \"GET / HTTP/1.1\\n\"+\n                    \"Host: whatever\\n\"+\n                    \"Cookie: name=quoted=\\\\\\\"value\\\\\\\"\\n\" +\n                    \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(1,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"quoted=\\\\\\\"value\\\\\\\"\",((Cookie)cookies.get(0)).getValue());\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"GET / HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(2,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"other\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"quoted=;value\",((Cookie)cookies.get(1)).getValue());\n\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"+\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(4,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"other\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"quoted=;value\",((Cookie)cookies.get(1)).getValue());\n\n        assertTrue((Cookie)cookies.get(0)==(Cookie)cookies.get(2));\n        assertTrue((Cookie)cookies.get(1)==(Cookie)cookies.get(3));\n\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"quoted=;value\\\"\\n\" +\n                \"\\n\"+\n                \"GET /other HTTP/1.1\\n\"+\n                \"Host: whatever\\n\"+\n                \"Other: header\\n\"+\n                \"Cookie: name=value; other=\\\"othervalue\\\"\\n\" +\n                \"\\n\"\n        );\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        assertEquals(4,cookies.size());\n        assertEquals(\"name\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"other\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"quoted=;value\",((Cookie)cookies.get(1)).getValue());\n\n        assertTrue((Cookie)cookies.get(0)!=(Cookie)cookies.get(2));\n        assertTrue((Cookie)cookies.get(1)!=(Cookie)cookies.get(3));\n\n        cookies.clear();\n        response=_connector.getResponses(\n                \"POST / HTTP/1.1\\r\\n\"+\n                \"Host: whatever\\r\\n\"+\n                \"Cookie: name0=value0; name1 = value1 ; \\\"\\\\\\\"name2\\\\\\\"\\\"  =  \\\"\\\\\\\"value2\\\\\\\"\\\"  \\n\" +\n                \"Cookie: name3=value3=value3; name4=; name5 =  ; name6\\n\" +\n                \"Cookie: name7=value7;\\n\" +\n                \"Connection: close\\r\\n\"+\n        \"\\r\\n\");\n\n        assertEquals(\"name0\",((Cookie)cookies.get(0)).getName());\n        assertEquals(\"value0\",((Cookie)cookies.get(0)).getValue());\n        assertEquals(\"name1\",((Cookie)cookies.get(1)).getName());\n        assertEquals(\"value1\",((Cookie)cookies.get(1)).getValue());\n        assertEquals(\"\\\"name2\\\"\",((Cookie)cookies.get(2)).getName());\n        assertEquals(\"\\\"value2\\\"\",((Cookie)cookies.get(2)).getValue());\n        assertEquals(\"name3\",((Cookie)cookies.get(3)).getName());\n        assertEquals(\"value3=value3\",((Cookie)cookies.get(3)).getValue());\n        assertEquals(\"name4\",((Cookie)cookies.get(4)).getName());\n        assertEquals(\"\",((Cookie)cookies.get(4)).getValue());\n        assertEquals(\"name5\",((Cookie)cookies.get(5)).getName());\n        assertEquals(\"\",((Cookie)cookies.get(5)).getValue());\n        assertEquals(\"name6\",((Cookie)cookies.get(6)).getName());\n        assertEquals(\"\",((Cookie)cookies.get(6)).getValue());\n        assertEquals(\"name7\",((Cookie)cookies.get(7)).getName());\n        assertEquals(\"value7\",((Cookie)cookies.get(7)).getValue());\n        \n    }","commit_id":"18c97123630b37d9275f00e001f9cd83a21fe90c","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    myProvider.doCheckout();\n  }","id":77829,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(DataKeys.PROJECT);\n    myProvider.doCheckout(new MyListener(project));\n  }","commit_id":"7d31c2e5b47f904667a60f5c9120051882b78a2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = getProject(e);\n    if (project == null) {\n      return;\n    }\n    final AddModuleWizard wizard = new AddModuleWizard(project, new DefaultModulesProvider(project));\n\n    wizard.show();\n\n    if (wizard.isOK()) {\n      final ModuleBuilder moduleBuilder = wizard.getModuleBuilder();\n      Exception ex = ApplicationManager.getApplication().runWriteAction(new Computable<Exception>() {\n        public Exception compute() {\n          try {\n            final ModifiableModuleModel moduleModel = ModuleManager.getInstance(project).getModifiableModel();\n            moduleBuilder.createAndCommit(moduleModel, false);\n            return null;\n          }\n          catch (Exception e) {\n            return e;\n          }\n        }\n      });\n\n      if (ex != null) {\n        if (ex instanceof LoadCancelledException) {\n          LoadCancelledException cancelled = (LoadCancelledException)ex;\n          Messages.showInfoMessage(\n            ProjectBundle.message(\"module.new.creation.cancelled.message\", cancelled.getIssuer().getComponentName(), cancelled.getMessage()),\n            ProjectBundle.message(\"module.new.creation.cancelled.title\"));\n        } else {\n          Messages.showErrorDialog(ProjectBundle.message(\"module.new.error.message\", ex.getMessage()),\n                                   ProjectBundle.message(\"module.new.error.title\"));\n        }\n      }\n    }\n  }","id":77830,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = getProject(e);\n    if (project == null) {\n      return;\n    }\n    final AddModuleWizard wizard = new AddModuleWizard(project, new DefaultModulesProvider(project), null);\n\n    wizard.show();\n\n    if (wizard.isOK()) {\n      final ModuleBuilder moduleBuilder = wizard.getModuleBuilder();\n      Exception ex = ApplicationManager.getApplication().runWriteAction(new Computable<Exception>() {\n        public Exception compute() {\n          try {\n            final ModifiableModuleModel moduleModel = ModuleManager.getInstance(project).getModifiableModel();\n            moduleBuilder.createAndCommit(moduleModel, false);\n            return null;\n          }\n          catch (Exception e) {\n            return e;\n          }\n        }\n      });\n\n      if (ex != null) {\n        if (ex instanceof LoadCancelledException) {\n          LoadCancelledException cancelled = (LoadCancelledException)ex;\n          Messages.showInfoMessage(\n            ProjectBundle.message(\"module.new.creation.cancelled.message\", cancelled.getIssuer().getComponentName(), cancelled.getMessage()),\n            ProjectBundle.message(\"module.new.creation.cancelled.title\"));\n        } else {\n          Messages.showErrorDialog(ProjectBundle.message(\"module.new.error.message\", ex.getMessage()),\n                                   ProjectBundle.message(\"module.new.error.title\"));\n        }\n      }\n    }\n  }","commit_id":"7d31c2e5b47f904667a60f5c9120051882b78a2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    ProjectUtil.createNewProject((Project)e.getDataContext().getData(DataConstants.PROJECT));\n  }","id":77831,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    ProjectUtil.createNewProject((Project)e.getDataContext().getData(DataConstants.PROJECT), null);\n  }","commit_id":"7d31c2e5b47f904667a60f5c9120051882b78a2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProjectNameStep(WizardContext wizardContext) {\n    myWizardContext = wizardContext;\n    myNamePathComponent = new NamePathComponent(IdeBundle.message(\"label.project.name\"), IdeBundle.message(\"label.project.file.location\"), 'a', 'l',\n                                                IdeBundle.message(\"title.select.project.file.directory\"), IdeBundle.message(\"description.select.project.file.directory\"));\n\n    final String projectsStorePath = getDefaultProjectsStorePath();\n    //noinspection HardCodedStringLiteral\n    final String initialProjectName = ProjectWizardUtil.findNonExistingFileName(projectsStorePath, \"untitled\", \"\");\n    myNamePathComponent.setPath(projectsStorePath + File.separator + initialProjectName);\n    myNamePathComponent.setNameValue(initialProjectName);\n\n    myPanel = new JPanel(new GridBagLayout());\n    myPanel.setBorder(BorderFactory.createEtchedBorder());\n\n    ApplicationInfo info = ApplicationManager.getApplication().getComponent(ApplicationInfo.class);\n    String appName = info.getVersionName();\n    myPanel.add(new JLabel(IdeBundle.message(\"label.please.enter.project.name\", appName)),\n                new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(8, 10, 8, 10), 0, 0));\n\n    myPanel.add(myNamePathComponent, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(8, 10, 8, 10), 0, 0));\n  }","id":77832,"modified_method":"public ProjectNameStep(WizardContext wizardContext) {\n    myWizardContext = wizardContext;\n    myNamePathComponent = new NamePathComponent(IdeBundle.message(\"label.project.name\"), IdeBundle.message(\"label.project.file.location\"), 'a', 'l',\n                                                IdeBundle.message(\"title.select.project.file.directory\"), IdeBundle.message(\"description.select.project.file.directory\"));\n\n    if (myWizardContext.getProjectFileDirectory() != null) {\n      myNamePathComponent.setPath(myWizardContext.getProjectFileDirectory());\n      List<String> components = StringUtil.split(myWizardContext.getProjectFileDirectory(), File.separator);\n      if (components.size() > 0) {\n        myNamePathComponent.setNameValue(components.get(components.size()-1));\n      }\n    }\n    else {\n      final String projectsStorePath = getDefaultProjectsStorePath();\n      //noinspection HardCodedStringLiteral\n      final String initialProjectName = ProjectWizardUtil.findNonExistingFileName(projectsStorePath, \"untitled\", \"\");\n      myNamePathComponent.setPath(projectsStorePath + File.separator + initialProjectName);\n      myNamePathComponent.setNameValue(initialProjectName);\n    }\n\n    myPanel = new JPanel(new GridBagLayout());\n    myPanel.setBorder(BorderFactory.createEtchedBorder());\n\n    ApplicationInfo info = ApplicationManager.getApplication().getComponent(ApplicationInfo.class);\n    String appName = info.getVersionName();\n    myPanel.add(new JLabel(IdeBundle.message(\"label.please.enter.project.name\", appName)),\n                new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(8, 10, 8, 10), 0, 0));\n\n    myPanel.add(myNamePathComponent, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(8, 10, 8, 10), 0, 0));\n  }","commit_id":"7d31c2e5b47f904667a60f5c9120051882b78a2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void createNewProject(Project projectToClose) {\n    AddModuleWizard dialog = new AddModuleWizard(null, ModulesProvider.EMPTY_MODULES_PROVIDER);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return;\n    }\n\n    final ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    final String projectFilePath = dialog.getNewProjectFilePath();\n\n    final Project newProject = projectManager.newProject(projectFilePath, true, false);\n\n    final ProjectJdk jdk = dialog.getNewProjectJdk();\n    if (jdk != null) {\n      final String versionString = jdk.getVersionString();\n      if (versionString != null) { //jdk is valid\n        CommandProcessor.getInstance().executeCommand(newProject, new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                final ProjectRootManagerEx projectRootManager = (ProjectRootManagerEx)ProjectRootManager.getInstance(newProject);\n                projectRootManager.setProjectJdk(jdk);\n                projectRootManager.setLanguageLevel(getDefaultLanguageLevel(versionString));\n              }\n            });\n          }\n        }, null, null);\n      }\n    }\n\n    final String compileOutput = dialog.getNewCompileOutput();\n    if (compileOutput != null){\n      CommandProcessor.getInstance().executeCommand(newProject, new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              final ProjectRootManagerEx projectRootManager = (ProjectRootManagerEx)ProjectRootManager.getInstance(newProject);\n              String canonicalPath = compileOutput;\n              try {\n                canonicalPath = FileUtil.resolveShortWindowsName(compileOutput);\n              }\n              catch (IOException e) {\n                //file doesn't exist\n              }\n              canonicalPath = FileUtil.toSystemIndependentName(canonicalPath);\n              projectRootManager.setCompilerOutputUrl(VfsUtil.pathToUrl(canonicalPath));\n            }\n          });\n        }\n      }, null, null);\n    }\n\n    newProject.save();\n\n    Project[] openProjects = ProjectManager.getInstance().getOpenProjects();\n    if (openProjects.length > 0) {\n      int exitCode = Messages.showDialog(\n        IdeBundle.message(\"prompt.open.project.in.new.frame\"),\n        IdeBundle.message(\"title.new.project\"),\n        new String[]{IdeBundle.message(\"button.yes\"), IdeBundle.message(\"button.no\")},\n        1,\n        Messages.getQuestionIcon()\n      );\n      if (exitCode == 1) { // \"No\" option\n        closeProject(projectToClose != null ? projectToClose : openProjects[openProjects.length - 1]);\n      }\n    }\n\n    final ModuleBuilder moduleBuilder = dialog.getModuleBuilder();\n    if (moduleBuilder != null) {\n      Exception ex = ApplicationManager.getApplication().runWriteAction(new Computable<Exception>() {\n        public Exception compute() {\n          try {\n            final ModifiableModuleModel moduleModel = ModuleManager.getInstance(newProject).getModifiableModel();\n            moduleBuilder.createAndCommit(moduleModel, true);\n            return null;\n          }\n          catch (Exception e) {\n            return e;\n          }\n        }\n      });\n      if (ex != null) {\n        Messages.showErrorDialog(IdeBundle.message(\"error.adding.module.to.project\", ex.getMessage()),\n                                 IdeBundle.message(\"title.add.module\"));\n      }\n    }\n\n    StartupManager.getInstance(newProject).registerPostStartupActivity(new Runnable() {\n      public void run() {\n        // ensure the dialog is shown after all startup activities are done\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            final ToolWindow toolWindow = ToolWindowManager.getInstance(newProject).getToolWindow(ToolWindowId.PROJECT_VIEW);\n            if (toolWindow != null) {\n              toolWindow.activate(null);\n            }\n            if (moduleBuilder == null) {\n              ModulesConfigurator.showDialog(newProject, null, null, true);\n            }\n          }\n        });\n      }\n    });\n\n    updateLastProjectLocation(projectFilePath);\n\n    projectManager.openProject(newProject);\n  }","id":77833,"modified_method":"public static void createNewProject(Project projectToClose, @Nullable final String defaultPath) {\n    AddModuleWizard dialog = new AddModuleWizard(null, ModulesProvider.EMPTY_MODULES_PROVIDER, defaultPath);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return;\n    }\n\n    final ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    final String projectFilePath = dialog.getNewProjectFilePath();\n\n    final Project newProject = projectManager.newProject(projectFilePath, true, false);\n\n    final ProjectJdk jdk = dialog.getNewProjectJdk();\n    if (jdk != null) {\n      final String versionString = jdk.getVersionString();\n      if (versionString != null) { //jdk is valid\n        CommandProcessor.getInstance().executeCommand(newProject, new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                final ProjectRootManagerEx projectRootManager = (ProjectRootManagerEx)ProjectRootManager.getInstance(newProject);\n                projectRootManager.setProjectJdk(jdk);\n                projectRootManager.setLanguageLevel(getDefaultLanguageLevel(versionString));\n              }\n            });\n          }\n        }, null, null);\n      }\n    }\n\n    final String compileOutput = dialog.getNewCompileOutput();\n    if (compileOutput != null){\n      CommandProcessor.getInstance().executeCommand(newProject, new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              final ProjectRootManagerEx projectRootManager = (ProjectRootManagerEx)ProjectRootManager.getInstance(newProject);\n              String canonicalPath = compileOutput;\n              try {\n                canonicalPath = FileUtil.resolveShortWindowsName(compileOutput);\n              }\n              catch (IOException e) {\n                //file doesn't exist\n              }\n              canonicalPath = FileUtil.toSystemIndependentName(canonicalPath);\n              projectRootManager.setCompilerOutputUrl(VfsUtil.pathToUrl(canonicalPath));\n            }\n          });\n        }\n      }, null, null);\n    }\n\n    newProject.save();\n\n    Project[] openProjects = ProjectManager.getInstance().getOpenProjects();\n    if (openProjects.length > 0) {\n      int exitCode = Messages.showDialog(\n        IdeBundle.message(\"prompt.open.project.in.new.frame\"),\n        IdeBundle.message(\"title.new.project\"),\n        new String[]{IdeBundle.message(\"button.yes\"), IdeBundle.message(\"button.no\")},\n        1,\n        Messages.getQuestionIcon()\n      );\n      if (exitCode == 1) { // \"No\" option\n        closeProject(projectToClose != null ? projectToClose : openProjects[openProjects.length - 1]);\n      }\n    }\n\n    final ModuleBuilder moduleBuilder = dialog.getModuleBuilder();\n    if (moduleBuilder != null) {\n      Exception ex = ApplicationManager.getApplication().runWriteAction(new Computable<Exception>() {\n        public Exception compute() {\n          try {\n            final ModifiableModuleModel moduleModel = ModuleManager.getInstance(newProject).getModifiableModel();\n            moduleBuilder.createAndCommit(moduleModel, true);\n            return null;\n          }\n          catch (Exception e) {\n            return e;\n          }\n        }\n      });\n      if (ex != null) {\n        Messages.showErrorDialog(IdeBundle.message(\"error.adding.module.to.project\", ex.getMessage()),\n                                 IdeBundle.message(\"title.add.module\"));\n      }\n    }\n\n    StartupManager.getInstance(newProject).registerPostStartupActivity(new Runnable() {\n      public void run() {\n        // ensure the dialog is shown after all startup activities are done\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            final ToolWindow toolWindow = ToolWindowManager.getInstance(newProject).getToolWindow(ToolWindowId.PROJECT_VIEW);\n            if (toolWindow != null) {\n              toolWindow.activate(null);\n            }\n            if (moduleBuilder == null) {\n              ModulesConfigurator.showDialog(newProject, null, null, true);\n            }\n          }\n        });\n      }\n    });\n\n    updateLastProjectLocation(projectFilePath);\n\n    projectManager.openProject(newProject);\n  }","commit_id":"7d31c2e5b47f904667a60f5c9120051882b78a2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addDefaultQuickStartActions(final ActionGroupDescriptor quickStarts, final ActionManager actionManager) {\n    MyActionButton newProject = new MyActionButton(NEW_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e) {\n        ProjectUtil.createNewProject(null);\n      }\n    };\n    quickStarts.addButton(newProject, UIBundle.message(\"welcome.screen.create.new.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.create.new.project.action.description\"));\n\n    MyActionButton openProject = new ButtonWithExtension(OPEN_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final AnAction action = new OpenProjectAction();\n        action.actionPerformed(new AnActionEvent(e, new DataContext() {\n          public Object getData(String dataId) {\n            if (DataConstants.PROJECT.equals(dataId)) {\n              return null;\n            }\n            return button;\n          }\n        }, ActionPlaces.UNKNOWN, new PresentationFactory().getPresentation(action), actionManager, 0));\n      }\n    };\n\n    quickStarts.addButton(openProject, UIBundle.message(\"welcome.screen.open.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.open.project.action.description\", ApplicationNamesInfo.getInstance().getFullProductName()));\n\n    MyActionButton openRecentProject = new ButtonWithExtension(REOPEN_RECENT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final AnAction action = new RecentProjectsAction();\n        action.actionPerformed(new AnActionEvent(e, new DataContext() {\n          public Object getData(String dataId) {\n            if (DataConstants.PROJECT.equals(dataId)) {\n              return null;\n            }\n            return button;\n          }\n        }, ActionPlaces.UNKNOWN, new PresentationFactory().getPresentation(action), actionManager, 0));\n      }\n    };\n    quickStarts.addButton(openRecentProject, UIBundle.message(\"welcome.screen.reopen.recent.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.reopen.recent.project.action.description\"));\n\n    MyActionButton getFromVCS = new ButtonWithExtension(FROM_VCS_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final GetFromVcsAction action = new GetFromVcsAction();\n        action.actionPerformed(button, e);\n      }\n    };\n\n    quickStarts.addButton(getFromVCS, UIBundle.message(\"welcome.screen.check.out.from.version.control.action.name\"),\n                          UIBundle.message(\"welcome.screen.check.out.from.version.control.action.description\"));\n\n    /*\n    MyActionButton checkForUpdate = new MyActionButton (CHECK_FOR_UPDATE_ICON, null) {\n      protected void onPress(InputEvent e) {\n        CheckForUpdateAction.actionPerformed(true);\n      }\n    };\n\n    quickStarts.addButton(checkForUpdate, \"Check for Update\", ApplicationNamesInfo.getInstance().getFullProductName() +\n                                                              \" will check for a new available update of itself, \" +\n                                                              \"using your internet connection.\");\n    */\n  }","id":77834,"modified_method":"private void addDefaultQuickStartActions(final ActionGroupDescriptor quickStarts, final ActionManager actionManager) {\n    MyActionButton newProject = new MyActionButton(NEW_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e) {\n        ProjectUtil.createNewProject(null, null);\n      }\n    };\n    quickStarts.addButton(newProject, UIBundle.message(\"welcome.screen.create.new.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.create.new.project.action.description\"));\n\n    MyActionButton openProject = new ButtonWithExtension(OPEN_PROJECT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final AnAction action = new OpenProjectAction();\n        action.actionPerformed(new AnActionEvent(e, new DataContext() {\n          public Object getData(String dataId) {\n            if (DataConstants.PROJECT.equals(dataId)) {\n              return null;\n            }\n            return button;\n          }\n        }, ActionPlaces.UNKNOWN, new PresentationFactory().getPresentation(action), actionManager, 0));\n      }\n    };\n\n    quickStarts.addButton(openProject, UIBundle.message(\"welcome.screen.open.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.open.project.action.description\", ApplicationNamesInfo.getInstance().getFullProductName()));\n\n    MyActionButton openRecentProject = new ButtonWithExtension(REOPEN_RECENT_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final AnAction action = new RecentProjectsAction();\n        action.actionPerformed(new AnActionEvent(e, new DataContext() {\n          public Object getData(String dataId) {\n            if (DataConstants.PROJECT.equals(dataId)) {\n              return null;\n            }\n            return button;\n          }\n        }, ActionPlaces.UNKNOWN, new PresentationFactory().getPresentation(action), actionManager, 0));\n      }\n    };\n    quickStarts.addButton(openRecentProject, UIBundle.message(\"welcome.screen.reopen.recent.project.action.name\"),\n                          UIBundle.message(\"welcome.screen.reopen.recent.project.action.description\"));\n\n    MyActionButton getFromVCS = new ButtonWithExtension(FROM_VCS_ICON, null) {\n      protected void onPress(InputEvent e, final MyActionButton button) {\n        final GetFromVcsAction action = new GetFromVcsAction();\n        action.actionPerformed(button, e);\n      }\n    };\n\n    quickStarts.addButton(getFromVCS, UIBundle.message(\"welcome.screen.check.out.from.version.control.action.name\"),\n                          UIBundle.message(\"welcome.screen.check.out.from.version.control.action.description\"));\n\n    /*\n    MyActionButton checkForUpdate = new MyActionButton (CHECK_FOR_UPDATE_ICON, null) {\n      protected void onPress(InputEvent e) {\n        CheckForUpdateAction.actionPerformed(true);\n      }\n    };\n\n    quickStarts.addButton(checkForUpdate, \"Check for Update\", ApplicationNamesInfo.getInstance().getFullProductName() +\n                                                              \" will check for a new available update of itself, \" +\n                                                              \"using your internet connection.\");\n    */\n  }","commit_id":"7d31c2e5b47f904667a60f5c9120051882b78a2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Solution addProjectSolution(@NotNull File solutionDescriptionFile) {\n    ProjectDescriptor projectDescriptor = getProjectDescriptor();\n    SModel model = projectDescriptor.getModel();\n    model.setLoading(true);\n    SolutionPath solutionPath = new SolutionPath(model);\n    solutionPath.setPath(solutionDescriptionFile.getAbsolutePath());\n    projectDescriptor.addProjectSolution(solutionPath);\n    setProjectDescriptor(projectDescriptor);\n    myEventTranslator.projectChanged();\n\n    for (Solution s : getProjectSolutions()) {\n      File descriptorFile = s.getDescriptorFile();\n      assert descriptorFile != null;\n      if (descriptorFile.getAbsolutePath().equals(solutionDescriptionFile.getAbsolutePath())) {\n        return s;\n      }\n    }\n\n    throw new RuntimeException(\"it can't happen\");\n  }","id":77835,"modified_method":"@NotNull\n  public Solution addProjectSolution(@NotNull File solutionDescriptionFile) {\n    ProjectDescriptor projectDescriptor = getProjectDescriptor();\n    SModel model = projectDescriptor.getModel();\n    model.setLoading(true);\n\n    SolutionPath solutionPath = null;\n    for (SolutionPath p : getProjectDescriptor().getProjectSolutions()) {\n      if (p.getPath().equals(solutionDescriptionFile.getPath())) {\n        solutionPath = p;\n        break;\n      }\n    }\n\n    if (solutionPath == null) {\n      solutionPath = new SolutionPath(model);\n      solutionPath.setPath(solutionDescriptionFile.getAbsolutePath());\n      projectDescriptor.addProjectSolution(solutionPath);\n    }\n\n    setProjectDescriptor(projectDescriptor);\n\n    for (Solution s : getProjectSolutions()) {\n      File descriptorFile = s.getDescriptorFile();\n      assert descriptorFile != null;\n      if (descriptorFile.getAbsolutePath().equals(solutionDescriptionFile.getAbsolutePath())) {\n        return s;\n      }\n    }\n\n    throw new RuntimeException(\"it can't happen\");\n  }","commit_id":"00c110a814ebf7b007f525531f03b5e286ca7498","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected void handleOperation(SlingHttpServletRequest request,\n            HtmlResponse response, List<Modification> changes)\n            throws RepositoryException {\n      \n\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n        String principalName = request.getParameter(SlingPostConstants.RP_NODE_NAME);\n        User user = createUser(session, \n                            principalName, \n                            request.getParameter(\"pwd\"),\n                            request.getParameter(\"pwdConfirm\"),\n                            request.getRequestParameterMap(), \n                            changes);\n        \n        String userPath = AuthorizableResourceProvider.SYSTEM_USER_MANAGER_USER_PREFIX\n                + user.getID();\n        response.setPath(userPath);\n        response.setLocation(externalizePath(request, userPath));\n        response.setParentLocation(externalizePath(request,\n            AuthorizableResourceProvider.SYSTEM_USER_MANAGER_USER_PATH));\n    }","id":77836,"modified_method":"@Override\n    protected void handleOperation(SlingHttpServletRequest request,\n            HtmlResponse response, List<Modification> changes)\n            throws RepositoryException {\n      \n\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n        String principalName = request.getParameter(SlingPostConstants.RP_NODE_NAME);\n        User user = createUser(session, \n                            principalName, \n                            request.getParameter(\"pwd\"),\n                            request.getParameter(\"pwdConfirm\"),\n                            request.getRequestParameterMap(), \n                            changes);\n        \n        String userPath = null;\n        if (user == null) {\n            if (changes.size() > 0) {\n                Modification modification = changes.get(0);\n                if (modification.getType() == ModificationType.CREATE) {\n                    userPath = modification.getSource();\n                }\n            }\n        } else {\n            userPath = AuthorizableResourceProvider.SYSTEM_USER_MANAGER_USER_PREFIX\n                    + user.getID();\n        }\n        \n        if (userPath != null) {\n            response.setPath(userPath);\n            response.setLocation(externalizePath(request, userPath));\n        }\n        response.setParentLocation(externalizePath(request,\n            AuthorizableResourceProvider.SYSTEM_USER_MANAGER_USER_PATH));\n    }","commit_id":"6ede039a59abe1c6ab6a572c904f1990b662f4c8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Constructor.<p>\n     *\n     * @param entry the access control entry\n     * @param editable the editable flag\n     * @param isFolder the is folder flag\n     * @param inheritedFrom the inherited from path\n     * @param changeHandler the change handler\n     */\n    public CmsPermissionView(\n        CmsAccessControlEntry entry,\n        boolean editable,\n        boolean isFolder,\n        String inheritedFrom,\n        PermissionChangeHandler changeHandler) {\n        m_changeHandler = changeHandler;\n        m_editable = editable;\n        m_entry = entry;\n        CmsVaadinUtils.readAndLocalizeDesign(this, null, null);\n        CmsObject cms = A_CmsUI.getCmsObject();\n        // get name and type of the current entry\n        I_CmsPrincipal principal;\n        try {\n            principal = CmsPrincipal.readPrincipalIncludingHistory(cms, entry.getPrincipal());\n        } catch (@SuppressWarnings(\"unused\") CmsException e) {\n            principal = null;\n        }\n\n        m_principalName = (principal != null) ? principal.getName() : entry.getPrincipal().toString();\n        String ou = null;\n        String displayName;\n\n        int flags = 0;\n        if ((principal != null) && (principal instanceof CmsHistoryPrincipal)) {\n            // there is a history principal entry, handle it\n            if (principal.isGroup()) {\n                String niceName = OpenCms.getWorkplaceManager().translateGroupName(principal.getName(), false);\n                displayName = CmsVaadinUtils.getMessageText(\n                    org.opencms.security.Messages.GUI_ORGUNIT_DISPLAY_NAME_2,\n                    ((CmsHistoryPrincipal)principal).getDescription(),\n                    niceName);\n                ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n            } else {\n                displayName = ((CmsHistoryPrincipal)principal).getName();\n                ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n            }\n        } else if ((principal != null) && principal.isGroup()) {\n            String niceName = OpenCms.getWorkplaceManager().translateGroupName(principal.getName(), false);\n            displayName = CmsVaadinUtils.getMessageText(\n                org.opencms.security.Messages.GUI_ORGUNIT_DISPLAY_NAME_2,\n                ((CmsGroup)principal).getDescription(A_CmsUI.get().getLocale()),\n                niceName);\n            ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n        } else if ((principal != null) && principal.isUser()) {\n            displayName = ((CmsUser)principal).getFullName();\n            ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n        } else if ((m_principalName != null)\n            && m_principalName.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n            m_principalName = CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME;\n            displayName = CmsVaadinUtils.getMessageText(Messages.GUI_LABEL_ALLOTHERS_0);\n            m_responsibleCheckbox.setVisible(false);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS;\n        } else if ((m_principalName != null)\n            && m_principalName.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n            m_principalName = CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_NAME;\n            displayName = CmsVaadinUtils.getMessageText(Messages.GUI_LABEL_OVERWRITEALL_0);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL;\n        } else {\n            // check if it is the case of a role\n            CmsRole role = CmsRole.valueOfId(entry.getPrincipal());\n            if (role != null) {\n                displayName = role.getName(A_CmsUI.get().getLocale());\n                m_principalName = role.getRoleName();\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_ROLE;\n            } else {\n                displayName = entry.getPrincipal().toString();\n            }\n        }\n\n        if ((flags > 0) && ((entry.getFlags() & flags) == 0)) {\n            // the flag is set to the wrong principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\n                    Messages.get().getBundle(A_CmsUI.get().getLocale()).key(\n                        Messages.ERR_INVALID_ACE_1,\n                        entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | flags));\n        } else if (entry.getFlags() < CmsAccessControlEntry.ACCESS_FLAGS_USER) {\n            // the flag is set to NO principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\n                    Messages.get().getBundle(A_CmsUI.get().getLocale()).key(\n                        Messages.ERR_INVALID_ACE_1,\n                        entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | CmsAccessControlEntry.ACCESS_FLAGS_GROUP));\n        }\n\n        m_principalType = getEntryType(entry.getFlags(), false);\n\n        if (m_principalName == null) {\n            m_principalName = \"\";\n        }\n\n        FontIcon icon = null;\n        switch (flags) {\n            case CmsAccessControlEntry.ACCESS_FLAGS_USER:\n                icon = FontAwesome.USER;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_GROUP:\n                icon = FontAwesome.GROUP;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS:\n                icon = FontAwesome.GLOBE;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_ROLE:\n                icon = FontAwesome.GRADUATION_CAP;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL:\n                icon = FontAwesome.EXCLAMATION_CIRCLE;\n                break;\n            default:\n                icon = FontAwesome.QUESTION_CIRCLE;\n        }\n\n        m_label.setContentMode(ContentMode.HTML);\n        m_label.setValue(\n            icon.getHtml() + \" <b>\" + displayName + \"<\/b> \" + entry.getPermissions().getPermissionString());\n        m_label.setWidthUndefined();\n        m_details.setIcon(FontAwesome.PLUS_SQUARE_O);\n        m_details.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                toggleDetails();\n            }\n        });\n\n        m_setButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                setPermissions();\n            }\n        });\n\n        m_deleteButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                deletePermissionSet();\n            }\n        });\n\n        if (inheritedFrom != null) {\n            m_inheritedFrom.setValue(inheritedFrom);\n        } else {\n            m_inheritedFrom.setVisible(false);\n        }\n\n        // get all permissions of the current entry\n        CmsPermissionSet permissions = entry.getPermissions();\n        IndexedContainer container = getPermissionContainer(permissions);\n        m_permissions.setContainerDataSource(container);\n        m_permissions.setColumnReorderingAllowed(false);\n        m_permissions.setColumnHeader(PROPERTY_LABEL, CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_0));\n        m_permissions.setColumnHeader(\n            PROPERTY_ALLOWED,\n            CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_ALLOWED_0));\n        m_permissions.setColumnHeader(\n            PROPERTY_DISPLAY_ALLOWED,\n            CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_ALLOWED_0));\n        m_permissions.setColumnHeader(PROPERTY_DENIED, CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_DENIED_0));\n        m_permissions.setColumnHeader(\n            PROPERTY_DISPLAY_DENIED,\n            CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_DENIED_0));\n\n        m_permissions.setPageLength(5);\n        m_permissions.setSortEnabled(false);\n\n        if (m_editable) {\n            m_permissions.setVisibleColumns(PROPERTY_LABEL, PROPERTY_ALLOWED, PROPERTY_DENIED);\n            toggleDetails();\n            m_details.setVisible(false);\n            m_permissions.setTableFieldFactory(FIELD_FACTORY);\n            m_permissions.setEditable(m_editable);\n            m_responsibleCheckbox.setValue(isResponsible(entry.getFlags()));\n            m_overwriteCheckbox.setValue(isOverWritingInherited(entry.getFlags()));\n            m_inheritCheckbox.setVisible(isFolder);\n            m_inheritCheckbox.setValue(Boolean.valueOf(m_entry.isInheriting()));\n            m_buttonBar.setVisible(true);\n        } else {\n            m_permissions.setVisibleColumns(PROPERTY_LABEL, PROPERTY_DISPLAY_ALLOWED, PROPERTY_DISPLAY_DENIED);\n        }\n    }","id":77837,"modified_method":"/**\n     * Constructor.<p>\n     *\n     * @param entry the access control entry\n     * @param editable the editable flag\n     * @param isFolder the is folder flag\n     * @param inheritedFrom the inherited from path\n     * @param changeHandler the change handler\n     */\n    public CmsPermissionView(\n        CmsAccessControlEntry entry,\n        boolean editable,\n        boolean isFolder,\n        String inheritedFrom,\n        PermissionChangeHandler changeHandler) {\n        m_changeHandler = changeHandler;\n        m_editable = editable;\n        m_entry = entry;\n        CmsVaadinUtils.readAndLocalizeDesign(this, null, null);\n        CmsObject cms = A_CmsUI.getCmsObject();\n        // get name and type of the current entry\n        I_CmsPrincipal principal;\n        try {\n            principal = CmsPrincipal.readPrincipalIncludingHistory(cms, entry.getPrincipal());\n        } catch (@SuppressWarnings(\"unused\") CmsException e) {\n            principal = null;\n        }\n\n        m_principalName = (principal != null) ? principal.getName() : entry.getPrincipal().toString();\n        @SuppressWarnings(\"unused\")\n        String ou = null;\n        String displayName;\n\n        int flags = 0;\n        if ((principal != null) && (principal instanceof CmsHistoryPrincipal)) {\n            // there is a history principal entry, handle it\n            if (principal.isGroup()) {\n                String niceName = OpenCms.getWorkplaceManager().translateGroupName(principal.getName(), false);\n                displayName = CmsVaadinUtils.getMessageText(\n                    org.opencms.security.Messages.GUI_ORGUNIT_DISPLAY_NAME_2,\n                    ((CmsHistoryPrincipal)principal).getDescription(),\n                    niceName);\n                ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n            } else {\n                displayName = ((CmsHistoryPrincipal)principal).getName();\n                ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n            }\n        } else if ((principal != null) && principal.isGroup()) {\n            String niceName = OpenCms.getWorkplaceManager().translateGroupName(principal.getName(), false);\n            displayName = CmsVaadinUtils.getMessageText(\n                org.opencms.security.Messages.GUI_ORGUNIT_DISPLAY_NAME_2,\n                ((CmsGroup)principal).getDescription(A_CmsUI.get().getLocale()),\n                niceName);\n            ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_GROUP;\n        } else if ((principal != null) && principal.isUser()) {\n            displayName = ((CmsUser)principal).getFullName();\n            ou = CmsOrganizationalUnit.getParentFqn(m_principalName);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_USER;\n        } else if ((m_principalName != null)\n            && m_principalName.equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString())) {\n            m_principalName = CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME;\n            displayName = CmsVaadinUtils.getMessageText(Messages.GUI_LABEL_ALLOTHERS_0);\n            m_responsibleCheckbox.setVisible(false);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS;\n        } else if ((m_principalName != null)\n            && m_principalName.equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID.toString())) {\n            m_principalName = CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_NAME;\n            displayName = CmsVaadinUtils.getMessageText(Messages.GUI_LABEL_OVERWRITEALL_0);\n            flags = CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL;\n        } else {\n            // check if it is the case of a role\n            CmsRole role = CmsRole.valueOfId(entry.getPrincipal());\n            if (role != null) {\n                displayName = role.getName(A_CmsUI.get().getLocale());\n                m_principalName = role.getRoleName();\n                flags = CmsAccessControlEntry.ACCESS_FLAGS_ROLE;\n            } else {\n                displayName = entry.getPrincipal().toString();\n            }\n        }\n\n        if ((flags > 0) && ((entry.getFlags() & flags) == 0)) {\n            // the flag is set to the wrong principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\n                    Messages.get().getBundle(A_CmsUI.get().getLocale()).key(\n                        Messages.ERR_INVALID_ACE_1,\n                        entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | flags));\n        } else if (entry.getFlags() < CmsAccessControlEntry.ACCESS_FLAGS_USER) {\n            // the flag is set to NO principal type\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\n                    Messages.get().getBundle(A_CmsUI.get().getLocale()).key(\n                        Messages.ERR_INVALID_ACE_1,\n                        entry.toString()));\n            }\n            entry = new CmsAccessControlEntry(\n                entry.getResource(),\n                entry.getPrincipal(),\n                entry.getAllowedPermissions(),\n                entry.getDeniedPermissions(),\n                (entry.getFlags() | CmsAccessControlEntry.ACCESS_FLAGS_GROUP));\n        }\n\n        m_principalType = getEntryType(entry.getFlags(), false);\n\n        if (m_principalName == null) {\n            m_principalName = \"\";\n        }\n\n        FontIcon icon = null;\n        boolean isOverwriteAll = false;\n        switch (flags) {\n            case CmsAccessControlEntry.ACCESS_FLAGS_USER:\n                icon = FontAwesome.USER;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_GROUP:\n                icon = FontAwesome.GROUP;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_ALLOTHERS:\n                icon = FontAwesome.GLOBE;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_ROLE:\n                icon = FontAwesome.GRADUATION_CAP;\n                break;\n            case CmsAccessControlEntry.ACCESS_FLAGS_OVERWRITE_ALL:\n                icon = FontAwesome.EXCLAMATION_CIRCLE;\n                isOverwriteAll = true;\n                break;\n            default:\n                icon = FontAwesome.QUESTION_CIRCLE;\n        }\n\n        m_label.setContentMode(ContentMode.HTML);\n        m_label.setValue(\n            icon.getHtml() + \" <b>\" + displayName + \"<\/b> \" + entry.getPermissions().getPermissionString());\n        m_label.setWidthUndefined();\n        m_details.setIcon(FontAwesome.PLUS_SQUARE_O);\n        m_details.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                toggleDetails();\n            }\n        });\n\n        m_setButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                setPermissions();\n            }\n        });\n\n        m_deleteButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                deletePermissionSet();\n            }\n        });\n\n        if (inheritedFrom != null) {\n            m_inheritedFrom.setValue(inheritedFrom);\n        } else {\n            m_inheritedFrom.setVisible(false);\n        }\n\n        if (isOverwriteAll) {\n            m_details.setVisible(false);\n            if (m_editable) {\n                addComponent(m_deleteButton, 2);\n                m_deleteButton.addStyleName(\"o-permissions_delete\");\n            }\n        } else {\n            // get all permissions of the current entry\n            CmsPermissionSet permissions = entry.getPermissions();\n            IndexedContainer container = getPermissionContainer(permissions);\n            m_permissions.setContainerDataSource(container);\n            m_permissions.setColumnReorderingAllowed(false);\n            m_permissions.setColumnHeader(PROPERTY_LABEL, CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_0));\n            m_permissions.setColumnHeader(\n                PROPERTY_ALLOWED,\n                CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_ALLOWED_0));\n            m_permissions.setColumnHeader(\n                PROPERTY_DISPLAY_ALLOWED,\n                CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_ALLOWED_0));\n            m_permissions.setColumnHeader(\n                PROPERTY_DENIED,\n                CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_DENIED_0));\n            m_permissions.setColumnHeader(\n                PROPERTY_DISPLAY_DENIED,\n                CmsVaadinUtils.getMessageText(Messages.GUI_PERMISSION_DENIED_0));\n\n            m_permissions.setPageLength(5);\n            m_permissions.setSortEnabled(false);\n            if (m_editable) {\n                toggleDetails();\n                m_details.setVisible(false);\n                m_permissions.setVisibleColumns(PROPERTY_LABEL, PROPERTY_ALLOWED, PROPERTY_DENIED);\n                m_permissions.setTableFieldFactory(FIELD_FACTORY);\n                m_permissions.setEditable(m_editable);\n                m_responsibleCheckbox.setValue(isResponsible(entry.getFlags()));\n                m_overwriteCheckbox.setValue(isOverWritingInherited(entry.getFlags()));\n                m_inheritCheckbox.setVisible(isFolder);\n                m_inheritCheckbox.setValue(Boolean.valueOf(m_entry.isInheriting()));\n\n                m_buttonBar.setVisible(true);\n            } else {\n                m_permissions.setVisibleColumns(PROPERTY_LABEL, PROPERTY_DISPLAY_ALLOWED, PROPERTY_DISPLAY_DENIED);\n            }\n        }\n\n    }","commit_id":"a9cb660cef522e2fc01d88fa2c40d2a77b5bbe42","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n    public void run() {\n      try {\n        FileInStream stream = sTfs.getInStream(mFile);\n        stream.read();\n        stream.close();\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }","id":77838,"modified_method":"@Override\n    public void run() {\n      try {\n        FileInStream stream = sTfs.openFile(mUri);\n        stream.read();\n        stream.close();\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"FileRead(TachyonFile file) {\n      mFile = file;\n    }","id":77839,"modified_method":"FileRead(TachyonURI uri) {\n      mUri = uri;\n    }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests the concurrent read of {@link FileInStream}.\n   */\n  @Test\n  public void FileInStreamConcurrencyTest() throws Exception {\n    String uniqPath = PathUtils.uniqPath();\n    TachyonFile f =\n        TachyonFSTestUtils.createByteFile(sTfs, uniqPath, BLOCK_SIZE * 2, sWriteTachyon);\n\n    List<Thread> threads = Lists.newArrayList();\n    for (int i = 0; i < READ_THREADS_NUM; i ++) {\n      threads.add(new Thread(new FileRead(f)));\n    }\n\n    ConcurrencyTestUtils.assertConcurrent(threads, 100);\n  }","id":77840,"modified_method":"/**\n   * Tests the concurrent read of {@link FileInStream}.\n   */\n  @Test\n  public void FileInStreamConcurrencyTest() throws Exception {\n    String uniqPath = PathUtils.uniqPath();\n    TachyonFSTestUtils.createByteFile(sTfs, uniqPath, BLOCK_SIZE * 2, sWriteTachyon);\n\n    List<Thread> threads = Lists.newArrayList();\n    for (int i = 0; i < READ_THREADS_NUM; i ++) {\n      threads.add(new Thread(new FileRead(new TachyonURI(uniqPath))));\n    }\n\n    ConcurrencyTestUtils.assertConcurrent(threads, 100);\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void mkdirTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    MkdirOptions options = new MkdirOptions.Builder(new TachyonConf()).setRecursive(true).build();\n    for (int k = 0; k < 10; k ++) {\n      Assert.assertTrue(mTfs.mkdir(new TachyonURI(uniqPath + k), options));\n      try {\n        Assert.assertFalse(mTfs.mkdir(new TachyonURI(uniqPath + k), options));\n        Assert.assertTrue(\"mkdir should throw FileAlreadyExistsException\", false);\n      } catch (FileAlreadyExistsException faee) {\n        Assert.assertEquals(faee.getMessage(),\n            ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(uniqPath + k));\n      }\n    }\n  }","id":77841,"modified_method":"@Test\n  public void mkdirTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    CreateDirectoryOptions options = CreateDirectoryOptions.defaults().setRecursive(true);\n    for (int k = 0; k < 10; k ++) {\n      mTfs.createDirectory(new TachyonURI(uniqPath + k), options);\n      try {\n        mTfs.createDirectory(new TachyonURI(uniqPath + k), options);\n        Assert.fail(\"mkdir should throw FileAlreadyExistsException\");\n      } catch (FileAlreadyExistsException faee) {\n        Assert.assertEquals(faee.getMessage(),\n            ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(uniqPath + k));\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void mountAlternateUfsTest() throws IOException, TachyonException {\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      String filePath = PathUtils.concatPath(alternateUfsRoot, \"file1\");\n      UnderFileSystemUtils.touch(filePath, mLocalTachyonClusterResource.getTestConf());\n      Assert.assertTrue(mTfs.mount(new TachyonURI(\"/dir1\"), new TachyonURI(alternateUfsRoot)));\n      mTfs.loadMetadata(new TachyonURI(\"/dir1/file1\"));\n      Assert.assertEquals(\"file1\", mTfs.listStatus(mTfs.open(new TachyonURI(\"/dir1\"))).get(0)\n          .getName());\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","id":77842,"modified_method":"@Test\n  public void mountAlternateUfsTest() throws IOException, TachyonException {\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      String filePath = PathUtils.concatPath(alternateUfsRoot, \"file1\");\n      UnderFileSystemUtils.touch(filePath, mLocalTachyonClusterResource.getTestConf());\n      mTfs.mount(new TachyonURI(\"/dir1\"), new TachyonURI(alternateUfsRoot));\n      mTfs.loadMetadata(new TachyonURI(\"/dir1/file1\"));\n      Assert.assertEquals(\"file1\", mTfs.listStatus(new TachyonURI(\"/dir1\")).get(0).getName());\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void createFileWithFileAlreadyExistsExceptionTest() throws IOException, TachyonException {\n    TachyonURI uri = new TachyonURI(PathUtils.uniqPath());\n    mTfs.getOutStream(uri, mWriteBoth).close();\n    Assert.assertNotNull(mTfs.getInfo(mTfs.open(uri)));\n    try {\n      mTfs.getOutStream(uri, mWriteBoth);\n    } catch (TachyonException e) {\n      Assert.assertEquals(e.getType(), TachyonExceptionType.FILE_ALREADY_EXISTS);\n    }\n  }","id":77843,"modified_method":"@Test\n  public void createFileWithFileAlreadyExistsExceptionTest() throws IOException, TachyonException {\n    TachyonURI uri = new TachyonURI(PathUtils.uniqPath());\n    mTfs.createFile(uri, mWriteBoth).close();\n    Assert.assertNotNull(mTfs.getStatus(uri));\n    try {\n      mTfs.createFile(uri, mWriteBoth);\n    } catch (TachyonException e) {\n      Assert.assertEquals(e.getType(), TachyonExceptionType.FILE_ALREADY_EXISTS);\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void getRootTest() throws IOException, TachyonException {\n    Assert.assertEquals(0, mTfs.getInfo(mTfs.open(new TachyonURI(\"/\"))).getFileId());\n  }","id":77844,"modified_method":"@Test\n  public void getRootTest() throws IOException, TachyonException {\n    Assert.assertEquals(0, mTfs.getStatus(new TachyonURI(\"/\")).getFileId());\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void createFileTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = 1; k < 5; k ++) {\n      TachyonURI uri = new TachyonURI(uniqPath + k);\n      mTfs.getOutStream(uri, mWriteBoth).close();\n      Assert.assertNotNull(mTfs.getInfo(mTfs.open(uri)));\n    }\n  }","id":77845,"modified_method":"@Test\n  public void createFileTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = 1; k < 5; k ++) {\n      TachyonURI uri = new TachyonURI(uniqPath + k);\n      mTfs.createFile(uri, mWriteBoth).close();\n      Assert.assertNotNull(mTfs.getStatus(uri));\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void createFileWithInvalidPathExceptionTest() throws IOException, TachyonException {\n    mThrown.expect(InvalidPathException.class);\n    mThrown.expectMessage(\"Path root/testFile1 is invalid.\");\n    mTfs.getOutStream(new TachyonURI(\"root/testFile1\"), mWriteBoth);\n  }","id":77846,"modified_method":"@Test\n  public void createFileWithInvalidPathExceptionTest() throws IOException, TachyonException {\n    mThrown.expect(InvalidPathException.class);\n    mThrown.expectMessage(\"Path root/testFile1 is invalid.\");\n    mTfs.createFile(new TachyonURI(\"root/testFile1\"), mWriteBoth);\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void mountShadowUfsTest() throws Exception {\n    TachyonConf testConf = mLocalTachyonClusterResource.getTestConf();\n    String ufsRoot = testConf.get(Constants.UNDERFS_ADDRESS);\n    String ufsSubdir = PathUtils.concatPath(ufsRoot, \"dir1\");\n    UnderFileSystemUtils.mkdirIfNotExists(ufsSubdir, testConf);\n\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      String subdirPath = PathUtils.concatPath(alternateUfsRoot, \"subdir\");\n      UnderFileSystemUtils.mkdirIfNotExists(subdirPath, testConf);\n      // Cannot mount to path that shadows a file in the primary UFS\n      Assert.assertFalse(mTfs.mount(new TachyonURI(\"/dir1\"), new TachyonURI(subdirPath)));\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","id":77847,"modified_method":"@Test\n  public void mountShadowUfsTest() throws Exception {\n    TachyonConf testConf = mLocalTachyonClusterResource.getTestConf();\n    String ufsRoot = testConf.get(Constants.UNDERFS_ADDRESS);\n    String ufsSubdir = PathUtils.concatPath(ufsRoot, \"dir1\");\n    UnderFileSystemUtils.mkdirIfNotExists(ufsSubdir, testConf);\n\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      String subdirPath = PathUtils.concatPath(alternateUfsRoot, \"subdir\");\n      UnderFileSystemUtils.mkdirIfNotExists(subdirPath, testConf);\n      // Cannot mount to path that shadows a file in the primary UFS\n      mTfs.mount(new TachyonURI(\"/dir1\"), new TachyonURI(subdirPath));\n      Assert.fail(\"Cannot mount to path that shadows a file in the primary UFS\");\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void mountPrefixUfsTest() throws Exception {\n    TachyonConf testConf = mLocalTachyonClusterResource.getTestConf();\n    // Primary UFS cannot be re-mounted\n    String ufsRoot = testConf.get(Constants.UNDERFS_ADDRESS);\n    String ufsSubdir = PathUtils.concatPath(ufsRoot, \"dir1\");\n    UnderFileSystemUtils.mkdirIfNotExists(ufsSubdir, testConf);\n    Assert.assertFalse(mTfs.mount(new TachyonURI(\"/dir\"), new TachyonURI(ufsSubdir)));\n\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      String midDirPath = PathUtils.concatPath(alternateUfsRoot, \"mid\");\n      String innerDirPath = PathUtils.concatPath(midDirPath, \"inner\");\n      UnderFileSystemUtils.mkdirIfNotExists(innerDirPath, testConf);\n      Assert.assertTrue(mTfs.mount(new TachyonURI(\"/mid\"), new TachyonURI(midDirPath)));\n      // Cannot mount suffix of already-mounted directory\n      Assert.assertFalse(mTfs.mount(new TachyonURI(\"/inner\"), new TachyonURI(innerDirPath)));\n      // Cannot mount prefix of already-mounted directory\n      Assert.assertFalse(mTfs.mount(new TachyonURI(\"/root\"), new TachyonURI(alternateUfsRoot)));\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","id":77848,"modified_method":"@Test\n  public void mountPrefixUfsTest() throws Exception {\n    TachyonConf testConf = mLocalTachyonClusterResource.getTestConf();\n    // Primary UFS cannot be re-mounted\n    String ufsRoot = testConf.get(Constants.UNDERFS_ADDRESS);\n    String ufsSubdir = PathUtils.concatPath(ufsRoot, \"dir1\");\n    UnderFileSystemUtils.mkdirIfNotExists(ufsSubdir, testConf);\n    try {\n      mTfs.mount(new TachyonURI(\"/dir\"), new TachyonURI(ufsSubdir));\n      Assert.fail(\"Cannot remount primary ufs.\");\n    } catch (TachyonException e) {\n      // Exception expected, continue\n    }\n\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      String midDirPath = PathUtils.concatPath(alternateUfsRoot, \"mid\");\n      String innerDirPath = PathUtils.concatPath(midDirPath, \"inner\");\n      UnderFileSystemUtils.mkdirIfNotExists(innerDirPath, testConf);\n      mTfs.mount(new TachyonURI(\"/mid\"), new TachyonURI(midDirPath));\n      // Cannot mount suffix of already-mounted directory\n      try {\n        mTfs.mount(new TachyonURI(\"/inner\"), new TachyonURI(innerDirPath));\n        Assert.fail(\"Cannot mount suffix of already-mounted directory\");\n      } catch (TachyonException e) {\n        // Exception expected, continue\n      }\n      // Cannot mount prefix of already-mounted directory\n      try {\n        mTfs.mount(new TachyonURI(\"/root\"), new TachyonURI(alternateUfsRoot));\n        Assert.fail(\"Cannot mount prefix of already-mounted directory\");\n      } catch (TachyonException e) {\n        // Exception expected, continue\n      }\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void deleteFileTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n\n    for (int k = 0; k < 5; k ++) {\n      TachyonURI fileURI = new TachyonURI(uniqPath + k);\n      TachyonFile f = TachyonFSTestUtils.createByteFile(mTfs, fileURI.getPath(), k, mWriteBoth);\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n      Assert.assertNotNull(mTfs.getInfo(f));\n    }\n\n    for (int k = 0; k < 5; k ++) {\n      TachyonURI fileURI = new TachyonURI(uniqPath + k);\n      TachyonFile f = mTfs.open(fileURI);\n      mTfs.delete(f);\n      Assert.assertNull(mTfs.openIfExists(fileURI));\n      mThrown.expect(FileDoesNotExistException.class);\n      mTfs.getInfo(f);\n    }\n  }","id":77849,"modified_method":"@Test\n  public void deleteFileTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n\n    for (int k = 0; k < 5; k ++) {\n      TachyonURI fileURI = new TachyonURI(uniqPath + k);\n      TachyonFSTestUtils.createByteFile(mTfs, fileURI.getPath(), k, mWriteBoth);\n      Assert.assertTrue(mTfs.getStatus(fileURI).getInMemoryPercentage() == 100);\n      Assert.assertNotNull(mTfs.getStatus(fileURI));\n    }\n\n    for (int k = 0; k < 5; k ++) {\n      TachyonURI fileURI = new TachyonURI(uniqPath + k);\n      mTfs.delete(fileURI);\n      Assert.assertFalse(mTfs.exists(fileURI));\n      mThrown.expect(FileDoesNotExistException.class);\n      mTfs.getStatus(fileURI);\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void getFileStatusTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    int writeBytes = USER_QUOTA_UNIT_BYTES * 2;\n    TachyonURI uri = new TachyonURI(uniqPath);\n    TachyonFile f = TachyonFSTestUtils.createByteFile(mTfs, uri.getPath(), writeBytes, mWriteBoth);\n    Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    FileInfo fileInfo = mTfs.getInfo(f);\n    Assert.assertNotNull(fileInfo);\n    Assert.assertTrue(fileInfo.getPath().equals(uniqPath));\n  }","id":77850,"modified_method":"@Test\n  public void getFileStatusTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    int writeBytes = USER_QUOTA_UNIT_BYTES * 2;\n    TachyonURI uri = new TachyonURI(uniqPath);\n    TachyonFSTestUtils.createByteFile(mTfs, uri.getPath(), writeBytes, mWriteBoth);\n    Assert.assertTrue(mTfs.getStatus(uri).getInMemoryPercentage() == 100);\n\n    Assert.assertTrue(mTfs.getStatus(uri).getPath().equals(uniqPath));\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void renameFileTest1() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    TachyonURI path1 = new TachyonURI(uniqPath + 1);\n    mTfs.getOutStream(path1, mWriteBoth).close();\n    for (int k = 1; k < 10; k ++) {\n      TachyonURI fileA = new TachyonURI(uniqPath + k);\n      TachyonURI fileB = new TachyonURI(uniqPath + (k + 1));\n      TachyonFile existingFile = mTfs.open(fileA);\n      long oldFileId = existingFile.getFileId();\n      Assert.assertNotNull(existingFile);\n      Assert.assertTrue(mTfs.rename(existingFile, fileB));\n      TachyonFile renamedFile = mTfs.open(fileB);\n      Assert.assertNotNull(renamedFile);\n      Assert.assertEquals(oldFileId, renamedFile.getFileId());\n    }\n  }","id":77851,"modified_method":"@Test\n  public void renameFileTest1() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    TachyonURI path1 = new TachyonURI(uniqPath + 1);\n    mTfs.createFile(path1, mWriteBoth).close();\n    for (int k = 1; k < 10; k ++) {\n      TachyonURI fileA = new TachyonURI(uniqPath + k);\n      TachyonURI fileB = new TachyonURI(uniqPath + (k + 1));\n      URIStatus existingFile = mTfs.getStatus(fileA);\n      long oldFileId = existingFile.getFileId();\n      Assert.assertNotNull(existingFile);\n      mTfs.rename(fileA, fileB);\n      URIStatus renamedFile = mTfs.getStatus(fileB);\n      Assert.assertNotNull(renamedFile);\n      Assert.assertEquals(oldFileId, renamedFile.getFileId());\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void renameFileTest2() throws IOException, TachyonException {\n    TachyonURI uniqUri = new TachyonURI(PathUtils.uniqPath());\n    mTfs.getOutStream(uniqUri, mWriteBoth).close();\n    TachyonFile f = mTfs.open(uniqUri);\n    long oldFileId = f.getFileId();\n    Assert.assertTrue(mTfs.rename(f, uniqUri));\n    Assert.assertEquals(oldFileId, mTfs.open(uniqUri).getFileId());\n  }","id":77852,"modified_method":"@Test\n  public void renameFileTest2() throws IOException, TachyonException {\n    TachyonURI uniqUri = new TachyonURI(PathUtils.uniqPath());\n    mTfs.createFile(uniqUri, mWriteBoth).close();\n    URIStatus f = mTfs.getStatus(uniqUri);\n    long oldFileId = f.getFileId();\n    mTfs.rename(uniqUri, uniqUri);\n    Assert.assertEquals(oldFileId, mTfs.getStatus(uniqUri).getFileId());\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void mountAlternateUfsSubdirsTest() throws Exception {\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      TachyonConf testConf = mLocalTachyonClusterResource.getTestConf();\n      String dirPath1 = PathUtils.concatPath(alternateUfsRoot, \"dir1\");\n      String dirPath2 = PathUtils.concatPath(alternateUfsRoot, \"dir2\");\n      UnderFileSystemUtils.mkdirIfNotExists(dirPath1, testConf);\n      UnderFileSystemUtils.mkdirIfNotExists(dirPath2, testConf);\n      String filePath1 = PathUtils.concatPath(dirPath1, \"file1\");\n      String filePath2 = PathUtils.concatPath(dirPath2, \"file2\");\n      UnderFileSystemUtils.touch(filePath1, testConf);\n      UnderFileSystemUtils.touch(filePath2, testConf);\n\n      Assert.assertTrue(mTfs.mount(new TachyonURI(\"/dirx\"), new TachyonURI(dirPath1)));\n      Assert.assertTrue(mTfs.mount(new TachyonURI(\"/diry\"), new TachyonURI(dirPath2)));\n      mTfs.loadMetadata(new TachyonURI(\"/dirx/file1\"));\n      mTfs.loadMetadata(new TachyonURI(\"/diry/file2\"));\n      Assert.assertEquals(\"file1\", mTfs.listStatus(mTfs.open(new TachyonURI(\"/dirx\"))).get(0)\n          .getName());\n      Assert.assertEquals(\"file2\", mTfs.listStatus(mTfs.open(new TachyonURI(\"/diry\"))).get(0)\n          .getName());\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","id":77853,"modified_method":"@Test\n  public void mountAlternateUfsSubdirsTest() throws Exception {\n    String alternateUfsRoot = createAlternateUfs();\n    try {\n      TachyonConf testConf = mLocalTachyonClusterResource.getTestConf();\n      String dirPath1 = PathUtils.concatPath(alternateUfsRoot, \"dir1\");\n      String dirPath2 = PathUtils.concatPath(alternateUfsRoot, \"dir2\");\n      UnderFileSystemUtils.mkdirIfNotExists(dirPath1, testConf);\n      UnderFileSystemUtils.mkdirIfNotExists(dirPath2, testConf);\n      String filePath1 = PathUtils.concatPath(dirPath1, \"file1\");\n      String filePath2 = PathUtils.concatPath(dirPath2, \"file2\");\n      UnderFileSystemUtils.touch(filePath1, testConf);\n      UnderFileSystemUtils.touch(filePath2, testConf);\n\n      mTfs.mount(new TachyonURI(\"/dirx\"), new TachyonURI(dirPath1));\n      mTfs.mount(new TachyonURI(\"/diry\"), new TachyonURI(dirPath2));\n      mTfs.loadMetadata(new TachyonURI(\"/dirx/file1\"));\n      mTfs.loadMetadata(new TachyonURI(\"/diry/file2\"));\n      Assert.assertEquals(\"file1\", mTfs.listStatus(new TachyonURI(\"/dirx\")).get(0).getName());\n      Assert.assertEquals(\"file2\", mTfs.listStatus(new TachyonURI(\"/diry\")).get(0).getName());\n    } finally {\n      destroyAlternateUfs(alternateUfsRoot);\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void lineageCompleteAndAsyncPersistTest() throws Exception {\n    LineageMasterClient lineageMasterClient = getLineageMasterClient();\n\n    Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n        TimeUnit.SECONDS));\n    Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC, 5,\n        TimeUnit.SECONDS));\n\n    try {\n      lineageMasterClient.createLineage(Lists.<String>newArrayList(), Lists.newArrayList(OUT_FILE),\n          mJob);\n\n      OutStreamOptions options = new OutStreamOptions.Builder(mTestConf)\n          .setWriteType(WriteType.MUST_CACHE).setBlockSizeBytes(BLOCK_SIZE_BYTES).build();\n      LineageFileSystem tfs =\n          (LineageFileSystem) mLocalTachyonClusterResource.get().getClient();\n      FileOutStream outputStream = tfs.getOutStream(new TachyonURI(OUT_FILE), options);\n      outputStream.write(1);\n      outputStream.close();\n\n      List<LineageInfo> infos = lineageMasterClient.getLineageInfoList();\n      String uri = infos.get(0).outputFiles.get(0);\n      long fileId = getFileSystemMasterClient().getFileId(uri);\n      FileInfo fileInfo = getFileSystemMasterClient().getFileInfo(fileId);\n      Assert.assertEquals(PersistenceState.NOT_PERSISTED.toString(),\n          fileInfo.getPersistenceState());\n      Assert.assertTrue(fileInfo.isCompleted);\n\n      // Execute the checkpoint scheduler for async checkpoint\n      HeartbeatScheduler.schedule(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n          TimeUnit.SECONDS));\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC, 5,\n          TimeUnit.SECONDS));\n\n      fileInfo = getFileSystemMasterClient().getFileInfo(fileId);\n      Assert.assertEquals(PersistenceState.IN_PROGRESS.toString(),\n          fileInfo.getPersistenceState());\n\n      // sleep and wait for worker to persist the file\n      CommonUtils.sleepMs(5);\n\n      // worker notifies the master\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC, 5,\n          TimeUnit.SECONDS));\n\n      fileInfo = getFileSystemMasterClient().getFileInfo(fileId);\n      Assert.assertEquals(PersistenceState.PERSISTED.toString(),\n          fileInfo.getPersistenceState());\n\n    } finally {\n      lineageMasterClient.close();\n    }\n  }","id":77854,"modified_method":"@Test\n  public void lineageCompleteAndAsyncPersistTest() throws Exception {\n    LineageMasterClient lineageMasterClient = getLineageMasterClient();\n\n    Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n        TimeUnit.SECONDS));\n    Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC, 5,\n        TimeUnit.SECONDS));\n\n    try {\n      lineageMasterClient.createLineage(Lists.<String>newArrayList(), Lists.newArrayList(OUT_FILE),\n          mJob);\n\n      CreateFileOptions options =\n          CreateFileOptions.defaults().setWriteType(WriteType.MUST_CACHE)\n              .setBlockSizeBytes(BLOCK_SIZE_BYTES);\n      LineageFileSystem tfs =\n          (LineageFileSystem) mLocalTachyonClusterResource.get().getClient();\n      FileOutStream outputStream = tfs.createFile(new TachyonURI(OUT_FILE), options);\n      outputStream.write(1);\n      outputStream.close();\n\n      List<LineageInfo> infos = lineageMasterClient.getLineageInfoList();\n      String uri = infos.get(0).outputFiles.get(0);\n      long fileId = getFileSystemMasterClient().getFileId(uri);\n      FileInfo fileInfo = getFileSystemMasterClient().getFileInfo(fileId);\n      Assert.assertEquals(PersistenceState.NOT_PERSISTED.toString(),\n          fileInfo.getPersistenceState());\n      Assert.assertTrue(fileInfo.isCompleted);\n\n      // Execute the checkpoint scheduler for async checkpoint\n      HeartbeatScheduler.schedule(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n          TimeUnit.SECONDS));\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC, 5,\n          TimeUnit.SECONDS));\n\n      fileInfo = getFileSystemMasterClient().getFileInfo(fileId);\n      Assert.assertEquals(PersistenceState.IN_PROGRESS.toString(),\n          fileInfo.getPersistenceState());\n\n      // sleep and wait for worker to persist the file\n      CommonUtils.sleepMs(5);\n\n      // worker notifies the master\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC, 5,\n          TimeUnit.SECONDS));\n\n      fileInfo = getFileSystemMasterClient().getFileInfo(fileId);\n      Assert.assertEquals(PersistenceState.PERSISTED.toString(),\n          fileInfo.getPersistenceState());\n\n    } finally {\n      lineageMasterClient.close();\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#read(byte[])}.\n   */\n  @Test\n  public void readTest2() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n        byte[] ret = new byte[k];\n        Assert.assertEquals(k, is.read(ret));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n\n        is = sTfs.getInStream(f, sReadCache);\n        ret = new byte[k];\n        Assert.assertEquals(k, is.read(ret));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n      }\n    }\n  }","id":77855,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#read(byte[])}.\n   */\n  @Test\n  public void readTest2() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n        byte[] ret = new byte[k];\n        Assert.assertEquals(k, is.read(ret));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n\n        is = sTfs.openFile(uri, sReadCache);\n        ret = new byte[k];\n        Assert.assertEquals(k, is.read(ret));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"private List<OutStreamOptions> getOptionSet() {\n    List<OutStreamOptions> ret = new ArrayList<OutStreamOptions>(3);\n    ret.add(sWriteBoth);\n    ret.add(sWriteTachyon);\n    return ret;\n  }","id":77856,"modified_method":"private List<CreateFileOptions> getOptionSet() {\n    List<CreateFileOptions> ret = new ArrayList<CreateFileOptions>(3);\n    ret.add(sWriteBoth);\n    ret.add(sWriteTachyon);\n    return ret;\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#seek(long)}. Validate the expected\n   * exception for seeking a negative position.\n   *\n   * @throws IOException\n   * @throws TachyonException\n   */\n  @Test\n  public void seekExceptionTest1() throws IOException, TachyonException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(String.format(PreconditionMessage.ERR_SEEK_NEGATIVE, -1));\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n\n        try {\n          is.seek(-1);\n        } finally {\n          is.close();\n        }\n      }\n    }\n  }","id":77857,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#seek(long)}. Validate the expected\n   * exception for seeking a negative position.\n   *\n   * @throws IOException\n   * @throws TachyonException\n   */\n  @Test\n  public void seekExceptionTest1() throws IOException, TachyonException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(String.format(PreconditionMessage.ERR_SEEK_NEGATIVE, -1));\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n\n        try {\n          is.seek(-1);\n        } finally {\n          is.close();\n        }\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#seek(long)}. Validate the expected\n   * exception for seeking a position that is past buffer limit.\n   *\n   * @throws IOException\n   * @throws TachyonException\n   */\n  @Test\n  public void seekExceptionTest2() throws IOException, TachyonException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(String.format(PreconditionMessage.ERR_SEEK_PAST_END_OF_FILE, 1));\n\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n        try {\n          is.seek(k + 1);\n        } finally {\n          is.close();\n        }\n      }\n    }\n  }","id":77858,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#seek(long)}. Validate the expected\n   * exception for seeking a position that is past buffer limit.\n   *\n   * @throws IOException\n   * @throws TachyonException\n   */\n  @Test\n  public void seekExceptionTest2() throws IOException, TachyonException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(String.format(PreconditionMessage.ERR_SEEK_PAST_END_OF_FILE, 1));\n\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n        try {\n          is.seek(k + 1);\n        } finally {\n          is.close();\n        }\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#read(byte[], int, int)}.\n   */\n  @Test\n  public void readTest3() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n        byte[] ret = new byte[k / 2];\n        Assert.assertEquals(k / 2, is.read(ret, 0, k / 2));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k / 2, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n\n        is = sTfs.getInStream(f, sReadCache);\n        ret = new byte[k];\n        Assert.assertEquals(k, is.read(ret, 0, k));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n      }\n    }\n  }","id":77859,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#read(byte[], int, int)}.\n   */\n  @Test\n  public void readTest3() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n        byte[] ret = new byte[k / 2];\n        Assert.assertEquals(k / 2, is.read(ret, 0, k / 2));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k / 2, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n\n        is = sTfs.openFile(uri, sReadCache);\n        ret = new byte[k];\n        Assert.assertEquals(k, is.read(ret, 0, k));\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#skip(long)}.\n   */\n  @Test\n  public void skipTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n        Assert.assertEquals(k / 2, is.skip(k / 2));\n        Assert.assertEquals(k / 2, is.read());\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n\n        is = sTfs.getInStream(f, sReadCache);\n        int t = k / 3;\n        Assert.assertEquals(t, is.skip(t));\n        Assert.assertEquals(t, is.read());\n        Assert.assertEquals(t, is.skip(t));\n        Assert.assertEquals(2 * t + 1, is.read());\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n      }\n    }\n  }","id":77860,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#skip(long)}.\n   */\n  @Test\n  public void skipTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n        Assert.assertEquals(k / 2, is.skip(k / 2));\n        Assert.assertEquals(k / 2, is.read());\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n\n        is = sTfs.openFile(uri, sReadCache);\n        int t = k / 3;\n        Assert.assertEquals(t, is.skip(t));\n        Assert.assertEquals(t, is.read());\n        Assert.assertEquals(t, is.skip(t));\n        Assert.assertEquals(2 * t + 1, is.read());\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#seek(long)}.\n   *\n   * @throws IOException\n   * @throws TachyonException\n   */\n  @Test\n  public void seekTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n\n        is.seek(k / 3);\n        Assert.assertEquals(k / 3, is.read());\n        is.seek(k / 2);\n        Assert.assertEquals(k / 2, is.read());\n        is.seek(k / 4);\n        Assert.assertEquals(k / 4, is.read());\n        is.close();\n      }\n    }\n  }","id":77861,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#seek(long)}.\n   *\n   * @throws IOException\n   * @throws TachyonException\n   */\n  @Test\n  public void seekTest() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n\n        is.seek(k / 3);\n        Assert.assertEquals(k / 3, is.read());\n        is.seek(k / 2);\n        Assert.assertEquals(k / 2, is.read());\n        is.seek(k / 4);\n        Assert.assertEquals(k / 4, is.read());\n        is.close();\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#read()}.\n   */\n  @Test\n  public void readTest1() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (OutStreamOptions op : getOptionSet()) {\n        TachyonFile f =\n            TachyonFSTestUtils.createByteFile(sTfs, uniqPath + \"/file_\" + k + \"_\"\n            + op.hashCode(), k, op);\n\n        FileInStream is = sTfs.getInStream(f, sReadNoCache);\n        byte[] ret = new byte[k];\n        int value = is.read();\n        int cnt = 0;\n        while (value != -1) {\n          Assert.assertTrue(value >= 0);\n          Assert.assertTrue(value < 256);\n          ret[cnt ++] = (byte) value;\n          value = is.read();\n        }\n        Assert.assertEquals(cnt, k);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n\n        is = sTfs.getInStream(f, sReadCache);\n        ret = new byte[k];\n        value = is.read();\n        cnt = 0;\n        while (value != -1) {\n          Assert.assertTrue(value >= 0);\n          Assert.assertTrue(value < 256);\n          ret[cnt ++] = (byte) value;\n          value = is.read();\n        }\n        Assert.assertEquals(cnt, k);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getInfo(f).getInMemoryPercentage() == 100);\n      }\n    }\n  }","id":77862,"modified_method":"/**\n   * Test {@link tachyon.client.block.LocalBlockInStream#read()}.\n   */\n  @Test\n  public void readTest1() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN; k <= MAX_LEN; k += DELTA) {\n      for (CreateFileOptions op : getOptionSet()) {\n        TachyonURI uri = new TachyonURI(uniqPath + \"/file_\" + k + \"_\" + op.hashCode());\n        TachyonFSTestUtils.createByteFile(sTfs, uri, op, k);\n\n        FileInStream is = sTfs.openFile(uri, sReadNoCache);\n        byte[] ret = new byte[k];\n        int value = is.read();\n        int cnt = 0;\n        while (value != -1) {\n          Assert.assertTrue(value >= 0);\n          Assert.assertTrue(value < 256);\n          ret[cnt ++] = (byte) value;\n          value = is.read();\n        }\n        Assert.assertEquals(cnt, k);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n\n        is = sTfs.openFile(uri, sReadCache);\n        ret = new byte[k];\n        value = is.read();\n        cnt = 0;\n        while (value != -1) {\n          Assert.assertTrue(value >= 0);\n          Assert.assertTrue(value < 256);\n          ret[cnt ++] = (byte) value;\n          value = is.read();\n        }\n        Assert.assertEquals(cnt, k);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n        is.close();\n        Assert.assertTrue(sTfs.getStatus(uri).getInMemoryPercentage() == 100);\n      }\n    }\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n  public final void before() throws Exception {\n    mTfs = mLocalTachyonClusterResource.get().getClient();\n    mFSMasterClient = new FileSystemMasterClient(\n        new InetSocketAddress(mLocalTachyonClusterResource.get().getMasterHostname(),\n            mLocalTachyonClusterResource.get().getMasterPort()),\n        mLocalTachyonClusterResource.get().getWorkerTachyonConf());\n    mSetPinned = new SetStateOptions.Builder().setPinned(true).build();\n    mUnsetPinned = new SetStateOptions.Builder().setPinned(false).build();\n  }","id":77863,"modified_method":"@Before\n  public final void before() throws Exception {\n    mTfs = mLocalTachyonClusterResource.get().getClient();\n    mFSMasterClient = new FileSystemMasterClient(\n        new InetSocketAddress(mLocalTachyonClusterResource.get().getMasterHostname(),\n            mLocalTachyonClusterResource.get().getMasterPort()),\n        mLocalTachyonClusterResource.get().getWorkerTachyonConf());\n    mSetPinned = SetAttributeOptions.defaults().setPinned(true);\n    mUnsetPinned = SetAttributeOptions.defaults().setPinned(false);\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"private TachyonFile createEmptyFile(TachyonURI fileURI) throws IOException, TachyonException {\n    OutStreamOptions options =\n        new OutStreamOptions.Builder(new TachyonConf())\n            .setTachyonStorageType(TachyonStorageType.STORE)\n            .setUnderStorageType(UnderStorageType.NO_PERSIST).build();\n    FileOutStream os = mTfs.getOutStream(fileURI, options);\n    os.close();\n    return mTfs.open(fileURI);\n  }","id":77864,"modified_method":"private void createEmptyFile(TachyonURI fileURI) throws IOException, TachyonException {\n    CreateFileOptions options = CreateFileOptions.defaults().setWriteType(WriteType.MUST_CACHE);\n    FileOutStream os = mTfs.createFile(fileURI, options);\n    os.close();\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void recursivePinness() throws Exception {\n    TachyonFile dir0 = mTfs.open(new TachyonURI(\"/\"));\n    TachyonURI folderURI = new TachyonURI(\"/myFolder\");\n    TachyonURI fileURI = new TachyonURI(\"/myFolder/myFile\");\n\n    mTfs.mkdir(folderURI);\n    TachyonFile dir = mTfs.open(folderURI);\n\n    TachyonFile file = createEmptyFile(fileURI);\n    Assert.assertFalse(mTfs.getInfo(file).isPinned);\n\n    mTfs.setState(file, mSetPinned);\n    Assert.assertTrue(mTfs.getInfo(file).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file.getFileId()));\n\n    mTfs.setState(file, mUnsetPinned);\n    Assert.assertFalse(mTfs.getInfo(file).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()), Sets.<Long>newHashSet());\n\n    // Pinning a folder should recursively pin subfolders.\n    mTfs.setState(dir, mSetPinned);\n    Assert.assertTrue(mTfs.getInfo(file).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file.getFileId()));\n\n    // Same with unpinning.\n    mTfs.setState(dir0, mUnsetPinned);\n    Assert.assertFalse(mTfs.getInfo(file).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()), Sets.<Long>newHashSet());\n\n    // The last pin command always wins.\n    mTfs.setState(file, mSetPinned);\n    Assert.assertTrue(mTfs.getInfo(file).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file.getFileId()));\n  }","id":77865,"modified_method":"@Test\n  public void recursivePinness() throws Exception {\n    TachyonURI folderURI = new TachyonURI(\"/myFolder\");\n    TachyonURI fileURI = new TachyonURI(\"/myFolder/myFile\");\n\n    mTfs.createDirectory(folderURI);\n\n    createEmptyFile(fileURI);\n    Assert.assertFalse(mTfs.getStatus(fileURI).isPinned());\n\n    mTfs.setAttribute(fileURI, mSetPinned);\n    URIStatus status = mTfs.getStatus(fileURI);\n    Assert.assertTrue(status.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status.getFileId()));\n\n    mTfs.setAttribute(fileURI, mUnsetPinned);\n    status = mTfs.getStatus(fileURI);\n    Assert.assertFalse(status.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()), Sets.<Long>newHashSet());\n\n    // Pinning a folder should recursively pin subfolders.\n    mTfs.setAttribute(folderURI, mSetPinned);\n    status = mTfs.getStatus(fileURI);\n    Assert.assertTrue(status.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status.getFileId()));\n\n    // Same with unpinning.\n    mTfs.setAttribute(folderURI, mUnsetPinned);\n    status = mTfs.getStatus(fileURI);\n    Assert.assertFalse(status.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()), Sets.<Long>newHashSet());\n\n    // The last pin command always wins.\n    mTfs.setAttribute(fileURI, mSetPinned);\n    status = mTfs.getStatus(fileURI);\n    Assert.assertTrue(status.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status.getFileId()));\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void newFilesInheritPinness() throws Exception {\n    // Children should inherit the isPinned value of their parents on creation.\n\n    // Pin root\n    TachyonFile root = mTfs.open(new TachyonURI(\"/\"));\n    mTfs.setState(root, mSetPinned);\n\n    // Child file should be pinned\n    TachyonFile file0 = createEmptyFile(new TachyonURI(\"/file0\"));\n    Assert.assertTrue(mTfs.getInfo(file0).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file0.getFileId()));\n\n    // Child folder should be pinned\n    mTfs.mkdir(new TachyonURI(\"/folder\"));\n    TachyonFile folder = mTfs.open(new TachyonURI(\"/folder\"));\n    Assert.assertTrue(mTfs.getInfo(folder).isPinned);\n\n    // Grandchild file also pinned\n    TachyonFile file1 = createEmptyFile(new TachyonURI(\"/folder/file1\"));\n    Assert.assertTrue(mTfs.getInfo(file1).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file0.getFileId(), file1.getFileId()));\n\n    // Unpinning child folder should cause its children to be unpinned as well\n    mTfs.setState(folder, mUnsetPinned);\n    Assert.assertFalse(mTfs.getInfo(folder).isPinned);\n    Assert.assertFalse(mTfs.getInfo(file1).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file0.getFileId()));\n\n    // And new grandchildren should be unpinned too.\n    TachyonFile file2 = createEmptyFile(new TachyonURI(\"/folder/file2\"));\n    Assert.assertFalse(mTfs.getInfo(file2).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file0.getFileId()));\n\n    // But toplevel children still should be pinned!\n    TachyonFile file3 = createEmptyFile(new TachyonURI(\"/file3\"));\n    Assert.assertTrue(mTfs.getInfo(file3).isPinned);\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(file0.getFileId(), file3.getFileId()));\n  }","id":77866,"modified_method":"@Test\n  public void newFilesInheritPinness() throws Exception {\n    // Children should inherit the isPinned value of their parents on creation.\n\n    // Pin root\n    mTfs.setAttribute(new TachyonURI(\"/\"), mSetPinned);\n\n    // Child file should be pinned\n    TachyonURI file0 = new TachyonURI(\"/file0\");\n    createEmptyFile(file0);\n    URIStatus status0 = mTfs.getStatus(file0);\n    Assert.assertTrue(status0.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status0.getFileId()));\n\n    // Child folder should be pinned\n    TachyonURI folder = new TachyonURI(\"/folder\");\n    mTfs.createDirectory(folder);\n    Assert.assertTrue(mTfs.getStatus(folder).isPinned());\n\n    // Grandchild file also pinned\n    TachyonURI file1 = new TachyonURI(\"/folder/file1\");\n    URIStatus status1 = mTfs.getStatus(file1);\n    Assert.assertTrue(status1.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status0.getFileId(), status1.getFileId()));\n\n    // Unpinning child folder should cause its children to be unpinned as well\n    mTfs.setAttribute(folder, mUnsetPinned);\n    Assert.assertFalse(mTfs.getStatus(folder).isPinned());\n    Assert.assertFalse(mTfs.getStatus(file1).isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status0.getFileId()));\n\n    // And new grandchildren should be unpinned too.\n    createEmptyFile(new TachyonURI(\"/folder/file2\"));\n    Assert.assertFalse(mTfs.getStatus(new TachyonURI(\"/folder/file2\")).isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status0.getFileId()));\n\n    // But top level children still should be pinned!\n    createEmptyFile(new TachyonURI(\"/file3\"));\n    URIStatus status3 = mTfs.getStatus(new TachyonURI(\"/file3\"));\n    Assert.assertTrue(status3.isPinned());\n    Assert.assertEquals(Sets.newHashSet(mFSMasterClient.getPinList()),\n        Sets.newHashSet(status0.getFileId(), status3.getFileId()));\n  }","commit_id":"048f71b2f721c6e3fcce4d4b13db516774706974","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Attempts to create a file. Overwrite will not succeed if the path exists and is a folder.\n   *\n   * @param cPath path to create\n   * @param permission permissions of the created file/folder\n   * @param overwrite overwrite if file exists\n   * @param bufferSize the size in bytes of the buffer to be used\n   * @param replication under filesystem replication factor\n   * @param blockSize block size in bytes\n   * @param progress queryable progress\n   * @return an {@link FSDataOutputStream} created at the indicated path of a file\n   * @throws IOException if overwrite is not specified and the path already exists or if the path is\n   *         a folder\n   */\n  @Override\n  public FSDataOutputStream create(Path cPath, FsPermission permission, boolean overwrite,\n      int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    LOG.info(\"create({}, {}, {}, {}, {}, {}, {})\", cPath, permission, overwrite, bufferSize,\n        replication, blockSize, progress);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n\n    // Check whether the file already exists, and delete it if overwrite is true\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    try {\n      TachyonFile file = mTFS.openIfExists(path);\n      if (file != null) {\n        if (!overwrite) {\n          throw new IOException(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(cPath.toString()));\n        }\n        FileInfo info = mTFS.getInfo(file);\n        if (info.isIsFolder()) {\n          throw new IOException(\n              ExceptionMessage.FILE_CREATE_IS_DIRECTORY.getMessage(cPath.toString()));\n        }\n        mTFS.delete(file);\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    // The file no longer exists at this point, so we can create it\n    OutStreamOptions options =\n        new OutStreamOptions.Builder(mTachyonConf).setBlockSizeBytes(blockSize).build();\n    try {\n      FileOutStream outStream = mTFS.getOutStream(path, options);\n      return new FSDataOutputStream(outStream, mStatistics);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","id":77867,"modified_method":"/**\n   * Attempts to create a file. Overwrite will not succeed if the path exists and is a folder.\n   *\n   * @param cPath path to create\n   * @param permission permissions of the created file/folder\n   * @param overwrite overwrite if file exists\n   * @param bufferSize the size in bytes of the buffer to be used\n   * @param replication under filesystem replication factor\n   * @param blockSize block size in bytes\n   * @param progress queryable progress\n   * @return an {@link FSDataOutputStream} created at the indicated path of a file\n   * @throws IOException if overwrite is not specified and the path already exists or if the path is\n   *         a folder\n   */\n  @Override\n  public FSDataOutputStream create(Path cPath, FsPermission permission, boolean overwrite,\n      int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    LOG.info(\"create({}, {}, {}, {}, {}, {}, {})\", cPath, permission, overwrite, bufferSize,\n        replication, blockSize, progress);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n\n    // Check whether the file already exists, and delete it if overwrite is true\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    try {\n      if (mTFS.exists(path)) {\n        if (!overwrite) {\n          throw new IOException(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(cPath.toString()));\n        }\n        if (mTFS.getStatus(path).isFolder()) {\n          throw new IOException(\n              ExceptionMessage.FILE_CREATE_IS_DIRECTORY.getMessage(cPath.toString()));\n        }\n        mTFS.delete(path);\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    // The file no longer exists at this point, so we can create it\n    CreateFileOptions options = CreateFileOptions.defaults().setBlockSizeBytes(blockSize);\n    try {\n      FileOutStream outStream = mTFS.createFile(path, options);\n      return new FSDataOutputStream(outStream, mStatistics);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Attempts to delete the file or directory with the specified path.\n   *\n   * @param cPath path to delete\n   * @param recursive if true, will attempt to delete all children of the path\n   * @return true if one or more files/directories were deleted; false otherwise\n   * @throws IOException if the path failed to be deleted due to some constraint (ie. non empty\n   *         directory with recursive flag disabled)\n   */\n  @Override\n  public boolean delete(Path cPath, boolean recursive) throws IOException {\n    LOG.info(\"delete({}, {})\", cPath, recursive);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    DeleteOptions options = new DeleteOptions.Builder().setRecursive(recursive).build();\n    try {\n      TachyonFile file = mTFS.open(path);\n      mTFS.delete(file, options);\n      return true;\n    } catch (InvalidPathException e) {\n      LOG.info(\"delete failed: {}\", e.getMessage());\n      return false;\n    } catch (FileDoesNotExistException e) {\n      LOG.info(\"delete failed: {}\", e.getMessage());\n      return false;\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","id":77868,"modified_method":"/**\n   * Attempts to delete the file or directory with the specified path.\n   *\n   * @param cPath path to delete\n   * @param recursive if true, will attempt to delete all children of the path\n   * @return true if one or more files/directories were deleted; false otherwise\n   * @throws IOException if the path failed to be deleted due to some constraint (ie. non empty\n   *         directory with recursive flag disabled)\n   */\n  @Override\n  public boolean delete(Path cPath, boolean recursive) throws IOException {\n    LOG.info(\"delete({}, {})\", cPath, recursive);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    DeleteOptions options = new DeleteOptions.Builder().setRecursive(recursive).build();\n    try {\n      mTFS.delete(path, options);\n      return true;\n    } catch (InvalidPathException e) {\n      LOG.info(\"delete failed: {}\", e.getMessage());\n      return false;\n    } catch (FileDoesNotExistException e) {\n      LOG.info(\"delete failed: {}\", e.getMessage());\n      return false;\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Attempts to create a folder with the specified path. Parent directories will be created.\n   *\n   * @param cPath path to create\n   * @param permission permissions to grant the created folder\n   * @return true if the indicated folder is created successfully or already exists, false otherwise\n   * @throws IOException if the folder cannot be created\n   */\n  @Override\n  public boolean mkdirs(Path cPath, FsPermission permission) throws IOException {\n    LOG.info(\"mkdirs({}, {})\", cPath, permission);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    MkdirOptions options =\n        new MkdirOptions.Builder(mTachyonConf).setRecursive(true).setAllowExists(true).build();\n    try {\n      return mTFS.mkdir(path, options);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","id":77869,"modified_method":"/**\n   * Attempts to create a folder with the specified path. Parent directories will be created.\n   *\n   * @param cPath path to create\n   * @param permission permissions to grant the created folder\n   * @return true if the indicated folder is created successfully or already exists, false otherwise\n   * @throws IOException if the folder cannot be created\n   */\n  @Override\n  public boolean mkdirs(Path cPath, FsPermission permission) throws IOException {\n    LOG.info(\"mkdirs({}, {})\", cPath, permission);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    CreateDirectoryOptions options =\n        CreateDirectoryOptions.defaults().setRecursive(true).setAllowExists(true);\n    try {\n      mTFS.createDirectory(path, options);\n      return true;\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Attempts to open the specified file for reading.\n   *\n   * @param cPath the file name to open\n   * @param bufferSize the size in bytes of the buffer to be used\n   * @return an {@link FSDataInputStream} at the indicated path of a file\n   * @throws IOException if the file cannot be opened (e.g., the path is a folder)\n   */\n  @Override\n  public FSDataInputStream open(Path cPath, int bufferSize) throws IOException {\n    LOG.info(\"open({}, {})\", cPath, bufferSize);\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    TachyonFile file = tryOpen(path);\n    long fileId = file.getFileId();\n\n    return new FSDataInputStream(new HdfsFileInputStream(fileId,\n        Utils.getHDFSPath(path, mUnderFSAddress), getConf(), bufferSize, mStatistics));\n  }","id":77870,"modified_method":"/**\n   * Attempts to open the specified file for reading.\n   *\n   * @param cPath the file name to open\n   * @param bufferSize the size in bytes of the buffer to be used\n   * @return an {@link FSDataInputStream} at the indicated path of a file\n   * @throws IOException if the file cannot be opened (e.g., the path is a folder)\n   */\n  @Override\n  public FSDataInputStream open(Path cPath, int bufferSize) throws IOException {\n    LOG.info(\"open({}, {})\", cPath, bufferSize);\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    try {\n      long fileId = mTFS.getStatus(path).getFileId();\n\n      return new FSDataInputStream(new HdfsFileInputStream(fileId,\n          Utils.getHDFSPath(path, mUnderFSAddress), getConf(), bufferSize, mStatistics));\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"rename({}, {})\", src, dst);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n\n    TachyonURI srcPath = new TachyonURI(Utils.getPathWithoutScheme(src));\n    TachyonURI dstPath = new TachyonURI(Utils.getPathWithoutScheme(dst));\n    TachyonFile srcFile = tryOpen(srcPath);\n    FileInfo info;\n    try {\n      TachyonFile file = mTFS.open(dstPath);\n      info = mTFS.getInfo(file);\n    } catch (IOException e) {\n      info = null;\n    } catch (TachyonException e) {\n      info = null;\n    }\n    // If the destination is an existing folder, try to move the src into the folder\n    if (info != null && info.isFolder) {\n      dstPath = dstPath.join(srcPath.getName());\n    }\n    try {\n      return mTFS.rename(srcFile, dstPath);\n    } catch (IOException e) {\n      LOG.error(\"Failed to rename {} to {}\", src, dst, e);\n      return false;\n    } catch (TachyonException e) {\n      LOG.error(\"Failed to rename {} to {}\", src, dst, e);\n      return false;\n    }\n  }","id":77871,"modified_method":"@Override\n  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"rename({}, {})\", src, dst);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n\n    TachyonURI srcPath = new TachyonURI(Utils.getPathWithoutScheme(src));\n    TachyonURI dstPath = new TachyonURI(Utils.getPathWithoutScheme(dst));\n    ensureExists(srcPath);\n    URIStatus dstStatus;\n    try {\n      dstStatus = mTFS.getStatus(dstPath);\n    } catch (IOException e) {\n      dstStatus = null;\n    } catch (TachyonException e) {\n      dstStatus = null;\n    }\n    // If the destination is an existing folder, try to move the src into the folder\n    if (dstStatus != null && dstStatus.isFolder()) {\n      dstPath = dstPath.join(srcPath.getName());\n    }\n    try {\n      mTFS.rename(srcPath, dstPath);\n      return true;\n    } catch (IOException e) {\n      LOG.error(\"Failed to rename {} to {}\", src, dst, e);\n      return false;\n    } catch (TachyonException e) {\n      LOG.error(\"Failed to rename {} to {}\", src, dst, e);\n      return false;\n    }\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * {@inheritDoc}\n   *\n   * If the file does not exist in Tachyon, query it from HDFS.\n   */\n  @Override\n  public FileStatus getFileStatus(Path path) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n\n    LOG.info(\"getFileStatus({}): HDFS Path: {} TPath: {}{}\", path, hdfsPath, mTachyonHeader, tPath);\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n    FileInfo fileStatus;\n    try {\n      TachyonFile file = mTFS.open(tPath);\n      fileStatus = mTFS.getInfo(file);\n    } catch (InvalidPathException e) {\n      throw new FileNotFoundException(e.getMessage());\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    FileStatus ret = new FileStatus(fileStatus.getLength(), fileStatus.isIsFolder(),\n        BLOCK_REPLICATION_CONSTANT, fileStatus.getBlockSizeBytes(), fileStatus.getCreationTimeMs(),\n        fileStatus.getCreationTimeMs(), null, null, null, new Path(mTachyonHeader + tPath));\n    return ret;\n  }","id":77872,"modified_method":"/**\n   * {@inheritDoc}\n   *\n   * If the file does not exist in Tachyon, query it from HDFS.\n   */\n  @Override\n  public FileStatus getFileStatus(Path path) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n\n    LOG.info(\"getFileStatus({}): HDFS Path: {} TPath: {}{}\", path, hdfsPath, mTachyonHeader, tPath);\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n    URIStatus fileStatus;\n    try {\n      fileStatus = mTFS.getStatus(tPath);\n    } catch (InvalidPathException e) {\n      throw new FileNotFoundException(e.getMessage());\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    FileStatus ret = new FileStatus(fileStatus.getLength(), fileStatus.isFolder(),\n        BLOCK_REPLICATION_CONSTANT, fileStatus.getBlockSizeBytes(), fileStatus.getCreationTimeMs(),\n        fileStatus.getCreationTimeMs(), null, null, null, new Path(mTachyonHeader + tPath));\n    return ret;\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FileStatus[] listStatus(Path path) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n    LOG.info(\"listStatus({}): HDFS Path: {}\", path, hdfsPath);\n\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n\n    List<FileInfo> files;\n    try {\n      TachyonFile file = mTFS.open(tPath);\n      files = mTFS.listStatus(file);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    FileStatus[] ret = new FileStatus[files.size()];\n    for (int k = 0; k < files.size(); k ++) {\n      FileInfo info = files.get(k);\n      // TODO(hy): Replicate 3 with the number of disk replications.\n      ret[k] = new FileStatus(info.getLength(), info.isFolder, 3, info.getBlockSizeBytes(),\n          info.getCreationTimeMs(), info.getCreationTimeMs(), null, null, null,\n          new Path(mTachyonHeader + info.getPath()));\n    }\n    return ret;\n  }","id":77873,"modified_method":"@Override\n  public FileStatus[] listStatus(Path path) throws IOException {\n    TachyonURI tPath = new TachyonURI(Utils.getPathWithoutScheme(path));\n    Path hdfsPath = Utils.getHDFSPath(tPath, mUnderFSAddress);\n    LOG.info(\"listStatus({}): HDFS Path: {}\", path, hdfsPath);\n\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n\n    List<URIStatus> statuses;\n    try {\n      statuses = mTFS.listStatus(tPath);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    FileStatus[] ret = new FileStatus[statuses.size()];\n    for (int k = 0; k < statuses.size(); k ++) {\n      URIStatus status = statuses.get(k);\n      // TODO(hy): Replicate 3 with the number of disk replications.\n      ret[k] = new FileStatus(status.getLength(), status.isFolder(), 3, status.getBlockSizeBytes(),\n          status.getCreationTimeMs(), status.getCreationTimeMs(), null, null, null,\n          new Path(mTachyonHeader + status.getPath()));\n    }\n    return ret;\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len)\n      throws IOException {\n    if (file == null) {\n      return null;\n    }\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(file.getPath()));\n    TachyonFile fileMetadata = tryOpen(path);\n    List<FileBlockInfo> blocks = getFileBlocks(fileMetadata.getFileId());\n\n    List<BlockLocation> blockLocations = new ArrayList<BlockLocation>();\n    for (int k = 0; k < blocks.size(); k ++) {\n      FileBlockInfo info = blocks.get(k);\n      long offset = info.getOffset();\n      long end = offset + info.blockInfo.getLength();\n      // Check if there is any overlapping between [start, start+len] and [offset, end]\n      if (end >= start && offset <= start + len) {\n        ArrayList<String> names = new ArrayList<String>();\n        ArrayList<String> hosts = new ArrayList<String>();\n        List<NetAddress> addrs = Lists.newArrayList();\n        // add the existing in-memory block locations first\n        for (tachyon.thrift.BlockLocation location : info.getBlockInfo().getLocations()) {\n          addrs.add(location.getWorkerAddress());\n        }\n        // then add under file system location\n        addrs.addAll(info.getUfsLocations());\n        for (NetAddress addr : addrs) {\n          // Name format is \"hostname:data transfer port\"\n          String name = addr.host + \":\" + addr.dataPort;\n          LOG.debug(\"getFileBlockLocations : adding name : {}\", name);\n          names.add(name);\n          hosts.add(addr.host);\n        }\n        blockLocations.add(new BlockLocation(CommonUtils.toStringArray(names),\n            CommonUtils.toStringArray(hosts), offset, info.blockInfo.getLength()));\n      }\n    }\n\n    BlockLocation[] ret = new BlockLocation[blockLocations.size()];\n    blockLocations.toArray(ret);\n    return ret;\n  }","id":77874,"modified_method":"@Override\n  public BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len)\n      throws IOException {\n    if (file == null) {\n      return null;\n    }\n    if (mStatistics != null) {\n      mStatistics.incrementReadOps(1);\n    }\n\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(file.getPath()));\n    URIStatus status;\n    try {\n      status = mTFS.getStatus(path);\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n    List<FileBlockInfo> blocks = getFileBlocks(status.getFileId());\n\n    List<BlockLocation> blockLocations = new ArrayList<BlockLocation>();\n    for (int k = 0; k < blocks.size(); k ++) {\n      FileBlockInfo info = blocks.get(k);\n      long offset = info.getOffset();\n      long end = offset + info.blockInfo.getLength();\n      // Check if there is any overlapping between [start, start+len] and [offset, end]\n      if (end >= start && offset <= start + len) {\n        ArrayList<String> names = new ArrayList<String>();\n        ArrayList<String> hosts = new ArrayList<String>();\n        List<NetAddress> addrs = Lists.newArrayList();\n        // add the existing in-memory block locations first\n        for (tachyon.thrift.BlockLocation location : info.getBlockInfo().getLocations()) {\n          addrs.add(location.getWorkerAddress());\n        }\n        // then add under file system location\n        addrs.addAll(info.getUfsLocations());\n        for (NetAddress addr : addrs) {\n          // Name format is \"hostname:data transfer port\"\n          String name = addr.host + \":\" + addr.dataPort;\n          LOG.debug(\"getFileBlockLocations : adding name : {}\", name);\n          names.add(name);\n          hosts.add(addr.host);\n        }\n        blockLocations.add(new BlockLocation(CommonUtils.toStringArray(names),\n            CommonUtils.toStringArray(hosts), offset, info.blockInfo.getLength()));\n      }\n    }\n\n    BlockLocation[] ret = new BlockLocation[blockLocations.size()];\n    blockLocations.toArray(ret);\n    return ret;\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Opens an {@link FSDataOutputStream} at the indicated Path with\n   * write-progress reporting. Same as\n   * {@link #create(Path, boolean, int, short, long, Progressable)}, except fails if parent\n   * directory doesn't already exist.\n   *\n   * TODO(hy): We need to refactor this method after having a new internal API support (TACHYON-46).\n   *\n   * @param cPath the file name to open\n   * @param overwrite if a file with this name already exists, then if true, the file will be\n   *        overwritten, and if false an error will be thrown.\n   * @param bufferSize the size of the buffer to be used\n   * @param replication required block replication for the file\n   * @param blockSize the size in bytes of the buffer to be used\n   * @param progress queryable progress\n   * @throws IOException if 1) overwrite is not specified and the path already exists, 2) if the\n   *         path is a folder, or 3) the parent directory does not exist\n   * @see {@link #setPermission(Path, FsPermission)}\n   * @deprecated API only for 0.20-append\n   */\n  @Override\n  @Deprecated\n  public FSDataOutputStream createNonRecursive(Path cPath, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)\n          throws IOException {\n    TachyonURI parentPath = new TachyonURI(Utils.getPathWithoutScheme(cPath.getParent()));\n    tryOpen(parentPath);\n    return this.create(cPath, permission, overwrite, bufferSize, replication, blockSize, progress);\n  }","id":77875,"modified_method":"/**\n   * Opens an {@link FSDataOutputStream} at the indicated Path with\n   * write-progress reporting. Same as\n   * {@link #create(Path, boolean, int, short, long, Progressable)}, except fails if parent\n   * directory doesn't already exist.\n   *\n   * TODO(hy): We need to refactor this method after having a new internal API support (TACHYON-46).\n   *\n   * @param cPath the file name to open\n   * @param overwrite if a file with this name already exists, then if true, the file will be\n   *        overwritten, and if false an error will be thrown.\n   * @param bufferSize the size of the buffer to be used\n   * @param replication required block replication for the file\n   * @param blockSize the size in bytes of the buffer to be used\n   * @param progress queryable progress\n   * @throws IOException if 1) overwrite is not specified and the path already exists, 2) if the\n   *         path is a folder, or 3) the parent directory does not exist\n   * @see {@link #setPermission(Path, FsPermission)}\n   * @deprecated API only for 0.20-append\n   */\n  @Override\n  @Deprecated\n  public FSDataOutputStream createNonRecursive(Path cPath, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)\n          throws IOException {\n    TachyonURI parentPath = new TachyonURI(Utils.getPathWithoutScheme(cPath.getParent()));\n    ensureExists(parentPath);\n    return this.create(cPath, permission, overwrite, bufferSize, replication, blockSize, progress);\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public FSDataOutputStream append(Path cPath, int bufferSize, Progressable progress)\n      throws IOException {\n    LOG.info(\"append({}, {}, {})\", cPath, bufferSize, progress);\n    if (mStatistics != null) {\n      mStatistics.incrementWriteOps(1);\n    }\n    TachyonURI path = new TachyonURI(Utils.getPathWithoutScheme(cPath));\n    TachyonFile file;\n    try {\n      file = mTFS.open(path);\n      if (mTFS.getInfo(file).length > 0) {\n        LOG.warn(\"Appending to nonempty file. This may be an error.\");\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n\n    return new FSDataOutputStream(mTFS.getOutStream(file.getFileId(), OutStreamOptions.defaults()),\n        mStatistics);\n  }","id":77876,"modified_method":"@Override\n  public FSDataOutputStream append(Path cPath, int bufferSize, Progressable progress)\n      throws IOException {\n    LOG.info(\"append({}, {}, {})\", cPath, bufferSize, progress);\n    throw new UnsupportedOperationException(\"Append is not supported in Tachyon.\");\n  }","commit_id":"b791ad5c0ef462aa79c73ae120d84eec2a8f060a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chgrpTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 10);\n    mFsShell.run(\"chgrp\", \"group1\", \"/testFile\");\n    TachyonFile tf = mTfs.open(new TachyonURI(\"/testFile\"));\n    String group = mTfs.getInfo(tf).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrp\", \"group2\", \"/testFile\");\n    group = mTfs.getInfo(tf).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","id":77877,"modified_method":"@Test\n  public void chgrpTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chgrp\", \"group1\", \"/testFile\");\n    String group = mTfs.getStatus(new TachyonURI(\"/testFile\")).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrp\", \"group2\", \"/testFile\");\n    group = mTfs.getStatus(new TachyonURI(\"/testFile\")).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chgrprTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 10);\n    mFsShell.run(\"chgrpr\", \"group1\", \"/testFolder1\");\n    TachyonFile tf = mTfs.open(new TachyonURI(\"/testFolder1/testFile\"));\n    String group = mTfs.getInfo(tf).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrpr\", \"group2\", \"/testFolder1\");\n    group = mTfs.getInfo(tf).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","id":77878,"modified_method":"@Test\n  public void chgrprTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chgrpr\", \"group1\", \"/testFolder1\");\n    String group = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrpr\", \"group2\", \"/testFolder1\");\n    group = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chmodTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 10);\n    mFsShell.run(\"chmod\", \"777\", \"/testFile\");\n    TachyonFile tf = mTfs.open(new TachyonURI(\"/testFile\"));\n    int permission = mTfs.getInfo(tf).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmod\", \"755\", \"/testFile\");\n    permission = mTfs.getInfo(tf).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","id":77879,"modified_method":"@Test\n  public void chmodTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chmod\", \"777\", \"/testFile\");\n    int permission = mTfs.getStatus(new TachyonURI(\"/testFile\")).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmod\", \"755\", \"/testFile\");\n    permission = mTfs.getStatus(new TachyonURI(\"/testFile\")).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chmodrTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 10);\n    mFsShell.run(\"chmodr\", \"777\", \"/testFolder1\");\n    TachyonFile tf = mTfs.open(new TachyonURI(\"/testFolder1\"));\n    int permission = mTfs.getInfo(tf).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmodr\", \"755\", \"/testFolder1\");\n    permission = mTfs.getInfo(tf).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","id":77880,"modified_method":"@Test\n  public void chmodrTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chmodr\", \"777\", \"/testFolder1\");\n    int permission = mTfs.getStatus(new TachyonURI(\"/testFolder1\")).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmodr\", \"755\", \"/testFolder1\");\n    permission = mTfs.getStatus(new TachyonURI(\"/testFolder1\")).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chownTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 10);\n    mFsShell.run(\"chown\", \"user1\", \"/testFile\");\n    TachyonFile tf = mTfs.open(new TachyonURI(\"/testFile\"));\n    String owner = mTfs.getInfo(tf).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chown\", \"user2\", \"/testFile\");\n    owner = mTfs.getInfo(tf).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","id":77881,"modified_method":"@Test\n  public void chownTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chown\", \"user1\", \"/testFile\");\n    String owner = mTfs.getStatus(new TachyonURI(\"/testFile\")).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chown\", \"user2\", \"/testFile\");\n    owner = mTfs.getStatus(new TachyonURI(\"/testFile\")).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chownrTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", TachyonStorageType.STORE,\n        UnderStorageType.NO_PERSIST, 10);\n    mFsShell.run(\"chownr\", \"user1\", \"/testFolder1\");\n    TachyonFile tf = mTfs.open(new TachyonURI(\"/testFolder1/testFile\"));\n    String owner = mTfs.getInfo(mTfs.open(new TachyonURI(\"/testFolder1/testFile\"))).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chownr\", \"user2\", \"/testFolder1\");\n    owner = mTfs.getInfo(tf).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","id":77882,"modified_method":"@Test\n  public void chownrTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chownr\", \"user1\", \"/testFolder1\");\n    String owner = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chownr\", \"user2\", \"/testFolder1\");\n    owner = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyMkdir(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    if (recursive) {\n      mFileSystemMaster.mkdir(new TachyonURI(path),\n          new MkdirOptions.Builder(MasterContext.getConf()).setRecursive(true).build());\n    } else {\n      mFileSystemMaster.mkdir(new TachyonURI(path), MkdirOptions.defaults());\n    }\n\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(\n        new TachyonURI(path)));\n    String[] pathComponents = path.split(\"/\");\n    Assert.assertEquals(pathComponents[pathComponents.length - 1], fileInfo.getName());\n    Assert.assertEquals(true, fileInfo.isFolder);\n    Assert.assertEquals(user.getUser(), fileInfo.getUserName());\n  }","id":77883,"modified_method":"private void verifyMkdir(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    if (recursive) {\n      mFileSystemMaster.mkdir(new TachyonURI(path),\n          new CreateDirectoryOptions.Builder(MasterContext.getConf()).setRecursive(true).build());\n    } else {\n      mFileSystemMaster.mkdir(new TachyonURI(path), CreateDirectoryOptions.defaults());\n    }\n\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(\n        new TachyonURI(path)));\n    String[] pathComponents = path.split(\"/\");\n    Assert.assertEquals(pathComponents[pathComponents.length - 1], fileInfo.getName());\n    Assert.assertEquals(true, fileInfo.isFolder);\n    Assert.assertEquals(user.getUser(), fileInfo.getUserName());\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setStateSuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    SetStateOptions expect = getNonDefaultSetState();\n    SetStateOptions result = verifySetState(TEST_USER_2, getFileId(TEST_USER_1, file), expect);\n\n    Assert.assertEquals(expect.getTtl(), result.getTtl());\n    Assert.assertEquals(expect.getPinned(), result.getPinned());\n  }","id":77884,"modified_method":"@Test\n  public void setStateSuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    SetAttributeOptions expect = getNonDefaultSetState();\n    SetAttributeOptions result = verifySetState(TEST_USER_2, file, expect);\n\n    Assert.assertEquals(expect.getTtl(), result.getTtl());\n    Assert.assertEquals(expect.getPinned(), result.getPinned());\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setStateFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    SetStateOptions expect = getNonDefaultSetState();\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testState1\")));\n    verifySetState(TEST_USER_2, getFileId(TEST_USER_1, file), expect);\n  }","id":77885,"modified_method":"@Test\n  public void setStateFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    SetAttributeOptions expect = getNonDefaultSetState();\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testState1\")));\n    verifySetState(TEST_USER_2, file, expect);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyCompleteFile(TestUser user, long fileId, CompleteFileOptions options)\n      throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    mFileSystemMaster.completeFile(fileId, options);\n  }","id":77886,"modified_method":"private void verifyCompleteFile(TestUser user, String path, CompleteFileOptions options)\n      throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    mFileSystemMaster.completeFile(new TachyonURI(path), options);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void freeNonNullDirectoryFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI + \"/testComplete1\");\n    verifyCreate(TEST_USER_1, file, false);\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testComplete1\")));\n    verifyFree(TEST_USER_2, getFileId(TEST_USER_1, file), false);\n  }","id":77887,"modified_method":"@Test\n  public void freeNonNullDirectoryFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI + \"/testComplete1\");\n    verifyCreate(TEST_USER_1, file, false);\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testComplete1\")));\n    verifyFree(TEST_USER_2, file, false);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void freeFileSuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    verifyFree(TEST_USER_2, getFileId(TEST_USER_1, file), false);\n  }","id":77888,"modified_method":"@Test\n  public void freeFileSuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    verifyFree(TEST_USER_2, file, false);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyFree(TestUser user, long fileId, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    mFileSystemMaster.free(fileId, recursive);\n  }","id":77889,"modified_method":"private void verifyFree(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    mFileSystemMaster.free(new TachyonURI(path), recursive);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyCreate(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    long fileId;\n    if (recursive) {\n      fileId = mFileSystemMaster.create(new TachyonURI(path),\n          new CreateOptions.Builder(MasterContext.getConf()).setRecursive(true).build());\n    } else {\n      fileId = mFileSystemMaster.create(new TachyonURI(path), CreateOptions.defaults());\n    }\n\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    String[] pathComponents = path.split(\"/\");\n    Assert.assertEquals(pathComponents[pathComponents.length - 1], fileInfo.getName());\n    Assert.assertEquals(user.getUser(), fileInfo.getUserName());\n  }","id":77890,"modified_method":"private void verifyCreate(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    long fileId;\n    if (recursive) {\n      fileId = mFileSystemMaster.create(new TachyonURI(path),\n          new CreateFileOptions.Builder(MasterContext.getConf()).setRecursive(true).build());\n    } else {\n      fileId = mFileSystemMaster.create(new TachyonURI(path), CreateFileOptions.defaults());\n    }\n\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    String[] pathComponents = path.split(\"/\");\n    Assert.assertEquals(pathComponents[pathComponents.length - 1], fileInfo.getName());\n    Assert.assertEquals(user.getUser(), fileInfo.getUserName());\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyRename(TestUser user, String srcPath, String dstPath) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    String fileOwner = mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(\n        new TachyonURI(srcPath))).getUserName();\n\n    mFileSystemMaster.rename(mFileSystemMaster.getFileId(new TachyonURI(srcPath)),\n        new TachyonURI(dstPath));\n\n    Assert.assertEquals(-1, mFileSystemMaster.getFileId(new TachyonURI(srcPath)));\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(\n        new TachyonURI(dstPath)));\n    String[] pathComponents = dstPath.split(\"/\");\n    Assert.assertEquals(pathComponents[pathComponents.length - 1], fileInfo.getName());\n    Assert.assertEquals(fileOwner, fileInfo.getUserName());\n  }","id":77891,"modified_method":"private void verifyRename(TestUser user, String srcPath, String dstPath) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    String fileOwner = mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(\n        new TachyonURI(srcPath))).getUserName();\n\n    mFileSystemMaster.rename(new TachyonURI(srcPath), new TachyonURI(dstPath));\n\n    Assert.assertEquals(-1, mFileSystemMaster.getFileId(new TachyonURI(srcPath)));\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(\n        new TachyonURI(dstPath)));\n    String[] pathComponents = dstPath.split(\"/\");\n    Assert.assertEquals(pathComponents[pathComponents.length - 1], fileInfo.getName());\n    Assert.assertEquals(fileOwner, fileInfo.getUserName());\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyDelete(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    mFileSystemMaster.deleteFile(mFileSystemMaster.getFileId(new TachyonURI(path)), recursive);\n\n    Assert.assertEquals(-1, mFileSystemMaster.getFileId(new TachyonURI(path)));\n  }","id":77892,"modified_method":"private void verifyDelete(TestUser user, String path, boolean recursive) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n    mFileSystemMaster.deleteFile(new TachyonURI(path), recursive);\n\n    Assert.assertEquals(-1, mFileSystemMaster.getFileId(new TachyonURI(path)));\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private SetStateOptions verifySetState(TestUser user, long fileId, SetStateOptions options)\n      throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n\n    mFileSystemMaster.setState(fileId, options);\n\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    return new SetStateOptions.Builder()\n        .setPinned(fileInfo.isIsPinned())\n        .setTtl(fileInfo.getTtl())\n        .setPersisted(fileInfo.isIsPersisted())\n        .build();\n  }","id":77893,"modified_method":"private SetAttributeOptions verifySetState(\n      TestUser user, String path, SetAttributeOptions options) throws Exception {\n    PlainSaslServer.AuthorizedClientUser.set(user.getUser());\n\n    mFileSystemMaster.setState(new TachyonURI(path), options);\n\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(new TachyonURI(path));\n    return SetAttributeOptions.defaults().setPinned(fileInfo.isIsPinned())\n        .setTtl(fileInfo.getTtl()).setPersisted(fileInfo.isIsPersisted());\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void freeNonNullDirectorySuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String subDir = PathUtils.concatPath(TEST_DIR_URI, \"/testState\");\n    verifyMkdir(TEST_USER_1, subDir, false);\n    String file = subDir + \"/testState1\";\n    verifyCreate(TEST_USER_1, file, false);\n    verifyFree(TEST_USER_2, getFileId(TEST_USER_1, subDir), true);\n  }","id":77894,"modified_method":"@Test\n  public void freeNonNullDirectorySuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String subDir = PathUtils.concatPath(TEST_DIR_URI, \"/testState\");\n    verifyMkdir(TEST_USER_1, subDir, false);\n    String file = subDir + \"/testState1\";\n    verifyCreate(TEST_USER_1, file, false);\n    verifyFree(TEST_USER_2, subDir, true);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void completeFileSuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    CompleteFileOptions expect = getNonDefaultCompleteFileOptions();\n    verifyCompleteFile(TEST_USER_2, getFileId(TEST_USER_1, file), expect);\n  }","id":77895,"modified_method":"@Test\n  public void completeFileSuccessTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"044\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testState1\");\n    verifyCreate(TEST_USER_1, file, false);\n    CompleteFileOptions expect = getNonDefaultCompleteFileOptions();\n    verifyCompleteFile(TEST_USER_2, file, expect);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void freeFileFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testComplete1\");\n    verifyCreate(TEST_USER_1, file, false);\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testComplete1\")));\n    verifyFree(TEST_USER_2, getFileId(TEST_USER_1, file), false);\n  }","id":77896,"modified_method":"@Test\n  public void freeFileFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testComplete1\");\n    verifyCreate(TEST_USER_1, file, false);\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testComplete1\")));\n    verifyFree(TEST_USER_2, file, false);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void completeFileFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testComplete1\");\n    verifyCreate(TEST_USER_1, file, false);\n    CompleteFileOptions expect = getNonDefaultCompleteFileOptions();\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testComplete1\")));\n    verifyCompleteFile(TEST_USER_2, getFileId(TEST_USER_1, file), expect);\n  }","id":77897,"modified_method":"@Test\n  public void completeFileFailTest() throws Exception {\n    // set unmask\n    TachyonConf conf = MasterContext.getConf();\n    conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSIONS_UMASK, \"066\");\n    MasterContext.reset(conf);\n\n    String file = PathUtils.concatPath(TEST_DIR_URI, \"/testComplete1\");\n    verifyCreate(TEST_USER_1, file, false);\n    CompleteFileOptions expect = getNonDefaultCompleteFileOptions();\n\n    mThrown.expect(AccessControlException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(toExceptionMessage(\n        TEST_USER_2.getUser(), FileSystemAction.WRITE, file, \"testComplete1\")));\n    verifyCompleteFile(TEST_USER_2, file, expect);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"private SetStateOptions getNonDefaultSetState() {\n    boolean recursive = true;\n    long ttl = 11;\n\n    return new SetStateOptions.Builder().setPinned(recursive).setTtl(ttl).build();\n  }","id":77898,"modified_method":"private SetAttributeOptions getNonDefaultSetState() {\n    boolean recursive = true;\n    long ttl = 11;\n\n    return SetAttributeOptions.defaults().setPinned(recursive).setTtl(ttl);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {\n      Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\",\n      Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\",\n      Constants.SECURITY_GROUP_MAPPING, FakeUserGroupsMapping.FULL_CLASS_NAME})\n  public void setAclTest() throws Exception {\n    TachyonURI filePath = new TachyonURI(\"/file\");\n\n    ClientContext.getConf().set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon\");\n    CreateFileOptions op =\n        CreateFileOptions.defaults().setBlockSizeBytes(64);\n    mTfs.createFile(filePath, op).close();\n\n    mTfs.setAcl(filePath,\n        new SetAclOptions.Builder().setOwner(\"user1\").setRecursive(false).build());\n    mTfs.setAcl(filePath,\n        new SetAclOptions.Builder().setGroup(\"group1\").setRecursive(false).build());\n    mTfs.setAcl(filePath,\n        new SetAclOptions.Builder().setPermission((short) 0400).setRecursive(false).build());\n\n    URIStatus status = mTfs.getStatus(filePath);\n\n    mLocalTachyonCluster.stopTFS();\n\n    aclTestUtil(status);\n    deleteFsMasterJournalLogs();\n    aclTestUtil(status);\n  }","id":77899,"modified_method":"@Test\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {\n      Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\",\n      Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\",\n      Constants.SECURITY_GROUP_MAPPING, FakeUserGroupsMapping.FULL_CLASS_NAME})\n  public void setAclTest() throws Exception {\n    TachyonURI filePath = new TachyonURI(\"/file\");\n\n    ClientContext.getConf().set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon\");\n    CreateFileOptions op =\n        CreateFileOptions.defaults().setBlockSizeBytes(64);\n    mTfs.createFile(filePath, op).close();\n\n    mTfs.setAcl(filePath, SetAclOptions.defaults().setOwner(\"user1\").setRecursive(false));\n    mTfs.setAcl(filePath, SetAclOptions.defaults().setGroup(\"group1\").setRecursive(false));\n    mTfs.setAcl(filePath, SetAclOptions.defaults().setPermission((short) 0400).setRecursive(false));\n\n    URIStatus status = mTfs.getStatus(filePath);\n\n    mLocalTachyonCluster.stopTFS();\n\n    aclTestUtil(status);\n    deleteFsMasterJournalLogs();\n    aclTestUtil(status);\n  }","commit_id":"a04c378167f52f264260fd940e05e91e77af55d3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Copies a list of files or directories specified by srcFiles from the local filesystem to\n   * dstPath in the Tachyon filesystem space. This method is used when the input path contains\n   * wildcards.\n   *\n   * @param srcFiles The list of files in the local filesystem\n   * @param dstPath The {@link TachyonURI} of the destination\n   * @throws IOException if a non-Tachyon related exception occurs\n   */\n  private void copyFromLocalWildcard(List<File> srcFiles, TachyonURI dstPath) throws IOException {\n    try {\n      mTfs.mkdir(dstPath);\n    } catch (FileAlreadyExistsException e) {\n      // it's fine if the directory already exists\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    FileInfo dstFileInfo;\n    try {\n      TachyonFile dstFd = mTfs.open(dstPath);\n      dstFileInfo = mTfs.getInfo(dstFd);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n    if (!dstFileInfo.isFolder) {\n      throw new IOException(\n          ExceptionMessage.DESTINATION_FILE_CANNOT_EXIST_WITH_WILDCARD_SOURCE.getMessage());\n    }\n\n    List<String> errorMessages = Lists.newArrayList();\n    for (File srcFile : srcFiles) {\n      try {\n        copyFromLocal(srcFile,\n            new TachyonURI(PathUtils.concatPath(dstPath.getPath(), srcFile.getName())));\n      } catch (IOException e) {\n        errorMessages.add(e.getMessage());\n      }\n    }\n    if (errorMessages.size() != 0) {\n      throw new IOException(Joiner.on('\\n').join(errorMessages));\n    }\n  }","id":77900,"modified_method":"/**\n   * Copies a list of files or directories specified by srcFiles from the local filesystem to\n   * dstPath in the Tachyon filesystem space. This method is used when the input path contains\n   * wildcards.\n   *\n   * @param srcFiles The list of files in the local filesystem\n   * @param dstPath The {@link TachyonURI} of the destination\n   * @throws IOException if a non-Tachyon related exception occurs\n   */\n  private void copyFromLocalWildcard(List<File> srcFiles, TachyonURI dstPath) throws IOException {\n    try {\n      mTfs.createDirectory(dstPath);\n    } catch (FileAlreadyExistsException e) {\n      // it's fine if the directory already exists\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    URIStatus dstStatus;\n    try {\n      dstStatus = mTfs.getStatus(dstPath);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n    if (!dstStatus.isFolder()) {\n      throw new IOException(\n          ExceptionMessage.DESTINATION_FILE_CANNOT_EXIST_WITH_WILDCARD_SOURCE.getMessage());\n    }\n\n    List<String> errorMessages = Lists.newArrayList();\n    for (File srcFile : srcFiles) {\n      try {\n        copyFromLocal(srcFile,\n            new TachyonURI(PathUtils.concatPath(dstPath.getPath(), srcFile.getName())));\n      } catch (IOException e) {\n        errorMessages.add(e.getMessage());\n      }\n    }\n    if (errorMessages.size() != 0) {\n      throw new IOException(Joiner.on('\\n').join(errorMessages));\n    }\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"private void copyPath(File src, TachyonURI dstPath) throws IOException {\n    try {\n      if (!src.isDirectory()) {\n        // If the dstPath is a directory, then it should be updated to be the path of the file where\n        // src will be copied to\n        TachyonFile fd = mTfs.openIfExists(dstPath);\n        if (fd != null) {\n          FileInfo tFile = mTfs.getInfo(fd);\n          if (tFile.isFolder) {\n            dstPath = dstPath.join(src.getName());\n          }\n        }\n\n        Closer closer = Closer.create();\n        FileOutStream os = null;\n        try {\n          os = closer.register(mTfs.getOutStream(dstPath, OutStreamOptions.defaults()));\n          FileInputStream in = closer.register(new FileInputStream(src));\n          FileChannel channel = closer.register(in.getChannel());\n          ByteBuffer buf = ByteBuffer.allocate(8 * Constants.MB);\n          while (channel.read(buf) != -1) {\n            buf.flip();\n            os.write(buf.array(), 0, buf.limit());\n          }\n        } catch (IOException e) {\n          // Close the out stream and delete the file, so we don't have an incomplete file lying\n          // around\n          if (os != null) {\n            os.cancel();\n            fd = mTfs.openIfExists(dstPath);\n            if (fd != null) {\n              mTfs.delete(fd);\n            }\n          }\n          throw e;\n        } finally {\n          closer.close();\n        }\n      } else {\n        mTfs.mkdir(dstPath);\n        List<String> errorMessages = Lists.newArrayList();\n        String[] fileList = src.list();\n        for (String file : fileList) {\n          TachyonURI newPath = new TachyonURI(dstPath, new TachyonURI(file));\n          File srcFile = new File(src, file);\n          try {\n            copyPath(srcFile, newPath);\n          } catch (IOException e) {\n            errorMessages.add(e.getMessage());\n          }\n        }\n        if (errorMessages.size() != 0) {\n          if (errorMessages.size() == fileList.length) {\n            // If no files were created, then delete the directory\n            TachyonFile f = mTfs.openIfExists(dstPath);\n            if (f != null) {\n              mTfs.delete(f);\n            }\n          }\n          throw new IOException(Joiner.on('\\n').join(errorMessages));\n        }\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","id":77901,"modified_method":"private void copyPath(File src, TachyonURI dstPath) throws IOException {\n    try {\n      if (!src.isDirectory()) {\n        // If the dstPath is a directory, then it should be updated to be the path of the file where\n        // src will be copied to\n        if (mTfs.exists(dstPath) && mTfs.getStatus(dstPath).isFolder()) {\n          dstPath = dstPath.join(src.getName());\n        }\n\n        Closer closer = Closer.create();\n        FileOutStream os = null;\n        try {\n          os = closer.register(mTfs.createFile(dstPath));\n          FileInputStream in = closer.register(new FileInputStream(src));\n          FileChannel channel = closer.register(in.getChannel());\n          ByteBuffer buf = ByteBuffer.allocate(8 * Constants.MB);\n          while (channel.read(buf) != -1) {\n            buf.flip();\n            os.write(buf.array(), 0, buf.limit());\n          }\n        } catch (IOException e) {\n          // Close the out stream and delete the file, so we don't have an incomplete file lying\n          // around\n          if (os != null) {\n            os.cancel();\n            if (mTfs.exists(dstPath)) {\n              mTfs.delete(dstPath);\n            }\n          }\n          throw e;\n        } finally {\n          closer.close();\n        }\n      } else {\n        mTfs.createDirectory(dstPath);\n        List<String> errorMessages = Lists.newArrayList();\n        String[] fileList = src.list();\n        for (String file : fileList) {\n          TachyonURI newPath = new TachyonURI(dstPath, new TachyonURI(file));\n          File srcFile = new File(src, file);\n          try {\n            copyPath(srcFile, newPath);\n          } catch (IOException e) {\n            errorMessages.add(e.getMessage());\n          }\n        }\n        if (errorMessages.size() != 0) {\n          if (errorMessages.size() == fileList.length) {\n            // If no files were created, then delete the directory\n            if (mTfs.exists(dstPath)) {\n              mTfs.delete(dstPath);\n            }\n          }\n          throw new IOException(Joiner.on('\\n').join(errorMessages));\n        }\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Copies a file or a directory from the Tachyon filesystem to the local filesystem.\n   *\n   * @param srcPath The source {@link TachyonURI} (could be a file or a directory)\n   * @param dstFile The destination file in the local filesystem\n   * @throws IOException\n   */\n  private void copyToLocal(TachyonURI srcPath, File dstFile) throws IOException {\n    TachyonFile srcFd;\n    FileInfo srcFileInfo;\n    try {\n      srcFd = mTfs.open(srcPath);\n      srcFileInfo = mTfs.getInfo(srcFd);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (srcFileInfo.isFolder) {\n      // make a local directory\n      if (!dstFile.exists()) {\n        if (!dstFile.mkdirs()) {\n          throw new IOException(\"mkdir failure for directory: \" + dstFile.getAbsolutePath());\n        } else {\n          System.out.println(\"Create directory: \" + dstFile.getAbsolutePath());\n        }\n      }\n\n      List<FileInfo> files = null;\n      try {\n        files = mTfs.listStatus(srcFd);\n      } catch (TachyonException e) {\n        throw new IOException(e.getMessage());\n      }\n\n      List<String> errorMessages = new ArrayList<String>();\n      for (FileInfo file : files) {\n        try {\n          copyToLocal(\n              new TachyonURI(srcPath.getScheme(), srcPath.getAuthority(), file.getPath()),\n              new File(dstFile.getAbsolutePath(), file.getName()));\n        } catch (IOException e) {\n          errorMessages.add(e.getMessage());\n        }\n      }\n\n      if (errorMessages.size() != 0) {\n        throw new IOException(Joiner.on('\\n').join(errorMessages));\n      }\n    } else {\n      copyFileToLocal(srcPath, dstFile);\n    }\n  }","id":77902,"modified_method":"/**\n   * Copies a file or a directory from the Tachyon filesystem to the local filesystem.\n   *\n   * @param srcPath The source {@link TachyonURI} (could be a file or a directory)\n   * @param dstFile The destination file in the local filesystem\n   * @throws IOException\n   */\n  private void copyToLocal(TachyonURI srcPath, File dstFile) throws IOException {\n    TachyonFile srcFd;\n    URIStatus srcStatus;\n    try {\n      srcStatus = mTfs.getStatus(srcPath);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (srcStatus.isFolder()) {\n      // make a local directory\n      if (!dstFile.exists()) {\n        if (!dstFile.mkdirs()) {\n          throw new IOException(\"mkdir failure for directory: \" + dstFile.getAbsolutePath());\n        } else {\n          System.out.println(\"Create directory: \" + dstFile.getAbsolutePath());\n        }\n      }\n\n      List<URIStatus> statuses = null;\n      try {\n        statuses = mTfs.listStatus(srcPath);\n      } catch (TachyonException e) {\n        throw new IOException(e.getMessage());\n      }\n\n      List<String> errorMessages = new ArrayList<String>();\n      for (URIStatus status : statuses) {\n        try {\n          copyToLocal(\n              new TachyonURI(srcPath.getScheme(), srcPath.getAuthority(), status.getPath()),\n              new File(dstFile.getAbsolutePath(), status.getName()));\n        } catch (IOException e) {\n          errorMessages.add(e.getMessage());\n        }\n      }\n\n      if (errorMessages.size() != 0) {\n        throw new IOException(Joiner.on('\\n').join(errorMessages));\n      }\n    } else {\n      copyFileToLocal(srcPath, dstFile);\n    }\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Copies a file specified by argv from the filesystem to the local filesystem. This is the\n   * utility function.\n   *\n   * @param srcPath The source {@link TachyonURI} (has to be a file)\n   * @param dstFile The destination file in the local filesystem\n   * @throws IOException\n   */\n  private void copyFileToLocal(TachyonURI srcPath, File dstFile) throws IOException {\n    try {\n      TachyonFile srcFd = mTfs.open(srcPath);\n      File tmpDst = File.createTempFile(\"copyToLocal\", null);\n      tmpDst.deleteOnExit();\n\n      Closer closer = Closer.create();\n      try {\n        InStreamOptions op = new InStreamOptions.Builder(mTachyonConf)\n            .setTachyonStorageType(TachyonStorageType.NO_STORE).build();\n        FileInStream is = closer.register(mTfs.getInStream(srcFd, op));\n        FileOutputStream out = closer.register(new FileOutputStream(tmpDst));\n        byte[] buf = new byte[64 * Constants.MB];\n        int t = is.read(buf);\n        while (t != -1) {\n          out.write(buf, 0, t);\n          t = is.read(buf);\n        }\n        if (!tmpDst.renameTo(dstFile)) {\n          throw new IOException(\n              \"Failed to rename \" + tmpDst.getPath() + \" to destination \" + dstFile.getPath());\n        }\n        System.out.println(\"Copied \" + srcPath + \" to \" + dstFile.getPath());\n      } finally {\n        closer.close();\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","id":77903,"modified_method":"/**\n   * Copies a file specified by argv from the filesystem to the local filesystem. This is the\n   * utility function.\n   *\n   * @param srcPath The source {@link TachyonURI} (has to be a file)\n   * @param dstFile The destination file in the local filesystem\n   * @throws IOException\n   */\n  private void copyFileToLocal(TachyonURI srcPath, File dstFile) throws IOException {\n    try {\n      File tmpDst = File.createTempFile(\"copyToLocal\", null);\n      tmpDst.deleteOnExit();\n\n      Closer closer = Closer.create();\n      try {\n        OpenFileOptions options = OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE);\n        FileInStream is = closer.register(mTfs.openFile(srcPath, options));\n        FileOutputStream out = closer.register(new FileOutputStream(tmpDst));\n        byte[] buf = new byte[64 * Constants.MB];\n        int t = is.read(buf);\n        while (t != -1) {\n          out.write(buf, 0, t);\n          t = is.read(buf);\n        }\n        if (!tmpDst.renameTo(dstFile)) {\n          throw new IOException(\n              \"Failed to rename \" + tmpDst.getPath() + \" to destination \" + dstFile.getPath());\n        }\n        System.out.println(\"Copied \" + srcPath + \" to \" + dstFile.getPath());\n      } finally {\n        closer.close();\n      }\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Calculates the size of a path (file or folder) specified by a {@link TachyonURI}.\n   *\n   * @param tachyonFS A {@link tachyon.client.file.FileSystem}\n   * @param path A {@link TachyonURI} denoting the path\n   * @return total size of the specified path in byte\n   * @throws IOException if a non-Tachyon related exception occurs\n   */\n  private long getFileOrFolderSize(FileSystem tachyonFS, TachyonURI path)\n      throws IOException {\n    long sizeInBytes = 0;\n    List<FileInfo> files;\n    try {\n      TachyonFile inputFile = tachyonFS.open(path);\n      files = tachyonFS.listStatus(inputFile);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n    for (FileInfo file : files) {\n      if (file.isFolder) {\n        TachyonURI subFolder = new TachyonURI(file.getPath());\n        sizeInBytes += getFileOrFolderSize(tachyonFS, subFolder);\n      } else {\n        sizeInBytes += file.getLength();\n      }\n    }\n    return sizeInBytes;\n  }","id":77904,"modified_method":"/**\n   * Calculates the size of a path (file or folder) specified by a {@link TachyonURI}.\n   *\n   * @param tachyonFS A {@link tachyon.client.file.FileSystem}\n   * @param path A {@link TachyonURI} denoting the path\n   * @return total size of the specified path in byte\n   * @throws IOException if a non-Tachyon related exception occurs\n   */\n  private long getFileOrFolderSize(FileSystem tachyonFS, TachyonURI path)\n      throws IOException {\n    long sizeInBytes = 0;\n    List<URIStatus> statuses;\n    try {\n      statuses = tachyonFS.listStatus(path);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n    for (URIStatus status : statuses) {\n      if (status.isFolder()) {\n        TachyonURI subFolder = new TachyonURI(status.getPath());\n        sizeInBytes += getFileOrFolderSize(tachyonFS, subFolder);\n      } else {\n        sizeInBytes += status.getLength();\n      }\n    }\n    return sizeInBytes;\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  void runCommand(TachyonURI path) throws IOException {\n    TachyonFile fd;\n    FileInfo fInfo;\n    try {\n      fd = mTfs.open(path);\n      fInfo = mTfs.getInfo(fd);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (fInfo.isFolder) {\n      throw new IOException(path + \" is a directory path so does not have file blocks.\");\n    }\n\n    System.out.println(fInfo);\n    System.out.println(\"Containing the following blocks: \");\n    for (long blockId : fInfo.getBlockIds()) {\n      System.out.println(TachyonBlockStore.get().getInfo(blockId));\n    }\n  }","id":77905,"modified_method":"@Override\n  void runCommand(TachyonURI path) throws IOException {\n    URIStatus status;\n    try {\n      status = mTfs.getStatus(path);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (status.isFolder()) {\n      throw new IOException(path + \" is a directory path so does not have file blocks.\");\n    }\n\n    System.out.println(status);\n    System.out.println(\"Containing the following blocks: \");\n    for (long blockId : status.getBlockIds()) {\n      System.out.println(TachyonBlockStore.get().getInfo(blockId));\n    }\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  void runCommand(TachyonURI path) throws IOException {\n    TachyonFile fd;\n    FileInfo fInfo;\n    try {\n      fd = mTfs.open(path);\n      fInfo = mTfs.getInfo(fd);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (fInfo.isFolder) {\n      throw new IOException(\"rm: cannot remove a directory, please try rmr <path>\");\n    }\n\n    try {\n      mTfs.delete(fd);\n      System.out.println(path + \" has been removed\");\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","id":77906,"modified_method":"@Override\n  void runCommand(TachyonURI path) throws IOException {\n    try {\n      if (!mTfs.exists(path)) {\n        throw new IOException(\"rm: path \" + path + \" to remove does not exist.\");\n      }\n      if (mTfs.getStatus(path).isFolder()) {\n        throw new IOException(\"rm: cannot remove a directory, please try rmr <path>\");\n      }\n      mTfs.delete(path);\n      System.out.println(path + \" has been removed\");\n    } catch (TachyonException e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"public TfsShell(TachyonConf tachyonConf) {\n    mTachyonConf = tachyonConf;\n    mCloser = Closer.create();\n    mTfs = TachyonFileSystemFactory.get();\n    loadCommands();\n  }","id":77907,"modified_method":"public TfsShell(TachyonConf tachyonConf) {\n    mTachyonConf = tachyonConf;\n    mCloser = Closer.create();\n    mTfs = FileSystem.Factory.create();\n    loadCommands();\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void run(String... args) throws IOException {\n    TachyonURI inputPath = new TachyonURI(args[0]);\n\n    try {\n      mTfs.getOutStream(inputPath, new OutStreamOptions.Builder(mTachyonConf)\n          .setUnderStorageType(UnderStorageType.SYNC_PERSIST).build()).close();\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n    System.out.println(inputPath + \" has been created\");\n  }","id":77908,"modified_method":"@Override\n  public void run(String... args) throws IOException {\n    TachyonURI inputPath = new TachyonURI(args[0]);\n\n    try {\n      mTfs.createFile(inputPath, CreateFileOptions.defaults().setWriteType(WriteType.CACHE_THROUGH))\n          .close();\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n    System.out.println(inputPath + \" has been created\");\n  }","commit_id":"04e5fac9fd99e757f620b34a6c4977f07997caa6","url":"https://github.com/amplab/tachyon"},{"original_method":"public void createApplyVpnCommands(final boolean isCreate, final RemoteAccessVpn vpn, final VirtualRouter router, final Commands cmds) {\n        final List<VpnUserVO> vpnUsers = _vpnUsersDao.listByAccount(vpn.getAccountId());\n\n        createApplyVpnUsersCommand(vpnUsers, router, cmds);\n\n        final IpAddress ip = _networkModel.getIp(vpn.getServerAddressId());\n\n        // This block is needed due to the line 206 of the\n        // RemoteAccessVpnManagenerImpl:\n        // TODO: assumes one virtual network / domr per account per zone\n        final String cidr;\n        final Network network = _networkDao.findById(vpn.getNetworkId());\n        if (network == null) {\n            Vpc vpc = _vpcDao.findById(vpn.getVpcId());\n            cidr = vpc.getCidr();\n        } else {\n            cidr = network.getCidr();\n        }\n\n        final RemoteAccessVpnCfgCommand startVpnCmd = new RemoteAccessVpnCfgCommand(isCreate, ip.getAddress().addr(), vpn.getLocalIp(), vpn.getIpRange(),\n                vpn.getIpsecPresharedKey(), vpn.getVpcId() != null);\n        startVpnCmd.setLocalCidr(cidr);\n        startVpnCmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n        startVpnCmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n        final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n        startVpnCmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n        cmds.addCommand(\"startVpn\", startVpnCmd);\n    }","id":77909,"modified_method":"public void createApplyVpnCommands(final boolean isCreate, final RemoteAccessVpn vpn, final VirtualRouter router, final Commands cmds) {\n        final List<VpnUserVO> vpnUsers = _vpnUsersDao.listByAccount(vpn.getAccountId());\n\n        createApplyVpnUsersCommand(vpnUsers, router, cmds);\n\n        final IpAddress ip = _networkModel.getIp(vpn.getServerAddressId());\n\n        // This block is needed due to the line 206 of the\n        // RemoteAccessVpnManagenerImpl:\n        // TODO: assumes one virtual network / domr per account per zone\n        final String cidr;\n        final Network network = _networkDao.findById(vpn.getNetworkId());\n        if (network == null) {\n            final Vpc vpc = _vpcDao.findById(vpn.getVpcId());\n            cidr = vpc.getCidr();\n        } else {\n            cidr = network.getCidr();\n        }\n\n        final RemoteAccessVpnCfgCommand startVpnCmd = new RemoteAccessVpnCfgCommand(isCreate, ip.getAddress().addr(), vpn.getLocalIp(), vpn.getIpRange(),\n                vpn.getIpsecPresharedKey(), vpn.getVpcId() != null);\n        startVpnCmd.setLocalCidr(cidr);\n        startVpnCmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n        startVpnCmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n        final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n        startVpnCmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n        cmds.addCommand(\"startVpn\", startVpnCmd);\n    }","commit_id":"2ed64b2356143d8b70a343b71424ebfd31badc71","url":"https://github.com/apache/cloudstack"},{"original_method":"public void createDhcpEntryCommand(final VirtualRouter router, final UserVm vm, final NicVO nic, final Commands cmds) {\n        final DhcpEntryCommand dhcpCommand = new DhcpEntryCommand(nic.getMacAddress(), nic.getIp4Address(), vm.getHostName(), nic.getIp6Address(),\n                _networkModel.getExecuteInSeqNtwkElmtCmd());\n\n        String gatewayIp = nic.getGateway();\n        if (!nic.isDefaultNic()) {\n            GuestOSVO guestOS = _guestOSDao.findById(vm.getGuestOSId());\n            if (guestOS == null || !guestOS.getDisplayName().toLowerCase().contains(\"windows\")) {\n                gatewayIp = \"0.0.0.0\";\n            }\n        }\n\n        final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n\n        dhcpCommand.setDefaultRouter(gatewayIp);\n        dhcpCommand.setIp6Gateway(nic.getIp6Gateway());\n        String ipaddress = null;\n        final NicVO domrDefaultNic = findDefaultDnsIp(vm.getId());\n        if (domrDefaultNic != null) {\n            ipaddress = domrDefaultNic.getIp4Address();\n        }\n        dhcpCommand.setDefaultDns(ipaddress);\n        dhcpCommand.setDuid(NetUtils.getDuidLL(nic.getMacAddress()));\n        dhcpCommand.setDefault(nic.isDefaultNic());\n\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, _routerControlHelper.getRouterIpInNetwork(nic.getNetworkId(), router.getId()));\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n        cmds.addCommand(\"dhcp\", dhcpCommand);\n    }","id":77910,"modified_method":"public void createDhcpEntryCommand(final VirtualRouter router, final UserVm vm, final NicVO nic, final Commands cmds) {\n        final DhcpEntryCommand dhcpCommand = new DhcpEntryCommand(nic.getMacAddress(), nic.getIp4Address(), vm.getHostName(), nic.getIp6Address(),\n                _networkModel.getExecuteInSeqNtwkElmtCmd());\n\n        String gatewayIp = nic.getGateway();\n        if (!nic.isDefaultNic()) {\n            final GuestOSVO guestOS = _guestOSDao.findById(vm.getGuestOSId());\n            if (guestOS == null || !guestOS.getDisplayName().toLowerCase().contains(\"windows\")) {\n                gatewayIp = \"0.0.0.0\";\n            }\n        }\n\n        final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n\n        dhcpCommand.setDefaultRouter(gatewayIp);\n        dhcpCommand.setIp6Gateway(nic.getIp6Gateway());\n        String ipaddress = null;\n        final NicVO domrDefaultNic = findDefaultDnsIp(vm.getId());\n        if (domrDefaultNic != null) {\n            ipaddress = domrDefaultNic.getIp4Address();\n        }\n        dhcpCommand.setDefaultDns(ipaddress);\n        dhcpCommand.setDuid(NetUtils.getDuidLL(nic.getMacAddress()));\n        dhcpCommand.setDefault(nic.isDefaultNic());\n\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, _routerControlHelper.getRouterIpInNetwork(nic.getNetworkId(), router.getId()));\n        dhcpCommand.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n        cmds.addCommand(\"dhcp\", dhcpCommand);\n    }","commit_id":"2ed64b2356143d8b70a343b71424ebfd31badc71","url":"https://github.com/apache/cloudstack"},{"original_method":"public void createVpcAssociatePublicIPCommands(final VirtualRouter router, final List<? extends PublicIpAddress> ips, final Commands cmds,\n            final Map<String, String> vlanMacAddress) {\n\n        Pair<IpAddressTO, Long> sourceNatIpAdd = null;\n        Boolean addSourceNat = null;\n        // Ensure that in multiple vlans case we first send all ip addresses of\n        // vlan1, then all ip addresses of vlan2, etc..\n        final Map<String, ArrayList<PublicIpAddress>> vlanIpMap = new HashMap<String, ArrayList<PublicIpAddress>>();\n        for (final PublicIpAddress ipAddress : ips) {\n            final String vlanTag = ipAddress.getVlanTag();\n            ArrayList<PublicIpAddress> ipList = vlanIpMap.get(vlanTag);\n            if (ipList == null) {\n                ipList = new ArrayList<PublicIpAddress>();\n            }\n            // VR doesn't support release for sourceNat IP address; so reset the\n            // state\n            if (ipAddress.isSourceNat() && ipAddress.getState() == IpAddress.State.Releasing) {\n                ipAddress.setState(IpAddress.State.Allocated);\n            }\n            ipList.add(ipAddress);\n            vlanIpMap.put(vlanTag, ipList);\n        }\n\n        for (final Map.Entry<String, ArrayList<PublicIpAddress>> vlanAndIp : vlanIpMap.entrySet()) {\n            final List<PublicIpAddress> ipAddrList = vlanAndIp.getValue();\n\n            // Get network rate - required for IpAssoc\n            final Integer networkRate = _networkModel.getNetworkRate(ipAddrList.get(0).getNetworkId(), router.getId());\n            final Network network = _networkModel.getNetwork(ipAddrList.get(0).getNetworkId());\n\n            final IpAddressTO[] ipsToSend = new IpAddressTO[ipAddrList.size()];\n            int i = 0;\n\n            for (final PublicIpAddress ipAddr : ipAddrList) {\n                final boolean add = ipAddr.getState() == IpAddress.State.Releasing ? false : true;\n\n                final String macAddress = vlanMacAddress.get(BroadcastDomainType.getValue(BroadcastDomainType.fromString(ipAddr.getVlanTag())));\n\n                final IpAddressTO ip = new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, false, ipAddr.isSourceNat(), ipAddr.getVlanTag(),\n                        ipAddr.getGateway(), ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());\n\n                ip.setTrafficType(network.getTrafficType());\n                ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));\n                ipsToSend[i++] = ip;\n                if (ipAddr.isSourceNat()) {\n                    sourceNatIpAdd = new Pair<IpAddressTO, Long>(ip, ipAddr.getNetworkId());\n                    addSourceNat = add;\n                }\n            }\n            final IpAssocVpcCommand cmd = new IpAssocVpcCommand(ipsToSend);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, _routerControlHelper.getRouterIpInNetwork(ipAddrList.get(0).getNetworkId(), router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n            cmds.addCommand(\"IPAssocVpcCommand\", cmd);\n        }\n\n        // set source nat ip\n        if (sourceNatIpAdd != null) {\n            final IpAddressTO sourceNatIp = sourceNatIpAdd.first();\n            final SetSourceNatCommand cmd = new SetSourceNatCommand(sourceNatIp, addSourceNat);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n            cmds.addCommand(\"SetSourceNatCommand\", cmd);\n        }\n    }","id":77911,"modified_method":"public void createVpcAssociatePublicIPCommands(final VirtualRouter router, final List<? extends PublicIpAddress> ips, final Commands cmds,\n            final Map<String, String> vlanMacAddress) {\n\n        Pair<IpAddressTO, Long> sourceNatIpAdd = null;\n        Boolean addSourceNat = null;\n        // Ensure that in multiple vlans case we first send all ip addresses of\n        // vlan1, then all ip addresses of vlan2, etc..\n        final Map<String, ArrayList<PublicIpAddress>> vlanIpMap = new HashMap<String, ArrayList<PublicIpAddress>>();\n        for (final PublicIpAddress ipAddress : ips) {\n            final String vlanTag = ipAddress.getVlanTag();\n            ArrayList<PublicIpAddress> ipList = vlanIpMap.get(vlanTag);\n            if (ipList == null) {\n                ipList = new ArrayList<PublicIpAddress>();\n            }\n            // VR doesn't support release for sourceNat IP address; so reset the\n            // state\n            if (ipAddress.isSourceNat() && ipAddress.getState() == IpAddress.State.Releasing) {\n                ipAddress.setState(IpAddress.State.Allocated);\n            }\n            ipList.add(ipAddress);\n            vlanIpMap.put(vlanTag, ipList);\n        }\n\n        for (final Map.Entry<String, ArrayList<PublicIpAddress>> vlanAndIp : vlanIpMap.entrySet()) {\n            final List<PublicIpAddress> ipAddrList = vlanAndIp.getValue();\n\n            // Get network rate - required for IpAssoc\n            final Integer networkRate = _networkModel.getNetworkRate(ipAddrList.get(0).getNetworkId(), router.getId());\n            final Network network = _networkModel.getNetwork(ipAddrList.get(0).getNetworkId());\n\n            final IpAddressTO[] ipsToSend = new IpAddressTO[ipAddrList.size()];\n            int i = 0;\n\n            for (final PublicIpAddress ipAddr : ipAddrList) {\n                final boolean add = ipAddr.getState() == IpAddress.State.Releasing ? false : true;\n\n                final String macAddress = vlanMacAddress.get(BroadcastDomainType.getValue(BroadcastDomainType.fromString(ipAddr.getVlanTag())));\n\n                final IpAddressTO ip = new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, false, ipAddr.isSourceNat(), BroadcastDomainType.fromString(ipAddr.getVlanTag()).toString(), ipAddr.getGateway(),\n                        ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());\n\n                ip.setTrafficType(network.getTrafficType());\n                ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));\n                ipsToSend[i++] = ip;\n                if (ipAddr.isSourceNat()) {\n                    sourceNatIpAdd = new Pair<IpAddressTO, Long>(ip, ipAddr.getNetworkId());\n                    addSourceNat = add;\n                }\n            }\n            final IpAssocVpcCommand cmd = new IpAssocVpcCommand(ipsToSend);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, _routerControlHelper.getRouterIpInNetwork(ipAddrList.get(0).getNetworkId(), router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n            cmds.addCommand(\"IPAssocVpcCommand\", cmd);\n        }\n\n        // set source nat ip\n        if (sourceNatIpAdd != null) {\n            final IpAddressTO sourceNatIp = sourceNatIpAdd.first();\n            final SetSourceNatCommand cmd = new SetSourceNatCommand(sourceNatIp, addSourceNat);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n            cmds.addCommand(\"SetSourceNatCommand\", cmd);\n        }\n    }","commit_id":"2ed64b2356143d8b70a343b71424ebfd31badc71","url":"https://github.com/apache/cloudstack"},{"original_method":"public void createStaticRouteCommands(final List<StaticRouteProfile> staticRoutes, final VirtualRouter router, final Commands cmds) {\n        SetStaticRouteCommand cmd = new SetStaticRouteCommand(staticRoutes);\n        cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n        cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n        final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n        cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n        cmds.addCommand(cmd);\n    }","id":77912,"modified_method":"public void createStaticRouteCommands(final List<StaticRouteProfile> staticRoutes, final VirtualRouter router, final Commands cmds) {\n        final SetStaticRouteCommand cmd = new SetStaticRouteCommand(staticRoutes);\n        cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, _routerControlHelper.getRouterControlIp(router.getId()));\n        cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n        final DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n        cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n        cmds.addCommand(cmd);\n    }","commit_id":"2ed64b2356143d8b70a343b71424ebfd31badc71","url":"https://github.com/apache/cloudstack"},{"original_method":"private void createVpcAssociatePublicIPCommands(final VirtualRouter router, final List<? extends PublicIpAddress> ips, Commands cmds,\n            Map<String, String> vlanMacAddress) {\n\n        Pair<IpAddressTO, Long> sourceNatIpAdd = null;\n        Boolean addSourceNat = null;\n        // Ensure that in multiple vlans case we first send all ip addresses of vlan1, then all ip addresses of vlan2, etc..\n        Map<String, ArrayList<PublicIpAddress>> vlanIpMap = new HashMap<String, ArrayList<PublicIpAddress>>();\n        for (final PublicIpAddress ipAddress : ips) {\n            String vlanTag = ipAddress.getVlanTag();\n            ArrayList<PublicIpAddress> ipList = vlanIpMap.get(vlanTag);\n            if (ipList == null) {\n                ipList = new ArrayList<PublicIpAddress>();\n            }\n            //VR doesn't support release for sourceNat IP address; so reset the state\n            if (ipAddress.isSourceNat() && ipAddress.getState() == IpAddress.State.Releasing) {\n                ipAddress.setState(IpAddress.State.Allocated);\n            }\n            ipList.add(ipAddress);\n            vlanIpMap.put(vlanTag, ipList);\n        }\n\n        for (Map.Entry<String, ArrayList<PublicIpAddress>> vlanAndIp : vlanIpMap.entrySet()) {\n            List<PublicIpAddress> ipAddrList = vlanAndIp.getValue();\n\n            // Get network rate - required for IpAssoc\n            Integer networkRate = _networkModel.getNetworkRate(ipAddrList.get(0).getNetworkId(), router.getId());\n            Network network = _networkModel.getNetwork(ipAddrList.get(0).getNetworkId());\n\n            IpAddressTO[] ipsToSend = new IpAddressTO[ipAddrList.size()];\n            int i = 0;\n\n            for (final PublicIpAddress ipAddr : ipAddrList) {\n                boolean add = (ipAddr.getState() == IpAddress.State.Releasing ? false : true);\n\n                String macAddress = vlanMacAddress.get(BroadcastDomainType.getValue(BroadcastDomainType.fromString(ipAddr.getVlanTag())));\n\n                IpAddressTO ip =\n                        new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, false, ipAddr.isSourceNat(), ipAddr.getVlanTag(), ipAddr.getGateway(),\n                                ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());\n\n                ip.setTrafficType(network.getTrafficType());\n                ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));\n                ipsToSend[i++] = ip;\n                if (ipAddr.isSourceNat()) {\n                    sourceNatIpAdd = new Pair<IpAddressTO, Long>(ip, ipAddr.getNetworkId());\n                    addSourceNat = add;\n                }\n            }\n            IpAssocVpcCommand cmd = new IpAssocVpcCommand(ipsToSend);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, getRouterIpInNetwork(ipAddrList.get(0).getNetworkId(), router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n            cmds.addCommand(\"IPAssocVpcCommand\", cmd);\n        }\n\n        //set source nat ip\n        if (sourceNatIpAdd != null) {\n            IpAddressTO sourceNatIp = sourceNatIpAdd.first();\n            SetSourceNatCommand cmd = new SetSourceNatCommand(sourceNatIp, addSourceNat);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n            cmds.addCommand(\"SetSourceNatCommand\", cmd);\n        }\n    }","id":77913,"modified_method":"private void createVpcAssociatePublicIPCommands(final VirtualRouter router, final List<? extends PublicIpAddress> ips, Commands cmds,\n            Map<String, String> vlanMacAddress) {\n\n        Pair<IpAddressTO, Long> sourceNatIpAdd = null;\n        Boolean addSourceNat = null;\n        // Ensure that in multiple vlans case we first send all ip addresses of vlan1, then all ip addresses of vlan2, etc..\n        Map<String, ArrayList<PublicIpAddress>> vlanIpMap = new HashMap<String, ArrayList<PublicIpAddress>>();\n        for (final PublicIpAddress ipAddress : ips) {\n            String vlanTag = ipAddress.getVlanTag();\n            ArrayList<PublicIpAddress> ipList = vlanIpMap.get(vlanTag);\n            if (ipList == null) {\n                ipList = new ArrayList<PublicIpAddress>();\n            }\n            //VR doesn't support release for sourceNat IP address; so reset the state\n            if (ipAddress.isSourceNat() && ipAddress.getState() == IpAddress.State.Releasing) {\n                ipAddress.setState(IpAddress.State.Allocated);\n            }\n            ipList.add(ipAddress);\n            vlanIpMap.put(vlanTag, ipList);\n        }\n\n        for (Map.Entry<String, ArrayList<PublicIpAddress>> vlanAndIp : vlanIpMap.entrySet()) {\n            List<PublicIpAddress> ipAddrList = vlanAndIp.getValue();\n\n            // Get network rate - required for IpAssoc\n            Integer networkRate = _networkModel.getNetworkRate(ipAddrList.get(0).getNetworkId(), router.getId());\n            Network network = _networkModel.getNetwork(ipAddrList.get(0).getNetworkId());\n\n            IpAddressTO[] ipsToSend = new IpAddressTO[ipAddrList.size()];\n            int i = 0;\n\n            for (final PublicIpAddress ipAddr : ipAddrList) {\n                boolean add = (ipAddr.getState() == IpAddress.State.Releasing ? false : true);\n\n                String macAddress = vlanMacAddress.get(BroadcastDomainType.getValue(BroadcastDomainType.fromString(ipAddr.getVlanTag())));\n\n                IpAddressTO ip =\n                        new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, false, ipAddr.isSourceNat(), BroadcastDomainType.fromString(ipAddr.getVlanTag()).toString(), ipAddr.getGateway(),\n                                ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());\n\n                ip.setTrafficType(network.getTrafficType());\n                ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));\n                ipsToSend[i++] = ip;\n                if (ipAddr.isSourceNat()) {\n                    sourceNatIpAdd = new Pair<IpAddressTO, Long>(ip, ipAddr.getNetworkId());\n                    addSourceNat = add;\n                }\n            }\n            IpAssocVpcCommand cmd = new IpAssocVpcCommand(ipsToSend);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, getRouterIpInNetwork(ipAddrList.get(0).getNetworkId(), router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n            cmds.addCommand(\"IPAssocVpcCommand\", cmd);\n        }\n\n        //set source nat ip\n        if (sourceNatIpAdd != null) {\n            IpAddressTO sourceNatIp = sourceNatIpAdd.first();\n            SetSourceNatCommand cmd = new SetSourceNatCommand(sourceNatIp, addSourceNat);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n            cmds.addCommand(\"SetSourceNatCommand\", cmd);\n        }\n    }","commit_id":"c10189f79aa1d9be1d01bb2ff1b6d7406e2ea7e1","url":"https://github.com/apache/cloudstack"},{"original_method":"private void createVpcAssociatePublicIPCommands(final VirtualRouter router, final List<? extends PublicIpAddress> ips, Commands cmds,\n            Map<String, String> vlanMacAddress) {\n\n        Pair<IpAddressTO, Long> sourceNatIpAdd = null;\n        Boolean addSourceNat = null;\n        // Ensure that in multiple vlans case we first send all ip addresses of vlan1, then all ip addresses of vlan2, etc..\n        Map<String, ArrayList<PublicIpAddress>> vlanIpMap = new HashMap<String, ArrayList<PublicIpAddress>>();\n        for (final PublicIpAddress ipAddress : ips) {\n            String vlanTag = ipAddress.getVlanTag();\n            ArrayList<PublicIpAddress> ipList = vlanIpMap.get(vlanTag);\n            if (ipList == null) {\n                ipList = new ArrayList<PublicIpAddress>();\n            }\n            //VR doesn't support release for sourceNat IP address; so reset the state\n            if (ipAddress.isSourceNat() && ipAddress.getState() == IpAddress.State.Releasing) {\n                ipAddress.setState(IpAddress.State.Allocated);\n            }\n            ipList.add(ipAddress);\n            vlanIpMap.put(vlanTag, ipList);\n        }\n\n        for (Map.Entry<String, ArrayList<PublicIpAddress>> vlanAndIp : vlanIpMap.entrySet()) {\n            List<PublicIpAddress> ipAddrList = vlanAndIp.getValue();\n\n            // Get network rate - required for IpAssoc\n            Integer networkRate = _networkModel.getNetworkRate(ipAddrList.get(0).getNetworkId(), router.getId());\n            Network network = _networkModel.getNetwork(ipAddrList.get(0).getNetworkId());\n\n            IpAddressTO[] ipsToSend = new IpAddressTO[ipAddrList.size()];\n            int i = 0;\n\n            for (final PublicIpAddress ipAddr : ipAddrList) {\n                boolean add = (ipAddr.getState() == IpAddress.State.Releasing ? false : true);\n\n                String macAddress = vlanMacAddress.get(BroadcastDomainType.getValue(BroadcastDomainType.fromString(ipAddr.getVlanTag())));\n\n                IpAddressTO ip =\n                        new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, false, ipAddr.isSourceNat(), ipAddr.getVlanTag(), ipAddr.getGateway(),\n                                ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());\n\n                ip.setTrafficType(network.getTrafficType());\n                ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));\n                ipsToSend[i++] = ip;\n                if (ipAddr.isSourceNat()) {\n                    sourceNatIpAdd = new Pair<IpAddressTO, Long>(ip, ipAddr.getNetworkId());\n                    addSourceNat = add;\n                }\n            }\n            IpAssocVpcCommand cmd = new IpAssocVpcCommand(ipsToSend);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, getRouterIpInNetwork(ipAddrList.get(0).getNetworkId(), router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n            cmds.addCommand(\"IPAssocVpcCommand\", cmd);\n        }\n\n        //set source nat ip\n        if (sourceNatIpAdd != null) {\n            IpAddressTO sourceNatIp = sourceNatIpAdd.first();\n            SetSourceNatCommand cmd = new SetSourceNatCommand(sourceNatIp, addSourceNat);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n            cmds.addCommand(\"SetSourceNatCommand\", cmd);\n        }\n    }","id":77914,"modified_method":"private void createVpcAssociatePublicIPCommands(final VirtualRouter router, final List<? extends PublicIpAddress> ips, Commands cmds,\n            Map<String, String> vlanMacAddress) {\n\n        Pair<IpAddressTO, Long> sourceNatIpAdd = null;\n        Boolean addSourceNat = null;\n        // Ensure that in multiple vlans case we first send all ip addresses of vlan1, then all ip addresses of vlan2, etc..\n        Map<String, ArrayList<PublicIpAddress>> vlanIpMap = new HashMap<String, ArrayList<PublicIpAddress>>();\n        for (final PublicIpAddress ipAddress : ips) {\n            String vlanTag = ipAddress.getVlanTag();\n            ArrayList<PublicIpAddress> ipList = vlanIpMap.get(vlanTag);\n            if (ipList == null) {\n                ipList = new ArrayList<PublicIpAddress>();\n            }\n            //VR doesn't support release for sourceNat IP address; so reset the state\n            if (ipAddress.isSourceNat() && ipAddress.getState() == IpAddress.State.Releasing) {\n                ipAddress.setState(IpAddress.State.Allocated);\n            }\n            ipList.add(ipAddress);\n            vlanIpMap.put(vlanTag, ipList);\n        }\n\n        for (Map.Entry<String, ArrayList<PublicIpAddress>> vlanAndIp : vlanIpMap.entrySet()) {\n            List<PublicIpAddress> ipAddrList = vlanAndIp.getValue();\n\n            // Get network rate - required for IpAssoc\n            Integer networkRate = _networkModel.getNetworkRate(ipAddrList.get(0).getNetworkId(), router.getId());\n            Network network = _networkModel.getNetwork(ipAddrList.get(0).getNetworkId());\n\n            IpAddressTO[] ipsToSend = new IpAddressTO[ipAddrList.size()];\n            int i = 0;\n\n            for (final PublicIpAddress ipAddr : ipAddrList) {\n                boolean add = (ipAddr.getState() == IpAddress.State.Releasing ? false : true);\n\n                String macAddress = vlanMacAddress.get(BroadcastDomainType.getValue(BroadcastDomainType.fromString(ipAddr.getVlanTag())));\n\n                IpAddressTO ip =\n                        new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, false, ipAddr.isSourceNat(), BroadcastDomainType.fromString(ipAddr.getVlanTag()).toString(), ipAddr.getGateway(),\n                                ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());\n\n                ip.setTrafficType(network.getTrafficType());\n                ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));\n                ipsToSend[i++] = ip;\n                if (ipAddr.isSourceNat()) {\n                    sourceNatIpAdd = new Pair<IpAddressTO, Long>(ip, ipAddr.getNetworkId());\n                    addSourceNat = add;\n                }\n            }\n            IpAssocVpcCommand cmd = new IpAssocVpcCommand(ipsToSend);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_GUEST_IP, getRouterIpInNetwork(ipAddrList.get(0).getNetworkId(), router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n\n            cmds.addCommand(\"IPAssocVpcCommand\", cmd);\n        }\n\n        //set source nat ip\n        if (sourceNatIpAdd != null) {\n            IpAddressTO sourceNatIp = sourceNatIpAdd.first();\n            SetSourceNatCommand cmd = new SetSourceNatCommand(sourceNatIp, addSourceNat);\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_IP, getRouterControlIp(router.getId()));\n            cmd.setAccessDetail(NetworkElementCommand.ROUTER_NAME, router.getInstanceName());\n            DataCenterVO dcVo = _dcDao.findById(router.getDataCenterId());\n            cmd.setAccessDetail(NetworkElementCommand.ZONE_NETWORK_TYPE, dcVo.getNetworkType().toString());\n            cmds.addCommand(\"SetSourceNatCommand\", cmd);\n        }\n    }","commit_id":"6b8e0baa21e6cffc62eb2d35eecc7aeb2087d1c1","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n\t * By default this returns \"onclick\" uses can overwrite this on which event the label behavior\n\t * should be triggered\n\t * \n\t * @return The event name\n\t */\n\tprotected String getLabelAjaxEvent()\n\t{\n\t\treturn \"onclick\";\n\t}","id":77915,"modified_method":"/**\n\t * By default this returns \"onclick\" uses can overwrite this on which event the label behavior\n\t * should be triggered\n\t * \n\t * @return The event name\n\t */\n\tprotected String getLabelAjaxEvent()\n\t{\n\t\treturn \"click\";\n\t}","commit_id":"be8a4eaaf1537059b78d8d0994a6361cb8fbaa76","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Invoked when the label is in edit mode, received a new input, but that input didn't validate\n\t * \n\t * @param target\n\t *            the ajax request target\n\t */\n\tprotected void onError(final AjaxRequestTarget target)\n\t{\n\t\tif (editor.hasErrorMessage())\n\t\t{\n\t\t\tSerializable errorMessage = editor.getFeedbackMessages().first(FeedbackMessage.ERROR);\n\t\t\ttarget.appendJavaScript(\"window.status='\" +\n\t\t\t\tJavaScriptUtils.escapeQuotes(errorMessage.toString()) + \"';\");\n\t\t}\n\t\ttarget.appendJavaScript(\"{var el=Wicket.$('\" + editor.getMarkupId() +\n\t\t\t\"'); el.select(); el.focus();}\");\n\t}","id":77916,"modified_method":"/**\n\t * Invoked when the label is in edit mode, received a new input, but that input didn't validate\n\t * \n\t * @param target\n\t *            the ajax request target\n\t */\n\tprotected void onError(final AjaxRequestTarget target)\n\t{\n\t\tif (editor.hasErrorMessage())\n\t\t{\n\t\t\tSerializable errorMessage = editor.getFeedbackMessages().first(FeedbackMessage.ERROR);\n\t\t\ttarget.appendJavaScript(\"window.status='\" +\n\t\t\t\tJavaScriptUtils.escapeQuotes(errorMessage.toString()) + \"';\");\n\t\t}\n\t\tString selectAndFocusScript = String.format(\"(function(){var el=Wicket.$('%s'); if (el.select) el.select(); el.focus();})()\",\n\t\t\t\teditor.getMarkupId());\n\t\ttarget.appendJavaScript(selectAndFocusScript);\n\t}","commit_id":"be8a4eaaf1537059b78d8d0994a6361cb8fbaa76","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Called when the label is clicked and the component is put in edit mode.\n\t * \n\t * @param target\n\t *            Ajax target\n\t */\n\tpublic void onEdit(final AjaxRequestTarget target)\n\t{\n\t\tlabel.setVisible(false);\n\t\teditor.setVisible(true);\n\t\ttarget.add(AjaxEditableLabel.this);\n\t\t// put focus on the textfield and stupid explorer hack to move the\n\t\t// caret to the end\n\t\ttarget.appendJavaScript(\"{ var el=Wicket.$('\" + editor.getMarkupId() + \"');\" +\n\t\t\t\"   if (el.createTextRange) { \" +\n\t\t\t\"     var v = el.value; var r = el.createTextRange(); \" +\n\t\t\t\"     r.moveStart('character', v.length); r.select(); } }\");\n\t\ttarget.focusComponent(editor);\n\t}","id":77917,"modified_method":"/**\n\t * Called when the label is clicked and the component is put in edit mode.\n\t * \n\t * @param target\n\t *            Ajax target\n\t */\n\tpublic void onEdit(final AjaxRequestTarget target)\n\t{\n\t\tlabel.setVisible(false);\n\t\teditor.setVisible(true);\n\t\ttarget.add(AjaxEditableLabel.this);\n\t\tString selectScript = String.format(\"(function(){var el = Wicket.$('%s'); if (el.select) el.select();})()\",\n\t\t\t\teditor.getMarkupId());\n\t\ttarget.appendJavaScript(selectScript);\n\t\ttarget.focusComponent(editor);\n\t}","commit_id":"be8a4eaaf1537059b78d8d0994a6361cb8fbaa76","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Create a new form component instance to serve as editor.\n\t * \n\t * @param parent\n\t *            The parent component\n\t * @param componentId\n\t *            Id that should be used by the component\n\t * @param model\n\t *            The model\n\t * @return The editor\n\t */\n\tprotected FormComponent<T> newEditor(final MarkupContainer parent, final String componentId,\n\t\tfinal IModel<T> model)\n\t{\n\t\tTextField<T> editor = new TextField<T>(componentId, model)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic <C> IConverter<C> getConverter(final Class<C> type)\n\t\t\t{\n\t\t\t\tIConverter<C> c = AjaxEditableLabel.this.getConverter(type);\n\t\t\t\treturn c != null ? c : super.getConverter(type);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onModelChanged()\n\t\t\t{\n\t\t\t\tsuper.onModelChanged();\n\t\t\t\tAjaxEditableLabel.this.onModelChanged();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onModelChanging()\n\t\t\t{\n\t\t\t\tsuper.onModelChanging();\n\t\t\t\tAjaxEditableLabel.this.onModelChanging();\n\t\t\t}\n\t\t};\n\t\teditor.setOutputMarkupId(true);\n\t\teditor.setVisible(false);\n\t\teditor.add(new EditorAjaxBehavior()\n\t\t{\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n\t\t\t{\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setEventNames(\"blur\", \"keyup\");\n\n\t\t\t\tCharSequence dynamicExtraParameters = \"var result = [], \"\n\t\t\t\t\t+ \"kc=Wicket.Event.keyCode(event),\"\n\t\t\t\t\t+ \"evtType=attrs.event.type;\"\n\t\t\t\t\t+ \"if (evtType === 'keyup') {\"\n\t\t\t\t\t+\n\t\t\t\t\t// ESCAPE key\n\t\t\t\t\t\"if (kc===27) { result.push( { name: 'save', value: false } ); }\"\n\t\t\t\t\t+\n\n\t\t\t\t\t// ENTER key\n\t\t\t\t\t\"else if (kc===13) { result = Wicket.Form.serializeElement(attrs.c); result.push( { name: 'save', value: true } ); }\"\n\t\t\t\t\t+ \"}\"\n\t\t\t\t\t+ \"else if (evtType==='blur') { result = Wicket.Form.serializeElement(attrs.c); result.push( { name: 'save', value: true } ); }\"\n\t\t\t\t\t+ \"return result;\";\n\t\t\t\tattributes.getDynamicExtraParameters().add(dynamicExtraParameters);\n\n\t\t\t\tCharSequence precondition = \"var kc=Wicket.Event.keyCode(event),\"\n\t\t\t\t\t+ \"evtType=attrs.event.type,\"\n\t\t\t\t\t+ \"ret=false;\"\n\t\t\t\t\t+ \"if(evtType==='blur' || (evtType==='keyup' && (kc===27 || kc===13))) ret = true;\"\n\t\t\t\t\t+ \"return ret;\";\n\t\t\t\tAjaxCallListener ajaxCallListener = new AjaxCallListener();\n\t\t\t\tajaxCallListener.onPrecondition(precondition);\n\t\t\t\tattributes.getAjaxCallListeners().add(ajaxCallListener);\n\n\t\t\t}\n\t\t});\n\t\treturn editor;\n\t}","id":77918,"modified_method":"/**\n\t * Create a new form component instance to serve as editor.\n\t * \n\t * @param parent\n\t *            The parent component\n\t * @param componentId\n\t *            Id that should be used by the component\n\t * @param model\n\t *            The model\n\t * @return The editor\n\t */\n\tprotected FormComponent<T> newEditor(final MarkupContainer parent, final String componentId,\n\t\tfinal IModel<T> model)\n\t{\n\t\tTextField<T> editor = new TextField<T>(componentId, model)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic <C> IConverter<C> getConverter(final Class<C> type)\n\t\t\t{\n\t\t\t\tIConverter<C> c = AjaxEditableLabel.this.getConverter(type);\n\t\t\t\treturn c != null ? c : super.getConverter(type);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onModelChanged()\n\t\t\t{\n\t\t\t\tsuper.onModelChanged();\n\t\t\t\tAjaxEditableLabel.this.onModelChanged();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onModelChanging()\n\t\t\t{\n\t\t\t\tsuper.onModelChanging();\n\t\t\t\tAjaxEditableLabel.this.onModelChanging();\n\t\t\t}\n\t\t};\n\t\teditor.setOutputMarkupId(true);\n\t\teditor.setVisible(false);\n\t\teditor.add(new EditorAjaxBehavior()\n\t\t{\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n\t\t\t{\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setEventNames(\"blur\", \"keyup\");\n\n\t\t\t\tCharSequence dynamicExtraParameters = \"var result = [], \"\n\t\t\t\t\t+ \"kc=Wicket.Event.keyCode(attrs.event),\"\n\t\t\t\t\t+ \"evtType=attrs.event.type;\"\n\t\t\t\t\t+ \"if (evtType === 'keyup') {\"\n\t\t\t\t\t+\n\t\t\t\t\t// ESCAPE key\n\t\t\t\t\t\"if (kc===27) { result.push( { name: 'save', value: false } ); }\"\n\t\t\t\t\t+\n\n\t\t\t\t\t// ENTER key\n\t\t\t\t\t\"else if (kc===13) { result = Wicket.Form.serializeElement(attrs.c); result.push( { name: 'save', value: true } ); }\"\n\t\t\t\t\t+ \"}\"\n\t\t\t\t\t+ \"else if (evtType==='blur') { result = Wicket.Form.serializeElement(attrs.c); result.push( { name: 'save', value: true } ); }\"\n\t\t\t\t\t+ \"return result;\";\n\t\t\t\tattributes.getDynamicExtraParameters().add(dynamicExtraParameters);\n\n\t\t\t\tCharSequence precondition = \"var kc=Wicket.Event.keyCode(attrs.event),\"\n\t\t\t\t\t+ \"evtType=attrs.event.type,\"\n\t\t\t\t\t+ \"ret=false;\"\n\t\t\t\t\t+ \"if(evtType==='blur' || (evtType==='keyup' && (kc===27 || kc===13))) ret = true;\"\n\t\t\t\t\t+ \"return ret;\";\n\t\t\t\tAjaxCallListener ajaxCallListener = new AjaxCallListener();\n\t\t\t\tajaxCallListener.onPrecondition(precondition);\n\t\t\t\tattributes.getAjaxCallListeners().add(ajaxCallListener);\n\n\t\t\t}\n\t\t});\n\t\treturn editor;\n\t}","commit_id":"be8a4eaaf1537059b78d8d0994a6361cb8fbaa76","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected FormComponent<T> newEditor(final MarkupContainer parent, final String componentId,\n\t\tfinal IModel<T> model)\n\t{\n\t\tTextArea<T> editor = new TextArea<T>(componentId, model)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * {@inheritDoc}\n\t\t\t */\n\t\t\t@Override\n\t\t\tprotected void onModelChanged()\n\t\t\t{\n\t\t\t\tAjaxEditableMultiLineLabel.this.onModelChanged();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * {@inheritDoc}\n\t\t\t */\n\t\t\t@Override\n\t\t\tprotected void onModelChanging()\n\t\t\t{\n\t\t\t\tAjaxEditableMultiLineLabel.this.onModelChanging();\n\t\t\t}\n\t\t};\n\t\teditor.add(new AttributeModifier(\"rows\", new AbstractReadOnlyModel<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t}));\n\t\teditor.add(new AttributeModifier(\"cols\", new AbstractReadOnlyModel<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn cols;\n\t\t\t}\n\t\t}));\n\t\teditor.setOutputMarkupId(true);\n\t\teditor.setVisible(false);\n\t\teditor.add(new EditorAjaxBehavior()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n\t\t\t{\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setMethod(Method.POST);\n\t\t\t\tattributes.setEventNames(\"blur\", \"keyup\");\n\t\t\t\tCharSequence dynamicExtraParameters = \n\t\t\t\t\t\t\"var result = [], \" +\n\t\t\t\t\t\t\t\t\"kc=Wicket.Event.keyCode(event),\" +\n\t\t\t\t\t\t\t\t\"evtType=attrs.event.type;\" +\n\t\t\t\t\t\t\t\t\"if (evtType === 'keyup') {\" +\n\t\t\t\t\t\t\t\t\t// ESCAPE key\n\t\t\t\t\t\t\t\t\t\"if (kc===27) { result.push( { name: 'save', value: false } ); }\" +\n\t\t\t\t\t\t\t\t\"}\" +\n\t\t\t\t\t\t\t\t\"else if (evtType==='blur') { result = Wicket.Form.serializeElement(attrs.c); result.push( { name: 'save', value: true } ); }\" +\n\t\t\t\t\t\t\t\t\"return result;\";\n\t\t\t\tattributes.getDynamicExtraParameters().add(dynamicExtraParameters);\n\n\t\t\t\tCharSequence precondition =\n\t\t\t\t\t\t\"var kc=Wicket.Event.keyCode(event),\"+\n\t\t\t\t\t\t\t\t\"evtType=attrs.event.type,\"+\n\t\t\t\t\t\t\t\t\"ret=false;\"+\n\t\t\t\t\t\t\t\t\"if(evtType==='blur' || (evtType==='keyup' && (kc===27))) ret = true;\"+\n\t\t\t\t\t\t\t\t\"return ret;\";\n\t\t\t\tAjaxCallListener ajaxCallListener = new AjaxCallListener();\n\t\t\t\tajaxCallListener.onPrecondition(precondition);\n\t\t\t\tattributes.getAjaxCallListeners().add(ajaxCallListener);\n\t\t\t}\n\t\t});\n\t\treturn editor;\n\t}","id":77919,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected FormComponent<T> newEditor(final MarkupContainer parent, final String componentId,\n\t\tfinal IModel<T> model)\n\t{\n\t\tTextArea<T> editor = new TextArea<T>(componentId, model)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * {@inheritDoc}\n\t\t\t */\n\t\t\t@Override\n\t\t\tprotected void onModelChanged()\n\t\t\t{\n\t\t\t\tAjaxEditableMultiLineLabel.this.onModelChanged();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * {@inheritDoc}\n\t\t\t */\n\t\t\t@Override\n\t\t\tprotected void onModelChanging()\n\t\t\t{\n\t\t\t\tAjaxEditableMultiLineLabel.this.onModelChanging();\n\t\t\t}\n\t\t};\n\t\teditor.add(new AttributeModifier(\"rows\", new AbstractReadOnlyModel<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t}));\n\t\teditor.add(new AttributeModifier(\"cols\", new AbstractReadOnlyModel<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn cols;\n\t\t\t}\n\t\t}));\n\t\teditor.setOutputMarkupId(true);\n\t\teditor.setVisible(false);\n\t\teditor.add(new EditorAjaxBehavior()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n\t\t\t{\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setMethod(Method.POST);\n\t\t\t\tattributes.setEventNames(\"blur\", \"keyup\");\n\t\t\t\tCharSequence dynamicExtraParameters = \n\t\t\t\t\t\t\"var result = [], \" +\n\t\t\t\t\t\t\t\t\"kc=Wicket.Event.keyCode(attrs.event),\" +\n\t\t\t\t\t\t\t\t\"evtType=attrs.event.type;\" +\n\t\t\t\t\t\t\t\t\"if (evtType === 'keyup') {\" +\n\t\t\t\t\t\t\t\t\t// ESCAPE key\n\t\t\t\t\t\t\t\t\t\"if (kc===27) { result.push( { name: 'save', value: false } ); }\" +\n\t\t\t\t\t\t\t\t\"}\" +\n\t\t\t\t\t\t\t\t\"else if (evtType==='blur') { result = Wicket.Form.serializeElement(attrs.c); result.push( { name: 'save', value: true } ); }\" +\n\t\t\t\t\t\t\t\t\"return result;\";\n\t\t\t\tattributes.getDynamicExtraParameters().add(dynamicExtraParameters);\n\n\t\t\t\tCharSequence precondition =\n\t\t\t\t\t\t\"var kc=Wicket.Event.keyCode(attrs.event),\"+\n\t\t\t\t\t\t\t\t\"evtType=attrs.event.type,\"+\n\t\t\t\t\t\t\t\t\"ret=false;\"+\n\t\t\t\t\t\t\t\t\"if(evtType==='blur' || (evtType==='keyup' && (kc===27))) ret = true;\"+\n\t\t\t\t\t\t\t\t\"return ret;\";\n\t\t\t\tAjaxCallListener ajaxCallListener = new AjaxCallListener();\n\t\t\t\tajaxCallListener.onPrecondition(precondition);\n\t\t\t\tattributes.getAjaxCallListeners().add(ajaxCallListener);\n\t\t\t}\n\t\t});\n\t\treturn editor;\n\t}","commit_id":"be8a4eaaf1537059b78d8d0994a6361cb8fbaa76","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic void renderHead(IHeaderResponse response)\n\t{\n\t\t// make sure we have all the javascript we need\n\t\tCoreLibrariesContributor.contributeAjax(getApplication(), response);\n\t\tresponse.render(JavaScriptHeaderItem.forReference(JS));\n\t\tString findCheckboxes = getFindCheckboxesFunction().toString();\n\n\t\t// initialize the selector\n\t\tresponse.render(OnLoadHeaderItem.forScript(\"Wicket.CheckboxSelector.initializeSelector('\" +\n\t\t\tthis.getMarkupId() + \"', \" + findCheckboxes + \");\"));\n\t\tif (wantAutomaticUpdate())\n\t\t{\n\t\t\t// initialize the handlers for automatic updating of the selector state\n\t\t\tresponse.render(OnLoadHeaderItem.forScript(\"Wicket.CheckboxSelector.attachUpdateHandlers('\" +\n\t\t\t\tthis.getMarkupId() + \"', \" + findCheckboxes + \");\"));\n\t\t}\n\t}","id":77920,"modified_method":"@Override\n\tpublic void renderHead(IHeaderResponse response)\n\t{\n\t\tresponse.render(JavaScriptHeaderItem.forReference(JS));\n\n\t\tString findCheckboxes = getFindCheckboxesFunction().toString();\n\n\t\t// initialize the selector\n\t\tresponse.render(OnLoadHeaderItem.forScript(\"Wicket.CheckboxSelector.initializeSelector('\" +\n\t\t\tthis.getMarkupId() + \"', \" + findCheckboxes + \");\"));\n\t\tif (wantAutomaticUpdate())\n\t\t{\n\t\t\t// initialize the handlers for automatic updating of the selector state\n\t\t\tresponse.render(OnLoadHeaderItem.forScript(\"Wicket.CheckboxSelector.attachUpdateHandlers('\" +\n\t\t\t\tthis.getMarkupId() + \"', \" + findCheckboxes + \");\"));\n\t\t}\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            The component ID\n\t * @param boxes\n\t *            The CheckBoxes this selector will control.\n\t */\n\tpublic CheckBoxSelector(String id, CheckBox... boxes)\n\t{\n\t\tsuper(id);\n\t\tsetOutputMarkupId(true);\n\t\tcheckBoxIdArrayLiteral = buildMarkupIdJSArrayLiteral(Arrays.asList(boxes));\n\t}","id":77921,"modified_method":"/**\n\t * @param id\n\t *            The component ID\n\t * @param boxes\n\t *            The CheckBoxes this selector will control.\n\t */\n\tpublic CheckBoxSelector(String id, CheckBox... boxes)\n\t{\n\t\tsuper(id);\n\n\t\tcheckBoxIdArrayLiteral = buildMarkupIdJSArrayLiteral(Arrays.asList(boxes));\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected CharSequence getFindCheckboxesFunction()\n\t{\n\t\treturn \"Wicket.CheckboxSelector.Checkboxes.findCheckboxesFunction(\" +\n\t\t\tcheckBoxIdArrayLiteral + \")\";\n\t}","id":77922,"modified_method":"@Override\n\tprotected CharSequence getFindCheckboxesFunction()\n\t{\n\t\treturn String.format(\"Wicket.CheckboxSelector.getCheckboxesFunction(%s)\",\n\t\t\tcheckBoxIdArrayLiteral);\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * A Selector that will work with the given group.\n\t * \n\t * @param id\n\t *            component id\n\t * @param group\n\t *            group to work with\n\t */\n\tpublic CheckGroupSelector(String id, CheckGroup<?> group)\n\t{\n\t\tsuper(id);\n\t\tthis.group = group;\n\t\tsetOutputMarkupId(true);\n\t}","id":77923,"modified_method":"/**\n\t * A Selector that will work with the given group.\n\t * \n\t * @param id\n\t *            component id\n\t * @param group\n\t *            group to work with\n\t */\n\tpublic CheckGroupSelector(String id, CheckGroup<?> group)\n\t{\n\t\tsuper(id);\n\n\t\tthis.group = group;\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected CharSequence getFindCheckboxesFunction()\n\t{\n\t\tCheckGroup<?> group = getGroup();\n\t\tif (group == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\"CheckGroupSelector component [\" +\n\t\t\t\t\tgetPath() +\n\t\t\t\t\t\"] cannot find its parent CheckGroup. All CheckGroupSelector components must be a child of or below in the hierarchy of a CheckGroup component.\");\n\t\t}\n\t\treturn \"Wicket.CheckboxSelector.Group.findCheckboxesFunction('\" +\n\t\t\tgroup.getForm().getRootForm().getMarkupId() + \"','\" + group.getInputName() + \"')\";\n\t}","id":77924,"modified_method":"/**\n\t * Find all checkboxes in the containing form with the same input name as the {@link CheckGroup}\n\t * .\n\t */\n\t@Override\n\tprotected CharSequence getFindCheckboxesFunction()\n\t{\n\t\tCheckGroup<?> group = getGroup();\n\t\tif (group == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\"CheckGroupSelector component [\" +\n\t\t\t\t\tgetPath() +\n\t\t\t\t\t\"] cannot find its parent CheckGroup. All CheckGroupSelector components must be a child of or below in the hierarchy of a CheckGroup component.\");\n\t\t}\n\n\t\t// we search the complete form because the CheckGroup might not output its markup tag or be\n\t\t// located on a <wicket:container>\n\t\treturn String.format(\"Wicket.CheckboxSelector.findCheckboxesFunction('%s','%s')\",\n\t\t\tgroup.getForm().getMarkupId(), group.getInputName());\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            The component ID\n\t * @param choiceComponent\n\t *            The checkbox choice component this Selector will manage.\n\t */\n\tpublic CheckboxMultipleChoiceSelector(String id, CheckBoxMultipleChoice<?> choiceComponent)\n\t{\n\t\tsuper(id);\n\t\tthis.choiceComponent = choiceComponent;\n\t\tchoiceComponent.setOutputMarkupId(true);\n\t\tsetOutputMarkupId(true);\n\t}","id":77925,"modified_method":"/**\n\t * @param id\n\t *            The component ID\n\t * @param choiceComponent\n\t *            The checkbox choice component this Selector will manage.\n\t */\n\tpublic CheckboxMultipleChoiceSelector(String id, CheckBoxMultipleChoice<?> choiceComponent)\n\t{\n\t\tsuper(id);\n\n\t\tthis.choiceComponent = choiceComponent;\n\t\tchoiceComponent.setOutputMarkupId(true);\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected CharSequence getFindCheckboxesFunction()\n\t{\n\t\treturn \"Wicket.CheckboxSelector.Choice.findCheckboxesFunction('\" +\n\t\t\tchoiceComponent.getMarkupId() + \"')\";\n\t}","id":77926,"modified_method":"@Override\n\tprotected CharSequence getFindCheckboxesFunction()\n\t{\n\t\treturn String.format(\"Wicket.CheckboxSelector.findCheckboxesFunction('%s', '%s')\",\n\t\t\tchoiceComponent.getMarkupId(), choiceComponent.getInputName());\n\t}","commit_id":"311e0d29a112aaecfb30191407e8df125d1a751f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n   * @summary get the total ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsCapacityBytes() {\n    try {\n      return RestUtils\n          .createResponse(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_TOTAL));\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","id":77927,"modified_method":"/**\n   * @summary get the total ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsCapacityBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_TOTAL);\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the free ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsFreeBytes() {\n    try {\n      return RestUtils\n          .createResponse(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_FREE));\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","id":77928,"modified_method":"/**\n   * @summary get the free ufs capacity in bytes, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsFreeBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_FREE);\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the used capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return RestUtils.createResponse(mBlockMaster.getUsedBytes());\n  }","id":77929,"modified_method":"/**\n   * @summary get the used capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mBlockMaster.getUsedBytes();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the used disk capacity, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsUsedBytes() {\n    try {\n      return RestUtils\n          .createResponse(mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_USED));\n    } catch (IOException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","id":77930,"modified_method":"/**\n   * @summary get the used disk capacity, a negative value means the capacity is unknown.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UFS_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUfsUsedBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mUfs.getSpace(mUfsRoot, UnderFileSystem.SpaceType.SPACE_USED);\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, keys are in the order\n   *    from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getUsedBytesOnTiers() {\n    SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mBlockMaster.getUsedBytesOnTiers().entrySet()) {\n      usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(usedBytesOnTiers);\n  }","id":77931,"modified_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, keys are in the order\n   *    from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getUsedBytesOnTiers() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n        for (Map.Entry<String, Long> tierBytes : mBlockMaster.getUsedBytesOnTiers().entrySet()) {\n          usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n        }\n        return usedBytesOnTiers;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the configuration map, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CONFIGURATION)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.String>\")\n  public Response getConfiguration() {\n    Set<Map.Entry<String, String>> properties = Configuration.toMap().entrySet();\n    SortedMap<String, String> configuration = new TreeMap<>();\n    for (Map.Entry<String, String> entry : properties) {\n      String key = entry.getKey();\n      if (key.startsWith(ALLUXIO_CONF_PREFIX)) {\n        configuration.put(key, entry.getValue());\n      }\n    }\n    return RestUtils.createResponse(configuration);\n  }","id":77932,"modified_method":"/**\n   * @summary get the configuration map, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CONFIGURATION)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.String>\")\n  public Response getConfiguration() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        Set<Map.Entry<String, String>> properties = Configuration.toMap().entrySet();\n        SortedMap<String, String> configuration = new TreeMap<>();\n        for (Map.Entry<String, String> entry : properties) {\n          String key = entry.getKey();\n          if (key.startsWith(ALLUXIO_CONF_PREFIX)) {\n            configuration.put(key, entry.getValue());\n          }\n        }\n        return configuration;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the total capacity of all workers in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return RestUtils.createResponse(mBlockMaster.getCapacityBytes());\n  }","id":77933,"modified_method":"/**\n   * @summary get the total capacity of all workers in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mBlockMaster.getCapacityBytes();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to total capacity of the tier in bytes, keys are in\n   *    the order from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getCapacityBytesOnTiers() {\n    SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mBlockMaster.getTotalBytesOnTiers().entrySet()) {\n      capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(capacityBytesOnTiers);\n  }","id":77934,"modified_method":"/**\n   * @summary get the mapping from tier alias to total capacity of the tier in bytes, keys are in\n   *    the order from tier alias with smaller ordinal to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getCapacityBytesOnTiers() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n        for (Map.Entry<String, Long> tierBytes : mBlockMaster.getTotalBytesOnTiers().entrySet()) {\n          capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n        }\n        return capacityBytesOnTiers;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the version of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    return RestUtils.createResponse(RuntimeConstants.VERSION);\n  }","id":77935,"modified_method":"/**\n   * @summary get the version of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return RuntimeConstants.VERSION;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the free capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getFreeBytes() {\n    return RestUtils.createResponse(mBlockMaster.getCapacityBytes() - mBlockMaster.getUsedBytes());\n  }","id":77936,"modified_method":"/**\n   * @summary get the free capacity\n   * @return the response object\n   */\n  @GET\n  @Path(GET_FREE_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getFreeBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mBlockMaster.getCapacityBytes() - mBlockMaster.getUsedBytes();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the uptime of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return RestUtils.createResponse(mMaster.getUptimeMs());\n  }","id":77937,"modified_method":"/**\n   * @summary get the uptime of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mMaster.getUptimeMs();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the master metrics, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getMetrics() {\n    MetricRegistry metricRegistry = mMaster.getMasterMetricsSystem().getMetricRegistry();\n\n    // Get all counters.\n    Map<String, Counter> counters = metricRegistry.getCounters();\n\n    // Only the gauge for pinned files is retrieved here, other gauges are statistics of free/used\n    // spaces, those statistics can be gotten via other REST apis.\n    String filesPinnedProperty = CommonUtils.argsToString(\".\",\n        MasterContext.getMasterSource().getName(), MasterSource.FILES_PINNED);\n    @SuppressWarnings(\"unchecked\")\n    Gauge<Integer> filesPinned =\n        (Gauge<Integer>) metricRegistry.getGauges().get(filesPinnedProperty);\n\n    // Get values of the counters and gauges and put them into a metrics map.\n    SortedMap<String, Long> metrics = new TreeMap<>();\n    for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n      metrics.put(counter.getKey(), counter.getValue().getCount());\n    }\n    metrics.put(filesPinnedProperty, filesPinned.getValue().longValue());\n\n    return RestUtils.createResponse(metrics);\n  }","id":77938,"modified_method":"/**\n   * @summary get the master metrics, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getMetrics() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        MetricRegistry metricRegistry = mMaster.getMasterMetricsSystem().getMetricRegistry();\n\n        // Get all counters.\n        Map<String, Counter> counters = metricRegistry.getCounters();\n\n        // Only the gauge for pinned files is retrieved here, other gauges are statistics of\n        // free/used spaces, those statistics can be gotten via other REST apis.\n        String filesPinnedProperty = CommonUtils\n            .argsToString(\".\", MasterContext.getMasterSource().getName(),\n                MasterSource.FILES_PINNED);\n        @SuppressWarnings(\"unchecked\") Gauge<Integer> filesPinned =\n            (Gauge<Integer>) metricRegistry.getGauges().get(filesPinnedProperty);\n\n        // Get values of the counters and gauges and put them into a metrics map.\n        SortedMap<String, Long> metrics = new TreeMap<>();\n        for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n          metrics.put(counter.getKey(), counter.getValue().getCount());\n        }\n        metrics.put(filesPinnedProperty, filesPinned.getValue().longValue());\n\n        return metrics;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the list of worker descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.WorkerInfo>\")\n  public Response getWorkerInfoList() {\n    return RestUtils.createResponse(mBlockMaster.getWorkerInfoList());\n  }","id":77939,"modified_method":"/**\n   * @summary get the list of worker descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.WorkerInfo>\")\n  public Response getWorkerInfoList() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mBlockMaster.getWorkerInfoList();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the count of workers\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_COUNT)\n  @ReturnType(\"java.lang.Integer\")\n  public Response getWorkerCount() {\n    return RestUtils.createResponse(mBlockMaster.getWorkerCount());\n  }","id":77940,"modified_method":"/**\n   * @summary get the count of workers\n   * @return the response object\n   */\n  @GET\n  @Path(GET_WORKER_COUNT)\n  @ReturnType(\"java.lang.Integer\")\n  public Response getWorkerCount() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mBlockMaster.getWorkerCount();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the start time of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return RestUtils.createResponse(mMaster.getStartTimeMs());\n  }","id":77941,"modified_method":"/**\n   * @summary get the start time of the master\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mMaster.getStartTimeMs();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the master rpc address\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    return RestUtils.createResponse(mMaster.getMasterAddress().toString());\n  }","id":77942,"modified_method":"/**\n   * @summary get the master rpc address\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mMaster.getMasterAddress().toString();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the version of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    return RestUtils.createResponse(RuntimeConstants.VERSION);\n  }","id":77943,"modified_method":"/**\n   * @summary get the version of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_VERSION)\n  @ReturnType(\"java.lang.String\")\n  public Response getVersion() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return RuntimeConstants.VERSION;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the total capacity of the tier in bytes, the keys\n   *    are in the order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getCapacityBytesOnTiers() {\n    SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mStoreMeta.getCapacityBytesOnTiers().entrySet()) {\n      capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(capacityBytesOnTiers);\n  }","id":77944,"modified_method":"/**\n   * @summary get the mapping from tier alias to the total capacity of the tier in bytes, the keys\n   *    are in the order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getCapacityBytesOnTiers() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        SortedMap<String, Long> capacityBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n        for (Map.Entry<String, Long> tierBytes : mStoreMeta.getCapacityBytesOnTiers().entrySet()) {\n          capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n        }\n        return capacityBytesOnTiers;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the total capacity of the worker in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return RestUtils.createResponse(mStoreMeta.getCapacityBytes());\n  }","id":77945,"modified_method":"/**\n   * @summary get the total capacity of the worker in bytes\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CAPACITY_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getCapacityBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mStoreMeta.getCapacityBytes();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the configuration map, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CONFIGURATION)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.String>\")\n  public Response getConfiguration() {\n    Set<Map.Entry<String, String>> properties = Configuration.toMap().entrySet();\n    SortedMap<String, String> configuration = new TreeMap<>();\n    for (Map.Entry<String, String> entry : properties) {\n      String key = entry.getKey();\n      if (key.startsWith(ALLUXIO_CONF_PREFIX)) {\n        configuration.put(key, entry.getValue());\n      }\n    }\n    return RestUtils.createResponse(configuration);\n  }","id":77946,"modified_method":"/**\n   * @summary get the configuration map, the keys are ordered alphabetically.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_CONFIGURATION)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.String>\")\n  public Response getConfiguration() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        Set<Map.Entry<String, String>> properties = Configuration.toMap().entrySet();\n        SortedMap<String, String> configuration = new TreeMap<>();\n        for (Map.Entry<String, String> entry : properties) {\n          String key = entry.getKey();\n          if (key.startsWith(ALLUXIO_CONF_PREFIX)) {\n            configuration.put(key, entry.getValue());\n          }\n        }\n        return configuration;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the worker metrics\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getMetrics() {\n    MetricRegistry metricRegistry = mWorker.getWorkerMetricsSystem().getMetricRegistry();\n\n    // Get all counters.\n    Map<String, Counter> counters = metricRegistry.getCounters();\n\n    // Only the gauge for cached blocks is retrieved here, other gauges are statistics of free/used\n    // spaces, those statistics can be gotten via other REST apis.\n    String blocksCachedProperty = CommonUtils.argsToString(\".\",\n        WorkerContext.getWorkerSource().getName(), WorkerSource.BLOCKS_CACHED);\n    @SuppressWarnings(\"unchecked\")\n    Gauge<Integer> blocksCached =\n        (Gauge<Integer>) metricRegistry.getGauges().get(blocksCachedProperty);\n\n    // Get values of the counters and gauges and put them into a metrics map.\n    SortedMap<String, Long> metrics = new TreeMap<>();\n    for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n      metrics.put(counter.getKey(), counter.getValue().getCount());\n    }\n    metrics.put(blocksCachedProperty, blocksCached.getValue().longValue());\n\n    return RestUtils.createResponse(metrics);\n  }","id":77947,"modified_method":"/**\n   * @summary get the worker metrics\n   * @return the response object\n   */\n  @GET\n  @Path(GET_METRICS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getMetrics() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        MetricRegistry metricRegistry = mWorker.getWorkerMetricsSystem().getMetricRegistry();\n\n        // Get all counters.\n        Map<String, Counter> counters = metricRegistry.getCounters();\n\n        // Only the gauge for cached blocks is retrieved here, other gauges are statistics of free/used\n\n\n        // spaces, those statistics can be gotten via other REST apis.\n        String blocksCachedProperty = CommonUtils\n            .argsToString(\".\", WorkerContext.getWorkerSource().getName(), WorkerSource.BLOCKS_CACHED);\n        @SuppressWarnings(\"unchecked\") Gauge<Integer> blocksCached =\n            (Gauge<Integer>) metricRegistry.getGauges().get(blocksCachedProperty);\n\n        // Get values of the counters and gauges and put them into a metrics map.\n        SortedMap<String, Long> metrics = new TreeMap<>();\n        for (Map.Entry<String, Counter> counter : counters.entrySet()) {\n          metrics.put(counter.getKey(), counter.getValue().getCount());\n        }\n        metrics.put(blocksCachedProperty, blocksCached.getValue().longValue());\n\n        return metrics;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the start time of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return RestUtils.createResponse(mWorker.getStartTimeMs());\n  }","id":77948,"modified_method":"/**\n   * @summary get the start time of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_START_TIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getStartTimeMs() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mWorker.getStartTimeMs();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the paths of the directories in the tier\n   * @return the response object\n   */\n  @GET\n  @Path(GET_DIRECTORY_PATHS_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.util.List<java.lang.String>>\")\n  public Response getDirectoryPathsOnTiers() {\n    SortedMap<String, List<String>> tierToDirPaths = new TreeMap<>(getTierAliasComparator());\n    tierToDirPaths.putAll(mStoreMeta.getDirectoryPathsOnTiers());\n    return RestUtils.createResponse(tierToDirPaths);\n  }","id":77949,"modified_method":"/**\n   * @summary get the mapping from tier alias to the paths of the directories in the tier\n   * @return the response object\n   */\n  @GET\n  @Path(GET_DIRECTORY_PATHS_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.util.List<java.lang.String>>\")\n  public Response getDirectoryPathsOnTiers() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        SortedMap<String, List<String>> tierToDirPaths = new TreeMap<>(getTierAliasComparator());\n        tierToDirPaths.putAll(mStoreMeta.getDirectoryPathsOnTiers());\n        return tierToDirPaths;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the uptime of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return RestUtils.createResponse(mWorker.getUptimeMs());\n  }","id":77950,"modified_method":"/**\n   * @summary get the uptime of the worker in milliseconds\n   * @return the response object\n   */\n  @GET\n  @Path(GET_UPTIME_MS)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUptimeMs() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mWorker.getUptimeMs();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the address of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    return RestUtils.createResponse(mWorker.getWorkerAddress().toString());\n  }","id":77951,"modified_method":"/**\n   * @summary get the address of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_RPC_ADDRESS)\n  @ReturnType(\"java.lang.String\")\n  public Response getRpcAddress() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mWorker.getWorkerAddress().toString();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the used bytes of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return RestUtils.createResponse(mStoreMeta.getUsedBytes());\n  }","id":77952,"modified_method":"/**\n   * @summary get the used bytes of the worker\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES)\n  @ReturnType(\"java.lang.Long\")\n  public Response getUsedBytes() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mStoreMeta.getUsedBytes();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, the keys are in the\n   *    order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getUsedBytesOnTiers() {\n    SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n    for (Map.Entry<String, Long> tierBytes : mStoreMeta.getUsedBytesOnTiers().entrySet()) {\n      usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n    }\n    return RestUtils.createResponse(usedBytesOnTiers);\n  }","id":77953,"modified_method":"/**\n   * @summary get the mapping from tier alias to the used bytes of the tier, the keys are in the\n   *    order from tier aliases with smaller ordinals to those with larger ones.\n   * @return the response object\n   */\n  @GET\n  @Path(GET_USED_BYTES_ON_TIERS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, java.lang.Long>\")\n  public Response getUsedBytesOnTiers() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        SortedMap<String, Long> usedBytesOnTiers = new TreeMap<>(getTierAliasComparator());\n        for (Map.Entry<String, Long> tierBytes : mStoreMeta.getUsedBytesOnTiers().entrySet()) {\n          usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());\n        }\n        return usedBytesOnTiers;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.BLOCK_MASTER_CLIENT_SERVICE_VERSION);\n  }","id":77954,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.BLOCK_MASTER_CLIENT_SERVICE_VERSION;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.createResponse(Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME);\n  }","id":77955,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.BLOCK_WORKER_CLIENT_SERVICE_VERSION);\n  }","id":77956,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.BLOCK_WORKER_CLIENT_SERVICE_VERSION;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    // Need to encode the string as JSON because Jackson will not do it automatically.\n    return RestUtils.createResponse(Constants.BLOCK_WORKER_CLIENT_SERVICE_NAME);\n  }","id":77957,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @Produces(MediaType.APPLICATION_JSON)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.BLOCK_WORKER_CLIENT_SERVICE_NAME;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_VERSION);\n  }","id":77958,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_VERSION;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the map from alluxio paths of mount points to the mount point details\n   * @return the response object\n   */\n  @GET\n  @Path(GET_MOUNT_POINTS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, alluxio.wire.MountPointInfo>\")\n  public Response getMountPoints() {\n    SortedMap<String, MountPointInfo> mountPoints = new TreeMap<>();\n    for (Map.Entry<String, MountInfo> mountPoint : mFileSystemMaster.getMountTable().entrySet()) {\n      MountInfo mountInfo = mountPoint.getValue();\n      MountPointInfo info = new MountPointInfo();\n      info.setUfsInfo(mountInfo.getUfsUri().toString());\n      info.setReadOnly(mountInfo.getOptions().isReadOnly());\n      info.setProperties(mountInfo.getOptions().getProperties());\n      mountPoints.put(mountPoint.getKey(), info);\n    }\n    return RestUtils.createResponse(mountPoints);\n  }","id":77959,"modified_method":"/**\n   * @summary get the map from alluxio paths of mount points to the mount point details\n   * @return the response object\n   */\n  @GET\n  @Path(GET_MOUNT_POINTS)\n  @ReturnType(\"java.util.SortedMap<java.lang.String, alluxio.wire.MountPointInfo>\")\n  public Response getMountPoints() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        SortedMap<String, MountPointInfo> mountPoints = new TreeMap<>();\n        for (Map.Entry<String, MountInfo> mountPoint : mFileSystemMaster.getMountTable().entrySet\n            ()) {\n          MountInfo mountInfo = mountPoint.getValue();\n          MountPointInfo info = new MountPointInfo();\n          info.setUfsInfo(mountInfo.getUfsUri().toString());\n          info.setReadOnly(mountInfo.getOptions().isReadOnly());\n          info.setProperties(mountInfo.getOptions().getProperties());\n          mountPoints.put(mountPoint.getKey(), info);\n        }\n        return mountPoints;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.createResponse(Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_NAME);\n  }","id":77960,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.FILE_SYSTEM_MASTER_CLIENT_SERVICE_NAME;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.createResponse(Constants.LINEAGE_MASTER_CLIENT_SERVICE_VERSION);\n  }","id":77961,"modified_method":"/**\n   * @summary get the service version\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_VERSION)\n  @ReturnType(\"java.lang.Long\")\n  public Response getServiceVersion() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.LINEAGE_MASTER_CLIENT_SERVICE_VERSION;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the list of lineage descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_LINEAGE_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.LineageInfo>\")\n  public Response getLineageInfoList() {\n    try {\n      return RestUtils.createResponse(mLineageMaster.getLineageInfoList());\n    } catch (AlluxioException e) {\n      LOG.warn(e.getMessage());\n      return RestUtils.createErrorResponse(e.getMessage());\n    }\n  }","id":77962,"modified_method":"/**\n   * @summary get the list of lineage descriptors\n   * @return the response object\n   */\n  @GET\n  @Path(GET_LINEAGE_INFO_LIST)\n  @ReturnType(\"java.util.List<alluxio.wire.LineageInfo>\")\n  public Response getLineageInfoList() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return mLineageMaster.getLineageInfoList();\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.createResponse(Constants.LINEAGE_MASTER_CLIENT_SERVICE_NAME);\n  }","id":77963,"modified_method":"/**\n   * @summary get the service name\n   * @return the response object\n   */\n  @GET\n  @Path(SERVICE_NAME)\n  @ReturnType(\"java.lang.String\")\n  public Response getServiceName() {\n    return RestUtils.call(new RestUtils.RestCallable() {\n      @Override\n      public Object call() throws Exception {\n        return Constants.LINEAGE_MASTER_CLIENT_SERVICE_NAME;\n      }\n    });\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates the default response.\n   *\n   * @return the response\n   */\n  public static Response createResponse() {\n    return Response.ok().build();\n  }","id":77964,"modified_method":"/**\n   * Creates the default response.\n   *\n   * @return the response\n   */\n  private static Response createResponse() {\n    return Response.ok().build();\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates an error response using the given message.\n   *\n   * @param message the message to respond with\n   * @return the response\n   */\n  public static Response createErrorResponse(String message) {\n    return Response.serverError().entity(message).build();\n  }","id":77965,"modified_method":"/**\n   * Creates an error response using the given message.\n   *\n   * @param message the message to respond with\n   * @return the response\n   */\n  private static Response createErrorResponse(String message) {\n    return Response.serverError().entity(message).build();\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a response using the given object.\n   *\n   * @param object the object to respond with\n   * @return the response\n   */\n  public static Response createResponse(Object object) {\n    if (object instanceof String) {\n      // Need to explicitly encode the string as JSON because Jackson will not do it automatically.\n      ObjectMapper mapper = new ObjectMapper();\n      try {\n        return Response.ok(mapper.writeValueAsString(object)).build();\n      } catch (JsonProcessingException e) {\n        return createErrorResponse(e.getMessage());\n      }\n    }\n    return Response.ok(object).build();\n  }","id":77966,"modified_method":"/**\n   * Creates a response using the given object.\n   *\n   * @param object the object to respond with\n   * @return the response\n   */\n  private static Response createResponse(Object object) {\n    if (object instanceof String) {\n      // Need to explicitly encode the string as JSON because Jackson will not do it automatically.\n      ObjectMapper mapper = new ObjectMapper();\n      try {\n        return Response.ok(mapper.writeValueAsString(object)).build();\n      } catch (JsonProcessingException e) {\n        return createErrorResponse(e.getMessage());\n      }\n    }\n    return Response.ok(object).build();\n  }","commit_id":"8a35d5ef9647e3d729f66d81c91637bf4eee3bf4","url":"https://github.com/amplab/tachyon"},{"original_method":"private void initFilter(final ServiceReference reference,\n            final Filter filter) {\n        // Check if filter will be registered by Felix HttpService Whiteboard\n        if (reference.getProperty(FELIX_WHITEBOARD_PATTERN_PROPERTY) != null) {\n            return;\n        }\n\n        final String filterName = SlingFilterConfig.getName(reference);\n        if (filterName == null) {\n            log.error(\"initFilter: Missing name for filter {}\", reference);\n        } else {\n\n            // initialize the filter first\n            try {\n                final FilterConfig config = new SlingFilterConfig(\n                    servletContext, reference, filterName);\n                filter.init(config);\n\n                // service id\n                Long serviceId = (Long) reference.getProperty(Constants.SERVICE_ID);\n\n                // get the order, Integer.MAX_VALUE by default\n                Object orderObj = reference.getProperty(Constants.SERVICE_RANKING);\n                if (orderObj == null) {\n                    // filter order is defined as lower value has higher priority\n                    // while service ranking is the opposite\n                    // In addition we allow different types than Integer\n                    orderObj = reference.getProperty(EngineConstants.FILTER_ORDER);\n                    if ( orderObj != null ) {\n                        // we can use 0 as the default as this will be applied in\n                        // the next step anyway if this props contains an invalid\n                        // value\n                        Integer order = OsgiUtil.toInteger(orderObj, 0);\n                        order = order * -1;\n                    }\n                }\n                final int order = (orderObj instanceof Integer)\n                        ? ((Integer) orderObj).intValue()\n                        : 0;\n\n                // register by scope\n                String[] scopes = OsgiUtil.toStringArray(\n                    reference.getProperty(EngineConstants.FILTER_SCOPE), null);\n                if (scopes != null && scopes.length > 0) {\n                    for (String scope : scopes) {\n                        scope = scope.toUpperCase();\n                        try {\n                            FilterChainType type = FilterChainType.valueOf(scope.toString());\n                            getFilterChain(type).addFilter(filter, serviceId,\n                                order);\n\n                            if (type == FilterChainType.COMPONENT) {\n                                getFilterChain(FilterChainType.INCLUDE).addFilter(\n                                    filter, serviceId, order);\n                                getFilterChain(FilterChainType.FORWARD).addFilter(\n                                    filter, serviceId, order);\n                            }\n\n                        } catch (IllegalArgumentException iae) {\n                            // TODO: log ...\n                        }\n                    }\n                } else {\n                    log.warn(String.format(\n                        \"A Filter (Service ID %s) has been registered without a filter.scope property.\",\n                        reference.getProperty(Constants.SERVICE_ID)));\n                    getFilterChain(FilterChainType.REQUEST).addFilter(filter,\n                        serviceId, order);\n                }\n\n            } catch (ServletException ce) {\n                log.error(\"Filter \" + filterName + \" failed to initialize\", ce);\n            } catch (Throwable t) {\n                log.error(\"Unexpected Problem initializing ComponentFilter \"\n                    + \"\", t);\n            }\n        }\n    }","id":77967,"modified_method":"private void initFilter(final ServiceReference reference,\n            final Filter filter) {\n        if ( this.excludeFilter(reference) ) {\n            return;\n        }\n        final String filterName = SlingFilterConfig.getName(reference);\n        if (filterName == null) {\n            log.error(\"initFilter: Missing name for filter {}\", reference);\n        } else {\n\n            // initialize the filter first\n            try {\n                final FilterConfig config = new SlingFilterConfig(\n                    servletContext, reference, filterName);\n                filter.init(config);\n\n                // service id\n                Long serviceId = (Long) reference.getProperty(Constants.SERVICE_ID);\n\n                // get the order, Integer.MAX_VALUE by default\n                Object orderObj = reference.getProperty(Constants.SERVICE_RANKING);\n                if (orderObj == null) {\n                    // filter order is defined as lower value has higher priority\n                    // while service ranking is the opposite\n                    // In addition we allow different types than Integer\n                    orderObj = reference.getProperty(EngineConstants.FILTER_ORDER);\n                    if ( orderObj != null ) {\n                        // we can use 0 as the default as this will be applied in\n                        // the next step anyway if this props contains an invalid\n                        // value\n                        Integer order = OsgiUtil.toInteger(orderObj, 0);\n                        order = order * -1;\n                    }\n                }\n                final int order = (orderObj instanceof Integer)\n                        ? ((Integer) orderObj).intValue()\n                        : 0;\n\n                // register by scope\n                String[] scopes = OsgiUtil.toStringArray(\n                        reference.getProperty(EngineConstants.SLING_FILTER_SCOPE), null);\n                if ( scopes == null ) {\n                    scopes = OsgiUtil.toStringArray(\n                        reference.getProperty(EngineConstants.FILTER_SCOPE), null);\n                }\n                if (scopes != null && scopes.length > 0) {\n                    for (String scope : scopes) {\n                        scope = scope.toUpperCase();\n                        try {\n                            FilterChainType type = FilterChainType.valueOf(scope.toString());\n                            getFilterChain(type).addFilter(filter, serviceId,\n                                order);\n\n                            if (type == FilterChainType.COMPONENT) {\n                                getFilterChain(FilterChainType.INCLUDE).addFilter(\n                                    filter, serviceId, order);\n                                getFilterChain(FilterChainType.FORWARD).addFilter(\n                                    filter, serviceId, order);\n                            }\n\n                        } catch (IllegalArgumentException iae) {\n                            // TODO: log ...\n                        }\n                    }\n                } else {\n                    log.warn(String.format(\n                        \"A Filter (Service ID %s) has been registered without a filter.scope property.\",\n                        reference.getProperty(Constants.SERVICE_ID)));\n                    getFilterChain(FilterChainType.REQUEST).addFilter(filter,\n                        serviceId, order);\n                }\n\n            } catch (ServletException ce) {\n                log.error(\"Filter \" + filterName + \" failed to initialize\", ce);\n            } catch (Throwable t) {\n                log.error(\"Unexpected Problem initializing ComponentFilter \"\n                    + \"\", t);\n            }\n        }\n    }","commit_id":"9b9650da2a60045215b11c04a2bb4a93c15339f0","url":"https://github.com/apache/sling"},{"original_method":"public ServletFilterManager(BundleContext context,\n            final SlingServletContext servletContext) {\n        super(context, FILTER_SERVICE_NAME, null);\n        this.servletContext = servletContext;\n        this.filterChains = new SlingFilterChainHelper[FilterChainType.values().length];\n        this.filterChains[FilterChainType.REQUEST.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.ERROR.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.INCLUDE.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.FORWARD.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.COMPONENT.ordinal()] = new SlingFilterChainHelper();\n    }","id":77968,"modified_method":"public ServletFilterManager(final BundleContext context,\n            final SlingServletContext servletContext,\n            final boolean compatMode) {\n        super(context, FILTER_SERVICE_NAME, null);\n        this.servletContext = servletContext;\n        this.filterChains = new SlingFilterChainHelper[FilterChainType.values().length];\n        this.filterChains[FilterChainType.REQUEST.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.ERROR.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.INCLUDE.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.FORWARD.ordinal()] = new SlingFilterChainHelper();\n        this.filterChains[FilterChainType.COMPONENT.ordinal()] = new SlingFilterChainHelper();\n        this.compatMode = compatMode;\n    }","commit_id":"9b9650da2a60045215b11c04a2bb4a93c15339f0","url":"https://github.com/apache/sling"},{"original_method":"@Activate\n    protected void activate(final BundleContext bundleContext,\n            final Map<String, Object> componentConfig) {\n\n        // setup server info\n        final Dictionary<?, ?> props = bundleContext.getBundle().getHeaders();\n        final Version bundleVersion = Version.parseVersion((String) props.get(Constants.BUNDLE_VERSION));\n        final String productVersion = bundleVersion.getMajor() + \".\"\n            + bundleVersion.getMinor();\n        this.serverInfo = PRODUCT_NAME + \"/\" + productVersion + \" (\"\n            + System.getProperty(\"java.vm.name\") + \" \"\n            + System.getProperty(\"java.version\") + \"; \"\n            + System.getProperty(\"os.name\") + \" \"\n            + System.getProperty(\"os.version\") + \" \"\n            + System.getProperty(\"os.arch\") + \")\";\n        this.requestProcessor.setServerInfo(serverInfo);\n\n        // prepare the servlet configuration from the component config\n        final Hashtable<String, Object> configuration = new Hashtable<String, Object>(\n            componentConfig);\n\n        // ensure the servlet name\n        if (!(configuration.get(\"servlet-name\") instanceof String)) {\n            configuration.put(\"servlet-name\", PRODUCT_NAME + \" \"\n                + productVersion);\n        }\n\n        // configure method filter\n        allowTrace = OsgiUtil.toBoolean(componentConfig.get(PROP_ALLOW_TRACE),\n                DEFAULT_ALLOW_TRACE);\n\n        // configure the request limits\n        RequestData.setMaxIncludeCounter(OsgiUtil.toInteger(\n            componentConfig.get(PROP_MAX_INCLUSION_COUNTER),\n            RequestData.DEFAULT_MAX_INCLUSION_COUNTER));\n        RequestData.setMaxCallCounter(OsgiUtil.toInteger(\n            componentConfig.get(PROP_MAX_CALL_COUNTER),\n            RequestData.DEFAULT_MAX_CALL_COUNTER));\n        RequestData.setSlingMainServlet(this);\n\n        // register the servlet and resources\n        try {\n            Dictionary<String, String> servletConfig = toStringConfig(configuration);\n\n            this.httpService.registerServlet(SLING_ROOT, this, servletConfig,\n                slingHttpContext);\n\n            log.info(\"{} ready to serve requests\", this.getServerInfo());\n\n        } catch (Exception e) {\n            log.error(\"Cannot register \" + this.getServerInfo(), e);\n        }\n\n        // now that the sling main servlet is registered with the HttpService\n        // and initialized we can register the servlet context\n        slingServletContext = new SlingServletContext(bundleContext, this);\n\n        // register render filters already registered after registration with\n        // the HttpService as filter initialization may cause the servlet\n        // context to be required (see SLING-42)\n        filterManager = new ServletFilterManager(bundleContext,\n            slingServletContext);\n        filterManager.open();\n        requestProcessor.setFilterManager(filterManager);\n\n        // initialize requestListenerManager\n        requestListenerManager = new RequestListenerManager( bundleContext, slingServletContext );\n\n        // Setup configuration printer\n        this.printerRegistration = WebConsoleConfigPrinter.register(bundleContext, filterManager);\n\n        // setup the request info recorder\n        try {\n            int maxRequests = OsgiUtil.toInteger(\n                componentConfig.get(PROP_MAX_RECORD_REQUESTS),\n                RequestHistoryConsolePlugin.STORED_REQUESTS_COUNT);\n            RequestHistoryConsolePlugin.initPlugin(bundleContext, maxRequests);\n        } catch (Throwable t) {\n            log.debug(\n                \"Unable to register web console request recorder plugin.\", t);\n        }\n\n        // provide the SlingRequestProcessor service\n        Hashtable<String, String> srpProps = new Hashtable<String, String>();\n        srpProps.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        srpProps.put(Constants.SERVICE_DESCRIPTION, \"Sling Request Processor\");\n        requestProcessorRegistration = bundleContext.registerService(\n            SlingRequestProcessor.NAME, requestProcessor, srpProps);\n    }","id":77969,"modified_method":"@Activate\n    protected void activate(final BundleContext bundleContext,\n            final Map<String, Object> componentConfig) {\n\n        // setup server info\n        final Dictionary<?, ?> props = bundleContext.getBundle().getHeaders();\n        final Version bundleVersion = Version.parseVersion((String) props.get(Constants.BUNDLE_VERSION));\n        final String productVersion = bundleVersion.getMajor() + \".\"\n            + bundleVersion.getMinor();\n        this.serverInfo = PRODUCT_NAME + \"/\" + productVersion + \" (\"\n            + System.getProperty(\"java.vm.name\") + \" \"\n            + System.getProperty(\"java.version\") + \"; \"\n            + System.getProperty(\"os.name\") + \" \"\n            + System.getProperty(\"os.version\") + \" \"\n            + System.getProperty(\"os.arch\") + \")\";\n        this.requestProcessor.setServerInfo(serverInfo);\n\n        // prepare the servlet configuration from the component config\n        final Hashtable<String, Object> configuration = new Hashtable<String, Object>(\n            componentConfig);\n\n        // ensure the servlet name\n        if (!(configuration.get(\"servlet-name\") instanceof String)) {\n            configuration.put(\"servlet-name\", PRODUCT_NAME + \" \"\n                + productVersion);\n        }\n\n        // configure method filter\n        allowTrace = OsgiUtil.toBoolean(componentConfig.get(PROP_ALLOW_TRACE),\n                DEFAULT_ALLOW_TRACE);\n\n        // configure the request limits\n        RequestData.setMaxIncludeCounter(OsgiUtil.toInteger(\n            componentConfig.get(PROP_MAX_INCLUSION_COUNTER),\n            RequestData.DEFAULT_MAX_INCLUSION_COUNTER));\n        RequestData.setMaxCallCounter(OsgiUtil.toInteger(\n            componentConfig.get(PROP_MAX_CALL_COUNTER),\n            RequestData.DEFAULT_MAX_CALL_COUNTER));\n        RequestData.setSlingMainServlet(this);\n\n        // register the servlet and resources\n        try {\n            Dictionary<String, String> servletConfig = toStringConfig(configuration);\n\n            this.httpService.registerServlet(SLING_ROOT, this, servletConfig,\n                slingHttpContext);\n\n            log.info(\"{} ready to serve requests\", this.getServerInfo());\n\n        } catch (Exception e) {\n            log.error(\"Cannot register \" + this.getServerInfo(), e);\n        }\n\n        // now that the sling main servlet is registered with the HttpService\n        // and initialized we can register the servlet context\n        slingServletContext = new SlingServletContext(bundleContext, this);\n\n        // register render filters already registered after registration with\n        // the HttpService as filter initialization may cause the servlet\n        // context to be required (see SLING-42)\n        filterManager = new ServletFilterManager(bundleContext,\n            slingServletContext,\n            OsgiUtil.toBoolean(componentConfig.get(PROP_FILTER_COMPAT_MODE), DEFAULT_FILTER_COMPAT_MODE));\n        filterManager.open();\n        requestProcessor.setFilterManager(filterManager);\n\n        // initialize requestListenerManager\n        requestListenerManager = new RequestListenerManager( bundleContext, slingServletContext );\n\n        // Setup configuration printer\n        this.printerRegistration = WebConsoleConfigPrinter.register(bundleContext, filterManager);\n\n        // setup the request info recorder\n        try {\n            int maxRequests = OsgiUtil.toInteger(\n                componentConfig.get(PROP_MAX_RECORD_REQUESTS),\n                RequestHistoryConsolePlugin.STORED_REQUESTS_COUNT);\n            RequestHistoryConsolePlugin.initPlugin(bundleContext, maxRequests);\n        } catch (Throwable t) {\n            log.debug(\n                \"Unable to register web console request recorder plugin.\", t);\n        }\n\n        // provide the SlingRequestProcessor service\n        Hashtable<String, String> srpProps = new Hashtable<String, String>();\n        srpProps.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        srpProps.put(Constants.SERVICE_DESCRIPTION, \"Sling Request Processor\");\n        requestProcessorRegistration = bundleContext.registerService(\n            SlingRequestProcessor.NAME, requestProcessor, srpProps);\n    }","commit_id":"9b9650da2a60045215b11c04a2bb4a93c15339f0","url":"https://github.com/apache/sling"},{"original_method":"protected List<TaskInstanceInfo> getTaskInstanceInfos(\n\t\t\tlong workflowInstanceId, long[] actorIds, boolean pooledActors,\n\t\t\tBoolean completed, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\tJbpmContext jbpmContext = _jbpmConfiguration.createJbpmContext();\n\n\t\ttry {\n\t\t\tCustomSession customSession = new CustomSession(jbpmContext);\n\n\t\t\tList<TaskInstance> taskInstances = customSession.findTaskInstances(\n\t\t\t\t-1, workflowInstanceId, ArrayUtil.toStringArray(actorIds),\n\t\t\t\tpooledActors, completed, start, end, orderByComparator);\n\n\t\t\treturn toTaskInstanceInfos(taskInstances);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WorkflowException(e);\n\t\t}\n\t\tfinally {\n\t\t\tjbpmContext.close();\n\t\t}\n\t}","id":77970,"modified_method":"protected List<TaskInstanceInfo> getTaskInstanceInfos(\n\t\t\tlong workflowInstanceId, long[] actorIds, boolean pooledActors,\n\t\t\tBoolean completed, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\tJbpmContext jbpmContext = _jbpmConfiguration.createJbpmContext();\n\n\t\ttry {\n\t\t\tCustomSession customSession = new CustomSession(jbpmContext);\n\n\t\t\tList<TaskInstance> taskInstances = customSession.findTaskInstances(\n\t\t\t\t-1, workflowInstanceId,\n\t\t\t\tactorIds == null? null : ArrayUtil.toStringArray(actorIds),\n\t\t\t\tpooledActors, completed, start, end, orderByComparator);\n\n\t\t\treturn toTaskInstanceInfos(taskInstances);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WorkflowException(e);\n\t\t}\n\t\tfinally {\n\t\t\tjbpmContext.close();\n\t\t}\n\t}","commit_id":"b8c2fbf7336e0ed778d70543ff1d70038866a918","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean completed, boolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\treturn getWorkflowInstanceInfos(\n\t\t\tworkflowDefinitionName, workflowDefinitionVersion, completed,\n\t\t\tretrieveChildrenInfo, start, end, orderByComparator);\n\t}","id":77971,"modified_method":"public List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean completed, boolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\treturn getWorkflowInstanceInfos(\n\t\t\tworkflowDefinitionName, workflowDefinitionVersion, completed,\n\t\t\tBoolean.valueOf(retrieveChildrenInfo), start, end,\n\t\t\torderByComparator);\n\t}","commit_id":"b8c2fbf7336e0ed778d70543ff1d70038866a918","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected List<TaskInstanceInfo> getTaskInstanceInfos(\n\t\t\tlong workflowInstanceId, long[] actorIds, boolean pooledActors,\n\t\t\tBoolean completed, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\tJbpmContext jbpmContext = _jbpmConfiguration.createJbpmContext();\n\n\t\ttry {\n\t\t\tCustomSession customSession = new CustomSession(jbpmContext);\n\n\t\t\tList<TaskInstance> taskInstances = customSession.findTaskInstances(\n\t\t\t\t-1, workflowInstanceId,\n\t\t\t\tactorIds == null? null : ArrayUtil.toStringArray(actorIds),\n\t\t\t\tpooledActors, completed, start, end, orderByComparator);\n\n\t\t\treturn toTaskInstanceInfos(taskInstances);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WorkflowException(e);\n\t\t}\n\t\tfinally {\n\t\t\tjbpmContext.close();\n\t\t}\n\t}","id":77972,"modified_method":"protected List<TaskInstanceInfo> getTaskInstanceInfos(\n\t\t\tlong workflowInstanceId, long[] actorIds, boolean pooledActors,\n\t\t\tBoolean completed, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\tJbpmContext jbpmContext = _jbpmConfiguration.createJbpmContext();\n\n\t\ttry {\n\t\t\tCustomSession customSession = new CustomSession(jbpmContext);\n\n\t\t\tString[] actorIdStringArray = null;\n\n\t\t\tif (actorIds != null) {\n\t\t\t\tactorIdStringArray = ArrayUtil.toStringArray(actorIds);\n\t\t\t}\n\n\t\t\tList<TaskInstance> taskInstances = customSession.findTaskInstances(\n\t\t\t\t-1, workflowInstanceId, actorIdStringArray, pooledActors,\n\t\t\t\tcompleted, start, end, orderByComparator);\n\n\t\t\treturn toTaskInstanceInfos(taskInstances);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WorkflowException(e);\n\t\t}\n\t\tfinally {\n\t\t\tjbpmContext.close();\n\t\t}\n\t}","commit_id":"7e7a9cea06ce2111255ace402cf4dee0a9d4822d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean completed, boolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\treturn getWorkflowInstanceInfos(\n\t\t\tworkflowDefinitionName, workflowDefinitionVersion, completed,\n\t\t\tBoolean.valueOf(retrieveChildrenInfo), start, end,\n\t\t\torderByComparator);\n\t}","id":77973,"modified_method":"public List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean completed, boolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\treturn getWorkflowInstanceInfos(\n\t\t\tworkflowDefinitionName, workflowDefinitionVersion,\n\t\t\tBoolean.valueOf(completed), retrieveChildrenInfo, start, end,\n\t\t\torderByComparator);\n\t}","commit_id":"7e7a9cea06ce2111255ace402cf4dee0a9d4822d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean retrieveChildrenInfo, Boolean completed, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\tJbpmContext jbpmContext = _jbpmConfiguration.createJbpmContext();\n\n\t\ttry {\n\t\t\tProcessDefinition processDefinition = getProcessDefinition(\n\t\t\t\tjbpmContext, workflowDefinitionName, workflowDefinitionVersion);\n\n\t\t\tCustomSession customSession = new CustomSession(jbpmContext);\n\n\t\t\tList<ProcessInstance> processInstances =\n\t\t\t\tcustomSession.findProcessInstances(\n\t\t\t\t\tprocessDefinition.getId(), completed, start, end,\n\t\t\t\t\torderByComparator);\n\n\t\t\tList<WorkflowInstanceInfo> workflowInstanceInfos =\n\t\t\t\tnew ArrayList<WorkflowInstanceInfo>(processInstances.size());\n\n\t\t\tfor (ProcessInstance processInstance : processInstances) {\n\t\t\t\tToken token = processInstance.getRootToken();\n\n\t\t\t\tWorkflowInstanceInfoImpl workflowInstanceInfoImpl =\n\t\t\t\t\tnew WorkflowInstanceInfoImpl(token);\n\n\t\t\t\tif (retrieveChildrenInfo) {\n\t\t\t\t\tpopulateChildrenWorkflowInstanceInfos(\n\t\t\t\t\t\ttoken, workflowInstanceInfoImpl);\n\t\t\t\t}\n\n\t\t\t\tworkflowInstanceInfos.add(workflowInstanceInfoImpl);\n\t\t\t}\n\n\t\t\treturn workflowInstanceInfos;\n\t\t}\n\t\tcatch (WorkflowException we) {\n\t\t\tthrow we;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WorkflowException(e);\n\t\t}\n\t\tfinally {\n\t\t\tjbpmContext.close();\n\t\t}\n\t}","id":77974,"modified_method":"protected List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tBoolean completed, boolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\tJbpmContext jbpmContext = _jbpmConfiguration.createJbpmContext();\n\n\t\ttry {\n\t\t\tProcessDefinition processDefinition = getProcessDefinition(\n\t\t\t\tjbpmContext, workflowDefinitionName, workflowDefinitionVersion);\n\n\t\t\tCustomSession customSession = new CustomSession(jbpmContext);\n\n\t\t\tList<ProcessInstance> processInstances =\n\t\t\t\tcustomSession.findProcessInstances(\n\t\t\t\t\tprocessDefinition.getId(), completed, start, end,\n\t\t\t\t\torderByComparator);\n\n\t\t\tList<WorkflowInstanceInfo> workflowInstanceInfos =\n\t\t\t\tnew ArrayList<WorkflowInstanceInfo>(processInstances.size());\n\n\t\t\tfor (ProcessInstance processInstance : processInstances) {\n\t\t\t\tToken token = processInstance.getRootToken();\n\n\t\t\t\tWorkflowInstanceInfoImpl workflowInstanceInfoImpl =\n\t\t\t\t\tnew WorkflowInstanceInfoImpl(token);\n\n\t\t\t\tif (retrieveChildrenInfo) {\n\t\t\t\t\tpopulateChildrenWorkflowInstanceInfos(\n\t\t\t\t\t\ttoken, workflowInstanceInfoImpl);\n\t\t\t\t}\n\n\t\t\t\tworkflowInstanceInfos.add(workflowInstanceInfoImpl);\n\t\t\t}\n\n\t\t\treturn workflowInstanceInfos;\n\t\t}\n\t\tcatch (WorkflowException we) {\n\t\t\tthrow we;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WorkflowException(e);\n\t\t}\n\t\tfinally {\n\t\t\tjbpmContext.close();\n\t\t}\n\t}","commit_id":"7e7a9cea06ce2111255ace402cf4dee0a9d4822d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\treturn getWorkflowInstanceInfos(\n\t\t\tworkflowDefinitionName, workflowDefinitionVersion,\n\t\t\tretrieveChildrenInfo, null, start, end, orderByComparator);\n\t}","id":77975,"modified_method":"public List<WorkflowInstanceInfo> getWorkflowInstanceInfos(\n\t\t\tString workflowDefinitionName, Integer workflowDefinitionVersion,\n\t\t\tboolean retrieveChildrenInfo, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows WorkflowException {\n\n\t\treturn getWorkflowInstanceInfos(\n\t\t\tworkflowDefinitionName, workflowDefinitionVersion, null,\n\t\t\tretrieveChildrenInfo, start, end, orderByComparator);\n\t}","commit_id":"7e7a9cea06ce2111255ace402cf4dee0a9d4822d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n   * Constructor, adopting system properties starting with \"org.basex.\".\n   * @param file if {@code true}, options will be read from disk\n   */\n  GlobalOptions(final boolean file) {\n    super(file ? new IOFile(HOME, IO.BASEXSUFFIX) : null);\n    setSystem();\n\n    // set some static options\n    language = get(LANG);\n    langkeys = get(LANGKEYS);\n    debug = get(DEBUG);\n    final String ph = get(PROXYHOST);\n    final String pp = Integer.toString(get(PROXYPORT));\n    setSystem(\"http.proxyHost\", ph);\n    setSystem(\"http.proxyPort\", pp);\n    setSystem(\"https.proxyHost\", ph);\n    setSystem(\"https.proxyPort\", pp);\n    setSystem(\"http.nonProxyHosts\", get(NONPROXYHOSTS));\n  }","id":77976,"modified_method":"/**\n   * Constructor, adopting system properties starting with \"org.basex.\".\n   * @param file if {@code true}, options will be read from disk\n   */\n  GlobalOptions(final boolean file) {\n    super(file ? new IOFile(HOME, IO.BASEXSUFFIX) : null);\n    setSystem();\n\n    // set some static options\n    language = get(LANG);\n    langkeys = get(LANGKEYS);\n    debug = get(DEBUG);\n    final String ph = get(PROXYHOST);\n    if(!ph.isEmpty()) {\n      setSystem(\"http.proxyHost\", ph);\n      setSystem(\"https.proxyHost\", ph);\n    }\n    final String pp = Integer.toString(get(PROXYPORT));\n    if(!pp.isEmpty()) {\n      setSystem(\"http.proxyPort\", pp);\n      setSystem(\"https.proxyPort\", pp);\n    }\n    final String nph = get(NONPROXYHOSTS);\n    if(!nph.isEmpty()) {\n      setSystem(\"http.nonProxyHosts\", nph);\n    }\n  }","commit_id":"89d7189468fc914ece1291307abd568eed07b9d0","url":"https://github.com/BaseXdb/basex"},{"original_method":"public Integer map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        if ( tracker == null )\n            return 0;\n\n        GenomeLoc loc = context.getLocation();\n        VariantContext vc_input = tracker.getFirstValue(variantCollection.variants, loc);\n\n        VariantContext vc_comp = tracker.getFirstValue(comp, loc);\n\n        if ( vc_input == null  )\n            return 0;\n\n        if (vc_input.isFiltered()) {\n            vcfWriter.add(vc_input);\n            return 1;\n        }\n\n        BeagleFeature beagleR2Feature = tracker.getFirstValue(beagleR2);\n        BeagleFeature beagleProbsFeature = tracker.getFirstValue(beagleProbs);\n        BeagleFeature beaglePhasedFeature = tracker.getFirstValue(beaglePhased);\n\n        // ignore places where we don't have a variant\n        if ( beagleR2Feature == null || beagleProbsFeature == null ||  beaglePhasedFeature == null)\n        {\n            vcfWriter.add(vc_input);\n            return 1;\n        }\n\n\n        // get reference base for current position\n        byte refByte = ref.getBase();\n\n        // make new Genotypes based on Beagle results\n        GenotypesContext genotypes = GenotypesContext.create(vc_input.getGenotypes().size());\n\n        // for each genotype, create a new object with Beagle information on it\n\n        int numGenotypesChangedByBeagle = 0;\n        Integer alleleCountH = 0, chrCountH = 0;\n        Double alleleFrequencyH = 0.0;\n        int beagleVarCounts = 0;\n\n        GenotypesContext hapmapGenotypes = null;\n\n        if (vc_comp != null) {\n            hapmapGenotypes = vc_comp.getGenotypes();\n        }\n\n        for ( final Genotype g : vc_input.getGenotypes() ) {\n            boolean genotypeIsPhased = true;\n            String sample = g.getSampleName();\n\n            // If we have  a Hapmap (comp) ROD, compute Hapmap AC, AN and AF\n            // use sample as key into genotypes structure\n            if (vc_comp != null) {\n\n                if (vc_input.getGenotypes().containsSample(sample) && hapmapGenotypes.containsSample(sample))  {\n\n                    Genotype hapmapGenotype = hapmapGenotypes.get(sample);\n                    if (hapmapGenotype.isCalled()){\n                        chrCountH += 2;\n                        if (hapmapGenotype.isHet()) {\n                            alleleCountH += 1;\n                        }    else if (hapmapGenotype.isHomVar()) {\n                            alleleCountH += 2;\n                        }\n                    }\n                }\n            }\n\n            ArrayList<String> beagleProbabilities = beagleProbsFeature.getProbLikelihoods().get(sample);\n            ArrayList<String> beagleGenotypePairs = beaglePhasedFeature.getGenotypes().get(sample);\n\n            // original alleles at this genotype\n            Allele originalAlleleA = g.getAllele(0);\n\n            Allele originalAlleleB = (g.getAlleles().size() == 2) ? g.getAllele(1) : g.getAllele(0); // hack to deal with no-call genotypes\n\n\n            // We have phased genotype in hp. Need to set the isRef field in the allele.\n            List<Allele> alleles = new ArrayList<Allele>();\n\n            String alleleA = beagleGenotypePairs.get(0);\n            String alleleB = beagleGenotypePairs.get(1);\n\n            if ( alleleA.equals(\"null\") || alleleB.equals(\"null\") ) {\n                logger.warn(\"Beagle produced 'null' alleles at location \"+ref.getLocus().toString()+\". Ignoring.\");\n                return 0;\n            }\n\n            // Beagle always produces genotype strings based on the strings we input in the likelihood file.\n            String refString = vc_input.getReference().getDisplayString();\n\n            Allele bglAlleleA, bglAlleleB;\n\n            if (alleleA.matches(refString))\n                bglAlleleA = Allele.create(alleleA,true);\n            else\n                bglAlleleA = Allele.create(alleleA,false);\n\n            if (alleleB.matches(refString))\n                bglAlleleB = Allele.create(alleleB,true);\n            else\n                bglAlleleB = Allele.create(alleleB,false);\n\n\n            alleles.add(bglAlleleA);\n            alleles.add(bglAlleleB);\n\n            // Compute new GQ field = -10*log10Pr(Genotype call is wrong)\n            // Beagle gives probability that genotype is AA, AB and BB.\n            // Which, by definition, are prob of hom ref, het and hom var.\n            double probWrongGenotype, genotypeQuality;\n            Double homRefProbability = Double.valueOf(beagleProbabilities.get(0));\n            Double hetProbability = Double.valueOf(beagleProbabilities.get(1));\n            Double homVarProbability = Double.valueOf(beagleProbabilities.get(2));\n\n            if (bglAlleleA.isReference() && bglAlleleB.isReference()) // HomRef call\n                probWrongGenotype = hetProbability + homVarProbability;\n            else if ((bglAlleleB.isReference() && bglAlleleA.isNonReference()) || (bglAlleleA.isReference() && bglAlleleB.isNonReference()))\n                probWrongGenotype = homRefProbability + homVarProbability;\n            else // HomVar call\n                probWrongGenotype = hetProbability + homRefProbability;\n\n            // deal with numerical errors coming from limited formatting value on Beagle output files\n            if (probWrongGenotype > 1 - MIN_PROB_ERROR)\n                probWrongGenotype = 1 - MIN_PROB_ERROR;\n\n            if (1-probWrongGenotype < noCallThreshold) {\n                // quality is bad: don't call genotype\n                alleles.clear();\n                alleles.add(originalAlleleA);\n                alleles.add(originalAlleleB);\n                genotypeIsPhased = false;\n            }\n\n            if (probWrongGenotype < MIN_PROB_ERROR)\n                genotypeQuality = MAX_GENOTYPE_QUALITY;\n            else\n                genotypeQuality = log10(probWrongGenotype);\n\n            HashMap<String,Object> originalAttributes = new HashMap<String,Object>(g.getExtendedAttributes());\n\n            // get original encoding and add to keynotype attributes\n            String a1, a2, og;\n            if (originalAlleleA.isNoCall())\n                a1 = \".\";\n            else if (originalAlleleA.isReference())\n                a1 = \"0\";\n            else\n                a1 = \"1\";\n\n            if (originalAlleleB.isNoCall())\n                a2 = \".\";\n            else if (originalAlleleB.isReference())\n                a2 = \"0\";\n            else\n                a2 = \"1\";\n\n            og = a1+\"/\"+a2;\n\n            // See if Beagle switched genotypes\n            if (! originalAlleleA.equals(Allele.NO_CALL) && beagleSwitchedGenotypes(bglAlleleA,originalAlleleA,bglAlleleB,originalAlleleB)){\n                originalAttributes.put(\"OG\",og);\n                numGenotypesChangedByBeagle++;\n            }\n            else {\n                originalAttributes.put(\"OG\",\".\");\n            }\n            Genotype imputedGenotype = new GenotypeBuilder(g).alleles(alleles).log10PError(genotypeQuality).attributes(originalAttributes).phased(genotypeIsPhased).make();\n            if ( imputedGenotype.isHet() || imputedGenotype.isHomVar() ) {\n                beagleVarCounts++;\n            }\n\n            genotypes.add(imputedGenotype);\n        }\n\n        final VariantContextBuilder builder = new VariantContextBuilder(vc_input).source(\"outputvcf\").genotypes(genotypes);\n        if ( ! ( beagleVarCounts > 0 || DONT_FILTER_MONOMORPHIC_SITES ) ) {\n            Set<String> removedFilters = vc_input.filtersWereApplied() ? new HashSet<String>(vc_input.getFilters()) : new HashSet<String>(1);\n            removedFilters.add(String.format(\"BGL_RM_WAS_%s\",vc_input.getAlternateAllele(0)));\n            builder.alleles(new HashSet<Allele>(Arrays.asList(vc_input.getReference()))).filters(removedFilters);\n        }\n\n        // re-compute chromosome counts\n        VariantContextUtils.calculateChromosomeCounts(builder, false);\n\n        // Get Hapmap AC and AF\n        if (vc_comp != null) {\n            builder.attribute(\"ACH\", alleleCountH.toString() );\n            builder.attribute(\"ANH\", chrCountH.toString() );\n            builder.attribute(\"AFH\", String.format(\"%4.2f\", (double)alleleCountH/chrCountH) );\n\n        }\n\n        builder.attribute(\"NumGenotypesChanged\", numGenotypesChangedByBeagle );\n        if( !beagleR2Feature.getR2value().equals(Double.NaN) ) {\n            builder.attribute(\"R2\", beagleR2Feature.getR2value().toString() );\n        }\n\n        vcfWriter.add(builder.make());\n\n        return 1;\n    }","id":77977,"modified_method":"public Integer map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        if ( tracker == null )\n            return 0;\n\n        GenomeLoc loc = context.getLocation();\n        VariantContext vc_input = tracker.getFirstValue(variantCollection.variants, loc);\n\n        VariantContext vc_comp = tracker.getFirstValue(comp, loc);\n\n        if ( vc_input == null  )\n            return 0;\n\n        if (vc_input.isFiltered()) {\n            vcfWriter.add(vc_input);\n            return 1;\n        }\n\n        BeagleFeature beagleR2Feature = tracker.getFirstValue(beagleR2);\n        BeagleFeature beagleProbsFeature = tracker.getFirstValue(beagleProbs);\n        BeagleFeature beaglePhasedFeature = tracker.getFirstValue(beaglePhased);\n\n        // ignore places where we don't have a variant\n        if ( beagleR2Feature == null || beagleProbsFeature == null ||  beaglePhasedFeature == null)\n        {\n            vcfWriter.add(vc_input);\n            return 1;\n        }\n\n\n        // get reference base for current position\n        byte refByte = ref.getBase();\n\n        // make new Genotypes based on Beagle results\n        GenotypesContext genotypes = GenotypesContext.create(vc_input.getGenotypes().size());\n\n        // for each genotype, create a new object with Beagle information on it\n\n        int numGenotypesChangedByBeagle = 0;\n        Integer alleleCountH = 0, chrCountH = 0;\n        Double alleleFrequencyH = 0.0;\n        int beagleVarCounts = 0;\n\n        GenotypesContext hapmapGenotypes = null;\n\n        if (vc_comp != null) {\n            hapmapGenotypes = vc_comp.getGenotypes();\n        }\n\n        for ( final Genotype g : vc_input.getGenotypes() ) {\n            boolean genotypeIsPhased = true;\n            String sample = g.getSampleName();\n\n            // If we have  a Hapmap (comp) ROD, compute Hapmap AC, AN and AF\n            // use sample as key into genotypes structure\n            if (vc_comp != null) {\n\n                if (vc_input.getGenotypes().containsSample(sample) && hapmapGenotypes.containsSample(sample))  {\n\n                    Genotype hapmapGenotype = hapmapGenotypes.get(sample);\n                    if (hapmapGenotype.isCalled()){\n                        chrCountH += 2;\n                        if (hapmapGenotype.isHet()) {\n                            alleleCountH += 1;\n                        }    else if (hapmapGenotype.isHomVar()) {\n                            alleleCountH += 2;\n                        }\n                    }\n                }\n            }\n\n            ArrayList<String> beagleProbabilities = beagleProbsFeature.getProbLikelihoods().get(sample);\n            ArrayList<String> beagleGenotypePairs = beaglePhasedFeature.getGenotypes().get(sample);\n\n            // original alleles at this genotype\n            Allele originalAlleleA = g.getAllele(0);\n\n            Allele originalAlleleB = (g.getAlleles().size() == 2) ? g.getAllele(1) : g.getAllele(0); // hack to deal with no-call genotypes\n\n\n            // We have phased genotype in hp. Need to set the isRef field in the allele.\n            List<Allele> alleles = new ArrayList<Allele>();\n\n            String alleleA = beagleGenotypePairs.get(0);\n            String alleleB = beagleGenotypePairs.get(1);\n\n            if ( alleleA.equals(\"null\") || alleleB.equals(\"null\") ) {\n                logger.warn(\"Beagle produced 'null' alleles at location \"+ref.getLocus().toString()+\". Ignoring.\");\n                return 0;\n            }\n\n            // Beagle always produces genotype strings based on the strings we input in the likelihood file.\n            String refString = vc_input.getReference().getDisplayString();\n\n            Allele bglAlleleA, bglAlleleB;\n\n            if (alleleA.matches(refString))\n                bglAlleleA = Allele.create(alleleA,true);\n            else\n                bglAlleleA = Allele.create(alleleA,false);\n\n            if (alleleB.matches(refString))\n                bglAlleleB = Allele.create(alleleB,true);\n            else\n                bglAlleleB = Allele.create(alleleB,false);\n\n\n            alleles.add(bglAlleleA);\n            alleles.add(bglAlleleB);\n\n            // Compute new GQ field = -10*log10Pr(Genotype call is wrong)\n            // Beagle gives probability that genotype is AA, AB and BB.\n            // Which, by definition, are prob of hom ref, het and hom var.\n            double probWrongGenotype, genotypeQuality;\n            Double homRefProbability = Double.valueOf(beagleProbabilities.get(0));\n            Double hetProbability = Double.valueOf(beagleProbabilities.get(1));\n            Double homVarProbability = Double.valueOf(beagleProbabilities.get(2));\n\n            if (bglAlleleA.isReference() && bglAlleleB.isReference()) // HomRef call\n                probWrongGenotype = hetProbability + homVarProbability;\n            else if ((bglAlleleB.isReference() && bglAlleleA.isNonReference()) || (bglAlleleA.isReference() && bglAlleleB.isNonReference()))\n                probWrongGenotype = homRefProbability + homVarProbability;\n            else // HomVar call\n                probWrongGenotype = hetProbability + homRefProbability;\n\n            // deal with numerical errors coming from limited formatting value on Beagle output files\n            if (probWrongGenotype > 1 - MIN_PROB_ERROR)\n                probWrongGenotype = 1 - MIN_PROB_ERROR;\n\n            if (1-probWrongGenotype < noCallThreshold) {\n                // quality is bad: don't call genotype\n                alleles.clear();\n                alleles.add(originalAlleleA);\n                alleles.add(originalAlleleB);\n                genotypeIsPhased = false;\n            }\n\n            if (probWrongGenotype < MIN_PROB_ERROR)\n                genotypeQuality = MAX_GENOTYPE_QUALITY;\n            else\n                genotypeQuality = log10(probWrongGenotype);\n\n            HashMap<String,Object> originalAttributes = new HashMap<String,Object>(g.getExtendedAttributes());\n\n            // get original encoding and add to keynotype attributes\n            String a1, a2, og;\n            if (originalAlleleA.isNoCall())\n                a1 = \".\";\n            else if (originalAlleleA.isReference())\n                a1 = \"0\";\n            else\n                a1 = \"1\";\n\n            if (originalAlleleB.isNoCall())\n                a2 = \".\";\n            else if (originalAlleleB.isReference())\n                a2 = \"0\";\n            else\n                a2 = \"1\";\n\n            og = a1+\"/\"+a2;\n\n            // See if Beagle switched genotypes\n            if (! originalAlleleA.equals(Allele.NO_CALL) && beagleSwitchedGenotypes(bglAlleleA,originalAlleleA,bglAlleleB,originalAlleleB)){\n                originalAttributes.put(\"OG\",og);\n                numGenotypesChangedByBeagle++;\n            }\n            else {\n                originalAttributes.put(\"OG\",\".\");\n            }\n            Genotype imputedGenotype = new GenotypeBuilder(g).alleles(alleles).log10PError(genotypeQuality).attributes(originalAttributes).phased(genotypeIsPhased).make();\n            if ( imputedGenotype.isHet() || imputedGenotype.isHomVar() ) {\n                beagleVarCounts++;\n            }\n\n            genotypes.add(imputedGenotype);\n        }\n\n        final VariantContextBuilder builder = new VariantContextBuilder(vc_input).source(\"outputvcf\").genotypes(genotypes);\n        if ( ! ( beagleVarCounts > 0 || DONT_FILTER_MONOMORPHIC_SITES ) ) {\n            builder.attribute(ORIGINAL_ALT_ALLELE_INFO_KEY, vc_input.getAlternateAllele(0));\n            builder.alleles(Collections.singleton(vc_input.getReference())).filter(BEAGLE_MONO_FILTER_STRING);\n        }\n\n        // re-compute chromosome counts\n        VariantContextUtils.calculateChromosomeCounts(builder, false);\n\n        // Get Hapmap AC and AF\n        if (vc_comp != null) {\n            builder.attribute(\"ACH\", alleleCountH.toString() );\n            builder.attribute(\"ANH\", chrCountH.toString() );\n            builder.attribute(\"AFH\", String.format(\"%4.2f\", (double)alleleCountH/chrCountH) );\n\n        }\n\n        builder.attribute(\"NumGenotypesChanged\", numGenotypesChangedByBeagle );\n        if( !beagleR2Feature.getR2value().equals(Double.NaN) ) {\n            builder.attribute(\"R2\", beagleR2Feature.getR2value().toString() );\n        }\n\n        vcfWriter.add(builder.make());\n\n        return 1;\n    }","commit_id":"b16a048adccf0a257be66ffc01579021fd561bb6","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n\n        // setup the header fields\n\n        final Set<VCFHeaderLine> hInfo = new HashSet<VCFHeaderLine>();\n        hInfo.addAll(GATKVCFUtils.getHeaderFields(getToolkit()));\n        hInfo.add(new VCFFormatHeaderLine(\"OG\",1, VCFHeaderLineType.String, \"Original Genotype input to Beagle\"));\n        hInfo.add(new VCFInfoHeaderLine(\"R2\", 1, VCFHeaderLineType.Float, \"r2 Value reported by Beagle on each site\"));\n        hInfo.add(new VCFInfoHeaderLine(\"NumGenotypesChanged\", 1, VCFHeaderLineType.Integer, \"The number of genotypes changed by Beagle\"));\n        hInfo.add(new VCFFilterHeaderLine(\"BGL_RM_WAS_A\", \"This 'A' site was set to monomorphic by Beagle\"));\n        hInfo.add(new VCFFilterHeaderLine(\"BGL_RM_WAS_C\", \"This 'C' site was set to monomorphic by Beagle\"));\n        hInfo.add(new VCFFilterHeaderLine(\"BGL_RM_WAS_G\", \"This 'G' site was set to monomorphic by Beagle\"));\n        hInfo.add(new VCFFilterHeaderLine(\"BGL_RM_WAS_T\", \"This 'T' site was set to monomorphic by Beagle\"));\n\n        if ( comp.isBound() ) {\n            hInfo.add(new VCFInfoHeaderLine(\"ACH\", 1, VCFHeaderLineType.Integer, \"Allele Count from Comparison ROD at this site\"));\n            hInfo.add(new VCFInfoHeaderLine(\"ANH\", 1, VCFHeaderLineType.Integer, \"Allele Frequency from Comparison ROD at this site\"));\n            hInfo.add(new VCFInfoHeaderLine(\"AFH\", 1, VCFHeaderLineType.Float, \"Allele Number from Comparison ROD at this site\"));\n        }\n\n        Set<String> samples = SampleUtils.getSampleListWithVCFHeader(getToolkit(), Arrays.asList(variantCollection.variants.getName()));\n\n        final VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n        vcfWriter.writeHeader(vcfHeader);\n    }","id":77978,"modified_method":"public void initialize() {\n\n        // setup the header fields\n\n        final Set<VCFHeaderLine> hInfo = new HashSet<VCFHeaderLine>();\n        hInfo.addAll(GATKVCFUtils.getHeaderFields(getToolkit()));\n        hInfo.add(new VCFFormatHeaderLine(\"OG\",1, VCFHeaderLineType.String, \"Original Genotype input to Beagle\"));\n        hInfo.add(new VCFInfoHeaderLine(\"R2\", 1, VCFHeaderLineType.Float, \"r2 Value reported by Beagle on each site\"));\n        hInfo.add(new VCFInfoHeaderLine(\"NumGenotypesChanged\", 1, VCFHeaderLineType.Integer, \"The number of genotypes changed by Beagle\"));\n        hInfo.add(new VCFInfoHeaderLine(ORIGINAL_ALT_ALLELE_INFO_KEY, 1, VCFHeaderLineType.String, \"The original alt allele for a site set to monomorphic by Beagle\"));\n        hInfo.add(new VCFFilterHeaderLine(BEAGLE_MONO_FILTER_STRING, \"This site was set to monomorphic by Beagle\"));\n\n        if ( comp.isBound() ) {\n            hInfo.add(new VCFInfoHeaderLine(\"ACH\", 1, VCFHeaderLineType.Integer, \"Allele Count from Comparison ROD at this site\"));\n            hInfo.add(new VCFInfoHeaderLine(\"ANH\", 1, VCFHeaderLineType.Integer, \"Allele Frequency from Comparison ROD at this site\"));\n            hInfo.add(new VCFInfoHeaderLine(\"AFH\", 1, VCFHeaderLineType.Float, \"Allele Number from Comparison ROD at this site\"));\n        }\n\n        Set<String> samples = SampleUtils.getSampleListWithVCFHeader(getToolkit(), Arrays.asList(variantCollection.variants.getName()));\n\n        final VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n        vcfWriter.writeHeader(vcfHeader);\n    }","commit_id":"b16a048adccf0a257be66ffc01579021fd561bb6","url":"https://github.com/broadgsa/gatk"},{"original_method":"static LinkedHashSet<Cipher> defaultSort(final LinkedHashSet<Cipher> ciphers) {\n        final LinkedHashSet<Cipher> result = new LinkedHashSet<>(ciphers.size());\n        final LinkedHashSet<Cipher> ecdh = new LinkedHashSet<>(ciphers.size());\n\n        /* Everything else being equal, prefer ephemeral ECDH over other key exchange mechanisms */\n        ecdh.addAll(filterByKeyExchange(ciphers, new HashSet<>(Arrays.asList(KeyExchange.EECDH, KeyExchange.ECDHEPSK))));\n\n        /* AES is our preferred symmetric cipher */\n        Set<Encryption> aes = new HashSet<>(Arrays.asList(Encryption.AES128, Encryption.AES128CCM,\n                Encryption.AES128CCM8, Encryption.AES128GCM, Encryption.AES256,\n                Encryption.AES256CCM, Encryption.AES256CCM8, Encryption.AES256GCM));\n\n        /* Now arrange all ciphers by preference: */\n        result.addAll(filterByEncryption(ecdh, aes));\n        result.addAll(filterByEncryption(ciphers, aes));\n\n        /* Add everything else */\n        result.addAll(ecdh);\n        result.addAll(ciphers);\n\n        /* Low priority for MD5 */\n        moveToEnd(result, filterByMessageDigest(result, Collections.singleton(MessageDigest.MD5)));\n\n        /* Move anonymous ciphers to the end.  Usually, these will remain disabled.\n         * (For applications that allow them, they aren't too bad, but we prefer\n         * authenticated ciphers.) */\n        moveToEnd(result, filterByAuthentication(result, Collections.singleton(Authentication.aNULL)));\n\n        /* Move ciphers without forward secrecy to the end */\n        moveToEnd(result, filterByAuthentication(result, Collections.singleton(Authentication.ECDH)));\n        moveToEnd(result, filterByKeyExchange(result, Collections.singleton(KeyExchange.RSA)));\n        moveToEnd(result, filterByKeyExchange(result, Collections.singleton(KeyExchange.PSK)));\n\n        /* RC4 is sort-of broken -- move the the end */\n        moveToEnd(result, filterByEncryption(result, Collections.singleton(Encryption.RC4)));\n        return strengthSort(result);\n    }","id":77979,"modified_method":"static LinkedHashSet<Cipher> defaultSort(final LinkedHashSet<Cipher> ciphers) {\n        final LinkedHashSet<Cipher> result = new LinkedHashSet<>(ciphers.size());\n        final LinkedHashSet<Cipher> ecdh = new LinkedHashSet<>(ciphers.size());\n\n        /* Everything else being equal, prefer ephemeral ECDH over other key exchange mechanisms */\n        ecdh.addAll(filterByKeyExchange(ciphers, Collections.singleton(KeyExchange.EECDH)));\n\n        /* AES is our preferred symmetric cipher */\n        Set<Encryption> aes = new HashSet<>(Arrays.asList(Encryption.AES128, Encryption.AES128CCM,\n                Encryption.AES128CCM8, Encryption.AES128GCM, Encryption.AES256,\n                Encryption.AES256CCM, Encryption.AES256CCM8, Encryption.AES256GCM));\n\n        /* Now arrange all ciphers by preference: */\n        result.addAll(filterByEncryption(ecdh, aes));\n        result.addAll(filterByEncryption(ciphers, aes));\n\n        /* Add everything else */\n        result.addAll(ecdh);\n        result.addAll(ciphers);\n\n        /* Low priority for MD5 */\n        moveToEnd(result, filterByMessageDigest(result, Collections.singleton(MessageDigest.MD5)));\n\n        /* Move anonymous ciphers to the end.  Usually, these will remain disabled.\n         * (For applications that allow them, they aren't too bad, but we prefer\n         * authenticated ciphers.) */\n        moveToEnd(result, filterByAuthentication(result, Collections.singleton(Authentication.aNULL)));\n\n        /* Move ciphers without forward secrecy to the end */\n        moveToEnd(result, filterByAuthentication(result, Collections.singleton(Authentication.ECDH)));\n        moveToEnd(result, filterByKeyExchange(result, Collections.singleton(KeyExchange.RSA)));\n        moveToEnd(result, filterByKeyExchange(result, Collections.singleton(KeyExchange.PSK)));\n\n        /* RC4 is sort-of broken -- move the the end */\n        moveToEnd(result, filterByEncryption(result, Collections.singleton(Encryption.RC4)));\n        return strengthSort(result);\n    }","commit_id":"8d4b2b4aa53dd19f87018c144435bb3ff3cb168c","url":"https://github.com/apache/tomcat"},{"original_method":"private static final void init() {\n\n        for (Cipher cipher : Cipher.values()) {\n            String alias = cipher.getOpenSSLAlias();\n            if (aliases.containsKey(alias)) {\n                aliases.get(alias).add(cipher);\n            } else {\n                List<Cipher> list = new ArrayList<>();\n                list.add(cipher);\n                aliases.put(alias, list);\n            }\n            aliases.put(cipher.name(), Collections.singletonList(cipher));\n\n            for (String openSSlAltName : cipher.getOpenSSLAltNames()) {\n                if (aliases.containsKey(openSSlAltName)) {\n                    aliases.get(openSSlAltName).add(cipher);\n                } else {\n                    List<Cipher> list = new ArrayList<>();\n                    list.add(cipher);\n                    aliases.put(openSSlAltName, list);\n                }\n\n            }\n\n            jsseToOpenSSL.put(cipher.name(), cipher.getOpenSSLAlias());\n            Set<String> jsseNames = cipher.getJsseNames();\n            for (String jsseName : jsseNames) {\n                jsseToOpenSSL.put(jsseName, cipher.getOpenSSLAlias());\n            }\n        }\n        List<Cipher> allCiphersList = Arrays.asList(Cipher.values());\n        Collections.reverse(allCiphersList);\n        LinkedHashSet<Cipher> allCiphers = defaultSort(new LinkedHashSet<>(allCiphersList));\n        addListAlias(eNULL, filterByEncryption(allCiphers, Collections.singleton(Encryption.eNULL)));\n        LinkedHashSet<Cipher> all = new LinkedHashSet<>(allCiphers);\n        remove(all, eNULL);\n        addListAlias(ALL, all);\n        addListAlias(HIGH, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.HIGH)));\n        addListAlias(MEDIUM, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.MEDIUM)));\n        addListAlias(LOW, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.LOW)));\n        addListAlias(EXPORT, filterByEncryptionLevel(allCiphers, new HashSet<>(Arrays.asList(EncryptionLevel.EXP40, EncryptionLevel.EXP56))));\n        aliases.put(\"EXP\", aliases.get(EXPORT));\n        addListAlias(EXPORT40, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.EXP40)));\n        addListAlias(EXPORT56, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.EXP56)));\n        aliases.put(\"NULL\", aliases.get(eNULL));\n        aliases.put(COMPLEMENTOFALL, aliases.get(eNULL));\n        addListAlias(aNULL, filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(kRSA, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.RSA)));\n        addListAlias(aRSA, filterByAuthentication(allCiphers, Collections.singleton(Authentication.RSA)));\n        // Despite what the docs say, RSA is equivalent to kRSA\n        aliases.put(RSA, aliases.get(kRSA));\n        addListAlias(kEDH, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH)));\n        addListAlias(kDHE, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH)));\n        Set<Cipher> edh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH));\n        edh.removeAll(filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(EDH, edh);\n        addListAlias(DHE, edh);\n        addListAlias(kDHr, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.DHr)));\n        addListAlias(kDHd, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.DHd)));\n        addListAlias(kDH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.DHr, KeyExchange.DHd))));\n\n        addListAlias(kECDHr, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.ECDHr)));\n        addListAlias(kECDHe, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.ECDHe)));\n        addListAlias(kECDH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.ECDHe, KeyExchange.ECDHr))));\n        addListAlias(ECDH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.ECDHe, KeyExchange.ECDHr, KeyExchange.EECDH))));\n        addListAlias(kECDHE, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.ECDHe)));\n        aliases.put(ECDHE, aliases.get(kECDHE));\n        addListAlias(kEECDH, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EECDH)));\n        aliases.put(EECDHE, aliases.get(kEECDH));\n        Set<Cipher> eecdh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EECDH));\n        eecdh.removeAll(filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(EECDH, eecdh);\n        addListAlias(aDSS, filterByAuthentication(allCiphers, Collections.singleton(Authentication.DSS)));\n        aliases.put(\"DSS\", aliases.get(aDSS));\n        addListAlias(aDH, filterByAuthentication(allCiphers, Collections.singleton(Authentication.DH)));\n        Set<Cipher> aecdh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EECDH));\n        addListAlias(AECDH, filterByAuthentication(aecdh, Collections.singleton(Authentication.aNULL)));\n        addListAlias(aECDH, filterByAuthentication(allCiphers, Collections.singleton(Authentication.ECDH)));\n        addListAlias(ECDSA, filterByAuthentication(allCiphers, Collections.singleton(Authentication.ECDSA)));\n        aliases.put(aECDSA, aliases.get(ECDSA));\n        addListAlias(kFZA, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.FZA)));\n        addListAlias(aFZA, filterByAuthentication(allCiphers, Collections.singleton(Authentication.FZA)));\n        addListAlias(eFZA, filterByEncryption(allCiphers, Collections.singleton(Encryption.FZA)));\n        addListAlias(FZA, filter(allCiphers, null, Collections.singleton(KeyExchange.FZA), Collections.singleton(Authentication.FZA), Collections.singleton(Encryption.FZA), null, null));\n        addListAlias(Constants.SSL_PROTO_TLSv1_2, filterByProtocol(allCiphers, Collections.singleton(Protocol.TLSv1_2)));\n        addListAlias(Constants.SSL_PROTO_TLSv1_1, filterByProtocol(allCiphers, Collections.singleton(Protocol.SSLv3)));\n        addListAlias(Constants.SSL_PROTO_TLSv1, filterByProtocol(allCiphers, new HashSet<>(Arrays.asList(Protocol.TLSv1, Protocol.SSLv3))));\n        aliases.put(Constants.SSL_PROTO_SSLv3, aliases.get(Constants.SSL_PROTO_TLSv1));\n        addListAlias(Constants.SSL_PROTO_SSLv2, filterByProtocol(allCiphers, Collections.singleton(Protocol.SSLv2)));\n        addListAlias(DH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.DHr, KeyExchange.DHd, KeyExchange.EDH))));\n        Set<Cipher> adh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH));\n        adh.retainAll(filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(ADH, adh);\n        addListAlias(AES128, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES128, Encryption.AES128CCM, Encryption.AES128CCM8, Encryption.AES128GCM))));\n        addListAlias(AES256, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES256, Encryption.AES256CCM, Encryption.AES256CCM8, Encryption.AES256GCM))));\n        addListAlias(AES, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES128, Encryption.AES128CCM, Encryption.AES128CCM8, Encryption.AES128GCM, Encryption.AES256, Encryption.AES256CCM, Encryption.AES256CCM8, Encryption.AES256GCM))));\n        addListAlias(AESGCM, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES128GCM, Encryption.AES256GCM))));\n        addListAlias(CAMELLIA, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.CAMELLIA128, Encryption.CAMELLIA256))));\n        addListAlias(CAMELLIA128, filterByEncryption(allCiphers, Collections.singleton(Encryption.CAMELLIA128)));\n        addListAlias(CAMELLIA256, filterByEncryption(allCiphers, Collections.singleton(Encryption.CAMELLIA256)));\n        addListAlias(TRIPLE_DES, filterByEncryption(allCiphers, Collections.singleton(Encryption.TRIPLE_DES)));\n        addListAlias(DES, filterByEncryption(allCiphers, Collections.singleton(Encryption.DES)));\n        addListAlias(RC4, filterByEncryption(allCiphers, Collections.singleton(Encryption.RC4)));\n        addListAlias(RC2, filterByEncryption(allCiphers, Collections.singleton(Encryption.RC2)));\n        addListAlias(IDEA, filterByEncryption(allCiphers, Collections.singleton(Encryption.IDEA)));\n        addListAlias(SEED, filterByEncryption(allCiphers, Collections.singleton(Encryption.SEED)));\n        addListAlias(MD5, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.MD5)));\n        addListAlias(SHA1, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.SHA1)));\n        aliases.put(SHA, aliases.get(SHA1));\n        addListAlias(SHA256, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.SHA256)));\n        addListAlias(SHA384, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.SHA384)));\n        addListAlias(aGOST, filterByAuthentication(allCiphers, new HashSet<>(Arrays.asList(Authentication.GOST01, Authentication.GOST94))));\n        addListAlias(aGOST01, filterByAuthentication(allCiphers, Collections.singleton(Authentication.GOST01)));\n        addListAlias(aGOST94, filterByAuthentication(allCiphers, Collections.singleton(Authentication.GOST94)));\n        addListAlias(kGOST, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.GOST)));\n        addListAlias(GOST94, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.GOST94)));\n        addListAlias(GOST89MAC, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.GOST89MAC)));\n        addListAlias(PSK, filter(allCiphers, null, new HashSet<>(Arrays.asList(KeyExchange.PSK, KeyExchange.RSAPSK, KeyExchange.DHEPSK, KeyExchange.ECDHEPSK)), Collections.singleton(Authentication.PSK), null, null, null));\n        addListAlias(KRB5, filter(allCiphers, null, Collections.singleton(KeyExchange.KRB5), Collections.singleton(Authentication.KRB5), null, null, null));\n        addListAlias(aSRP, filterByAuthentication(allCiphers, Collections.singleton(Authentication.SRP)));\n        addListAlias(kSRP, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.SRP)));\n        addListAlias(SRP, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.SRP)));\n        initialized = true;\n        // Despite what the OpenSSL docs say, DEFAULT also excludes SSLv2\n        addListAlias(DEFAULT, parse(\"ALL:!EXPORT:!eNULL:!aNULL:!SSLv2:!DES:!RC2:!RC4\"));\n        // COMPLEMENTOFDEFAULT is also not exactly as defined by the docs\n        Set<Cipher> complementOfDefault = filterByKeyExchange(all, new HashSet<>(Arrays.asList(KeyExchange.EDH,KeyExchange.EECDH)));\n        complementOfDefault = filterByAuthentication(complementOfDefault, Collections.singleton(Authentication.aNULL));\n        complementOfDefault.removeAll(aliases.get(eNULL));\n        complementOfDefault.addAll(aliases.get(Constants.SSL_PROTO_SSLv2));\n        complementOfDefault.addAll(aliases.get(EXPORT));\n        complementOfDefault.addAll(aliases.get(DES));\n        complementOfDefault.addAll(aliases.get(RC2));\n        complementOfDefault.addAll(aliases.get(RC4));\n        addListAlias(COMPLEMENTOFDEFAULT, complementOfDefault);\n    }","id":77980,"modified_method":"private static final void init() {\n\n        for (Cipher cipher : Cipher.values()) {\n            String alias = cipher.getOpenSSLAlias();\n            if (aliases.containsKey(alias)) {\n                aliases.get(alias).add(cipher);\n            } else {\n                List<Cipher> list = new ArrayList<>();\n                list.add(cipher);\n                aliases.put(alias, list);\n            }\n            aliases.put(cipher.name(), Collections.singletonList(cipher));\n\n            for (String openSSlAltName : cipher.getOpenSSLAltNames()) {\n                if (aliases.containsKey(openSSlAltName)) {\n                    aliases.get(openSSlAltName).add(cipher);\n                } else {\n                    List<Cipher> list = new ArrayList<>();\n                    list.add(cipher);\n                    aliases.put(openSSlAltName, list);\n                }\n\n            }\n\n            jsseToOpenSSL.put(cipher.name(), cipher.getOpenSSLAlias());\n            Set<String> jsseNames = cipher.getJsseNames();\n            for (String jsseName : jsseNames) {\n                jsseToOpenSSL.put(jsseName, cipher.getOpenSSLAlias());\n            }\n        }\n        List<Cipher> allCiphersList = Arrays.asList(Cipher.values());\n        Collections.reverse(allCiphersList);\n        LinkedHashSet<Cipher> allCiphers = defaultSort(new LinkedHashSet<>(allCiphersList));\n        addListAlias(eNULL, filterByEncryption(allCiphers, Collections.singleton(Encryption.eNULL)));\n        LinkedHashSet<Cipher> all = new LinkedHashSet<>(allCiphers);\n        remove(all, eNULL);\n        addListAlias(ALL, all);\n        addListAlias(HIGH, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.HIGH)));\n        addListAlias(MEDIUM, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.MEDIUM)));\n        addListAlias(LOW, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.LOW)));\n        addListAlias(EXPORT, filterByEncryptionLevel(allCiphers, new HashSet<>(Arrays.asList(EncryptionLevel.EXP40, EncryptionLevel.EXP56))));\n        aliases.put(\"EXP\", aliases.get(EXPORT));\n        addListAlias(EXPORT40, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.EXP40)));\n        addListAlias(EXPORT56, filterByEncryptionLevel(allCiphers, Collections.singleton(EncryptionLevel.EXP56)));\n        aliases.put(\"NULL\", aliases.get(eNULL));\n        aliases.put(COMPLEMENTOFALL, aliases.get(eNULL));\n        addListAlias(aNULL, filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(kRSA, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.RSA)));\n        addListAlias(aRSA, filterByAuthentication(allCiphers, Collections.singleton(Authentication.RSA)));\n        // Despite what the docs say, RSA is equivalent to kRSA\n        aliases.put(RSA, aliases.get(kRSA));\n        addListAlias(kEDH, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH)));\n        addListAlias(kDHE, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH)));\n        Set<Cipher> edh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH));\n        edh.removeAll(filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(EDH, edh);\n        addListAlias(DHE, edh);\n        addListAlias(kDHr, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.DHr)));\n        addListAlias(kDHd, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.DHd)));\n        addListAlias(kDH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.DHr, KeyExchange.DHd))));\n\n        addListAlias(kECDHr, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.ECDHr)));\n        addListAlias(kECDHe, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.ECDHe)));\n        addListAlias(kECDH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.ECDHe, KeyExchange.ECDHr))));\n        addListAlias(ECDH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.ECDHe, KeyExchange.ECDHr, KeyExchange.EECDH))));\n        addListAlias(kECDHE, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.ECDHe)));\n        aliases.put(ECDHE, aliases.get(kECDHE));\n        addListAlias(kEECDH, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EECDH)));\n        aliases.put(EECDHE, aliases.get(kEECDH));\n        Set<Cipher> eecdh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EECDH));\n        eecdh.removeAll(filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(EECDH, eecdh);\n        addListAlias(aDSS, filterByAuthentication(allCiphers, Collections.singleton(Authentication.DSS)));\n        aliases.put(\"DSS\", aliases.get(aDSS));\n        addListAlias(aDH, filterByAuthentication(allCiphers, Collections.singleton(Authentication.DH)));\n        Set<Cipher> aecdh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EECDH));\n        addListAlias(AECDH, filterByAuthentication(aecdh, Collections.singleton(Authentication.aNULL)));\n        addListAlias(aECDH, filterByAuthentication(allCiphers, Collections.singleton(Authentication.ECDH)));\n        addListAlias(ECDSA, filterByAuthentication(allCiphers, Collections.singleton(Authentication.ECDSA)));\n        aliases.put(aECDSA, aliases.get(ECDSA));\n        addListAlias(kFZA, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.FZA)));\n        addListAlias(aFZA, filterByAuthentication(allCiphers, Collections.singleton(Authentication.FZA)));\n        addListAlias(eFZA, filterByEncryption(allCiphers, Collections.singleton(Encryption.FZA)));\n        addListAlias(FZA, filter(allCiphers, null, Collections.singleton(KeyExchange.FZA), Collections.singleton(Authentication.FZA), Collections.singleton(Encryption.FZA), null, null));\n        addListAlias(Constants.SSL_PROTO_TLSv1_2, filterByProtocol(allCiphers, Collections.singleton(Protocol.TLSv1_2)));\n        addListAlias(Constants.SSL_PROTO_TLSv1_0, filterByProtocol(allCiphers, Collections.singleton(Protocol.TLSv1)));\n        addListAlias(Constants.SSL_PROTO_SSLv3, filterByProtocol(allCiphers, Collections.singleton(Protocol.SSLv3)));\n        aliases.put(Constants.SSL_PROTO_TLSv1, aliases.get(Constants.SSL_PROTO_SSLv3));\n        addListAlias(Constants.SSL_PROTO_SSLv2, filterByProtocol(allCiphers, Collections.singleton(Protocol.SSLv2)));\n        addListAlias(DH, filterByKeyExchange(allCiphers, new HashSet<>(Arrays.asList(KeyExchange.DHr, KeyExchange.DHd, KeyExchange.EDH))));\n        Set<Cipher> adh = filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.EDH));\n        adh.retainAll(filterByAuthentication(allCiphers, Collections.singleton(Authentication.aNULL)));\n        addListAlias(ADH, adh);\n        addListAlias(AES128, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES128, Encryption.AES128CCM, Encryption.AES128CCM8, Encryption.AES128GCM))));\n        addListAlias(AES256, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES256, Encryption.AES256CCM, Encryption.AES256CCM8, Encryption.AES256GCM))));\n        addListAlias(AES, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES128, Encryption.AES128CCM, Encryption.AES128CCM8, Encryption.AES128GCM, Encryption.AES256, Encryption.AES256CCM, Encryption.AES256CCM8, Encryption.AES256GCM))));\n        addListAlias(AESGCM, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.AES128GCM, Encryption.AES256GCM))));\n        addListAlias(CAMELLIA, filterByEncryption(allCiphers, new HashSet<>(Arrays.asList(Encryption.CAMELLIA128, Encryption.CAMELLIA256))));\n        addListAlias(CAMELLIA128, filterByEncryption(allCiphers, Collections.singleton(Encryption.CAMELLIA128)));\n        addListAlias(CAMELLIA256, filterByEncryption(allCiphers, Collections.singleton(Encryption.CAMELLIA256)));\n        addListAlias(TRIPLE_DES, filterByEncryption(allCiphers, Collections.singleton(Encryption.TRIPLE_DES)));\n        addListAlias(DES, filterByEncryption(allCiphers, Collections.singleton(Encryption.DES)));\n        addListAlias(RC4, filterByEncryption(allCiphers, Collections.singleton(Encryption.RC4)));\n        addListAlias(RC2, filterByEncryption(allCiphers, Collections.singleton(Encryption.RC2)));\n        addListAlias(IDEA, filterByEncryption(allCiphers, Collections.singleton(Encryption.IDEA)));\n        addListAlias(SEED, filterByEncryption(allCiphers, Collections.singleton(Encryption.SEED)));\n        addListAlias(MD5, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.MD5)));\n        addListAlias(SHA1, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.SHA1)));\n        aliases.put(SHA, aliases.get(SHA1));\n        addListAlias(SHA256, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.SHA256)));\n        addListAlias(SHA384, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.SHA384)));\n        addListAlias(aGOST, filterByAuthentication(allCiphers, new HashSet<>(Arrays.asList(Authentication.GOST01, Authentication.GOST94))));\n        addListAlias(aGOST01, filterByAuthentication(allCiphers, Collections.singleton(Authentication.GOST01)));\n        addListAlias(aGOST94, filterByAuthentication(allCiphers, Collections.singleton(Authentication.GOST94)));\n        addListAlias(kGOST, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.GOST)));\n        addListAlias(GOST94, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.GOST94)));\n        addListAlias(GOST89MAC, filterByMessageDigest(allCiphers, Collections.singleton(MessageDigest.GOST89MAC)));\n        addListAlias(PSK, filter(allCiphers, null, new HashSet<>(Arrays.asList(KeyExchange.PSK, KeyExchange.RSAPSK, KeyExchange.DHEPSK, KeyExchange.ECDHEPSK)), Collections.singleton(Authentication.PSK), null, null, null));\n        addListAlias(KRB5, filter(allCiphers, null, Collections.singleton(KeyExchange.KRB5), Collections.singleton(Authentication.KRB5), null, null, null));\n        addListAlias(aSRP, filterByAuthentication(allCiphers, Collections.singleton(Authentication.SRP)));\n        addListAlias(kSRP, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.SRP)));\n        addListAlias(SRP, filterByKeyExchange(allCiphers, Collections.singleton(KeyExchange.SRP)));\n        initialized = true;\n        // Despite what the OpenSSL docs say, DEFAULT also excludes SSLv2\n        addListAlias(DEFAULT, parse(\"ALL:!EXPORT:!eNULL:!aNULL:!SSLv2:!DES:!RC2:!RC4\"));\n        // COMPLEMENTOFDEFAULT is also not exactly as defined by the docs\n        Set<Cipher> complementOfDefault = filterByKeyExchange(all, new HashSet<>(Arrays.asList(KeyExchange.EDH,KeyExchange.EECDH)));\n        complementOfDefault = filterByAuthentication(complementOfDefault, Collections.singleton(Authentication.aNULL));\n        complementOfDefault.removeAll(aliases.get(eNULL));\n        complementOfDefault.addAll(aliases.get(Constants.SSL_PROTO_SSLv2));\n        complementOfDefault.addAll(aliases.get(EXPORT));\n        complementOfDefault.addAll(aliases.get(DES));\n        complementOfDefault.addAll(aliases.get(RC2));\n        complementOfDefault.addAll(aliases.get(RC4));\n        addListAlias(COMPLEMENTOFDEFAULT, complementOfDefault);\n    }","commit_id":"0da70300536d9a20f79db015939f11944987f172","url":"https://github.com/apache/tomcat"},{"original_method":"public static boolean createRootRule_Condition_1194610104145(final IOperationContext operationContext, final CreateRootRuleContext _context) {\n    SModel smodel = _context.getGenerator().getSourceModel();\n    return SequenceOperations.getSize(SModelOperations.getNodes(smodel, \"jetbrains.mps.regexp.structure.InlineRegexpExpression\")) > 0;\n  }","id":77981,"modified_method":"public static boolean createRootRule_Condition_1194610104145(final IOperationContext operationContext, final CreateRootRuleContext _context) {\n    SModel smodel = _context.getGenerator().getSourceModel();\n    return ListSequence.fromList(SModelOperations.getNodes(smodel, \"jetbrains.mps.regexp.structure.InlineRegexpExpression\")).count() > 0;\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_1174655313358(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_pattern_\" + SequenceOperations.getSize(nodes);\n  }","id":77982,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174655313358(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_pattern_\" + ListSequence.fromList(nodes).count();\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_1175169648262(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_matcher_\" + SequenceOperations.getSize(nodes);\n  }","id":77983,"modified_method":"public static Object propertyMacro_GetPropertyValue_1175169648262(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_matcher_\" + ListSequence.fromList(nodes).count();\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_1175155526348(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_pattern_\" + SequenceOperations.getSize(nodes);\n  }","id":77984,"modified_method":"public static Object propertyMacro_GetPropertyValue_1175155526348(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_pattern_\" + ListSequence.fromList(nodes).count();\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_1175155558088(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_matcher_\" + SequenceOperations.getSize(nodes);\n  }","id":77985,"modified_method":"public static Object propertyMacro_GetPropertyValue_1175155558088(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_matcher_\" + ListSequence.fromList(nodes).count();\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_1174655168104(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_matcher_\" + SequenceOperations.getSize(nodes);\n  }","id":77986,"modified_method":"public static Object propertyMacro_GetPropertyValue_1174655168104(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_matcher_\" + ListSequence.fromList(nodes).count();\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_1175169642723(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_pattern_\" + SequenceOperations.getSize(nodes);\n  }","id":77987,"modified_method":"public static Object propertyMacro_GetPropertyValue_1175169642723(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    List<SNode> nodes = SNodeOperations.getAncestors(_context.getNode(), \"jetbrains.mps.regexp.structure.RegexpUsingConstruction\", false);\n    return \"_pattern_\" + ListSequence.fromList(nodes).count();\n  }","commit_id":"caadc407b0cd541c93057f38b91bfe399afbc58d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void _doFireDeployEvent(HotDeployEvent event) {\n\t\tif (_deployedServletContextNames.contains(\n\t\t\t\tevent.getServletContextName())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tboolean hasDependencies = true;\n\n\t\tSet<String> dependentServletContextNames =\n\t\t\tevent.getDependentServletContextNames();\n\n\t\tfor (String dependentServletContextName :\n\t\t\t\tdependentServletContextNames) {\n\n\t\t\tif (!_deployedServletContextNames.contains(\n\t\t\t\t\tdependentServletContextName)) {\n\n\t\t\t\thasDependencies = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hasDependencies) {\n\t\t\tif (_dependentEvents.contains(event)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Deploy \" + event.getServletContextName() +\n\t\t\t\t\t\t\t\" from queue\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (HotDeployListener listener : _listeners) {\n\t\t\t\ttry {\n\t\t\t\t\tlistener.invokeDeploy(event);\n\t\t\t\t}\n\t\t\t\tcatch (HotDeployException hde) {\n\t\t\t\t\t_log.error(hde, hde);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_deployedServletContextNames.add(event.getServletContextName());\n\n\t\t\t_dependentEvents.remove(event);\n\n\t\t\tList<HotDeployEvent> dependentEvents =\n\t\t\t\tnew ArrayList<HotDeployEvent>(_dependentEvents);\n\n\t\t\tfor (HotDeployEvent dependentEvent : dependentEvents) {\n\t\t\t\t_doFireDeployEvent(dependentEvent);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!_dependentEvents.contains(event)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Queue \" + event.getServletContextName() +\n\t\t\t\t\t\t\t\" for deploy because its dependencies are not \" +\n\t\t\t\t\t\t\t\t\"available\");\n\t\t\t\t}\n\n\t\t\t\t_dependentEvents.add(event);\n\t\t\t}\n\t\t}\n\t}","id":77988,"modified_method":"private void _doFireDeployEvent(HotDeployEvent event) {\n\t\tif (_deployedServletContextNames.contains(\n\t\t\t\tevent.getServletContextName())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> missingServletContextNames = new ArrayList<String>();\n\n\t\tSet<String> dependentServletContextNames =\n\t\t\tevent.getDependentServletContextNames();\n\n\t\tfor (String dependentServletContextName :\n\t\t\t\tdependentServletContextNames) {\n\n\t\t\tif (!_deployedServletContextNames.contains(\n\t\t\t\t\tdependentServletContextName)) {\n\n\t\t\t\tmissingServletContextNames.add(dependentServletContextName);\n\t\t\t}\n\t\t}\n\n\t\tif (missingServletContextNames.isEmpty()) {\n\t\t\tif (_dependentEvents.contains(event)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Deploy \" + event.getServletContextName() +\n\t\t\t\t\t\t\t\" from queue\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (HotDeployListener listener : _listeners) {\n\t\t\t\ttry {\n\t\t\t\t\tlistener.invokeDeploy(event);\n\t\t\t\t}\n\t\t\t\tcatch (HotDeployException hde) {\n\t\t\t\t\t_log.error(hde, hde);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_deployedServletContextNames.add(event.getServletContextName());\n\n\t\t\t_dependentEvents.remove(event);\n\n\t\t\tList<HotDeployEvent> dependentEvents =\n\t\t\t\tnew ArrayList<HotDeployEvent>(_dependentEvents);\n\n\t\t\tfor (HotDeployEvent dependentEvent : dependentEvents) {\n\t\t\t\t_doFireDeployEvent(dependentEvent);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!_dependentEvents.contains(event)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\t\tsb.append(\"Queue \");\n\t\t\t\t\tsb.append(event.getServletContextName());\n\t\t\t\t\tsb.append(\" for deploy because it is missing \");\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\tStringUtil.merge(missingServletContextNames, \", \"));\n\n\t\t\t\t\t_log.info(sb.toString());\n\t\t\t\t}\n\n\t\t\t\t_dependentEvents.add(event);\n\t\t\t}\n\t\t}\n\t}","commit_id":"89ccdd6b16c4f1ff85aae9c8c9c91da020390bfb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initRulesWithWord() {\n    if (testOptions.verbose || DEBUG_LEXICON) {\n      log.info(\"\\nInitializing lexicon scores ... \");\n    }\n    // int numWords = words.size()+sigs.size()+1;\n    int unkWord = wordIndex.addToIndex(UNKNOWN_WORD);\n    int numWords = wordIndex.size();\n    rulesWithWord = new List[numWords];\n    for (int w = 0; w < numWords; w++) {\n      rulesWithWord[w] = new ArrayList<>(1); // most have 1 or 2\n                                                          // items in them\n    }\n    // for (Iterator ruleI = rules.iterator(); ruleI.hasNext();) {\n    tags = Generics.newHashSet();\n    for (IntTaggedWord iTW : seenCounter.keySet()) {\n      if (iTW.word() == nullWord && iTW.tag() != nullTag) {\n        tags.add(iTW);\n      }\n    }\n\n    // tags for unknown words\n    if (DEBUG_LEXICON) {\n      log.info(\"Lexicon initializing tags for UNKNOWN WORD (\" +\n                         Lexicon.UNKNOWN_WORD + \", \" + unkWord + ')');\n    }\n    if (DEBUG_LEXICON) log.info(\"unSeenCounter is: \" + uwModel.unSeenCounter());\n    if (DEBUG_LEXICON) log.info(\"Train.openClassTypesThreshold is \" + trainOptions.openClassTypesThreshold);\n    for (IntTaggedWord iT : tags) {\n      if (DEBUG_LEXICON) log.info(\"Entry for \" + iT + \" is \" + uwModel.unSeenCounter().getCount(iT));\n      double types = uwModel.unSeenCounter().getCount(iT);\n      if (types > trainOptions.openClassTypesThreshold) {\n        // Number of types before it's treated as open class\n        IntTaggedWord iTW = new IntTaggedWord(unkWord, iT.tag);\n        rulesWithWord[iTW.word].add(iTW);\n      }\n    }\n    if (testOptions.verbose || DEBUG_LEXICON) {\n      log.info(\"The \" + rulesWithWord[unkWord].size() + \" open class tags are: [\");\n      for (IntTaggedWord item : rulesWithWord[unkWord]) {\n        log.info(\" \" + tagIndex.get(item.tag()));\n        if (DEBUG_LEXICON) {\n          IntTaggedWord iTprint = new IntTaggedWord(nullWord, item.tag);\n          log.info(\" (tag \" + item.tag() + \", type count is \" +\n                           uwModel.unSeenCounter().getCount(iTprint) + ')');\n        }\n      }\n      log.info(\" ] \");\n    }\n\n    for (IntTaggedWord iTW : seenCounter.keySet()) {\n      if (iTW.tag() != nullTag && iTW.word() != nullWord) {\n        rulesWithWord[iTW.word].add(iTW);\n      }\n    }\n  }","id":77989,"modified_method":"protected void initRulesWithWord() {\n    if (testOptions.verbose || DEBUG_LEXICON) {\n      log.info(\"\\nInitializing lexicon scores ... \");\n    }\n    // int numWords = words.size()+sigs.size()+1;\n    int unkWord = wordIndex.addToIndex(UNKNOWN_WORD);\n    int numWords = wordIndex.size();\n    rulesWithWord = new List[numWords];\n    for (int w = 0; w < numWords; w++) {\n      rulesWithWord[w] = new ArrayList<>(1); // most have 1 or 2\n                                                          // items in them\n    }\n    // for (Iterator ruleI = rules.iterator(); ruleI.hasNext();) {\n    tags = Generics.newHashSet();\n    for (IntTaggedWord iTW : seenCounter.keySet()) {\n      if (iTW.word() == nullWord && iTW.tag() != nullTag) {\n        tags.add(iTW);\n      }\n    }\n\n    // tags for unknown words\n    if (DEBUG_LEXICON) {\n      log.info(\"Lexicon initializing tags for UNKNOWN WORD (\" +\n                         Lexicon.UNKNOWN_WORD + \", \" + unkWord + ')');\n    }\n    if (DEBUG_LEXICON) log.info(\"unSeenCounter is: \" + uwModel.unSeenCounter());\n    if (DEBUG_LEXICON) log.info(\"Train.openClassTypesThreshold is \" + trainOptions.openClassTypesThreshold);\n    for (IntTaggedWord iT : tags) {\n      if (DEBUG_LEXICON) log.info(\"Entry for \" + iT + \" is \" + uwModel.unSeenCounter().getCount(iT));\n      double types = uwModel.unSeenCounter().getCount(iT);\n      if (types > trainOptions.openClassTypesThreshold) {\n        // Number of types before it's treated as open class\n        IntTaggedWord iTW = new IntTaggedWord(unkWord, iT.tag);\n        rulesWithWord[iTW.word].add(iTW);\n      }\n    }\n    if (testOptions.verbose || DEBUG_LEXICON) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"The \").append(rulesWithWord[unkWord].size()).append(\" open class tags are: [\");\n      for (IntTaggedWord item : rulesWithWord[unkWord]) {\n        sb.append(' ').append(tagIndex.get(item.tag()));\n        if (DEBUG_LEXICON) {\n          IntTaggedWord iTprint = new IntTaggedWord(nullWord, item.tag);\n          sb.append(\" (tag \").append(item.tag()).append(\", type count is \");\n          sb.append(uwModel.unSeenCounter().getCount(iTprint)).append(')');\n        }\n      }\n      sb.append(\" ]\");\n      log.info(sb.toString());\n    }\n\n    for (IntTaggedWord iTW : seenCounter.keySet()) {\n      if (iTW.tag() != nullTag && iTW.word() != nullWord) {\n        rulesWithWord[iTW.word].add(iTW);\n      }\n    }\n  }","commit_id":"c7a0688f771453bdbec1431d9ffbe3a73b1ff167","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Print the start of timing message to stderr and start the timer. */\n  public static void startDoing(String str) {\n    log.info(str);\n    log.info(\" ... \");\n    System.err.flush();\n    startTime();\n  }","id":77990,"modified_method":"/** Print the start of timing message to stderr and start the timer. */\n  public static void startDoing(String str) {\n    log.info(str + \" ... \");\n    startTime();\n  }","commit_id":"c7a0688f771453bdbec1431d9ffbe3a73b1ff167","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Print the start of timing message to stderr and start the timer. */\n  public void doing(String str) {\n    log.info(str);\n    log.info(\" ... \");\n    System.err.flush();\n    start();\n  }","id":77991,"modified_method":"/** Print the start of timing message to stderr and start the timer. */\n  public void doing(String str) {\n    log.info(str + \" ... \");\n    start();\n  }","commit_id":"c7a0688f771453bdbec1431d9ffbe3a73b1ff167","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EntryPointer(final long entryId, final long shardId) {\n    super(entryId, shardId);\n  }","id":77992,"modified_method":"public EntryPointer(final long entryId,\n      final long shardId) {\n    super(null, entryId, shardId);\n  }","commit_id":"f046870d6975a67cc9bd012ca8d8f6df5c7a776b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\r\n  public boolean equals(Object o) {\r\n    return entryId == ((QueueEntryPointer)o).entryId &&\r\n        shardId == ((QueueEntryPointer)o).shardId;\r\n  }","id":77993,"modified_method":"@Override\r\n  public boolean equals(Object o) {\r\n    return this.entryId == ((QueueEntryPointer)o).entryId &&\r\n        this.shardId == ((QueueEntryPointer)o).shardId;\r\n  }","commit_id":"f046870d6975a67cc9bd012ca8d8f6df5c7a776b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\r\n  public String toString() {\r\n    return Objects.toStringHelper(this)\r\n        .add(\"entryId\", this.entryId)\r\n        .add(\"shardId\", this.shardId)\r\n        .toString();\r\n  }","id":77994,"modified_method":"@Override\r\n  public String toString() {\r\n    return Objects.toStringHelper(this)\r\n        .add(\"queueName\", this.queueName)\r\n        .add(\"entryId\", this.entryId)\r\n        .add(\"shardId\", this.shardId)\r\n        .toString();\r\n  }","commit_id":"f046870d6975a67cc9bd012ca8d8f6df5c7a776b","url":"https://github.com/caskdata/cdap"},{"original_method":"public QueueEntryPointer(final long entryId, final long shardId) {\r\n    this.entryId = entryId;\r\n    this.shardId = shardId;\r\n  }","id":77995,"modified_method":"public QueueEntryPointer(final byte [] queueName, final long entryId,\r\n      final long shardId) {\r\n    this.queueName = queueName;\r\n    this.entryId = entryId;\r\n    this.shardId = shardId;\r\n  }","commit_id":"f046870d6975a67cc9bd012ca8d8f6df5c7a776b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public EnqueueResult enqueue(byte[] data, long cleanWriteVersion) {\n    log(\"Enqueueing (data.len=\" + data.length + \", writeVersion=\" +\n        cleanWriteVersion + \")\");\n    // Get a dirty pointer\n    ImmutablePair<ReadPointer,Long> dirty = dirtyPointer();\n    // Get our unique entry id\n    long entryId = this.table.increment(makeRow(GLOBAL_ENTRY_HEADER),\n        GLOBAL_ENTRYID_COUNTER, 1, dirty.getFirst(), dirty.getSecond());\n    log(\"New enqueue got entry id \" + entryId);\n\n    // Get exclusive lock on shard determination\n    byte [] entryWritePointerRow = makeRow(GLOBAL_ENTRY_WRITEPOINTER_HEADER);\n    while (getCounter(entryWritePointerRow, GLOBAL_ENTRYID_WRITEPOINTER_COUNTER,\n        dirty.getFirst()) != (entryId - 1)) {\n      // Wait\n      log(\"Waiting for exclusive lock on shard determination\");\n      quickWait();\n    }\n    log(\"Exclusive lock acquired for entry id \" + entryId);\n\n    // We have an exclusive lock, determine updated shard state\n    ShardMeta shardMeta = null;\n    boolean movedShards = false;\n    byte [] shardMetaRow = makeRow(GLOBAL_SHARDS_HEADER);\n    if (entryId == 1) {\n      // If our entryId is 1 we are first, initialize state\n      shardMeta = new ShardMeta(1, data.length, 1);\n      log(\"First entry, initializing first shard meta\");\n    } else {\n      // Not first, read existing and determine which shard we should be in\n      shardMeta = ShardMeta.fromBytes(this.table.get(shardMetaRow,\n          GLOBAL_SHARD_META, dirty.getFirst()));\n      log(\"Found existing global shard meta: \" + shardMeta.toString());\n      // Check if we need to move to next shard (pass max bytes or max entries)\n      if ((shardMeta.getShardBytes() + data.length > this.maxBytesPerShard &&\n          shardMeta.getShardEntries() > 1) ||\n          shardMeta.getShardEntries() == this.maxEntriesPerShard) {\n        // Move to next shard\n        movedShards = true;\n        shardMeta = new ShardMeta(shardMeta.getShardId() + 1, data.length, 1);\n        log(\"Moving to next shard\");\n      } else {\n        // Update current shard sizing\n        shardMeta = new ShardMeta(shardMeta.getShardId(),\n            shardMeta.getShardBytes() + data.length,\n            shardMeta.getShardEntries() + 1);\n      }\n    }\n\n    // Write the updated shard meta (can do dirty because we have lock)\n    this.table.put(shardMetaRow, GLOBAL_SHARD_META, dirty.getSecond(),\n        shardMeta.getBytes());\n    // Increment entry write pointer (release shard lock)\n    long newWritePointer = this.table.increment(entryWritePointerRow,\n        GLOBAL_ENTRYID_WRITEPOINTER_COUNTER, 1, dirty.getFirst(),\n        dirty.getSecond());\n    log(\"Updated shard meta (\" + shardMeta + \") and incremented write \" +\n        \"pointer to \" + newWritePointer);\n\n    // If we moved shards, insert end-of-shard entry in previously active shard\n    if (movedShards) {\n      this.table.put(makeRow(GLOBAL_DATA_HEADER, shardMeta.getShardId() - 1),\n          makeColumn(entryId, ENTRY_META), cleanWriteVersion,\n          new EntryMeta(EntryState.SHARD_END).getBytes());\n      log(\"Moved shard, inserting end-of-shard marker for: \" + shardMeta);\n    }\n\n    // Insert entry at active shard\n    this.table.put(makeRow(GLOBAL_DATA_HEADER, shardMeta.getShardId()),\n        new byte [][] {\n          makeColumn(entryId, ENTRY_META), makeColumn(entryId, ENTRY_DATA)\n        }, cleanWriteVersion,\n        new byte [][] {\n          new EntryMeta(EntryState.VALID).getBytes(), data\n        });\n\n    // Return success with pointer to entry\n    return new EnqueueResult(EnqueueStatus.SUCCESS,\n        new QueueEntryPointer(entryId, shardMeta.getShardId()));\n  }","id":77996,"modified_method":"@Override\n  public EnqueueResult enqueue(byte[] data, long cleanWriteVersion) {\n    log(\"Enqueueing (data.len=\" + data.length + \", writeVersion=\" +\n        cleanWriteVersion + \")\");\n    // Get a dirty pointer\n    ImmutablePair<ReadPointer,Long> dirty = dirtyPointer();\n    // Get our unique entry id\n    long entryId = this.table.increment(makeRow(GLOBAL_ENTRY_HEADER),\n        GLOBAL_ENTRYID_COUNTER, 1, dirty.getFirst(), dirty.getSecond());\n    log(\"New enqueue got entry id \" + entryId);\n\n    // Get exclusive lock on shard determination\n    byte [] entryWritePointerRow = makeRow(GLOBAL_ENTRY_WRITEPOINTER_HEADER);\n    while (getCounter(entryWritePointerRow, GLOBAL_ENTRYID_WRITEPOINTER_COUNTER,\n        dirty.getFirst()) != (entryId - 1)) {\n      // Wait\n      log(\"Waiting for exclusive lock on shard determination\");\n      quickWait();\n    }\n    log(\"Exclusive lock acquired for entry id \" + entryId);\n\n    // We have an exclusive lock, determine updated shard state\n    ShardMeta shardMeta = null;\n    boolean movedShards = false;\n    byte [] shardMetaRow = makeRow(GLOBAL_SHARDS_HEADER);\n    if (entryId == 1) {\n      // If our entryId is 1 we are first, initialize state\n      shardMeta = new ShardMeta(1, data.length, 1);\n      log(\"First entry, initializing first shard meta\");\n    } else {\n      // Not first, read existing and determine which shard we should be in\n      shardMeta = ShardMeta.fromBytes(this.table.get(shardMetaRow,\n          GLOBAL_SHARD_META, dirty.getFirst()));\n      log(\"Found existing global shard meta: \" + shardMeta.toString());\n      // Check if we need to move to next shard (pass max bytes or max entries)\n      if ((shardMeta.getShardBytes() + data.length > this.maxBytesPerShard &&\n          shardMeta.getShardEntries() > 1) ||\n          shardMeta.getShardEntries() == this.maxEntriesPerShard) {\n        // Move to next shard\n        movedShards = true;\n        shardMeta = new ShardMeta(shardMeta.getShardId() + 1, data.length, 1);\n        log(\"Moving to next shard\");\n      } else {\n        // Update current shard sizing\n        shardMeta = new ShardMeta(shardMeta.getShardId(),\n            shardMeta.getShardBytes() + data.length,\n            shardMeta.getShardEntries() + 1);\n      }\n    }\n\n    // Write the updated shard meta (can do dirty because we have lock)\n    this.table.put(shardMetaRow, GLOBAL_SHARD_META, dirty.getSecond(),\n        shardMeta.getBytes());\n    // Increment entry write pointer (release shard lock)\n    long newWritePointer = this.table.increment(entryWritePointerRow,\n        GLOBAL_ENTRYID_WRITEPOINTER_COUNTER, 1, dirty.getFirst(),\n        dirty.getSecond());\n    log(\"Updated shard meta (\" + shardMeta + \") and incremented write \" +\n        \"pointer to \" + newWritePointer);\n\n    // If we moved shards, insert end-of-shard entry in previously active shard\n    if (movedShards) {\n      this.table.put(makeRow(GLOBAL_DATA_HEADER, shardMeta.getShardId() - 1),\n          makeColumn(entryId, ENTRY_META), cleanWriteVersion,\n          new EntryMeta(EntryState.SHARD_END).getBytes());\n      log(\"Moved shard, inserting end-of-shard marker for: \" + shardMeta);\n    }\n\n    // Insert entry at active shard\n    this.table.put(makeRow(GLOBAL_DATA_HEADER, shardMeta.getShardId()),\n        new byte [][] {\n          makeColumn(entryId, ENTRY_META), makeColumn(entryId, ENTRY_DATA)\n        }, cleanWriteVersion,\n        new byte [][] {\n          new EntryMeta(EntryState.VALID).getBytes(), data\n        });\n\n    // Return success with pointer to entry\n    return new EnqueueResult(EnqueueStatus.SUCCESS,\n        new QueueEntryPointer(queueName, entryId, shardMeta.getShardId()));\n  }","commit_id":"f046870d6975a67cc9bd012ca8d8f6df5c7a776b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return com.google.common.base.Objects.toStringHelper(this)\n        .add(\"key\", key)\n        .add(\"name\", name)\n        .add(\"type\", type)\n        .toString();\n  }","id":77997,"modified_method":"@Override\n  public String toString() {\n    return com.google.common.base.Objects.toStringHelper(this)\n        .add(\"id\", id)\n        .add(\"key\", key)\n        .add(\"name\", name)\n        .add(\"type\", type)\n        .toString();\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public MetricImpl(String key, String name, MetricType type) {\n    this.key = requireNonNull(key);\n    this.name = requireNonNull(name);\n    this.type = requireNonNull(type);\n  }","id":77998,"modified_method":"public MetricImpl(int id, String key, String name, MetricType type) {\n    this.id = id;\n    this.key = requireNonNull(key);\n    this.name = requireNonNull(name);\n    this.type = requireNonNull(type);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void equals_uses_only_key() {\n    MetricImpl expected = new MetricImpl(SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT);\n\n    assertThat(new MetricImpl(SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT)).isEqualTo(expected);\n    assertThat(new MetricImpl(SOME_KEY, SOME_NAME, Metric.MetricType.STRING)).isEqualTo(expected);\n    assertThat(new MetricImpl(\"some other key\", SOME_NAME, Metric.MetricType.FLOAT)).isNotEqualTo(expected);\n  }","id":77999,"modified_method":"@Test\n  public void equals_uses_only_key() {\n    MetricImpl expected = new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT);\n\n    assertThat(new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT)).isEqualTo(expected);\n    assertThat(new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, Metric.MetricType.STRING)).isEqualTo(expected);\n    assertThat(new MetricImpl(SOME_ID, \"some other key\", SOME_NAME, Metric.MetricType.FLOAT)).isNotEqualTo(expected);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"}]